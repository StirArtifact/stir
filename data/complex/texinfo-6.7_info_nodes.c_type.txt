char	O
*	O
info_recent_file_error	*(char)
=	O
NULL	O
;	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
*	O
info_loaded_files	*(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
=	O
NULL	O
;	O
size_t	long
info_loaded_files_index	long
=	O
0	int
;	O
size_t	long
info_loaded_files_slots	long
=	O
0	int
;	O
static	O
void	O
build_tag_table	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
static	O
void	O
get_nodes_of_tags_table	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),long,long,int)))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
buffer_binding	*(struct(*(char),long,long,int))
)	O
;	O
static	O
void	O
get_tags_of_indirect_tags_table	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),long,long,int)),*(struct(*(char),long,long,int)))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
indirect_binding	*(struct(*(char),long,long,int))
,	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
tags_binding	*(struct(*(char),long,long,int))
)	O
;	O
static	O
void	O
free_file_buffer_tags	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
static	O
void	O
free_info_tag	(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(void)
(	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
;	O
void	O
build_tags_and_nodes	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
SEARCH_BINDING	struct(*(char),long,long,int)
binding	*(struct(*(char),long,long,int))
;	O
long	O
position	long
;	O
long	O
tags_table_begin	long
,	O
tags_table_end	long
;	O
free_file_buffer_tags	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
flags	int
&=	O
~	O
N_HasTagsTable	int
;	O
binding	*(struct(*(char),long,long,int))
.	O
buffer	*(struct)
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
;	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
;	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
=	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
-	O
1000	int
;	O
if	O
(	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
<	O
0	int
)	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
=	O
0	int
;	O
binding	*(struct(*(char),long,long,int))
.	O
flags	int
=	O
S_FoldCase	int
;	O
position	long
=	O
find_file_section	(*(struct(*(char),long,long,int)),*(char))->(long)
(	O
&	O
binding	*(struct(*(char),long,long,int))
,	O
TAGS_TABLE_END_LABEL	*(char)
)	O
;	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
goto	O
no_tags_table	O
;	O
if	O
(	O
position	long
==	O
0	int
)	O
goto	O
no_tags_table	O
;	O
else	O
tags_table_end	long
=	O
position	long
-	O
1	int
;	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
=	O
tags_table_end	long
;	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
=	O
0	int
;	O
position	long
=	O
find_file_section	(*(struct(*(char),long,long,int)),*(char))->(long)
(	O
&	O
binding	*(struct(*(char),long,long,int))
,	O
TAGS_TABLE_BEG_LABEL	*(char)
)	O
;	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
goto	O
no_tags_table	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
flags	int
|=	O
N_HasTagsTable	int
;	O
tags_table_begin	long
=	O
position	long
;	O
position	long
+=	O
skip_node_separator	(*(char))->(int)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
+	O
position	long
)	O
;	O
position	long
+=	O
strlen	(*(char))->(long)
(	O
TAGS_TABLE_BEG_LABEL	*(char)
)	O
;	O
position	long
+=	O
strspn	(*(char),*(char))->(long)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
+	O
position	long
,	O
"\r\n"	*(char)
)	O
;	O
if	O
(	O
!	O
looking_at_line	(*(char),*(char))->(int)
(	O
TAGS_TABLE_IS_INDIRECT_LABEL	*(char)
,	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
+	O
position	long
)	O
)	O
{	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
=	O
tags_table_begin	long
;	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
=	O
tags_table_end	long
;	O
get_nodes_of_tags_table	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),long,long,int)))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
&	O
binding	*(struct(*(char),long,long,int))
)	O
;	O
}	O
else	O
{	O
SEARCH_BINDING	struct(*(char),long,long,int)
indirect	struct(*(char),long,long,int)
;	O
indirect	struct(*(char),long,long,int)
.	O
start	int
=	O
tags_table_begin	long
;	O
indirect	struct(*(char),long,long,int)
.	O
end	int
=	O
0	int
;	O
indirect	struct(*(char),long,long,int)
.	O
buffer	*(struct)
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
;	O
indirect	struct(*(char),long,long,int)
.	O
flags	int
=	O
S_FoldCase	int
;	O
position	long
=	O
find_file_section	(*(struct(*(char),long,long,int)),*(char))->(long)
(	O
&	O
indirect	struct(*(char),long,long,int)
,	O
INDIRECT_TABLE_LABEL	*(char)
)	O
;	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
return	O
;	O
position	long
+=	O
skip_node_separator	(*(char))->(int)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
+	O
position	long
)	O
;	O
position	long
+=	O
strlen	(*(char))->(long)
(	O
INDIRECT_TABLE_LABEL	*(char)
)	O
;	O
position	long
+=	O
strspn	(*(char),*(char))->(long)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
+	O
position	long
,	O
"\r\n"	*(char)
)	O
;	O
indirect	struct(*(char),long,long,int)
.	O
start	int
=	O
position	long
;	O
indirect	struct(*(char),long,long,int)
.	O
end	int
=	O
tags_table_begin	long
;	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
=	O
tags_table_begin	long
;	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
=	O
tags_table_end	long
;	O
get_tags_of_indirect_tags_table	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),long,long,int)),*(struct(*(char),long,long,int)))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
&	O
indirect	struct(*(char),long,long,int)
,	O
&	O
binding	*(struct(*(char),long,long,int))
)	O
;	O
}	O
return	O
;	O
no_tags_table	O
:	O
build_tag_table	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
}	O
static	O
void	O
init_file_buffer_tag	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
{	O
if	O
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
flags	int
&	O
N_HasTagsTable	int
)	O
{	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
flags	int
|=	O
N_HasTagsTable	int
;	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
filename	*(char)
=	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
;	O
if	O
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
flags	int
&	O
N_TagsIndirect	int
)	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
flags	int
|=	O
N_TagsIndirect	int
;	O
}	O
}	O
static	O
void	O
build_tag_table	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
long	O
nodestart	long
;	O
size_t	long
tags_index	long
=	O
0	int
;	O
SEARCH_BINDING	struct(*(char),long,long,int)
binding	*(struct(*(char),long,long,int))
;	O
binding	*(struct(*(char),long,long,int))
.	O
buffer	*(struct)
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
;	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
=	O
0	int
;	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
;	O
binding	*(struct(*(char),long,long,int))
.	O
flags	int
=	O
S_FoldCase	int
;	O
while	O
(	O
(	O
nodestart	long
=	O
find_node_separator	(*(struct(*(char),long,long,int)))->(long)
(	O
&	O
binding	*(struct(*(char),long,long,int))
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
int	O
start	int
;	O
char	O
*	O
nodeline	*(char)
;	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
;	O
int	O
anchor	int
=	O
0	int
;	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
=	O
nodestart	long
;	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
+=	O
skip_node_separator	(*(char))->(int)
(	O
binding	*(struct(*(char),long,long,int))
.	O
buffer	*(struct)
+	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
)	O
;	O
nodeline	*(char)
=	O
binding	*(struct(*(char),long,long,int))
.	O
buffer	*(struct)
+	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
;	O
start	int
=	O
string_in_line	(*(char),*(char))->(int)
(	O
INFO_NODE_LABEL	*(char)
,	O
nodeline	*(char)
)	O
;	O
if	O
(	O
start	int
==	O
-	O
1	int
)	O
{	O
start	int
=	O
string_in_line	(*(char),*(char))->(int)
(	O
INFO_REF_LABEL	*(char)
,	O
nodeline	*(char)
)	O
;	O
if	O
(	O
start	int
!=	O
-	O
1	int
)	O
anchor	int
=	O
1	int
;	O
}	O
if	O
(	O
start	int
==	O
-	O
1	int
)	O
continue	O
;	O
start	int
+=	O
skip_whitespace	(*(char))->(int)
(	O
nodeline	*(char)
+	O
start	int
)	O
;	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
info_create_tag	()->(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
(	O
)	O
;	O
read_quoted_string	(*(char),*(char),int,*(*(char)))->(long)
(	O
nodeline	*(char)
+	O
start	int
,	O
",\n\r\t"	*(char)
,	O
0	int
,	O
&	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
)	O
;	O
if	O
(	O
!	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
||	O
!	O
*	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
;	O
continue	O
;	O
}	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart	long
=	O
nodestart	long
;	O
init_file_buffer_tag	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
;	O
if	O
(	O
anchor	int
)	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
=	O
0	int
;	O
else	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
=	O
-	O
1	int
;	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
filename	*(char)
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
;	O
add_pointer_to_array	O
(	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
,	O
tags_index	long
,	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
,	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags_slots	long
,	O
100	int
)	O
;	O
}	O
}	O
static	O
void	O
get_nodes_of_tags_table	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),long,long,int)))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
buffer_binding	*(struct(*(char),long,long,int))
)	O
{	O
int	O
name_offset	int
;	O
SEARCH_BINDING	struct(*(char),long,long,int)
s	*(char)
;	O
long	O
position	long
;	O
size_t	long
tags_index	long
=	O
0	int
;	O
s	*(char)
=	O
*	O
buffer_binding	*(struct(*(char),long,long,int))
;	O
position	long
=	O
buffer_binding	*(struct(*(char),long,long,int))
->	O
start	int
;	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
return	O
;	O
s	*(char)
.	O
start	int
=	O
position	long
;	O
s	*(char)
.	O
start	int
+=	O
skip_node_separator	(*(char))->(int)
(	O
s	*(char)
.	O
buffer	*(struct)
+	O
s	*(char)
.	O
start	int
)	O
;	O
s	*(char)
.	O
start	int
+=	O
strlen	(*(char))->(long)
(	O
TAGS_TABLE_BEG_LABEL	*(char)
)	O
;	O
while	O
(	O
search_forward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
"\n"	*(char)
,	O
&	O
s	*(char)
,	O
&	O
position	long
)	O
==	O
search_success	int
)	O
{	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
;	O
char	O
*	O
nodedef	*(char)
;	O
unsigned	O
p	*(void)
;	O
int	O
anchor	int
=	O
0	int
;	O
s	*(char)
.	O
start	int
=	O
position	long
;	O
s	*(char)
.	O
start	int
++	O
;	O
if	O
(	O
!	O
tags_index	long
&&	O
looking_at	(*(char),*(struct(*(char),long,long,int)))->(int)
(	O
TAGS_TABLE_IS_INDIRECT_LABEL	*(char)
,	O
&	O
s	*(char)
)	O
)	O
continue	O
;	O
name_offset	int
=	O
string_in_line	(*(char),*(char))->(int)
(	O
INFO_NODE_LABEL	*(char)
,	O
s	*(char)
.	O
buffer	*(struct)
+	O
s	*(char)
.	O
start	int
)	O
;	O
if	O
(	O
name_offset	int
==	O
-	O
1	int
)	O
{	O
name_offset	int
=	O
string_in_line	(*(char),*(char))->(int)
(	O
INFO_REF_LABEL	*(char)
,	O
s	*(char)
.	O
buffer	*(struct)
+	O
s	*(char)
.	O
start	int
)	O
;	O
if	O
(	O
name_offset	int
!=	O
-	O
1	int
)	O
anchor	int
=	O
1	int
;	O
}	O
if	O
(	O
name_offset	int
==	O
-	O
1	int
)	O
break	O
;	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
info_create_tag	()->(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
(	O
)	O
;	O
init_file_buffer_tag	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
;	O
s	*(char)
.	O
start	int
+=	O
name_offset	int
;	O
nodedef	*(char)
=	O
s	*(char)
.	O
buffer	*(struct)
+	O
s	*(char)
.	O
start	int
;	O
nodedef	*(char)
+=	O
skip_whitespace	(*(char))->(int)
(	O
nodedef	*(char)
)	O
;	O
for	O
(	O
p	*(void)
=	O
0	int
;	O
nodedef	*(char)
[	O
p	*(void)
]	O
&&	O
nodedef	*(char)
[	O
p	*(void)
]	O
!=	O
INFO_TAGSEP	char
;	O
p	*(void)
++	O
)	O
;	O
if	O
(	O
nodedef	*(char)
[	O
p	*(void)
]	O
!=	O
INFO_TAGSEP	char
)	O
continue	O
;	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
p	*(void)
+	O
1	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
,	O
nodedef	*(char)
,	O
p	*(void)
)	O
;	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
[	O
p	*(void)
]	O
=	O
0	int
;	O
p	*(void)
++	O
;	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart	long
=	O
atol	(*(char))->(long)
(	O
nodedef	*(char)
+	O
p	*(void)
)	O
;	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
=	O
anchor	int
?	O
0	int
:	O
-	O
1	int
;	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
filename	*(char)
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
;	O
add_pointer_to_array	O
(	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
,	O
tags_index	long
,	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
,	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags_slots	long
,	O
100	int
)	O
;	O
}	O
}	O
static	O
void	O
get_tags_of_indirect_tags_table	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),long,long,int)),*(struct(*(char),long,long,int)))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
indirect_binding	*(struct(*(char),long,long,int))
,	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
tags_binding	*(struct(*(char),long,long,int))
)	O
{	O
int	O
i	int
;	O
typedef	O
struct	O
{	O
char	O
*	O
filename	*(char)
;	O
long	O
first_byte	long
;	O
}	O
SUBFILE	struct(*(char),long)
;	O
SUBFILE	struct(*(char),long)
*	O
*	O
subfiles	*(*(char))
=	O
NULL	O
;	O
size_t	long
subfiles_index	long
=	O
0	int
,	O
subfiles_slots	long
=	O
0	int
;	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
flags	int
|=	O
N_TagsIndirect	int
;	O
get_nodes_of_tags_table	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),long,long,int)))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
tags_binding	*(struct(*(char),long,long,int))
)	O
;	O
if	O
(	O
!	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
return	O
;	O
{	O
char	O
*	O
start	int
,	O
*	O
end	int
,	O
*	O
line	*(char)
;	O
SUBFILE	struct(*(char),long)
*	O
subfile	*(char)
;	O
start	int
=	O
indirect_binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
+	O
indirect_binding	*(struct(*(char),long,long,int))
->	O
start	int
;	O
end	int
=	O
indirect_binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
+	O
indirect_binding	*(struct(*(char),long,long,int))
->	O
end	int
;	O
line	*(char)
=	O
start	int
;	O
while	O
(	O
line	*(char)
<	O
end	int
)	O
{	O
int	O
colon	int
;	O
colon	int
=	O
string_in_line	(*(char),*(char))->(int)
(	O
":"	*(char)
,	O
line	*(char)
)	O
;	O
if	O
(	O
colon	int
==	O
-	O
1	int
)	O
break	O
;	O
subfile	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
SUBFILE	struct(*(char),long)
)	O
)	O
;	O
subfile	*(char)
->	O
filename	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
colon	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
subfile	*(char)
->	O
filename	*(char)
,	O
line	*(char)
,	O
colon	int
-	O
1	int
)	O
;	O
subfile	*(char)
->	O
filename	*(char)
[	O
colon	int
-	O
1	int
]	O
=	O
0	int
;	O
subfile	*(char)
->	O
first_byte	long
=	O
(	O
long	O
)	O
atol	(*(char))->(long)
(	O
line	*(char)
+	O
colon	int
)	O
;	O
add_pointer_to_array	O
(	O
subfile	*(char)
,	O
subfiles_index	long
,	O
subfiles	*(*(char))
,	O
subfiles_slots	long
,	O
10	int
)	O
;	O
while	O
(	O
*	O
line	*(char)
++	O
!=	O
'\n'	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
subfiles	*(*(char))
)	O
{	O
free_file_buffer_tags	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
return	O
;	O
}	O
else	O
{	O
int	O
tags_index	long
;	O
long	O
header_length	long
;	O
SEARCH_BINDING	struct(*(char),long,long,int)
binding	*(struct(*(char),long,long,int))
;	O
binding	*(struct(*(char),long,long,int))
.	O
buffer	*(struct)
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
;	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
=	O
0	int
;	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
;	O
binding	*(struct(*(char),long,long,int))
.	O
flags	int
=	O
S_FoldCase	int
;	O
header_length	long
=	O
find_node_separator	(*(struct(*(char),long,long,int)))->(long)
(	O
&	O
binding	*(struct(*(char),long,long,int))
)	O
;	O
if	O
(	O
header_length	long
==	O
-	O
1	int
)	O
header_length	long
=	O
0	int
;	O
{	O
char	O
*	O
containing_dir	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
)	O
;	O
char	O
*	O
temp	*(char)
=	O
filename_non_directory	(*(char))->(*(char))
(	O
containing_dir	*(char)
)	O
;	O
int	O
len_containing_dir	int
;	O
if	O
(	O
temp	*(char)
>	O
containing_dir	*(char)
)	O
{	O
if	O
(	O
HAVE_DRIVE	O
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
)	O
&&	O
temp	*(char)
==	O
containing_dir	*(char)
+	O
2	int
)	O
{	O
*	O
temp	*(char)
=	O
'.'	O
;	O
temp	*(char)
+=	O
2	int
;	O
}	O
temp	*(char)
[	O
-	O
1	int
]	O
=	O
0	int
;	O
}	O
len_containing_dir	int
=	O
strlen	(*(char))->(long)
(	O
containing_dir	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
subfiles	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
(	O
1	int
+	O
i	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
subfiles	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
fullpath	*(char)
;	O
fullpath	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
2	int
+	O
strlen	(*(char))->(long)
(	O
subfiles	*(*(char))
[	O
i	int
]	O
->	O
filename	*(char)
)	O
+	O
len_containing_dir	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
fullpath	*(char)
,	O
"%s/%s"	*(char)
,	O
containing_dir	*(char)
,	O
subfiles	*(*(char))
[	O
i	int
]	O
->	O
filename	*(char)
)	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
[	O
i	int
]	O
=	O
fullpath	*(char)
;	O
}	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
[	O
i	int
]	O
=	O
NULL	O
;	O
free	(*(void))->(void)
(	O
containing_dir	*(char)
)	O
;	O
}	O
for	O
(	O
tags_index	long
=	O
0	int
;	O
(	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
[	O
tags_index	long
]	O
)	O
;	O
tags_index	long
++	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
subfiles	*(*(char))
[	O
i	int
]	O
&&	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart	long
>=	O
subfiles	*(*(char))
[	O
i	int
]	O
->	O
first_byte	long
;	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
i	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
subfiles	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
free	(*(void))->(void)
(	O
subfiles	*(*(char))
[	O
i	int
]	O
->	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
subfiles	*(*(char))
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
=	O
NULL	O
;	O
free_file_buffer_tags	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
return	O
;	O
}	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
filename	*(char)
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
[	O
i	int
-	O
1	int
]	O
;	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart	long
-=	O
subfiles	*(*(char))
[	O
i	int
-	O
1	int
]	O
->	O
first_byte	long
;	O
entry	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart	long
+=	O
header_length	long
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
subfiles	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
free	(*(void))->(void)
(	O
subfiles	*(*(char))
[	O
i	int
]	O
->	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
subfiles	*(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
subfiles	*(*(char))
)	O
;	O
}	O
static	O
void	O
free_file_buffer_tags	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
int	O
i	int
;	O
if	O
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
{	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
free_info_tag	(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(void)
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
;	O
free	(*(void))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
=	O
NULL	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags_slots	long
=	O
0	int
;	O
}	O
if	O
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
free	(*(void))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
)	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
free_info_tag	(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(void)
(	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
{	O
free	(*(void))->(void)
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
;	O
}	O
static	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
info_load_file	(*(char),int)->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
char	O
*	O
fullpath	*(char)
,	O
int	O
get_tags	int
)	O
;	O
static	O
void	O
get_file_character_encoding	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
static	O
void	O
forget_info_file	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
static	O
void	O
info_reload_file_buffer_contents	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
check_loaded_file	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
char	O
*	O
filename	*(char)
)	O
{	O
int	O
is_fullpath	int
,	O
i	int
;	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
is_fullpath	int
=	O
IS_ABSOLUTE	O
(	O
filename	*(char)
)	O
||	O
filename	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
IS_SLASH	O
(	O
filename	*(char)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
info_loaded_files	*(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_loaded_files	*(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
(	O
FILENAME_CMP	O
(	O
filename	*(char)
,	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
)	O
==	O
0	int
)	O
||	O
(	O
!	O
is_fullpath	int
&&	O
(	O
FILENAME_CMP	O
(	O
filename	*(char)
,	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filename	*(char)
)	O
==	O
0	int
)	O
)	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
new_info	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
*	O
old_info	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
old_info	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
=	O
&	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
,	O
&	O
new_info	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
-	O
1	int
||	O
new_info	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
!=	O
old_info	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
||	O
new_info	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
!=	O
old_info	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mtime	O
)	O
{	O
forget_info_file	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
)	O
{	O
info_reload_file_buffer_contents	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
if	O
(	O
!	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
)	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
build_tags_and_nodes	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
return	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
}	O
}	O
return	O
0	int
;	O
}	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
info_find_file	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
char	O
*	O
filename	*(char)
)	O
{	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
char	O
*	O
fullpath	*(char)
;	O
int	O
is_fullpath	int
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
check_loaded_file	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
filename	*(char)
)	O
;	O
if	O
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
return	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
is_fullpath	int
=	O
IS_ABSOLUTE	O
(	O
filename	*(char)
)	O
||	O
filename	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
IS_SLASH	O
(	O
filename	*(char)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
is_fullpath	int
)	O
fullpath	*(char)
=	O
info_find_fullpath	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
filename	*(char)
,	O
0	int
)	O
;	O
else	O
fullpath	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
filename	*(char)
)	O
;	O
if	O
(	O
!	O
fullpath	*(char)
)	O
return	O
NULL	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_load_file	(*(char),int)->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
fullpath	*(char)
,	O
0	int
)	O
;	O
free	(*(void))->(void)
(	O
fullpath	*(char)
)	O
;	O
return	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
}	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
info_find_subfile	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
char	O
*	O
fullpath	*(char)
)	O
{	O
char	O
*	O
with_extension	*(char)
=	O
0	int
;	O
int	O
i	int
;	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
0	int
;	O
int	O
fullpath_len	int
=	O
strlen	(*(char))->(long)
(	O
fullpath	*(char)
)	O
;	O
if	O
(	O
info_loaded_files	*(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_loaded_files	*(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
,	O
fullpath	*(char)
,	O
fullpath_len	int
)	O
&&	O
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
[	O
fullpath_len	int
]	O
==	O
'\0'	O
||	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
[	O
fullpath_len	int
]	O
==	O
'.'	O
)	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
new_info	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
*	O
old_info	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
old_info	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
=	O
&	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
,	O
&	O
new_info	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
-	O
1	int
||	O
new_info	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
!=	O
old_info	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
||	O
new_info	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
!=	O
old_info	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mtime	O
)	O
{	O
forget_info_file	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
break	O
;	O
}	O
return	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
}	O
}	O
with_extension	*(char)
=	O
info_find_fullpath	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
fullpath	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
with_extension	*(char)
)	O
{	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_load_file	(*(char),int)->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
with_extension	*(char)
,	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
with_extension	*(char)
)	O
;	O
}	O
return	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
}	O
static	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
info_load_file	(*(char),int)->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
char	O
*	O
fullpath	*(char)
,	O
int	O
is_subfile	int
)	O
{	O
char	O
*	O
contents	*(char)
;	O
size_t	long
filesize	long
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
int	O
compressed	int
;	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
NULL	O
;	O
contents	*(char)
=	O
filesys_read_info_file	(*(char),*(long),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(int))->(*(char))
(	O
fullpath	*(char)
,	O
&	O
filesize	long
,	O
&	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
&	O
compressed	int
)	O
;	O
if	O
(	O
!	O
contents	*(char)
)	O
return	O
NULL	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
make_file_buffer	()->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
)	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
fullpath	*(char)
)	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filename	*(char)
=	O
filename_non_directory	(*(char))->(*(char))
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
)	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filename	*(char)
)	O
;	O
{	O
char	O
*	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filename	*(char)
,	O
'.'	O
)	O
;	O
if	O
(	O
p	*(void)
)	O
*	O
p	*(void)
=	O
'\0'	O
;	O
}	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
=	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
=	O
filesize	long
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
=	O
contents	*(char)
;	O
if	O
(	O
compressed	int
)	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
flags	int
|=	O
N_IsCompressed	int
;	O
get_file_character_encoding	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
if	O
(	O
!	O
is_subfile	int
)	O
{	O
build_tags_and_nodes	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
if	O
(	O
!	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
{	O
free	(*(void))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
encoding	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
flags	int
|=	O
N_Subfile	int
;	O
if	O
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
add_pointer_to_array	O
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
info_loaded_files_index	long
,	O
info_loaded_files	*(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
,	O
info_loaded_files_slots	long
,	O
10	int
)	O
;	O
return	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
}	O
static	O
void	O
get_file_character_encoding	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
SEARCH_BINDING	struct(*(char),long,long,int)
binding	*(struct(*(char),long,long,int))
;	O
long	O
position	long
;	O
long	O
int	O
enc_start	long
,	O
enc_len	long
;	O
char	O
*	O
enc_string	*(char)
;	O
binding	*(struct(*(char),long,long,int))
.	O
buffer	*(struct)
=	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
;	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
=	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
;	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
=	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
-	O
1000	int
;	O
if	O
(	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
<	O
0	int
)	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
=	O
0	int
;	O
binding	*(struct(*(char),long,long,int))
.	O
flags	int
=	O
S_FoldCase	int
;	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
encoding	*(char)
=	O
0	int
;	O
if	O
(	O
search_backward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
LOCAL_VARIABLES_LABEL	*(char)
,	O
&	O
binding	*(struct(*(char),long,long,int))
,	O
&	O
position	long
)	O
!=	O
search_success	int
)	O
return	O
;	O
binding	*(struct(*(char),long,long,int))
.	O
start	int
=	O
position	long
;	O
binding	*(struct(*(char),long,long,int))
.	O
end	int
=	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
;	O
if	O
(	O
search_forward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
CHARACTER_ENCODING_LABEL	*(char)
,	O
&	O
binding	*(struct(*(char),long,long,int))
,	O
&	O
enc_start	long
)	O
!=	O
search_success	int
)	O
return	O
;	O
enc_start	long
+=	O
strlen	(*(char))->(long)
(	O
CHARACTER_ENCODING_LABEL	*(char)
)	O
;	O
enc_start	long
+=	O
skip_whitespace	(*(char))->(int)
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
+	O
enc_start	long
)	O
;	O
enc_len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
+	O
enc_start	long
,	O
"\r\n"	*(char)
)	O
;	O
enc_string	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
enc_len	long
+	O
1	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
enc_string	*(char)
,	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
+	O
enc_start	long
,	O
enc_len	long
)	O
;	O
enc_string	*(char)
[	O
enc_len	long
]	O
=	O
'\0'	O
;	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
encoding	*(char)
=	O
enc_string	*(char)
;	O
}	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
make_file_buffer	()->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
void	O
)	O
{	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
)	O
)	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filename	*(char)
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
=	O
NULL	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
=	O
NULL	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
=	O
NULL	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
subfiles	*(*(char))
=	O
NULL	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags_slots	long
=	O
0	int
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
flags	int
=	O
0	int
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
encoding	*(char)
=	O
0	int
;	O
return	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
}	O
static	O
void	O
forget_info_file	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
flags	int
|=	O
N_Gone	int
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filename	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
=	O
""	*(char)
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
,	O
0	int
,	O
sizeof	O
(	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
;	O
}	O
static	O
void	O
info_reload_file_buffer_contents	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
int	O
is_compressed	*(int)
;	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
flags	int
&=	O
~	O
N_IsCompressed	int
;	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
=	O
filesys_read_info_file	(*(char),*(long),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))),*(int))->(*(char))
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
,	O
&	O
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
)	O
,	O
&	O
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
,	O
&	O
is_compressed	*(int)
)	O
;	O
if	O
(	O
is_compressed	*(int)
)	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
flags	int
|=	O
N_IsCompressed	int
;	O
}	O
static	O
long	O
get_node_length	(*(struct(*(char),long,long,int)))->(long)
(	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
binding	*(struct(*(char),long,long,int))
)	O
;	O
static	O
void	O
node_set_body_start	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
static	O
int	O
adjust_nodestart	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(int)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
;	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
info_create_tag	()->(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
(	O
void	O
)	O
{	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
t	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
t	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
,	O
0	int
,	O
sizeof	O
(	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
)	O
;	O
t	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
filename	*(char)
=	O
0	int
;	O
t	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
=	O
0	int
;	O
t	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart	long
=	O
-	O
1	int
;	O
t	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart_adjusted	long
=	O
-	O
1	int
;	O
t	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
=	O
-	O
1	int
;	O
return	O
t	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
;	O
}	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
info_create_node	()->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
void	O
)	O
{	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
n	long
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
)	O
)	O
;	O
n	long
->	O
fullpath	*(char)
=	O
0	int
;	O
n	long
->	O
subfile	*(char)
=	O
0	int
;	O
n	long
->	O
nodename	*(char)
=	O
0	int
;	O
n	long
->	O
contents	*(char)
=	O
0	int
;	O
n	long
->	O
nodelen	long
=	O
-	O
1	int
;	O
n	long
->	O
display_pos	long
=	O
0	int
;	O
n	long
->	O
body_start	long
=	O
0	int
;	O
n	long
->	O
flags	int
=	O
0	int
;	O
n	long
->	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
0	int
;	O
n	long
->	O
up	*(char)
=	O
0	int
;	O
n	long
->	O
prev	*(char)
=	O
0	int
;	O
n	long
->	O
next	*(char)
=	O
0	int
;	O
return	O
n	long
;	O
}	O
static	O
long	O
get_node_length	(*(struct(*(char),long,long,int)))->(long)
(	O
SEARCH_BINDING	struct(*(char),long,long,int)
*	O
binding	*(struct(*(char),long,long,int))
)	O
{	O
int	O
i	int
;	O
char	O
*	O
body	*(char)
;	O
for	O
(	O
i	int
=	O
binding	*(struct(*(char),long,long,int))
->	O
start	int
,	O
body	*(char)
=	O
binding	*(struct(*(char),long,long,int))
->	O
buffer	*(struct)
;	O
i	int
<	O
binding	*(struct(*(char),long,long,int))
->	O
end	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
body	*(char)
[	O
i	int
]	O
==	O
INFO_FF	char
||	O
body	*(char)
[	O
i	int
]	O
==	O
INFO_COOKIE	char
)	O
break	O
;	O
}	O
return	O
i	int
-	O
binding	*(struct(*(char),long,long,int))
->	O
start	int
;	O
}	O
int	O
follow_strategy	int
;	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
info_get_node_with_defaults	(*(char),*(char),*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
char	O
*	O
filename_in	*(char)
,	O
char	O
*	O
nodename_in	*(char)
,	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
defaults	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
0	int
;	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
NULL	O
;	O
char	O
*	O
filename	*(char)
=	O
0	int
,	O
*	O
nodename	*(char)
=	O
0	int
;	O
info_recent_file_error	*(char)
=	O
NULL	O
;	O
filename	*(char)
=	O
filename_in	*(char)
;	O
if	O
(	O
filename_in	*(char)
)	O
{	O
filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
filename_in	*(char)
)	O
;	O
if	O
(	O
follow_strategy	int
==	O
FOLLOW_REMAIN	int
&&	O
defaults	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
&&	O
defaults	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
&&	O
filename_in	*(char)
)	O
{	O
char	O
*	O
file_in_same_dir	*(char)
;	O
char	O
saved_char	char
,	O
*	O
p	*(void)
;	O
p	*(void)
=	O
defaults	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
+	O
strlen	(*(char))->(long)
(	O
defaults	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
)	O
;	O
while	O
(	O
p	*(void)
>	O
defaults	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
&&	O
!	O
IS_SLASH	O
(	O
*	O
p	*(void)
)	O
)	O
p	*(void)
--	O
;	O
if	O
(	O
p	*(void)
>	O
defaults	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
)	O
{	O
saved_char	char
=	O
*	O
p	*(void)
;	O
*	O
p	*(void)
=	O
0	int
;	O
file_in_same_dir	*(char)
=	O
info_add_extension	(*(char),*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(char))
(	O
defaults	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
,	O
filename	*(char)
,	O
0	int
)	O
;	O
*	O
p	*(void)
=	O
saved_char	char
;	O
if	O
(	O
file_in_same_dir	*(char)
)	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_find_file	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
file_in_same_dir	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
file_in_same_dir	*(char)
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
defaults	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
defaults	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
)	O
;	O
else	O
filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"dir"	*(char)
)	O
;	O
}	O
if	O
(	O
nodename_in	*(char)
&&	O
*	O
nodename_in	*(char)
)	O
nodename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
nodename_in	*(char)
)	O
;	O
else	O
nodename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"Top"	*(char)
)	O
;	O
if	O
(	O
is_dir_name	(*(char))->(int)
(	O
filename	*(char)
)	O
)	O
{	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
get_dir_node	()->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
)	O
;	O
goto	O
cleanup_and_exit	O
;	O
}	O
if	O
(	O
mbscasecmp	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
MANPAGE_FILE_BUFFER_NAME	*(char)
)	O
==	O
0	int
)	O
{	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
get_manpage_node	(*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
nodename	*(char)
)	O
;	O
goto	O
cleanup_and_exit	O
;	O
}	O
if	O
(	O
!	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
info_find_file	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
filename	*(char)
)	O
;	O
if	O
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
{	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_get_node_of_file_buffer	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
nodename	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
&&	O
(	O
nodename	*(char)
&&	O
mbscasecmp	(*(char),*(char))->(int)
(	O
nodename	*(char)
,	O
"Top"	*(char)
)	O
==	O
0	int
)	O
)	O
{	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_get_node_of_file_buffer	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
"Top"	*(char)
)	O
;	O
if	O
(	O
!	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_get_node_of_file_buffer	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
"top"	*(char)
)	O
;	O
if	O
(	O
!	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_get_node_of_file_buffer	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
"TOP"	*(char)
)	O
;	O
}	O
cleanup_and_exit	O
:	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
nodename	*(char)
)	O
;	O
return	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
}	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
info_get_node	(*(char),*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
char	O
*	O
filename_in	*(char)
,	O
char	O
*	O
nodename_in	*(char)
)	O
{	O
return	O
info_get_node_with_defaults	(*(char),*(char),*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
filename_in	*(char)
,	O
nodename_in	*(char)
,	O
0	int
)	O
;	O
}	O
static	O
void	O
node_set_body_start	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
int	O
n	long
=	O
skip_node_separator	(*(char))->(int)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
body_start	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
+	O
n	long
,	O
"\n"	*(char)
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
body_start	long
+=	O
n	long
;	O
}	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
info_get_node_of_file_buffer	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
char	O
*	O
nodename	*(char)
)	O
{	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
NULL	O
;	O
if	O
(	O
!	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
)	O
info_reload_file_buffer_contents	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
nodename	*(char)
,	O
"*"	*(char)
)	O
==	O
0	int
)	O
{	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_create_node	()->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"*"	*(char)
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
body_start	long
=	O
0	int
;	O
}	O
else	O
{	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
;	O
int	O
i	int
;	O
if	O
(	O
!	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
nodename	*(char)
,	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
)	O
==	O
0	int
)	O
{	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_node_of_tag	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
&	O
file_buffer	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
return	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
}	O
static	O
int	O
adjust_nodestart	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(int)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
long	O
position	long
=	O
-	O
1	int
;	O
SEARCH_BINDING	struct(*(char),long,long,int)
s	*(char)
;	O
s	*(char)
.	O
buffer	*(struct)
=	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
;	O
s	*(char)
.	O
start	int
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodestart	long
;	O
s	*(char)
.	O
end	int
=	O
s	*(char)
.	O
start	int
+	O
1	int
;	O
if	O
(	O
s	*(char)
.	O
start	int
>=	O
0	int
&&	O
s	*(char)
.	O
start	int
<	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
)	O
{	O
position	long
=	O
find_node_in_binding	(*(char),*(struct(*(char),long,long,int)))->(long)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
,	O
&	O
s	*(char)
)	O
;	O
}	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
strict_node_location_p	int
)	O
return	O
0	int
;	O
s	*(char)
.	O
start	int
-=	O
DEFAULT_INFO_FUDGE	int
;	O
s	*(char)
.	O
end	int
+=	O
DEFAULT_INFO_FUDGE	int
;	O
if	O
(	O
s	*(char)
.	O
start	int
<	O
0	int
)	O
s	*(char)
.	O
start	int
=	O
0	int
;	O
else	O
if	O
(	O
s	*(char)
.	O
start	int
>	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
)	O
s	*(char)
.	O
start	int
=	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
;	O
if	O
(	O
s	*(char)
.	O
end	int
>	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
)	O
s	*(char)
.	O
end	int
=	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
filesize	long
;	O
position	long
=	O
find_node_in_binding	(*(char),*(struct(*(char),long,long,int)))->(long)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
,	O
&	O
s	*(char)
)	O
;	O
if	O
(	O
position	long
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
&	O
N_HasTagsTable	int
)	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
|=	O
N_UpdateTags	int
;	O
}	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodestart_adjusted	long
=	O
s	*(char)
.	O
buffer	*(struct)
+	O
position	long
-	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
contents	*(char)
;	O
return	O
1	int
;	O
}	O
static	O
int	O
find_node_from_tag	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(int)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
parent	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
{	O
int	O
success	int
;	O
if	O
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart_adjusted	long
!=	O
-	O
1	int
)	O
success	int
=	O
1	int
;	O
else	O
success	int
=	O
adjust_nodestart	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(int)
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
;	O
if	O
(	O
success	int
)	O
return	O
success	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
set_tag_nodelen	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(void)
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
subfile	*(char)
,	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
{	O
SEARCH_BINDING	struct(*(char),long,long,int)
node_body	struct(*(char),long,long,int)
;	O
node_body	struct(*(char),long,long,int)
.	O
buffer	*(struct)
=	O
subfile	*(char)
->	O
contents	*(char)
;	O
node_body	struct(*(char),long,long,int)
.	O
start	int
=	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart_adjusted	long
;	O
node_body	struct(*(char),long,long,int)
.	O
end	int
=	O
subfile	*(char)
->	O
filesize	long
;	O
node_body	struct(*(char),long,long,int)
.	O
flags	int
=	O
0	int
;	O
node_body	struct(*(char),long,long,int)
.	O
start	int
+=	O
skip_node_separator	(*(char))->(int)
(	O
node_body	struct(*(char),long,long,int)
.	O
buffer	*(struct)
+	O
node_body	struct(*(char),long,long,int)
.	O
start	int
)	O
;	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
=	O
get_node_length	(*(struct(*(char),long,long,int)))->(long)
(	O
&	O
node_body	struct(*(char),long,long,int)
)	O
;	O
}	O
static	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
info_node_of_tag_ext	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),int)->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
*	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
,	O
int	O
fast	int
)	O
{	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
*	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
;	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
int	O
is_anchor	int
;	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
anchor_tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
;	O
int	O
node_pos	int
,	O
anchor_pos	int
;	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
parent	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
subfile	*(char)
;	O
if	O
(	O
!	O
FILENAME_CMP	O
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
,	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
filename	*(char)
)	O
)	O
parent	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
subfile	*(char)
=	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
else	O
{	O
parent	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
=	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
;	O
subfile	*(char)
=	O
info_find_subfile	(*(char))->(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
filename	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
subfile	*(char)
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
subfile	*(char)
->	O
contents	*(char)
)	O
{	O
info_reload_file_buffer_contents	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))))->(void)
(	O
subfile	*(char)
)	O
;	O
if	O
(	O
!	O
subfile	*(char)
->	O
contents	*(char)
)	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart	long
>=	O
0	int
&&	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart	long
<	O
subfile	*(char)
->	O
filesize	long
)	O
)	O
return	O
NULL	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
0	int
;	O
is_anchor	int
=	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
==	O
0	int
;	O
if	O
(	O
is_anchor	int
)	O
{	O
anchor_pos	int
=	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
-	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
;	O
for	O
(	O
node_pos	int
=	O
anchor_pos	int
-	O
1	int
;	O
node_pos	int
>=	O
0	int
&&	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
[	O
node_pos	int
]	O
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
==	O
0	int
;	O
node_pos	int
--	O
)	O
;	O
if	O
(	O
node_pos	int
<	O
0	int
)	O
return	O
NULL	O
;	O
anchor_tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
;	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
[	O
node_pos	int
]	O
;	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
=	O
&	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
tags	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
[	O
node_pos	int
]	O
;	O
}	O
if	O
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
find_node_from_tag	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(int)
(	O
parent	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
subfile	*(char)
,	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
)	O
return	O
NULL	O
;	O
set_tag_nodelen	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))->(void)
(	O
subfile	*(char)
,	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
)	O
;	O
}	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
0	int
,	O
sizeof	O
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
)	O
)	O
;	O
if	O
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
)	O
{	O
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
;	O
if	O
(	O
!	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
)	O
{	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
=	O
subfile	*(char)
->	O
contents	*(char)
+	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart_adjusted	long
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
+=	O
skip_node_separator	(*(char))->(int)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
=	O
subfile	*(char)
->	O
contents	*(char)
+	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart_adjusted	long
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
+=	O
skip_node_separator	(*(char))->(int)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
=	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
nodelen	long
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
=	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodename	*(char)
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
=	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
flags	int
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
=	O
parent	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
->	O
fullpath	*(char)
;	O
if	O
(	O
parent	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
!=	O
subfile	*(char)
)	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
subfile	*(char)
=	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
filename	*(char)
;	O
if	O
(	O
fast	int
)	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
|=	O
N_Simple	int
;	O
else	O
{	O
scan_node_contents	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)),*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))))->(void)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
parent	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
;	O
node_set_body_start	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(void)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
=	O
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
if	O
(	O
!	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
&	O
N_WasRewritten	int
)	O
)	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
cache	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
.	O
contents	*(char)
=	O
0	int
;	O
}	O
}	O
if	O
(	O
subfile	*(char)
->	O
flags	int
&	O
N_IsCompressed	int
)	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
|=	O
N_IsCompressed	int
;	O
if	O
(	O
is_anchor	int
)	O
{	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
display_pos	long
=	O
anchor_tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart_adjusted	long
-	O
(	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart_adjusted	long
+	O
skip_node_separator	(*(char))->(int)
(	O
subfile	*(char)
->	O
contents	*(char)
+	O
tag	*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
->	O
nodestart_adjusted	long
)	O
)	O
;	O
if	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
display_pos	long
>=	O
(	O
unsigned	O
long	O
)	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
)	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
display_pos	long
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
-	O
1	int
;	O
else	O
if	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
display_pos	long
<	O
0	int
)	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
display_pos	long
=	O
0	int
;	O
}	O
return	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
}	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
info_node_of_tag	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
*	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
{	O
return	O
info_node_of_tag_ext	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),int)->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
,	O
0	int
)	O
;	O
}	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
info_node_of_tag_fast	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
FILE_BUFFER	struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),long,int,*(char))
*	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
TAG	struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
*	O
*	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
)	O
{	O
return	O
info_node_of_tag_ext	(*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct`)),long,int,*(char))),*(*(struct(*(char),*(char),long,long,int,struct(*`,*`,*`,*`,long,long,long,int,*`,*`,*`,*`,int)))),int)->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
fb	*(struct(*(char),*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(char),long,*(*(char)),*(*(struct(*`,*`,long,long,int,struct`))),long,int,*(char)))
,	O
tag_ptr	*(*(struct(*(char),*(char),long,long,int,struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*`),*(char),*(char),*(char),int))))
,	O
1	int
)	O
;	O
}	O
