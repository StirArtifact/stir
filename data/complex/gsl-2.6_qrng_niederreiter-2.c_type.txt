static	O
size_t	long
nied2_state_size	(int)->(long)
(	O
unsigned	O
int	O
dimension	int
)	O
;	O
static	O
int	O
nied2_init	(*(void),int)->(int)
(	O
void	O
*	O
state	*(int)
,	O
unsigned	O
int	O
dimension	int
)	O
;	O
static	O
int	O
nied2_get	(*(void),int,*(double))->(int)
(	O
void	O
*	O
state	*(int)
,	O
unsigned	O
int	O
dimension	int
,	O
double	O
*	O
v	*(double)
)	O
;	O
static	O
const	O
gsl_qrng_type	struct(*(char),int,*((int)->(long)),*((*(void),int)->(int)),*((*(void),int,array(double))->(int)))
nied2_type	struct(*(char),int,*((int)->(long)),*((*(void),int)->(int)),*((*(void),int,array(double))->(int)))
=	O
{	O
"niederreiter-base-2"	*(char)
,	O
NIED2_MAX_DIMENSION	int
,	O
nied2_state_size	(int)->(long)
,	O
nied2_init	(*(void),int)->(int)
,	O
nied2_get	(*(void),int,*(double))->(int)
}	O
;	O
const	O
gsl_qrng_type	struct(*(char),int,*((int)->(long)),*((*(void),int)->(int)),*((*(void),int,array(double))->(int)))
*	O
gsl_qrng_niederreiter_2	*(struct(*(char),int,*((int)->(long)),*((*(void),int)->(int)),*((*(void),int,array(double))->(int))))
=	O
&	O
nied2_type	struct(*(char),int,*((int)->(long)),*((*(void),int)->(int)),*((*(void),int,array(double))->(int)))
;	O
static	O
const	O
int	O
primitive_poly	array(array(int))
[	O
NIED2_MAX_DIMENSION	int
+	O
1	int
]	O
[	O
NIED2_MAX_PRIM_DEGREE	int
+	O
1	int
]	O
=	O
{	O
{	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
}	O
,	O
{	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
}	O
,	O
{	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
}	O
,	O
{	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
}	O
,	O
{	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
1	int
}	O
,	O
{	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
}	O
,	O
{	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
}	O
}	O
;	O
static	O
const	O
int	O
poly_degree	array(int)
[	O
NIED2_MAX_DIMENSION	int
+	O
1	int
]	O
=	O
{	O
0	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
3	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
}	O
;	O
typedef	O
struct	O
{	O
unsigned	O
int	O
sequence_count	int
;	O
int	O
cj	array(array(int))
[	O
NIED2_NBITS	O
]	O
[	O
NIED2_MAX_DIMENSION	int
]	O
;	O
int	O
nextq	array(int)
[	O
NIED2_MAX_DIMENSION	int
]	O
;	O
}	O
nied2_state_t	struct(int,array(array(int)),array(int))
;	O
static	O
size_t	long
nied2_state_size	(int)->(long)
(	O
unsigned	O
int	O
dimension	int
)	O
{	O
return	O
sizeof	O
(	O
nied2_state_t	struct(int,array(array(int)),array(int))
)	O
;	O
}	O
static	O
void	O
poly_multiply	(array(int),int,array(int),int,array(int),*(int))->(void)
(	O
const	O
int	O
pa	array(int)
[	O
]	O
,	O
int	O
pa_degree	int
,	O
const	O
int	O
pb	array(int)
[	O
]	O
,	O
int	O
pb_degree	int
,	O
int	O
pc	array(int)
[	O
]	O
,	O
int	O
*	O
pc_degree	*(int)
)	O
{	O
int	O
j	int
,	O
k	int
;	O
int	O
pt	array(int)
[	O
NIED2_MAX_DEGREE	int
+	O
1	int
]	O
;	O
int	O
pt_degree	int
=	O
pa_degree	int
+	O
pb_degree	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
pt_degree	int
;	O
k	int
++	O
)	O
{	O
int	O
term	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
k	int
;	O
j	int
++	O
)	O
{	O
const	O
int	O
conv_term	int
=	O
NIED2_MUL	O
(	O
pa	array(int)
[	O
k	int
-	O
j	int
]	O
,	O
pb	array(int)
[	O
j	int
]	O
)	O
;	O
term	int
=	O
NIED2_ADD	O
(	O
term	int
,	O
conv_term	int
)	O
;	O
}	O
pt	array(int)
[	O
k	int
]	O
=	O
term	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
pt_degree	int
;	O
k	int
++	O
)	O
{	O
pc	array(int)
[	O
k	int
]	O
=	O
pt	array(int)
[	O
k	int
]	O
;	O
}	O
for	O
(	O
k	int
=	O
pt_degree	int
+	O
1	int
;	O
k	int
<=	O
NIED2_MAX_DEGREE	int
;	O
k	int
++	O
)	O
{	O
pc	array(int)
[	O
k	int
]	O
=	O
0	int
;	O
}	O
*	O
pc_degree	*(int)
=	O
pt_degree	int
;	O
}	O
static	O
void	O
calculate_v	(array(int),int,array(int),*(int),array(int),int)->(void)
(	O
const	O
int	O
px	array(int)
[	O
]	O
,	O
int	O
px_degree	int
,	O
int	O
pb	array(int)
[	O
]	O
,	O
int	O
*	O
pb_degree	int
,	O
int	O
v	*(double)
[	O
]	O
,	O
int	O
maxv	int
)	O
{	O
const	O
int	O
nonzero_element	int
=	O
1	int
;	O
const	O
int	O
arbitrary_element	int
=	O
1	int
;	O
int	O
ph	array(int)
[	O
NIED2_MAX_DEGREE	int
+	O
1	int
]	O
;	O
int	O
bigm	int
=	O
*	O
pb_degree	int
;	O
int	O
m	int
;	O
int	O
r	int
,	O
k	int
,	O
kj	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
NIED2_MAX_DEGREE	int
;	O
k	int
++	O
)	O
{	O
ph	array(int)
[	O
k	int
]	O
=	O
pb	array(int)
[	O
k	int
]	O
;	O
}	O
poly_multiply	(array(int),int,array(int),int,array(int),*(int))->(void)
(	O
px	array(int)
,	O
px_degree	int
,	O
pb	array(int)
,	O
*	O
pb_degree	int
,	O
pb	array(int)
,	O
pb_degree	int
)	O
;	O
m	int
=	O
*	O
pb_degree	int
;	O
kj	int
=	O
bigm	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
kj	int
;	O
r	int
++	O
)	O
{	O
v	*(double)
[	O
r	int
]	O
=	O
0	int
;	O
}	O
v	*(double)
[	O
kj	int
]	O
=	O
1	int
;	O
if	O
(	O
kj	int
>=	O
bigm	int
)	O
{	O
for	O
(	O
r	int
=	O
kj	int
+	O
1	int
;	O
r	int
<	O
m	int
;	O
r	int
++	O
)	O
{	O
v	*(double)
[	O
r	int
]	O
=	O
arbitrary_element	int
;	O
}	O
}	O
else	O
{	O
int	O
term	int
=	O
NIED2_SUB	O
(	O
0	int
,	O
ph	array(int)
[	O
kj	int
]	O
)	O
;	O
for	O
(	O
r	int
=	O
kj	int
+	O
1	int
;	O
r	int
<	O
bigm	int
;	O
r	int
++	O
)	O
{	O
v	*(double)
[	O
r	int
]	O
=	O
arbitrary_element	int
;	O
term	int
=	O
NIED2_SUB	O
(	O
term	int
,	O
NIED2_MUL	O
(	O
ph	array(int)
[	O
r	int
]	O
,	O
v	*(double)
[	O
r	int
]	O
)	O
)	O
;	O
}	O
v	*(double)
[	O
bigm	int
]	O
=	O
NIED2_ADD	O
(	O
nonzero_element	int
,	O
term	int
)	O
;	O
for	O
(	O
r	int
=	O
bigm	int
+	O
1	int
;	O
r	int
<	O
m	int
;	O
r	int
++	O
)	O
{	O
v	*(double)
[	O
r	int
]	O
=	O
arbitrary_element	int
;	O
}	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<=	O
maxv	int
-	O
m	int
;	O
r	int
++	O
)	O
{	O
int	O
term	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
m	int
;	O
k	int
++	O
)	O
{	O
term	int
=	O
NIED2_SUB	O
(	O
term	int
,	O
NIED2_MUL	O
(	O
pb	array(int)
[	O
k	int
]	O
,	O
v	*(double)
[	O
r	int
+	O
k	int
]	O
)	O
)	O
;	O
}	O
v	*(double)
[	O
r	int
+	O
m	int
]	O
=	O
term	int
;	O
}	O
}	O
static	O
void	O
calculate_cj	(*(struct(int,array(array(int)),array(int))),int)->(void)
(	O
nied2_state_t	struct(int,array(array(int)),array(int))
*	O
ns	*(struct(int,array(array(int)),array(int)))
,	O
unsigned	O
int	O
dimension	int
)	O
{	O
int	O
ci	array(array(int))
[	O
NIED2_NBITS	O
]	O
[	O
NIED2_NBITS	O
]	O
;	O
int	O
v	*(double)
[	O
MAXV	O
+	O
1	int
]	O
;	O
int	O
r	int
;	O
unsigned	O
int	O
i_dim	int
;	O
for	O
(	O
i_dim	int
=	O
0	int
;	O
i_dim	int
<	O
dimension	int
;	O
i_dim	int
++	O
)	O
{	O
const	O
int	O
poly_index	int
=	O
i_dim	int
+	O
1	int
;	O
int	O
j	int
,	O
k	int
;	O
int	O
u	int
=	O
0	int
;	O
int	O
pb	array(int)
[	O
NIED2_MAX_DEGREE	int
+	O
1	int
]	O
;	O
int	O
px	array(int)
[	O
NIED2_MAX_DEGREE	int
+	O
1	int
]	O
;	O
int	O
px_degree	int
=	O
poly_degree	array(int)
[	O
poly_index	int
]	O
;	O
int	O
pb_degree	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
px_degree	int
;	O
k	int
++	O
)	O
{	O
px	array(int)
[	O
k	int
]	O
=	O
primitive_poly	array(array(int))
[	O
poly_index	int
]	O
[	O
k	int
]	O
;	O
pb	array(int)
[	O
k	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
;	O
k	int
<	O
NIED2_MAX_DEGREE	int
+	O
1	int
;	O
k	int
++	O
)	O
{	O
px	array(int)
[	O
k	int
]	O
=	O
0	int
;	O
pb	array(int)
[	O
k	int
]	O
=	O
0	int
;	O
}	O
pb	array(int)
[	O
0	int
]	O
=	O
1	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NIED2_NBITS	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
u	int
==	O
0	int
)	O
calculate_v	(array(int),int,array(int),*(int),array(int),int)->(void)
(	O
px	array(int)
,	O
px_degree	int
,	O
pb	array(int)
,	O
&	O
pb_degree	int
,	O
v	*(double)
,	O
MAXV	O
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
NIED2_NBITS	O
;	O
r	int
++	O
)	O
{	O
ci	array(array(int))
[	O
r	int
]	O
[	O
j	int
]	O
=	O
v	*(double)
[	O
r	int
+	O
u	int
]	O
;	O
}	O
++	O
u	int
;	O
if	O
(	O
u	int
==	O
px_degree	int
)	O
u	int
=	O
0	int
;	O
}	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
NIED2_NBITS	O
;	O
r	int
++	O
)	O
{	O
int	O
term	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NIED2_NBITS	O
;	O
j	int
++	O
)	O
{	O
term	int
=	O
2	int
*	O
term	int
+	O
ci	array(array(int))
[	O
r	int
]	O
[	O
j	int
]	O
;	O
}	O
ns	*(struct(int,array(array(int)),array(int)))
->	O
cj	array(array(int))
[	O
r	int
]	O
[	O
i_dim	int
]	O
=	O
term	int
;	O
}	O
}	O
}	O
static	O
int	O
nied2_init	(*(void),int)->(int)
(	O
void	O
*	O
state	*(int)
,	O
unsigned	O
int	O
dimension	int
)	O
{	O
nied2_state_t	struct(int,array(array(int)),array(int))
*	O
n_state	*(struct(int,array(array(int)),array(int)))
=	O
(	O
nied2_state_t	struct(int,array(array(int)),array(int))
*	O
)	O
state	*(int)
;	O
unsigned	O
int	O
i_dim	int
;	O
if	O
(	O
dimension	int
<	O
1	int
||	O
dimension	int
>	O
NIED2_MAX_DIMENSION	int
)	O
return	O
GSL_EINVAL	int
;	O
calculate_cj	(*(struct(int,array(array(int)),array(int))),int)->(void)
(	O
n_state	*(struct(int,array(array(int)),array(int)))
,	O
dimension	int
)	O
;	O
for	O
(	O
i_dim	int
=	O
0	int
;	O
i_dim	int
<	O
dimension	int
;	O
i_dim	int
++	O
)	O
n_state	*(struct(int,array(array(int)),array(int)))
->	O
nextq	array(int)
[	O
i_dim	int
]	O
=	O
0	int
;	O
n_state	*(struct(int,array(array(int)),array(int)))
->	O
sequence_count	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
nied2_get	(*(void),int,*(double))->(int)
(	O
void	O
*	O
state	*(int)
,	O
unsigned	O
int	O
dimension	int
,	O
double	O
*	O
v	*(double)
)	O
{	O
static	O
const	O
double	O
recip	double
=	O
1.0	int
/	O
(	O
double	O
)	O
(	O
1U	int
<<	O
NIED2_NBITS	O
)	O
;	O
nied2_state_t	struct(int,array(array(int)),array(int))
*	O
n_state	*(struct(int,array(array(int)),array(int)))
=	O
(	O
nied2_state_t	struct(int,array(array(int)),array(int))
*	O
)	O
state	*(int)
;	O
int	O
r	int
;	O
int	O
c	int
;	O
unsigned	O
int	O
i_dim	int
;	O
for	O
(	O
i_dim	int
=	O
0	int
;	O
i_dim	int
<	O
dimension	int
;	O
i_dim	int
++	O
)	O
{	O
v	*(double)
[	O
i_dim	int
]	O
=	O
n_state	*(struct(int,array(array(int)),array(int)))
->	O
nextq	array(int)
[	O
i_dim	int
]	O
*	O
recip	double
;	O
}	O
r	int
=	O
0	int
;	O
c	int
=	O
n_state	*(struct(int,array(array(int)),array(int)))
->	O
sequence_count	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
(	O
c	int
%	O
2	int
)	O
==	O
1	int
)	O
{	O
++	O
r	int
;	O
c	int
/=	O
2	int
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
r	int
>=	O
NIED2_NBITS	O
)	O
return	O
GSL_EFAILED	int
;	O
for	O
(	O
i_dim	int
=	O
0	int
;	O
i_dim	int
<	O
dimension	int
;	O
i_dim	int
++	O
)	O
{	O
n_state	*(struct(int,array(array(int)),array(int)))
->	O
nextq	array(int)
[	O
i_dim	int
]	O
^=	O
n_state	*(struct(int,array(array(int)),array(int)))
->	O
cj	array(array(int))
[	O
r	int
]	O
[	O
i_dim	int
]	O
;	O
}	O
n_state	*(struct(int,array(array(int)),array(int)))
->	O
sequence_count	int
++	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
