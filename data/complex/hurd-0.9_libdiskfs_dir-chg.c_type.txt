kern_return_t	O
diskfs_S_dir_notice_changes	(*(struct),int)->(int)
(	O
struct	O
protid	O
*	O
cred	*(struct)
,	O
mach_port_t	O
notify	int
)	O
{	O
error_t	O
err	O
;	O
struct	O
modreq	O
*	O
req	*(struct)
;	O
struct	O
node	O
*	O
np	*(struct)
;	O
if	O
(	O
!	O
cred	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
np	*(struct)
=	O
cred	*(struct)
->	O
po	O
->	O
np	*(struct)
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
if	O
(	O
!	O
S_ISDIR	()->(int)
(	O
np	*(struct)
->	O
dn_stat	O
.	O
st_mode	O
)	O
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
return	O
ENOTDIR	O
;	O
}	O
err	O
=	O
dir_changed	()->(int)
(	O
notify	int
,	O
np	*(struct)
->	O
dirmod_tick	O
,	O
DIR_CHANGED_NULL	O
,	O
""	*(char)
)	O
;	O
if	O
(	O
err	O
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
return	O
err	O
;	O
}	O
req	*(struct)
=	O
malloc	O
(	O
sizeof	O
(	O
struct	O
modreq	O
)	O
)	O
;	O
if	O
(	O
!	O
req	*(struct)
)	O
{	O
pthread_mutex_unlock	()->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
return	O
ENOMEM	O
;	O
}	O
req	*(struct)
->	O
port	O
=	O
notify	int
;	O
req	*(struct)
->	O
next	O
=	O
np	*(struct)
->	O
dirmod_reqs	O
;	O
np	*(struct)
->	O
dirmod_reqs	O
=	O
req	*(struct)
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
np	*(struct)
->	O
lock	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
diskfs_notice_dirchange	(*(struct),enum,*(char))->(void)
(	O
struct	O
node	O
*	O
dp	*(struct)
,	O
enum	O
dir_changed_type	O
type	enum
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
error_t	O
err	O
;	O
struct	O
modreq	O
*	O
*	O
preq	*(*(struct))
;	O
dp	*(struct)
->	O
dirmod_tick	O
++	O
;	O
preq	*(*(struct))
=	O
&	O
dp	*(struct)
->	O
dirmod_reqs	O
;	O
while	O
(	O
*	O
preq	*(*(struct))
)	O
{	O
struct	O
modreq	O
*	O
req	*(struct)
=	O
*	O
preq	*(*(struct))
;	O
err	O
=	O
dir_changed	()->(int)
(	O
req	*(struct)
->	O
port	O
,	O
dp	*(struct)
->	O
dirmod_tick	O
,	O
type	enum
,	O
(	O
char	O
*	O
)	O
name	*(char)
)	O
;	O
if	O
(	O
err	O
&&	O
err	O
!=	O
MACH_SEND_TIMED_OUT	O
)	O
{	O
*	O
preq	*(*(struct))
=	O
req	*(struct)
->	O
next	O
;	O
mach_port_deallocate	()->(int)
(	O
mach_task_self	()->(int)
(	O
)	O
,	O
req	*(struct)
->	O
port	O
)	O
;	O
free	()->(int)
(	O
req	*(struct)
)	O
;	O
}	O
else	O
preq	*(*(struct))
=	O
&	O
req	*(struct)
->	O
next	O
;	O
}	O
}	O
