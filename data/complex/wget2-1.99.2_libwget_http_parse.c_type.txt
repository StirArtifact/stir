static	O
const	O
unsigned	O
char	O
http_ctype	array(char)
[	O
256	int
]	O
=	O
{	O
[	O
'('	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
')'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'<'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'>'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'@'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
','	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
';'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
':'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'\\'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'\"'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'/'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'['	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
']'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'?'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'='	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'{'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'}'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
' '	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
,	O
[	O
'\t'	O
]	O
=	O
HTTP_CTYPE_SEPARATOR	O
}	O
;	O
const	O
char	O
*	O
wget_http_get_host	(*(struct))->(*(char))
(	O
const	O
wget_http_connection	struct
*	O
conn	*(struct)
)	O
{	O
return	O
conn	*(struct)
->	O
esc_host	struct(*(char),long,long,bool,bool,bool)
;	O
}	O
uint16_t	short
wget_http_get_port	(*(struct))->(short)
(	O
const	O
wget_http_connection	struct
*	O
conn	*(struct)
)	O
{	O
return	O
conn	*(struct)
->	O
port	short
;	O
}	O
wget_iri_scheme	enum(int,int)
wget_http_get_scheme	(*(struct))->(enum(int,int))
(	O
const	O
wget_http_connection	struct
*	O
conn	*(struct)
)	O
{	O
return	O
conn	*(struct)
->	O
scheme	enum(int,int)
;	O
}	O
int	O
wget_http_get_protocol	(*(struct))->(int)
(	O
const	O
wget_http_connection	struct
*	O
conn	*(struct)
)	O
{	O
return	O
conn	*(struct)
->	O
protocol	int
;	O
}	O
bool	bool
wget_http_isseparator	(char)->(bool)
(	O
char	O
c	int
)	O
{	O
return	O
_http_isseparator	O
(	O
c	int
)	O
;	O
}	O
bool	bool
wget_http_istoken	(char)->(bool)
(	O
char	O
c	int
)	O
{	O
return	O
c	int
>	O
32	int
&&	O
c	int
<=	O
126	int
&&	O
!	O
_http_isseparator	O
(	O
c	int
)	O
;	O
}	O
const	O
char	O
*	O
wget_http_parse_token	(*(char),*(*(char)))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
*	O
token	*(*(char))
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
s	*(char)
;	O
wget_http_istoken	(char)->(bool)
(	O
*	O
s	*(char)
)	O
;	O
s	*(char)
++	O
)	O
;	O
*	O
token	*(*(char))
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
p	*(char)
,	O
s	*(char)
-	O
p	*(char)
)	O
;	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_quoted_string	(*(char),*(*(char)))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
*	O
qstring	*(*(char))
)	O
{	O
if	O
(	O
*	O
s	*(char)
==	O
'\"'	O
)	O
{	O
const	O
char	O
*	O
p	*(char)
=	O
++	O
s	*(char)
;	O
while	O
(	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
*	O
s	*(char)
==	O
'\"'	O
)	O
break	O
;	O
else	O
if	O
(	O
*	O
s	*(char)
==	O
'\\'	O
&&	O
s	*(char)
[	O
1	int
]	O
)	O
{	O
s	*(char)
+=	O
2	int
;	O
}	O
else	O
s	*(char)
++	O
;	O
}	O
*	O
qstring	*(*(char))
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
p	*(char)
,	O
s	*(char)
-	O
p	*(char)
)	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
'\"'	O
)	O
s	*(char)
++	O
;	O
}	O
else	O
*	O
qstring	*(*(char))
=	O
NULL	O
;	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_param	(*(char),*(*(char)),*(*(char)))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
*	O
param	*(*(char))
,	O
const	O
char	O
*	O
*	O
value	*(void)
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
*	O
param	*(*(char))
=	O
*	O
value	*(void)
=	O
NULL	O
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
';'	O
)	O
{	O
s	*(char)
++	O
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
}	O
if	O
(	O
!	O
*	O
s	*(char)
)	O
return	O
s	*(char)
;	O
for	O
(	O
p	*(char)
=	O
s	*(char)
;	O
wget_http_istoken	(char)->(bool)
(	O
*	O
s	*(char)
)	O
;	O
s	*(char)
++	O
)	O
;	O
*	O
param	*(*(char))
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
p	*(char)
,	O
s	*(char)
-	O
p	*(char)
)	O
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
if	O
(	O
*	O
s	*(char)
&&	O
*	O
s	*(char)
++	O
==	O
'='	O
)	O
{	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
'\"'	O
)	O
{	O
s	*(char)
=	O
wget_http_parse_quoted_string	(*(char),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
value	*(void)
)	O
;	O
}	O
else	O
{	O
s	*(char)
=	O
wget_http_parse_token	(*(char),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
value	*(void)
)	O
;	O
}	O
}	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_name	(*(char),*(*(char)))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
*	O
name	*(char)
)	O
{	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
s	*(char)
=	O
wget_http_parse_token	(*(char),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
name	*(char)
)	O
;	O
while	O
(	O
*	O
s	*(char)
&&	O
*	O
s	*(char)
!=	O
':'	O
)	O
s	*(char)
++	O
;	O
return	O
*	O
s	*(char)
==	O
':'	O
?	O
s	*(char)
+	O
1	int
:	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_parse_name_fixed	(*(char),*(*(char)),*(long))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
*	O
name	*(char)
,	O
size_t	long
*	O
namelen	*(long)
)	O
{	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
*	O
name	*(char)
=	O
s	*(char)
;	O
while	O
(	O
wget_http_istoken	(char)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
*	O
namelen	*(long)
=	O
s	*(char)
-	O
*	O
name	*(char)
;	O
while	O
(	O
*	O
s	*(char)
&&	O
*	O
s	*(char)
!=	O
':'	O
)	O
s	*(char)
++	O
;	O
return	O
*	O
s	*(char)
==	O
':'	O
?	O
s	*(char)
+	O
1	int
:	O
s	*(char)
;	O
}	O
static	O
int	O
WGET_GCC_NONNULL_ALL	O
compare_param	(*(struct(*(char),*(char))),*(struct(*(char),*(char))))->(int)
(	O
wget_http_header_param	struct(*(char),*(char))
*	O
p1	*(struct(*(char),*(char)))
,	O
wget_http_header_param	struct(*(char),*(char))
*	O
p2	*(struct(*(char),*(char)))
)	O
{	O
return	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
p1	*(struct(*(char),*(char)))
->	O
name	*(char)
,	O
p2	*(struct(*(char),*(char)))
->	O
name	*(char)
)	O
;	O
}	O
void	O
wget_http_add_param	(*(*(struct)),*(struct(*(char),*(char))))->(void)
(	O
wget_vector	struct
*	O
*	O
params	*(struct)
,	O
wget_http_header_param	struct(*(char),*(char))
*	O
param	*(*(char))
)	O
{	O
if	O
(	O
!	O
*	O
params	*(struct)
)	O
*	O
params	*(struct)
=	O
wget_vector_create	(int,*((*(void),*(void))->(int)))->(*(struct))
(	O
4	int
,	O
(	O
wget_vector_compare_fn	(*(void),*(void))->(int)
*	O
)	O
compare_param	(*(struct(*(char),*(char))),*(struct(*(char),*(char))))->(int)
)	O
;	O
wget_vector_add_memdup	(*(struct),*(void),long)->(int)
(	O
*	O
params	*(struct)
,	O
param	*(*(char))
,	O
sizeof	O
(	O
*	O
param	*(*(char))
)	O
)	O
;	O
}	O
const	O
char	O
*	O
wget_http_parse_link	(*(char),*(struct(*(char),*(char),int,enum(int,int,int))))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
wget_http_link	struct(*(char),*(char),int,enum(int,int,int))
*	O
link	(*(char),*(char))->(int)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
link	(*(char),*(char))->(int)
,	O
0	int
,	O
sizeof	O
(	O
*	O
link	(*(char),*(char))->(int)
)	O
)	O
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
'<'	O
)	O
{	O
const	O
char	O
*	O
p	*(char)
=	O
s	*(char)
+	O
1	int
;	O
if	O
(	O
(	O
s	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(char)
,	O
'>'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
=	O
NULL	O
,	O
*	O
value	*(void)
=	O
NULL	O
;	O
link	(*(char),*(char))->(int)
->	O
uri	*(char)
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
p	*(char)
,	O
s	*(char)
-	O
p	*(char)
)	O
;	O
s	*(char)
++	O
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
while	O
(	O
*	O
s	*(char)
==	O
';'	O
)	O
{	O
s	*(char)
=	O
wget_http_parse_param	(*(char),*(*(char)),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
&	O
name	*(char)
,	O
&	O
value	*(void)
)	O
;	O
if	O
(	O
name	*(char)
&&	O
value	*(void)
)	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"rel"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
value	*(void)
,	O
"describedby"	*(char)
)	O
)	O
link	(*(char),*(char))->(int)
->	O
rel	enum(int,int,int)
=	O
link_rel_describedby	int
;	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
value	*(void)
,	O
"duplicate"	*(char)
)	O
)	O
link	(*(char),*(char))->(int)
->	O
rel	enum(int,int,int)
=	O
link_rel_duplicate	int
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"pri"	*(char)
)	O
)	O
{	O
link	(*(char),*(char))->(int)
->	O
pri	int
=	O
atoi	(*(char))->(int)
(	O
value	*(void)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"type"	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
link	(*(char),*(char))->(int)
->	O
type	*(char)
)	O
{	O
link	(*(char),*(char))->(int)
->	O
type	*(char)
=	O
value	*(void)
;	O
value	*(void)
=	O
NULL	O
;	O
}	O
}	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
}	O
xfree	O
(	O
name	*(char)
)	O
;	O
xfree	O
(	O
value	*(void)
)	O
;	O
}	O
while	O
(	O
*	O
s	*(char)
&&	O
!	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
}	O
}	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_digest	(*(char),*(struct(*(char),*(char))))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
wget_http_digest	struct(*(char),*(char))
*	O
digest	*(struct(*(char),*(char)))
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
digest	*(struct(*(char),*(char)))
,	O
0	int
,	O
sizeof	O
(	O
*	O
digest	*(struct(*(char),*(char)))
)	O
)	O
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
s	*(char)
=	O
wget_http_parse_token	(*(char),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
&	O
digest	*(struct(*(char),*(char)))
->	O
algorithm	*(char)
)	O
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
'='	O
)	O
{	O
s	*(char)
++	O
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
'\"'	O
)	O
{	O
s	*(char)
=	O
wget_http_parse_quoted_string	(*(char),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
&	O
digest	*(struct(*(char),*(char)))
->	O
encoded_digest	*(char)
)	O
;	O
}	O
else	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
for	O
(	O
p	*(char)
=	O
s	*(char)
;	O
*	O
s	*(char)
&&	O
!	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
&&	O
*	O
s	*(char)
!=	O
','	O
&&	O
*	O
s	*(char)
!=	O
';'	O
;	O
s	*(char)
++	O
)	O
;	O
digest	*(struct(*(char),*(char)))
->	O
encoded_digest	*(char)
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
p	*(char)
,	O
s	*(char)
-	O
p	*(char)
)	O
;	O
}	O
}	O
while	O
(	O
*	O
s	*(char)
&&	O
!	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_challenge	(*(char),*(struct(*(char),*(struct))))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
wget_http_challenge	struct(*(char),*(struct))
*	O
challenge	*(struct(*(char),*(struct)))
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
challenge	*(struct(*(char),*(struct)))
,	O
0	int
,	O
sizeof	O
(	O
*	O
challenge	*(struct(*(char),*(struct)))
)	O
)	O
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
s	*(char)
=	O
wget_http_parse_token	(*(char),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
&	O
challenge	*(struct(*(char),*(struct)))
->	O
auth_scheme	*(char)
)	O
;	O
if	O
(	O
*	O
s	*(char)
==	O
' '	O
)	O
s	*(char)
++	O
;	O
else	O
{	O
xfree	O
(	O
challenge	*(struct(*(char),*(struct)))
->	O
auth_scheme	*(char)
)	O
;	O
return	O
s	*(char)
;	O
}	O
wget_http_header_param	struct(*(char),*(char))
param	*(*(char))
;	O
do	O
{	O
const	O
char	O
*	O
old	*(char)
=	O
s	*(char)
;	O
s	*(char)
=	O
wget_http_parse_param	(*(char),*(*(char)),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
&	O
param	*(*(char))
.	O
name	*(char)
,	O
&	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
if	O
(	O
param	*(*(char))
.	O
name	*(char)
)	O
{	O
if	O
(	O
*	O
param	*(*(char))
.	O
name	*(char)
&&	O
!	O
param	*(*(char))
.	O
value	*(void)
)	O
{	O
xfree	O
(	O
param	*(*(char))
.	O
name	*(char)
)	O
;	O
return	O
old	*(char)
;	O
}	O
if	O
(	O
!	O
param	*(*(char))
.	O
value	*(void)
)	O
{	O
xfree	O
(	O
param	*(*(char))
.	O
name	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
challenge	*(struct(*(char),*(struct)))
->	O
params	*(struct)
)	O
challenge	*(struct(*(char),*(struct)))
->	O
params	*(struct)
=	O
wget_stringmap_create_nocase	(int)->(*(struct))
(	O
8	int
)	O
;	O
wget_stringmap_put	(*(struct),*(char),*(void))->(int)
(	O
challenge	*(struct(*(char),*(struct)))
->	O
params	*(struct)
,	O
param	*(*(char))
.	O
name	*(char)
,	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
}	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
if	O
(	O
*	O
s	*(char)
!=	O
','	O
)	O
break	O
;	O
else	O
if	O
(	O
*	O
s	*(char)
)	O
s	*(char)
++	O
;	O
}	O
while	O
(	O
*	O
s	*(char)
)	O
;	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_challenges	(*(char),*(struct))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
wget_vector	struct
*	O
challenges	*(struct)
)	O
{	O
wget_http_challenge	struct(*(char),*(struct))
challenge	*(struct(*(char),*(struct)))
;	O
while	O
(	O
*	O
s	*(char)
)	O
{	O
s	*(char)
=	O
wget_http_parse_challenge	(*(char),*(struct(*(char),*(struct))))->(*(char))
(	O
s	*(char)
,	O
&	O
challenge	*(struct(*(char),*(struct)))
)	O
;	O
if	O
(	O
challenge	*(struct(*(char),*(struct)))
.	O
auth_scheme	*(char)
)	O
{	O
wget_vector_add_memdup	(*(struct),*(void),long)->(int)
(	O
challenges	*(struct)
,	O
&	O
challenge	*(struct(*(char),*(struct)))
,	O
sizeof	O
(	O
challenge	*(struct(*(char),*(struct)))
)	O
)	O
;	O
}	O
}	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_location	(*(char),*(*(char)))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
*	O
location	*(char)
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
for	O
(	O
p	*(char)
=	O
s	*(char)
;	O
*	O
s	*(char)
&&	O
*	O
s	*(char)
!=	O
'\r'	O
&&	O
*	O
s	*(char)
!=	O
'\n'	O
;	O
s	*(char)
++	O
)	O
;	O
while	O
(	O
s	*(char)
>	O
p	*(char)
&&	O
c_isblank	(int)->(bool)
(	O
*	O
(	O
s	*(char)
-	O
1	int
)	O
)	O
)	O
s	*(char)
--	O
;	O
*	O
location	*(char)
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
p	*(char)
,	O
s	*(char)
-	O
p	*(char)
)	O
;	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_transfer_encoding	(*(char),*(enum(int,int)))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
wget_transfer_encoding	enum(int,int)
*	O
transfer_encoding	enum(int,int)
)	O
{	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"identity"	*(char)
)	O
)	O
*	O
transfer_encoding	enum(int,int)
=	O
wget_transfer_encoding_identity	int
;	O
else	O
*	O
transfer_encoding	enum(int,int)
=	O
wget_transfer_encoding_chunked	int
;	O
while	O
(	O
wget_http_istoken	(char)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_content_type	(*(char),*(*(char)),*(*(char)))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
*	O
content_type	*(char)
,	O
const	O
char	O
*	O
*	O
charset	*(*(char))
)	O
{	O
wget_http_header_param	struct(*(char),*(char))
param	*(*(char))
;	O
const	O
char	O
*	O
p	*(char)
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
for	O
(	O
p	*(char)
=	O
s	*(char)
;	O
*	O
s	*(char)
&&	O
(	O
wget_http_istoken	(char)->(bool)
(	O
*	O
s	*(char)
)	O
||	O
*	O
s	*(char)
==	O
'/'	O
)	O
;	O
s	*(char)
++	O
)	O
;	O
if	O
(	O
content_type	*(char)
)	O
*	O
content_type	*(char)
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
p	*(char)
,	O
s	*(char)
-	O
p	*(char)
)	O
;	O
if	O
(	O
charset	*(*(char))
)	O
{	O
*	O
charset	*(*(char))
=	O
NULL	O
;	O
while	O
(	O
*	O
s	*(char)
)	O
{	O
s	*(char)
=	O
wget_http_parse_param	(*(char),*(*(char)),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
&	O
param	*(*(char))
.	O
name	*(char)
,	O
&	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
"charset"	*(char)
,	O
param	*(*(char))
.	O
name	*(char)
)	O
)	O
{	O
xfree	O
(	O
param	*(*(char))
.	O
name	*(char)
)	O
;	O
*	O
charset	*(*(char))
=	O
param	*(*(char))
.	O
value	*(void)
;	O
break	O
;	O
}	O
xfree	O
(	O
param	*(*(char))
.	O
name	*(char)
)	O
;	O
xfree	O
(	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
}	O
}	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_content_disposition	(*(char),*(*(char)))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
*	O
filename	*(*(char))
)	O
{	O
wget_http_header_param	struct(*(char),*(char))
param	*(*(char))
;	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
filename	*(*(char))
)	O
{	O
*	O
filename	*(*(char))
=	O
NULL	O
;	O
while	O
(	O
*	O
s	*(char)
&&	O
!	O
*	O
filename	*(*(char))
)	O
{	O
s	*(char)
=	O
wget_http_parse_param	(*(char),*(*(char)),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
&	O
param	*(*(char))
.	O
name	*(char)
,	O
&	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
if	O
(	O
param	*(*(char))
.	O
value	*(void)
&&	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
"filename"	*(char)
,	O
param	*(*(char))
.	O
name	*(char)
)	O
)	O
{	O
if	O
(	O
!	O
*	O
filename	*(*(char))
)	O
{	O
if	O
(	O
(	O
p	*(char)
=	O
strpbrk	(*(char),*(char))->(*(char))
(	O
param	*(*(char))
.	O
value	*(void)
,	O
"/\\"	*(char)
)	O
)	O
)	O
{	O
p	*(char)
=	O
wget_strdup	(*(char))->(*(char))
(	O
p	*(char)
+	O
1	int
)	O
;	O
}	O
else	O
{	O
p	*(char)
=	O
(	O
char	O
*	O
)	O
param	*(*(char))
.	O
value	*(void)
;	O
param	*(*(char))
.	O
value	*(void)
=	O
NULL	O
;	O
}	O
wget_percent_unescape	(*(char))->(int)
(	O
p	*(char)
)	O
;	O
if	O
(	O
!	O
wget_str_is_valid_utf8	(*(char))->(bool)
(	O
p	*(char)
)	O
)	O
{	O
*	O
filename	*(*(char))
=	O
wget_str_to_utf8	(*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
"iso-8859-1"	*(char)
)	O
;	O
xfree	O
(	O
p	*(char)
)	O
;	O
}	O
else	O
{	O
*	O
filename	*(*(char))
=	O
p	*(char)
;	O
p	*(char)
=	O
NULL	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
param	*(*(char))
.	O
value	*(void)
&&	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
"filename*"	*(char)
,	O
param	*(*(char))
.	O
name	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
param	*(*(char))
.	O
value	*(void)
,	O
'\''	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
charset	*(*(char))
=	O
param	*(*(char))
.	O
value	*(void)
;	O
const	O
char	O
*	O
language	*(char)
=	O
p	*(char)
+	O
1	int
;	O
*	O
p	*(char)
=	O
0	int
;	O
if	O
(	O
(	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
language	*(char)
,	O
'\''	O
)	O
)	O
)	O
{	O
*	O
p	*(char)
++	O
=	O
0	int
;	O
if	O
(	O
*	O
p	*(char)
)	O
{	O
wget_percent_unescape	(*(char))->(int)
(	O
p	*(char)
)	O
;	O
if	O
(	O
wget_str_needs_encoding	(*(char))->(int)
(	O
p	*(char)
)	O
)	O
*	O
filename	*(*(char))
=	O
wget_str_to_utf8	(*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
charset	*(*(char))
)	O
;	O
else	O
*	O
filename	*(*(char))
=	O
wget_strdup	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
if	O
(	O
*	O
filename	*(*(char))
&&	O
(	O
p	*(char)
=	O
strpbrk	(*(char),*(char))->(*(char))
(	O
*	O
filename	*(*(char))
,	O
"/\\"	*(char)
)	O
)	O
)	O
{	O
p	*(char)
=	O
wget_strdup	(*(char))->(*(char))
(	O
p	*(char)
+	O
1	int
)	O
;	O
xfree	O
(	O
*	O
filename	*(*(char))
)	O
;	O
*	O
filename	*(*(char))
=	O
p	*(char)
;	O
}	O
xfree	O
(	O
param	*(*(char))
.	O
name	*(char)
)	O
;	O
xfree	O
(	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
xfree	O
(	O
param	*(*(char))
.	O
name	*(char)
)	O
;	O
xfree	O
(	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
}	O
}	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_public_key_pins	(*(char),*(struct))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
wget_hpkp	struct
*	O
hpkp	*(*(struct))
)	O
{	O
wget_http_header_param	struct(*(char),*(char))
param	*(*(char))
;	O
wget_hpkp_set_include_subdomains	(*(struct),bool)->(void)
(	O
hpkp	*(*(struct))
,	O
false	int
)	O
;	O
while	O
(	O
*	O
s	*(char)
)	O
{	O
s	*(char)
=	O
wget_http_parse_param	(*(char),*(*(char)),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
&	O
param	*(*(char))
.	O
name	*(char)
,	O
&	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
if	O
(	O
param	*(*(char))
.	O
value	*(void)
)	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
param	*(*(char))
.	O
name	*(char)
,	O
"max-age"	*(char)
)	O
)	O
{	O
wget_hpkp_set_maxage	(*(struct),long)->(void)
(	O
hpkp	*(*(struct))
,	O
(	O
time_t	long
)	O
atoll	(*(char))->(long long)
(	O
param	*(*(char))
.	O
value	*(void)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
param	*(*(char))
.	O
name	*(char)
,	O
"pin-"	*(char)
,	O
4	int
)	O
)	O
{	O
wget_hpkp_pin_add	(*(struct),*(char),*(char))->(void)
(	O
hpkp	*(*(struct))
,	O
param	*(*(char))
.	O
name	*(char)
+	O
4	int
,	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
param	*(*(char))
.	O
name	*(char)
,	O
"includeSubDomains"	*(char)
)	O
)	O
wget_hpkp_set_include_subdomains	(*(struct),bool)->(void)
(	O
hpkp	*(*(struct))
,	O
true	int
)	O
;	O
}	O
xfree	O
(	O
param	*(*(char))
.	O
name	*(char)
)	O
;	O
xfree	O
(	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
}	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_strict_transport_security	(*(char),*(long),*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
time_t	long
*	O
maxage	long
,	O
char	O
*	O
include_subdomains	int
)	O
{	O
wget_http_header_param	struct(*(char),*(char))
param	*(*(char))
;	O
*	O
maxage	long
=	O
0	int
;	O
*	O
include_subdomains	int
=	O
0	int
;	O
while	O
(	O
*	O
s	*(char)
)	O
{	O
s	*(char)
=	O
wget_http_parse_param	(*(char),*(*(char)),*(*(char)))->(*(char))
(	O
s	*(char)
,	O
&	O
param	*(*(char))
.	O
name	*(char)
,	O
&	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
if	O
(	O
param	*(*(char))
.	O
value	*(void)
)	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
param	*(*(char))
.	O
name	*(char)
,	O
"max-age"	*(char)
)	O
)	O
{	O
*	O
maxage	long
=	O
(	O
time_t	long
)	O
atoll	(*(char))->(long long)
(	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
param	*(*(char))
.	O
name	*(char)
,	O
"includeSubDomains"	*(char)
)	O
)	O
{	O
*	O
include_subdomains	int
=	O
1	int
;	O
}	O
}	O
xfree	O
(	O
param	*(*(char))
.	O
name	*(char)
)	O
;	O
xfree	O
(	O
param	*(*(char))
.	O
value	*(void)
)	O
;	O
}	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_content_encoding	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
*	O
content_encoding	char
)	O
{	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"gzip"	*(char)
)	O
||	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"x-gzip"	*(char)
)	O
)	O
*	O
content_encoding	char
=	O
wget_content_encoding_gzip	int
;	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"deflate"	*(char)
)	O
)	O
*	O
content_encoding	char
=	O
wget_content_encoding_deflate	int
;	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"bzip2"	*(char)
)	O
)	O
*	O
content_encoding	char
=	O
wget_content_encoding_bzip2	int
;	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"xz"	*(char)
)	O
||	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"lzma"	*(char)
)	O
||	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"x-lzma"	*(char)
)	O
)	O
*	O
content_encoding	char
=	O
wget_content_encoding_lzma	int
;	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"br"	*(char)
)	O
)	O
*	O
content_encoding	char
=	O
wget_content_encoding_brotli	int
;	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"zstd"	*(char)
)	O
)	O
*	O
content_encoding	char
=	O
wget_content_encoding_zstd	int
;	O
else	O
*	O
content_encoding	char
=	O
wget_content_encoding_identity	int
;	O
while	O
(	O
wget_http_istoken	(char)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_connection	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
char	O
*	O
keep_alive	char
)	O
{	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"keep-alive"	*(char)
)	O
)	O
*	O
keep_alive	char
=	O
1	int
;	O
else	O
*	O
keep_alive	char
=	O
0	int
;	O
while	O
(	O
wget_http_istoken	(char)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
return	O
s	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_etag	(*(char),*(*(char)))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
*	O
etag	*(char)
)	O
{	O
const	O
char	O
*	O
p	*(char)
;	O
while	O
(	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
)	O
s	*(char)
++	O
;	O
for	O
(	O
p	*(char)
=	O
s	*(char)
;	O
*	O
s	*(char)
&&	O
!	O
c_isblank	(int)->(bool)
(	O
*	O
s	*(char)
)	O
;	O
s	*(char)
++	O
)	O
;	O
*	O
etag	*(char)
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
p	*(char)
,	O
s	*(char)
-	O
p	*(char)
)	O
;	O
return	O
s	*(char)
;	O
}	O
static	O
int	O
leap_days	(int,int)->(int)
(	O
int	O
y1	int
,	O
int	O
y2	int
)	O
{	O
y1	int
--	O
;	O
y2	int
--	O
;	O
return	O
(	O
y2	int
/	O
4	int
-	O
y1	int
/	O
4	int
)	O
-	O
(	O
y2	int
/	O
100	int
-	O
y1	int
/	O
100	int
)	O
+	O
(	O
y2	int
/	O
400	int
-	O
y1	int
/	O
400	int
)	O
;	O
}	O
time_t	long
wget_http_parse_full_date	(*(char))->(long)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
static	O
const	O
char	O
*	O
mnames	array(*(char))
[	O
12	int
]	O
=	O
{	O
"Jan"	*(char)
,	O
"Feb"	*(char)
,	O
"Mar"	*(char)
,	O
"Apr"	*(char)
,	O
"May"	*(char)
,	O
"Jun"	*(char)
,	O
"Jul"	*(char)
,	O
"Aug"	*(char)
,	O
"Sep"	*(char)
,	O
"Oct"	*(char)
,	O
"Nov"	*(char)
,	O
"Dec"	*(char)
}	O
;	O
static	O
int	O
days_per_month	array(int)
[	O
12	int
]	O
=	O
{	O
31	int
,	O
28	int
,	O
31	int
,	O
30	int
,	O
31	int
,	O
30	int
,	O
31	int
,	O
31	int
,	O
30	int
,	O
31	int
,	O
30	int
,	O
31	int
}	O
;	O
static	O
const	O
int	O
sum_of_days	array(int)
[	O
12	int
]	O
=	O
{	O
0	int
,	O
31	int
,	O
59	int
,	O
90	int
,	O
120	int
,	O
151	int
,	O
181	int
,	O
212	int
,	O
243	int
,	O
273	int
,	O
304	int
,	O
334	int
}	O
;	O
int	O
day	int
,	O
mon	int
=	O
0	int
,	O
year	int
,	O
hour	int
,	O
min	int
,	O
sec	int
,	O
leap_month	int
,	O
leap_year	int
,	O
days	int
;	O
char	O
mname	array(char)
[	O
4	int
]	O
=	O
""	*(char)
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
" %*[a-zA-Z], %02d %3s %4d %2d:%2d:%2d"	*(char)
,	O
&	O
day	int
,	O
mname	array(char)
,	O
&	O
year	int
,	O
&	O
hour	int
,	O
&	O
min	int
,	O
&	O
sec	int
)	O
>=	O
6	int
)	O
{	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
" %*[a-zA-Z], %2d-%3s-%4d %2d:%2d:%2d"	*(char)
,	O
&	O
day	int
,	O
mname	array(char)
,	O
&	O
year	int
,	O
&	O
hour	int
,	O
&	O
min	int
,	O
&	O
sec	int
)	O
>=	O
6	int
)	O
{	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
" %*[a-zA-Z] %3s %2d %2d:%2d:%2d %4d"	*(char)
,	O
mname	array(char)
,	O
&	O
day	int
,	O
&	O
hour	int
,	O
&	O
min	int
,	O
&	O
sec	int
,	O
&	O
year	int
)	O
>=	O
6	int
)	O
{	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
" %d %3s %4d %2d:%2d:%2d"	*(char)
,	O
&	O
day	int
,	O
mname	array(char)
,	O
&	O
year	int
,	O
&	O
hour	int
,	O
&	O
min	int
,	O
&	O
sec	int
)	O
>=	O
6	int
)	O
{	O
}	O
else	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to parse date '%s'\n"	*(char)
)	O
,	O
s	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
*	O
mname	array(char)
)	O
{	O
unsigned	O
it	int
;	O
for	O
(	O
it	int
=	O
0	int
;	O
it	int
<	O
countof	O
(	O
mnames	array(*(char))
)	O
;	O
it	int
++	O
)	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	(*(char),*(char))->(int)
(	O
mname	array(char)
,	O
mnames	array(*(char))
[	O
it	int
]	O
)	O
)	O
{	O
mon	int
=	O
it	int
+	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
year	int
<	O
70	int
&&	O
year	int
>=	O
0	int
)	O
year	int
+=	O
2000	int
;	O
else	O
if	O
(	O
year	int
>=	O
70	int
&&	O
year	int
<=	O
99	int
)	O
year	int
+=	O
1900	int
;	O
if	O
(	O
year	int
<	O
1970	int
)	O
year	int
=	O
1970	int
;	O
leap_year	int
=	O
year	int
%	O
4	int
==	O
0	int
&&	O
(	O
year	int
%	O
100	int
!=	O
0	int
||	O
year	int
%	O
400	int
==	O
0	int
)	O
;	O
leap_month	int
=	O
(	O
mon	int
==	O
2	int
&&	O
leap_year	int
)	O
;	O
if	O
(	O
mon	int
<	O
1	int
||	O
mon	int
>	O
12	int
||	O
day	int
<	O
1	int
||	O
(	O
day	int
>	O
days_per_month	array(int)
[	O
mon	int
-	O
1	int
]	O
+	O
leap_month	int
)	O
||	O
hour	int
<	O
0	int
||	O
hour	int
>	O
23	int
||	O
min	int
<	O
0	int
||	O
min	int
>	O
60	int
||	O
sec	int
<	O
0	int
||	O
sec	int
>	O
60	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to parse date '%s'\n"	*(char)
)	O
,	O
s	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
days	int
=	O
365	int
*	O
(	O
year	int
-	O
1970	int
)	O
+	O
leap_days	(int,int)->(int)
(	O
1970	int
,	O
year	int
)	O
;	O
days	int
+=	O
sum_of_days	array(int)
[	O
mon	int
-	O
1	int
]	O
+	O
(	O
mon	int
>	O
2	int
&&	O
leap_year	int
)	O
;	O
days	int
+=	O
day	int
-	O
1	int
;	O
return	O
(	O
(	O
(	O
time_t	long
)	O
days	int
*	O
24	int
+	O
hour	int
)	O
*	O
60	int
+	O
min	int
)	O
*	O
60	int
+	O
sec	int
;	O
}	O
char	O
*	O
wget_http_print_date	(long,*(char),long)->(*(char))
(	O
time_t	long
t	long
,	O
char	O
*	O
buf	*(char)
,	O
size_t	long
bufsize	long
)	O
{	O
static	O
const	O
char	O
*	O
dnames	array(*(char))
[	O
7	int
]	O
=	O
{	O
"Sun"	*(char)
,	O
"Mon"	*(char)
,	O
"Tue"	*(char)
,	O
"Wed"	*(char)
,	O
"Thu"	*(char)
,	O
"Fri"	*(char)
,	O
"Sat"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
mnames	array(*(char))
[	O
12	int
]	O
=	O
{	O
"Jan"	*(char)
,	O
"Feb"	*(char)
,	O
"Mar"	*(char)
,	O
"Apr"	*(char)
,	O
"May"	*(char)
,	O
"Jun"	*(char)
,	O
"Jul"	*(char)
,	O
"Aug"	*(char)
,	O
"Sep"	*(char)
,	O
"Oct"	*(char)
,	O
"Nov"	*(char)
,	O
"Dec"	*(char)
}	O
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
if	O
(	O
!	O
bufsize	long
)	O
return	O
buf	*(char)
;	O
if	O
(	O
gmtime_r	(*(long),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
t	long
,	O
&	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
)	O
{	O
wget_snprintf	(*(char),long,*(char))->(long)
(	O
buf	*(char)
,	O
bufsize	long
,	O
"%s, %02d %s %d %02d:%02d:%02d GMT"	*(char)
,	O
dnames	array(*(char))
[	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_wday	int
]	O
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mday	int
,	O
mnames	array(*(char))
[	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_mon	int
]	O
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_year	int
+	O
1900	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_hour	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_min	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
.	O
tm_sec	int
)	O
;	O
}	O
else	O
*	O
buf	*(char)
=	O
0	int
;	O
return	O
buf	*(char)
;	O
}	O
const	O
char	O
*	O
wget_http_parse_setcookie	(*(char),*(*(struct)))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
,	O
wget_cookie	struct
*	O
*	O
cookie	*(struct)
)	O
{	O
return	O
wget_cookie_parse_setcookie	(*(char),*(*(struct)))->(*(char))
(	O
s	*(char)
,	O
cookie	*(struct)
)	O
;	O
}	O
static	O
void	O
cookie_free	(*(void))->(void)
(	O
void	O
*	O
cookie	*(struct)
)	O
{	O
if	O
(	O
cookie	*(struct)
)	O
wget_cookie_free	(*(*(struct)))->(void)
(	O
(	O
wget_cookie	struct
*	O
*	O
)	O
&	O
cookie	*(struct)
)	O
;	O
}	O
int	O
wget_http_parse_header_line	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)),*(char),long,*(char),long)->(int)
(	O
wget_http_response	struct
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
,	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
namelen	*(long)
,	O
const	O
char	O
*	O
value	*(void)
,	O
size_t	long
valuelen	long
)	O
{	O
if	O
(	O
!	O
name	*(char)
||	O
!	O
value	*(void)
)	O
return	O
WGET_E_INVALID	int
;	O
char	O
valuebuf	array(char)
[	O
256	int
]	O
;	O
char	O
*	O
value0	*(char)
;	O
int	O
ret	int
=	O
WGET_E_SUCCESS	int
;	O
if	O
(	O
valuelen	long
<	O
sizeof	O
(	O
valuebuf	array(char)
)	O
)	O
{	O
wget_strmemcpy	(*(char),long,*(void),long)->(void)
(	O
value0	*(char)
=	O
valuebuf	array(char)
,	O
sizeof	O
(	O
valuebuf	array(char)
)	O
,	O
value	*(void)
,	O
valuelen	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
value0	*(char)
=	O
wget_strmemdup	(*(void),long)->(*(char))
(	O
value	*(void)
,	O
valuelen	long
)	O
)	O
)	O
return	O
WGET_E_MEMORY	int
;	O
}	O
switch	O
(	O
*	O
name	*(char)
|	O
0x20	int
)	O
{	O
case	O
':'	O
:	O
if	O
(	O
!	O
memcmp	(*(void),*(void),long)->(int)
(	O
name	*(char)
,	O
":status"	*(char)
,	O
namelen	*(long)
)	O
&&	O
valuelen	long
==	O
3	int
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
code	short
=	O
(	O
(	O
value	*(void)
[	O
0	int
]	O
-	O
'0'	O
)	O
*	O
10	int
+	O
(	O
value	*(void)
[	O
1	int
]	O
-	O
'0'	O
)	O
)	O
*	O
10	int
+	O
(	O
value	*(void)
[	O
2	int
]	O
-	O
'0'	O
)	O
;	O
}	O
else	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
case	O
'c'	O
:	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"content-encoding"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
wget_http_parse_content_encoding	(*(char),*(char))->(*(char))
(	O
value0	*(char)
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
content_encoding	char
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"content-type"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
if	O
(	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
content_type	*(char)
&&	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
content_type_encoding	*(char)
)	O
wget_http_parse_content_type	(*(char),*(*(char)),*(*(char)))->(*(char))
(	O
value0	*(char)
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
content_type	*(char)
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
content_type_encoding	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"content-length"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
content_length	long
=	O
(	O
size_t	long
)	O
atoll	(*(char))->(long long)
(	O
value0	*(char)
)	O
;	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
content_length_valid	bool
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"content-disposition"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
if	O
(	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
content_filename	*(char)
)	O
wget_http_parse_content_disposition	(*(char),*(*(char)))->(*(char))
(	O
value0	*(char)
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
content_filename	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"connection"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
wget_http_parse_connection	(*(char),*(char))->(*(char))
(	O
value0	*(char)
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
keep_alive	char
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"Content-Security-Policy"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
csp	bool
=	O
1	int
;	O
}	O
else	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"digest"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
wget_http_digest	struct(*(char),*(char))
digest	*(struct(*(char),*(char)))
;	O
wget_http_parse_digest	(*(char),*(struct(*(char),*(char))))->(*(char))
(	O
value0	*(char)
,	O
&	O
digest	*(struct(*(char),*(char)))
)	O
;	O
if	O
(	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
digests	*(struct)
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
digests	*(struct)
=	O
wget_vector_create	(int,*((*(void),*(void))->(int)))->(*(struct))
(	O
4	int
,	O
NULL	O
)	O
;	O
wget_vector_set_destructor	(*(struct),*((*(void))->(void)))->(void)
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
digests	*(struct)
,	O
(	O
wget_vector_destructor	(*(void))->(void)
*	O
)	O
wget_http_free_digest	(*(struct(*(char),*(char))))->(void)
)	O
;	O
}	O
wget_vector_add_memdup	(*(struct),*(void),long)->(int)
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
digests	*(struct)
,	O
&	O
digest	*(struct(*(char),*(char)))
,	O
sizeof	O
(	O
digest	*(struct(*(char),*(char)))
)	O
)	O
;	O
}	O
else	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
case	O
'e'	O
:	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"etag"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
if	O
(	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
etag	*(char)
)	O
wget_http_parse_etag	(*(char),*(*(char)))->(*(char))
(	O
value0	*(char)
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
etag	*(char)
)	O
;	O
}	O
else	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"icy-metaint"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
icy_metaint	int
=	O
atoi	(*(char))->(int)
(	O
value0	*(char)
)	O
;	O
}	O
else	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
case	O
'l'	O
:	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"last-modified"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
last_modified	long
=	O
wget_http_parse_full_date	(*(char))->(long)
(	O
value0	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
code	short
/	O
100	int
==	O
3	int
&&	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"location"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
if	O
(	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
location	*(char)
)	O
wget_http_parse_location	(*(char),*(*(char)))->(*(char))
(	O
value0	*(char)
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
location	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
code	short
/	O
100	int
==	O
3	int
&&	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"link"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
wget_http_link	struct(*(char),*(char),int,enum(int,int,int))
link	(*(char),*(char))->(int)
;	O
wget_http_parse_link	(*(char),*(struct(*(char),*(char),int,enum(int,int,int))))->(*(char))
(	O
value0	*(char)
,	O
&	O
link	(*(char),*(char))->(int)
)	O
;	O
if	O
(	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
links	*(struct)
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
links	*(struct)
=	O
wget_vector_create	(int,*((*(void),*(void))->(int)))->(*(struct))
(	O
8	int
,	O
NULL	O
)	O
;	O
wget_vector_set_destructor	(*(struct),*((*(void))->(void)))->(void)
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
links	*(struct)
,	O
(	O
wget_vector_destructor	(*(void))->(void)
*	O
)	O
wget_http_free_link	(*(struct(*(char),*(char),int,enum(int,int,int))))->(void)
)	O
;	O
}	O
wget_vector_add_memdup	(*(struct),*(void),long)->(int)
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
links	*(struct)
,	O
&	O
link	(*(char),*(char))->(int)
,	O
sizeof	O
(	O
link	(*(char),*(char))->(int)
)	O
)	O
;	O
}	O
else	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"public-key-pins"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
if	O
(	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
hpkp	*(*(struct))
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
hpkp	*(*(struct))
=	O
wget_hpkp_new	()->(*(struct))
(	O
)	O
;	O
wget_http_parse_public_key_pins	(*(char),*(struct))->(*(char))
(	O
value0	*(char)
,	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
hpkp	*(*(struct))
)	O
;	O
debug_printf	O
(	O
"new host pubkey pinnings added to hpkp db\n"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"proxy-authenticate"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
wget_http_challenge	struct(*(char),*(struct))
*	O
challenge	*(struct(*(char),*(struct)))
=	O
wget_malloc	(long)->(*(void))
(	O
sizeof	O
(	O
wget_http_challenge	struct(*(char),*(struct))
)	O
)	O
;	O
if	O
(	O
!	O
challenge	*(struct(*(char),*(struct)))
)	O
{	O
ret	int
=	O
WGET_E_MEMORY	int
;	O
goto	O
out	*(*(char))
;	O
}	O
wget_http_parse_challenge	(*(char),*(struct(*(char),*(struct))))->(*(char))
(	O
value0	*(char)
,	O
challenge	*(struct(*(char),*(struct)))
)	O
;	O
if	O
(	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
challenges	*(struct)
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
challenges	*(struct)
=	O
wget_vector_create	(int,*((*(void),*(void))->(int)))->(*(struct))
(	O
2	int
,	O
NULL	O
)	O
;	O
wget_vector_set_destructor	(*(struct),*((*(void))->(void)))->(void)
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
challenges	*(struct)
,	O
(	O
wget_vector_destructor	(*(void))->(void)
*	O
)	O
wget_http_free_challenge	(*(struct(*(char),*(struct))))->(void)
)	O
;	O
}	O
wget_vector_add	(*(struct),*(void))->(int)
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
challenges	*(struct)
,	O
challenge	*(struct(*(char),*(struct)))
)	O
;	O
}	O
else	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"set-cookie"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
wget_cookie	struct
*	O
cookie	*(struct)
;	O
wget_http_parse_setcookie	(*(char),*(*(struct)))->(*(char))
(	O
value0	*(char)
,	O
&	O
cookie	*(struct)
)	O
;	O
if	O
(	O
cookie	*(struct)
)	O
{	O
if	O
(	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
cookies	*(struct)
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
cookies	*(struct)
=	O
wget_vector_create	(int,*((*(void),*(void))->(int)))->(*(struct))
(	O
4	int
,	O
NULL	O
)	O
;	O
wget_vector_set_destructor	(*(struct),*((*(void))->(void)))->(void)
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
cookies	*(struct)
,	O
cookie_free	(*(void))->(void)
)	O
;	O
}	O
wget_vector_add	(*(struct),*(void))->(int)
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
cookies	*(struct)
,	O
cookie	*(struct)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"strict-transport-security"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
hsts	bool
=	O
1	int
;	O
wget_http_parse_strict_transport_security	(*(char),*(long),*(char))->(*(char))
(	O
value0	*(char)
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
hsts_maxage	long
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
hsts_include_subdomains	char
)	O
;	O
}	O
else	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
case	O
't'	O
:	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"transfer-encoding"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
wget_http_parse_transfer_encoding	(*(char),*(enum(int,int)))->(*(char))
(	O
value0	*(char)
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
transfer_encoding	enum(int,int)
)	O
;	O
}	O
else	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
case	O
'w'	O
:	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"www-authenticate"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
wget_http_challenge	struct(*(char),*(struct))
*	O
challenge	*(struct(*(char),*(struct)))
=	O
wget_malloc	(long)->(*(void))
(	O
sizeof	O
(	O
wget_http_challenge	struct(*(char),*(struct))
)	O
)	O
;	O
if	O
(	O
!	O
challenge	*(struct(*(char),*(struct)))
)	O
{	O
ret	int
=	O
WGET_E_MEMORY	int
;	O
goto	O
out	*(*(char))
;	O
}	O
wget_http_parse_challenge	(*(char),*(struct(*(char),*(struct))))->(*(char))
(	O
value0	*(char)
,	O
challenge	*(struct(*(char),*(struct)))
)	O
;	O
if	O
(	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
challenges	*(struct)
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
challenges	*(struct)
=	O
wget_vector_create	(int,*((*(void),*(void))->(int)))->(*(struct))
(	O
2	int
,	O
NULL	O
)	O
;	O
wget_vector_set_destructor	(*(struct),*((*(void))->(void)))->(void)
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
challenges	*(struct)
,	O
(	O
wget_vector_destructor	(*(void))->(void)
*	O
)	O
wget_http_free_challenge	(*(struct(*(char),*(struct))))->(void)
)	O
;	O
}	O
wget_vector_add	(*(struct),*(void))->(int)
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
challenges	*(struct)
,	O
challenge	*(struct(*(char),*(struct)))
)	O
;	O
}	O
else	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
case	O
'x'	O
:	O
if	O
(	O
!	O
wget_strncasecmp_ascii	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
"x-archive-orig-last-modified"	*(char)
,	O
namelen	*(long)
)	O
)	O
{	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
last_modified	long
=	O
wget_http_parse_full_date	(*(char))->(long)
(	O
value0	*(char)
)	O
;	O
}	O
else	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
default	O
:	O
ret	int
=	O
WGET_E_UNKNOWN	int
;	O
break	O
;	O
}	O
out	*(*(char))
:	O
if	O
(	O
value0	*(char)
!=	O
valuebuf	array(char)
)	O
xfree	O
(	O
value0	*(char)
)	O
;	O
return	O
ret	int
;	O
}	O
wget_http_response	struct
*	O
wget_http_parse_response_header	(*(char))->(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
(	O
char	O
*	O
buf	*(char)
)	O
{	O
char	O
*	O
eol	*(char)
;	O
wget_http_response	struct
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
=	O
wget_calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
wget_http_response	struct
)	O
)	O
;	O
if	O
(	O
!	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
return	O
NULL	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
" HTTP/%3hd.%3hd %3hd %31[^\r\n] "	*(char)
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
major	short
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
minor	short
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
code	short
,	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
reason	array(char)
)	O
>=	O
3	int
)	O
{	O
if	O
(	O
(	O
eol	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
buf	*(char)
+	O
10	int
,	O
'\n'	O
)	O
)	O
)	O
{	O
}	O
else	O
{	O
return	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
;	O
}	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
" ICY %3hd %31[^\r\n] "	*(char)
,	O
&	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
code	short
,	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
->	O
reason	array(char)
)	O
>=	O
1	int
)	O
{	O
if	O
(	O
(	O
eol	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
buf	*(char)
+	O
4	int
,	O
'\n'	O
)	O
)	O
)	O
{	O
}	O
else	O
{	O
return	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
;	O
}	O
}	O
else	O
{	O
error_printf	O
(	O
_	O
(	O
"HTTP response header not found\n"	*(char)
)	O
)	O
;	O
xfree	O
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
char	O
*	O
line	*(char)
=	O
eol	*(char)
+	O
1	int
;	O
eol	*(char)
&&	O
*	O
line	*(char)
&&	O
*	O
line	*(char)
!=	O
'\r'	O
&&	O
*	O
line	*(char)
!=	O
'\n'	O
;	O
line	*(char)
=	O
eol	*(char)
+	O
1	int
)	O
{	O
eol	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
line	*(char)
,	O
'\n'	O
)	O
;	O
while	O
(	O
eol	*(char)
&&	O
c_isblank	(int)->(bool)
(	O
eol	*(char)
[	O
1	int
]	O
)	O
)	O
{	O
*	O
eol	*(char)
=	O
eol	*(char)
[	O
-	O
1	int
]	O
=	O
' '	O
;	O
eol	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
eol	*(char)
,	O
'\n'	O
)	O
;	O
}	O
if	O
(	O
eol	*(char)
)	O
{	O
if	O
(	O
eol	*(char)
[	O
-	O
1	int
]	O
==	O
'\r'	O
)	O
eol	*(char)
[	O
-	O
1	int
]	O
=	O
0	int
;	O
else	O
*	O
eol	*(char)
=	O
0	int
;	O
}	O
size_t	long
namelen	*(long)
,	O
valuelen	long
;	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
value	*(void)
=	O
wget_parse_name_fixed	(*(char),*(*(char)),*(long))->(*(char))
(	O
line	*(char)
,	O
&	O
name	*(char)
,	O
&	O
namelen	*(long)
)	O
;	O
if	O
(	O
eol	*(char)
)	O
valuelen	long
=	O
eol	*(char)
-	O
value	*(void)
-	O
(	O
eol	*(char)
[	O
-	O
1	int
]	O
==	O
0	int
)	O
;	O
else	O
valuelen	long
=	O
strlen	(*(char))->(long)
(	O
value	*(void)
)	O
;	O
wget_http_parse_header_line	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)),*(char),long,*(char),long)->(int)
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
,	O
name	*(char)
,	O
namelen	*(long)
,	O
value	*(void)
,	O
valuelen	long
)	O
;	O
}	O
return	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
;	O
}	O
void	O
wget_http_free_param	(*(struct(*(char),*(char))))->(void)
(	O
wget_http_header_param	struct(*(char),*(char))
*	O
param	*(*(char))
)	O
{	O
xfree	O
(	O
param	*(*(char))
->	O
name	*(char)
)	O
;	O
xfree	O
(	O
param	*(*(char))
->	O
value	*(void)
)	O
;	O
xfree	O
(	O
param	*(*(char))
)	O
;	O
}	O
void	O
wget_http_free_link	(*(struct(*(char),*(char),int,enum(int,int,int))))->(void)
(	O
wget_http_link	struct(*(char),*(char),int,enum(int,int,int))
*	O
link	(*(char),*(char))->(int)
)	O
{	O
xfree	O
(	O
link	(*(char),*(char))->(int)
->	O
uri	*(char)
)	O
;	O
xfree	O
(	O
link	(*(char),*(char))->(int)
->	O
type	*(char)
)	O
;	O
xfree	O
(	O
link	(*(char),*(char))->(int)
)	O
;	O
}	O
void	O
wget_http_free_links	(*(*(struct)))->(void)
(	O
wget_vector	struct
*	O
*	O
links	*(struct)
)	O
{	O
wget_vector_free	(*(*(struct)))->(void)
(	O
links	*(struct)
)	O
;	O
}	O
void	O
wget_http_free_digest	(*(struct(*(char),*(char))))->(void)
(	O
wget_http_digest	struct(*(char),*(char))
*	O
digest	*(struct(*(char),*(char)))
)	O
{	O
xfree	O
(	O
digest	*(struct(*(char),*(char)))
->	O
algorithm	*(char)
)	O
;	O
xfree	O
(	O
digest	*(struct(*(char),*(char)))
->	O
encoded_digest	*(char)
)	O
;	O
xfree	O
(	O
digest	*(struct(*(char),*(char)))
)	O
;	O
}	O
void	O
wget_http_free_digests	(*(*(struct)))->(void)
(	O
wget_vector	struct
*	O
*	O
digests	*(struct)
)	O
{	O
wget_vector_free	(*(*(struct)))->(void)
(	O
digests	*(struct)
)	O
;	O
}	O
void	O
wget_http_free_challenge	(*(struct(*(char),*(struct))))->(void)
(	O
wget_http_challenge	struct(*(char),*(struct))
*	O
challenge	*(struct(*(char),*(struct)))
)	O
{	O
xfree	O
(	O
challenge	*(struct(*(char),*(struct)))
->	O
auth_scheme	*(char)
)	O
;	O
wget_stringmap_free	(*(*(struct)))->(void)
(	O
&	O
challenge	*(struct(*(char),*(struct)))
->	O
params	*(struct)
)	O
;	O
xfree	O
(	O
challenge	*(struct(*(char),*(struct)))
)	O
;	O
}	O
void	O
wget_http_free_challenges	(*(*(struct)))->(void)
(	O
wget_vector	struct
*	O
*	O
challenges	*(struct)
)	O
{	O
wget_vector_free	(*(*(struct)))->(void)
(	O
challenges	*(struct)
)	O
;	O
}	O
void	O
wget_http_free_cookies	(*(*(struct)))->(void)
(	O
wget_vector	struct
*	O
*	O
cookies	*(struct)
)	O
{	O
wget_vector_free	(*(*(struct)))->(void)
(	O
cookies	*(struct)
)	O
;	O
}	O
void	O
wget_http_free_hpkp_entries	(*(*(struct)))->(void)
(	O
wget_hpkp	struct
*	O
*	O
hpkp	*(*(struct))
)	O
{	O
if	O
(	O
hpkp	*(*(struct))
)	O
{	O
wget_hpkp_free	(*(struct))->(void)
(	O
*	O
hpkp	*(*(struct))
)	O
;	O
*	O
hpkp	*(*(struct))
=	O
NULL	O
;	O
}	O
}	O
void	O
wget_http_free_response	(*(*(struct(*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(struct`),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long))))->(void)
(	O
wget_http_response	struct
*	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
{	O
if	O
(	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
&&	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
{	O
wget_http_free_links	(*(*(struct)))->(void)
(	O
&	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
links	*(struct)
)	O
;	O
wget_http_free_digests	(*(*(struct)))->(void)
(	O
&	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
digests	*(struct)
)	O
;	O
wget_http_free_challenges	(*(*(struct)))->(void)
(	O
&	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
challenges	*(struct)
)	O
;	O
wget_http_free_cookies	(*(*(struct)))->(void)
(	O
&	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
cookies	*(struct)
)	O
;	O
wget_http_free_hpkp_entries	(*(*(struct)))->(void)
(	O
&	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
hpkp	*(*(struct))
)	O
;	O
xfree	O
(	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
content_type	*(char)
)	O
;	O
xfree	O
(	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
content_type_encoding	*(char)
)	O
;	O
xfree	O
(	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
content_filename	*(char)
)	O
;	O
xfree	O
(	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
location	*(char)
)	O
;	O
xfree	O
(	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
etag	*(char)
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
header	*(struct(*(char),long,long,bool,bool,bool))
)	O
;	O
wget_buffer_free	(*(*(struct(*(char),long,long,bool,bool,bool))))->(void)
(	O
&	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
->	O
body	*(char)
)	O
;	O
xfree	O
(	O
*	O
resp	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,struct`,struct`,long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)),*(struct),*(struct),*(struct),*(struct),*(struct),*(char),*(char),*(char),*(char),*(char),*(struct(*`,long,long,bool,bool,bool)),*(struct(*`,long,long,bool,bool,bool)),long,long,long,long,long,array(char),int,short,short,short,enum(int,int),char,char,char,bool,bool,bool,long long)))
)	O
;	O
}	O
}	O
void	O
wget_http_free_request	(*(*(struct(*(struct`),*(char),*((*`,*`)->(int)),*((*`,*`,*`,long)->(int)),*(void),*(void),*(void),struct(*`,long,long,bool,bool,bool),struct(*`,long,long,bool,bool,bool),long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long))))->(void)
(	O
wget_http_request	struct(*(struct),*(char),*((*(struct),*(void))->(int)),*((*(struct),*(void),*(char),long)->(int)),*(void),*(void),*(void),struct(*(char),long,long,bool,bool,bool),struct(*(char),long,long,bool,bool,bool),long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long)
*	O
*	O
req	*(struct(*(struct),*(char),*((*(struct`),*(void))->(int)),*((*(struct`),*(void),*(char),long)->(int)),*(void),*(void),*(void),struct(*(char),long,long,bool,bool,bool),struct(*(char),long,long,bool,bool,bool),long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long))
)	O
{	O
if	O
(	O
req	*(struct(*(struct),*(char),*((*(struct`),*(void))->(int)),*((*(struct`),*(void),*(char),long)->(int)),*(void),*(void),*(void),struct(*(char),long,long,bool,bool,bool),struct(*(char),long,long,bool,bool,bool),long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long))
&&	O
*	O
req	*(struct(*(struct),*(char),*((*(struct`),*(void))->(int)),*((*(struct`),*(void),*(char),long)->(int)),*(void),*(void),*(void),struct(*(char),long,long,bool,bool,bool),struct(*(char),long,long,bool,bool,bool),long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long))
)	O
{	O
wget_buffer_deinit	(*(struct(*(char),long,long,bool,bool,bool)))->(void)
(	O
&	O
(	O
*	O
req	*(struct(*(struct),*(char),*((*(struct`),*(void))->(int)),*((*(struct`),*(void),*(char),long)->(int)),*(void),*(void),*(void),struct(*(char),long,long,bool,bool,bool),struct(*(char),long,long,bool,bool,bool),long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long))
)	O
->	O
esc_resource	struct(*(char),long,long,bool,bool,bool)
)	O
;	O
wget_buffer_deinit	(*(struct(*(char),long,long,bool,bool,bool)))->(void)
(	O
&	O
(	O
*	O
req	*(struct(*(struct),*(char),*((*(struct`),*(void))->(int)),*((*(struct`),*(void),*(char),long)->(int)),*(void),*(void),*(void),struct(*(char),long,long,bool,bool,bool),struct(*(char),long,long,bool,bool,bool),long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long))
)	O
->	O
esc_host	struct(*(char),long,long,bool,bool,bool)
)	O
;	O
wget_vector_free	(*(*(struct)))->(void)
(	O
&	O
(	O
*	O
req	*(struct(*(struct),*(char),*((*(struct`),*(void))->(int)),*((*(struct`),*(void),*(char),long)->(int)),*(void),*(void),*(void),struct(*(char),long,long,bool,bool,bool),struct(*(char),long,long,bool,bool,bool),long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long))
)	O
->	O
headers	*(struct)
)	O
;	O
xfree	O
(	O
(	O
*	O
req	*(struct(*(struct),*(char),*((*(struct`),*(void))->(int)),*((*(struct`),*(void),*(char),long)->(int)),*(void),*(void),*(void),struct(*(char),long,long,bool,bool,bool),struct(*(char),long,long,bool,bool,bool),long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long))
)	O
->	O
body	*(char)
)	O
;	O
xfree	O
(	O
*	O
req	*(struct(*(struct),*(char),*((*(struct`),*(void))->(int)),*((*(struct`),*(void),*(char),long)->(int)),*(void),*(void),*(void),struct(*(char),long,long,bool,bool,bool),struct(*(char),long,long,bool,bool,bool),long,int,enum(int,int),array(char),array(char),array(char),bool,bool,long long,long long))
)	O
;	O
}	O
}	O
