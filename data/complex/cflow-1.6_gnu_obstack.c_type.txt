static	O
void	O
*	O
call_chunkfun	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),long)->(*(void))
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
*	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
use_extra_arg	int
)	O
return	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunkfun	union(*((long)->(*(void))),*((*(void),long)->(*(void))))
.	O
extra	*((*(void),long)->(*(void)))
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
extra_arg	*(void)
,	O
size	long
)	O
;	O
else	O
return	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunkfun	union(*((long)->(*(void))),*((*(void),long)->(*(void))))
.	O
plain	*((long)->(*(void)))
(	O
size	long
)	O
;	O
}	O
static	O
void	O
call_freefun	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),*(void))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
*	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
void	O
*	O
old_chunk	*(void)
)	O
{	O
if	O
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
use_extra_arg	int
)	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
freefun	union(*((*(void))->(void)),*((*(void),*(void))->(void)))
.	O
extra	*((*(void),long)->(*(void)))
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
extra_arg	*(void)
,	O
old_chunk	*(void)
)	O
;	O
else	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
freefun	union(*((*(void))->(void)),*((*(void),*(void))->(void)))
.	O
plain	*((long)->(*(void)))
(	O
old_chunk	*(void)
)	O
;	O
}	O
static	O
int	O
_obstack_begin_worker	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),long,long)->(int)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
*	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
_OBSTACK_SIZE_T	O
size	long
,	O
_OBSTACK_SIZE_T	O
alignment	long
)	O
{	O
struct	O
_obstack_chunk	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),array(char))
*	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
if	O
(	O
alignment	long
==	O
0	int
)	O
alignment	long
=	O
DEFAULT_ALIGNMENT	O
;	O
if	O
(	O
size	long
==	O
0	int
)	O
{	O
int	O
extra	*((*(void),long)->(*(void)))
=	O
(	O
(	O
(	O
(	O
12	int
+	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
&	O
~	O
(	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
)	O
+	O
4	int
+	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
&	O
~	O
(	O
DEFAULT_ROUNDING	O
-	O
1	int
)	O
)	O
;	O
size	long
=	O
4096	int
-	O
extra	*((*(void),long)->(*(void)))
;	O
}	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk_size	long
=	O
size	long
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
alignment_mask	long
=	O
alignment	long
-	O
1	int
;	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
call_chunkfun	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),long)->(*(void))
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk_size	long
)	O
;	O
if	O
(	O
!	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
(	O
*	O
obstack_alloc_failed_handler	*(()->(void))
)	O
(	O
)	O
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
next_free	*(char)
=	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
object_base	*(char)
=	O
__PTR_ALIGN	O
(	O
(	O
char	O
*	O
)	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
,	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
contents	array(char)
,	O
alignment	long
-	O
1	int
)	O
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk_limit	*(char)
=	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
limit	*(char)
=	O
(	O
char	O
*	O
)	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
+	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk_size	long
;	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
0	int
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
maybe_empty_object	int
=	O
0	int
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
alloc_failed	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
_obstack_begin	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),long,long,*((long)->(*(void))),*((*(void))->(void)))->(int)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
*	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
_OBSTACK_SIZE_T	O
size	long
,	O
_OBSTACK_SIZE_T	O
alignment	long
,	O
void	O
*	O
(	O
*	O
chunkfun	union(*((long)->(*(void))),*((*(void),long)->(*(void))))
)	O
(	O
size_t	long
)	O
,	O
void	O
(	O
*	O
freefun	union(*((*(void))->(void)),*((*(void),*(void))->(void)))
)	O
(	O
void	O
*	O
)	O
)	O
{	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunkfun	union(*((long)->(*(void))),*((*(void),long)->(*(void))))
.	O
plain	*((long)->(*(void)))
=	O
chunkfun	union(*((long)->(*(void))),*((*(void),long)->(*(void))))
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
freefun	union(*((*(void))->(void)),*((*(void),*(void))->(void)))
.	O
plain	*((long)->(*(void)))
=	O
freefun	union(*((*(void))->(void)),*((*(void),*(void))->(void)))
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
use_extra_arg	int
=	O
0	int
;	O
return	O
_obstack_begin_worker	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),long,long)->(int)
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
size	long
,	O
alignment	long
)	O
;	O
}	O
int	O
_obstack_begin_1	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),long,long,*((*(void),long)->(*(void))),*((*(void),*(void))->(void)),*(void))->(int)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
*	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
_OBSTACK_SIZE_T	O
size	long
,	O
_OBSTACK_SIZE_T	O
alignment	long
,	O
void	O
*	O
(	O
*	O
chunkfun	union(*((long)->(*(void))),*((*(void),long)->(*(void))))
)	O
(	O
void	O
*	O
,	O
size_t	long
)	O
,	O
void	O
(	O
*	O
freefun	union(*((*(void))->(void)),*((*(void),*(void))->(void)))
)	O
(	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
arg	*(void)
)	O
{	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunkfun	union(*((long)->(*(void))),*((*(void),long)->(*(void))))
.	O
extra	*((*(void),long)->(*(void)))
=	O
chunkfun	union(*((long)->(*(void))),*((*(void),long)->(*(void))))
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
freefun	union(*((*(void))->(void)),*((*(void),*(void))->(void)))
.	O
extra	*((*(void),long)->(*(void)))
=	O
freefun	union(*((*(void))->(void)),*((*(void),*(void))->(void)))
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
extra_arg	*(void)
=	O
arg	*(void)
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
use_extra_arg	int
=	O
1	int
;	O
return	O
_obstack_begin_worker	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),long,long)->(int)
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
size	long
,	O
alignment	long
)	O
;	O
}	O
void	O
_obstack_newchunk	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),long)->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
*	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
_OBSTACK_SIZE_T	O
length	long
)	O
{	O
struct	O
_obstack_chunk	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),array(char))
*	O
old_chunk	*(void)
=	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
struct	O
_obstack_chunk	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),array(char))
*	O
new_chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
0	int
;	O
size_t	long
obj_size	long
=	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
next_free	*(char)
-	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
object_base	*(char)
;	O
char	O
*	O
object_base	*(char)
;	O
size_t	long
sum1	long
=	O
obj_size	long
+	O
length	long
;	O
size_t	long
sum2	long
=	O
sum1	long
+	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
alignment_mask	long
;	O
size_t	long
new_size	long
=	O
sum2	long
+	O
(	O
obj_size	long
>>	O
3	int
)	O
+	O
100	int
;	O
if	O
(	O
new_size	long
<	O
sum2	long
)	O
new_size	long
=	O
sum2	long
;	O
if	O
(	O
new_size	long
<	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk_size	long
)	O
new_size	long
=	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk_size	long
;	O
if	O
(	O
obj_size	long
<=	O
sum1	long
&&	O
sum1	long
<=	O
sum2	long
)	O
new_chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
call_chunkfun	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),long)->(*(void))
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
new_size	long
)	O
;	O
if	O
(	O
!	O
new_chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
(	O
*	O
obstack_alloc_failed_handler	*(()->(void))
)	O
(	O
)	O
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
new_chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
new_chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
old_chunk	*(void)
;	O
new_chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
limit	*(char)
=	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk_limit	*(char)
=	O
(	O
char	O
*	O
)	O
new_chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
+	O
new_size	long
;	O
object_base	*(char)
=	O
__PTR_ALIGN	O
(	O
(	O
char	O
*	O
)	O
new_chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
,	O
new_chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
contents	array(char)
,	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
alignment_mask	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
object_base	*(char)
,	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
object_base	*(char)
,	O
obj_size	long
)	O
;	O
if	O
(	O
!	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
maybe_empty_object	int
&&	O
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
object_base	*(char)
==	O
__PTR_ALIGN	O
(	O
(	O
char	O
*	O
)	O
old_chunk	*(void)
,	O
old_chunk	*(void)
->	O
contents	array(char)
,	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
alignment_mask	long
)	O
)	O
)	O
{	O
new_chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
old_chunk	*(void)
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
call_freefun	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),*(void))->(void)
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
old_chunk	*(void)
)	O
;	O
}	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
object_base	*(char)
=	O
object_base	*(char)
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
next_free	*(char)
=	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
object_base	*(char)
+	O
obj_size	long
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
maybe_empty_object	int
=	O
0	int
;	O
}	O
int	O
_obstack_allocated_p	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),*(void))->(int)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
*	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
void	O
*	O
obj	*(void)
)	O
__attribute_pure__	O
;	O
int	O
_obstack_allocated_p	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),*(void))->(int)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
*	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
void	O
*	O
obj	*(void)
)	O
{	O
struct	O
_obstack_chunk	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),array(char))
*	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
struct	O
_obstack_chunk	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),array(char))
*	O
plp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
)	O
->	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
while	O
(	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
!=	O
0	int
&&	O
(	O
(	O
void	O
*	O
)	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
>=	O
obj	*(void)
||	O
(	O
void	O
*	O
)	O
(	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
->	O
limit	*(char)
<	O
obj	*(void)
)	O
)	O
{	O
plp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
plp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
}	O
return	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
!=	O
0	int
;	O
}	O
void	O
_obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),*(void))->(void)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
*	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
void	O
*	O
obj	*(void)
)	O
{	O
struct	O
_obstack_chunk	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),array(char))
*	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
struct	O
_obstack_chunk	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),array(char))
*	O
plp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
while	O
(	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
!=	O
0	int
&&	O
(	O
(	O
void	O
*	O
)	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
>=	O
obj	*(void)
||	O
(	O
void	O
*	O
)	O
(	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
->	O
limit	*(char)
<	O
obj	*(void)
)	O
)	O
{	O
plp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
call_freefun	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)),*(void))->(void)
(	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
,	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
;	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
plp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
maybe_empty_object	int
=	O
1	int
;	O
}	O
if	O
(	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
{	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
object_base	*(char)
=	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
next_free	*(char)
=	O
(	O
char	O
*	O
)	O
(	O
obj	*(void)
)	O
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk_limit	*(char)
=	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
limit	*(char)
;	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
}	O
else	O
if	O
(	O
obj	*(void)
!=	O
0	int
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
_OBSTACK_SIZE_T	O
_obstack_memory_used	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))->(long)
(	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
*	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
)	O
{	O
struct	O
_obstack_chunk	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),array(char))
*	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
_OBSTACK_SIZE_T	O
nbytes	long
=	O
0	int
;	O
for	O
(	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
h	*(struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int))
->	O
chunk	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
!=	O
0	int
;	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
=	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
prev	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
)	O
{	O
nbytes	long
+=	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
->	O
limit	*(char)
-	O
(	O
char	O
*	O
)	O
lp	*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char)))
;	O
}	O
return	O
nbytes	long
;	O
}	O
static	O
_Noreturn	O
void	O
print_and_abort	()->(void)
(	O
void	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
_	O
(	O
"memory exhausted"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
obstack_exit_failure	int
)	O
;	O
}	O
__attribute_noreturn__	O
void	O
(	O
*	O
obstack_alloc_failed_handler	*(()->(void))
)	O
(	O
void	O
)	O
=	O
print_and_abort	()->(void)
;	O
