typedef	O
enum	O
color	enum(int,int)
{	O
BLACK	int
,	O
RED	int
}	O
color_t	enum(int,int)
;	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
{	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
*	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
*	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
*	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
color_t	enum(int,int)
color	enum(int,int)
;	O
const	O
void	O
*	O
value	*(void)
;	O
}	O
;	O
typedef	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
*	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
struct	O
gl_oset_impl	struct(struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*((*(void),*(void))->(int)),*((*(void))->(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),long)
{	O
struct	O
gl_oset_impl_base	struct(*(struct(*((*(struct`),*((*`,*`)->(int)),*((*`)->(void)))->(*(struct`))),*((*(struct`))->(long)),*((*(struct`),*(void))->(bool)),*((*(struct`),*((*`,*`)->(bool)),*(void),*(*`))->(bool)),*((*(struct`),*(void))->(int)),*((*(struct`),*(void))->(bool)),*((*(struct`))->(void)),*((*(struct`))->(struct(*`,*`,long,*`,*`,long,long))),*((*(struct`),*(*`))->(bool)),*((*(struct`))->(void)))),*((*(void),*(void))->(int)),*((*(void))->(void)))
base	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*((*(void),*(void))->(int)),*((*(void))->(void)))
;	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
*	O
root	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
size_t	long
count	long
;	O
}	O
;	O
static	O
inline	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
rotate_left	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
c_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
c_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
c_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
)	O
c_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
return	O
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
static	O
inline	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
rotate_right	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
c_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
c_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
c_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
)	O
c_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
d_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
return	O
b_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
static	O
void	O
rebalance_after_add	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(void)
(	O
gl_oset_t	*(struct)
set	*(struct)
,	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
uncle	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
BLACK	int
)	O
{	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
return	O
;	O
}	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
uncle	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
if	O
(	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
uncle	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
uncle	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
&&	O
uncle	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
RED	int
)	O
{	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
uncle	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
else	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
*	O
grandparentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
;	O
if	O
(	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
grandparentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
&	O
set	*(struct)
->	O
root	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
if	O
(	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
grandparentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
&	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
if	O
(	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
grandparentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
&	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
rotate_left	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
*	O
grandparentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
rotate_right	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
}	O
else	O
{	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
rotate_right	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
*	O
grandparentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
rotate_left	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
grandparent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
}	O
return	O
;	O
}	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
{	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
rebalance_after_remove	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(void)
(	O
gl_oset_t	*(struct)
set	*(struct)
,	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
*	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
;	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
&	O
set	*(struct)
->	O
root	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
&	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
&	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
RED	int
)	O
{	O
*	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
rotate_left	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
&	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
if	O
(	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
&&	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
RED	int
)	O
{	O
*	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
rotate_left	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
return	O
;	O
}	O
else	O
if	O
(	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
&&	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
RED	int
)	O
{	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
rotate_right	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
*	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
rotate_left	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
BLACK	int
)	O
{	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
else	O
{	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
return	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
RED	int
)	O
{	O
*	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
rotate_right	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
&	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
if	O
(	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
&&	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
RED	int
)	O
{	O
*	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
rotate_right	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
return	O
;	O
}	O
else	O
if	O
(	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
&&	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
RED	int
)	O
{	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
rotate_left	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
*	O
parentp	*(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
=	O
rotate_right	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
BLACK	int
)	O
{	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
else	O
{	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
sibling	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
RED	int
;	O
return	O
;	O
}	O
}	O
}	O
else	O
abort	()->(void)
(	O
)	O
;	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
return	O
;	O
}	O
}	O
static	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
gl_tree_nx_add_first	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(void))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
gl_oset_t	*(struct)
set	*(struct)
,	O
const	O
void	O
*	O
elt	*(void)
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
(	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
)	O
)	O
;	O
if	O
(	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
NULL	O
;	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
NULL	O
;	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
value	*(void)
=	O
elt	*(void)
;	O
if	O
(	O
set	*(struct)
->	O
root	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
{	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
set	*(struct)
->	O
root	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
NULL	O
;	O
}	O
else	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
for	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
set	*(struct)
->	O
root	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
;	O
)	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
rebalance_after_add	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(void)
(	O
set	*(struct)
,	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
}	O
set	*(struct)
->	O
count	long
++	O
;	O
return	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
static	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
gl_tree_nx_add_before	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(void))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
gl_oset_t	*(struct)
set	*(struct)
,	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
const	O
void	O
*	O
elt	*(void)
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
(	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
)	O
)	O
;	O
if	O
(	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
NULL	O
;	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
NULL	O
;	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
value	*(void)
=	O
elt	*(void)
;	O
if	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
{	O
for	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
;	O
)	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
rebalance_after_add	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(void)
(	O
set	*(struct)
,	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
set	*(struct)
->	O
count	long
++	O
;	O
return	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
static	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
gl_tree_nx_add_after	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(void))->(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))
(	O
gl_oset_t	*(struct)
set	*(struct)
,	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
const	O
void	O
*	O
elt	*(void)
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
(	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
gl_oset_node_impl	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void))),enum(int,int),*(void))
)	O
)	O
;	O
if	O
(	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
NULL	O
;	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
NULL	O
;	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
value	*(void)
=	O
elt	*(void)
;	O
if	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
{	O
for	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
;	O
)	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
rebalance_after_add	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(void)
(	O
set	*(struct)
,	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
set	*(struct)
->	O
count	long
++	O
;	O
return	O
new_node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
static	O
bool	bool
gl_tree_remove_node	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(bool)
(	O
gl_oset_t	*(struct)
set	*(struct)
,	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
)	O
{	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
}	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
set	*(struct)
->	O
root	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
{	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
&&	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
BLACK	int
)	O
rebalance_after_remove	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(void)
(	O
set	*(struct)
,	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
set	*(struct)
->	O
root	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
{	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
}	O
else	O
{	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
subst_parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
color_t	enum(int,int)
removed_color	enum(int,int)
;	O
for	O
(	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
;	O
)	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
subst_parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
removed_color	enum(int,int)
=	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
;	O
if	O
(	O
subst_parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
if	O
(	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
)	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
subst_parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
subst_parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
if	O
(	O
subst_parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
{	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
}	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
;	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
)	O
set	*(struct)
->	O
root	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
else	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
=	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
;	O
if	O
(	O
removed_color	enum(int,int)
==	O
BLACK	int
)	O
{	O
if	O
(	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
&&	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
RED	int
)	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
=	O
BLACK	int
;	O
else	O
rebalance_after_remove	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))))->(void)
(	O
set	*(struct)
,	O
child	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
subst_parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
?	O
subst_parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
:	O
subst	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
}	O
}	O
set	*(struct)
->	O
count	long
--	O
;	O
if	O
(	O
set	*(struct)
->	O
base	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*((*(void),*(void))->(int)),*((*(void))->(void)))
.	O
dispose_fn	*((*(void))->(void))
!=	O
NULL	O
)	O
set	*(struct)
->	O
base	struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*((*(void),*(void))->(int)),*((*(void))->(void)))
.	O
dispose_fn	*((*(void))->(void))
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
value	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
;	O
return	O
true	int
;	O
}	O
static	O
unsigned	O
int	O
check_invariants	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(long))->(int)
(	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
gl_oset_node_t	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
size_t	long
*	O
counterp	*(long)
)	O
{	O
unsigned	O
int	O
left_blackheight	int
=	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
?	O
check_invariants	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(long))->(int)
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
left	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
counterp	*(long)
)	O
:	O
0	int
)	O
;	O
unsigned	O
int	O
right_blackheight	int
=	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
?	O
check_invariants	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(long))->(int)
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
right	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
counterp	*(long)
)	O
:	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
BLACK	int
||	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
RED	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
parent	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
==	O
NULL	O
&&	O
!	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
BLACK	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
(	O
left_blackheight	int
==	O
right_blackheight	int
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
(	O
*	O
counterp	*(long)
)	O
++	O
;	O
return	O
left_blackheight	int
+	O
(	O
node	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
->	O
color	enum(int,int)
==	O
BLACK	int
?	O
1	int
:	O
0	int
)	O
;	O
}	O
void	O
gl_rbtree_oset_check_invariants	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)))->(void)
(	O
gl_oset_t	*(struct)
set	*(struct)
)	O
{	O
size_t	long
counter	long
=	O
0	int
;	O
if	O
(	O
set	*(struct)
->	O
root	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
!=	O
NULL	O
)	O
check_invariants	(*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(struct(*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),*(struct(*`,*`,*`,enum(int,int),*`)),enum(int,int),*(void))),*(long))->(int)
(	O
set	*(struct)
->	O
root	*(struct(*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int),*(void))),enum(int,int),*(void)))
,	O
NULL	O
,	O
&	O
counter	long
)	O
;	O
if	O
(	O
!	O
(	O
set	*(struct)
->	O
count	long
==	O
counter	long
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
const	O
struct	O
gl_oset_implementation	struct(*((*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*((*(void),*(void))->(int)),*((*(void))->(void)))->(*(struct))),*((*(struct))->(long)),*((*(struct),*(void))->(bool)),*((*(struct),*((*(void),*(void))->(bool)),*(void),*(*(void)))->(bool)),*((*(struct),*(void))->(int)),*((*(struct),*(void))->(bool)),*((*(struct))->(void)),*((*(struct))->(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct),long,*(void),*(void),long,long))),*((*(struct(*(struct`),*(struct`),long,*(void),*(void),long,long)),*(*(void)))->(bool)),*((*(struct(*(struct`),*(struct`),long,*(void),*(void),long,long)))->(void)))
gl_rbtree_oset_implementation	struct(*((*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*((*`,*`)->(int)),*((*`)->(void)))->(*(struct))),*((*(struct))->(long)),*((*(struct),*(void))->(bool)),*((*(struct),*((*`,*`)->(bool)),*(void),*(*(void)))->(bool)),*((*(struct),*(void))->(int)),*((*(struct),*(void))->(bool)),*((*(struct))->(void)),*((*(struct))->(struct(*(struct`),*(struct`),long,*(void),*(void),long,long))),*((*(struct(*`,*`,long,*`,*`,long,long)),*(*(void)))->(bool)),*((*(struct(*`,*`,long,*`,*`,long,long)))->(void)))
=	O
{	O
gl_tree_nx_create_empty	(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*((*(void),*(void))->(int)),*((*(void))->(void)))->(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)))
,	O
gl_tree_size	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)))->(long)
,	O
gl_tree_search	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(void))->(bool)
,	O
gl_tree_search_atleast	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*((*(void),*(void))->(bool)),*(void),*(*(void)))->(bool)
,	O
gl_tree_nx_add	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(void))->(int)
,	O
gl_tree_remove	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)),*(void))->(bool)
,	O
gl_tree_oset_free	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)))->(void)
,	O
gl_tree_iterator	(*(struct(struct(*(struct`),*((*`,*`)->(int)),*((*`)->(void))),*(struct(*`,*`,*`,enum(int,int),*`)),long)))->(struct(*(struct(*((*`,*`,*`)->(*`)),*((*`)->(long)),*((*`,*`)->(bool)),*((*`,*`,*`,*`)->(bool)),*((*`,*`)->(int)),*((*`,*`)->(bool)),*((*`)->(void)),*((*`)->(struct`)),*((*`,*`)->(bool)),*((*`)->(void)))),*(struct(struct(*`,*`,*`),*(struct`),long)),long,*(void),*(void),long,long))
,	O
gl_tree_iterator_next	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(struct`,*`,long)),long,*(void),*(void),long,long)),*(*(void)))->(bool)
,	O
gl_tree_iterator_free	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(struct(struct`,*`,long)),long,*(void),*(void),long,long)))->(void)
}	O
;	O
