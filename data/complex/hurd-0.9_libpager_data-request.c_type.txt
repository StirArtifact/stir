kern_return_t	O
_pager_S_memory_object_data_request	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)),int,int,int,int)->(int)
(	O
struct	O
pager	struct(struct,*(struct),enum(int,int,int),int,int,*(struct),*(struct),int,int,int,int,int,int,int,*(short),int)
*	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
,	O
mach_port_t	O
control	int
,	O
vm_offset_t	int
offset	int
,	O
vm_size_t	int
length	int
,	O
vm_prot_t	int
access	int
)	O
{	O
short	O
*	O
pm_entry	*(short)
;	O
int	O
doread	int
,	O
doerror	int
;	O
error_t	int
err	O
;	O
vm_address_t	int
page	O
;	O
int	O
write_lock	int
;	O
if	O
(	O
!	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
||	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
port	struct
.	O
class	O
!=	O
_pager_class	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
if	O
(	O
control	int
!=	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
memobjcntl	int
)	O
{	O
printf	O
(	O
"incg data request: wrong control port\n"	*(char)
)	O
;	O
goto	O
release_out	O
;	O
}	O
if	O
(	O
length	int
!=	O
__vm_page_size	O
)	O
{	O
printf	O
(	O
"incg data request: bad length size %zd\n"	*(char)
,	O
length	int
)	O
;	O
goto	O
release_out	O
;	O
}	O
if	O
(	O
offset	int
%	O
__vm_page_size	O
)	O
{	O
printf	O
(	O
"incg data request: misaligned request\n"	*(char)
)	O
;	O
goto	O
release_out	O
;	O
}	O
_pager_block_termination	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)))->(void)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
)	O
;	O
if	O
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
pager_state	enum(int,int,int)
!=	O
NORMAL	int
)	O
{	O
printf	O
(	O
"pager in wrong state for read\n"	*(char)
)	O
;	O
goto	O
allow_release_out	O
;	O
}	O
err	O
=	O
_pager_pagemap_resize	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)),int)->(int)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
,	O
offset	int
+	O
length	int
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
allow_release_out	O
;	O
pm_entry	*(short)
=	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
pagemap	*(short)
[	O
offset	int
/	O
__vm_page_size	O
]	O
;	O
if	O
(	O
*	O
pm_entry	*(short)
&	O
PM_PAGINGOUT	int
)	O
{	O
doread	int
=	O
0	int
;	O
*	O
pm_entry	*(short)
|=	O
PM_PAGEINWAIT	int
;	O
}	O
else	O
doread	int
=	O
1	int
;	O
if	O
(	O
*	O
pm_entry	*(short)
&	O
PM_INVALID	int
)	O
doerror	int
=	O
1	int
;	O
else	O
doerror	int
=	O
0	int
;	O
*	O
pm_entry	*(short)
|=	O
PM_INCORE	int
;	O
if	O
(	O
PM_NEXTERROR	O
(	O
*	O
pm_entry	*(short)
)	O
!=	O
PAGE_NOERR	int
&&	O
(	O
access	int
&	O
VM_PROT_WRITE	O
)	O
)	O
{	O
memory_object_data_error	()->(int)
(	O
control	int
,	O
offset	int
,	O
length	int
,	O
_pager_page_errors	array(int)
[	O
PM_NEXTERROR	O
(	O
*	O
pm_entry	*(short)
)	O
]	O
)	O
;	O
_pager_mark_object_error	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)),int,int,int)->(void)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
,	O
offset	int
,	O
length	int
,	O
_pager_page_errors	array(int)
[	O
PM_NEXTERROR	O
(	O
*	O
pm_entry	*(short)
)	O
]	O
)	O
;	O
*	O
pm_entry	*(short)
=	O
SET_PM_NEXTERROR	O
(	O
*	O
pm_entry	*(short)
,	O
PAGE_NOERR	int
)	O
;	O
doread	int
=	O
0	int
;	O
}	O
pthread_mutex_unlock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
if	O
(	O
!	O
doread	int
)	O
goto	O
allow_term_out	O
;	O
if	O
(	O
doerror	int
)	O
goto	O
error_read	O
;	O
err	O
=	O
pager_read_page	()->(int)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
upi	*(struct)
,	O
offset	int
,	O
&	O
page	O
,	O
&	O
write_lock	int
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
error_read	O
;	O
memory_object_data_supply	()->(int)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
memobjcntl	int
,	O
offset	int
,	O
page	O
,	O
length	int
,	O
1	int
,	O
write_lock	int
?	O
VM_PROT_WRITE	O
:	O
VM_PROT_NONE	O
,	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
notify_on_evict	int
?	O
1	int
:	O
0	int
,	O
MACH_PORT_NULL	O
)	O
;	O
pthread_mutex_lock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
_pager_mark_object_error	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)),int,int,int)->(void)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
,	O
offset	int
,	O
length	int
,	O
0	int
)	O
;	O
_pager_allow_termination	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)))->(void)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
return	O
0	int
;	O
error_read	O
:	O
memory_object_data_error	()->(int)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
memobjcntl	int
,	O
offset	int
,	O
length	int
,	O
EIO	O
)	O
;	O
_pager_mark_object_error	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)),int,int,int)->(void)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
,	O
offset	int
,	O
length	int
,	O
EIO	O
)	O
;	O
allow_term_out	O
:	O
pthread_mutex_lock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
_pager_allow_termination	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)))->(void)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
)	O
;	O
pthread_mutex_unlock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
return	O
0	int
;	O
allow_release_out	O
:	O
_pager_allow_termination	(*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*`,*`,int,int,int,int,int)),*(struct(*`,*`,int,int,int,int)),int,int,int,int,int,int,int,*(short),int)))->(void)
(	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
)	O
;	O
release_out	O
:	O
pthread_mutex_unlock	()->(int)
(	O
&	O
p	*(struct(struct,*(struct),enum(int,int,int),int,int,*(struct(*(struct`),*(*`),int,int,int,int,int)),*(struct(*(struct`),*(*`),int,int,int,int)),int,int,int,int,int,int,int,*(short),int))
->	O
interlock	int
)	O
;	O
return	O
0	int
;	O
}	O
