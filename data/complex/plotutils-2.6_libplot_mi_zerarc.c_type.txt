typedef	O
struct	O
{	O
bool	enum(int,int)
skipStart	enum(int,int)
;	O
bool	enum(int,int)
haveStart	enum(int,int)
;	O
miPoint	struct(int,int)
startPt	struct(int,int)
;	O
bool	enum(int,int)
haveLast	enum(int,int)
;	O
bool	enum(int,int)
skipLast	enum(int,int)
;	O
miPoint	struct(int,int)
endPt	struct(int,int)
;	O
int	O
dashNum	int
;	O
int	O
dashIndex	int
;	O
int	O
dashOffset	int
;	O
int	O
dashNumInit	int
;	O
int	O
dashIndexInit	int
;	O
int	O
dashOffsetInit	int
;	O
}	O
miDashInfo	struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int)
;	O
static	O
const	O
miZeroArcPt	struct(int,int,int)
_oob_arc_pt	struct(int,int,int)
=	O
{	O
INT_MAX	O
,	O
INT_MAX	O
,	O
0	int
}	O
;	O
static	O
bool	enum(int,int)
miZeroArcSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,struct(int,int,int),struct(int,int,int),struct(int,int,int),struct(int,int,int),int,int,int,int)),enum(int,int))->(enum(int,int))
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miZeroArc	struct(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,struct(int,int,int),struct(int,int,int),struct(int,int,int),struct(int,int,int),int,int,int,int)
*	O
info	*(struct(*(char),char,char,char))
,	O
bool	enum(int,int)
ok360	enum(int,int)
)	O
;	O
static	O
miPoint	struct(int,int)
*	O
miZeroArcPts	(*(struct(int,int,int,int,int,int)),*(struct(int,int)))->(*(struct(int,int)))
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miPoint	struct(int,int)
*	O
pts	array(struct(int,int))
)	O
;	O
static	O
void	O
miZeroArcDashPts	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int)),int,*(*(struct(int,int))))->(void)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miDashInfo	struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int)
*	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
,	O
int	O
maxPts	int
,	O
miPoint	struct(int,int)
*	O
*	O
pts	array(struct(int,int))
)	O
;	O
void	O
miZeroPolyArc_r	O
(	O
miPaintedSet	struct
*	O
paintedSet	*(struct)
,	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
int	O
narcs	int
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
parcs	*(struct(int,int,int,int,int,int))
,	O
miEllipseCache	struct
*	O
ellipseCache	*(struct)
)	O
{	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
;	O
miDashInfo	struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int)
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
;	O
int	O
j	int
;	O
if	O
(	O
pGC	*(struct)
->	O
lineStyle	int
!=	O
(	O
int	O
)	O
MI_LINE_SOLID	int
)	O
{	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
.	O
haveStart	enum(int,int)
=	O
false	int
;	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
.	O
skipStart	enum(int,int)
=	O
false	int
;	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
.	O
haveLast	enum(int,int)
=	O
false	int
;	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
.	O
dashIndexInit	int
=	O
0	int
;	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
.	O
dashNumInit	int
=	O
0	int
;	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
.	O
dashOffsetInit	int
=	O
0	int
;	O
miStepDash	O
(	O
pGC	*(struct)
->	O
dashOffset	int
,	O
&	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
.	O
dashNumInit	int
,	O
&	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
.	O
dashIndexInit	int
,	O
pGC	*(struct)
->	O
dash	*(int)
,	O
pGC	*(struct)
->	O
numInDashList	int
,	O
&	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
.	O
dashOffsetInit	int
)	O
;	O
}	O
for	O
(	O
arc	*(struct(int,int,int,int,int,int))
=	O
parcs	*(struct(int,int,int,int,int,int))
,	O
j	int
=	O
narcs	int
;	O
--	O
j	int
>=	O
0	int
;	O
arc	*(struct(int,int,int,int,int,int))
++	O
)	O
{	O
if	O
(	O
!	O
MI_CAN_ZERO_ARC	O
(	O
arc	*(struct(int,int,int,int,int,int))
)	O
)	O
miPolyArc_r	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
,	O
1	int
,	O
arc	*(struct(int,int,int,int,int,int))
,	O
ellipseCache	*(struct)
)	O
;	O
else	O
{	O
miPoint	struct(int,int)
*	O
*	O
ptsInit	*(*(struct(int,int)))
,	O
*	O
*	O
pts	array(struct(int,int))
;	O
int	O
maxPts	int
=	O
0	int
,	O
numPts	int
,	O
i	int
,	O
n	array(double)
;	O
int	O
numPixels	int
=	O
pGC	*(struct)
->	O
numPixels	int
;	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
>	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
maxPts	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
+	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
)	O
;	O
else	O
maxPts	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
+	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
>>	O
1	int
)	O
;	O
if	O
(	O
maxPts	int
==	O
0	int
)	O
continue	O
;	O
numPts	int
=	O
4	int
*	O
maxPts	int
;	O
ptsInit	*(*(struct(int,int)))
=	O
(	O
miPoint	struct(int,int)
*	O
*	O
)	O
mi_xmalloc	O
(	O
numPixels	int
*	O
sizeof	O
(	O
miPoint	struct(int,int)
*	O
)	O
)	O
;	O
pts	array(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
*	O
)	O
mi_xmalloc	O
(	O
numPixels	int
*	O
sizeof	O
(	O
miPoint	struct(int,int)
*	O
)	O
)	O
;	O
if	O
(	O
pGC	*(struct)
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_SOLID	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numPixels	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
1	int
)	O
ptsInit	*(*(struct(int,int)))
[	O
i	int
]	O
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
numPts	int
*	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
)	O
;	O
else	O
ptsInit	*(*(struct(int,int)))
[	O
i	int
]	O
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
NULL	O
;	O
pts	array(struct(int,int))
[	O
i	int
]	O
=	O
ptsInit	*(*(struct(int,int)))
[	O
i	int
]	O
;	O
}	O
pts	array(struct(int,int))
[	O
1	int
]	O
=	O
miZeroArcPts	(*(struct(int,int,int,int,int,int)),*(struct(int,int)))->(*(struct(int,int)))
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
ptsInit	*(*(struct(int,int)))
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numPixels	int
;	O
i	int
++	O
)	O
{	O
ptsInit	*(*(struct(int,int)))
[	O
i	int
]	O
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
numPts	int
*	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
)	O
;	O
pts	array(struct(int,int))
[	O
i	int
]	O
=	O
ptsInit	*(*(struct(int,int)))
[	O
i	int
]	O
;	O
}	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
.	O
skipLast	enum(int,int)
=	O
(	O
i	int
==	O
0	int
?	O
false	int
:	O
true	int
)	O
;	O
miZeroArcDashPts	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int)),int,*(*(struct(int,int))))->(void)
(	O
pGC	*(struct)
,	O
arc	*(struct(int,int,int,int,int,int))
,	O
&	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
,	O
maxPts	int
,	O
pts	array(struct(int,int))
)	O
;	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
.	O
skipStart	enum(int,int)
=	O
true	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numPixels	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
ptsInit	*(*(struct(int,int)))
[	O
i	int
]	O
==	O
(	O
miPoint	struct(int,int)
*	O
)	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
i	int
==	O
0	int
&&	O
pGC	*(struct)
->	O
lineStyle	int
!=	O
(	O
int	O
)	O
MI_LINE_DOUBLE_DASH	int
)	O
{	O
free	(*(void))->(void)
(	O
ptsInit	*(*(struct(int,int)))
[	O
i	int
]	O
)	O
;	O
continue	O
;	O
}	O
n	array(double)
=	O
pts	array(struct(int,int))
[	O
i	int
]	O
-	O
ptsInit	*(*(struct(int,int)))
[	O
i	int
]	O
;	O
if	O
(	O
n	array(double)
>	O
0	int
)	O
{	O
unsigned	O
int	O
*	O
widths	*(int)
;	O
int	O
k	int
;	O
widths	*(int)
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
n	array(double)
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	array(double)
;	O
k	int
++	O
)	O
widths	*(int)
[	O
k	int
]	O
=	O
1	int
;	O
miQuickSortSpansY	O
(	O
ptsInit	*(*(struct(int,int)))
[	O
i	int
]	O
,	O
widths	*(int)
,	O
n	array(double)
)	O
;	O
MI_PAINT_SPANS	O
(	O
paintedSet	*(struct)
,	O
pGC	*(struct)
->	O
pixels	*(struct(char,union(char,array(char))))
[	O
i	int
]	O
,	O
n	array(double)
,	O
ptsInit	*(*(struct(int,int)))
[	O
i	int
]	O
,	O
widths	*(int)
)	O
}	O
}	O
free	(*(void))->(void)
(	O
pts	array(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
ptsInit	*(*(struct(int,int)))
)	O
;	O
}	O
}	O
}	O
static	O
miPoint	struct(int,int)
*	O
miZeroArcPts	(*(struct(int,int,int,int,int,int)),*(struct(int,int)))->(*(struct(int,int)))
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miPoint	struct(int,int)
*	O
pts	array(struct(int,int))
)	O
{	O
miZeroArc	struct(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,struct(int,int,int),struct(int,int,int),struct(int,int,int),struct(int,int,int),int,int,int,int)
info	*(struct(*(char),char,char,char))
;	O
int	O
x	double
,	O
y	double
,	O
a	int
,	O
b	int
,	O
d	int
;	O
unsigned	O
int	O
mask	int
;	O
int	O
k1	int
,	O
k3	int
,	O
dx	int
,	O
dy	int
;	O
bool	enum(int,int)
do360	enum(int,int)
;	O
do360	enum(int,int)
=	O
miZeroArcSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,struct(int,int,int),struct(int,int,int),struct(int,int,int),struct(int,int,int),int,int,int,int)),enum(int,int))->(enum(int,int))
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
&	O
info	*(struct(*(char),char,char,char))
,	O
true	int
)	O
;	O
MIARCSETUP	O
(	O
info	*(struct(*(char),char,char,char))
,	O
x	double
,	O
y	double
,	O
k1	int
,	O
k3	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
dx	int
,	O
dy	int
)	O
;	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
.	O
initialMask	int
;	O
if	O
(	O
!	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
)	O
{	O
DoPix	O
(	O
pts	array(struct(int,int))
,	O
mask	int
,	O
1	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
)	O
;	O
DoPix	O
(	O
pts	array(struct(int,int))
,	O
mask	int
,	O
3	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
)	O
;	O
}	O
if	O
(	O
!	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
x	double
||	O
!	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
y	double
)	O
{	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
mask	int
;	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
=	O
info	*(struct(*(char),char,char,char))
.	O
altend	struct(int,int,int)
;	O
}	O
if	O
(	O
do360	enum(int,int)
&&	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
==	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
&&	O
!	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
)	O
{	O
int	O
yorgh	int
=	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
info	*(struct(*(char),char,char,char))
.	O
h	int
;	O
int	O
xorghp	int
=	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
info	*(struct(*(char),char,char,char))
.	O
h	int
;	O
int	O
xorghn	int
=	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
-	O
info	*(struct(*(char),char,char,char))
.	O
h	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
if	O
(	O
a	int
<	O
0	int
)	O
break	O
;	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
xorghp	int
-	O
y	double
,	O
yorgh	int
-	O
x	double
)	O
;	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
xorghn	int
+	O
y	double
,	O
yorgh	int
-	O
x	double
)	O
;	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
xorghn	int
+	O
y	double
,	O
yorgh	int
+	O
x	double
)	O
;	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
xorghp	int
-	O
y	double
,	O
yorgh	int
+	O
x	double
)	O
;	O
MIARCCIRCLESTEP	O
(	O
x	double
,	O
y	double
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
)	O
;	O
}	O
if	O
(	O
x	double
>	O
1	int
&&	O
pts	array(struct(int,int))
[	O
-	O
1	int
]	O
.	O
x	double
==	O
pts	array(struct(int,int))
[	O
-	O
5	int
]	O
.	O
x	double
&&	O
pts	array(struct(int,int))
[	O
-	O
1	int
]	O
.	O
y	double
==	O
pts	array(struct(int,int))
[	O
-	O
5	int
]	O
.	O
y	double
)	O
pts	array(struct(int,int))
-=	O
4	int
;	O
x	double
=	O
info	*(struct(*(char),char,char,char))
.	O
w	int
;	O
y	double
=	O
info	*(struct(*(char),char,char,char))
.	O
h	int
;	O
}	O
else	O
if	O
(	O
do360	enum(int,int)
)	O
{	O
while	O
(	O
y	double
<	O
(	O
int	O
)	O
info	*(struct(*(char),char,char,char))
.	O
h	int
||	O
x	double
<	O
(	O
int	O
)	O
info	*(struct(*(char),char,char,char))
.	O
w	int
)	O
{	O
MIARCOCTANTSHIFT	O
(	O
info	*(struct(*(char),char,char,char))
,	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
)	O
;	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
Pixelate	O
(	O
pts	array(struct(int,int))
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
MIARCSTEP	O
(	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
,	O
;	O
)	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
y	double
<	O
(	O
int	O
)	O
info	*(struct(*(char),char,char,char))
.	O
h	int
||	O
x	double
<	O
(	O
int	O
)	O
info	*(struct(*(char),char,char,char))
.	O
w	int
)	O
{	O
MIARCOCTANTSHIFT	O
(	O
info	*(struct(*(char),char,char,char))
,	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
)	O
;	O
if	O
(	O
(	O
x	double
==	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
y	double
)	O
)	O
{	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
mask	int
;	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
=	O
info	*(struct(*(char),char,char,char))
.	O
altstart	struct(int,int,int)
;	O
}	O
DoPix	O
(	O
pts	array(struct(int,int))
,	O
mask	int
,	O
0	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
pts	array(struct(int,int))
,	O
mask	int
,	O
1	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
pts	array(struct(int,int))
,	O
mask	int
,	O
2	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
DoPix	O
(	O
pts	array(struct(int,int))
,	O
mask	int
,	O
3	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
if	O
(	O
(	O
x	double
==	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
y	double
)	O
)	O
{	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
mask	int
;	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
=	O
info	*(struct(*(char),char,char,char))
.	O
altend	struct(int,int,int)
;	O
}	O
MIARCSTEP	O
(	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
,	O
;	O
)	O
;	O
}	O
}	O
if	O
(	O
(	O
x	double
==	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
y	double
)	O
)	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
mask	int
;	O
DoPix	O
(	O
pts	array(struct(int,int))
,	O
mask	int
,	O
0	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
pts	array(struct(int,int))
,	O
mask	int
,	O
2	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
{	O
DoPix	O
(	O
pts	array(struct(int,int))
,	O
mask	int
,	O
1	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
pts	array(struct(int,int))
,	O
mask	int
,	O
3	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
}	O
return	O
pts	array(struct(int,int))
;	O
}	O
static	O
void	O
miZeroArcDashPts	(*(struct(int,*(struct(char,union`)),int,array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),array(struct(char,union(char,array(char)))),*(int),int,int,int,int,int,int,double,int,int)),*(struct(int,int,int,int,int,int)),*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int)),int,*(*(struct(int,int))))->(void)
(	O
const	O
miGC	struct
*	O
pGC	*(struct)
,	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miDashInfo	struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int)
*	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
,	O
int	O
maxPts	int
,	O
miPoint	struct(int,int)
*	O
*	O
pts	array(struct(int,int))
)	O
{	O
miZeroArc	struct(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,struct(int,int,int),struct(int,int,int),struct(int,int,int),struct(int,int,int),int,int,int,int)
info	*(struct(*(char),char,char,char))
;	O
int	O
x	double
,	O
y	double
,	O
a	int
,	O
b	int
,	O
d	int
;	O
unsigned	O
int	O
mask	int
;	O
int	O
k1	int
,	O
k3	int
,	O
dx	int
,	O
dy	int
;	O
int	O
dashRemaining	int
,	O
numPixels	int
;	O
miPoint	struct(int,int)
*	O
points	*(struct(int,int))
,	O
*	O
arcPts	array(*(struct(int,int)))
[	O
4	int
]	O
;	O
miPoint	struct(int,int)
*	O
startPts	array(*(struct(int,int)))
[	O
5	int
]	O
,	O
*	O
endPts	array(*(struct(int,int)))
[	O
5	int
]	O
;	O
int	O
deltas	array(int)
[	O
5	int
]	O
;	O
miPoint	struct(int,int)
*	O
pt	*(struct(int,int))
,	O
*	O
startPt	struct(int,int)
,	O
*	O
lastPt	*(struct(int,int))
;	O
int	O
i	int
,	O
j	int
,	O
seg	int
,	O
startseg	int
;	O
points	*(struct(int,int))
=	O
(	O
miPoint	struct(int,int)
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct(int,int)
)	O
*	O
4	int
*	O
maxPts	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
arcPts	array(*(struct(int,int)))
[	O
i	int
]	O
=	O
points	*(struct(int,int))
+	O
(	O
i	int
*	O
maxPts	int
)	O
;	O
miZeroArcSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,struct(int,int,int),struct(int,int,int),struct(int,int,int),struct(int,int,int),int,int,int,int)),enum(int,int))->(enum(int,int))
(	O
arc	*(struct(int,int,int,int,int,int))
,	O
&	O
info	*(struct(*(char),char,char,char))
,	O
false	int
)	O
;	O
MIARCSETUP	O
(	O
info	*(struct(*(char),char,char,char))
,	O
x	double
,	O
y	double
,	O
k1	int
,	O
k3	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
dx	int
,	O
dy	int
)	O
;	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
.	O
initialMask	int
;	O
startseg	int
=	O
info	*(struct(*(char),char,char,char))
.	O
startAngle	int
/	O
QUADRANT	O
;	O
startPt	struct(int,int)
=	O
arcPts	array(*(struct(int,int)))
[	O
startseg	int
]	O
;	O
if	O
(	O
!	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
)	O
)	O
{	O
DoPix	O
(	O
arcPts	array(*(struct(int,int)))
,	O
mask	int
,	O
1	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
)	O
;	O
DoPix	O
(	O
arcPts	array(*(struct(int,int)))
,	O
mask	int
,	O
3	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
)	O
;	O
}	O
if	O
(	O
!	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
x	double
||	O
!	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
y	double
)	O
{	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
mask	int
;	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
=	O
info	*(struct(*(char),char,char,char))
.	O
altend	struct(int,int,int)
;	O
}	O
while	O
(	O
y	double
<	O
(	O
int	O
)	O
info	*(struct(*(char),char,char,char))
.	O
h	int
||	O
x	double
<	O
(	O
int	O
)	O
info	*(struct(*(char),char,char,char))
.	O
w	int
)	O
{	O
MIARCOCTANTSHIFT	O
(	O
info	*(struct(*(char),char,char,char))
,	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
)	O
;	O
if	O
(	O
(	O
x	double
==	O
info	*(struct(*(char),char,char,char))
.	O
firstx	int
)	O
||	O
(	O
y	double
==	O
info	*(struct(*(char),char,char,char))
.	O
firsty	int
)	O
)	O
startPt	struct(int,int)
=	O
arcPts	array(*(struct(int,int)))
[	O
startseg	int
]	O
;	O
if	O
(	O
(	O
x	double
==	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
y	double
)	O
)	O
{	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
mask	int
;	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
=	O
info	*(struct(*(char),char,char,char))
.	O
altstart	struct(int,int,int)
;	O
}	O
DoPix	O
(	O
arcPts	array(*(struct(int,int)))
,	O
mask	int
,	O
0	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
arcPts	array(*(struct(int,int)))
,	O
mask	int
,	O
1	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
arcPts	array(*(struct(int,int)))
,	O
mask	int
,	O
2	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
DoPix	O
(	O
arcPts	array(*(struct(int,int)))
,	O
mask	int
,	O
3	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
if	O
(	O
(	O
x	double
==	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
y	double
)	O
)	O
{	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
.	O
mask	int
;	O
info	*(struct(*(char),char,char,char))
.	O
end	struct(int,int,int)
=	O
info	*(struct(*(char),char,char,char))
.	O
altend	struct(int,int,int)
;	O
}	O
MIARCSTEP	O
(	O
x	double
,	O
y	double
,	O
dx	int
,	O
dy	int
,	O
a	int
,	O
b	int
,	O
d	int
,	O
k1	int
,	O
k3	int
,	O
;	O
,	O
;	O
)	O
;	O
}	O
if	O
(	O
(	O
x	double
==	O
info	*(struct(*(char),char,char,char))
.	O
firstx	int
)	O
||	O
(	O
y	double
==	O
info	*(struct(*(char),char,char,char))
.	O
firsty	int
)	O
)	O
startPt	struct(int,int)
=	O
arcPts	array(*(struct(int,int)))
[	O
startseg	int
]	O
;	O
if	O
(	O
(	O
x	double
==	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
x	double
)	O
||	O
(	O
y	double
==	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
y	double
)	O
)	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
.	O
start	struct(int,int,int)
.	O
mask	int
;	O
DoPix	O
(	O
arcPts	array(*(struct(int,int)))
,	O
mask	int
,	O
0	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
arcPts	array(*(struct(int,int)))
,	O
mask	int
,	O
2	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
&	O
1	int
)	O
{	O
DoPix	O
(	O
arcPts	array(*(struct(int,int)))
,	O
mask	int
,	O
1	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorgo	int
-	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorg	int
+	O
y	double
)	O
;	O
DoPix	O
(	O
arcPts	array(*(struct(int,int)))
,	O
mask	int
,	O
3	int
,	O
info	*(struct(*(char),char,char,char))
.	O
xorg	int
+	O
x	double
,	O
info	*(struct(*(char),char,char,char))
.	O
yorgo	int
-	O
y	double
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
seg	int
=	O
(	O
startseg	int
+	O
i	int
)	O
&	O
3	int
;	O
pt	*(struct(int,int))
=	O
points	*(struct(int,int))
+	O
(	O
seg	int
*	O
maxPts	int
)	O
;	O
if	O
(	O
seg	int
&	O
1	int
)	O
{	O
startPts	array(*(struct(int,int)))
[	O
i	int
]	O
=	O
pt	*(struct(int,int))
;	O
endPts	array(*(struct(int,int)))
[	O
i	int
]	O
=	O
arcPts	array(*(struct(int,int)))
[	O
seg	int
]	O
;	O
deltas	array(int)
[	O
i	int
]	O
=	O
1	int
;	O
}	O
else	O
{	O
startPts	array(*(struct(int,int)))
[	O
i	int
]	O
=	O
arcPts	array(*(struct(int,int)))
[	O
seg	int
]	O
-	O
1	int
;	O
endPts	array(*(struct(int,int)))
[	O
i	int
]	O
=	O
pt	*(struct(int,int))
-	O
1	int
;	O
deltas	array(int)
[	O
i	int
]	O
=	O
-	O
1	int
;	O
}	O
}	O
startPts	array(*(struct(int,int)))
[	O
4	int
]	O
=	O
startPts	array(*(struct(int,int)))
[	O
0	int
]	O
;	O
endPts	array(*(struct(int,int)))
[	O
4	int
]	O
=	O
startPt	struct(int,int)
;	O
startPts	array(*(struct(int,int)))
[	O
0	int
]	O
=	O
startPt	struct(int,int)
;	O
if	O
(	O
startseg	int
&	O
1	int
)	O
{	O
if	O
(	O
startPts	array(*(struct(int,int)))
[	O
4	int
]	O
!=	O
endPts	array(*(struct(int,int)))
[	O
4	int
]	O
)	O
endPts	array(*(struct(int,int)))
[	O
4	int
]	O
--	O
;	O
deltas	array(int)
[	O
4	int
]	O
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
startPts	array(*(struct(int,int)))
[	O
0	int
]	O
>	O
startPts	array(*(struct(int,int)))
[	O
4	int
]	O
)	O
startPts	array(*(struct(int,int)))
[	O
0	int
]	O
--	O
;	O
if	O
(	O
startPts	array(*(struct(int,int)))
[	O
4	int
]	O
<	O
endPts	array(*(struct(int,int)))
[	O
4	int
]	O
)	O
endPts	array(*(struct(int,int)))
[	O
4	int
]	O
--	O
;	O
deltas	array(int)
[	O
4	int
]	O
=	O
-	O
1	int
;	O
}	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
<	O
0	int
)	O
{	O
miPoint	struct(int,int)
*	O
tmps	*(struct(int,int))
,	O
*	O
tmpe	*(struct(int,int))
;	O
int	O
tmpd	int
;	O
tmpd	int
=	O
deltas	array(int)
[	O
0	int
]	O
;	O
tmps	*(struct(int,int))
=	O
startPts	array(*(struct(int,int)))
[	O
0	int
]	O
-	O
tmpd	int
;	O
tmpe	*(struct(int,int))
=	O
endPts	array(*(struct(int,int)))
[	O
0	int
]	O
-	O
tmpd	int
;	O
startPts	array(*(struct(int,int)))
[	O
0	int
]	O
=	O
endPts	array(*(struct(int,int)))
[	O
4	int
]	O
-	O
deltas	array(int)
[	O
4	int
]	O
;	O
endPts	array(*(struct(int,int)))
[	O
0	int
]	O
=	O
startPts	array(*(struct(int,int)))
[	O
4	int
]	O
-	O
deltas	array(int)
[	O
4	int
]	O
;	O
deltas	array(int)
[	O
0	int
]	O
=	O
-	O
deltas	array(int)
[	O
4	int
]	O
;	O
startPts	array(*(struct(int,int)))
[	O
4	int
]	O
=	O
tmpe	*(struct(int,int))
;	O
endPts	array(*(struct(int,int)))
[	O
4	int
]	O
=	O
tmps	*(struct(int,int))
;	O
deltas	array(int)
[	O
4	int
]	O
=	O
-	O
tmpd	int
;	O
tmpd	int
=	O
deltas	array(int)
[	O
1	int
]	O
;	O
tmps	*(struct(int,int))
=	O
startPts	array(*(struct(int,int)))
[	O
1	int
]	O
-	O
tmpd	int
;	O
tmpe	*(struct(int,int))
=	O
endPts	array(*(struct(int,int)))
[	O
1	int
]	O
-	O
tmpd	int
;	O
startPts	array(*(struct(int,int)))
[	O
1	int
]	O
=	O
endPts	array(*(struct(int,int)))
[	O
3	int
]	O
-	O
deltas	array(int)
[	O
3	int
]	O
;	O
endPts	array(*(struct(int,int)))
[	O
1	int
]	O
=	O
startPts	array(*(struct(int,int)))
[	O
3	int
]	O
-	O
deltas	array(int)
[	O
3	int
]	O
;	O
deltas	array(int)
[	O
1	int
]	O
=	O
-	O
deltas	array(int)
[	O
3	int
]	O
;	O
startPts	array(*(struct(int,int)))
[	O
3	int
]	O
=	O
tmpe	*(struct(int,int))
;	O
endPts	array(*(struct(int,int)))
[	O
3	int
]	O
=	O
tmps	*(struct(int,int))
;	O
deltas	array(int)
[	O
3	int
]	O
=	O
-	O
tmpd	int
;	O
tmps	*(struct(int,int))
=	O
startPts	array(*(struct(int,int)))
[	O
2	int
]	O
-	O
deltas	array(int)
[	O
2	int
]	O
;	O
startPts	array(*(struct(int,int)))
[	O
2	int
]	O
=	O
endPts	array(*(struct(int,int)))
[	O
2	int
]	O
-	O
deltas	array(int)
[	O
2	int
]	O
;	O
endPts	array(*(struct(int,int)))
[	O
2	int
]	O
=	O
tmps	*(struct(int,int))
;	O
deltas	array(int)
[	O
2	int
]	O
=	O
-	O
deltas	array(int)
[	O
2	int
]	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
5	int
&&	O
startPts	array(*(struct(int,int)))
[	O
i	int
]	O
==	O
endPts	array(*(struct(int,int)))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
i	int
==	O
5	int
)	O
return	O
;	O
pt	*(struct(int,int))
=	O
startPts	array(*(struct(int,int)))
[	O
i	int
]	O
;	O
for	O
(	O
j	int
=	O
4	int
;	O
startPts	array(*(struct(int,int)))
[	O
j	int
]	O
==	O
endPts	array(*(struct(int,int)))
[	O
j	int
]	O
;	O
j	int
--	O
)	O
;	O
lastPt	*(struct(int,int))
=	O
endPts	array(*(struct(int,int)))
[	O
j	int
]	O
-	O
deltas	array(int)
[	O
j	int
]	O
;	O
if	O
(	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
haveLast	enum(int,int)
&&	O
(	O
pt	*(struct(int,int))
->	O
x	double
==	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
endPt	struct(int,int)
.	O
x	double
)	O
&&	O
(	O
pt	*(struct(int,int))
->	O
y	double
==	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
endPt	struct(int,int)
.	O
y	double
)	O
)	O
startPts	array(*(struct(int,int)))
[	O
i	int
]	O
+=	O
deltas	array(int)
[	O
i	int
]	O
;	O
else	O
{	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashNum	int
=	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashNumInit	int
;	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashIndex	int
=	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashIndexInit	int
;	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashOffset	int
=	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashOffsetInit	int
;	O
}	O
if	O
(	O
!	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
skipStart	enum(int,int)
&&	O
(	O
info	*(struct(*(char),char,char,char))
.	O
startAngle	int
!=	O
info	*(struct(*(char),char,char,char))
.	O
endAngle	int
)	O
)	O
{	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
startPt	struct(int,int)
=	O
*	O
pt	*(struct(int,int))
;	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
haveStart	enum(int,int)
=	O
true	int
;	O
}	O
else	O
if	O
(	O
!	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
skipLast	enum(int,int)
&&	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
haveStart	enum(int,int)
&&	O
(	O
lastPt	*(struct(int,int))
->	O
x	double
==	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
startPt	struct(int,int)
.	O
x	double
)	O
&&	O
(	O
lastPt	*(struct(int,int))
->	O
y	double
==	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
startPt	struct(int,int)
.	O
y	double
)	O
&&	O
(	O
lastPt	*(struct(int,int))
!=	O
startPts	array(*(struct(int,int)))
[	O
i	int
]	O
)	O
)	O
endPts	array(*(struct(int,int)))
[	O
j	int
]	O
=	O
lastPt	*(struct(int,int))
;	O
if	O
(	O
info	*(struct(*(char),char,char,char))
.	O
startAngle	int
!=	O
info	*(struct(*(char),char,char,char))
.	O
endAngle	int
)	O
{	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
haveLast	enum(int,int)
=	O
true	int
;	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
endPt	struct(int,int)
=	O
*	O
lastPt	*(struct(int,int))
;	O
}	O
dashRemaining	int
=	O
(	O
int	O
)	O
pGC	*(struct)
->	O
dash	*(int)
[	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashIndex	int
]	O
-	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashOffset	int
;	O
numPixels	int
=	O
pGC	*(struct)
->	O
numPixels	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
5	int
;	O
i	int
++	O
)	O
{	O
int	O
delta	int
;	O
pt	*(struct(int,int))
=	O
startPts	array(*(struct(int,int)))
[	O
i	int
]	O
;	O
lastPt	*(struct(int,int))
=	O
endPts	array(*(struct(int,int)))
[	O
i	int
]	O
;	O
delta	int
=	O
deltas	array(int)
[	O
i	int
]	O
;	O
while	O
(	O
pt	*(struct(int,int))
!=	O
lastPt	*(struct(int,int))
)	O
{	O
int	O
dashNum	int
,	O
paintType	int
;	O
dashNum	int
=	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashNum	int
;	O
paintType	int
=	O
(	O
dashNum	int
&	O
1	int
)	O
?	O
0	int
:	O
1	int
+	O
(	O
(	O
dashNum	int
/	O
2	int
)	O
%	O
(	O
numPixels	int
-	O
1	int
)	O
)	O
;	O
while	O
(	O
(	O
pt	*(struct(int,int))
!=	O
lastPt	*(struct(int,int))
)	O
&&	O
--	O
dashRemaining	int
>=	O
0	int
)	O
{	O
*	O
(	O
pts	array(struct(int,int))
[	O
paintType	int
]	O
++	O
)	O
=	O
*	O
pt	*(struct(int,int))
;	O
pt	*(struct(int,int))
+=	O
delta	int
;	O
}	O
if	O
(	O
dashRemaining	int
<=	O
0	int
)	O
{	O
++	O
(	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashNum	int
)	O
;	O
if	O
(	O
++	O
(	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashIndex	int
)	O
==	O
pGC	*(struct)
->	O
numInDashList	int
)	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashIndex	int
=	O
0	int
;	O
dashRemaining	int
=	O
(	O
int	O
)	O
pGC	*(struct)
->	O
dash	*(int)
[	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashIndex	int
]	O
;	O
}	O
}	O
}	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashOffset	int
=	O
(	O
int	O
)	O
pGC	*(struct)
->	O
dash	*(int)
[	O
dinfo	*(struct(enum(int,int),enum(int,int),struct(int,int),enum(int,int),enum(int,int),struct(int,int),int,int,int,int,int,int))
->	O
dashIndex	int
]	O
-	O
dashRemaining	int
;	O
free	(*(void))->(void)
(	O
points	*(struct(int,int))
)	O
;	O
}	O
static	O
bool	enum(int,int)
miZeroArcSetup	(*(struct(int,int,int,int,int,int)),*(struct(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,struct(int,int,int),struct(int,int,int),struct(int,int,int),struct(int,int,int),int,int,int,int)),enum(int,int))->(enum(int,int))
(	O
const	O
miArc	struct(int,int,int,int,int,int)
*	O
arc	*(struct(int,int,int,int,int,int))
,	O
miZeroArc	struct(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,struct(int,int,int),struct(int,int,int),struct(int,int,int),struct(int,int,int),int,int,int,int)
*	O
info	*(struct(*(char),char,char,char))
,	O
bool	enum(int,int)
ok360	enum(int,int)
)	O
{	O
int	O
l	int
,	O
i	int
;	O
int	O
angle1	int
,	O
angle2	int
;	O
int	O
startseg	int
,	O
endseg	int
;	O
int	O
startAngle	int
,	O
endAngle	int
;	O
miZeroArcPt	struct(int,int,int)
start	struct(int,int,int)
,	O
end	struct(int,int,int)
;	O
bool	enum(int,int)
overlap	enum(int,int)
;	O
l	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&	O
1	int
;	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
==	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
alpha	int
=	O
4	int
;	O
info	*(struct(*(char),char,char,char))
->	O
beta	int
=	O
4	int
;	O
info	*(struct(*(char),char,char,char))
->	O
k1	int
=	O
-	O
8	int
;	O
info	*(struct(*(char),char,char,char))
->	O
k3	int
=	O
-	O
16	int
;	O
info	*(struct(*(char),char,char,char))
->	O
b	int
=	O
12	int
;	O
info	*(struct(*(char),char,char,char))
->	O
a	int
=	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
<<	O
2	int
)	O
-	O
12	int
;	O
info	*(struct(*(char),char,char,char))
->	O
d	int
=	O
17	int
-	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
<<	O
1	int
)	O
;	O
if	O
(	O
l	int
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
b	int
-=	O
4	int
;	O
info	*(struct(*(char),char,char,char))
->	O
a	int
+=	O
4	int
;	O
info	*(struct(*(char),char,char,char))
->	O
d	int
-=	O
7	int
;	O
}	O
}	O
else	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
==	O
0	int
||	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
==	O
0	int
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
alpha	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
beta	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
k1	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
k3	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
a	int
=	O
-	O
(	O
int	O
)	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
info	*(struct(*(char),char,char,char))
->	O
b	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
d	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
info	*(struct(*(char),char,char,char))
->	O
alpha	int
=	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
)	O
<<	O
2	int
;	O
info	*(struct(*(char),char,char,char))
->	O
beta	int
=	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
<<	O
2	int
;	O
info	*(struct(*(char),char,char,char))
->	O
k1	int
=	O
info	*(struct(*(char),char,char,char))
->	O
beta	int
<<	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
k3	int
=	O
info	*(struct(*(char),char,char,char))
->	O
k1	int
+	O
(	O
info	*(struct(*(char),char,char,char))
->	O
alpha	int
<<	O
1	int
)	O
;	O
info	*(struct(*(char),char,char,char))
->	O
b	int
=	O
l	int
?	O
0	int
:	O
-	O
info	*(struct(*(char),char,char,char))
->	O
beta	int
;	O
info	*(struct(*(char),char,char,char))
->	O
a	int
=	O
info	*(struct(*(char),char,char,char))
->	O
alpha	int
*	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
info	*(struct(*(char),char,char,char))
->	O
d	int
=	O
info	*(struct(*(char),char,char,char))
->	O
b	int
-	O
(	O
info	*(struct(*(char),char,char,char))
->	O
a	int
>>	O
1	int
)	O
-	O
(	O
info	*(struct(*(char),char,char,char))
->	O
alpha	int
>>	O
2	int
)	O
;	O
if	O
(	O
l	int
)	O
info	*(struct(*(char),char,char,char))
->	O
d	int
-=	O
info	*(struct(*(char),char,char,char))
->	O
beta	int
>>	O
2	int
;	O
info	*(struct(*(char),char,char,char))
->	O
a	int
-=	O
info	*(struct(*(char),char,char,char))
->	O
b	int
;	O
info	*(struct(*(char),char,char,char))
->	O
b	int
-=	O
info	*(struct(*(char),char,char,char))
->	O
k1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
a	int
+=	O
info	*(struct(*(char),char,char,char))
->	O
k1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
d	int
+=	O
info	*(struct(*(char),char,char,char))
->	O
b	int
;	O
info	*(struct(*(char),char,char,char))
->	O
k1	int
=	O
-	O
info	*(struct(*(char),char,char,char))
->	O
k1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
k3	int
=	O
-	O
info	*(struct(*(char),char,char,char))
->	O
k3	int
;	O
info	*(struct(*(char),char,char,char))
->	O
b	int
=	O
-	O
info	*(struct(*(char),char,char,char))
->	O
b	int
;	O
info	*(struct(*(char),char,char,char))
->	O
d	int
=	O
info	*(struct(*(char),char,char,char))
->	O
b	int
-	O
info	*(struct(*(char),char,char,char))
->	O
a	int
-	O
info	*(struct(*(char),char,char,char))
->	O
d	int
;	O
info	*(struct(*(char),char,char,char))
->	O
a	int
=	O
info	*(struct(*(char),char,char,char))
->	O
a	int
-	O
(	O
info	*(struct(*(char),char,char,char))
->	O
b	int
<<	O
1	int
)	O
;	O
}	O
info	*(struct(*(char),char,char,char))
->	O
dx	int
=	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
dy	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
w	int
=	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
+	O
1	int
)	O
>>	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
h	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
>>	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
xorg	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
x	double
+	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
>>	O
1	int
)	O
;	O
info	*(struct(*(char),char,char,char))
->	O
yorg	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
y	double
;	O
info	*(struct(*(char),char,char,char))
->	O
xorgo	int
=	O
info	*(struct(*(char),char,char,char))
->	O
xorg	int
+	O
l	int
;	O
info	*(struct(*(char),char,char,char))
->	O
yorgo	int
=	O
info	*(struct(*(char),char,char,char))
->	O
yorg	int
+	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
;	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
==	O
0	int
)	O
{	O
if	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
==	O
0	int
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
x	double
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
y	double
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
startAngle	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
endAngle	int
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
=	O
_oob_arc_pt	struct(int,int,int)
;	O
info	*(struct(*(char),char,char,char))
->	O
end	struct(int,int,int)
=	O
_oob_arc_pt	struct(int,int,int)
;	O
return	O
false	int
;	O
}	O
info	*(struct(*(char),char,char,char))
->	O
x	double
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
y	double
=	O
1	int
;	O
}	O
else	O
{	O
info	*(struct(*(char),char,char,char))
->	O
x	double
=	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
y	double
=	O
0	int
;	O
}	O
angle1	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
angle1	int
;	O
angle2	int
=	O
arc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
;	O
if	O
(	O
(	O
angle1	int
==	O
0	int
)	O
&&	O
(	O
angle2	int
>=	O
FULLCIRCLE	O
)	O
)	O
{	O
startAngle	int
=	O
0	int
;	O
endAngle	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
angle2	int
>	O
FULLCIRCLE	O
)	O
angle2	int
=	O
FULLCIRCLE	O
;	O
else	O
if	O
(	O
angle2	int
<	O
-	O
FULLCIRCLE	O
)	O
angle2	int
=	O
-	O
FULLCIRCLE	O
;	O
if	O
(	O
angle2	int
<	O
0	int
)	O
{	O
startAngle	int
=	O
angle1	int
+	O
angle2	int
;	O
endAngle	int
=	O
angle1	int
;	O
}	O
else	O
{	O
startAngle	int
=	O
angle1	int
;	O
endAngle	int
=	O
angle1	int
+	O
angle2	int
;	O
}	O
if	O
(	O
startAngle	int
<	O
0	int
)	O
startAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
startAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
startAngle	int
>=	O
FULLCIRCLE	O
)	O
startAngle	int
=	O
startAngle	int
%	O
FULLCIRCLE	O
;	O
if	O
(	O
endAngle	int
<	O
0	int
)	O
endAngle	int
=	O
FULLCIRCLE	O
-	O
(	O
-	O
endAngle	int
)	O
%	O
FULLCIRCLE	O
;	O
if	O
(	O
endAngle	int
>=	O
FULLCIRCLE	O
)	O
endAngle	int
=	O
endAngle	int
%	O
FULLCIRCLE	O
;	O
}	O
info	*(struct(*(char),char,char,char))
->	O
startAngle	int
=	O
startAngle	int
;	O
info	*(struct(*(char),char,char,char))
->	O
endAngle	int
=	O
endAngle	int
;	O
if	O
(	O
ok360	enum(int,int)
&&	O
(	O
startAngle	int
==	O
endAngle	int
)	O
&&	O
arc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
&&	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&&	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
=	O
0xf	int
;	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
=	O
_oob_arc_pt	struct(int,int,int)
;	O
info	*(struct(*(char),char,char,char))
->	O
end	struct(int,int,int)
=	O
_oob_arc_pt	struct(int,int,int)
;	O
return	O
true	int
;	O
}	O
startseg	int
=	O
startAngle	int
/	O
OCTANT	O
;	O
if	O
(	O
!	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
||	O
(	O
(	O
(	O
startseg	int
+	O
1	int
)	O
&	O
2	int
)	O
&&	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
)	O
)	O
{	O
start	struct(int,int,int)
.	O
x	double
=	O
(	O
int	O
)	O
(	O
Dcos	O
(	O
startAngle	int
)	O
*	O
(	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
+	O
1	int
)	O
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
start	struct(int,int,int)
.	O
x	double
<	O
0	int
)	O
start	struct(int,int,int)
.	O
x	double
=	O
-	O
start	struct(int,int,int)
.	O
x	double
;	O
start	struct(int,int,int)
.	O
y	double
=	O
-	O
1	int
;	O
}	O
else	O
{	O
start	struct(int,int,int)
.	O
y	double
=	O
(	O
int	O
)	O
(	O
Dsin	O
(	O
startAngle	int
)	O
*	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
start	struct(int,int,int)
.	O
y	double
<	O
0	int
)	O
start	struct(int,int,int)
.	O
y	double
=	O
-	O
start	struct(int,int,int)
.	O
y	double
;	O
start	struct(int,int,int)
.	O
y	double
=	O
info	*(struct(*(char),char,char,char))
->	O
h	int
-	O
start	struct(int,int,int)
.	O
y	double
;	O
start	struct(int,int,int)
.	O
x	double
=	O
INT_MAX	O
;	O
}	O
endseg	int
=	O
endAngle	int
/	O
OCTANT	O
;	O
if	O
(	O
!	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
||	O
(	O
(	O
(	O
endseg	int
+	O
1	int
)	O
&	O
2	int
)	O
&&	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
)	O
)	O
{	O
end	struct(int,int,int)
.	O
x	double
=	O
(	O
int	O
)	O
(	O
Dcos	O
(	O
endAngle	int
)	O
*	O
(	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
+	O
1	int
)	O
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
end	struct(int,int,int)
.	O
x	double
<	O
0	int
)	O
end	struct(int,int,int)
.	O
x	double
=	O
-	O
end	struct(int,int,int)
.	O
x	double
;	O
end	struct(int,int,int)
.	O
y	double
=	O
-	O
1	int
;	O
}	O
else	O
{	O
end	struct(int,int,int)
.	O
y	double
=	O
(	O
int	O
)	O
(	O
Dsin	O
(	O
endAngle	int
)	O
*	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
end	struct(int,int,int)
.	O
y	double
<	O
0	int
)	O
end	struct(int,int,int)
.	O
y	double
=	O
-	O
end	struct(int,int,int)
.	O
y	double
;	O
end	struct(int,int,int)
.	O
y	double
=	O
info	*(struct(*(char),char,char,char))
->	O
h	int
-	O
end	struct(int,int,int)
.	O
y	double
;	O
end	struct(int,int,int)
.	O
x	double
=	O
INT_MAX	O
;	O
}	O
info	*(struct(*(char),char,char,char))
->	O
firstx	int
=	O
start	struct(int,int,int)
.	O
x	double
;	O
info	*(struct(*(char),char,char,char))
->	O
firsty	int
=	O
start	struct(int,int,int)
.	O
y	double
;	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
=	O
0	int
;	O
overlap	enum(int,int)
=	O
(	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
angle2	int
!=	O
0	int
)	O
&&	O
(	O
endAngle	int
<=	O
startAngle	int
)	O
)	O
?	O
true	int
:	O
false	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
overlap	enum(int,int)
?	O
(	O
(	O
i	int
*	O
QUADRANT	O
<=	O
endAngle	int
)	O
||	O
(	O
(	O
i	int
+	O
1	int
)	O
*	O
QUADRANT	O
>	O
startAngle	int
)	O
)	O
:	O
(	O
(	O
i	int
*	O
QUADRANT	O
<=	O
endAngle	int
)	O
&&	O
(	O
(	O
i	int
+	O
1	int
)	O
*	O
QUADRANT	O
>	O
startAngle	int
)	O
)	O
)	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
|=	O
(	O
1	int
<<	O
i	int
)	O
;	O
}	O
start	struct(int,int,int)
.	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
;	O
end	struct(int,int,int)
.	O
mask	int
=	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
;	O
startseg	int
>>=	O
1	int
;	O
endseg	int
>>=	O
1	int
;	O
overlap	enum(int,int)
=	O
(	O
overlap	enum(int,int)
&&	O
(	O
endseg	int
==	O
startseg	int
)	O
)	O
?	O
true	int
:	O
false	int
;	O
if	O
(	O
start	struct(int,int,int)
.	O
x	double
!=	O
end	struct(int,int,int)
.	O
x	double
||	O
start	struct(int,int,int)
.	O
y	double
!=	O
end	struct(int,int,int)
.	O
y	double
||	O
!	O
overlap	enum(int,int)
)	O
{	O
if	O
(	O
startseg	int
&	O
1	int
)	O
{	O
if	O
(	O
!	O
overlap	enum(int,int)
)	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
&=	O
~	O
(	O
1	int
<<	O
startseg	int
)	O
;	O
if	O
(	O
start	struct(int,int,int)
.	O
x	double
>	O
end	struct(int,int,int)
.	O
x	double
||	O
start	struct(int,int,int)
.	O
y	double
>	O
end	struct(int,int,int)
.	O
y	double
)	O
end	struct(int,int,int)
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
startseg	int
)	O
;	O
}	O
else	O
{	O
start	struct(int,int,int)
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
startseg	int
)	O
;	O
if	O
(	O
(	O
(	O
start	struct(int,int,int)
.	O
x	double
<	O
end	struct(int,int,int)
.	O
x	double
||	O
start	struct(int,int,int)
.	O
y	double
<	O
end	struct(int,int,int)
.	O
y	double
)	O
||	O
(	O
start	struct(int,int,int)
.	O
x	double
==	O
end	struct(int,int,int)
.	O
x	double
&&	O
start	struct(int,int,int)
.	O
y	double
==	O
end	struct(int,int,int)
.	O
y	double
&&	O
(	O
endseg	int
&	O
1	int
)	O
)	O
)	O
&&	O
!	O
overlap	enum(int,int)
)	O
end	struct(int,int,int)
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
startseg	int
)	O
;	O
}	O
if	O
(	O
endseg	int
&	O
1	int
)	O
{	O
end	struct(int,int,int)
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
endseg	int
)	O
;	O
if	O
(	O
(	O
(	O
start	struct(int,int,int)
.	O
x	double
>	O
end	struct(int,int,int)
.	O
x	double
||	O
start	struct(int,int,int)
.	O
y	double
>	O
end	struct(int,int,int)
.	O
y	double
)	O
||	O
(	O
start	struct(int,int,int)
.	O
x	double
==	O
end	struct(int,int,int)
.	O
x	double
&&	O
start	struct(int,int,int)
.	O
y	double
==	O
end	struct(int,int,int)
.	O
y	double
&&	O
!	O
(	O
startseg	int
&	O
1	int
)	O
)	O
)	O
&&	O
!	O
overlap	enum(int,int)
)	O
start	struct(int,int,int)
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
endseg	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
overlap	enum(int,int)
)	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
&=	O
~	O
(	O
1	int
<<	O
endseg	int
)	O
;	O
if	O
(	O
start	struct(int,int,int)
.	O
x	double
<	O
end	struct(int,int,int)
.	O
x	double
||	O
start	struct(int,int,int)
.	O
y	double
<	O
end	struct(int,int,int)
.	O
y	double
)	O
start	struct(int,int,int)
.	O
mask	int
&=	O
~	O
(	O
1	int
<<	O
endseg	int
)	O
;	O
}	O
}	O
if	O
(	O
startAngle	int
&&	O
(	O
(	O
start	struct(int,int,int)
.	O
y	double
<	O
0	int
&&	O
end	struct(int,int,int)
.	O
y	double
>=	O
0	int
)	O
||	O
(	O
start	struct(int,int,int)
.	O
y	double
>=	O
0	int
&&	O
end	struct(int,int,int)
.	O
y	double
<	O
0	int
)	O
)	O
)	O
{	O
i	int
=	O
(	O
startAngle	int
+	O
OCTANT	O
)	O
%	O
OCTANT	O
;	O
if	O
(	O
i	int
<	O
EPSILON45	int
||	O
i	int
>	O
OCTANT	O
-	O
EPSILON45	int
)	O
{	O
i	int
=	O
(	O
endAngle	int
+	O
OCTANT	O
)	O
%	O
OCTANT	O
;	O
if	O
(	O
i	int
<	O
EPSILON45	int
||	O
i	int
>	O
OCTANT	O
-	O
EPSILON45	int
)	O
{	O
if	O
(	O
start	struct(int,int,int)
.	O
y	double
<	O
0	int
)	O
{	O
i	int
=	O
(	O
int	O
)	O
(	O
Dsin	O
(	O
startAngle	int
)	O
*	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
i	int
=	O
-	O
i	int
;	O
if	O
(	O
(	O
int	O
)	O
info	*(struct(*(char),char,char,char))
->	O
h	int
-	O
i	int
==	O
end	struct(int,int,int)
.	O
y	double
)	O
start	struct(int,int,int)
.	O
mask	int
=	O
end	struct(int,int,int)
.	O
mask	int
;	O
}	O
else	O
{	O
i	int
=	O
(	O
int	O
)	O
(	O
Dsin	O
(	O
endAngle	int
)	O
*	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
/	O
2.0	int
)	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
i	int
=	O
-	O
i	int
;	O
if	O
(	O
(	O
int	O
)	O
info	*(struct(*(char),char,char,char))
->	O
h	int
-	O
i	int
==	O
start	struct(int,int,int)
.	O
y	double
)	O
end	struct(int,int,int)
.	O
mask	int
=	O
start	struct(int,int,int)
.	O
mask	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
startseg	int
&	O
1	int
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
=	O
start	struct(int,int,int)
;	O
info	*(struct(*(char),char,char,char))
->	O
end	struct(int,int,int)
=	O
_oob_arc_pt	struct(int,int,int)
;	O
}	O
else	O
{	O
info	*(struct(*(char),char,char,char))
->	O
end	struct(int,int,int)
=	O
start	struct(int,int,int)
;	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
=	O
_oob_arc_pt	struct(int,int,int)
;	O
}	O
if	O
(	O
endseg	int
&	O
1	int
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
altend	struct(int,int,int)
=	O
end	struct(int,int,int)
;	O
if	O
(	O
info	*(struct(*(char),char,char,char))
->	O
altend	struct(int,int,int)
.	O
x	double
<	O
info	*(struct(*(char),char,char,char))
->	O
end	struct(int,int,int)
.	O
x	double
||	O
info	*(struct(*(char),char,char,char))
->	O
altend	struct(int,int,int)
.	O
y	double
<	O
info	*(struct(*(char),char,char,char))
->	O
end	struct(int,int,int)
.	O
y	double
)	O
{	O
miZeroArcPt	struct(int,int,int)
tmp	struct(int,int,int)
;	O
tmp	struct(int,int,int)
=	O
info	*(struct(*(char),char,char,char))
->	O
altend	struct(int,int,int)
;	O
info	*(struct(*(char),char,char,char))
->	O
altend	struct(int,int,int)
=	O
info	*(struct(*(char),char,char,char))
->	O
end	struct(int,int,int)
;	O
info	*(struct(*(char),char,char,char))
->	O
end	struct(int,int,int)
=	O
tmp	struct(int,int,int)
;	O
}	O
info	*(struct(*(char),char,char,char))
->	O
altstart	struct(int,int,int)
=	O
_oob_arc_pt	struct(int,int,int)
;	O
}	O
else	O
{	O
info	*(struct(*(char),char,char,char))
->	O
altstart	struct(int,int,int)
=	O
end	struct(int,int,int)
;	O
if	O
(	O
info	*(struct(*(char),char,char,char))
->	O
altstart	struct(int,int,int)
.	O
x	double
<	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
.	O
x	double
||	O
info	*(struct(*(char),char,char,char))
->	O
altstart	struct(int,int,int)
.	O
y	double
<	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
.	O
y	double
)	O
{	O
miZeroArcPt	struct(int,int,int)
tmp	struct(int,int,int)
;	O
tmp	struct(int,int,int)
=	O
info	*(struct(*(char),char,char,char))
->	O
altstart	struct(int,int,int)
;	O
info	*(struct(*(char),char,char,char))
->	O
altstart	struct(int,int,int)
=	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
;	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
=	O
tmp	struct(int,int,int)
;	O
}	O
info	*(struct(*(char),char,char,char))
->	O
altend	struct(int,int,int)
=	O
_oob_arc_pt	struct(int,int,int)
;	O
}	O
if	O
(	O
!	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
.	O
x	double
||	O
!	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
.	O
y	double
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
=	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
.	O
mask	int
;	O
info	*(struct(*(char),char,char,char))
->	O
start	struct(int,int,int)
=	O
info	*(struct(*(char),char,char,char))
->	O
altstart	struct(int,int,int)
;	O
}	O
if	O
(	O
!	O
arc	*(struct(int,int,int,int,int,int))
->	O
width	array(short)
&&	O
(	O
arc	*(struct(int,int,int,int,int,int))
->	O
height	int
==	O
1	int
)	O
)	O
{	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
|=	O
info	*(struct(*(char),char,char,char))
->	O
end	struct(int,int,int)
.	O
mask	int
;	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
|=	O
info	*(struct(*(char),char,char,char))
->	O
initialMask	int
<<	O
1	int
;	O
info	*(struct(*(char),char,char,char))
->	O
end	struct(int,int,int)
.	O
x	double
=	O
0	int
;	O
info	*(struct(*(char),char,char,char))
->	O
end	struct(int,int,int)
.	O
mask	int
=	O
0	int
;	O
}	O
return	O
false	int
;	O
}	O
