void	O
osip_fifo_init	(*(struct(*(struct),*(struct),struct(int,*(struct`)),int,enum(int,int))))->(void)
(	O
osip_fifo_t	struct
*	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
)	O
{	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
=	O
osip_mutex_init	()->(*(struct))
(	O
)	O
;	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qisempty	*(struct)
=	O
osip_sem_init	(int)->(*(struct))
(	O
0	int
)	O
;	O
osip_list_init	(*(struct(int,*(struct(*`,*`)))))->(int)
(	O
&	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
queue	struct(int,*(struct(*(struct(*`,*`)),*(void))))
)	O
;	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
state	*(int)
=	O
osip_empty	int
;	O
}	O
int	O
osip_fifo_add	(*(struct(*(struct),*(struct),struct(int,*(struct`)),int,enum(int,int))),*(void))->(int)
(	O
osip_fifo_t	struct
*	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
,	O
void	O
*	O
el	*(void)
)	O
{	O
osip_mutex_lock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
osip_list_add	(*(struct(int,*(struct(*`,*`)))),*(void),int)->(int)
(	O
&	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
queue	struct(int,*(struct(*(struct(*`,*`)),*(void))))
,	O
el	*(void)
,	O
-	O
1	int
)	O
;	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
state	*(int)
=	O
osip_ok	int
;	O
osip_sem_post	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qisempty	*(struct)
)	O
;	O
osip_mutex_unlock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
osip_fifo_insert	(*(struct(*(struct),*(struct),struct(int,*(struct`)),int,enum(int,int))),*(void))->(int)
(	O
osip_fifo_t	struct
*	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
,	O
void	O
*	O
el	*(void)
)	O
{	O
osip_mutex_lock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
osip_list_add	(*(struct(int,*(struct(*`,*`)))),*(void),int)->(int)
(	O
&	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
queue	struct(int,*(struct(*(struct(*`,*`)),*(void))))
,	O
el	*(void)
,	O
0	int
)	O
;	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
state	*(int)
=	O
osip_ok	int
;	O
osip_sem_post	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qisempty	*(struct)
)	O
;	O
osip_mutex_unlock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
osip_fifo_size	(*(struct(*(struct),*(struct),struct(int,*(struct`)),int,enum(int,int))))->(int)
(	O
osip_fifo_t	struct
*	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
)	O
{	O
int	O
i	int
;	O
osip_mutex_lock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
i	int
=	O
osip_list_size	(*(struct(int,*(struct(*`,*`)))))->(int)
(	O
&	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
queue	struct(int,*(struct(*(struct(*`,*`)),*(void))))
)	O
;	O
osip_mutex_unlock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
return	O
i	int
;	O
}	O
void	O
*	O
osip_fifo_get	(*(struct(*(struct),*(struct),struct(int,*(struct`)),int,enum(int,int))))->(*(void))
(	O
osip_fifo_t	struct
*	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
)	O
{	O
void	O
*	O
el	*(void)
=	O
NULL	O
;	O
int	O
i	int
=	O
osip_sem_wait	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qisempty	*(struct)
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
NULL	O
;	O
osip_mutex_lock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
if	O
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
state	*(int)
!=	O
osip_empty	int
)	O
{	O
el	*(void)
=	O
osip_list_get	(*(struct(int,*(struct(*`,*`)))),int)->(*(void))
(	O
&	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
queue	struct(int,*(struct(*(struct(*`,*`)),*(void))))
,	O
0	int
)	O
;	O
osip_list_remove	(*(struct(int,*(struct(*`,*`)))),int)->(int)
(	O
&	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
queue	struct(int,*(struct(*(struct(*`,*`)),*(void))))
,	O
0	int
)	O
;	O
}	O
else	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_ERROR	O
,	O
NULL	O
,	O
"no element in fifo.\n"	*(char)
)	O
)	O
;	O
osip_mutex_unlock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
if	O
(	O
osip_list_size	(*(struct(int,*(struct(*`,*`)))))->(int)
(	O
&	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
queue	struct(int,*(struct(*(struct(*`,*`)),*(void))))
)	O
<=	O
0	int
)	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
state	*(int)
=	O
osip_empty	int
;	O
else	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
state	*(int)
=	O
osip_ok	int
;	O
osip_mutex_unlock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
return	O
el	*(void)
;	O
}	O
void	O
*	O
osip_fifo_tryget	(*(struct(*(struct),*(struct),struct(int,*(struct`)),int,enum(int,int))))->(*(void))
(	O
osip_fifo_t	struct
*	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
)	O
{	O
void	O
*	O
el	*(void)
=	O
NULL	O
;	O
if	O
(	O
0	int
!=	O
osip_sem_trywait	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qisempty	*(struct)
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
osip_mutex_lock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
if	O
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
state	*(int)
!=	O
osip_empty	int
)	O
{	O
el	*(void)
=	O
osip_list_get	(*(struct(int,*(struct(*`,*`)))),int)->(*(void))
(	O
&	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
queue	struct(int,*(struct(*(struct(*`,*`)),*(void))))
,	O
0	int
)	O
;	O
osip_list_remove	(*(struct(int,*(struct(*`,*`)))),int)->(int)
(	O
&	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
queue	struct(int,*(struct(*(struct(*`,*`)),*(void))))
,	O
0	int
)	O
;	O
}	O
else	O
{	O
OSIP_TRACE	O
(	O
osip_trace	(*(char),int,enum(int,int,int,int,int,int,int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_INFO4	O
,	O
NULL	O
,	O
"no element in fifo.\n"	*(char)
)	O
)	O
;	O
osip_mutex_unlock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
if	O
(	O
osip_list_size	(*(struct(int,*(struct(*`,*`)))))->(int)
(	O
&	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
queue	struct(int,*(struct(*(struct(*`,*`)),*(void))))
)	O
<=	O
0	int
)	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
state	*(int)
=	O
osip_empty	int
;	O
else	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
state	*(int)
=	O
osip_ok	int
;	O
osip_mutex_unlock	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
return	O
el	*(void)
;	O
}	O
void	O
osip_fifo_free	(*(struct(*(struct),*(struct),struct(int,*(struct`)),int,enum(int,int))))->(void)
(	O
osip_fifo_t	struct
*	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
)	O
{	O
if	O
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
==	O
NULL	O
)	O
return	O
;	O
osip_mutex_destroy	(*(struct))->(void)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qislocked	*(struct)
)	O
;	O
osip_sem_destroy	(*(struct))->(int)
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
->	O
qisempty	*(struct)
)	O
;	O
osip_free	O
(	O
ff	*(struct(*(struct),*(struct),struct(int,*(struct(*`,*`))),int,enum(int,int)))
)	O
;	O
}	O
