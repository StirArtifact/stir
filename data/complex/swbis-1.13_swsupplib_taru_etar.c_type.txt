ETAR	struct(int,*(char),long)
*	O
etar_open	(int)->(*(struct(int,*(char),long)))
(	O
int	O
flags	int
)	O
{	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
;	O
etar	*(struct(int,*(char),long))
=	O
(	O
ETAR	struct(int,*(char),long)
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
ETAR	struct(int,*(char),long)
)	O
)	O
;	O
if	O
(	O
!	O
etar	*(struct(int,*(char),long))
)	O
return	O
etar	*(struct(int,*(char),long))
;	O
etar	*(struct(int,*(char),long))
->	O
etar_tarheaderflagsM	int
=	O
flags	int
;	O
etar	*(struct(int,*(char),long))
->	O
timeM	long
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
etar	*(struct(int,*(char),long))
->	O
tar_hdrM	*(char)
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
(	O
size_t	long
)	O
(	O
HEADER_ALLOC	int
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
etar	*(struct(int,*(char),long))
->	O
tar_hdrM	*(char)
,	O
'\0'	O
,	O
(	O
size_t	long
)	O
(	O
HEADER_ALLOC	int
)	O
)	O
;	O
return	O
etar	*(struct(int,*(char),long))
;	O
}	O
void	O
etar_close	(*(struct(int,*(char),long)))->(void)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
)	O
{	O
free	(*(void))->(void)
(	O
etar	*(struct(int,*(char),long))
->	O
tar_hdrM	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
etar	*(struct(int,*(char),long))
)	O
;	O
}	O
struct	O
tar_header	struct(array(char),array(char),array(char),array(char),array(char),array(char),array(char),char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))
*	O
etar_get_hdr	(*(struct(int,*(char),long)))->(*(struct(array(char),array(char),array(char),array(char),array(char),array(char),array(char),char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))))
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
)	O
{	O
return	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
;	O
}	O
void	O
etar_init_hdr	(*(struct(int,*(char),long)))->(void)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
etar	*(struct(int,*(char),long))
->	O
tar_hdrM	*(char)
,	O
'\0'	O
,	O
(	O
size_t	long
)	O
(	O
HEADER_ALLOC	int
)	O
)	O
;	O
*	O
(	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
version	array(char)
)	O
=	O
'0'	O
;	O
*	O
(	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
version	array(char)
+	O
1	int
)	O
=	O
'0'	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
magic	array(char)
,	O
TMAGIC	*(char)
,	O
TMAGLEN	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
magic	array(char)
+	O
TMAGLEN	int
,	O
TVERSION	*(char)
,	O
TVERSLEN	int
)	O
;	O
etar_set_pathname	(*(struct(int,*(char),long)),*(char))->(int)
(	O
etar	*(struct(int,*(char),long))
,	O
ETAR_UNSET_FILENAME	*(char)
)	O
;	O
etar_set_mode_ul	(*(struct(int,*(char),long)),int)->(void)
(	O
etar	*(struct(int,*(char),long))
,	O
(	O
unsigned	O
int	O
)	O
(	O
0550	int
)	O
)	O
;	O
etar_set_uid	(*(struct(int,*(char),long)),int)->(void)
(	O
etar	*(struct(int,*(char),long))
,	O
0	int
)	O
;	O
etar_set_gid	(*(struct(int,*(char),long)),int)->(void)
(	O
etar	*(struct(int,*(char),long))
,	O
0	int
)	O
;	O
etar_set_size	(*(struct(int,*(char),long)),int)->(void)
(	O
etar	*(struct(int,*(char),long))
,	O
0	int
)	O
;	O
etar_set_time	(*(struct(int,*(char),long)),long)->(void)
(	O
etar	*(struct(int,*(char),long))
,	O
etar	*(struct(int,*(char),long))
->	O
timeM	long
)	O
;	O
etar_set_typeflag	(*(struct(int,*(char),long)),int)->(void)
(	O
etar	*(struct(int,*(char),long))
,	O
DIRTYPE	char
)	O
;	O
etar_set_linkname	(*(struct(int,*(char),long)),*(char))->(int)
(	O
etar	*(struct(int,*(char),long))
,	O
""	*(char)
)	O
;	O
etar_set_uname	(*(struct(int,*(char),long)),*(char))->(int)
(	O
etar	*(struct(int,*(char),long))
,	O
""	*(char)
)	O
;	O
etar_set_gname	(*(struct(int,*(char),long)),*(char))->(int)
(	O
etar	*(struct(int,*(char),long))
,	O
""	*(char)
)	O
;	O
etar_set_devmajor	(*(struct(int,*(char),long)),long)->(void)
(	O
etar	*(struct(int,*(char),long))
,	O
(	O
unsigned	O
long	O
)	O
(	O
0	int
)	O
)	O
;	O
etar_set_devminor	(*(struct(int,*(char),long)),long)->(void)
(	O
etar	*(struct(int,*(char),long))
,	O
(	O
unsigned	O
long	O
)	O
(	O
0	int
)	O
)	O
;	O
etar_set_chksum	(*(struct(int,*(char),long)))->(void)
(	O
etar	*(struct(int,*(char),long))
)	O
;	O
}	O
int	O
etar_emit_header	(*(struct(int,*(char),long)),int)->(int)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
int	O
fd	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
atomicio	(*((int,*(void),long)->(long)),int,*(void),long)->(long)
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
(	O
write	*((*(void),*(char),long)->(long))
)	O
,	O
fd	int
,	O
(	O
void	O
*	O
)	O
(	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
)	O
,	O
TARRECORDSIZE	int
)	O
;	O
if	O
(	O
ret	int
!=	O
TARRECORDSIZE	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
return	O
TARRECORDSIZE	int
;	O
}	O
int	O
etar_emit_data_from_fd	(*(struct(int,*(char),long)),int,int)->(int)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
int	O
ofd	int
,	O
int	O
ifd	int
)	O
{	O
int	O
ret	int
;	O
int	O
ret1	int
;	O
int	O
remains	int
;	O
ret	int
=	O
swlib_pipe_pump	(int,int)->(int)
(	O
ofd	int
,	O
ifd	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: etar_emit_data_from_fd(): loc=1: ret = %d\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
ret	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
remains	int
=	O
ret	int
%	O
TARRECORDSIZE	int
;	O
if	O
(	O
ret	int
&&	O
remains	int
>	O
0	int
)	O
{	O
remains	int
=	O
TARRECORDSIZE	int
-	O
remains	int
;	O
ret1	int
=	O
swlib_pad_amount	(int,int)->(int)
(	O
ofd	int
,	O
remains	int
)	O
;	O
if	O
(	O
ret1	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: etar_emit_data_from_fd(): loc=2: ret = %d\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
ret	int
)	O
;	O
return	O
-	O
2	int
;	O
}	O
}	O
else	O
{	O
remains	int
=	O
0	int
;	O
}	O
return	O
ret	int
+	O
remains	int
;	O
}	O
int	O
etar_emit_data_from_buffer	(*(struct(int,*(char),long)),int,*(char),int)->(int)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
int	O
ofd	int
,	O
char	O
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
bufsize	int
)	O
{	O
int	O
len	int
;	O
int	O
ret	int
;	O
int	O
ret1	int
;	O
int	O
remains	int
;	O
if	O
(	O
bufsize	int
<	O
0	int
)	O
len	int
=	O
strlen	(*(char))->(long)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
else	O
len	int
=	O
bufsize	int
;	O
ret	int
=	O
atomicio	(*((int,*(void),long)->(long)),int,*(void),long)->(long)
(	O
uxfio_write	(int,*(void),long)->(long)
,	O
ofd	int
,	O
(	O
void	O
*	O
)	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
len	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
ret	int
;	O
if	O
(	O
ret	int
!=	O
len	int
)	O
return	O
-	O
2	int
;	O
remains	int
=	O
ret	int
%	O
TARRECORDSIZE	int
;	O
if	O
(	O
ret	int
&&	O
remains	int
>	O
0	int
)	O
{	O
remains	int
=	O
TARRECORDSIZE	int
-	O
remains	int
;	O
ret1	int
=	O
swlib_pad_amount	(int,int)->(int)
(	O
ofd	int
,	O
remains	int
)	O
;	O
if	O
(	O
ret1	int
<	O
0	int
)	O
return	O
-	O
2	int
;	O
}	O
else	O
{	O
remains	int
=	O
0	int
;	O
}	O
return	O
ret	int
+	O
remains	int
;	O
}	O
int	O
etar_set_size_from_buffer	(*(struct(int,*(char),long)),*(char),int)->(int)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
char	O
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
bufsize	int
)	O
{	O
int	O
len	int
;	O
if	O
(	O
bufsize	int
<	O
0	int
)	O
len	int
=	O
strlen	(*(char))->(long)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
else	O
len	int
=	O
bufsize	int
;	O
etar_set_size	(*(struct(int,*(char),long)),int)->(void)
(	O
etar	*(struct(int,*(char),long))
,	O
(	O
unsigned	O
int	O
)	O
(	O
len	int
)	O
)	O
;	O
return	O
len	int
;	O
}	O
int	O
etar_set_size_from_fd	(*(struct(int,*(char),long)),int,*(int))->(int)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
int	O
fd	int
,	O
int	O
*	O
newfd	*(int)
)	O
{	O
int	O
tmp_fd	int
;	O
int	O
size	long
;	O
int	O
vfd	int
;	O
if	O
(	O
newfd	*(int)
)	O
*	O
newfd	*(int)
=	O
-	O
1	int
;	O
if	O
(	O
uxfio_espipe	(int)->(int)
(	O
fd	int
)	O
)	O
{	O
tmp_fd	int
=	O
swlib_open_memfd	()->(int)
(	O
)	O
;	O
swlib_pipe_pump	(int,int)->(int)
(	O
tmp_fd	int
,	O
fd	int
)	O
;	O
vfd	int
=	O
tmp_fd	int
;	O
if	O
(	O
newfd	*(int)
==	O
NULL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"usage error in etar_set_size_from_fd\n"	*(char)
)	O
;	O
if	O
(	O
newfd	*(int)
)	O
*	O
newfd	*(int)
=	O
tmp_fd	int
;	O
}	O
else	O
{	O
vfd	int
=	O
fd	int
;	O
}	O
size	long
=	O
(	O
size_t	long
)	O
uxfio_lseek	(int,long,int)->(long)
(	O
vfd	int
,	O
0	int
,	O
SEEK_END	int
)	O
;	O
if	O
(	O
size	long
<	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
etar_set_size	(*(struct(int,*(char),long)),int)->(void)
(	O
etar	*(struct(int,*(char),long))
,	O
(	O
unsigned	O
int	O
)	O
(	O
size	long
)	O
)	O
;	O
uxfio_lseek	(int,long,int)->(long)
(	O
vfd	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
return	O
size	long
;	O
}	O
int	O
etar_set_pathname	(*(struct(int,*(char),long)),*(char))->(int)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
char	O
*	O
pathname	*(char)
)	O
{	O
return	O
taru_set_new_name	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char),array(char),char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))),int,*(char),int)->(int)
(	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
,	O
-	O
1	int
,	O
pathname	*(char)
,	O
etar	*(struct(int,*(char),long))
->	O
etar_tarheaderflagsM	int
)	O
;	O
}	O
int	O
etar_set_linkname	(*(struct(int,*(char),long)),*(char))->(int)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
char	O
*	O
name	*(char)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
linkname	*(char)
,	O
'\0'	O
,	O
100	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
linkname	*(char)
,	O
name	*(char)
,	O
100	int
)	O
;	O
return	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
<=	O
100	int
?	O
0	int
:	O
1	int
;	O
}	O
int	O
etar_set_uname	(*(struct(int,*(char),long)),*(char))->(int)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
char	O
*	O
name	*(char)
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
uname	array(char)
,	O
name	*(char)
,	O
THB_FL_uname	int
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
>	O
THB_FL_uname	int
)	O
return	O
-	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
int	O
etar_set_gname	(*(struct(int,*(char),long)),*(char))->(int)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
char	O
*	O
name	*(char)
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
gname	array(char)
,	O
name	*(char)
,	O
THB_FL_gname	int
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
>	O
THB_FL_gname	int
)	O
return	O
-	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
void	O
etar_set_chksum	(*(struct(int,*(char),long)))->(void)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
)	O
{	O
taru_set_tar_header_sum	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char),array(char),char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))),int)->(int)
(	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
,	O
etar	*(struct(int,*(char),long))
->	O
etar_tarheaderflagsM	int
)	O
;	O
}	O
void	O
etar_set_mode_ul	(*(struct(int,*(char),long)),int)->(void)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
unsigned	O
int	O
mode_i	int
)	O
{	O
MODE_TO_CHARS	O
(	O
mode_i	int
,	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
mode	int
,	O
0	int
)	O
;	O
}	O
void	O
etar_set_uid	(*(struct(int,*(char),long)),int)->(void)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
unsigned	O
int	O
val	array(int)
)	O
{	O
UID_TO_CHARS	O
(	O
val	array(int)
,	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
uid	int
,	O
0	int
)	O
;	O
}	O
void	O
etar_set_gid	(*(struct(int,*(char),long)),int)->(void)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
unsigned	O
int	O
val	array(int)
)	O
{	O
GID_TO_CHARS	O
(	O
val	array(int)
,	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
gid	int
,	O
0	int
)	O
;	O
}	O
void	O
etar_set_size	(*(struct(int,*(char),long)),int)->(void)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
unsigned	O
int	O
val	array(int)
)	O
{	O
OFF_TO_CHARS	O
(	O
val	array(int)
,	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
size	long
,	O
0	int
)	O
;	O
}	O
void	O
etar_set_time	(*(struct(int,*(char),long)),long)->(void)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
time_t	long
val	array(int)
)	O
{	O
TIME_TO_CHARS	O
(	O
(	O
unsigned	O
long	O
int	O
)	O
(	O
val	array(int)
)	O
,	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
mtime	long
,	O
0	int
)	O
;	O
}	O
void	O
etar_set_typeflag	(*(struct(int,*(char),long)),int)->(void)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
int	O
tar_type	int
)	O
{	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
typeflag	char
=	O
tar_type	int
;	O
}	O
void	O
etar_set_devmajor	(*(struct(int,*(char),long)),long)->(void)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
unsigned	O
long	O
devno	long
)	O
{	O
MAJOR_TO_CHARS	O
(	O
devno	long
,	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
devmajor	array(char)
,	O
0	int
)	O
;	O
}	O
void	O
etar_set_devminor	(*(struct(int,*(char),long)),long)->(void)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
unsigned	O
long	O
devno	long
)	O
{	O
MINOR_TO_CHARS	O
(	O
devno	long
,	O
HDR	O
(	O
etar	*(struct(int,*(char),long))
)	O
->	O
devminor	array(char)
,	O
0	int
)	O
;	O
}	O
int	O
etar_write_trailer_blocks	(*(struct(int,*(char),long)),int,int)->(int)
(	O
ETAR	struct(int,*(char),long)
*	O
etar	*(struct(int,*(char),long))
,	O
int	O
ofd	int
,	O
int	O
nblocks	int
)	O
{	O
int	O
ret	int
;	O
int	O
retval	int
=	O
0	int
;	O
int	O
count	int
=	O
nblocks	int
;	O
static	O
char	O
*	O
nullblock	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
nullblock	*(char)
)	O
{	O
nullblock	*(char)
=	O
malloc	(long)->(*(void))
(	O
512	int
)	O
;	O
if	O
(	O
!	O
nullblock	*(char)
)	O
{	O
exit	(int)->(void)
(	O
44	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
nullblock	*(char)
,	O
'\0'	O
,	O
512	int
)	O
;	O
while	O
(	O
count	int
--	O
>	O
0	int
)	O
{	O
ret	int
=	O
uxfio_unix_atomic_write	(int,*(void),long)->(long)
(	O
ofd	int
,	O
(	O
void	O
*	O
)	O
(	O
nullblock	*(char)
)	O
,	O
(	O
size_t	long
)	O
(	O
512	int
)	O
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: etar_write_trailer_blocks(): %s\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
retval	int
+=	O
512	int
;	O
}	O
if	O
(	O
retval	int
!=	O
(	O
512	int
*	O
nblocks	int
)	O
)	O
{	O
SWLIB_FATAL	O
(	O
""	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
retval	int
;	O
}	O
