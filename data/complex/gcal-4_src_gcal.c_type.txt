__BEGIN_DECLARATIONS	O
static	O
Bool	int
is_correct_date_format	(*(char),*(int),*(int),*(int),*(int))->(int)
__P_	O
(	O
(	O
char	O
*	O
format_txt	*(char)
,	O
Bool	int
*	O
use_day_suffix	*(int)
,	O
Bool	int
*	O
use_short3_day_name	int
,	O
Bool	int
*	O
use_day_zeroleaded	int
,	O
Bool	int
*	O
use_year_zeroleaded	int
)	O
)	O
;	O
static	O
void	O
rearrange_argv	(*(char),*(int),array(*(char)))->(void)
__P_	O
(	O
(	O
const	O
char	O
*	O
opt_list	*(char)
,	O
int	O
*	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
)	O
;	O
static	O
void	O
check_command_line	(int,array(*(char)))->(void)
__P_	O
(	O
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
)	O
;	O
static	O
void	O
build_month_list	(array(*(char)))->(void)
__P_	O
(	O
(	O
char	O
*	O
argv	array(*(char))
[	O
]	O
)	O
)	O
;	O
static	O
void	O
eliminate_invalid_data	()->(void)
__P_	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
pseudo_blank_conversion	(*(*(char)))->(void)
__P_	O
(	O
(	O
char	O
*	O
*	O
text	*(*(char))
)	O
)	O
;	O
static	O
int	O
further_check	(*(*(char)))->(int)
__P_	O
(	O
(	O
char	O
*	O
*	O
option	*(*(char))
)	O
)	O
;	O
__END_DECLARATIONS	O
const	O
int	O
dvec	array(int)
[	O
]	O
=	O
{	O
31	int
,	O
28	int
,	O
31	int
,	O
30	int
,	O
31	int
,	O
30	int
,	O
31	int
,	O
31	int
,	O
30	int
,	O
31	int
,	O
30	int
,	O
31	int
}	O
;	O
const	O
int	O
mvec	array(int)
[	O
]	O
=	O
{	O
0	int
,	O
31	int
,	O
59	int
,	O
90	int
,	O
120	int
,	O
151	int
,	O
181	int
,	O
212	int
,	O
243	int
,	O
273	int
,	O
304	int
,	O
334	int
}	O
;	O
const	O
Lopt_struct	struct(int,*(char),array(*(char)),int,array(*(char)))
lopt	array(struct(int,*(char),array(*(char)),int,array(*(char))))
[	O
]	O
=	O
{	O
{	O
SYM_ADJUST_VALUE	int
,	O
"adjust-value"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ALTERNATIVE_FORMAT	int
,	O
"alternative-format"	*(char)
,	O
{	O
"A"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ASTRONOMICAL_HDY	int
,	O
"astronomical-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ATMOSPHERE	int
,	O
"atmosphere"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_BAHAI_HDY	int
,	O
"bahai-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_BAHAI_MTH	int
,	O
"bahai-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_BIORHYTHM_AXIS_LEN	int
,	O
"biorhythm-axis"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_BLOCKS	int
,	O
"blocks"	*(char)
,	O
{	O
"b"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_CALENDAR_DATES	int
,	O
"calendar-dates"	*(char)
,	O
{	O
"j"	*(char)
,	O
"jb"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
"special"	*(char)
,	O
"both"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_CC_HDY	int
,	O
"cc-holidays"	*(char)
,	O
{	O
"q"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_CELTIC_HDY	int
,	O
"celtic-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_CHINESE_FLEXIBLE_HDY	int
,	O
"chinese-flexible-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_CHINESE_FLEXIBLE_MTH	int
,	O
"chinese-flexible-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_CHINESE_HDY	int
,	O
"chinese-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_CHINESE_MTH	int
,	O
"chinese-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_CHRISTIAN_HDY	int
,	O
"christian-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_COPTIC_MTH	int
,	O
"coptic-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_LICENSE2	int
,	O
"copyleft"	*(char)
,	O
{	O
"L"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_LICENSE3	int
,	O
"copyright"	*(char)
,	O
{	O
"L"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_CYCLE_END	int
,	O
"cycle-end"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_CYCLE_STEP	int
,	O
"cycle-step"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_DATE_FORMAT	int
,	O
"date-format"	*(char)
,	O
{	O
"!\001"	*(char)
,	O
"!\002"	*(char)
,	O
"!\003"	*(char)
,	O
"!"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE_OR_ARG	int
,	O
{	O
CC_DE	*(char)
,	O
CC_US	*(char)
,	O
CC_GB	*(char)
,	O
N_	O
(	O
"ARG"	*(char)
)	O
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_DATE_VARIABLE	int
,	O
"date-variable"	*(char)
,	O
{	O
"v"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_DEBUG	int
,	O
"debug"	*(char)
,	O
{	O
"0"	*(char)
,	O
"1"	*(char)
,	O
"2"	*(char)
,	O
"3"	*(char)
,	O
"4"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO_OR_ONE	int
,	O
{	O
"internal"	*(char)
,	O
"handled"	*(char)
,	O
"unhandled"	*(char)
,	O
"all"	*(char)
,	O
"abort"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_DESC_FIXED_DATES_LIST	int
,	O
"descending-fixed-dates"	*(char)
,	O
{	O
"c-"	*(char)
,	O
"C-"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO_OR_ONE	int
,	O
{	O
"short"	*(char)
,	O
"long"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_DESC_HOLIDAY_LIST	int
,	O
"descending-holiday-list"	*(char)
,	O
{	O
"n-"	*(char)
,	O
"N-"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO_OR_ONE	int
,	O
{	O
"long"	*(char)
,	O
"short"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_DISABLE_HIGHLIGHTING	int
,	O
"disable-highlighting"	*(char)
,	O
{	O
"Hno"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_END_OF_MONTH	int
,	O
"end-of-month"	*(char)
,	O
{	O
"m+"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_END_OF_WEEK	int
,	O
"end-of-week"	*(char)
,	O
{	O
"w+"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_END_OF_YEAR	int
,	O
"end-of-year"	*(char)
,	O
{	O
"y+"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ETHIOPIC_MTH	int
,	O
"ethiopic-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_EXCLUDE_RC_TITLE	int
,	O
"exclude-fixed-dates-list-title"	*(char)
,	O
{	O
"x"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_EXCLUDE_HD_TITLE	int
,	O
"exclude-holiday-list-title"	*(char)
,	O
{	O
"X"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_EXECUTE_COMMAND	int
,	O
"execute-command"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_EXIT_STAT_HELP_NON_ZERO	int
,	O
"exit-status-help-non-zero"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_extern_static_DVARS	int
,	O
"export-date-variables"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_extern_static_TVARS	int
,	O
"export-text-variables"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_FILTER_DAY	int
,	O
"filter-day"	*(char)
,	O
{	O
"D"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_FILTER_PERIOD	int
,	O
"filter-period"	*(char)
,	O
{	O
"P"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_FILTER_TEXT	int
,	O
"filter-text"	*(char)
,	O
{	O
"I"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_FIXED_DATES	int
,	O
"fixed-dates"	*(char)
,	O
{	O
"jc"	*(char)
,	O
"jcb"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
"special"	*(char)
,	O
"both"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_FORCE_HIGHLIGHTING	int
,	O
"force-highlighting"	*(char)
,	O
{	O
"Hyes"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_FRENCH_REVOLUTIONARY_MTH	int
,	O
"french-revolutionary-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_GREG_REFORM	int
,	O
"gregorian-reform"	*(char)
,	O
{	O
"$\001"	*(char)
,	O
"$\002"	*(char)
,	O
"$\003"	*(char)
,	O
"$\004"	*(char)
,	O
"$"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE_OR_ARG	int
,	O
{	O
"1582"	*(char)
,	O
"1700"	*(char)
,	O
"1752"	*(char)
,	O
"1753"	*(char)
,	O
N_	O
(	O
"ARG"	*(char)
)	O
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_GROUPING_TEXT	int
,	O
"grouping-text"	*(char)
,	O
{	O
"g"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO_OR_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_HEADING_TEXT	int
,	O
"heading-text"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_HEBREW_HDY	int
,	O
"hebrew-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_HEBREW_MTH	int
,	O
"hebrew-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_LONG_HELP1	int
,	O
"help"	*(char)
,	O
{	O
"h"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_HERE_FILE	int
,	O
"here"	*(char)
,	O
{	O
"#"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_HIGHLIGHTING	int
,	O
"highlighting"	*(char)
,	O
{	O
"H"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_HOLIDAY_DATES	int
,	O
"holiday-dates"	*(char)
,	O
{	O
"jn"	*(char)
,	O
"jnb"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
"special"	*(char)
,	O
"both"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_HOLIDAY_LIST	int
,	O
"holiday-list"	*(char)
,	O
{	O
"n"	*(char)
,	O
"N"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO_OR_ONE	int
,	O
{	O
"long"	*(char)
,	O
"short"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_IGNORE_CASE	int
,	O
"ignore-case"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_INCLUDE_CONS_NUMBER	int
,	O
"include-consecutive-number"	*(char)
,	O
{	O
"z"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_INCLUDE_HOLIDAY	int
,	O
"include-holidays"	*(char)
,	O
{	O
"e"	*(char)
,	O
"E"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO_OR_ONE	int
,	O
{	O
"long"	*(char)
,	O
"short"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_INCLUDE_FILENAME	int
,	O
"include-resource-file-name"	*(char)
,	O
{	O
"a"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_INCLUDE_TODAY	int
,	O
"include-today"	*(char)
,	O
{	O
"d"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_INCLUDE_WEEK_NUMBER	int
,	O
"include-week-number"	*(char)
,	O
{	O
"k"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_INDIAN_CIVIL_MTH	int
,	O
"indian-civil-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ISLAMIC_HDY	int
,	O
"islamic-civil-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ISLAMIC_MTH	int
,	O
"islamic-civil-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ISO_WEEK_NUMBER	int
,	O
"iso-week-number"	*(char)
,	O
{	O
"y"	*(char)
,	O
"n"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
"yes"	*(char)
,	O
"no"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_JAPANESE_FLEXIBLE_HDY	int
,	O
"japanese-flexible-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_JAPANESE_FLEXIBLE_MTH	int
,	O
"japanese-flexible-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_JAPANESE_HDY	int
,	O
"japanese-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_JAPANESE_MTH	int
,	O
"japanese-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_LEAP_DAY	int
,	O
"leap-day"	*(char)
,	O
{	O
"f"	*(char)
,	O
"m"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
"february"	*(char)
,	O
"march"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_LICENSE1	int
,	O
"license"	*(char)
,	O
{	O
"L"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_LIMIT	int
,	O
"limit"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_LIST_MODE	int
,	O
"list-mode"	*(char)
,	O
{	O
"l"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_FIXED_DATES_LIST	int
,	O
"list-of-fixed-dates"	*(char)
,	O
{	O
"c"	*(char)
,	O
"C"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO_OR_ONE	int
,	O
{	O
"short"	*(char)
,	O
"long"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_LONG_HELP1	int
,	O
"long-help"	*(char)
,	O
{	O
"hh"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO_OR_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_MAIL	int
,	O
"mail"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO_OR_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_MONTH	int
,	O
"month"	*(char)
,	O
{	O
"m"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_MOONIMAGE_LINES	int
,	O
"moonimage-lines"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_MULTICULTURAL_NEW_YEAR_HDY	int
,	O
"multicultural-new-year-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_OLD_ARMENIC_MTH	int
,	O
"old-armenic-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_OLD_EGYPTIC_MTH	int
,	O
"old-egyptic-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_OMIT_DATE_PART	int
,	O
"omit-multiple-date-part"	*(char)
,	O
{	O
"o"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ORTHODOX_CALENDAR	int
,	O
"orthodox-calendar"	*(char)
,	O
{	O
"O"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ORTHODOX_NEW_HDY	int
,	O
"orthodox-new-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ORTHODOX_OLD_HDY	int
,	O
"orthodox-old-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_PAGER	int
,	O
"pager"	*(char)
,	O
{	O
"p"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_PERIOD	int
,	O
"period-of-fixed-dates"	*(char)
,	O
{	O
"c"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_PERSIAN_HDY	int
,	O
"persian-jalaali-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_PERSIAN_MTH	int
,	O
"persian-jalaali-months"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_PRECISE	int
,	O
"precise"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_RESOURCE_FILE	int
,	O
"resource-file"	*(char)
,	O
{	O
"f"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_RESPONSE_FILE	int
,	O
"response-file"	*(char)
,	O
{	O
"R"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_REVERT_MATCH	int
,	O
"revert-match"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_SCRIPT_FILE	int
,	O
"shell-script"	*(char)
,	O
{	O
"S"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_START_OF_MONTH	int
,	O
"start-of-month"	*(char)
,	O
{	O
"m-"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_START_OF_WEEK	int
,	O
"start-of-week"	*(char)
,	O
{	O
"w-"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_START_OF_YEAR	int
,	O
"start-of-year"	*(char)
,	O
{	O
"y-"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_STARTING_DAY	int
,	O
"starting-day"	*(char)
,	O
{	O
"s"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_SUPPRESS_CALENDAR	int
,	O
"suppress-calendar"	*(char)
,	O
{	O
"u"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_SUPPRESS_DATE_PART	int
,	O
"suppress-date-part"	*(char)
,	O
{	O
"U"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_SUPPRESS_FDLIST_SEP	int
,	O
"suppress-fixed-dates-list-separator"	*(char)
,	O
{	O
"Q"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_SUPPRESS_HDLIST_SEP	int
,	O
"suppress-holiday-list-separator"	*(char)
,	O
{	O
"G"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_SUPPRESS_TEXT_PART	int
,	O
"suppress-text-part"	*(char)
,	O
{	O
"J"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_TEXT_VARIABLE	int
,	O
"text-variable"	*(char)
,	O
{	O
"r"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_TIME_OFFSET	int
,	O
"time-offset"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_TODAY	int
,	O
"today"	*(char)
,	O
{	O
"c"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_TOMORROW	int
,	O
"tomorrow"	*(char)
,	O
{	O
"t"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_TRANSFORM_YEAR	int
,	O
"transform-year"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_TRANSLATE_STRING	int
,	O
"translate-string"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_TYPE_OF_CALENDAR	int
,	O
"type"	*(char)
,	O
{	O
"i"	*(char)
,	O
"i-"	*(char)
,	O
NULL	O
}	O
,	O
LARG_ONE	int
,	O
{	O
"special"	*(char)
,	O
"standard"	*(char)
,	O
NULL	O
}	O
}	O
,	O
{	O
SYM_LONG_HELP2	int
,	O
"usage"	*(char)
,	O
{	O
"hh"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO_OR_ONE	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_VERSION	int
,	O
"version"	*(char)
,	O
{	O
"V"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_WEEK	int
,	O
"week"	*(char)
,	O
{	O
"w"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_CALENDAR_WITH_WEEK_NUMBER	int
,	O
"with-week-number"	*(char)
,	O
{	O
"K"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_YEAR	int
,	O
"year"	*(char)
,	O
{	O
"y"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ZERO_DATES	int
,	O
"zero-dates-only"	*(char)
,	O
{	O
"Z"	*(char)
,	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_ZODIACAL_MARKER_HDY	int
,	O
"zodiacal-marker-holidays"	*(char)
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
,	O
{	O
SYM_NIL	int
,	O
NULL	O
,	O
{	O
NULL	O
}	O
,	O
LARG_NO	int
,	O
{	O
NULL	O
}	O
}	O
}	O
;	O
Df_struct	struct(*(char),*(char),*(char))
supported_date_format	array(struct(*(char),*(char),*(char)))
[	O
LARG_MAX	int
-	O
1	int
]	O
=	O
{	O
{	O
CC_DE	*(char)
,	O
N_	O
(	O
"Germany"	*(char)
)	O
,	O
"%<2#K,  %1%>2*D%2 %<3#U %>04*Y"	*(char)
}	O
,	O
{	O
CC_US	*(char)
,	O
N_	O
(	O
"U.S.A."	*(char)
)	O
,	O
"%<3#K,  %<3#U %1%>2&*D%2 %>04*Y"	*(char)
}	O
,	O
{	O
CC_GB	*(char)
,	O
N_	O
(	O
"Great Britain"	*(char)
)	O
,	O
"%<3#K,  %1%>2&*D%2 %<3#U %>04*Y"	*(char)
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
Df_struct	struct(*(char),*(char),*(char))
*	O
date_format	*(struct(*(char),*(char),*(char)))
=	O
supported_date_format	array(struct(*(char),*(char),*(char)))
;	O
Greg_struct	struct(int,int,int,int)
greg_reform_date	array(struct(int,int,int,int))
[	O
LARG_MAX	int
-	O
1	int
]	O
=	O
{	O
{	O
1582	int
,	O
10	int
,	O
5	int
,	O
14	int
}	O
,	O
{	O
1700	int
,	O
2	int
,	O
19	int
,	O
28	int
}	O
,	O
{	O
1752	int
,	O
9	int
,	O
3	int
,	O
13	int
}	O
,	O
{	O
1753	int
,	O
2	int
,	O
18	int
,	O
28	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
Greg_struct	struct(int,int,int,int)
*	O
greg	*(struct(int,int,int,int))
=	O
greg_reform_date	array(struct(int,int,int,int))
;	O
Greg_struct	struct(int,int,int,int)
users_greg	struct(int,int,int,int)
;	O
FILE	struct
*	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
(	O
FILE	struct
*	O
)	O
NULL	O
;	O
Ml_struct	struct(int,int)
*	O
month_list	*(struct(int,int))
=	O
(	O
Ml_struct	struct(int,int)
*	O
)	O
NULL	O
;	O
Hls_struct	struct(*(char),int)
ehls1s	struct(*(char),int)
;	O
Hls_struct	struct(*(char),int)
ehls1e	struct(*(char),int)
;	O
Hls_struct	struct(*(char),int)
ehls2s	struct(*(char),int)
;	O
Hls_struct	struct(*(char),int)
ehls2e	struct(*(char),int)
;	O
Uint	int
testval	int
=	O
(	O
Uint	int
)	O
0	int
;	O
Uint	int
maxlen_max	int
=	O
MAXLEN_MAX	int
;	O
int	O
len_year_max	int
=	O
0	int
;	O
int	O
len_dayname_max	int
=	O
0	int
;	O
int	O
len_monthname_max	int
=	O
0	int
;	O
int	O
len_suffix_max	int
=	O
0	int
;	O
int	O
warning_level	int
=	O
SPECIAL_VALUE	O
;	O
int	O
start_day	int
=	O
0	int
;	O
int	O
transform_year	int
=	O
0	int
;	O
int	O
time_hour_offset	int
=	O
0	int
;	O
int	O
time_min_offset	int
=	O
0	int
;	O
int	O
day	int
=	O
0	int
;	O
int	O
month	int
=	O
0	int
;	O
int	O
year	int
=	O
0	int
;	O
int	O
act_sec	int
=	O
0	int
;	O
int	O
act_min	int
=	O
0	int
;	O
int	O
act_hour	int
=	O
0	int
;	O
int	O
act_day	int
=	O
0	int
;	O
int	O
act_month	int
=	O
0	int
;	O
int	O
act_year	int
=	O
0	int
;	O
int	O
buf_ad	int
=	O
0	int
;	O
int	O
buf_am	int
=	O
0	int
;	O
int	O
buf_ay	int
=	O
0	int
;	O
int	O
true_day	int
=	O
0	int
;	O
int	O
true_month	int
=	O
0	int
;	O
int	O
true_year	int
=	O
0	int
;	O
int	O
fiscal_month	int
=	O
MONTH_MIN	int
;	O
int	O
is_tty	int
=	O
0	int
;	O
int	O
is_tty1	int
=	O
0	int
;	O
int	O
is_tty2	int
=	O
0	int
;	O
int	O
tty_rows	int
=	O
SPECIAL_VALUE	O
;	O
int	O
tty_cols	int
=	O
SPECIAL_VALUE	O
;	O
int	O
out_rows	int
=	O
0	int
;	O
int	O
out_cols	int
=	O
0	int
;	O
int	O
format_len	int
=	O
0	int
;	O
int	O
is_leap_year	int
=	O
0	int
;	O
char	O
*	O
tfn	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
email_adr	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
cc	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
yy_lit	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
yyyy_lit	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
mm_lit	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
www_lit	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
dd_lit	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
larg_lit	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
s1	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
s2	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
s3	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
s4	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
prgr_name	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
time_sep	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
translate_string	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
tz	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
char	O
*	O
ext_pager	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
Bool	int
use_day_suffix	*(int)
=	O
FALSE	O
;	O
Bool	int
use_short3_day_name	int
=	O
FALSE	O
;	O
Bool	int
use_day_zeroleaded	int
=	O
FALSE	O
;	O
Bool	int
use_year_zeroleaded	int
=	O
FALSE	O
;	O
Bool	int
hdy_astronomical	int
=	O
FALSE	O
;	O
Bool	int
hdy_bahai	int
=	O
FALSE	O
;	O
Bool	int
hdy_celtic	int
=	O
FALSE	O
;	O
Bool	int
hdy_chinese	int
=	O
FALSE	O
;	O
Bool	int
hdy_chinese_flexible	int
=	O
FALSE	O
;	O
Bool	int
hdy_christian	int
=	O
FALSE	O
;	O
Bool	int
hdy_hebrew	int
=	O
FALSE	O
;	O
Bool	int
hdy_islamic	int
=	O
FALSE	O
;	O
Bool	int
hdy_japanese	int
=	O
FALSE	O
;	O
Bool	int
hdy_japanese_flexible	int
=	O
FALSE	O
;	O
Bool	int
hdy_multicultural_new_year	int
=	O
FALSE	O
;	O
Bool	int
hdy_orthodox_new	int
=	O
FALSE	O
;	O
Bool	int
hdy_orthodox_old	int
=	O
FALSE	O
;	O
Bool	int
hdy_persian	int
=	O
FALSE	O
;	O
Bool	int
hdy_zodiacal_marker	int
=	O
FALSE	O
;	O
Bool	int
mth_bahai	int
=	O
FALSE	O
;	O
Bool	int
mth_chinese	int
=	O
FALSE	O
;	O
Bool	int
mth_chinese_flexible	int
=	O
FALSE	O
;	O
Bool	int
mth_coptic	int
=	O
FALSE	O
;	O
Bool	int
mth_ethiopic	int
=	O
FALSE	O
;	O
Bool	int
mth_french_revolutionary	int
=	O
FALSE	O
;	O
Bool	int
mth_hebrew	int
=	O
FALSE	O
;	O
Bool	int
mth_indian_civil	int
=	O
FALSE	O
;	O
Bool	int
mth_islamic	int
=	O
FALSE	O
;	O
Bool	int
mth_japanese	int
=	O
FALSE	O
;	O
Bool	int
mth_japanese_flexible	int
=	O
FALSE	O
;	O
Bool	int
mth_old_armenic	int
=	O
FALSE	O
;	O
Bool	int
mth_old_egyptic	int
=	O
FALSE	O
;	O
Bool	int
mth_persian	int
=	O
FALSE	O
;	O
Bool	int
orthodox_calendar	int
=	O
FALSE	O
;	O
Bool	int
suppr_cal_flag	int
=	O
FALSE	O
;	O
Bool	int
highlight_flag	int
=	O
TRUE	O
;	O
Bool	int
iso_week_number	int
=	O
FALSE	O
;	O
Bool	int
cal_with_week_number	int
=	O
FALSE	O
;	O
Bool	int
cal_special_flag	int
=	O
FALSE	O
;	O
Bool	int
cal_both_dates_flag	int
=	O
FALSE	O
;	O
Bool	int
holiday_flag	int
=	O
FALSE	O
;	O
Bool	int
hd_legal_days_only	int
=	O
FALSE	O
;	O
Bool	int
hd_sort_des_flag	int
=	O
FALSE	O
;	O
Bool	int
hd_special_flag	int
=	O
FALSE	O
;	O
Bool	int
hd_both_dates_flag	int
=	O
FALSE	O
;	O
Bool	int
hd_suppr_list_sep_flag	int
=	O
FALSE	O
;	O
Bool	int
hd_title_flag	int
=	O
TRUE	O
;	O
Bool	int
is_fiscal_year	int
=	O
FALSE	O
;	O
Bool	int
is_3month_mode	int
=	O
FALSE	O
;	O
Bool	int
is_3month_mode2	int
=	O
FALSE	O
;	O
Bool	int
is_ext_year	int
=	O
FALSE	O
;	O
Bool	int
is_ext_list	int
=	O
FALSE	O
;	O
Bool	int
is_ext_range	int
=	O
FALSE	O
;	O
Bool	int
is_special_range	int
=	O
FALSE	O
;	O
Bool	int
is_multi_range	int
=	O
FALSE	O
;	O
Bool	int
is_en	int
=	O
FALSE	O
;	O
Bool	int
special_calsheet_flag	int
=	O
FALSE	O
;	O
Bool	int
emu_hls	int
=	O
FALSE	O
;	O
Bool	int
pager_flag	int
=	O
FALSE	O
;	O
static	O
pid_t	int
child_pid	int
;	O
static	O
int	O
pipe_fd	array(int)
[	O
2	int
]	O
;	O
static	O
int	O
sys_fd	array(int)
[	O
2	int
]	O
;	O
static	O
Df_struct	struct(*(char),*(char),*(char))
users_date_format	struct(*(char),*(char),*(char))
;	O
static	O
Uint	int
month_list_max	int
=	O
MONTH_MAX	int
+	O
1	int
;	O
static	O
int	O
lopt_id	int
=	O
0	int
;	O
static	O
int	O
exit_stat_help	int
=	O
EXIT_STAT_HELP	O
;	O
static	O
int	O
buf_start_day	int
=	O
0	int
;	O
static	O
char	O
*	O
*	O
pg_argv	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
static	O
char	O
*	O
pagers	array(*(char))
[	O
]	O
=	O
{	O
PAGER1_PROG	*(char)
,	O
PAGER2_PROG	*(char)
,	O
PAGER3_PROG	*(char)
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
shl_filename	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
char	O
*	O
rsp_filename	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
char	O
*	O
hl_seq	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
char	O
*	O
errtxt_dformat	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
static	O
Bool	int
year_flag	int
=	O
FALSE	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
argc	int
,	O
argv	array(*(char))
)	O
int	O
argc	int
;	O
char	O
*	O
argv	array(*(char))
[	O
]	O
;	O
{	O
auto	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
(	O
FILE	struct
*	O
)	O
NULL	O
;	O
auto	O
Uint	int
my_argc_max	*(int)
=	O
MY_ARGC_MAX	int
;	O
auto	O
int	O
my_argc	*(int)
=	O
1	int
;	O
auto	O
int	O
i	int
;	O
register	O
int	O
j	int
;	O
auto	O
char	O
*	O
*	O
my_argv	array(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
NULL	O
;	O
static	O
const	O
char	O
*	O
these_short_opts_need_args	*(char)
=	O
"#DFHIPRSbfqrsv"	*(char)
;	O
auto	O
char	O
*	O
ptr_char	*(char)
;	O
auto	O
char	O
*	O
y_txt	*(char)
;	O
auto	O
char	O
*	O
m_txt	*(char)
;	O
auto	O
char	O
*	O
w_txt	*(char)
;	O
auto	O
char	O
*	O
d_txt	*(char)
;	O
auto	O
Bool	int
show_calendar	int
=	O
TRUE	O
;	O
auto	O
Bool	int
b_dummy	int
;	O
testval	int
=	O
INT_MAX	O
;	O
assert	O
(	O
MAXLEN_MAX	int
>=	O
1024	int
)	O
;	O
assert	O
(	O
(	O
Uint	int
)	O
MAXLEN_MAX	int
<=	O
testval	int
)	O
;	O
allocate_all_strings	(int,*(char),long)->(void)
(	O
MAXLEN_MAX	int
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
"%d"	*(char)
,	O
YEAR_MAX	int
)	O
;	O
len_year_max	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
s1	*(char)
)	O
;	O
assert	O
(	O
my_argc_max	*(int)
>	O
0	int
)	O
;	O
assert	O
(	O
my_argc_max	*(int)
<=	O
testval	int
)	O
;	O
assert	O
(	O
len_year_max	int
<	O
11	int
)	O
;	O
assert	O
(	O
len_year_max	int
>	O
0	int
)	O
;	O
assert	O
(	O
YEAR_MAX	int
>=	O
YEAR_MIN	int
)	O
;	O
assert	O
(	O
MONTH_MAX	int
==	O
12	int
)	O
;	O
assert	O
(	O
CENTURY	int
==	O
1900	int
)	O
;	O
assert	O
(	O
BUF_LEN	int
>=	O
1	int
)	O
;	O
assert	O
(	O
(	O
Uint	int
)	O
BUF_LEN	int
<	O
testval	int
)	O
;	O
assert	O
(	O
strlen	(*(char))->(long)
(	O
PACKAGE_NAME	*(char)
)	O
>	O
0	int
)	O
;	O
assert	O
(	O
strlen	(*(char))->(long)
(	O
PACKAGE_VERSION	*(char)
)	O
>	O
0	int
)	O
;	O
assert	O
(	O
MY_ARGC_MAX	int
>	O
1	int
)	O
;	O
assert	O
(	O
(	O
Uint	int
)	O
MY_ARGC_MAX	int
<=	O
testval	int
)	O
;	O
assert	O
(	O
HD_ELEMS_MAX	int
>	O
0	int
)	O
;	O
assert	O
(	O
(	O
Uint	int
)	O
HD_ELEMS_MAX	int
<=	O
testval	int
)	O
;	O
assert	O
(	O
FWIDTH_MAX	int
>	O
0	int
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
ptr_char	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_LANGUAGE	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
ptr_char	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_LC_ALL	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
ptr_char	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_LANG	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
s1	*(char)
,	O
ptr_char	*(char)
,	O
6	int
)	O
;	O
s1	*(char)
[	O
5	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
s1	*(char)
,	O
"de"	*(char)
,	O
2	int
)	O
)	O
is_en	int
=	O
FALSE	O
;	O
else	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
s1	*(char)
,	O
"en"	*(char)
,	O
2	int
)	O
)	O
is_en	int
=	O
TRUE	O
;	O
else	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
s1	*(char)
,	O
"posix"	*(char)
,	O
5	int
)	O
||	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
"c"	*(char)
)	O
)	O
is_en	int
=	O
TRUE	O
;	O
}	O
else	O
is_en	int
=	O
TRUE	O
;	O
}	O
else	O
is_en	int
=	O
TRUE	O
;	O
if	O
(	O
is_en	int
)	O
{	O
special_calsheet_flag	int
=	O
TRUE	O
;	O
iso_week_number	int
=	O
FALSE	O
;	O
out_rows	int
=	O
J_OUT_ROWS	int
;	O
greg	*(struct(int,int,int,int))
+=	O
2	int
;	O
date_format	*(struct(*(char),*(char),*(char)))
++	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
3	int
;	O
i	int
++	O
)	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
s1	*(char)
,	O
ptr_char	*(char)
,	O
3	int
)	O
;	O
s1	*(char)
[	O
2	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
CC_GB	*(char)
)	O
)	O
date_format	*(struct(*(char),*(char),*(char)))
++	O
;	O
}	O
}	O
}	O
else	O
{	O
special_calsheet_flag	int
=	O
FALSE	O
;	O
iso_week_number	int
=	O
TRUE	O
;	O
out_rows	int
=	O
S_OUT_ROWS	int
;	O
}	O
if	O
(	O
!	O
is_correct_date_format	(*(char),*(int),*(int),*(int),*(int))->(int)
(	O
date_format	*(struct(*(char),*(char),*(char)))
->	O
df_format	*(char)
,	O
&	O
use_day_suffix	*(int)
,	O
&	O
use_short3_day_name	int
,	O
&	O
use_day_zeroleaded	int
,	O
&	O
use_year_zeroleaded	int
)	O
)	O
errtxt_dformat	*(char)
=	O
_	O
(	O
"default"	*(char)
)	O
;	O
is_tty1	int
=	O
isatty	(int)->(int)
(	O
1	int
)	O
;	O
is_tty2	int
=	O
isatty	(int)->(int)
(	O
2	int
)	O
;	O
is_tty	int
=	O
(	O
is_tty1	int
&&	O
is_tty2	int
)	O
;	O
if	O
(	O
is_tty	int
)	O
{	O
dup2	(int,int)->(int)
(	O
0	int
,	O
sys_fd	array(int)
[	O
0	int
]	O
)	O
;	O
dup2	(int,int)->(int)
(	O
1	int
,	O
sys_fd	array(int)
[	O
1	int
]	O
)	O
;	O
}	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
*	O
argv	array(*(char))
)	O
;	O
if	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
i	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
if	O
(	O
!	O
i	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
s3	*(char)
,	O
PACKAGE_NAME	*(char)
)	O
;	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
s3	*(char)
,	O
*	O
argv	array(*(char))
)	O
;	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
s3	*(char)
)	O
;	O
ptr_char	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
s3	*(char)
,	O
*	O
DIR_SEP	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
++	O
;	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
;	O
}	O
else	O
ptr_char	*(char)
=	O
s3	*(char)
;	O
if	O
(	O
tolower	(int)->(int)
(	O
'A'	O
)	O
==	O
'a'	O
)	O
{	O
auto	O
char	O
*	O
buf_ptr_char	*(char)
=	O
ptr_char	*(char)
;	O
for	O
(	O
;	O
*	O
ptr_char	*(char)
;	O
ptr_char	*(char)
++	O
)	O
*	O
ptr_char	*(char)
=	O
(	O
char	O
)	O
tolower	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
;	O
ptr_char	*(char)
=	O
buf_ptr_char	*(char)
;	O
}	O
if	O
(	O
(	O
i	int
>	O
4	int
)	O
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
ptr_char	*(char)
+	O
i	int
-	O
4	int
,	O
".exe"	*(char)
)	O
)	O
{	O
i	int
-=	O
4	int
;	O
*	O
(	O
ptr_char	*(char)
+	O
i	int
)	O
=	O
'\0'	O
;	O
}	O
prgr_name	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
i	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"prgr_name"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
prgr_name	*(char)
,	O
ptr_char	*(char)
)	O
;	O
if	O
(	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
SIG_IGN	O
)	O
!=	O
SIG_IGN	O
)	O
(	O
void	O
)	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
(	O
Sig_type	*((int)->(void))
)	O
handle_signal	(int)->(void)
)	O
;	O
if	O
(	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTERM	int
,	O
SIG_IGN	O
)	O
!=	O
SIG_IGN	O
)	O
(	O
void	O
)	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGTERM	int
,	O
(	O
Sig_type	*((int)->(void))
)	O
handle_signal	(int)->(void)
)	O
;	O
if	O
(	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGHUP	int
,	O
SIG_IGN	O
)	O
!=	O
SIG_IGN	O
)	O
(	O
void	O
)	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGHUP	int
,	O
(	O
Sig_type	*((int)->(void))
)	O
handle_signal	(int)->(void)
)	O
;	O
time_sep	*(char)
=	O
_	O
(	O
":"	*(char)
)	O
;	O
y_txt	*(char)
=	O
_	O
(	O
"Y"	*(char)
)	O
;	O
m_txt	*(char)
=	O
_	O
(	O
"M"	*(char)
)	O
;	O
w_txt	*(char)
=	O
_	O
(	O
"W"	*(char)
)	O
;	O
d_txt	*(char)
=	O
_	O
(	O
"D"	*(char)
)	O
;	O
yy_lit	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
3	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"yy_lit"	*(char)
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
yy_lit	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
*	O
y_txt	*(char)
)	O
;	O
yy_lit	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
yyyy_lit	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
len_year_max	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"yyyy_lit"	*(char)
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len_year_max	int
;	O
i	int
++	O
)	O
yyyy_lit	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
*	O
y_txt	*(char)
)	O
;	O
yyyy_lit	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
mm_lit	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
3	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"mm_lit"	*(char)
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
mm_lit	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
*	O
m_txt	*(char)
)	O
;	O
mm_lit	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
www_lit	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
4	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"www_lit"	*(char)
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
3	int
;	O
i	int
++	O
)	O
www_lit	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
*	O
w_txt	*(char)
)	O
;	O
www_lit	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
dd_lit	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
3	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"dd_lit"	*(char)
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
dd_lit	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
*	O
d_txt	*(char)
)	O
;	O
dd_lit	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
larg_lit	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
4	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"larg_lit"	*(char)
,	O
0	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
larg_lit	*(char)
,	O
_	O
(	O
"ARG"	*(char)
)	O
,	O
4	int
)	O
;	O
larg_lit	*(char)
[	O
3	int
]	O
=	O
'\0'	O
;	O
my_argv	array(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
MY_ARGC_MAX	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"my_argv[MY_ARGC_MAX]"	*(char)
,	O
MY_ARGC_MAX	int
)	O
;	O
month_list	*(struct(int,int))
=	O
(	O
Ml_struct	struct(int,int)
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
MONTH_MAX	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
Ml_struct	struct(int,int)
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"month_list[MONTH_MAX+1]"	*(char)
,	O
MONTH_MAX	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
MONTH_MAX	int
;	O
i	int
++	O
)	O
month_list	*(struct(int,int))
[	O
i	int
]	O
.	O
ml_year	int
=	O
month_list	*(struct(int,int))
[	O
i	int
]	O
.	O
ml_month	int
=	O
0	int
;	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
=	O
(	O
Line_struct	struct(int,int,*(char),*(char),*(char),*(char))
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
sizeof	O
(	O
Line_struct	struct(int,int,*(char),*(char),*(char),*(char))
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"lineptrs"	*(char)
,	O
0	int
)	O
;	O
lptrs3	*(struct(int,int,*(char),*(char),*(char),*(char)))
=	O
(	O
Line_struct	struct(int,int,*(char),*(char),*(char),*(char))
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
sizeof	O
(	O
Line_struct	struct(int,int,*(char),*(char),*(char),*(char))
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"lptrs3"	*(char)
,	O
0	int
)	O
;	O
ptr_char	*(char)
=	O
_	O
(	O
"Fixed date list:"	*(char)
)	O
;	O
rc_heading_text	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
+	O
1	int
+	O
2	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_heading_text"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_heading_text	*(char)
,	O
"0 "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
rc_heading_text	*(char)
,	O
ptr_char	*(char)
)	O
;	O
ptr_char	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_GCAL_DATE_FORMAT	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
users_date_format	struct(*(char),*(char),*(char))
.	O
df_info	*(char)
=	O
_	O
(	O
"environment variable"	*(char)
)	O
;	O
users_date_format	struct(*(char),*(char),*(char))
.	O
df_format	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"users_date_format.df_format"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
users_date_format	struct(*(char),*(char),*(char))
.	O
df_format	*(char)
,	O
ptr_char	*(char)
)	O
;	O
date_format	*(struct(*(char),*(char),*(char)))
=	O
&	O
users_date_format	struct(*(char),*(char),*(char))
;	O
if	O
(	O
!	O
is_correct_date_format	(*(char),*(int),*(int),*(int),*(int))->(int)
(	O
date_format	*(struct(*(char),*(char),*(char)))
->	O
df_format	*(char)
,	O
&	O
use_day_suffix	*(int)
,	O
&	O
use_short3_day_name	int
,	O
&	O
use_day_zeroleaded	int
,	O
&	O
use_year_zeroleaded	int
)	O
)	O
errtxt_dformat	*(char)
=	O
_	O
(	O
"environment variable"	*(char)
)	O
;	O
else	O
errtxt_dformat	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
tz	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_TZ	*(char)
)	O
;	O
if	O
(	O
tz	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
!	O
*	O
tz	*(char)
)	O
tz	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
ptr_char	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_GCAL	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
while	O
(	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
ptr_char	*(char)
++	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
s1	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
||	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
{	O
s1	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
s1	*(char)
==	O
*	O
SWITCH	*(char)
||	O
*	O
s1	*(char)
==	O
*	O
SWITCH2	*(char)
||	O
*	O
s1	*(char)
==	O
RC_ADATE_CHAR	char
||	O
*	O
s1	*(char)
==	O
RSP_CHAR	char
)	O
{	O
if	O
(	O
i	int
==	O
1	int
||	O
(	O
(	O
i	int
==	O
2	int
)	O
&&	O
(	O
s1	*(char)
[	O
1	int
]	O
==	O
*	O
SWITCH	*(char)
||	O
s1	*(char)
[	O
1	int
]	O
==	O
RC_ADATE_CHAR	char
||	O
s1	*(char)
[	O
1	int
]	O
==	O
*	O
SWITCH2	*(char)
)	O
)	O
)	O
;	O
else	O
{	O
if	O
(	O
*	O
s1	*(char)
==	O
RSP_CHAR	char
)	O
{	O
rsp_filename	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
s1	*(char)
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rsp_filename"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rsp_filename	*(char)
,	O
s1	*(char)
+	O
1	int
)	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
file_open	(*(*(char)),int,enum(int,int,int,int,int,int,int),*(int))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
&	O
rsp_filename	*(char)
,	O
0	int
,	O
REsponse	int
,	O
&	O
b_dummy	int
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
{	O
my_argv	array(*(char))
=	O
insert_response_file	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),*(int),*(int),array(*(char)))->(*(*(char)))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
rsp_filename	*(char)
,	O
these_short_opts_need_args	*(char)
,	O
&	O
my_argc_max	*(int)
,	O
&	O
my_argc	*(int)
,	O
my_argv	array(*(char))
)	O
;	O
(	O
void	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
rsp_filename	*(char)
)	O
;	O
rsp_filename	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
*	O
s1	*(char)
==	O
*	O
SWITCH	*(char)
||	O
*	O
s1	*(char)
==	O
*	O
SWITCH2	*(char)
)	O
&&	O
(	O
s1	*(char)
[	O
1	int
]	O
!=	O
*	O
SWITCH	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
strchr	(*(char),int)->(*(char))
(	O
these_short_opts_need_args	*(char)
,	O
s1	*(char)
[	O
1	int
]	O
)	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
!	O
s1	*(char)
[	O
2	int
]	O
)	O
{	O
while	O
(	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
ptr_char	*(char)
++	O
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
s1	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
ptr_char	*(char)
++	O
;	O
}	O
s1	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
if	O
(	O
(	O
Uint	int
)	O
my_argc	*(int)
>=	O
my_argc_max	*(int)
)	O
{	O
my_argc_max	*(int)
<<=	O
1	int
;	O
if	O
(	O
my_argc_max	*(int)
*	O
sizeof	O
(	O
char	O
*	O
)	O
>	O
testval	int
)	O
my_argc_max	*(int)
--	O
;	O
my_argv	array(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
my_argv	array(*(char))
,	O
my_argc_max	*(int)
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"my_argv[my_argc_max]"	*(char)
,	O
my_argc_max	*(int)
)	O
;	O
}	O
my_argv	array(*(char))
[	O
my_argc	*(int)
]	O
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
i	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"my_argv[my_argc]"	*(char)
,	O
my_argc	*(int)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
my_argv	array(*(char))
[	O
my_argc	*(int)
++	O
]	O
,	O
s1	*(char)
)	O
;	O
}	O
}	O
while	O
(	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
ptr_char	*(char)
++	O
;	O
i	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
i	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: command in environment variable `%s' found -- %s\n%s\n%s\n"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
ENV_VAR_GCAL	*(char)
,	O
s1	*(char)
,	O
usage_msg	()->(*(char))
(	O
)	O
,	O
lopt_msg	()->(*(char))
(	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
ERR_INVALID_OPTION	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
while	O
(	O
argc	int
>	O
1	int
)	O
{	O
argv	array(*(char))
++	O
;	O
if	O
(	O
*	O
*	O
argv	array(*(char))
==	O
RSP_CHAR	char
)	O
{	O
rsp_filename	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
*	O
argv	array(*(char))
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rsp_filename"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rsp_filename	*(char)
,	O
*	O
argv	array(*(char))
+	O
1	int
)	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
file_open	(*(*(char)),int,enum(int,int,int,int,int,int,int),*(int))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
&	O
rsp_filename	*(char)
,	O
0	int
,	O
REsponse	int
,	O
&	O
b_dummy	int
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
{	O
my_argv	array(*(char))
=	O
insert_response_file	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),*(int),*(int),array(*(char)))->(*(*(char)))
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
rsp_filename	*(char)
,	O
these_short_opts_need_args	*(char)
,	O
&	O
my_argc_max	*(int)
,	O
&	O
my_argc	*(int)
,	O
my_argv	array(*(char))
)	O
;	O
(	O
void	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
rsp_filename	*(char)
)	O
;	O
rsp_filename	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
else	O
{	O
register	O
int	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
*	O
argv	array(*(char))
)	O
;	O
if	O
(	O
(	O
(	O
len	int
==	O
1	int
)	O
&&	O
(	O
*	O
*	O
argv	array(*(char))
==	O
*	O
SWITCH	*(char)
||	O
*	O
*	O
argv	array(*(char))
==	O
RC_ADATE_CHAR	char
||	O
*	O
*	O
argv	array(*(char))
==	O
*	O
SWITCH2	*(char)
)	O
)	O
||	O
(	O
(	O
len	int
==	O
2	int
)	O
&&	O
(	O
*	O
*	O
argv	array(*(char))
==	O
*	O
SWITCH	*(char)
||	O
*	O
*	O
argv	array(*(char))
==	O
RC_ADATE_CHAR	char
||	O
*	O
*	O
argv	array(*(char))
==	O
*	O
SWITCH2	*(char)
)	O
&&	O
(	O
*	O
(	O
*	O
argv	array(*(char))
+	O
1	int
)	O
==	O
*	O
SWITCH	*(char)
||	O
*	O
(	O
*	O
argv	array(*(char))
+	O
1	int
)	O
==	O
RC_ADATE_CHAR	char
||	O
*	O
(	O
*	O
argv	array(*(char))
+	O
1	int
)	O
==	O
*	O
SWITCH2	*(char)
)	O
)	O
)	O
;	O
else	O
{	O
if	O
(	O
(	O
Uint	int
)	O
my_argc	*(int)
>=	O
my_argc_max	*(int)
)	O
{	O
my_argc_max	*(int)
<<=	O
1	int
;	O
if	O
(	O
my_argc_max	*(int)
*	O
sizeof	O
(	O
char	O
*	O
)	O
>	O
testval	int
)	O
my_argc_max	*(int)
--	O
;	O
my_argv	array(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
my_argv	array(*(char))
,	O
my_argc_max	*(int)
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"my_argv[my_argc_max]"	*(char)
,	O
my_argc_max	*(int)
)	O
;	O
}	O
my_argv	array(*(char))
[	O
my_argc	*(int)
]	O
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
len	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"my_argv[my_argc]"	*(char)
,	O
my_argc	*(int)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
my_argv	array(*(char))
[	O
my_argc	*(int)
++	O
]	O
,	O
*	O
argv	array(*(char))
)	O
;	O
}	O
}	O
argc	int
--	O
;	O
}	O
if	O
(	O
my_argc	*(int)
>	O
1	int
)	O
{	O
rearrange_argv	(*(char),*(int),array(*(char)))->(void)
(	O
these_short_opts_need_args	*(char)
,	O
&	O
my_argc	*(int)
,	O
my_argv	array(*(char))
)	O
;	O
i	int
=	O
1	int
;	O
while	O
(	O
i	int
<	O
my_argc	*(int)
)	O
{	O
ptr_char	*(char)
=	O
my_argv	array(*(char))
[	O
i	int
]	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
SWITCH	*(char)
||	O
*	O
ptr_char	*(char)
==	O
*	O
SWITCH2	*(char)
)	O
{	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
SWITCH	*(char)
)	O
{	O
ptr_char	*(char)
++	O
;	O
j	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
;	O
if	O
(	O
(	O
Uint	int
)	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
j	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
s3	*(char)
,	O
ptr_char	*(char)
)	O
;	O
if	O
(	O
!	O
eval_longopt	(*(char),*(int))->(int)
(	O
s3	*(char)
,	O
&	O
lopt_id	int
)	O
)	O
ptr_char	*(char)
=	O
s3	*(char)
;	O
else	O
ptr_char	*(char)
=	O
s3	*(char)
+	O
strlen	(*(char))->(long)
(	O
s3	*(char)
)	O
;	O
}	O
else	O
lopt_id	int
=	O
SYM_NIL	int
;	O
if	O
(	O
lopt_id	int
==	O
SYM_DEBUG	int
)	O
warning_level	int
=	O
my_atoi	(*(char))->(int)
(	O
ptr_char	*(char)
)	O
;	O
else	O
if	O
(	O
lopt_id	int
==	O
SYM_EXECUTE_COMMAND	int
)	O
rc_execute_command	int
=	O
TRUE	O
;	O
else	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
'r'	O
)	O
{	O
ptr_char	*(char)
++	O
;	O
while	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
j	int
=	O
0	int
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
SEP	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
s1	*(char)
[	O
j	int
++	O
]	O
=	O
*	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
SEP	*(char)
)	O
&&	O
(	O
s1	*(char)
[	O
j	int
-	O
1	int
]	O
==	O
QUOTE_CHAR	char
)	O
)	O
s1	*(char)
[	O
j	int
-	O
1	int
]	O
=	O
*	O
ptr_char	*(char)
++	O
;	O
}	O
s1	*(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
pseudo_blank_conversion	(*(*(char)))->(void)
(	O
&	O
s1	*(char)
)	O
;	O
set_tvar	(*(char),*(char),long,enum(int,int))->(void)
(	O
s1	*(char)
,	O
_	O
(	O
"Internal"	*(char)
)	O
,	O
0L	int
,	O
GLobal	int
)	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
'v'	O
)	O
{	O
ptr_char	*(char)
++	O
;	O
while	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
j	int
=	O
0	int
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
SEP	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
s1	*(char)
[	O
j	int
++	O
]	O
=	O
*	O
ptr_char	*(char)
++	O
;	O
}	O
s1	*(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
set_dvar	(*(char),*(struct(int,int,*(char),*(char),*(char),*(char))),*(char),long,enum(int,int))->(void)
(	O
s1	*(char)
,	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
,	O
_	O
(	O
"Internal"	*(char)
)	O
,	O
0L	int
,	O
GLobal	int
)	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
*	O
my_argv	array(*(char))
[	O
i	int
]	O
!=	O
*	O
SWITCH	*(char)
)	O
&&	O
(	O
*	O
my_argv	array(*(char))
[	O
i	int
]	O
!=	O
*	O
SWITCH2	*(char)
)	O
&&	O
(	O
*	O
my_argv	array(*(char))
[	O
i	int
]	O
!=	O
RC_ADATE_CHAR	char
)	O
&&	O
(	O
*	O
my_argv	array(*(char))
[	O
i	int
]	O
!=	O
RSP_CHAR	char
)	O
)	O
break	O
;	O
i	int
++	O
;	O
}	O
}	O
if	O
(	O
my_argc	*(int)
>	O
1	int
)	O
{	O
i	int
=	O
1	int
;	O
while	O
(	O
i	int
<	O
my_argc	*(int)
)	O
{	O
if	O
(	O
*	O
my_argv	array(*(char))
[	O
i	int
]	O
==	O
RC_ADATE_CHAR	char
)	O
rc_adate	*(char)
=	O
my_argv	array(*(char))
[	O
i	int
]	O
+	O
1	int
;	O
if	O
(	O
(	O
*	O
my_argv	array(*(char))
[	O
i	int
]	O
!=	O
*	O
SWITCH	*(char)
)	O
&&	O
(	O
*	O
my_argv	array(*(char))
[	O
i	int
]	O
!=	O
*	O
SWITCH2	*(char)
)	O
&&	O
(	O
*	O
my_argv	array(*(char))
[	O
i	int
]	O
!=	O
RC_ADATE_CHAR	char
)	O
)	O
break	O
;	O
i	int
++	O
;	O
}	O
}	O
if	O
(	O
is_tty	int
)	O
{	O
ptr_char	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_PAGER	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
while	O
(	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
ptr_char	*(char)
++	O
;	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
;	O
if	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
i	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
s3	*(char)
,	O
ptr_char	*(char)
)	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
DIR_SEP	*(char)
)	O
{	O
ptr_char	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
s3	*(char)
,	O
*	O
DIR_SEP	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
ptr_char	*(char)
++	O
;	O
else	O
ptr_char	*(char)
=	O
s3	*(char)
;	O
}	O
j	int
=	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
;	O
ext_pager	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
j	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"ext_pager"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
ext_pager	*(char)
,	O
ptr_char	*(char)
)	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
ext_pager	*(char)
[	O
i	int
]	O
&&	O
!	O
isspace	(int)->(int)
(	O
ext_pager	*(char)
[	O
i	int
]	O
)	O
)	O
i	int
++	O
;	O
ext_pager	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
ext_pager	*(char)
==	O
*	O
DIR_SEP	*(char)
)	O
{	O
auto	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
!	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
ext_pager	*(char)
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
if	O
(	O
(	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
S_IFMT	O
)	O
==	O
S_IFREG	O
)	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
ext_pager	*(char)
,	O
"r"	*(char)
)	O
;	O
}	O
else	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
file_open	(*(*(char)),int,enum(int,int,int,int,int,int,int),*(int))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
&	O
ext_pager	*(char)
,	O
0	int
,	O
COmmon	int
,	O
&	O
b_dummy	int
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
ext_pager	*(char)
)	O
;	O
ext_pager	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
else	O
{	O
(	O
void	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
i	int
!=	O
j	int
)	O
{	O
register	O
Uint	int
pg_argc_max	int
=	O
MY_ARGC_MAX	int
;	O
register	O
int	O
pg_argc	int
=	O
0	int
;	O
register	O
int	O
k	int
=	O
j	int
;	O
pg_argv	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
MY_ARGC_MAX	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"pg_argv[MY_ARGC_MAX]"	*(char)
,	O
MY_ARGC_MAX	int
)	O
;	O
pg_argv	*(*(char))
[	O
pg_argc	int
]	O
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
i	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"pg_argv[pg_argc]"	*(char)
,	O
pg_argc	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
pg_argv	*(*(char))
[	O
pg_argc	int
++	O
]	O
,	O
ext_pager	*(char)
)	O
;	O
j	int
=	O
i	int
+	O
1	int
;	O
LOOP	O
{	O
if	O
(	O
(	O
Uint	int
)	O
pg_argc	int
>=	O
pg_argc_max	int
)	O
{	O
pg_argc_max	int
<<=	O
1	int
;	O
if	O
(	O
pg_argc_max	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
>	O
testval	int
)	O
pg_argc_max	int
--	O
;	O
pg_argv	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
pg_argv	*(*(char))
,	O
pg_argc_max	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"pg_argv[pg_argc_max]"	*(char)
,	O
pg_argc_max	int
)	O
;	O
}	O
while	O
(	O
isspace	(int)->(int)
(	O
ext_pager	*(char)
[	O
j	int
]	O
)	O
)	O
j	int
++	O
;	O
if	O
(	O
!	O
ext_pager	*(char)
[	O
j	int
]	O
)	O
break	O
;	O
ptr_char	*(char)
=	O
ext_pager	*(char)
+	O
j	int
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
=	O
ext_pager	*(char)
+	O
k	int
;	O
i	int
=	O
ptr_char	*(char)
-	O
(	O
ext_pager	*(char)
+	O
j	int
)	O
;	O
if	O
(	O
!	O
i	int
)	O
break	O
;	O
*	O
ptr_char	*(char)
=	O
'\0'	O
;	O
pg_argv	*(*(char))
[	O
pg_argc	int
]	O
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
i	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"pg_argv[pg_argc]"	*(char)
,	O
pg_argc	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
pg_argv	*(*(char))
[	O
pg_argc	int
++	O
]	O
,	O
ext_pager	*(char)
+	O
j	int
)	O
;	O
j	int
+=	O
i	int
;	O
if	O
(	O
j	int
>=	O
k	int
)	O
break	O
;	O
j	int
++	O
;	O
}	O
if	O
(	O
(	O
Uint	int
)	O
pg_argc	int
>=	O
pg_argc_max	int
)	O
{	O
pg_argc_max	int
<<=	O
1	int
;	O
if	O
(	O
pg_argc_max	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
>	O
testval	int
)	O
pg_argc_max	int
--	O
;	O
pg_argv	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
pg_argv	*(*(char))
,	O
pg_argc_max	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"pg_argv[pg_argc_max]"	*(char)
,	O
pg_argc_max	int
)	O
;	O
}	O
pg_argv	*(*(char))
[	O
pg_argc	int
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
ext_pager	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
pagers	array(*(char))
[	O
i	int
]	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ext_pager	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
pagers	array(*(char))
[	O
i	int
]	O
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"ext_pager"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
ext_pager	*(char)
,	O
pagers	array(*(char))
[	O
i	int
]	O
)	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
file_open	(*(*(char)),int,enum(int,int,int,int,int,int,int),*(int))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
&	O
ext_pager	*(char)
,	O
0	int
,	O
COmmon	int
,	O
&	O
b_dummy	int
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
{	O
(	O
void	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
}	O
free	(*(void))->(void)
(	O
ext_pager	*(char)
)	O
;	O
ext_pager	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
i	int
++	O
;	O
}	O
}	O
if	O
(	O
ext_pager	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
pipe_fd	array(int)
)	O
<	O
0	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
4L	int
,	O
"pipe()<"	*(char)
,	O
0	int
)	O
;	O
(	O
void	O
)	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
}	O
}	O
check_command_line	(int,array(*(char)))->(void)
(	O
my_argc	*(int)
,	O
my_argv	array(*(char))
)	O
;	O
if	O
(	O
errtxt_dformat	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_DATE_FORMAT	int
,	O
errtxt_dformat	*(char)
,	O
0	int
,	O
date_format	*(struct(*(char),*(char),*(char)))
->	O
df_format	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
email_adr	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
=	O
TMPFILENAME	O
;	O
if	O
(	O
ptr_char	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"tmpnam()="	*(char)
,	O
0	int
)	O
;	O
tfn	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"tfn"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
tfn	*(char)
,	O
ptr_char	*(char)
)	O
;	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
tfn	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_WRITE_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
tfn	*(char)
,	O
0	int
)	O
;	O
is_tty	int
=	O
(	O
int	O
)	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
year	int
&&	O
!	O
month	int
&&	O
(	O
holiday_flag	int
||	O
rc_use_flag	int
)	O
&&	O
!	O
year_flag	int
)	O
show_calendar	int
=	O
FALSE	O
;	O
else	O
if	O
(	O
suppr_cal_flag	int
&&	O
!	O
rc_use_flag	int
&&	O
!	O
holiday_flag	int
)	O
show_calendar	int
=	O
FALSE	O
;	O
is_date_given	int
=	O
(	O
Bool	int
)	O
(	O
month	int
||	O
year	int
||	O
is_fiscal_year	int
)	O
;	O
if	O
(	O
rc_use_flag	int
&&	O
(	O
(	O
!	O
month	int
&&	O
year	int
)	O
||	O
is_fiscal_year	int
)	O
)	O
date_enables_year	int
=	O
TRUE	O
;	O
if	O
(	O
rc_filename	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
pseudo_blank_conversion	(*(*(char)))->(void)
(	O
&	O
rc_filename	*(char)
)	O
;	O
if	O
(	O
rc_filter_text	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
pseudo_blank_conversion	(*(*(char)))->(void)
(	O
&	O
rc_filter_text	*(char)
)	O
;	O
eliminate_invalid_data	()->(void)
(	O
)	O
;	O
get_tty_hls	(*(char))->(void)
(	O
hl_seq	*(char)
)	O
;	O
if	O
(	O
is_tty1	int
&&	O
is_tty2	int
&&	O
(	O
ext_pager	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
pager_flag	int
)	O
{	O
setbuf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
setbuf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
get_tty_scr_size	(*(int),*(int))->(void)
(	O
&	O
tty_rows	int
,	O
&	O
tty_cols	int
)	O
;	O
}	O
if	O
(	O
rc_here_fn	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
rc_here_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_WRITE_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
rc_here_fn	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
rsp_filename	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
write_log_file	(*(char),enum(int,int,int,int,int,int,int),*(char),*(char),int,array(*(char)))->(void)
(	O
rsp_filename	*(char)
,	O
REsponse	int
,	O
_	O
(	O
"response file"	*(char)
)	O
,	O
_	O
(	O
"Created"	*(char)
)	O
,	O
my_argc	*(int)
,	O
my_argv	array(*(char))
)	O
;	O
if	O
(	O
shl_filename	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
write_log_file	(*(char),enum(int,int,int,int,int,int,int),*(char),*(char),int,array(*(char)))->(void)
(	O
shl_filename	*(char)
,	O
SCript	int
,	O
_	O
(	O
"shell script"	*(char)
)	O
,	O
_	O
(	O
"Created"	*(char)
)	O
,	O
my_argc	*(int)
,	O
my_argv	array(*(char))
)	O
;	O
if	O
(	O
is_tty1	int
&&	O
is_tty2	int
&&	O
pager_flag	int
&&	O
(	O
ext_pager	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
email_adr	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
child_pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
switch	O
(	O
child_pid	int
)	O
{	O
case	O
-	O
1	int
:	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
7L	int
,	O
"fork() child_pid="	*(char)
,	O
child_pid	int
)	O
;	O
case	O
0	int
:	O
close	(int)->(int)
(	O
pipe_fd	array(int)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
pipe_fd	array(int)
[	O
0	int
]	O
)	O
{	O
close	(int)->(int)
(	O
0	int
)	O
;	O
dup	(int)->(int)
(	O
pipe_fd	array(int)
[	O
0	int
]	O
)	O
;	O
close	(int)->(int)
(	O
pipe_fd	array(int)
[	O
0	int
]	O
)	O
;	O
}	O
if	O
(	O
pg_argv	*(*(char))
==	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
{	O
i	int
=	O
execlp	(*(char),*(char))->(int)
(	O
ext_pager	*(char)
,	O
ext_pager	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
j	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ext_pager	*(char)
)	O
+	O
LEN_SINGLE_LINE	int
;	O
if	O
(	O
(	O
Uint	int
)	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
j	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
"execlp(%s)="	*(char)
,	O
ext_pager	*(char)
)	O
;	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
9L	int
,	O
s1	*(char)
,	O
i	int
)	O
;	O
}	O
else	O
{	O
i	int
=	O
execvp	(*(char),array(*(char)))->(int)
(	O
ext_pager	*(char)
,	O
pg_argv	*(*(char))
)	O
;	O
j	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ext_pager	*(char)
)	O
+	O
LEN_SINGLE_LINE	int
;	O
if	O
(	O
(	O
Uint	int
)	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
j	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
"execvp(%s)="	*(char)
,	O
ext_pager	*(char)
)	O
;	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
9L	int
,	O
s1	*(char)
,	O
i	int
)	O
;	O
}	O
default	O
:	O
close	(int)->(int)
(	O
pipe_fd	array(int)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
pipe_fd	array(int)
[	O
1	int
]	O
!=	O
1	int
)	O
{	O
close	(int)->(int)
(	O
1	int
)	O
;	O
if	O
(	O
!	O
dup	(int)->(int)
(	O
pipe_fd	array(int)
[	O
1	int
]	O
)	O
)	O
{	O
dup	(int)->(int)
(	O
pipe_fd	array(int)
[	O
1	int
]	O
)	O
;	O
close	(int)->(int)
(	O
0	int
)	O
;	O
}	O
close	(int)->(int)
(	O
pipe_fd	array(int)
[	O
1	int
]	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
show_calendar	int
)	O
print_calendar	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
holiday_flag	int
||	O
rc_use_flag	int
)	O
{	O
register	O
int	O
tmp_ad	int
=	O
act_day	int
;	O
is_leap_year	int
=	O
(	O
days_of_february	(int)->(int)
(	O
year	int
)	O
==	O
29	int
)	O
;	O
if	O
(	O
is_fiscal_year	int
)	O
fiscal_month	int
=	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_month	int
;	O
if	O
(	O
cal_special_flag	int
)	O
act_day	int
=	O
day_of_year	(int,int,int)->(int)
(	O
tmp_ad	int
,	O
act_month	int
,	O
act_year	int
)	O
;	O
if	O
(	O
(	O
(	O
year	int
==	O
EASTER_MIN	int
-	O
1	int
)	O
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
||	O
(	O
(	O
year	int
>=	O
EASTER_MIN	int
)	O
&&	O
(	O
year	int
<=	O
EASTER_MAX	O
)	O
)	O
)	O
print_all_holidays	(int,int)->(void)
(	O
FALSE	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
cal_special_flag	int
)	O
act_day	int
=	O
tmp_ad	int
;	O
}	O
if	O
(	O
!	O
month_list	*(struct(int,int))
[	O
1	int
]	O
.	O
ml_month	int
)	O
{	O
if	O
(	O
is_fiscal_year	int
||	O
(	O
holiday_flag	int
&&	O
!	O
show_calendar	int
)	O
)	O
month	int
=	O
0	int
;	O
if	O
(	O
rc_use_flag	int
)	O
rc_use	()->(void)
(	O
)	O
;	O
if	O
(	O
holiday_flag	int
)	O
{	O
if	O
(	O
(	O
(	O
year	int
==	O
EASTER_MIN	int
-	O
1	int
)	O
&&	O
(	O
fiscal_month	int
==	O
1	int
)	O
)	O
||	O
year	int
<	O
EASTER_MIN	int
-	O
1	int
||	O
year	int
>	O
EASTER_MAX	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INVALID_EASTER_DATE	int
,	O
""	*(char)
,	O
0L	int
,	O
""	*(char)
,	O
0	int
)	O
;	O
print_all_holidays	(int,int)->(void)
(	O
FALSE	O
,	O
FALSE	O
)	O
;	O
}	O
}	O
if	O
(	O
is_tty1	int
&&	O
is_tty2	int
&&	O
pager_flag	int
&&	O
(	O
ext_pager	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
email_adr	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
close	(int)->(int)
(	O
0	int
)	O
;	O
dup	(int)->(int)
(	O
sys_fd	array(int)
[	O
0	int
]	O
)	O
;	O
close	(int)->(int)
(	O
1	int
)	O
;	O
dup	(int)->(int)
(	O
sys_fd	array(int)
[	O
1	int
]	O
)	O
;	O
while	O
(	O
wait	(*(int))->(int)
(	O
(	O
int	O
*	O
)	O
NULL	O
)	O
!=	O
child_pid	int
)	O
;	O
(	O
void	O
)	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
}	O
if	O
(	O
email_adr	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_WRITE_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
tfn	*(char)
,	O
0	int
)	O
;	O
else	O
{	O
auto	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
tfp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
(	O
FILE	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
!	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
tfn	*(char)
,	O
&	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
i	int
=	O
(	O
statbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
>	O
0	int
)	O
;	O
else	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_READ_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
tfn	*(char)
,	O
0	int
)	O
;	O
}	O
if	O
(	O
i	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
s2	*(char)
,	O
_	O
(	O
"Mail from \\`%s' (%02d-%s-%04d %02d%s%02d%s%02d"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
true_day	int
,	O
short_month_name	(int)->(*(char))
(	O
true_month	int
)	O
,	O
true_year	int
,	O
act_hour	int
,	O
time_sep	*(char)
,	O
act_min	int
,	O
time_sep	*(char)
,	O
act_sec	int
)	O
;	O
if	O
(	O
tz	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
" %s"	*(char)
,	O
tz	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s2	*(char)
,	O
s1	*(char)
)	O
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
s2	*(char)
,	O
")"	*(char)
)	O
;	O
ptr_char	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_MAILPROG	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
=	O
MAIL_PRGR	*(char)
;	O
}	O
else	O
ptr_char	*(char)
=	O
MAIL_PRGR	*(char)
;	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
s2	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
email_adr	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
REDIRECT_IN	*(char)
)	O
+	O
9	int
;	O
if	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
i	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
"%s -s \"%s\" %s %s %s"	*(char)
,	O
ptr_char	*(char)
,	O
s2	*(char)
,	O
email_adr	*(char)
,	O
REDIRECT_IN	*(char)
,	O
tfn	*(char)
)	O
;	O
if	O
(	O
my_system	(*(char))->(int)
(	O
s1	*(char)
)	O
)	O
{	O
i	int
=	O
unlink	(*(char))->(int)
(	O
tfn	*(char)
)	O
;	O
if	O
(	O
i	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"unlink(tfn)="	*(char)
,	O
i	int
)	O
;	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_EMAIL_SEND_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
13L	int
,	O
email_adr	*(char)
,	O
0	int
)	O
;	O
}	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: warning, eMail with empty message body not sent to <%s>.\n"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
email_adr	*(char)
)	O
;	O
i	int
=	O
unlink	(*(char))->(int)
(	O
tfn	*(char)
)	O
;	O
if	O
(	O
i	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
9L	int
,	O
"unlink(tfn)="	*(char)
,	O
i	int
)	O
;	O
}	O
if	O
(	O
rc_here_fn	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
i	int
=	O
unlink	(*(char))->(int)
(	O
rc_here_fn	*(char)
)	O
;	O
if	O
(	O
i	int
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
8L	int
,	O
"unlink(rc_here_fn)="	*(char)
,	O
i	int
)	O
;	O
}	O
if	O
(	O
rc_use_flag	int
&&	O
!	O
shell_escape_done	int
&&	O
(	O
!	O
rc_elems	int
||	O
(	O
rc_zero_dates_flag	int
&&	O
!	O
(	O
rc_elems	int
-	O
rc_zero_pos	int
)	O
)	O
)	O
)	O
exit	(int)->(void)
(	O
ERR_NO_FIXED_DATES_LISTED	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
int	O
eval_longopt	(*(char),*(int))->(int)
(	O
longopt	*(char)
,	O
longopt_symbolic	int
)	O
char	O
*	O
longopt	*(char)
;	O
int	O
*	O
longopt_symbolic	int
;	O
{	O
auto	O
const	O
Lopt_struct	struct(int,*(char),array(*(char)),int,array(*(char)))
*	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
=	O
lopt	array(struct(int,*(char),array(*(char)),int,array(*(char))))
;	O
*	O
longopt_symbolic	int
=	O
SYM_NIL	int
;	O
if	O
(	O
tolower	(int)->(int)
(	O
*	O
longopt	*(char)
)	O
>=	O
tolower	(int)->(int)
(	O
*	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
)	O
)	O
{	O
while	O
(	O
tolower	(int)->(int)
(	O
*	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
)	O
<	O
tolower	(int)->(int)
(	O
*	O
longopt	*(char)
)	O
)	O
{	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
++	O
;	O
if	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
==	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
tolower	(int)->(int)
(	O
*	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
)	O
==	O
tolower	(int)->(int)
(	O
*	O
longopt	*(char)
)	O
)	O
{	O
auto	O
const	O
Lopt_struct	struct(int,*(char),array(*(char)),int,array(*(char)))
*	O
ptr2_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
+	O
1	int
;	O
register	O
int	O
len_longopt	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
longopt	*(char)
)	O
;	O
auto	O
Bool	int
larg_sep_found	int
;	O
auto	O
Bool	int
ok	int
=	O
FALSE	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
longopt	*(char)
,	O
*	O
LARG_SEP	*(char)
)	O
!=	O
NULL	O
)	O
len_longopt	int
-=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
strchr	(*(char),int)->(*(char))
(	O
longopt	*(char)
,	O
*	O
LARG_SEP	*(char)
)	O
)	O
;	O
while	O
(	O
!	O
ok	int
&&	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
!=	O
NULL	O
)	O
)	O
{	O
if	O
(	O
ptr2_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
!=	O
NULL	O
)	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
,	O
longopt	*(char)
,	O
len_longopt	int
)	O
&&	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr2_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
,	O
longopt	*(char)
,	O
len_longopt	int
)	O
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
,	O
longopt	*(char)
,	O
len_longopt	int
)	O
)	O
{	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
++	O
;	O
if	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
!=	O
NULL	O
)	O
ptr2_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
++	O
;	O
if	O
(	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
!=	O
NULL	O
)	O
&&	O
(	O
ptr2_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
==	O
NULL	O
)	O
)	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
,	O
longopt	*(char)
,	O
len_longopt	int
)	O
)	O
ok	int
=	O
TRUE	O
;	O
}	O
else	O
ok	int
=	O
TRUE	O
;	O
}	O
if	O
(	O
!	O
ok	int
)	O
return	O
(	O
2	int
)	O
;	O
larg_sep_found	int
=	O
(	O
Bool	int
)	O
(	O
(	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
longopt	*(char)
)	O
-	O
len_longopt	int
)	O
?	O
TRUE	O
:	O
FALSE	O
)	O
;	O
if	O
(	O
larg_sep_found	int
&&	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
larg_mode	int
==	O
LARG_NO	int
)	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
)	O
;	O
*	O
longopt_symbolic	int
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
symbolic_name	int
;	O
return	O
(	O
3	int
)	O
;	O
}	O
if	O
(	O
!	O
larg_sep_found	int
&&	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
larg_mode	int
>	O
LARG_NO_OR_ONE	int
)	O
)	O
{	O
*	O
longopt_symbolic	int
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
symbolic_name	int
;	O
return	O
(	O
4	int
)	O
;	O
}	O
if	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
larg_mode	int
==	O
LARG_NO	int
||	O
(	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
larg_mode	int
==	O
LARG_NO_OR_ONE	int
)	O
&&	O
!	O
larg_sep_found	int
)	O
)	O
{	O
if	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
short_name	array(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
)	O
;	O
*	O
longopt_symbolic	int
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
symbolic_name	int
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
short_name	array(*(char))
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
auto	O
char	O
*	O
ptr_char	*(char)
=	O
longopt	*(char)
+	O
len_longopt	int
+	O
1	int
;	O
auto	O
char	O
*	O
larg_longopt	*(char)
;	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
)	O
{	O
*	O
longopt_symbolic	int
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
symbolic_name	int
;	O
return	O
(	O
4	int
)	O
;	O
}	O
larg_longopt	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
longopt	*(char)
)	O
-	O
len_longopt	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"larg_longopt"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
larg_longopt	*(char)
,	O
ptr_char	*(char)
)	O
;	O
if	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
if	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
short_name	array(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
LARG_SEP	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
larg_longopt	*(char)
)	O
;	O
*	O
longopt_symbolic	int
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
symbolic_name	int
;	O
free	(*(void))->(void)
(	O
larg_longopt	*(char)
)	O
;	O
return	O
(	O
-	O
2	int
)	O
;	O
}	O
if	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
larg_mode	int
==	O
LARG_ONE_OR_ARG	int
)	O
abort	()->(void)
(	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
short_name	array(*(char))
[	O
0	int
]	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
larg_longopt	*(char)
)	O
;	O
}	O
else	O
{	O
register	O
int	O
i	int
=	O
0	int
;	O
ok	int
=	O
FALSE	O
;	O
i	int
=	O
0	int
;	O
ptr_char	*(char)
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
i	int
++	O
]	O
;	O
while	O
(	O
!	O
ok	int
&&	O
(	O
ptr_char	*(char)
!=	O
NULL	O
)	O
)	O
{	O
if	O
(	O
tolower	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
==	O
tolower	(int)->(int)
(	O
*	O
larg_longopt	*(char)
)	O
)	O
{	O
register	O
int	O
j	int
=	O
i	int
-	O
1	int
;	O
register	O
int	O
len_larg	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
larg_longopt	*(char)
)	O
;	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
j	int
]	O
,	O
larg_longopt	*(char)
,	O
len_larg	int
)	O
)	O
{	O
if	O
(	O
len_larg	int
==	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
j	int
]	O
)	O
)	O
ok	int
=	O
TRUE	O
;	O
else	O
{	O
while	O
(	O
!	O
ok	int
&&	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
i	int
]	O
!=	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
i	int
]	O
,	O
larg_longopt	*(char)
,	O
len_larg	int
)	O
&&	O
(	O
len_larg	int
==	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
i	int
]	O
)	O
)	O
)	O
ok	int
=	O
TRUE	O
;	O
i	int
++	O
;	O
}	O
}	O
if	O
(	O
!	O
ok	int
)	O
{	O
auto	O
Bool	int
ambig	int
=	O
FALSE	O
;	O
i	int
=	O
j	int
+	O
1	int
;	O
while	O
(	O
!	O
ambig	int
&&	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
i	int
]	O
!=	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
i	int
]	O
,	O
larg_longopt	*(char)
,	O
len_larg	int
)	O
)	O
ambig	int
=	O
TRUE	O
;	O
i	int
++	O
;	O
}	O
if	O
(	O
ambig	int
)	O
{	O
*	O
longopt_symbolic	int
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
symbolic_name	int
;	O
return	O
(	O
6	int
)	O
;	O
}	O
else	O
{	O
ok	int
=	O
TRUE	O
;	O
i	int
=	O
j	int
+	O
1	int
;	O
}	O
}	O
}	O
else	O
ptr_char	*(char)
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
i	int
++	O
]	O
;	O
}	O
else	O
ptr_char	*(char)
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
i	int
++	O
]	O
;	O
}	O
if	O
(	O
!	O
ok	int
&&	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
larg_mode	int
!=	O
LARG_ONE_OR_ARG	int
)	O
)	O
{	O
*	O
longopt_symbolic	int
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
symbolic_name	int
;	O
return	O
(	O
5	int
)	O
;	O
}	O
i	int
--	O
;	O
if	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
short_name	array(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
long_name	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
LARG_SEP	*(char)
)	O
;	O
if	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
larg_mode	int
==	O
LARG_ONE_OR_ARG	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
larg_longopt	*(char)
)	O
;	O
else	O
strcat	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
i	int
]	O
)	O
;	O
*	O
longopt_symbolic	int
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
symbolic_name	int
;	O
free	(*(void))->(void)
(	O
larg_longopt	*(char)
)	O
;	O
return	O
(	O
-	O
2	int
)	O
;	O
}	O
if	O
(	O
!	O
ok	int
&&	O
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
larg_mode	int
==	O
LARG_ONE_OR_ARG	int
)	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
larg_longopt	*(char)
,	O
longopt	*(char)
+	O
len_longopt	int
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
short_name	array(*(char))
[	O
--	O
i	int
]	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
larg_longopt	*(char)
)	O
;	O
}	O
else	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
short_name	array(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
largs	array(*(char))
[	O
i	int
]	O
,	O
larg_lit	*(char)
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
longopt	*(char)
,	O
larg_longopt	*(char)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
larg_longopt	*(char)
)	O
;	O
}	O
}	O
else	O
return	O
(	O
2	int
)	O
;	O
}	O
else	O
return	O
(	O
2	int
)	O
;	O
}	O
else	O
return	O
(	O
2	int
)	O
;	O
*	O
longopt_symbolic	int
=	O
ptr_lopt	*(struct(int,*(char),array(*(char)),int,array(*(char))))
->	O
symbolic_name	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
Bool	int
is_correct_date_format	(*(char),*(int),*(int),*(int),*(int))->(int)
(	O
format_txt	*(char)
,	O
use_day_suffix	*(int)
,	O
use_short3_day_name	int
,	O
use_day_zeroleaded	int
,	O
use_year_zeroleaded	int
)	O
char	O
*	O
format_txt	*(char)
;	O
Bool	int
*	O
use_day_suffix	*(int)
;	O
Bool	int
*	O
use_short3_day_name	int
;	O
Bool	int
*	O
use_day_zeroleaded	int
;	O
Bool	int
*	O
use_year_zeroleaded	int
;	O
{	O
register	O
int	O
start_highlighting	int
=	O
2	int
;	O
register	O
int	O
end_highlighting	int
=	O
2	int
;	O
register	O
int	O
weekday_name_group	int
=	O
2	int
;	O
register	O
int	O
day_group	int
=	O
2	int
;	O
register	O
int	O
month_group	int
=	O
2	int
;	O
register	O
int	O
year_group	int
=	O
2	int
;	O
register	O
int	O
pos	int
;	O
auto	O
int	O
fstyle	*(int)
=	O
FSTYLE_NONE	O
;	O
auto	O
int	O
fwidth	*(int)
=	O
SPECIAL_VALUE	O
;	O
auto	O
Bool	int
is_cformat	*(int)
=	O
FALSE	O
;	O
auto	O
Bool	int
is_lformat	*(int)
=	O
FALSE	O
;	O
auto	O
Bool	int
is_sign	*(int)
=	O
FALSE	O
;	O
auto	O
Bool	int
is_lzero	*(int)
=	O
FALSE	O
;	O
auto	O
Bool	int
is_fformat	*(int)
=	O
FALSE	O
;	O
auto	O
Bool	int
is_suffix	*(int)
=	O
FALSE	O
;	O
*	O
use_day_suffix	*(int)
=	O
(	O
*	O
use_short3_day_name	int
)	O
=	O
(	O
*	O
use_day_zeroleaded	int
)	O
=	O
(	O
*	O
use_year_zeroleaded	int
)	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
*	O
format_txt	*(char)
)	O
return	O
(	O
FALSE	O
)	O
;	O
do	O
{	O
while	O
(	O
*	O
format_txt	*(char)
&&	O
(	O
*	O
format_txt	*(char)
!=	O
DFORMAT_CHAR	char
)	O
&&	O
(	O
*	O
format_txt	*(char)
!=	O
QUOTE_CHAR	char
)	O
)	O
format_txt	*(char)
++	O
;	O
if	O
(	O
*	O
format_txt	*(char)
)	O
{	O
if	O
(	O
*	O
format_txt	*(char)
==	O
DFORMAT_CHAR	char
)	O
{	O
pos	int
=	O
decode_format	(*(char),int,*(int),*(int),*(int),*(int),*(int),*(int),*(int),*(int))->(int)
(	O
format_txt	*(char)
,	O
1	int
,	O
&	O
is_cformat	*(int)
,	O
&	O
is_lformat	*(int)
,	O
&	O
is_sign	*(int)
,	O
&	O
is_lzero	*(int)
,	O
&	O
is_suffix	*(int)
,	O
&	O
is_fformat	*(int)
,	O
&	O
fstyle	*(int)
,	O
&	O
fwidth	*(int)
)	O
;	O
format_txt	*(char)
+=	O
pos	int
;	O
switch	O
(	O
*	O
format_txt	*(char)
)	O
{	O
case	O
HLS1S_CHAR	char
:	O
if	O
(	O
end_highlighting	int
==	O
2	int
)	O
if	O
(	O
start_highlighting	int
)	O
start_highlighting	int
--	O
;	O
break	O
;	O
case	O
HLS1E_CHAR	char
:	O
if	O
(	O
start_highlighting	int
==	O
1	int
)	O
if	O
(	O
end_highlighting	int
)	O
end_highlighting	int
--	O
;	O
break	O
;	O
case	O
DAYNR_CHAR	char
:	O
if	O
(	O
is_lzero	*(int)
)	O
*	O
use_day_zeroleaded	int
=	O
TRUE	O
;	O
if	O
(	O
is_suffix	*(int)
)	O
*	O
use_day_suffix	*(int)
=	O
TRUE	O
;	O
if	O
(	O
day_group	int
)	O
day_group	int
--	O
;	O
break	O
;	O
case	O
WDNAME_CHAR	char
:	O
if	O
(	O
fwidth	*(int)
==	O
3	int
)	O
*	O
use_short3_day_name	int
=	O
TRUE	O
;	O
if	O
(	O
weekday_name_group	int
)	O
weekday_name_group	int
--	O
;	O
break	O
;	O
case	O
MONTHNAME_CHAR	char
:	O
case	O
MONTHNR_CHAR	char
:	O
if	O
(	O
month_group	int
)	O
month_group	int
--	O
;	O
break	O
;	O
case	O
YEARNR_CHAR	char
:	O
if	O
(	O
is_lzero	*(int)
)	O
*	O
use_year_zeroleaded	int
=	O
TRUE	O
;	O
if	O
(	O
year_group	int
)	O
year_group	int
--	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
*	O
++	O
format_txt	*(char)
)	O
format_txt	*(char)
--	O
;	O
format_txt	*(char)
++	O
;	O
}	O
else	O
break	O
;	O
}	O
while	O
(	O
*	O
format_txt	*(char)
)	O
;	O
if	O
(	O
start_highlighting	int
!=	O
1	int
||	O
end_highlighting	int
!=	O
1	int
||	O
day_group	int
!=	O
1	int
||	O
month_group	int
!=	O
1	int
||	O
year_group	int
!=	O
1	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
if	O
(	O
weekday_name_group	int
<	O
1	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
static	O
void	O
rearrange_argv	(*(char),*(int),array(*(char)))->(void)
(	O
opt_list	*(char)
,	O
argc	int
,	O
argv	array(*(char))
)	O
const	O
char	O
*	O
opt_list	*(char)
;	O
int	O
*	O
argc	int
;	O
char	O
*	O
argv	array(*(char))
[	O
]	O
;	O
{	O
register	O
int	O
i	int
=	O
(	O
*	O
argc	int
-	O
1	int
)	O
;	O
register	O
int	O
n	long
=	O
1	int
;	O
auto	O
char	O
*	O
*	O
ptr_argv	*(*(char))
=	O
argv	array(*(char))
;	O
auto	O
char	O
*	O
*	O
ptr2_argv	*(*(char))
;	O
auto	O
Bool	int
is_modified	int
;	O
while	O
(	O
i	int
)	O
{	O
ptr_argv	*(*(char))
++	O
;	O
is_modified	int
=	O
FALSE	O
;	O
if	O
(	O
*	O
*	O
ptr_argv	*(*(char))
==	O
*	O
SWITCH	*(char)
||	O
*	O
*	O
ptr_argv	*(*(char))
==	O
*	O
SWITCH2	*(char)
)	O
{	O
(	O
*	O
ptr_argv	*(*(char))
)	O
++	O
;	O
if	O
(	O
*	O
*	O
ptr_argv	*(*(char))
&&	O
(	O
*	O
*	O
ptr_argv	*(*(char))
!=	O
*	O
SWITCH	*(char)
)	O
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
opt_list	*(char)
,	O
*	O
*	O
ptr_argv	*(*(char))
)	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
{	O
(	O
*	O
ptr_argv	*(*(char))
)	O
++	O
;	O
if	O
(	O
!	O
*	O
*	O
ptr_argv	*(*(char))
)	O
{	O
(	O
*	O
ptr_argv	*(*(char))
)	O
-=	O
2	int
;	O
ptr2_argv	*(*(char))
=	O
ptr_argv	*(*(char))
;	O
ptr2_argv	*(*(char))
++	O
;	O
if	O
(	O
(	O
*	O
*	O
ptr2_argv	*(*(char))
!=	O
RSP_CHAR	char
)	O
&&	O
(	O
*	O
*	O
ptr2_argv	*(*(char))
!=	O
RC_ADATE_CHAR	char
)	O
)	O
{	O
if	O
(	O
(	O
*	O
*	O
ptr2_argv	*(*(char))
==	O
*	O
SWITCH	*(char)
||	O
*	O
*	O
ptr2_argv	*(*(char))
==	O
*	O
SWITCH2	*(char)
)	O
&&	O
(	O
strlen	(*(char))->(long)
(	O
*	O
ptr2_argv	*(*(char))
)	O
<=	O
2	int
)	O
)	O
(	O
*	O
ptr_argv	*(*(char))
)	O
++	O
;	O
else	O
{	O
i	int
--	O
;	O
argv	array(*(char))
[	O
n	long
]	O
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
(	O
argv	array(*(char))
[	O
n	long
]	O
)	O
,	O
strlen	(*(char))->(long)
(	O
*	O
ptr_argv	*(*(char))
)	O
+	O
strlen	(*(char))->(long)
(	O
*	O
ptr2_argv	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"argv[n]"	*(char)
,	O
n	long
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
argv	array(*(char))
[	O
n	long
]	O
,	O
*	O
ptr_argv	*(*(char))
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
argv	array(*(char))
[	O
n	long
]	O
,	O
*	O
ptr2_argv	*(*(char))
)	O
;	O
ptr_argv	*(*(char))
++	O
;	O
is_modified	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
(	O
*	O
ptr_argv	*(*(char))
)	O
++	O
;	O
}	O
else	O
(	O
*	O
ptr_argv	*(*(char))
)	O
--	O
;	O
}	O
}	O
}	O
}	O
else	O
(	O
*	O
ptr_argv	*(*(char))
)	O
++	O
;	O
if	O
(	O
!	O
is_modified	int
)	O
{	O
(	O
*	O
ptr_argv	*(*(char))
)	O
--	O
;	O
argv	array(*(char))
[	O
n	long
]	O
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
(	O
argv	array(*(char))
[	O
n	long
]	O
)	O
,	O
strlen	(*(char))->(long)
(	O
*	O
ptr_argv	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"argv[n]"	*(char)
,	O
n	long
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
argv	array(*(char))
[	O
n	long
]	O
,	O
*	O
ptr_argv	*(*(char))
)	O
;	O
}	O
n	long
++	O
;	O
i	int
--	O
;	O
}	O
*	O
argc	int
=	O
n	long
;	O
}	O
static	O
void	O
check_command_line	(int,array(*(char)))->(void)
(	O
argc	int
,	O
argv	array(*(char))
)	O
int	O
argc	int
;	O
char	O
*	O
argv	array(*(char))
[	O
]	O
;	O
{	O
register	O
int	O
opt_error	int
=	O
0	int
;	O
register	O
int	O
len	int
;	O
auto	O
int	O
i	int
;	O
auto	O
int	O
lopt_help	int
;	O
auto	O
char	O
rel_time_offset	char
=	O
'\0'	O
;	O
auto	O
char	O
rel_loop_end	char
=	O
'\0'	O
;	O
auto	O
char	O
*	O
ptr_char	*(char)
;	O
auto	O
char	O
*	O
option	*(*(char))
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
char	O
*	O
rc_period_argv	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
char	O
*	O
rc_period_option	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
Bool	int
set_loop_end	int
=	O
FALSE	O
;	O
auto	O
Bool	int
rc_period_is_longopt	int
=	O
FALSE	O
;	O
auto	O
Bool	int
is_longopt	int
=	O
FALSE	O
;	O
auto	O
Bool	int
license_flag	int
=	O
FALSE	O
;	O
auto	O
Bool	int
version_flag	int
=	O
FALSE	O
;	O
auto	O
Bool	int
help_flag	int
=	O
FALSE	O
;	O
auto	O
Bool	int
ext_help_flag	int
=	O
FALSE	O
;	O
auto	O
Bool	int
help_on_help_flag	int
=	O
FALSE	O
;	O
auto	O
Bool	int
skip_option	int
=	O
FALSE	O
;	O
auto	O
Bool	int
lopt_ambig	int
=	O
FALSE	O
;	O
while	O
(	O
argc	int
>	O
1	int
)	O
{	O
option	*(*(char))
=	O
*	O
++	O
argv	array(*(char))
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
SWITCH	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
SWITCH2	*(char)
)	O
{	O
is_longopt	int
=	O
FALSE	O
;	O
for	O
(	O
option	*(*(char))
++	O
;	O
*	O
option	*(*(char))
;	O
option	*(*(char))
++	O
)	O
{	O
skip_option	int
=	O
FALSE	O
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
SWITCH	*(char)
)	O
{	O
option	*(*(char))
--	O
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
SWITCH	*(char)
)	O
{	O
is_longopt	int
=	O
TRUE	O
;	O
option	*(*(char))
+=	O
2	int
;	O
}	O
if	O
(	O
*	O
option	*(*(char))
&&	O
is_longopt	int
)	O
{	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
len	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
s2	*(char)
,	O
option	*(*(char))
)	O
;	O
opt_error	int
=	O
eval_longopt	(*(char),*(int))->(int)
(	O
s2	*(char)
,	O
&	O
lopt_id	int
)	O
;	O
if	O
(	O
opt_error	int
<	O
1	int
)	O
{	O
opt_error	int
=	O
0	int
;	O
switch	O
(	O
lopt_id	int
)	O
{	O
case	O
SYM_ADJUST_VALUE	int
:	O
option	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
*	O
LARG_SEP	*(char)
)	O
+	O
1	int
;	O
(	O
void	O
)	O
sscanf	(*(char),*(char))->(int)
(	O
option	*(*(char))
,	O
"%lf"	*(char)
,	O
&	O
adjust_value	double
)	O
;	O
if	O
(	O
abs	(int)->(int)
(	O
adjust_value	double
)	O
>	O
DEGS_PER_06_HOURS	int
)	O
opt_error	int
=	O
5	int
;	O
break	O
;	O
case	O
SYM_ATMOSPHERE	int
:	O
option	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
*	O
LARG_SEP	*(char)
)	O
+	O
1	int
;	O
ptr_char	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
option	*(*(char))
,	O
*	O
SPLIT_SEP	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
opt_error	int
=	O
5	int
;	O
else	O
*	O
ptr_char	*(char)
=	O
'\0'	O
;	O
(	O
void	O
)	O
sscanf	(*(char),*(char))->(int)
(	O
option	*(*(char))
,	O
"%lf"	*(char)
,	O
&	O
atm_pressure	double
)	O
;	O
if	O
(	O
atm_pressure	double
>	O
0.0	int
)	O
{	O
if	O
(	O
atm_pressure	double
>	O
1200.0	int
)	O
opt_error	int
=	O
5	int
;	O
else	O
{	O
atm_pressure	double
*=	O
100.0	int
;	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
(	O
void	O
)	O
sscanf	(*(char),*(char))->(int)
(	O
ptr_char	*(char)
,	O
"%lf"	*(char)
,	O
&	O
atm_temperature	double
)	O
;	O
if	O
(	O
abs	(int)->(int)
(	O
atm_temperature	double
)	O
>	O
100.0	int
)	O
opt_error	int
=	O
5	int
;	O
}	O
else	O
opt_error	int
=	O
5	int
;	O
}	O
}	O
else	O
opt_error	int
=	O
0	int
;	O
break	O
;	O
case	O
SYM_EXECUTE_COMMAND	int
:	O
rc_execute_command	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_extern_static_DVARS	int
:	O
rc_export_ldvar_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_extern_static_TVARS	int
:	O
rc_export_ltvar_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_HEADING_TEXT	int
:	O
option	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
*	O
LARG_SEP	*(char)
)	O
+	O
1	int
;	O
rc_heading_text	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
rc_heading_text	*(char)
,	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
+	O
2	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"rc_heading_text"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_heading_text	*(char)
,	O
"0 "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
rc_heading_text	*(char)
,	O
option	*(*(char))
)	O
;	O
pseudo_blank_conversion	(*(*(char)))->(void)
(	O
&	O
rc_heading_text	*(char)
)	O
;	O
break	O
;	O
case	O
SYM_IGNORE_CASE	int
:	O
rc_ignore_case_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_LIMIT	int
:	O
rc_limit	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_LEAP_DAY	int
:	O
rc_feb_29_to_feb_28	int
=	O
rc_feb_29_to_mar_01	int
=	O
FALSE	O
;	O
if	O
(	O
tolower	(int)->(int)
(	O
*	O
s2	*(char)
)	O
==	O
'f'	O
)	O
rc_feb_29_to_feb_28	int
=	O
TRUE	O
;	O
else	O
rc_feb_29_to_mar_01	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_PRECISE	int
:	O
rc_precise	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_REVERT_MATCH	int
:	O
rc_revert_match_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_BIORHYTHM_AXIS_LEN	int
:	O
option	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
*	O
LARG_SEP	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
'0'	O
)	O
{	O
while	O
(	O
*	O
option	*(*(char))
==	O
'0'	O
)	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
option	*(*(char))
--	O
;	O
}	O
rc_bio_axis_len	int
=	O
my_atoi	(*(char))->(int)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
rc_bio_axis_len	int
>	O
BIO_AXIS_MAX	int
||	O
rc_bio_axis_len	int
<	O
BIO_AXIS_MIN	int
)	O
opt_error	int
=	O
5	int
;	O
else	O
while	O
(	O
BIO_AXIS_MAX	int
%	O
rc_bio_axis_len	int
)	O
rc_bio_axis_len	int
--	O
;	O
break	O
;	O
case	O
SYM_MOONIMAGE_LINES	int
:	O
option	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
*	O
LARG_SEP	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
'0'	O
)	O
{	O
while	O
(	O
*	O
option	*(*(char))
==	O
'0'	O
)	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
option	*(*(char))
--	O
;	O
}	O
rc_moonimage_lines	int
=	O
my_atoi	(*(char))->(int)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
rc_moonimage_lines	int
>	O
MOONIMAGE_MAX	int
||	O
rc_moonimage_lines	int
<	O
MOONIMAGE_MIN	int
)	O
opt_error	int
=	O
5	int
;	O
break	O
;	O
case	O
SYM_MAIL	int
:	O
option	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
*	O
LARG_SEP	*(char)
)	O
;	O
if	O
(	O
option	*(*(char))
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_MAILTO	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
option	*(*(char))
=	O
ptr_char	*(char)
;	O
if	O
(	O
option	*(*(char))
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_USER	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
option	*(*(char))
=	O
ptr_char	*(char)
;	O
if	O
(	O
option	*(*(char))
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ENV_VAR_LOGNAME	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
option	*(*(char))
=	O
ptr_char	*(char)
;	O
}	O
}	O
}	O
else	O
option	*(*(char))
++	O
;	O
if	O
(	O
option	*(*(char))
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
option	*(*(char))
)	O
{	O
if	O
(	O
email_adr	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
email_adr	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"email_adr"	*(char)
,	O
0	int
)	O
;	O
else	O
email_adr	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
email_adr	*(char)
,	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"email_adr"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
email_adr	*(char)
,	O
option	*(*(char))
)	O
;	O
}	O
break	O
;	O
case	O
SYM_DEBUG	int
:	O
break	O
;	O
case	O
SYM_EXIT_STAT_HELP_NON_ZERO	int
:	O
exit_stat_help	int
=	O
ERR_EXIT_INFO_TEXTS_NON_ZERO	int
;	O
break	O
;	O
case	O
SYM_ISO_WEEK_NUMBER	int
:	O
if	O
(	O
tolower	(int)->(int)
(	O
*	O
s2	*(char)
)	O
==	O
'y'	O
)	O
iso_week_number	int
=	O
TRUE	O
;	O
else	O
iso_week_number	int
=	O
FALSE	O
;	O
break	O
;	O
case	O
SYM_CYCLE_END	int
:	O
case	O
SYM_CYCLE_STEP	int
:	O
case	O
SYM_TIME_OFFSET	int
:	O
{	O
register	O
int	O
sign	int
=	O
0	int
;	O
register	O
int	O
state	*(int)
=	O
1	int
;	O
register	O
int	O
digits	int
=	O
0	int
;	O
auto	O
Bool	int
skip	int
=	O
FALSE	O
;	O
auto	O
Bool	int
is_last	int
=	O
FALSE	O
;	O
auto	O
Bool	int
time_sep_found	int
=	O
FALSE	O
;	O
auto	O
Bool	int
is_leading_zero	int
=	O
TRUE	O
;	O
i	int
=	O
0	int
;	O
switch	O
(	O
lopt_id	int
)	O
{	O
case	O
SYM_TIME_OFFSET	int
:	O
time_hour_offset	int
=	O
time_min_offset	int
=	O
0	int
;	O
break	O
;	O
case	O
SYM_CYCLE_END	int
:	O
loop_end	int
=	O
SPECIAL_VALUE	O
;	O
set_loop_end	int
=	O
FALSE	O
;	O
break	O
;	O
case	O
SYM_CYCLE_STEP	int
:	O
loop_step	int
=	O
DEFAULT_CYCLE_STEP	int
;	O
}	O
option	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
*	O
LARG_SEP	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
RC_TIME_CHAR	char
||	O
*	O
option	*(*(char))
==	O
RC_GMTIME_CHAR	char
)	O
{	O
if	O
(	O
lopt_id	int
==	O
SYM_TIME_OFFSET	int
)	O
rel_time_offset	char
=	O
*	O
option	*(*(char))
;	O
else	O
if	O
(	O
lopt_id	int
==	O
SYM_CYCLE_END	int
)	O
rel_loop_end	char
=	O
*	O
option	*(*(char))
;	O
option	*(*(char))
++	O
;	O
}	O
else	O
if	O
(	O
lopt_id	int
==	O
SYM_TIME_OFFSET	int
)	O
rel_time_offset	char
=	O
'\0'	O
;	O
else	O
if	O
(	O
lopt_id	int
==	O
SYM_CYCLE_END	int
)	O
rel_loop_end	char
=	O
'\0'	O
;	O
if	O
(	O
*	O
option	*(*(char))
)	O
{	O
while	O
(	O
*	O
option	*(*(char))
)	O
{	O
skip	int
=	O
FALSE	O
;	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
1	int
:	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
*	O
option	*(*(char))
)	O
)	O
{	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
ASC_LIT	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
DES_LIT	*(char)
)	O
{	O
if	O
(	O
sign	int
||	O
time_sep_found	int
)	O
state	*(int)
=	O
0	int
;	O
else	O
sign	int
++	O
;	O
break	O
;	O
}	O
else	O
state	*(int)
++	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
option	*(*(char))
==	O
'0'	O
)	O
{	O
if	O
(	O
is_leading_zero	int
)	O
{	O
skip	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
digits	int
++	O
;	O
}	O
else	O
digits	int
++	O
;	O
is_leading_zero	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
case	O
2	int
:	O
if	O
(	O
!	O
digits	int
&&	O
!	O
is_leading_zero	int
)	O
state	*(int)
=	O
0	int
;	O
else	O
if	O
(	O
!	O
time_sep_found	int
)	O
{	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
time_sep	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
DEFAULT_TIME_SEP	*(char)
)	O
{	O
if	O
(	O
digits	int
>	O
2	int
)	O
state	*(int)
=	O
0	int
;	O
else	O
{	O
time_sep_found	int
=	O
TRUE	O
;	O
digits	int
=	O
0	int
;	O
state	*(int)
--	O
;	O
}	O
}	O
else	O
state	*(int)
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
digits	int
>	O
4	int
)	O
state	*(int)
=	O
0	int
;	O
else	O
is_last	int
=	O
TRUE	O
;	O
}	O
break	O
;	O
default	O
:	O
state	*(int)
=	O
0	int
;	O
}	O
if	O
(	O
state	*(int)
&&	O
!	O
skip	int
)	O
s3	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
option	*(*(char))
;	O
option	*(*(char))
++	O
;	O
}	O
if	O
(	O
!	O
state	*(int)
||	O
is_last	int
||	O
(	O
i	int
&&	O
!	O
time_sep_found	int
&&	O
!	O
is_leading_zero	int
&&	O
!	O
digits	int
)	O
||	O
(	O
time_sep_found	int
&&	O
(	O
digits	int
>	O
2	int
)	O
)	O
||	O
(	O
(	O
state	*(int)
==	O
1	int
)	O
&&	O
(	O
digits	int
>	O
4	int
)	O
)	O
)	O
opt_error	int
=	O
5	int
;	O
if	O
(	O
i	int
&&	O
!	O
opt_error	int
)	O
{	O
s3	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
i	int
=	O
atoi	(*(char))->(int)
(	O
s3	*(char)
)	O
;	O
if	O
(	O
time_sep_found	int
)	O
{	O
i	int
*=	O
MINS_PER_HOUR	int
;	O
ptr_char	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
s3	*(char)
,	O
*	O
time_sep	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
ptr_char	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
s3	*(char)
,	O
*	O
DEFAULT_TIME_SEP	*(char)
)	O
;	O
if	O
(	O
*	O
++	O
ptr_char	*(char)
)	O
{	O
state	*(int)
=	O
atoi	(*(char))->(int)
(	O
ptr_char	*(char)
)	O
;	O
if	O
(	O
abs	(int)->(int)
(	O
state	*(int)
)	O
>=	O
MINS_PER_HOUR	int
)	O
opt_error	int
=	O
5	int
;	O
else	O
if	O
(	O
!	O
i	int
)	O
{	O
if	O
(	O
*	O
s3	*(char)
==	O
*	O
DES_LIT	*(char)
)	O
i	int
=	O
-	O
state	*(int)
;	O
else	O
i	int
=	O
state	*(int)
;	O
}	O
else	O
if	O
(	O
SGN	O
(	O
i	int
)	O
<	O
0	int
)	O
i	int
-=	O
state	*(int)
;	O
else	O
i	int
+=	O
state	*(int)
;	O
}	O
}	O
if	O
(	O
!	O
opt_error	int
)	O
switch	O
(	O
lopt_id	int
)	O
{	O
case	O
SYM_TIME_OFFSET	int
:	O
time_hour_offset	int
=	O
MM2HH	O
(	O
abs	(int)->(int)
(	O
i	int
)	O
)	O
;	O
time_min_offset	int
=	O
abs	(int)->(int)
(	O
i	int
)	O
%	O
MINS_PER_HOUR	int
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
time_hour_offset	int
=	O
-	O
time_hour_offset	int
;	O
time_min_offset	int
=	O
-	O
time_min_offset	int
;	O
}	O
break	O
;	O
case	O
SYM_CYCLE_END	int
:	O
loop_end	int
=	O
i	int
;	O
set_loop_end	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_CYCLE_STEP	int
:	O
if	O
(	O
i	int
<=	O
0	int
)	O
loop_step	int
=	O
DEFAULT_CYCLE_STEP	int
;	O
else	O
if	O
(	O
i	int
>=	O
MINS_PER_DAY	int
)	O
loop_step	int
=	O
MINS_PER_DAY	int
-	O
1	int
;	O
else	O
loop_step	int
=	O
i	int
;	O
}	O
}	O
}	O
break	O
;	O
}	O
case	O
SYM_TRANSFORM_YEAR	int
:	O
option	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
*	O
LARG_SEP	*(char)
)	O
+	O
1	int
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
'0'	O
)	O
{	O
while	O
(	O
*	O
option	*(*(char))
==	O
'0'	O
)	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
option	*(*(char))
--	O
;	O
}	O
transform_year	int
=	O
atoi	(*(char))->(int)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
transform_year	int
>	O
YEAR_MAX	int
||	O
transform_year	int
<	O
-	O
YEAR_MAX	int
)	O
opt_error	int
=	O
5	int
;	O
break	O
;	O
case	O
SYM_TRANSLATE_STRING	int
:	O
option	*(*(char))
=	O
strchr	(*(char),int)->(*(char))
(	O
s2	*(char)
,	O
*	O
LARG_SEP	*(char)
)	O
+	O
1	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
len	int
&	O
1	int
)	O
opt_error	int
=	O
5	int
;	O
else	O
{	O
if	O
(	O
translate_string	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
translate_string	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
len	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"translate_string"	*(char)
,	O
0	int
)	O
;	O
else	O
translate_string	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
translate_string	*(char)
,	O
len	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"translate_string"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
translate_string	*(char)
,	O
option	*(*(char))
)	O
;	O
}	O
break	O
;	O
case	O
SYM_ASTRONOMICAL_HDY	int
:	O
hdy_astronomical	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_MULTICULTURAL_NEW_YEAR_HDY	int
:	O
hdy_multicultural_new_year	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_ZODIACAL_MARKER_HDY	int
:	O
hdy_zodiacal_marker	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_BAHAI_HDY	int
:	O
hdy_bahai	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_CELTIC_HDY	int
:	O
hdy_celtic	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_CHINESE_FLEXIBLE_HDY	int
:	O
hdy_chinese_flexible	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_CHINESE_HDY	int
:	O
hdy_chinese	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_CHRISTIAN_HDY	int
:	O
hdy_christian	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_HEBREW_HDY	int
:	O
hdy_hebrew	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_ISLAMIC_HDY	int
:	O
hdy_islamic	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_JAPANESE_FLEXIBLE_HDY	int
:	O
hdy_japanese_flexible	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_JAPANESE_HDY	int
:	O
hdy_japanese	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_ORTHODOX_NEW_HDY	int
:	O
hdy_orthodox_new	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_ORTHODOX_OLD_HDY	int
:	O
hdy_orthodox_old	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_PERSIAN_HDY	int
:	O
hdy_persian	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_BAHAI_MTH	int
:	O
mth_bahai	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_CHINESE_FLEXIBLE_MTH	int
:	O
mth_chinese_flexible	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_CHINESE_MTH	int
:	O
mth_chinese	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_COPTIC_MTH	int
:	O
mth_coptic	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_ETHIOPIC_MTH	int
:	O
mth_ethiopic	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_FRENCH_REVOLUTIONARY_MTH	int
:	O
mth_french_revolutionary	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_HEBREW_MTH	int
:	O
mth_hebrew	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_INDIAN_CIVIL_MTH	int
:	O
mth_indian_civil	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_ISLAMIC_MTH	int
:	O
mth_islamic	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_JAPANESE_FLEXIBLE_MTH	int
:	O
mth_japanese_flexible	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_JAPANESE_MTH	int
:	O
mth_japanese	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_OLD_ARMENIC_MTH	int
:	O
mth_old_armenic	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_OLD_EGYPTIC_MTH	int
:	O
mth_old_egyptic	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
SYM_PERSIAN_MTH	int
:	O
mth_persian	int
=	O
TRUE	O
;	O
break	O
;	O
default	O
:	O
option	*(*(char))
=	O
s2	*(char)
;	O
goto	O
LABEL_short_option	O
;	O
}	O
}	O
else	O
option	*(*(char))
=	O
s2	*(char)
;	O
}	O
else	O
opt_error	int
=	O
5	int
;	O
skip_option	int
=	O
TRUE	O
;	O
}	O
else	O
LABEL_short_option	O
:	O
switch	O
(	O
*	O
option	*(*(char))
)	O
{	O
case	O
'?'	O
:	O
case	O
'h'	O
:	O
skip_option	int
=	O
help_flag	int
=	O
TRUE	O
;	O
option	*(*(char))
++	O
;	O
if	O
(	O
*	O
option	*(*(char))
)	O
{	O
if	O
(	O
*	O
option	*(*(char))
==	O
'?'	O
||	O
*	O
option	*(*(char))
==	O
'h'	O
)	O
{	O
ext_help_flag	int
=	O
TRUE	O
;	O
lopt_help	int
=	O
SYM_NIL	int
;	O
option	*(*(char))
++	O
;	O
if	O
(	O
*	O
option	*(*(char))
&&	O
is_longopt	int
)	O
{	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
len	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
s3	*(char)
,	O
option	*(*(char))
)	O
;	O
lopt_ambig	int
=	O
(	O
Bool	int
)	O
(	O
eval_longopt	(*(char),*(int))->(int)
(	O
s3	*(char)
,	O
&	O
lopt_help	int
)	O
==	O
1	int
)	O
;	O
if	O
(	O
lopt_help	int
==	O
SYM_NIL	int
)	O
help_on_help_flag	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
2	int
;	O
}	O
else	O
opt_error	int
=	O
2	int
;	O
}	O
break	O
;	O
case	O
'G'	O
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'O'	O
:	O
case	O
'V'	O
:	O
case	O
'X'	O
:	O
case	O
'p'	O
:	O
case	O
'u'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
{	O
option	*(*(char))
--	O
;	O
switch	O
(	O
*	O
option	*(*(char))
)	O
{	O
case	O
'G'	O
:	O
hd_suppr_list_sep_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'K'	O
:	O
cal_with_week_number	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'L'	O
:	O
license_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'O'	O
:	O
orthodox_calendar	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'V'	O
:	O
version_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'X'	O
:	O
hd_title_flag	int
=	O
FALSE	O
;	O
break	O
;	O
case	O
'p'	O
:	O
pager_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'u'	O
:	O
suppr_cal_flag	int
=	O
TRUE	O
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
skip_option	int
=	O
TRUE	O
;	O
}	O
else	O
opt_error	int
=	O
2	int
;	O
break	O
;	O
case	O
'R'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
else	O
{	O
if	O
(	O
rsp_filename	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rsp_filename	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rsp_filename"	*(char)
,	O
0	int
)	O
;	O
else	O
rsp_filename	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
rsp_filename	*(char)
,	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"rsp_filename"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rsp_filename	*(char)
,	O
option	*(*(char))
)	O
;	O
skip_option	int
=	O
TRUE	O
;	O
}	O
break	O
;	O
case	O
'S'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
else	O
{	O
if	O
(	O
shl_filename	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
shl_filename	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"shl_filename"	*(char)
,	O
0	int
)	O
;	O
else	O
shl_filename	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
shl_filename	*(char)
,	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"shl_filename"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
shl_filename	*(char)
,	O
option	*(*(char))
)	O
;	O
skip_option	int
=	O
TRUE	O
;	O
}	O
break	O
;	O
case	O
'H'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
else	O
{	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
(	O
len	int
==	O
2	int
)	O
&&	O
(	O
tolower	(int)->(int)
(	O
*	O
option	*(*(char))
)	O
==	O
'n'	O
)	O
&&	O
(	O
tolower	(int)->(int)
(	O
*	O
(	O
option	*(*(char))
+	O
1	int
)	O
)	O
==	O
'o'	O
)	O
)	O
highlight_flag	int
=	O
FALSE	O
;	O
else	O
if	O
(	O
(	O
len	int
==	O
3	int
)	O
&&	O
(	O
tolower	(int)->(int)
(	O
*	O
option	*(*(char))
)	O
==	O
'y'	O
)	O
&&	O
(	O
tolower	(int)->(int)
(	O
*	O
(	O
option	*(*(char))
+	O
1	int
)	O
)	O
==	O
'e'	O
)	O
&&	O
(	O
tolower	(int)->(int)
(	O
*	O
(	O
option	*(*(char))
+	O
2	int
)	O
)	O
==	O
's'	O
)	O
)	O
{	O
highlight_flag	int
=	O
TRUE	O
;	O
is_tty	int
=	O
(	O
int	O
)	O
TRUE	O
;	O
}	O
else	O
{	O
if	O
(	O
hl_seq	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
hl_seq	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"hl_seq"	*(char)
,	O
0	int
)	O
;	O
else	O
hl_seq	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
hl_seq	*(char)
,	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"hl_seq"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
hl_seq	*(char)
,	O
option	*(*(char))
)	O
;	O
highlight_flag	int
=	O
TRUE	O
;	O
}	O
}	O
skip_option	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'i'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
is_en	int
)	O
{	O
special_calsheet_flag	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
year_flag	int
)	O
out_rows	int
=	O
S_OUT_ROWS	int
;	O
}	O
else	O
{	O
special_calsheet_flag	int
=	O
TRUE	O
;	O
if	O
(	O
!	O
year_flag	int
)	O
out_rows	int
=	O
J_OUT_ROWS	int
;	O
}	O
if	O
(	O
*	O
option	*(*(char))
)	O
{	O
if	O
(	O
*	O
option	*(*(char))
==	O
'-'	O
)	O
{	O
option	*(*(char))
++	O
;	O
if	O
(	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
5	int
;	O
}	O
else	O
opt_error	int
=	O
5	int
;	O
}	O
option	*(*(char))
--	O
;	O
break	O
;	O
case	O
'n'	O
:	O
case	O
'N'	O
:	O
skip_option	int
=	O
holiday_flag	int
=	O
TRUE	O
;	O
hd_sort_des_flag	int
=	O
FALSE	O
;	O
hd_legal_days_only	int
=	O
(	O
Bool	int
)	O
(	O
(	O
*	O
option	*(*(char))
==	O
'N'	O
)	O
?	O
TRUE	O
:	O
FALSE	O
)	O
;	O
option	*(*(char))
++	O
;	O
if	O
(	O
*	O
option	*(*(char))
)	O
{	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
DES_LIT	*(char)
)	O
hd_sort_des_flag	int
=	O
TRUE	O
;	O
else	O
opt_error	int
=	O
5	int
;	O
}	O
break	O
;	O
case	O
'q'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
else	O
{	O
auto	O
const	O
Cc_struct	struct(*(char),*(char),*(()->(void)))
*	O
ptr_cc	*(struct(*(char),*(char),*(()->(void))))
;	O
*	O
s1	*(char)
=	O
'\0'	O
;	O
ptr_char	*(char)
=	O
option	*(*(char))
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
!	O
opt_error	int
)	O
do	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
CONNECT_SEP	*(char)
)	O
)	O
s2	*(char)
[	O
i	int
++	O
]	O
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
*	O
ptr_char	*(char)
++	O
)	O
;	O
s2	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
ptr_cc	*(struct(*(char),*(char),*(()->(void))))
=	O
binsearch_cc_id	(*(char))->(*(struct(*(char),*(char),*(()->(void)))))
(	O
s2	*(char)
)	O
;	O
if	O
(	O
ptr_cc	*(struct(*(char),*(char),*(()->(void))))
==	O
(	O
Cc_struct	struct(*(char),*(char),*(()->(void)))
*	O
)	O
NULL	O
)	O
{	O
opt_error	int
=	O
5	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
s1	*(char)
,	O
s2	*(char)
)	O
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
s1	*(char)
,	O
s2	*(char)
)	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
strcat	(*(char),*(char))->(*(char))
(	O
s1	*(char)
,	O
CONNECT_SEP	*(char)
)	O
;	O
}	O
}	O
while	O
(	O
*	O
ptr_char	*(char)
)	O
;	O
if	O
(	O
!	O
opt_error	int
)	O
{	O
if	O
(	O
cc	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
cc	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
s1	*(char)
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"cc"	*(char)
,	O
0	int
)	O
;	O
else	O
cc	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
cc	*(char)
,	O
strlen	(*(char))->(long)
(	O
s1	*(char)
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"cc"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
cc	*(char)
,	O
s1	*(char)
)	O
;	O
}	O
}	O
skip_option	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'!'	O
:	O
if	O
(	O
!	O
is_longopt	int
)	O
opt_error	int
=	O
2	int
;	O
else	O
{	O
option	*(*(char))
++	O
;	O
if	O
(	O
(	O
Uint	int
)	O
*	O
option	*(*(char))
<	O
LARG_MAX	int
-	O
1	int
)	O
{	O
date_format	*(struct(*(char),*(char),*(char)))
=	O
supported_date_format	array(struct(*(char),*(char),*(char)))
;	O
date_format	*(struct(*(char),*(char),*(char)))
+=	O
(	O
(	O
Uint	int
)	O
*	O
option	*(*(char))
-	O
1	int
)	O
;	O
if	O
(	O
date_format	*(struct(*(char),*(char),*(char)))
->	O
df_id	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
opt_error	int
=	O
5	int
;	O
}	O
else	O
{	O
users_date_format	struct(*(char),*(char),*(char))
.	O
df_info	*(char)
=	O
_	O
(	O
"command line"	*(char)
)	O
;	O
if	O
(	O
users_date_format	struct(*(char),*(char),*(char))
.	O
df_format	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
users_date_format	struct(*(char),*(char),*(char))
.	O
df_format	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"users_date_format.df_format"	*(char)
,	O
0	int
)	O
;	O
else	O
users_date_format	struct(*(char),*(char),*(char))
.	O
df_format	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
users_date_format	struct(*(char),*(char),*(char))
.	O
df_format	*(char)
,	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"users_date_format.df_format"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
users_date_format	struct(*(char),*(char),*(char))
.	O
df_format	*(char)
,	O
option	*(*(char))
)	O
;	O
date_format	*(struct(*(char),*(char),*(char)))
=	O
&	O
users_date_format	struct(*(char),*(char),*(char))
;	O
}	O
if	O
(	O
!	O
opt_error	int
)	O
{	O
if	O
(	O
!	O
is_correct_date_format	(*(char),*(int),*(int),*(int),*(int))->(int)
(	O
date_format	*(struct(*(char),*(char),*(char)))
->	O
df_format	*(char)
,	O
&	O
use_day_suffix	*(int)
,	O
&	O
use_short3_day_name	int
,	O
&	O
use_day_zeroleaded	int
,	O
&	O
use_year_zeroleaded	int
)	O
)	O
errtxt_dformat	*(char)
=	O
_	O
(	O
"command line"	*(char)
)	O
;	O
else	O
errtxt_dformat	*(char)
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
skip_option	int
=	O
TRUE	O
;	O
}	O
break	O
;	O
case	O
'$'	O
:	O
if	O
(	O
!	O
is_longopt	int
)	O
opt_error	int
=	O
2	int
;	O
else	O
{	O
option	*(*(char))
++	O
;	O
if	O
(	O
(	O
Uint	int
)	O
*	O
option	*(*(char))
<	O
LARG_MAX	int
-	O
1	int
)	O
{	O
greg	*(struct(int,int,int,int))
=	O
greg_reform_date	array(struct(int,int,int,int))
;	O
greg	*(struct(int,int,int,int))
+=	O
(	O
(	O
Uint	int
)	O
*	O
option	*(*(char))
-	O
1	int
)	O
;	O
if	O
(	O
!	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
opt_error	int
=	O
5	int
;	O
}	O
else	O
{	O
auto	O
Bool	int
ok	int
=	O
FALSE	O
;	O
users_greg	struct(int,int,int,int)
.	O
year	int
=	O
users_greg	struct(int,int,int,int)
.	O
month	int
=	O
users_greg	struct(int,int,int,int)
.	O
first_day	int
=	O
users_greg	struct(int,int,int,int)
.	O
last_day	int
=	O
0	int
;	O
ptr_char	*(char)
=	O
option	*(*(char))
;	O
do	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
!	O
ok	int
&&	O
!	O
opt_error	int
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
&&	O
(	O
i	int
<=	O
len_year_max	int
)	O
)	O
s1	*(char)
[	O
i	int
++	O
]	O
=	O
*	O
ptr_char	*(char)
;	O
else	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
ptr_char	*(char)
)	O
)	O
opt_error	int
=	O
5	int
;	O
else	O
if	O
(	O
i	int
&&	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
SPLIT_SEP	*(char)
)	O
)	O
{	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
SPLIT_SEP	*(char)
)	O
opt_error	int
=	O
5	int
;	O
else	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
i	int
&&	O
*	O
ptr_char	*(char)
)	O
opt_error	int
=	O
5	int
;	O
else	O
ok	int
=	O
TRUE	O
;	O
}	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
}	O
if	O
(	O
!	O
opt_error	int
)	O
{	O
s1	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
len	int
=	O
i	int
;	O
i	int
=	O
atoi	(*(char))->(int)
(	O
s1	*(char)
)	O
;	O
if	O
(	O
i	int
)	O
{	O
if	O
(	O
!	O
users_greg	struct(int,int,int,int)
.	O
year	int
)	O
{	O
if	O
(	O
len	int
>	O
len_year_max	int
)	O
if	O
(	O
atol	(*(char))->(long)
(	O
s1	*(char)
)	O
>	O
YEAR_MAX	int
+	O
3	int
)	O
opt_error	int
=	O
5	int
;	O
users_greg	struct(int,int,int,int)
.	O
year	int
=	O
i	int
;	O
}	O
else	O
if	O
(	O
!	O
users_greg	struct(int,int,int,int)
.	O
month	int
)	O
users_greg	struct(int,int,int,int)
.	O
month	int
=	O
i	int
;	O
else	O
if	O
(	O
!	O
users_greg	struct(int,int,int,int)
.	O
first_day	int
)	O
users_greg	struct(int,int,int,int)
.	O
first_day	int
=	O
i	int
;	O
else	O
if	O
(	O
!	O
users_greg	struct(int,int,int,int)
.	O
last_day	int
)	O
users_greg	struct(int,int,int,int)
.	O
last_day	int
=	O
i	int
;	O
else	O
opt_error	int
=	O
5	int
;	O
}	O
else	O
opt_error	int
=	O
5	int
;	O
}	O
}	O
while	O
(	O
!	O
ok	int
&&	O
!	O
opt_error	int
)	O
;	O
if	O
(	O
!	O
opt_error	int
)	O
{	O
if	O
(	O
users_greg	struct(int,int,int,int)
.	O
month	int
&&	O
users_greg	struct(int,int,int,int)
.	O
first_day	int
&&	O
users_greg	struct(int,int,int,int)
.	O
last_day	int
&&	O
(	O
users_greg	struct(int,int,int,int)
.	O
year	int
<=	O
YEAR_MAX	int
+	O
3	int
)	O
&&	O
(	O
users_greg	struct(int,int,int,int)
.	O
month	int
<=	O
MONTH_MAX	int
)	O
&&	O
(	O
users_greg	struct(int,int,int,int)
.	O
last_day	int
>=	O
users_greg	struct(int,int,int,int)
.	O
first_day	int
)	O
&&	O
(	O
(	O
(	O
users_greg	struct(int,int,int,int)
.	O
month	int
==	O
2	int
)	O
&&	O
(	O
users_greg	struct(int,int,int,int)
.	O
last_day	int
<=	O
(	O
(	O
users_greg	struct(int,int,int,int)
.	O
year	int
&	O
3	int
)	O
?	O
28	int
:	O
29	int
)	O
)	O
)	O
||	O
(	O
(	O
users_greg	struct(int,int,int,int)
.	O
month	int
!=	O
2	int
)	O
&&	O
(	O
users_greg	struct(int,int,int,int)
.	O
last_day	int
<=	O
dvec	array(int)
[	O
users_greg	struct(int,int,int,int)
.	O
month	int
-	O
1	int
]	O
)	O
)	O
)	O
)	O
greg	*(struct(int,int,int,int))
=	O
&	O
users_greg	struct(int,int,int,int)
;	O
else	O
opt_error	int
=	O
5	int
;	O
}	O
}	O
skip_option	int
=	O
TRUE	O
;	O
}	O
break	O
;	O
case	O
'j'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
{	O
cal_special_flag	int
=	O
TRUE	O
;	O
cal_both_dates_flag	int
=	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
option	*(*(char))
==	O
'b'	O
)	O
{	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
{	O
cal_special_flag	int
=	O
FALSE	O
;	O
cal_both_dates_flag	int
=	O
TRUE	O
;	O
}	O
else	O
opt_error	int
=	O
5	int
;	O
}	O
else	O
{	O
switch	O
(	O
*	O
option	*(*(char))
)	O
{	O
case	O
'n'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
{	O
hd_special_flag	int
=	O
TRUE	O
;	O
hd_both_dates_flag	int
=	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
*	O
option	*(*(char))
==	O
'b'	O
)	O
{	O
hd_special_flag	int
=	O
FALSE	O
;	O
hd_both_dates_flag	int
=	O
TRUE	O
;	O
}	O
else	O
opt_error	int
=	O
5	int
;	O
break	O
;	O
case	O
'c'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
{	O
rc_special_flag	int
=	O
TRUE	O
;	O
rc_both_dates_flag	int
=	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
*	O
option	*(*(char))
==	O
'b'	O
)	O
{	O
rc_special_flag	int
=	O
FALSE	O
;	O
rc_both_dates_flag	int
=	O
TRUE	O
;	O
}	O
else	O
opt_error	int
=	O
5	int
;	O
break	O
;	O
default	O
:	O
opt_error	int
=	O
5	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
option	*(*(char))
--	O
;	O
break	O
;	O
case	O
'b'	O
:	O
skip_option	int
=	O
year_flag	int
=	O
TRUE	O
;	O
option	*(*(char))
++	O
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
'0'	O
)	O
{	O
while	O
(	O
*	O
option	*(*(char))
==	O
'0'	O
)	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
option	*(*(char))
--	O
;	O
}	O
out_rows	int
=	O
my_atoi	(*(char))->(int)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
out_rows	int
>	O
MONTH_MAX	int
||	O
out_rows	int
<	O
MONTH_MIN	int
||	O
out_rows	int
==	O
5	int
||	O
(	O
(	O
out_rows	int
>	O
6	int
)	O
&&	O
(	O
out_rows	int
<	O
MONTH_MAX	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
else	O
opt_error	int
=	O
5	int
;	O
}	O
break	O
;	O
case	O
's'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
else	O
{	O
start_day	int
=	O
my_atoi	(*(char))->(int)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
!	O
start_day	int
)	O
start_day	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
option	*(*(char))
,	O
DAy	int
)	O
;	O
if	O
(	O
!	O
start_day	int
)	O
{	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
len	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
s1	*(char)
,	O
option	*(*(char))
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
s1	*(char)
)	O
>	O
strlen	(*(char))->(long)
(	O
"today"	*(char)
)	O
)	O
opt_error	int
=	O
5	int
;	O
else	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
option	*(*(char))
)	O
||	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
s1	*(char)
,	O
"today"	*(char)
,	O
len	int
)	O
)	O
start_day	int
=	O
SPECIAL_VALUE	O
;	O
else	O
opt_error	int
=	O
5	int
;	O
}	O
else	O
if	O
(	O
start_day	int
>	O
DAY_MAX	int
||	O
start_day	int
<	O
DAY_MIN	int
)	O
opt_error	int
=	O
5	int
;	O
}	O
skip_option	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'r'	O
:	O
case	O
'v'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
skip_option	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'F'	O
:	O
if	O
(	O
isupper	(int)->(int)
(	O
*	O
option	*(*(char))
)	O
)	O
rc_all_dates_flag	int
=	O
TRUE	O
;	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
else	O
{	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
CONNECT_SEP	*(char)
)	O
opt_error	int
=	O
5	int
;	O
else	O
{	O
if	O
(	O
len	int
>	O
1	int
)	O
{	O
if	O
(	O
(	O
*	O
(	O
option	*(*(char))
+	O
(	O
len	int
-	O
1	int
)	O
)	O
==	O
*	O
CONNECT_SEP	*(char)
)	O
&&	O
(	O
*	O
(	O
option	*(*(char))
+	O
(	O
len	int
-	O
2	int
)	O
)	O
!=	O
QUOTE_CHAR	char
)	O
)	O
opt_error	int
=	O
5	int
;	O
else	O
{	O
ptr_char	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
option	*(*(char))
,	O
*	O
CONNECT_SEP	*(char)
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
--	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
QUOTE_CHAR	char
)	O
ptr_char	*(char)
++	O
;	O
ptr_char	*(char)
++	O
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
!	O
opt_error	int
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
QUOTE_CHAR	char
)	O
ptr_char	*(char)
++	O
;	O
else	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
CONNECT_SEP	*(char)
)	O
{	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
QUOTE_CHAR	char
)	O
ptr_char	*(char)
++	O
;	O
else	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
CONNECT_SEP	*(char)
)	O
opt_error	int
=	O
5	int
;	O
}	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
opt_error	int
)	O
{	O
if	O
(	O
rc_filename	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_filename	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
len	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_filename"	*(char)
,	O
0	int
)	O
;	O
else	O
rc_filename	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
rc_filename	*(char)
,	O
len	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"rc_filename"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_filename	*(char)
,	O
option	*(*(char))
)	O
;	O
skip_option	int
=	O
rc_use_flag	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
'#'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
else	O
{	O
if	O
(	O
rc_here_fn	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
=	O
TMPFILENAME	O
;	O
if	O
(	O
ptr_char	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"tmpnam()="	*(char)
,	O
0	int
)	O
;	O
rc_here_fn	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_here_fn"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_here_fn	*(char)
,	O
ptr_char	*(char)
)	O
;	O
rc_here_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
rc_here_fn	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
rc_here_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_WRITE_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
rc_here_fn	*(char)
,	O
0	int
)	O
;	O
}	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
len	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
s2	*(char)
,	O
option	*(*(char))
)	O
;	O
pseudo_blank_conversion	(*(*(char)))->(void)
(	O
&	O
s2	*(char)
)	O
;	O
i	int
=	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
rc_here_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
s2	*(char)
)	O
;	O
if	O
(	O
i	int
==	O
EOF	O
)	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_WRITE_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
rc_here_fn	*(char)
,	O
0	int
)	O
;	O
}	O
skip_option	int
=	O
rc_use_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'D'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
else	O
{	O
ptr_char	*(char)
=	O
option	*(*(char))
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
!	O
opt_error	int
)	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
RC_EX_LHDY_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_NLHDY_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_AHDY_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_NAHDY_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_MON_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_NMON_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_TUE_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_NTUE_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_WED_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_NWED_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_THU_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_NTHU_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_FRI_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_NFRI_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_SAT_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_NSAT_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_SUN_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_NSUN_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_MON_2_THU_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_NMON_2_THU_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_MON_2_FRI_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EX_NMON_2_FRI_CHAR	char
)	O
ptr_char	*(char)
++	O
;	O
else	O
opt_error	int
=	O
5	int
;	O
if	O
(	O
!	O
opt_error	int
)	O
{	O
if	O
(	O
rc_filter_day	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_filter_day	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_filter_day"	*(char)
,	O
0	int
)	O
;	O
else	O
rc_filter_day	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
rc_filter_day	*(char)
,	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"rc_filter_day"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_filter_day	*(char)
,	O
option	*(*(char))
)	O
;	O
}	O
}	O
skip_option	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'P'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
else	O
{	O
ptr_char	*(char)
=	O
option	*(*(char))
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
!	O
opt_error	int
)	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
RC_IDATE_CHAR	char
||	O
*	O
ptr_char	*(char)
==	O
RC_EDATE_CHAR	char
)	O
{	O
ptr_char	*(char)
++	O
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
SPLIT_SEP	*(char)
)	O
)	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
||	O
*	O
ptr_char	*(char)
==	O
*	O
SPLIT_SEP	*(char)
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
}	O
else	O
opt_error	int
=	O
5	int
;	O
}	O
else	O
opt_error	int
=	O
5	int
;	O
if	O
(	O
!	O
opt_error	int
)	O
{	O
if	O
(	O
rc_filter_period	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_filter_period	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_filter_period"	*(char)
,	O
0	int
)	O
;	O
else	O
rc_filter_period	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
rc_filter_period	*(char)
,	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"rc_filter_period"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_filter_period	*(char)
,	O
option	*(*(char))
)	O
;	O
}	O
}	O
skip_option	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'I'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
4	int
;	O
else	O
{	O
if	O
(	O
rc_filter_text	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_filter_text	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_filter_text"	*(char)
,	O
0	int
)	O
;	O
else	O
rc_filter_text	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
rc_filter_text	*(char)
,	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"rc_filter_text"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_filter_text	*(char)
,	O
option	*(*(char))
)	O
;	O
}	O
skip_option	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'g'	O
:	O
option	*(*(char))
++	O
;	O
if	O
(	O
*	O
option	*(*(char))
)	O
{	O
if	O
(	O
rc_grp_sep	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_grp_sep	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
+	O
2	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_grp_sep"	*(char)
,	O
0	int
)	O
;	O
else	O
rc_grp_sep	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
rc_grp_sep	*(char)
,	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
+	O
2	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"rc_grp_sep"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_grp_sep	*(char)
,	O
"0 "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
rc_grp_sep	*(char)
,	O
option	*(*(char))
)	O
;	O
pseudo_blank_conversion	(*(*(char)))->(void)
(	O
&	O
rc_grp_sep	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
rc_grp_sep	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_grp_sep	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
RC_GROUP_SEP	*(char)
)	O
+	O
1	int
+	O
2	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_grp_sep"	*(char)
,	O
0	int
)	O
;	O
else	O
rc_grp_sep	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
rc_grp_sep	*(char)
,	O
strlen	(*(char))->(long)
(	O
RC_GROUP_SEP	*(char)
)	O
+	O
1	int
+	O
2	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"rc_grp_sep"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_grp_sep	*(char)
,	O
"0 "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
rc_grp_sep	*(char)
,	O
RC_GROUP_SEP	*(char)
)	O
;	O
}	O
skip_option	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'a'	O
:	O
rc_enable_fn_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'A'	O
:	O
rc_alternative_format_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'd'	O
:	O
rc_have_today_in_list	int
=	O
1	int
;	O
break	O
;	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
if	O
(	O
isupper	(int)->(int)
(	O
*	O
option	*(*(char))
)	O
)	O
{	O
rc_enable_hdl_flag	int
=	O
TRUE	O
;	O
rc_enable_hda_flag	int
=	O
FALSE	O
;	O
}	O
else	O
{	O
rc_enable_hdl_flag	int
=	O
FALSE	O
;	O
rc_enable_hda_flag	int
=	O
TRUE	O
;	O
}	O
break	O
;	O
case	O
'o'	O
:	O
rc_omit_date_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'l'	O
:	O
rc_period_list	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'k'	O
:	O
rc_week_number_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'U'	O
:	O
rc_suppr_date_part_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'Q'	O
:	O
rc_suppr_list_sep_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'J'	O
:	O
rc_suppr_text_part_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'x'	O
:	O
rc_title_flag	int
=	O
FALSE	O
;	O
break	O
;	O
case	O
'z'	O
:	O
rc_count_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
rc_zero_dates_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'c'	O
:	O
case	O
'C'	O
:	O
rc_use_flag	int
=	O
TRUE	O
;	O
if	O
(	O
isupper	(int)->(int)
(	O
*	O
option	*(*(char))
)	O
)	O
rc_all_dates_flag	int
=	O
TRUE	O
;	O
option	*(*(char))
++	O
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
DES_LIT	*(char)
)	O
{	O
rc_sort_des_flag	int
=	O
TRUE	O
;	O
while	O
(	O
*	O
option	*(*(char))
==	O
*	O
DES_LIT	*(char)
)	O
option	*(*(char))
++	O
;	O
}	O
option	*(*(char))
--	O
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
case	O
RC_HDY_CHAR	char
:	O
case	O
RC_NWD_CHAR	char
:	O
skip_option	int
=	O
rc_period_flag	int
=	O
TRUE	O
;	O
if	O
(	O
rc_period_argv	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_period_argv	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
*	O
argv	array(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_period_argv"	*(char)
,	O
0	int
)	O
;	O
else	O
rc_period_argv	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
rc_period_argv	*(char)
,	O
strlen	(*(char))->(long)
(	O
*	O
argv	array(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"rc_period_argv"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_period_argv	*(char)
,	O
*	O
argv	array(*(char))
)	O
;	O
if	O
(	O
rc_period_option	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_period_option	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_period_option"	*(char)
,	O
0	int
)	O
;	O
else	O
rc_period_option	*(char)
=	O
(	O
char	O
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
rc_period_option	*(char)
,	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"rc_period_option"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
rc_period_option	*(char)
,	O
option	*(*(char))
)	O
;	O
rc_period_is_longopt	int
=	O
is_longopt	int
;	O
break	O
;	O
case	O
't'	O
:	O
case	O
'T'	O
:	O
rc_clean_flags	()->(void)
(	O
)	O
;	O
skip_option	int
=	O
rc_use_flag	int
=	O
rc_tomorrow_flag	int
=	O
TRUE	O
;	O
if	O
(	O
isupper	(int)->(int)
(	O
*	O
option	*(*(char))
)	O
)	O
rc_all_dates_flag	int
=	O
TRUE	O
;	O
option	*(*(char))
++	O
;	O
if	O
(	O
*	O
option	*(*(char))
)	O
opt_error	int
=	O
5	int
;	O
break	O
;	O
case	O
'w'	O
:	O
case	O
'W'	O
:	O
case	O
'm'	O
:	O
case	O
'M'	O
:	O
case	O
'y'	O
:	O
case	O
'Y'	O
:	O
rc_clean_flags	()->(void)
(	O
)	O
;	O
switch	O
(	O
*	O
option	*(*(char))
)	O
{	O
case	O
'w'	O
:	O
case	O
'W'	O
:	O
rc_week_flag	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'm'	O
:	O
case	O
'M'	O
:	O
rc_month_flag	int
=	O
TRUE	O
;	O
break	O
;	O
default	O
:	O
rc_year_flag	int
=	O
TRUE	O
;	O
}	O
skip_option	int
=	O
rc_use_flag	int
=	O
TRUE	O
;	O
if	O
(	O
isupper	(int)->(int)
(	O
*	O
option	*(*(char))
)	O
)	O
rc_all_dates_flag	int
=	O
TRUE	O
;	O
opt_error	int
=	O
further_check	(*(*(char)))->(int)
(	O
&	O
option	*(*(char))
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
is_longopt	int
)	O
opt_error	int
=	O
5	int
;	O
else	O
opt_error	int
=	O
2	int
;	O
}	O
if	O
(	O
opt_error	int
)	O
{	O
ptr_char	*(char)
=	O
*	O
argv	array(*(char))
;	O
LABEL_option_error	O
:	O
if	O
(	O
!	O
is_longopt	int
)	O
while	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
SWITCH	*(char)
)	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
SWITCH2	*(char)
)	O
if	O
(	O
*	O
(	O
ptr_char	*(char)
+	O
1	int
)	O
!=	O
*	O
SWITCH2	*(char)
)	O
ptr_char	*(char)
++	O
;	O
switch	O
(	O
opt_error	int
)	O
{	O
case	O
1	int
:	O
case	O
2	int
:	O
case	O
3	int
:	O
case	O
4	int
:	O
case	O
5	int
:	O
case	O
6	int
:	O
if	O
(	O
is_longopt	int
&&	O
(	O
opt_error	int
==	O
3	int
)	O
)	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
LEN_SINGLE_LINE	int
;	O
else	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
+	O
LEN_SINGLE_LINE	int
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
len	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
break	O
;	O
default	O
:	O
;	O
}	O
switch	O
(	O
opt_error	int
)	O
{	O
case	O
1	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s: option `%s' is ambiguous"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
ptr_char	*(char)
)	O
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
is_longopt	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s: unrecognized option `%s'"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
ptr_char	*(char)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s: invalid option -- %s"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
ptr_char	*(char)
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
is_longopt	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s: option `--%s' doesn't allow an argument"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
option	*(*(char))
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s: option `%s' doesn't allow an argument"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
ptr_char	*(char)
)	O
;	O
break	O
;	O
case	O
4	int
:	O
if	O
(	O
is_longopt	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s: option `%s' requires an argument"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
ptr_char	*(char)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s: option requires an argument -- %s"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
ptr_char	*(char)
)	O
;	O
break	O
;	O
case	O
5	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s: option with invalid argument -- %s"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
ptr_char	*(char)
)	O
;	O
break	O
;	O
case	O
6	int
:	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s: option with ambiguous argument -- %s"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
ptr_char	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
opt_error	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
4L	int
,	O
""	*(char)
,	O
0	int
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n%s\n%s\n"	*(char)
,	O
s1	*(char)
,	O
usage_msg	()->(*(char))
(	O
)	O
,	O
lopt_msg	()->(*(char))
(	O
)	O
)	O
;	O
my_exit	(int)->(void)
(	O
ERR_INVALID_OPTION	int
)	O
;	O
}	O
if	O
(	O
skip_option	int
)	O
{	O
while	O
(	O
*	O
option	*(*(char))
)	O
option	*(*(char))
++	O
;	O
option	*(*(char))
--	O
;	O
}	O
}	O
argc	int
--	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
*	O
argv	array(*(char))
==	O
RC_ADATE_CHAR	char
)	O
argc	int
--	O
;	O
else	O
if	O
(	O
*	O
*	O
argv	array(*(char))
==	O
RSP_CHAR	char
)	O
argc	int
--	O
;	O
else	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
get_actual_date	()->(int)
(	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: invalid date given -- %c%s\n%s\n%s\n"	*(char)
)	O
,	O
prgr_name	*(char)
,	O
RC_ADATE_CHAR	char
,	O
rc_adate	*(char)
,	O
usage_msg	()->(*(char))
(	O
)	O
,	O
lopt_msg	()->(*(char))
(	O
)	O
)	O
;	O
my_exit	(int)->(void)
(	O
ERR_INVALID_OPTION	int
)	O
;	O
}	O
is_leap_year	int
=	O
(	O
days_of_february	(int)->(int)
(	O
act_year	int
)	O
==	O
29	int
)	O
;	O
buf_start_day	int
=	O
start_day	int
;	O
if	O
(	O
start_day	int
==	O
SPECIAL_VALUE	O
)	O
start_day	int
=	O
weekday_of_date	(int,int,int)->(int)
(	O
act_day	int
,	O
act_month	int
,	O
act_year	int
)	O
;	O
else	O
if	O
(	O
!	O
start_day	int
)	O
{	O
start_day	int
=	O
(	O
nl_langinfo	(int)->(*(char))
(	O
_NL_TIME_FIRST_WEEKDAY	int
)	O
[	O
0	int
]	O
+	O
5	int
)	O
%	O
7	int
+	O
1	int
;	O
}	O
if	O
(	O
rel_time_offset	char
)	O
{	O
if	O
(	O
!	O
time_hour_offset	int
&&	O
!	O
time_min_offset	int
)	O
{	O
if	O
(	O
rel_time_offset	char
==	O
RC_GMTIME_CHAR	char
)	O
{	O
time_hour_offset	int
=	O
gmt_hour	int
;	O
time_min_offset	int
=	O
gmt_min	int
;	O
}	O
else	O
{	O
time_hour_offset	int
=	O
act_hour	int
;	O
time_min_offset	int
=	O
act_min	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
rel_time_offset	char
==	O
RC_GMTIME_CHAR	char
)	O
i	int
=	O
HHMM2MM	O
(	O
gmt_hour	int
,	O
gmt_min	int
)	O
+	O
HHMM2MM	O
(	O
time_hour_offset	int
,	O
time_min_offset	int
)	O
;	O
else	O
i	int
=	O
HHMM2MM	O
(	O
act_hour	int
,	O
act_min	int
)	O
+	O
HHMM2MM	O
(	O
time_hour_offset	int
,	O
time_min_offset	int
)	O
;	O
time_hour_offset	int
=	O
MM2HH	O
(	O
abs	(int)->(int)
(	O
i	int
)	O
)	O
;	O
time_min_offset	int
=	O
abs	(int)->(int)
(	O
i	int
)	O
%	O
MINS_PER_HOUR	int
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
time_hour_offset	int
=	O
-	O
time_hour_offset	int
;	O
time_min_offset	int
=	O
-	O
time_min_offset	int
;	O
}	O
}	O
}	O
time_offset	double
=	O
HHMM2DAY	O
(	O
time_hour_offset	int
,	O
time_min_offset	int
)	O
;	O
if	O
(	O
rel_loop_end	char
)	O
{	O
if	O
(	O
rel_loop_end	char
==	O
RC_GMTIME_CHAR	char
)	O
i	int
=	O
HHMM2MM	O
(	O
gmt_hour	int
,	O
gmt_min	int
)	O
;	O
else	O
i	int
=	O
HHMM2MM	O
(	O
act_hour	int
,	O
act_min	int
)	O
;	O
if	O
(	O
!	O
set_loop_end	int
&&	O
(	O
loop_end	int
==	O
SPECIAL_VALUE	O
)	O
)	O
loop_end	int
=	O
i	int
;	O
else	O
loop_end	int
=	O
i	int
+	O
loop_end	int
;	O
set_loop_end	int
=	O
TRUE	O
;	O
}	O
if	O
(	O
set_loop_end	int
)	O
{	O
if	O
(	O
loop_end	int
<	O
0	int
)	O
loop_end	int
=	O
0	int
;	O
else	O
if	O
(	O
loop_end	int
>=	O
MINS_PER_DAY	int
)	O
loop_end	int
=	O
MINS_PER_DAY	int
-	O
1	int
;	O
}	O
if	O
(	O
rc_period_flag	int
)	O
{	O
if	O
(	O
!	O
rc_use_flag	int
)	O
opt_error	int
=	O
2	int
;	O
else	O
{	O
register	O
int	O
act_is_leap_year	int
=	O
(	O
days_of_february	(int)->(int)
(	O
act_year	int
)	O
==	O
29	int
)	O
;	O
auto	O
int	O
wmax	int
=	O
WEEK_MAX	int
;	O
auto	O
char	O
dvar	char
=	O
'\0'	O
;	O
auto	O
Bool	int
nth_day_of_year_flag	int
=	O
FALSE	O
;	O
if	O
(	O
act_year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
wmax	int
=	O
(	O
(	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
==	O
29	int
)	O
-	O
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
-	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
+	O
1	int
)	O
)	O
/	O
DAY_MAX	int
)	O
+	O
1	int
;	O
rc_clean_flags	()->(void)
(	O
)	O
;	O
i	int
=	O
0	int
;	O
rc_period	int
=	O
0	int
;	O
rc_period_flag	int
=	O
TRUE	O
;	O
option	*(*(char))
=	O
rc_period_option	*(char)
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
RC_HDY_CHAR	char
||	O
*	O
option	*(*(char))
==	O
RC_NWD_CHAR	char
)	O
dvar	char
=	O
*	O
option	*(*(char))
;	O
else	O
rc_period	int
=	O
atoi	(*(char))->(int)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
!	O
dvar	char
)	O
{	O
rc_fwdf_buffer	int
=	O
rc_forwards_flag	int
=	O
(	O
Bool	int
)	O
(	O
strchr	(*(char),int)->(*(char))
(	O
option	*(*(char))
,	O
*	O
ASC_LIT	*(char)
)	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
rc_bwdf_buffer	int
=	O
rc_backwards_flag	int
=	O
(	O
Bool	int
)	O
(	O
strchr	(*(char),int)->(*(char))
(	O
option	*(*(char))
,	O
*	O
DES_LIT	*(char)
)	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
ptr_char	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
option	*(*(char))
,	O
'w'	O
)	O
;	O
if	O
(	O
ptr_char	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
ptr_char	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
option	*(*(char))
,	O
'W'	O
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
)	O
rc_week_year_flag	int
=	O
TRUE	O
;	O
}	O
ptr_char	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
option	*(*(char))
,	O
'd'	O
)	O
;	O
if	O
(	O
ptr_char	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
ptr_char	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
option	*(*(char))
,	O
'D'	O
)	O
;	O
if	O
(	O
ptr_char	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
)	O
nth_day_of_year_flag	int
=	O
TRUE	O
;	O
}	O
i	int
=	O
(	O
int	O
)	O
rc_forwards_flag	int
+	O
rc_backwards_flag	int
+	O
rc_week_year_flag	int
+	O
nth_day_of_year_flag	int
;	O
}	O
if	O
(	O
rc_period	int
==	O
999	int
)	O
rc_period	int
=	O
DAY_LAST	int
+	O
act_is_leap_year	int
;	O
if	O
(	O
!	O
dvar	char
&&	O
(	O
i	int
>	O
1	int
||	O
(	O
(	O
rc_period	int
>	O
DAY_LAST	int
+	O
act_is_leap_year	int
)	O
&&	O
(	O
rc_forwards_flag	int
||	O
rc_backwards_flag	int
||	O
nth_day_of_year_flag	int
)	O
)	O
||	O
(	O
rc_week_year_flag	int
&&	O
(	O
rc_period	int
>	O
wmax	int
+	O
1	int
)	O
&&	O
(	O
rc_period	int
!=	O
99	int
)	O
)	O
)	O
)	O
opt_error	int
=	O
5	int
;	O
else	O
{	O
if	O
(	O
!	O
rc_week_year_flag	int
&&	O
!	O
rc_forwards_flag	int
&&	O
!	O
rc_backwards_flag	int
)	O
{	O
auto	O
int	O
y	int
=	O
act_year	int
;	O
auto	O
int	O
n	long
;	O
auto	O
char	O
hc	char
;	O
auto	O
Bool	int
is_weekday_mode	*(int)
;	O
if	O
(	O
!	O
nth_day_of_year_flag	int
)	O
{	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
+	O
len_year_max	int
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
len	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
s2	*(char)
,	O
"%0*d%s"	*(char)
,	O
len_year_max	int
,	O
y	int
,	O
option	*(*(char))
)	O
;	O
(	O
void	O
)	O
rc_get_date	(*(char),*(struct(int,int,*(char),*(char),*(char),*(char))),int,*(int),*(int),*(int),*(int),*(int),*(int),*(char),*(int),*(int),*(char),long,*(char),int)->(*(struct(int,int,*(char),*(char),*(char),*(char))))
(	O
s2	*(char)
,	O
lineptrs	*(struct(int,int,*(char),*(char),*(char),*(char)))
,	O
FALSE	O
,	O
&	O
is_weekday_mode	*(int)
,	O
&	O
day	int
,	O
&	O
month	int
,	O
&	O
y	int
,	O
&	O
n	long
,	O
&	O
wmax	int
,	O
&	O
hc	char
,	O
&	O
i	int
,	O
&	O
i	int
,	O
_	O
(	O
"Internal"	*(char)
)	O
,	O
-	O
1L	int
,	O
s2	*(char)
,	O
FALSE	O
)	O
;	O
if	O
(	O
y	int
!=	O
SPECIAL_VALUE	O
)	O
{	O
if	O
(	O
!	O
dvar	char
)	O
{	O
if	O
(	O
!	O
month	int
)	O
month	int
=	O
act_month	int
;	O
if	O
(	O
month	int
<	O
MONTH_MIN	int
||	O
month	int
>	O
MONTH_MAX	int
)	O
opt_error	int
=	O
5	int
;	O
else	O
{	O
i	int
=	O
dvec	array(int)
[	O
month	int
-	O
1	int
]	O
;	O
if	O
(	O
month	int
==	O
2	int
)	O
i	int
+=	O
act_is_leap_year	int
;	O
if	O
(	O
is_weekday_mode	*(int)
)	O
{	O
if	O
(	O
n	long
==	O
9	int
)	O
day	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
i	int
,	O
month	int
,	O
act_year	int
,	O
day	int
,	O
FALSE	O
)	O
;	O
else	O
{	O
day	int
=	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
DAY_MIN	int
,	O
month	int
,	O
act_year	int
,	O
day	int
,	O
TRUE	O
)	O
;	O
day	int
+=	O
(	O
DAY_MAX	int
*	O
(	O
n	long
-	O
1	int
)	O
)	O
;	O
if	O
(	O
day	int
>	O
i	int
)	O
opt_error	int
=	O
5	int
;	O
else	O
{	O
if	O
(	O
!	O
day	int
||	O
!	O
valid_date	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
act_year	int
)	O
)	O
opt_error	int
=	O
5	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
day	int
==	O
99	int
)	O
day	int
=	O
i	int
;	O
if	O
(	O
!	O
day	int
)	O
day	int
=	O
act_day	int
;	O
if	O
(	O
day	int
<	O
DAY_MIN	int
||	O
day	int
>	O
i	int
)	O
opt_error	int
=	O
5	int
;	O
}	O
}	O
}	O
else	O
if	O
(	O
!	O
day	int
||	O
!	O
month	int
)	O
opt_error	int
=	O
5	int
;	O
if	O
(	O
!	O
opt_error	int
)	O
rc_period	int
=	O
day_of_year	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
act_year	int
)	O
;	O
}	O
else	O
opt_error	int
=	O
5	int
;	O
}	O
else	O
if	O
(	O
!	O
rc_period	int
)	O
opt_error	int
=	O
5	int
;	O
if	O
(	O
!	O
opt_error	int
)	O
{	O
i	int
=	O
day_of_year	(int,int,int)->(int)
(	O
act_day	int
,	O
act_month	int
,	O
act_year	int
)	O
;	O
if	O
(	O
rc_period	int
>=	O
i	int
)	O
{	O
rc_period	int
-=	O
i	int
;	O
if	O
(	O
!	O
rc_period	int
)	O
rc_period_flag	int
=	O
FALSE	O
;	O
else	O
rc_forwards_flag	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
rc_period	int
=	O
i	int
-	O
rc_period	int
;	O
rc_backwards_flag	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
option	*(*(char))
)	O
)	O
{	O
i	int
++	O
;	O
option	*(*(char))
++	O
;	O
}	O
option	*(*(char))
--	O
;	O
if	O
(	O
!	O
rc_period	int
&&	O
!	O
rc_week_year_flag	int
)	O
opt_error	int
=	O
5	int
;	O
else	O
opt_error	int
=	O
further_check	(*(*(char)))->(int)
(	O
&	O
option	*(*(char))
)	O
;	O
}	O
}	O
}	O
if	O
(	O
opt_error	int
)	O
{	O
ptr_char	*(char)
=	O
rc_period_argv	*(char)
;	O
is_longopt	int
=	O
rc_period_is_longopt	int
;	O
goto	O
LABEL_option_error	O
;	O
}	O
else	O
{	O
free	(*(void))->(void)
(	O
rc_period_argv	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
rc_period_option	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
help_flag	int
||	O
license_flag	int
||	O
version_flag	int
)	O
{	O
if	O
(	O
is_tty1	int
&&	O
(	O
ext_pager	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
is_tty2	int
)	O
{	O
setbuf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
setbuf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
get_tty_scr_size	(*(int),*(int))->(void)
(	O
&	O
tty_rows	int
,	O
&	O
tty_cols	int
)	O
;	O
}	O
else	O
if	O
(	O
help_on_help_flag	int
)	O
get_tty_scr_size	(*(int),*(int))->(void)
(	O
&	O
tty_rows	int
,	O
&	O
tty_cols	int
)	O
;	O
get_tty_hls	(*(char))->(void)
(	O
hl_seq	*(char)
)	O
;	O
if	O
(	O
is_tty1	int
&&	O
is_tty2	int
&&	O
pager_flag	int
&&	O
(	O
ext_pager	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
email_adr	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
child_pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
switch	O
(	O
child_pid	int
)	O
{	O
case	O
-	O
1	int
:	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
7L	int
,	O
"fork() child_pid="	*(char)
,	O
child_pid	int
)	O
;	O
case	O
0	int
:	O
close	(int)->(int)
(	O
pipe_fd	array(int)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
pipe_fd	array(int)
[	O
0	int
]	O
)	O
{	O
close	(int)->(int)
(	O
0	int
)	O
;	O
dup	(int)->(int)
(	O
pipe_fd	array(int)
[	O
0	int
]	O
)	O
;	O
close	(int)->(int)
(	O
pipe_fd	array(int)
[	O
0	int
]	O
)	O
;	O
}	O
if	O
(	O
pg_argv	*(*(char))
==	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
{	O
i	int
=	O
execlp	(*(char),*(char))->(int)
(	O
ext_pager	*(char)
,	O
ext_pager	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ext_pager	*(char)
)	O
+	O
LEN_SINGLE_LINE	int
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
len	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
"execlp(%s)="	*(char)
,	O
ext_pager	*(char)
)	O
;	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
9L	int
,	O
s1	*(char)
,	O
i	int
)	O
;	O
}	O
else	O
{	O
i	int
=	O
execvp	(*(char),array(*(char)))->(int)
(	O
ext_pager	*(char)
,	O
pg_argv	*(*(char))
)	O
;	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ext_pager	*(char)
)	O
+	O
LEN_SINGLE_LINE	int
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
len	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
"execvp(%s)="	*(char)
,	O
ext_pager	*(char)
)	O
;	O
my_error	(int,*(char),long,*(char),int)->(void)
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
9L	int
,	O
s1	*(char)
,	O
i	int
)	O
;	O
}	O
default	O
:	O
close	(int)->(int)
(	O
pipe_fd	array(int)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
pipe_fd	array(int)
[	O
1	int
]	O
!=	O
1	int
)	O
{	O
close	(int)->(int)
(	O
1	int
)	O
;	O
if	O
(	O
!	O
dup	(int)->(int)
(	O
pipe_fd	array(int)
[	O
1	int
]	O
)	O
)	O
{	O
dup	(int)->(int)
(	O
pipe_fd	array(int)
[	O
1	int
]	O
)	O
;	O
close	(int)->(int)
(	O
0	int
)	O
;	O
}	O
close	(int)->(int)
(	O
pipe_fd	array(int)
[	O
1	int
]	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
help_flag	int
)	O
{	O
if	O
(	O
help_on_help_flag	int
)	O
my_help_on_help	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,int)->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s3	*(char)
,	O
lopt_ambig	int
,	O
tty_cols	int
)	O
;	O
else	O
if	O
(	O
ext_help_flag	int
)	O
my_extended_help	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
lopt_help	int
)	O
;	O
else	O
my_basic_help	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
license_flag	int
)	O
my_license	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
if	O
(	O
version_flag	int
)	O
my_version	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
is_tty1	int
&&	O
is_tty2	int
&&	O
pager_flag	int
&&	O
(	O
ext_pager	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
email_adr	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
close	(int)->(int)
(	O
0	int
)	O
;	O
dup	(int)->(int)
(	O
sys_fd	array(int)
[	O
0	int
]	O
)	O
;	O
close	(int)->(int)
(	O
1	int
)	O
;	O
dup	(int)->(int)
(	O
sys_fd	array(int)
[	O
1	int
]	O
)	O
;	O
while	O
(	O
wait	(*(int))->(int)
(	O
(	O
int	O
*	O
)	O
NULL	O
)	O
!=	O
child_pid	int
)	O
;	O
(	O
void	O
)	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
}	O
my_exit	(int)->(void)
(	O
exit_stat_help	int
)	O
;	O
}	O
month	int
=	O
0	int
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
auto	O
Bool	int
is_list	int
=	O
FALSE	O
;	O
auto	O
Bool	int
is_range	int
=	O
FALSE	O
;	O
auto	O
Bool	int
month_set	int
=	O
FALSE	O
;	O
auto	O
Bool	int
year_sep_found	int
=	O
FALSE	O
;	O
for	O
(	O
;	O
argc	int
>	O
1	int
;	O
argc	int
--	O
,	O
argv	array(*(char))
++	O
)	O
{	O
if	O
(	O
!	O
month	int
)	O
{	O
option	*(*(char))
=	O
*	O
argv	array(*(char))
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
MONTH3_LIT	*(char)
)	O
break	O
;	O
else	O
while	O
(	O
*	O
option	*(*(char))
)	O
{	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
MLIST_SEP	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
YLIST_SEP	*(char)
)	O
is_list	int
=	O
TRUE	O
;	O
else	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
MRANGE_SEP	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
YRANGE_SEP	*(char)
)	O
is_range	int
=	O
TRUE	O
;	O
else	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
YEAR_SEP	*(char)
)	O
year_sep_found	int
=	O
TRUE	O
;	O
else	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
FYEAR_SEP	*(char)
)	O
is_fiscal_year	int
=	O
TRUE	O
;	O
option	*(*(char))
++	O
;	O
}	O
option	*(*(char))
=	O
*	O
argv	array(*(char))
;	O
if	O
(	O
!	O
is_list	int
&&	O
!	O
is_range	int
&&	O
!	O
year_sep_found	int
&&	O
!	O
is_fiscal_year	int
&&	O
!	O
my_atoi	(*(char))->(int)
(	O
option	*(*(char))
)	O
)	O
{	O
month	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
option	*(*(char))
,	O
MOnth	int
)	O
;	O
if	O
(	O
month	int
)	O
{	O
month_set	int
=	O
TRUE	O
;	O
continue	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
month	int
)	O
{	O
build_month_list	(array(*(char)))->(void)
(	O
argv	array(*(char))
)	O
;	O
if	O
(	O
!	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_month	int
)	O
month	int
=	O
atoi	(*(char))->(int)
(	O
*	O
argv	array(*(char))
)	O
;	O
else	O
month	int
=	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_month	int
;	O
if	O
(	O
month	int
<	O
MONTH_MIN	int
||	O
month	int
>	O
MONTH_MAX	int
)	O
{	O
if	O
(	O
!	O
is_fiscal_year	int
)	O
year	int
=	O
month	int
;	O
month	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
year	int
)	O
{	O
if	O
(	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_year	int
&&	O
(	O
is_list	int
||	O
is_range	int
)	O
)	O
year	int
=	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_year	int
;	O
else	O
year	int
=	O
my_atoi	(*(char))->(int)
(	O
*	O
argv	array(*(char))
)	O
;	O
if	O
(	O
month	int
&&	O
isdigit	(int)->(int)
(	O
*	O
*	O
argv	array(*(char))
)	O
&&	O
(	O
strchr	(*(char),int)->(*(char))
(	O
*	O
argv	array(*(char))
,	O
*	O
MRANGE_SEP	*(char)
)	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
||	O
strchr	(*(char),int)->(*(char))
(	O
*	O
argv	array(*(char))
,	O
*	O
YRANGE_SEP	*(char)
)	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
(	O
*	O
(	O
argv	array(*(char))
)	O
+	O
i	int
)	O
)	O
)	O
{	O
s2	*(char)
[	O
i	int
]	O
=	O
*	O
(	O
*	O
(	O
argv	array(*(char))
)	O
+	O
i	int
)	O
;	O
i	int
++	O
;	O
}	O
if	O
(	O
*	O
(	O
*	O
(	O
argv	array(*(char))
)	O
+	O
i	int
)	O
==	O
*	O
MRANGE_SEP	*(char)
||	O
*	O
(	O
*	O
(	O
argv	array(*(char))
)	O
+	O
i	int
)	O
==	O
*	O
YRANGE_SEP	*(char)
)	O
{	O
s2	*(char)
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
year	int
=	O
my_atoi	(*(char))->(int)
(	O
s2	*(char)
)	O
;	O
if	O
(	O
!	O
year	int
)	O
year	int
=	O
act_year	int
;	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_year	int
=	O
year	int
;	O
year	int
=	O
my_atoi	(*(char))->(int)
(	O
*	O
(	O
argv	array(*(char))
)	O
+	O
i	int
)	O
;	O
if	O
(	O
!	O
year	int
)	O
year	int
=	O
act_year	int
;	O
month_list	*(struct(int,int))
[	O
1	int
]	O
.	O
ml_year	int
=	O
year	int
;	O
if	O
(	O
*	O
(	O
*	O
(	O
argv	array(*(char))
)	O
+	O
i	int
-	O
1	int
)	O
==	O
*	O
MRANGE_SEP	*(char)
)	O
{	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_month	int
=	O
month_list	*(struct(int,int))
[	O
1	int
]	O
.	O
ml_month	int
=	O
month	int
;	O
is_special_range	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
month_list	*(struct(int,int))
[	O
i	int
]	O
.	O
ml_month	int
)	O
i	int
++	O
;	O
if	O
(	O
!	O
i	int
)	O
{	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_month	int
=	O
month_list	*(struct(int,int))
[	O
1	int
]	O
.	O
ml_month	int
=	O
month	int
;	O
is_special_range	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
i	int
--	O
;	O
month_list	*(struct(int,int))
[	O
1	int
]	O
.	O
ml_month	int
=	O
month_list	*(struct(int,int))
[	O
i	int
]	O
.	O
ml_month	int
;	O
is_multi_range	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
else	O
{	O
year	int
=	O
month	int
;	O
month	int
=	O
0	int
;	O
}	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
MONTH3_LIT	*(char)
)	O
{	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
len	int
<=	O
2	int
)	O
{	O
if	O
(	O
*	O
(	O
option	*(*(char))
+	O
1	int
)	O
==	O
*	O
MONTH3_LIT	*(char)
)	O
is_3month_mode2	int
=	O
TRUE	O
;	O
else	O
is_3month_mode	int
=	O
TRUE	O
;	O
is_fiscal_year	int
=	O
TRUE	O
;	O
year_flag	int
=	O
FALSE	O
;	O
month	int
=	O
act_month	int
;	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
argv	array(*(char))
++	O
;	O
year	int
=	O
atoi	(*(char))->(int)
(	O
*	O
argv	array(*(char))
)	O
;	O
if	O
(	O
!	O
year	int
)	O
year	int
=	O
act_year	int
;	O
}	O
else	O
year	int
=	O
act_year	int
;	O
if	O
(	O
is_3month_mode	int
)	O
{	O
if	O
(	O
!	O
*	O
(	O
option	*(*(char))
+	O
1	int
)	O
)	O
{	O
month	int
--	O
;	O
if	O
(	O
!	O
month	int
)	O
{	O
month	int
=	O
MONTH_MAX	int
;	O
year	int
--	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
(	O
option	*(*(char))
+	O
1	int
)	O
==	O
*	O
DES_LIT	*(char)
)	O
{	O
month	int
-=	O
2	int
;	O
if	O
(	O
month	int
<	O
MONTH_MIN	int
)	O
{	O
month	int
=	O
MONTH_MAX	int
+	O
month	int
;	O
year	int
--	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
(	O
option	*(*(char))
+	O
1	int
)	O
==	O
*	O
ASC_LIT	*(char)
)	O
;	O
else	O
{	O
is_fiscal_year	int
=	O
FALSE	O
;	O
year	int
=	O
act_year	int
;	O
month	int
=	O
act_month	int
;	O
}	O
if	O
(	O
year	int
<	O
YEAR_MIN	int
)	O
{	O
year	int
=	O
YEAR_MIN	int
;	O
month	int
=	O
act_month	int
;	O
}	O
}	O
else	O
month	int
=	O
(	O
(	O
month	int
+	O
1	int
)	O
-	O
(	O
(	O
month	int
-	O
1	int
)	O
%	O
3	int
)	O
)	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
month	int
&&	O
!	O
year	int
&&	O
!	O
month_set	int
&&	O
!	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_month	int
&&	O
!	O
is_fiscal_year	int
)	O
{	O
year	int
=	O
month	int
;	O
month	int
=	O
0	int
;	O
}	O
}	O
}	O
static	O
void	O
build_month_list	(array(*(char)))->(void)
(	O
argv	array(*(char))
)	O
char	O
*	O
argv	array(*(char))
[	O
]	O
;	O
{	O
register	O
int	O
i	int
;	O
register	O
int	O
j	int
;	O
register	O
int	O
k	int
;	O
auto	O
const	O
char	O
*	O
option	*(*(char))
;	O
auto	O
Bool	int
is_list	int
=	O
FALSE	O
;	O
auto	O
Bool	int
is_range	int
=	O
FALSE	O
;	O
auto	O
Bool	int
year_sep_found	int
=	O
FALSE	O
;	O
auto	O
Bool	int
buf_is_ext_year	int
;	O
option	*(*(char))
=	O
*	O
argv	array(*(char))
;	O
for	O
(	O
;	O
*	O
option	*(*(char))
&&	O
!	O
is_list	int
&&	O
!	O
is_range	int
;	O
option	*(*(char))
++	O
)	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
MLIST_SEP	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
YLIST_SEP	*(char)
)	O
{	O
is_list	int
=	O
TRUE	O
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
YLIST_SEP	*(char)
)	O
is_ext_list	int
=	O
is_ext_year	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
MRANGE_SEP	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
YRANGE_SEP	*(char)
)	O
{	O
is_range	int
=	O
TRUE	O
;	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
YRANGE_SEP	*(char)
)	O
is_ext_range	int
=	O
is_ext_year	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
*	O
option	*(*(char))
==	O
*	O
YEAR_SEP	*(char)
)	O
year_sep_found	int
=	O
TRUE	O
;	O
buf_is_ext_year	int
=	O
is_ext_year	int
;	O
if	O
(	O
year_sep_found	int
||	O
(	O
is_fiscal_year	int
&&	O
(	O
is_ext_list	int
||	O
is_ext_year	int
||	O
(	O
!	O
is_list	int
&&	O
!	O
is_range	int
)	O
)	O
)	O
||	O
(	O
!	O
is_fiscal_year	int
&&	O
(	O
is_list	int
||	O
is_range	int
)	O
)	O
)	O
{	O
i	int
=	O
0	int
;	O
option	*(*(char))
=	O
*	O
argv	array(*(char))
;	O
while	O
(	O
*	O
option	*(*(char))
)	O
{	O
year_sep_found	int
=	O
FALSE	O
;	O
j	int
=	O
0	int
;	O
while	O
(	O
*	O
option	*(*(char))
&&	O
!	O
year_sep_found	int
&&	O
(	O
(	O
!	O
is_list	int
&&	O
!	O
is_range	int
)	O
||	O
(	O
(	O
is_list	int
&&	O
(	O
(	O
*	O
option	*(*(char))
!=	O
*	O
MLIST_SEP	*(char)
)	O
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
YLIST_SEP	*(char)
)	O
)	O
)	O
||	O
(	O
is_range	int
&&	O
(	O
(	O
*	O
option	*(*(char))
!=	O
*	O
MRANGE_SEP	*(char)
)	O
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
YRANGE_SEP	*(char)
)	O
)	O
)	O
)	O
)	O
)	O
{	O
year_sep_found	int
=	O
(	O
Bool	int
)	O
(	O
*	O
option	*(*(char))
==	O
*	O
YEAR_SEP	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
FYEAR_SEP	*(char)
)	O
;	O
s1	*(char)
[	O
j	int
++	O
]	O
=	O
*	O
option	*(*(char))
++	O
;	O
}	O
if	O
(	O
year_sep_found	int
)	O
s1	*(char)
[	O
j	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
else	O
s1	*(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
*	O
s1	*(char)
)	O
{	O
if	O
(	O
is_fiscal_year	int
)	O
{	O
j	int
=	O
atoi	(*(char))->(int)
(	O
option	*(*(char))
)	O
;	O
if	O
(	O
j	int
)	O
{	O
is_ext_year	int
=	O
FALSE	O
;	O
month_list	*(struct(int,int))
[	O
i	int
++	O
]	O
.	O
ml_month	int
=	O
act_month	int
;	O
}	O
}	O
else	O
{	O
j	int
=	O
0	int
;	O
while	O
(	O
*	O
option	*(*(char))
)	O
option	*(*(char))
++	O
;	O
}	O
}	O
else	O
j	int
=	O
my_atoi	(*(char))->(int)
(	O
s1	*(char)
)	O
;	O
if	O
(	O
is_ext_year	int
)	O
{	O
if	O
(	O
is_fiscal_year	int
)	O
{	O
if	O
(	O
(	O
j	int
>=	O
MONTH_MIN	int
)	O
&&	O
(	O
j	int
<=	O
MONTH_MAX	int
)	O
)	O
month_list	*(struct(int,int))
[	O
i	int
++	O
]	O
.	O
ml_month	int
=	O
j	int
;	O
else	O
{	O
j	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
s1	*(char)
,	O
MOnth	int
)	O
;	O
if	O
(	O
j	int
)	O
month_list	*(struct(int,int))
[	O
i	int
++	O
]	O
.	O
ml_month	int
=	O
j	int
;	O
else	O
if	O
(	O
!	O
*	O
option	*(*(char))
)	O
{	O
if	O
(	O
is_ext_list	int
||	O
is_ext_range	int
)	O
{	O
if	O
(	O
!	O
is_ext_list	int
)	O
month_list	*(struct(int,int))
[	O
i	int
]	O
.	O
ml_month	int
=	O
month_list	*(struct(int,int))
[	O
i	int
-	O
1	int
]	O
.	O
ml_month	int
;	O
else	O
month_list	*(struct(int,int))
[	O
i	int
]	O
.	O
ml_month	int
=	O
MONTH_MIN	int
;	O
j	int
=	O
my_atoi	(*(char))->(int)
(	O
s1	*(char)
)	O
;	O
if	O
(	O
j	int
)	O
month_list	*(struct(int,int))
[	O
i	int
++	O
]	O
.	O
ml_year	int
=	O
j	int
;	O
else	O
month_list	*(struct(int,int))
[	O
i	int
]	O
.	O
ml_month	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
year_sep_found	int
)	O
{	O
j	int
=	O
my_atoi	(*(char))->(int)
(	O
s1	*(char)
)	O
;	O
if	O
(	O
j	int
)	O
month_list	*(struct(int,int))
[	O
i	int
++	O
]	O
.	O
ml_month	int
=	O
j	int
;	O
}	O
else	O
year_sep_found	int
=	O
FALSE	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
year_sep_found	int
)	O
{	O
j	int
=	O
0	int
;	O
while	O
(	O
*	O
option	*(*(char))
&&	O
(	O
(	O
is_list	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
YLIST_SEP	*(char)
)	O
)	O
||	O
(	O
is_range	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
YRANGE_SEP	*(char)
)	O
)	O
)	O
)	O
s1	*(char)
[	O
j	int
++	O
]	O
=	O
*	O
option	*(*(char))
++	O
;	O
s1	*(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
j	int
=	O
my_atoi	(*(char))->(int)
(	O
s1	*(char)
)	O
;	O
}	O
if	O
(	O
j	int
)	O
month_list	*(struct(int,int))
[	O
i	int
++	O
]	O
.	O
ml_month	int
=	O
j	int
;	O
else	O
if	O
(	O
is_list	int
)	O
month_list	*(struct(int,int))
[	O
i	int
++	O
]	O
.	O
ml_month	int
=	O
act_year	int
;	O
}	O
if	O
(	O
year_sep_found	int
)	O
{	O
while	O
(	O
*	O
option	*(*(char))
==	O
*	O
YEAR_SEP	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
FYEAR_SEP	*(char)
)	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
is_fiscal_year	int
)	O
{	O
year_sep_found	int
=	O
FALSE	O
;	O
while	O
(	O
*	O
option	*(*(char))
&&	O
(	O
(	O
is_list	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
YLIST_SEP	*(char)
)	O
)	O
||	O
(	O
is_range	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
YRANGE_SEP	*(char)
)	O
)	O
)	O
)	O
option	*(*(char))
++	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
*	O
s1	*(char)
)	O
{	O
if	O
(	O
(	O
j	int
>=	O
MONTH_MIN	int
)	O
&&	O
(	O
j	int
<=	O
MONTH_MAX	int
)	O
)	O
month_list	*(struct(int,int))
[	O
i	int
++	O
]	O
.	O
ml_month	int
=	O
j	int
;	O
else	O
{	O
j	int
=	O
compare_d_m_name	(*(char),enum(int,int,int,int,int,int,int))->(int)
(	O
s1	*(char)
,	O
MOnth	int
)	O
;	O
if	O
(	O
j	int
)	O
month_list	*(struct(int,int))
[	O
i	int
++	O
]	O
.	O
ml_month	int
=	O
j	int
;	O
}	O
if	O
(	O
i	int
&&	O
is_range	int
&&	O
!	O
year_sep_found	int
&&	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_year	int
&&	O
!	O
*	O
option	*(*(char))
)	O
{	O
if	O
(	O
j	int
)	O
i	int
--	O
;	O
else	O
j	int
=	O
my_atoi	(*(char))->(int)
(	O
s1	*(char)
)	O
;	O
if	O
(	O
j	int
)	O
{	O
month_list	*(struct(int,int))
[	O
i	int
]	O
.	O
ml_month	int
=	O
month_list	*(struct(int,int))
[	O
i	int
-	O
1	int
]	O
.	O
ml_month	int
;	O
month_list	*(struct(int,int))
[	O
i	int
++	O
]	O
.	O
ml_year	int
=	O
j	int
;	O
is_ext_range	int
=	O
FALSE	O
;	O
is_special_range	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
if	O
(	O
year_sep_found	int
)	O
{	O
if	O
(	O
j	int
)	O
{	O
j	int
=	O
0	int
;	O
while	O
(	O
*	O
option	*(*(char))
==	O
*	O
YEAR_SEP	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
FYEAR_SEP	*(char)
)	O
option	*(*(char))
++	O
;	O
if	O
(	O
!	O
is_list	int
&&	O
!	O
is_range	int
)	O
while	O
(	O
*	O
option	*(*(char))
)	O
s1	*(char)
[	O
j	int
++	O
]	O
=	O
*	O
option	*(*(char))
++	O
;	O
else	O
if	O
(	O
is_fiscal_year	int
&&	O
(	O
is_ext_list	int
||	O
is_ext_range	int
)	O
)	O
while	O
(	O
*	O
option	*(*(char))
&&	O
(	O
(	O
is_list	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
YLIST_SEP	*(char)
)	O
)	O
||	O
(	O
is_range	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
YRANGE_SEP	*(char)
)	O
)	O
)	O
)	O
s1	*(char)
[	O
j	int
++	O
]	O
=	O
*	O
option	*(*(char))
++	O
;	O
else	O
while	O
(	O
*	O
option	*(*(char))
&&	O
(	O
(	O
is_list	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
MLIST_SEP	*(char)
)	O
)	O
||	O
(	O
is_range	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
MRANGE_SEP	*(char)
)	O
)	O
)	O
)	O
s1	*(char)
[	O
j	int
++	O
]	O
=	O
*	O
option	*(*(char))
++	O
;	O
s1	*(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
j	int
=	O
my_atoi	(*(char))->(int)
(	O
s1	*(char)
)	O
;	O
if	O
(	O
j	int
)	O
{	O
month_list	*(struct(int,int))
[	O
i	int
-	O
1	int
]	O
.	O
ml_year	int
=	O
j	int
;	O
if	O
(	O
is_list	int
&&	O
!	O
is_ext_range	int
)	O
is_ext_list	int
=	O
TRUE	O
;	O
else	O
if	O
(	O
is_range	int
&&	O
!	O
is_ext_list	int
)	O
is_ext_range	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
is_fiscal_year	int
)	O
month_list	*(struct(int,int))
[	O
i	int
-	O
1	int
]	O
.	O
ml_year	int
=	O
act_year	int
;	O
}	O
else	O
{	O
if	O
(	O
is_fiscal_year	int
)	O
while	O
(	O
*	O
option	*(*(char))
&&	O
(	O
(	O
is_list	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
YLIST_SEP	*(char)
)	O
)	O
||	O
(	O
is_range	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
YRANGE_SEP	*(char)
)	O
)	O
)	O
)	O
option	*(*(char))
++	O
;	O
else	O
while	O
(	O
*	O
option	*(*(char))
&&	O
(	O
(	O
is_list	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
MLIST_SEP	*(char)
)	O
)	O
||	O
(	O
is_range	int
&&	O
(	O
*	O
option	*(*(char))
!=	O
*	O
MRANGE_SEP	*(char)
)	O
)	O
)	O
)	O
option	*(*(char))
++	O
;	O
}	O
}	O
while	O
(	O
*	O
option	*(*(char))
==	O
*	O
MLIST_SEP	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
MRANGE_SEP	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
YLIST_SEP	*(char)
||	O
*	O
option	*(*(char))
==	O
*	O
YRANGE_SEP	*(char)
)	O
option	*(*(char))
++	O
;	O
if	O
(	O
i	int
&&	O
is_fiscal_year	int
&&	O
!	O
month_list	*(struct(int,int))
[	O
i	int
-	O
1	int
]	O
.	O
ml_year	int
)	O
{	O
month_list	*(struct(int,int))
[	O
i	int
-	O
1	int
]	O
.	O
ml_year	int
=	O
month_list	*(struct(int,int))
[	O
i	int
-	O
1	int
]	O
.	O
ml_month	int
;	O
month_list	*(struct(int,int))
[	O
i	int
-	O
1	int
]	O
.	O
ml_month	int
=	O
MONTH_MIN	int
;	O
}	O
is_ext_year	int
=	O
buf_is_ext_year	int
;	O
if	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
month_list_max	int
)	O
{	O
month_list_max	int
<<=	O
1	int
;	O
if	O
(	O
month_list_max	int
*	O
sizeof	O
(	O
Ml_struct	struct(int,int)
)	O
>	O
testval	int
)	O
month_list_max	int
--	O
;	O
month_list	*(struct(int,int))
=	O
(	O
Ml_struct	struct(int,int)
*	O
)	O
my_realloc	(*(void),int,int,*(char),long,*(char),int)->(*(void))
(	O
(	O
VOID_PTR	O
)	O
month_list	*(struct(int,int))
,	O
month_list_max	int
*	O
sizeof	O
(	O
Ml_struct	struct(int,int)
)	O
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
3L	int
,	O
"month_list[month_list_max]"	*(char)
,	O
month_list_max	int
)	O
;	O
for	O
(	O
k	int
=	O
i	int
;	O
k	int
<	O
(	O
int	O
)	O
month_list_max	int
;	O
k	int
++	O
)	O
month_list	*(struct(int,int))
[	O
k	int
]	O
.	O
ml_year	int
=	O
month_list	*(struct(int,int))
[	O
k	int
]	O
.	O
ml_month	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
is_range	int
&&	O
!	O
is_ext_range	int
&&	O
!	O
is_special_range	int
)	O
{	O
if	O
(	O
is_fiscal_year	int
)	O
is_ext_year	int
=	O
TRUE	O
;	O
else	O
{	O
j	int
=	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_month	int
;	O
k	int
=	O
month_list	*(struct(int,int))
[	O
1	int
]	O
.	O
ml_month	int
;	O
i	int
=	O
0	int
;	O
while	O
(	O
month_list	*(struct(int,int))
[	O
i	int
]	O
.	O
ml_month	int
)	O
month_list	*(struct(int,int))
[	O
i	int
++	O
]	O
.	O
ml_month	int
=	O
0	int
;	O
if	O
(	O
!	O
j	int
&&	O
!	O
k	int
)	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_month	int
=	O
act_month	int
;	O
else	O
{	O
if	O
(	O
!	O
j	int
)	O
j	int
=	O
MONTH_MIN	int
;	O
if	O
(	O
!	O
k	int
)	O
k	int
=	O
MONTH_MAX	int
;	O
i	int
=	O
0	int
;	O
if	O
(	O
j	int
>	O
k	int
)	O
for	O
(	O
;	O
j	int
>=	O
k	int
;	O
i	int
++	O
,	O
j	int
--	O
)	O
month_list	*(struct(int,int))
[	O
i	int
]	O
.	O
ml_month	int
=	O
j	int
;	O
else	O
for	O
(	O
;	O
j	int
<=	O
k	int
;	O
i	int
++	O
,	O
j	int
++	O
)	O
month_list	*(struct(int,int))
[	O
i	int
]	O
.	O
ml_month	int
=	O
j	int
;	O
}	O
}	O
}	O
if	O
(	O
is_ext_range	int
&&	O
month_list	*(struct(int,int))
[	O
2	int
]	O
.	O
ml_month	int
)	O
month_list	*(struct(int,int))
[	O
1	int
]	O
.	O
ml_month	int
=	O
0	int
;	O
if	O
(	O
!	O
month_list	*(struct(int,int))
[	O
1	int
]	O
.	O
ml_month	int
&&	O
(	O
is_ext_list	int
||	O
is_ext_range	int
||	O
is_special_range	int
||	O
is_ext_year	int
)	O
)	O
{	O
is_ext_list	int
=	O
is_ext_range	int
=	O
is_special_range	int
=	O
is_ext_year	int
=	O
FALSE	O
;	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_month	int
=	O
act_month	int
;	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_year	int
=	O
act_year	int
;	O
}	O
}	O
}	O
static	O
void	O
eliminate_invalid_data	()->(void)
(	O
)	O
{	O
register	O
int	O
i	int
;	O
register	O
int	O
len	int
;	O
if	O
(	O
!	O
month	int
&&	O
!	O
year	int
)	O
{	O
month	int
=	O
act_month	int
;	O
year	int
=	O
act_year	int
;	O
}	O
else	O
if	O
(	O
year	int
<	O
YEAR_MIN	int
||	O
year	int
>	O
YEAR_MAX	int
)	O
{	O
if	O
(	O
month	int
&&	O
year	int
)	O
month	int
=	O
act_month	int
;	O
year	int
=	O
act_year	int
;	O
}	O
if	O
(	O
year_flag	int
&&	O
month	int
)	O
month	int
=	O
0	int
;	O
if	O
(	O
month	int
&&	O
!	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_month	int
)	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_month	int
=	O
month	int
;	O
if	O
(	O
year	int
&&	O
!	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_year	int
)	O
(	O
*	O
month_list	*(struct(int,int))
)	O
.	O
ml_year	int
=	O
year	int
;	O
if	O
(	O
is_3month_mode	int
||	O
is_3month_mode2	int
)	O
{	O
if	O
(	O
special_calsheet_flag	int
)	O
{	O
if	O
(	O
cal_special_flag	int
)	O
{	O
out_rows	int
=	O
JI3_OUT_ROWS	O
;	O
out_cols	int
=	O
JI3_OUT_COLS	O
;	O
}	O
else	O
if	O
(	O
cal_both_dates_flag	int
)	O
{	O
out_rows	int
=	O
BI3_OUT_ROWS	O
;	O
out_cols	int
=	O
BI3_OUT_COLS	O
;	O
}	O
else	O
{	O
out_rows	int
=	O
SI3_OUT_ROWS	O
;	O
out_cols	int
=	O
SI3_OUT_COLS	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
cal_special_flag	int
)	O
{	O
out_rows	int
=	O
J3_OUT_ROWS	O
;	O
out_cols	int
=	O
J3_OUT_COLS	O
;	O
}	O
else	O
if	O
(	O
cal_both_dates_flag	int
)	O
{	O
out_rows	int
=	O
B3_OUT_ROWS	int
;	O
out_cols	int
=	O
B3_OUT_COLS	int
;	O
}	O
else	O
{	O
out_rows	int
=	O
S3_OUT_ROWS	int
;	O
out_cols	int
=	O
S3_OUT_COLS	int
;	O
}	O
}	O
}	O
else	O
{	O
switch	O
(	O
out_rows	int
)	O
{	O
case	O
MONTH_MIN	int
:	O
out_cols	int
=	O
MONTH_MAX	int
;	O
break	O
;	O
case	O
2	int
:	O
out_cols	int
=	O
6	int
;	O
break	O
;	O
case	O
3	int
:	O
out_cols	int
=	O
S_OUT_COLS	int
;	O
break	O
;	O
case	O
4	int
:	O
out_cols	int
=	O
J_OUT_COLS	int
;	O
break	O
;	O
case	O
6	int
:	O
out_cols	int
=	O
2	int
;	O
break	O
;	O
case	O
MONTH_MAX	int
:	O
out_cols	int
=	O
MONTH_MIN	int
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
year_flag	int
)	O
{	O
if	O
(	O
special_calsheet_flag	int
)	O
{	O
if	O
(	O
cal_special_flag	int
)	O
{	O
out_rows	int
=	O
JI_OUT_ROWS	int
;	O
out_cols	int
=	O
JI_OUT_COLS	int
;	O
}	O
else	O
if	O
(	O
cal_both_dates_flag	int
)	O
{	O
out_rows	int
=	O
BI_OUT_ROWS	O
;	O
out_cols	int
=	O
BI_OUT_COLS	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
cal_special_flag	int
)	O
{	O
out_rows	int
=	O
J_OUT_ROWS	int
;	O
out_cols	int
=	O
J_OUT_COLS	int
;	O
}	O
else	O
if	O
(	O
cal_both_dates_flag	int
)	O
{	O
out_rows	int
=	O
B_OUT_ROWS	int
;	O
out_cols	int
=	O
B_OUT_COLS	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
cal_special_flag	int
)	O
format_len	int
=	O
FORMAT_LEN_MIN	int
+	O
1	int
;	O
else	O
if	O
(	O
cal_both_dates_flag	int
)	O
format_len	int
=	O
FORMAT_LEN_MIN	int
+	O
5	int
;	O
else	O
format_len	int
=	O
FORMAT_LEN_MIN	int
;	O
len_dayname_max	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
DAY_MIN	int
;	O
i	int
<=	O
DAY_MAX	int
;	O
i	int
++	O
)	O
{	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
day_name	(int)->(*(char))
(	O
i	int
)	O
)	O
;	O
if	O
(	O
len	int
>	O
len_dayname_max	int
)	O
len_dayname_max	int
=	O
len	int
;	O
}	O
len_monthname_max	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
MONTH_MIN	int
;	O
i	int
<=	O
MONTH_MAX	int
;	O
i	int
++	O
)	O
{	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
month_name	(int)->(*(char))
(	O
i	int
)	O
)	O
;	O
if	O
(	O
len	int
>	O
len_monthname_max	int
)	O
len_monthname_max	int
=	O
len	int
;	O
}	O
len_suffix_max	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
DAY_MIN	int
;	O
i	int
<=	O
4	int
;	O
i	int
++	O
)	O
{	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
day_suffix	(int)->(*(char))
(	O
i	int
)	O
)	O
;	O
if	O
(	O
len	int
>	O
len_suffix_max	int
)	O
len_suffix_max	int
=	O
len	int
;	O
}	O
}	O
static	O
void	O
pseudo_blank_conversion	(*(*(char)))->(void)
(	O
text	*(*(char))
)	O
char	O
*	O
*	O
text	*(*(char))
;	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
*	O
text	*(*(char))
,	O
PSEUDO_BLANK	char
)	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
auto	O
char	O
*	O
ptr_char	*(char)
;	O
auto	O
char	O
*	O
ptr2_char	*(char)
;	O
ptr_char	*(char)
=	O
ptr2_char	*(char)
=	O
*	O
text	*(*(char))
;	O
while	O
(	O
*	O
ptr2_char	*(char)
)	O
{	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
PSEUDO_BLANK	char
)	O
{	O
ptr2_char	*(char)
++	O
;	O
*	O
ptr_char	*(char)
++	O
=	O
' '	O
;	O
}	O
else	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
QUOTE_CHAR	char
)	O
{	O
ptr2_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr2_char	*(char)
==	O
PSEUDO_BLANK	char
)	O
*	O
ptr_char	*(char)
++	O
=	O
*	O
ptr2_char	*(char)
++	O
;	O
else	O
*	O
ptr_char	*(char)
++	O
=	O
QUOTE_CHAR	char
;	O
}	O
else	O
*	O
ptr_char	*(char)
++	O
=	O
*	O
ptr2_char	*(char)
++	O
;	O
}	O
*	O
ptr_char	*(char)
=	O
'\0'	O
;	O
}	O
}	O
static	O
int	O
further_check	(*(*(char)))->(int)
(	O
option	*(*(char))
)	O
char	O
*	O
*	O
option	*(*(char))
;	O
{	O
register	O
int	O
opt_error	int
=	O
0	int
;	O
(	O
*	O
option	*(*(char))
)	O
++	O
;	O
if	O
(	O
*	O
*	O
option	*(*(char))
)	O
{	O
rc_week_year_flag	int
=	O
(	O
Bool	int
)	O
(	O
tolower	(int)->(int)
(	O
*	O
*	O
option	*(*(char))
)	O
==	O
'w'	O
)	O
;	O
rc_forwards_flag	int
=	O
(	O
Bool	int
)	O
(	O
*	O
*	O
option	*(*(char))
==	O
*	O
ASC_LIT	*(char)
)	O
;	O
rc_backwards_flag	int
=	O
(	O
Bool	int
)	O
(	O
*	O
*	O
option	*(*(char))
==	O
*	O
DES_LIT	*(char)
)	O
;	O
(	O
*	O
option	*(*(char))
)	O
++	O
;	O
if	O
(	O
*	O
*	O
option	*(*(char))
||	O
(	O
!	O
rc_week_year_flag	int
&&	O
!	O
rc_forwards_flag	int
&&	O
!	O
rc_backwards_flag	int
)	O
)	O
opt_error	int
=	O
5	int
;	O
}	O
return	O
(	O
opt_error	int
)	O
;	O
}	O
