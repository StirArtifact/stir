static	O
void	O
dump_headers	(*(struct),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(void)
(	O
mu_stream_t	*(struct)
out	*(struct)
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
mu_stream_t	*(struct)
stream	*(struct)
=	O
NULL	O
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_header_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
env	*(struct)
->	O
header	*(struct)
,	O
&	O
stream	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
"mu_header_get_streamref: %s"	*(char)
,	O
mu_stream_strerror	(*(struct),int)->(*(char))
(	O
stream	*(struct)
,	O
rc	int
)	O
)	O
;	O
return	O
;	O
}	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
out	*(struct)
,	O
stream	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
stream	*(struct)
)	O
;	O
}	O
static	O
int	O
check_headers	(*(struct),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
mu_stream_t	*(struct)
input	*(char)
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
char	O
*	O
p	*(char)
;	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
input	*(char)
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
switch	O
(	O
parse_headers	(*(struct),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
input	*(char)
,	O
env	*(struct)
)	O
)	O
{	O
case	O
parse_headers_ok	int
:	O
return	O
0	int
;	O
case	O
parse_headers_fatal	int
:	O
return	O
-	O
1	int
;	O
case	O
parse_headers_error	int
:	O
break	O
;	O
}	O
p	*(char)
=	O
ml_readline	(*(char))->(*(char))
(	O
_	O
(	O
"Edit again?"	*(char)
)	O
)	O
;	O
return	O
mu_true_answer_p	(*(char))->(int)
(	O
p	*(char)
)	O
;	O
}	O
static	O
void	O
escape_continue	()->(void)
(	O
void	O
)	O
{	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"(continue)\n"	*(char)
)	O
)	O
;	O
}	O
int	O
escape_check_args	(int,*(*(char)),int,int)->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
minargs	int
,	O
int	O
maxargs	int
)	O
{	O
char	O
*	O
escape	*(char)
=	O
"~"	*(char)
;	O
if	O
(	O
argc	int
<	O
minargs	int
)	O
{	O
minargs	int
--	O
;	O
mailvar_get	(*(void),*(char),enum(int,int,int,int),int)->(int)
(	O
&	O
escape	*(char)
,	O
mailvar_name_escape	*(char)
,	O
mailvar_type_string	int
,	O
0	int
)	O
;	O
mu_error	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"%c%s requires at least %d argument"	*(char)
,	O
"%c%s requires at least %d arguments"	*(char)
,	O
minargs	int
)	O
,	O
escape	*(char)
[	O
0	int
]	O
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
minargs	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
maxargs	int
>	O
1	int
&&	O
argc	int
>	O
maxargs	int
)	O
{	O
maxargs	int
--	O
;	O
mailvar_get	(*(void),*(char),enum(int,int,int,int),int)->(int)
(	O
&	O
escape	*(char)
,	O
mailvar_name_escape	*(char)
,	O
mailvar_type_string	int
,	O
0	int
)	O
;	O
mu_error	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"%c%s accepts at most %d argument"	*(char)
,	O
"%c%s accepts at most %d arguments"	*(char)
,	O
maxargs	int
)	O
,	O
escape	*(char)
[	O
0	int
]	O
,	O
argv	*(*(char))
[	O
0	int
]	O
,	O
maxargs	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
escape_shell	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
return	O
mail_execute	(int,*(char),int,*(*(char)))->(int)
(	O
1	int
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argc	int
-	O
1	int
,	O
argv	*(*(char))
+	O
1	int
)	O
;	O
}	O
int	O
escape_command	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
const	O
struct	O
mail_command_entry	struct(*(char),*(char),*(char),int,*((int,*(*(char)))->(int)),*((int,*(*(char)),int)->(*(*(char)))))
*	O
entry	*(struct(*(char),*(char),*(char),int,*((int,*(*`))->(int)),*((int,*(*`),int)->(*(*`)))))
;	O
int	O
status	int
;	O
if	O
(	O
escape_check_args	(int,*(*(char)),int,int)->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
[	O
0	int
]	O
==	O
'#'	O
)	O
return	O
0	int
;	O
entry	*(struct(*(char),*(char),*(char),int,*((int,*(*`))->(int)),*((int,*(*`),int)->(*(*`)))))
=	O
mail_find_command	(*(char))->(*(struct(*(char),*(char),*(char),int,*((int,*`)->(int)),*((int,*`,int)->(*`)))))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
entry	*(struct(*(char),*(char),*(char),int,*((int,*(*`))->(int)),*((int,*(*`),int)->(*(*`)))))
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Unknown command: %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
entry	*(struct(*(char),*(char),*(char),int,*((int,*(*`))->(int)),*((int,*(*`),int)->(*(*`)))))
->	O
flags	int
&	O
(	O
EF_FLOW	int
|	O
EF_SEND	int
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Command not allowed in an escape sequence\n"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
status	int
=	O
(	O
*	O
entry	*(struct(*(char),*(char),*(char),int,*((int,*(*`))->(int)),*((int,*(*`),int)->(*(*`)))))
->	O
func	*(char)
)	O
(	O
argc	int
-	O
1	int
,	O
argv	*(*(char))
+	O
1	int
)	O
;	O
return	O
status	int
;	O
}	O
int	O
escape_help	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
MU_ARG_UNUSED	O
)	O
{	O
int	O
status	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
status	int
=	O
mail_escape_help	(*(char))->(int)
(	O
NULL	O
)	O
;	O
else	O
while	O
(	O
--	O
argc	int
)	O
status	int
|=	O
mail_escape_help	(*(char))->(int)
(	O
*	O
++	O
argv	*(*(char))
)	O
;	O
escape_continue	()->(void)
(	O
)	O
;	O
return	O
status	int
;	O
}	O
int	O
escape_sign	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
char	O
*	O
p	*(char)
;	O
if	O
(	O
mailvar_get	(*(void),*(char),enum(int,int,int,int),int)->(int)
(	O
&	O
p	*(char)
,	O
mu_isupper	O
(	O
argv	*(*(char))
[	O
0	int
]	O
[	O
0	int
]	O
)	O
?	O
mailvar_name_Sign	*(char)
:	O
mailvar_name_sign	*(char)
,	O
mailvar_type_string	int
,	O
1	int
)	O
==	O
0	int
)	O
{	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
"-- \n"	*(char)
)	O
;	O
if	O
(	O
mu_isupper	O
(	O
argv	*(*(char))
[	O
0	int
]	O
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
name	*(char)
=	O
util_fullpath	(*(char))->(*(char))
(	O
p	*(char)
)	O
;	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
signstr	*(struct)
;	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
signstr	*(struct)
,	O
name	*(char)
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Cannot open %s: %s"	*(char)
)	O
,	O
name	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
else	O
{	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"Reading %s\n"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
signstr	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
signstr	*(struct)
)	O
;	O
}	O
}	O
else	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
"%s\n"	*(char)
,	O
p	*(char)
)	O
;	O
escape_continue	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
escape_bcc	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
while	O
(	O
--	O
argc	int
)	O
compose_header_set	(*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))),*(char),*(char),int)->(int)
(	O
env	*(struct)
,	O
MU_HEADER_BCC	*(char)
,	O
*	O
++	O
argv	*(*(char))
,	O
COMPOSE_SINGLE_LINE	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_cc	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
while	O
(	O
--	O
argc	int
)	O
compose_header_set	(*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))),*(char),*(char),int)->(int)
(	O
env	*(struct)
,	O
MU_HEADER_CC	*(char)
,	O
*	O
++	O
argv	*(*(char))
,	O
COMPOSE_SINGLE_LINE	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
verbose_copy	(*(struct),*(struct),*(char),*(long))->(int)
(	O
mu_stream_t	*(struct)
dest	*(struct(*(char),int,int))
,	O
mu_stream_t	*(struct)
src	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
const	O
char	O
*	O
filename	*(char)
,	O
mu_off_t	long
*	O
psize	*(long)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
buf	*(char)
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
,	O
n	*(long)
;	O
size_t	long
lines	long
;	O
mu_off_t	long
total	long
;	O
total	long
=	O
lines	long
=	O
0	int
;	O
while	O
(	O
(	O
rc	int
=	O
mu_stream_getline	(*(struct),*(*(char)),*(long),*(long))->(int)
(	O
src	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
&	O
buf	*(char)
,	O
&	O
size	long
,	O
&	O
n	*(long)
)	O
)	O
==	O
0	int
&&	O
n	*(long)
>	O
0	int
)	O
{	O
lines	long
++	O
;	O
rc	int
=	O
mu_stream_write	(*(struct),*(void),long,*(long))->(int)
(	O
dest	*(struct(*(char),int,int))
,	O
buf	*(char)
,	O
n	*(long)
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
total	long
+=	O
n	*(long)
;	O
}	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"error copying data: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_printf	(*(char))->(int)
(	O
"\"%s\" %lu/%lu\n"	*(char)
,	O
filename	*(char)
,	O
(	O
unsigned	O
long	O
)	O
lines	long
,	O
(	O
unsigned	O
long	O
)	O
total	long
)	O
;	O
if	O
(	O
psize	*(long)
)	O
*	O
psize	*(long)
=	O
total	long
;	O
return	O
rc	int
;	O
}	O
int	O
escape_deadletter	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	*(*(char))
MU_ARG_UNUSED	O
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
const	O
char	O
*	O
name	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"DEAD"	*(char)
)	O
;	O
mu_stream_t	*(struct)
str	*(struct)
;	O
int	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
str	*(struct)
,	O
name	*(char)
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Cannot open file %s: %s"	*(char)
)	O
,	O
name	*(char)
,	O
strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
verbose_copy	(*(struct),*(struct),*(char),*(long))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
str	*(struct)
,	O
name	*(char)
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
str	*(struct)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
run_editor	(*(char),*(char))->(int)
(	O
char	O
*	O
ed	*(char)
,	O
char	O
*	O
arg	*(char)
)	O
{	O
char	O
*	O
argv	*(*(char))
[	O
3	int
]	O
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
ed	*(char)
;	O
argv	*(*(char))
[	O
1	int
]	O
=	O
arg	*(char)
;	O
argv	*(*(char))
[	O
2	int
]	O
=	O
NULL	O
;	O
return	O
mail_execute	(int,*(char),int,*(*(char)))->(int)
(	O
1	int
,	O
ed	*(char)
,	O
2	int
,	O
argv	*(*(char))
)	O
;	O
}	O
static	O
int	O
escape_run_editor	(*(char),int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
char	O
*	O
ed	*(char)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
char	O
*	O
filename	*(char)
;	O
int	O
fd	int
;	O
mu_stream_t	*(struct)
tempstream	*(struct)
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_tempfile	(*(struct(*(char),*(char))),int,*(int),*(*(char)))->(int)
(	O
NULL	O
,	O
0	int
,	O
&	O
fd	int
,	O
&	O
filename	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_tempfile"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_fd_stream_create	(*(*(struct)),*(char),int,int)->(int)
(	O
&	O
tempstream	*(struct)
,	O
filename	*(char)
,	O
fd	int
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_fd_stream_create"	*(char)
,	O
filename	*(char)
,	O
rc	int
)	O
;	O
unlink	(*(char))->(int)
(	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
rc	int
;	O
}	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
mailvar_is_true	(*(char))->(int)
(	O
mailvar_name_editheaders	*(char)
)	O
)	O
{	O
dump_headers	(*(struct),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(void)
(	O
tempstream	*(struct)
,	O
env	*(struct)
)	O
;	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
tempstream	*(struct)
,	O
env	*(struct)
->	O
compstr	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
do	O
{	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
tempstream	*(struct)
)	O
;	O
run_editor	(*(char),*(char))->(int)
(	O
ed	*(char)
,	O
filename	*(char)
)	O
;	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
tempstream	*(struct)
,	O
filename	*(char)
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_file_stream_create"	*(char)
,	O
filename	*(char)
,	O
rc	int
)	O
;	O
unlink	(*(char))->(int)
(	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
while	O
(	O
check_headers	(*(struct),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
tempstream	*(struct)
,	O
env	*(struct)
)	O
)	O
;	O
}	O
else	O
{	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
tempstream	*(struct)
,	O
env	*(struct)
->	O
compstr	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
tempstream	*(struct)
)	O
;	O
run_editor	(*(char),*(char))->(int)
(	O
ed	*(char)
,	O
filename	*(char)
)	O
;	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
tempstream	*(struct)
,	O
filename	*(char)
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_file_stream_create"	*(char)
,	O
filename	*(char)
,	O
rc	int
)	O
;	O
unlink	(*(char))->(int)
(	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_off_t	long
size	long
;	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
tempstream	*(struct)
,	O
0	int
,	O
&	O
size	long
)	O
;	O
mu_stream_truncate	(*(struct),long)->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
size	long
)	O
;	O
}	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
tempstream	*(struct)
)	O
;	O
unlink	(*(char))->(int)
(	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
0	int
,	O
MU_SEEK_END	int
,	O
NULL	O
)	O
;	O
escape_continue	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_editor	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
return	O
escape_run_editor	(*(char),int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
getenv	(*(char))->(*(char))
(	O
"EDITOR"	*(char)
)	O
,	O
argc	int
,	O
argv	*(*(char))
,	O
env	*(struct)
)	O
;	O
}	O
int	O
escape_visual	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
return	O
escape_run_editor	(*(char),int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
getenv	(*(char))->(*(char))
(	O
"VISUAL"	*(char)
)	O
,	O
argc	int
,	O
argv	*(*(char))
,	O
env	*(struct)
)	O
;	O
}	O
int	O
escape_print	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
MU_ARG_UNUSED	O
)	O
{	O
return	O
mail_print	(int,*(*(char)))->(int)
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
}	O
void	O
reread_header	(*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))),*(char),*(char))->(void)
(	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
,	O
char	O
*	O
hdr	*(struct)
,	O
char	O
*	O
prompt	*(char)
)	O
{	O
char	O
*	O
p	*(char)
;	O
p	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
compose_header_get	(*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))),*(char),*(char))->(*(char))
(	O
env	*(struct)
,	O
hdr	*(struct)
,	O
""	*(char)
)	O
)	O
;	O
ml_reread	(*(char),*(*(char)))->(int)
(	O
prompt	*(char)
,	O
&	O
p	*(char)
)	O
;	O
compose_header_set	(*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))),*(char),*(char),int)->(int)
(	O
env	*(struct)
,	O
hdr	*(struct)
,	O
p	*(char)
,	O
COMPOSE_REPLACE	int
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
}	O
int	O
escape_headers	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
reread_header	(*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))),*(char),*(char))->(void)
(	O
env	*(struct)
,	O
MU_HEADER_TO	*(char)
,	O
"To: "	*(char)
)	O
;	O
reread_header	(*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))),*(char),*(char))->(void)
(	O
env	*(struct)
,	O
MU_HEADER_CC	*(char)
,	O
"Cc: "	*(char)
)	O
;	O
reread_header	(*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))),*(char),*(char))->(void)
(	O
env	*(struct)
,	O
MU_HEADER_BCC	*(char)
,	O
"Bcc: "	*(char)
)	O
;	O
reread_header	(*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))),*(char),*(char))->(void)
(	O
env	*(struct)
,	O
MU_HEADER_SUBJECT	*(char)
,	O
"Subject: "	*(char)
)	O
;	O
escape_continue	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_insert	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
if	O
(	O
escape_check_args	(int,*(*(char)),int,int)->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
mailvar_variable_format	(*(struct),*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))),*(char))->(void)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
mailvar_find_variable	(*(char),int)->(*(struct(*(char),enum(int,int,int,int),int,union(*(char),int,int))))
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
0	int
)	O
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
quote_closure	struct(*(struct),int)
{	O
mu_stream_t	*(struct)
str	*(struct)
;	O
int	O
islower	int
;	O
}	O
;	O
int	O
quote0	(*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(void))->(int)
(	O
msgset_t	struct
*	O
mspec	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
,	O
mu_message_t	*(struct)
mesg	*(struct)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
quote_closure	struct(*(struct),int)
*	O
clos	*(void)
=	O
data	*(void)
;	O
int	O
rc	int
;	O
mu_stream_t	*(struct)
stream	*(struct)
;	O
char	O
*	O
prefix	array(*(char))
=	O
"\t"	*(char)
;	O
mu_stream_t	*(struct)
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
;	O
char	O
*	O
argv	*(*(char))
[	O
3	int
]	O
;	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"Interpolating: %lu\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
mspec	*(struct(*(struct(*(struct`),int,*(long))),int,*(long)))
->	O
msg_part	*(long)
[	O
0	int
]	O
)	O
;	O
mailvar_get	(*(void),*(char),enum(int,int,int,int),int)->(int)
(	O
&	O
prefix	array(*(char))
,	O
mailvar_name_indentprefix	*(char)
,	O
mailvar_type_string	int
,	O
0	int
)	O
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
"INLINE-COMMENT"	*(char)
;	O
argv	*(*(char))
[	O
1	int
]	O
=	O
prefix	array(*(char))
;	O
argv	*(*(char))
[	O
2	int
]	O
=	O
NULL	O
;	O
rc	int
=	O
mu_filter_create_args	(*(*(struct)),*(struct),*(char),int,*(*(char)),int,int)->(int)
(	O
&	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
,	O
clos	*(void)
->	O
str	*(struct)
,	O
"INLINE-COMMENT"	*(char)
,	O
2	int
,	O
(	O
const	O
char	O
*	O
*	O
)	O
argv	*(*(char))
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_WRITE	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_filter_create_args"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
clos	*(void)
->	O
islower	int
)	O
{	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
mu_body_t	*(struct)
body	*(struct)
;	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
mesg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
;	O
mu_header_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
hdr	*(struct)
,	O
&	O
itr	*(struct)
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
,	O
*	O
value	*(void)
;	O
if	O
(	O
mu_iterator_current_kv	(*(struct),*(*(void)),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
name	*(char)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
value	*(void)
)	O
==	O
0	int
&&	O
mail_header_is_visible	(*(char))->(int)
(	O
name	*(char)
)	O
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
,	O
"%s: %s\n"	*(char)
,	O
name	*(char)
,	O
value	*(void)
)	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
mu_stream_write	(*(struct),*(void),long,*(long))->(int)
(	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
,	O
"\n"	*(char)
,	O
1	int
,	O
NULL	O
)	O
;	O
mu_message_get_body	(*(struct),*(*(struct)))->(int)
(	O
mesg	*(struct)
,	O
&	O
body	*(struct)
)	O
;	O
rc	int
=	O
mu_body_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
body	*(struct)
,	O
&	O
stream	*(struct)
)	O
;	O
}	O
else	O
rc	int
=	O
mu_message_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
mesg	*(struct)
,	O
&	O
stream	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"get_streamref error: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
,	O
stream	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
stream	*(struct)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
flt	*((*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))),*(void))->(int))
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_quote	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
struct	O
quote_closure	struct(*(struct),int)
clos	*(void)
;	O
clos	*(void)
.	O
str	*(struct)
=	O
env	*(struct)
->	O
compstr	*(struct)
;	O
clos	*(void)
.	O
islower	int
=	O
mu_islower	O
(	O
argv	*(*(char))
[	O
0	int
]	O
[	O
0	int
]	O
)	O
;	O
util_foreach_msg	(int,*(*(char)),int,*((*(struct(*`,int,*`)),*(struct),*(void))->(int)),*(void))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
MSG_NODELETED	int
|	O
MSG_SILENT	int
,	O
quote0	(*(struct(*(struct(*`,int,*`)),int,*(long))),*(struct),*(void))->(int)
,	O
&	O
clos	*(void)
)	O
;	O
escape_continue	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_type_input	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
mu_printf	(*(char))->(int)
(	O
_	O
(	O
"Message contains:\n"	*(char)
)	O
)	O
;	O
dump_headers	(*(struct),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(void)
(	O
mu_strout	*(struct)
,	O
env	*(struct)
)	O
;	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
mu_strout	*(struct)
,	O
env	*(struct)
->	O
compstr	*(struct)
,	O
0	int
,	O
NULL	O
)	O
;	O
escape_continue	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_read	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
MU_ARG_UNUSED	O
)	O
{	O
char	O
*	O
filename	*(char)
;	O
mu_stream_t	*(struct)
instr	*(struct)
;	O
int	O
rc	int
;	O
if	O
(	O
escape_check_args	(int,*(*(char)),int,int)->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
filename	*(char)
=	O
util_fullpath	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
instr	*(struct)
,	O
filename	*(char)
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Cannot open %s: %s"	*(char)
)	O
,	O
filename	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
verbose_copy	(*(struct),*(struct),*(char),*(long))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
instr	*(struct)
,	O
filename	*(char)
,	O
NULL	O
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
instr	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_subj	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
char	O
*	O
buf	*(char)
;	O
if	O
(	O
escape_check_args	(int,*(*(char)),int,int)->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
mu_argcv_string	(int,*(*(char)),*(*(char)))->(int)
(	O
argc	int
-	O
1	int
,	O
argv	*(*(char))
+	O
1	int
,	O
&	O
buf	*(char)
)	O
;	O
compose_header_set	(*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))),*(char),*(char),int)->(int)
(	O
env	*(struct)
,	O
MU_HEADER_SUBJECT	*(char)
,	O
buf	*(char)
,	O
COMPOSE_REPLACE	int
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_to	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
while	O
(	O
--	O
argc	int
)	O
compose_header_set	(*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))),*(char),*(char),int)->(int)
(	O
env	*(struct)
,	O
MU_HEADER_TO	*(char)
,	O
*	O
++	O
argv	*(*(char))
,	O
COMPOSE_SINGLE_LINE	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_write	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
char	O
*	O
filename	*(char)
;	O
mu_stream_t	*(struct)
wstr	*(struct)
;	O
int	O
rc	int
;	O
mu_off_t	long
size	long
;	O
if	O
(	O
escape_check_args	(int,*(*(char)),int,int)->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
filename	*(char)
=	O
util_fullpath	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
mu_file_stream_create	(*(*(struct)),*(char),int)->(int)
(	O
&	O
wstr	*(struct)
,	O
filename	*(char)
,	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Cannot open %s for writing: %s"	*(char)
)	O
,	O
filename	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
verbose_copy	(*(struct),*(struct),*(char),*(long))->(int)
(	O
wstr	*(struct)
,	O
env	*(struct)
->	O
compstr	*(struct)
,	O
filename	*(char)
,	O
&	O
size	long
)	O
;	O
mu_stream_truncate	(*(struct),long)->(int)
(	O
wstr	*(struct)
,	O
size	long
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
wstr	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_pipe	(int,*(*(char)),*(struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
compose_env_t	struct(*(struct),*(struct),*(*(char)),int,int,*(struct),*(struct))
*	O
env	*(struct)
)	O
{	O
int	O
rc	int
,	O
status	int
;	O
int	O
p	*(char)
[	O
2	int
]	O
;	O
pid_t	int
pid	int
;	O
int	O
fd	int
;	O
mu_off_t	long
isize	long
,	O
osize	long
=	O
0	int
;	O
mu_stream_t	*(struct)
tstr	*(struct)
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
p	*(char)
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
"pipe: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
mu_tempfile	(*(struct(*(char),*(char))),int,*(int),*(*(char)))->(int)
(	O
NULL	O
,	O
0	int
,	O
&	O
fd	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
(	O
pid	int
=	O
fork	()->(int)
(	O
)	O
)	O
<	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
p	*(char)
[	O
0	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
p	*(char)
[	O
1	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
mu_error	(*(char))->(int)
(	O
"fork: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
0	int
)	O
;	O
dup	(int)->(int)
(	O
p	*(char)
[	O
0	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
p	*(char)
[	O
0	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
p	*(char)
[	O
1	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
1	int
)	O
;	O
dup	(int)->(int)
(	O
fd	int
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
execvp	(*(char),array(*(char)))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
argv	*(*(char))
+	O
1	int
)	O
;	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Cannot execute `%s': %s"	*(char)
)	O
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
_exit	(int)->(void)
(	O
127	int
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
p	*(char)
[	O
0	int
]	O
)	O
;	O
rc	int
=	O
mu_stdio_stream_create	(*(*(struct)),int,int)->(int)
(	O
&	O
tstr	*(struct)
,	O
p	*(char)
[	O
1	int
]	O
,	O
MU_STREAM_WRITE	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_stdio_stream_create"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
kill	(int,int)->(int)
(	O
pid	int
,	O
SIGKILL	int
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
return	O
rc	int
;	O
}	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
env	*(struct)
->	O
compstr	*(struct)
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
tstr	*(struct)
,	O
env	*(struct)
->	O
compstr	*(struct)
,	O
0	int
,	O
&	O
isize	long
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
tstr	*(struct)
)	O
;	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Child terminated abnormally: %d"	*(char)
)	O
,	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
;	O
else	O
{	O
struct	O
stat	*(int)
st	*(struct(long,long,long))
;	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
&	O
st	*(struct(long,long,long))
)	O
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Cannot stat output file: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
else	O
osize	long
=	O
st	*(struct(long,long,long))
.	O
st_size	long
;	O
}	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
mu_strout	*(struct)
,	O
"\"|%s\" in: %lu "	*(char)
,	O
argv	*(*(char))
[	O
1	int
]	O
,	O
(	O
unsigned	O
long	O
)	O
isize	long
)	O
;	O
if	O
(	O
osize	long
==	O
0	int
)	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
mu_strout	*(struct)
,	O
_	O
(	O
"no lines out\n"	*(char)
)	O
)	O
;	O
else	O
{	O
mu_stream_t	*(struct)
str	*(struct)
;	O
mu_stream_printf	(*(struct),*(char))->(int)
(	O
mu_strout	*(struct)
,	O
"out: %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
osize	long
)	O
;	O
rc	int
=	O
mu_fd_stream_create	(*(*(struct)),*(char),int,int)->(int)
(	O
&	O
str	*(struct)
,	O
NULL	O
,	O
fd	int
,	O
MU_STREAM_RDWR	O
|	O
MU_STREAM_SEEK	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"Cannot open composition stream: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
}	O
else	O
{	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
env	*(struct)
->	O
compstr	*(struct)
)	O
;	O
env	*(struct)
->	O
compstr	*(struct)
=	O
str	*(struct)
;	O
}	O
}	O
return	O
0	int
;	O
}	O
