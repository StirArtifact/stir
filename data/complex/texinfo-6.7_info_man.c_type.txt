static	O
char	O
const	O
*	O
const	O
exec_extensions	array(*(char))
[	O
]	O
=	O
{	O
""	*(char)
,	O
NULL	O
}	O
;	O
static	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
xrefs_of_manpage	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(*(*(struct(*(char),*(char),*(char),int,int,long,int))))
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
static	O
char	O
*	O
read_from_fd	(int)->(*(char))
(	O
int	O
fd	int
)	O
;	O
static	O
char	O
*	O
get_manpage_contents	(*(char))->(*(char))
(	O
char	O
*	O
pagename	*(char)
)	O
;	O
static	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
*	O
manpage_nodes	*(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
=	O
0	int
;	O
size_t	long
manpage_node_index	long
=	O
0	int
;	O
size_t	long
manpage_node_slots	long
=	O
0	int
;	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
get_manpage_node	(*(char))->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
char	O
*	O
pagename	*(char)
)	O
{	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
0	int
,	O
*	O
*	O
n	long
,	O
*	O
node2	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
0	int
;	O
char	O
*	O
page	*(char)
;	O
if	O
(	O
manpage_node_index	long
>	O
0	int
)	O
for	O
(	O
n	long
=	O
manpage_nodes	*(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
;	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
*	O
n	long
)	O
;	O
n	long
++	O
)	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
,	O
pagename	*(char)
)	O
)	O
break	O
;	O
if	O
(	O
!	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
info_create_node	()->(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
(	O
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
fullpath	*(char)
=	O
MANPAGE_FILE_BUFFER_NAME	*(char)
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
pagename	*(char)
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
flags	int
|=	O
N_HasTagsTable	int
|	O
N_IsManPage	int
;	O
add_pointer_to_array	O
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
,	O
manpage_node_index	long
,	O
manpage_nodes	*(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))
,	O
manpage_node_slots	long
,	O
100	int
)	O
;	O
}	O
if	O
(	O
!	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
)	O
{	O
int	O
plen	*(long)
;	O
page	*(char)
=	O
get_manpage_contents	(*(char))->(*(char))
(	O
pagename	*(char)
)	O
;	O
if	O
(	O
!	O
page	*(char)
)	O
return	O
0	int
;	O
plen	*(long)
=	O
strlen	(*(char))->(long)
(	O
page	*(char)
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
=	O
page	*(char)
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
=	O
plen	*(long)
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
body_start	long
=	O
0	int
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
references	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
xrefs_of_manpage	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(*(*(struct(*(char),*(char),*(char),int,int,long,int))))
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
;	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
up	*(char)
=	O
"(dir)"	*(char)
;	O
}	O
node2	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
)	O
)	O
;	O
*	O
node2	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
=	O
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
return	O
node2	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
;	O
}	O
static	O
char	O
*	O
executable_file_in_path	(*(char),*(char))->(*(char))
(	O
char	O
*	O
filename	*(char)
,	O
char	O
*	O
path	*(char)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
char	O
*	O
temp_dirname	*(char)
;	O
int	O
statable	int
,	O
dirname_index	int
;	O
dirname_index	int
=	O
0	int
;	O
while	O
(	O
(	O
temp_dirname	*(char)
=	O
extract_colon_unit	(*(char),*(int))->(*(char))
(	O
path	*(char)
,	O
&	O
dirname_index	int
)	O
)	O
)	O
{	O
char	O
*	O
temp	*(char)
;	O
char	O
*	O
temp_end	*(char)
;	O
int	O
i	int
;	O
if	O
(	O
*	O
temp_dirname	*(char)
==	O
'~'	O
)	O
{	O
char	O
*	O
expanded_dirname	*(char)
;	O
expanded_dirname	*(char)
=	O
tilde_expand_word	(*(char))->(*(char))
(	O
temp_dirname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
temp_dirname	*(char)
)	O
;	O
temp_dirname	*(char)
=	O
expanded_dirname	*(char)
;	O
}	O
temp	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
34	int
+	O
strlen	(*(char))->(long)
(	O
temp_dirname	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
temp	*(char)
,	O
temp_dirname	*(char)
)	O
;	O
if	O
(	O
!	O
IS_SLASH	O
(	O
temp	*(char)
[	O
(	O
strlen	(*(char))->(long)
(	O
temp	*(char)
)	O
)	O
-	O
1	int
]	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
temp	*(char)
,	O
"/"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
temp	*(char)
,	O
filename	*(char)
)	O
;	O
temp_end	*(char)
=	O
temp	*(char)
+	O
strlen	(*(char))->(long)
(	O
temp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
temp_dirname	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
exec_extensions	array(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
exec_extensions	array(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
temp_end	*(char)
,	O
exec_extensions	array(*(char))
[	O
i	int
]	O
)	O
;	O
statable	int
=	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
temp	*(char)
,	O
&	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
==	O
0	int
)	O
;	O
if	O
(	O
(	O
statable	int
)	O
&&	O
(	O
S_ISREG	O
(	O
finfo	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
&&	O
(	O
access	(*(char),int)->(int)
(	O
temp	*(char)
,	O
X_OK	int
)	O
==	O
0	int
)	O
)	O
return	O
temp	*(char)
;	O
}	O
free	(*(void))->(void)
(	O
temp	*(char)
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
find_man_formatter	()->(*(char))
(	O
void	O
)	O
{	O
char	O
*	O
man_command	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"INFO_MAN_COMMAND"	*(char)
)	O
;	O
return	O
man_command	*(char)
?	O
man_command	*(char)
:	O
executable_file_in_path	(*(char),*(char))->(*(char))
(	O
"man"	*(char)
,	O
getenv	(*(char))->(*(char))
(	O
"PATH"	*(char)
)	O
)	O
;	O
}	O
static	O
char	O
*	O
manpage_pagename	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
manpage_section	*(char)
=	O
NULL	O
;	O
static	O
void	O
get_page_and_section	(*(char))->(void)
(	O
char	O
*	O
pagename	*(char)
)	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
manpage_pagename	*(char)
)	O
free	(*(void))->(void)
(	O
manpage_pagename	*(char)
)	O
;	O
if	O
(	O
manpage_section	*(char)
)	O
free	(*(void))->(void)
(	O
manpage_section	*(char)
)	O
;	O
manpage_pagename	*(char)
=	O
NULL	O
;	O
manpage_section	*(char)
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
pagename	*(char)
[	O
i	int
]	O
!=	O
'\0'	O
&&	O
pagename	*(char)
[	O
i	int
]	O
!=	O
'('	O
;	O
i	int
++	O
)	O
;	O
manpage_pagename	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
1	int
+	O
i	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
manpage_pagename	*(char)
,	O
pagename	*(char)
,	O
i	int
)	O
;	O
manpage_pagename	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
pagename	*(char)
[	O
i	int
]	O
==	O
'('	O
)	O
{	O
int	O
start	int
;	O
start	int
=	O
i	int
+	O
1	int
;	O
for	O
(	O
i	int
=	O
start	int
;	O
pagename	*(char)
[	O
i	int
]	O
!=	O
'\0'	O
&&	O
pagename	*(char)
[	O
i	int
]	O
!=	O
')'	O
;	O
i	int
++	O
)	O
;	O
manpage_section	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
1	int
+	O
(	O
i	int
-	O
start	int
)	O
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
manpage_section	*(char)
,	O
pagename	*(char)
+	O
start	int
,	O
(	O
i	int
-	O
start	int
)	O
)	O
;	O
manpage_section	*(char)
[	O
i	int
-	O
start	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
void	O
clean_manpage	(*(char))->(void)
(	O
char	O
*	O
manpage	*(char)
)	O
{	O
mbi_iterator_t	struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char)))
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
manpage	*(char)
)	O
;	O
char	O
*	O
newpage	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
len	long
+	O
1	int
)	O
;	O
char	O
*	O
np	*(long)
=	O
newpage	*(char)
;	O
int	O
prev_len	int
=	O
0	int
;	O
for	O
(	O
mbi_init	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
,	O
manpage	*(char)
,	O
len	long
)	O
;	O
mbi_avail	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
;	O
mbi_advance	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
)	O
{	O
const	O
char	O
*	O
cur_ptr	*(char)
=	O
mbi_cur_ptr	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
;	O
size_t	long
cur_len	long
=	O
mb_len	O
(	O
mbi_cur	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
)	O
;	O
if	O
(	O
cur_len	long
==	O
1	int
)	O
{	O
if	O
(	O
*	O
cur_ptr	*(char)
==	O
'\b'	O
||	O
*	O
cur_ptr	*(char)
==	O
'\f'	O
)	O
{	O
if	O
(	O
np	*(long)
>=	O
newpage	*(char)
+	O
prev_len	int
)	O
np	*(long)
-=	O
prev_len	int
;	O
}	O
else	O
if	O
(	O
ansi_escape	(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))),*(long))->(int)
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
,	O
&	O
cur_len	long
)	O
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
np	*(long)
,	O
cur_ptr	*(char)
,	O
cur_len	long
)	O
;	O
np	*(long)
+=	O
cur_len	long
;	O
ITER_SETBYTES	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
,	O
cur_len	long
)	O
;	O
}	O
else	O
if	O
(	O
show_malformed_multibyte_p	int
||	O
mbi_cur	O
(	O
iter	*(struct(*(char),bool,struct(int,union(int,array(char))),bool,struct(*(char),long,bool,int,array(char))))
)	O
.	O
wc_valid	bool
)	O
*	O
np	*(long)
++	O
=	O
*	O
cur_ptr	*(char)
;	O
}	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
np	*(long)
,	O
cur_ptr	*(char)
,	O
cur_len	long
)	O
;	O
np	*(long)
+=	O
cur_len	long
;	O
}	O
prev_len	int
=	O
cur_len	long
;	O
}	O
*	O
np	*(long)
=	O
0	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
manpage	*(char)
,	O
newpage	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
newpage	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
get_manpage_from_formatter	(array(*(char)))->(*(char))
(	O
char	O
*	O
formatter_args	array(*(char))
[	O
]	O
)	O
;	O
static	O
char	O
*	O
get_manpage_contents	(*(char))->(*(char))
(	O
char	O
*	O
pagename	*(char)
)	O
{	O
static	O
char	O
*	O
formatter_args	array(*(char))
[	O
4	int
]	O
=	O
{	O
NULL	O
}	O
;	O
char	O
*	O
formatted_page	*(char)
;	O
if	O
(	O
formatter_args	array(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
formatter_args	array(*(char))
[	O
0	int
]	O
=	O
find_man_formatter	()->(*(char))
(	O
)	O
;	O
if	O
(	O
formatter_args	array(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
get_page_and_section	(*(char))->(void)
(	O
pagename	*(char)
)	O
;	O
if	O
(	O
manpage_section	*(char)
)	O
formatter_args	array(*(char))
[	O
1	int
]	O
=	O
manpage_section	*(char)
;	O
else	O
formatter_args	array(*(char))
[	O
1	int
]	O
=	O
"-a"	*(char)
;	O
formatter_args	array(*(char))
[	O
2	int
]	O
=	O
manpage_pagename	*(char)
;	O
formatter_args	array(*(char))
[	O
3	int
]	O
=	O
NULL	O
;	O
formatted_page	*(char)
=	O
get_manpage_from_formatter	(array(*(char)))->(*(char))
(	O
formatter_args	array(*(char))
)	O
;	O
if	O
(	O
!	O
formatted_page	*(char)
&&	O
manpage_section	*(char)
)	O
{	O
formatter_args	array(*(char))
[	O
1	int
]	O
=	O
"-a"	*(char)
;	O
formatted_page	*(char)
=	O
get_manpage_from_formatter	(array(*(char)))->(*(char))
(	O
formatter_args	array(*(char))
)	O
;	O
}	O
return	O
formatted_page	*(char)
;	O
}	O
static	O
char	O
*	O
get_manpage_from_formatter	(array(*(char)))->(*(char))
(	O
char	O
*	O
formatter_args	array(*(char))
[	O
]	O
)	O
{	O
char	O
*	O
formatted_page	*(char)
=	O
NULL	O
;	O
int	O
pipes	array(int)
[	O
2	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
formatter_status	int
=	O
0	int
;	O
pipe	(array(int))->(int)
(	O
pipes	array(int)
)	O
;	O
child	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
child	int
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
if	O
(	O
child	int
!=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
pipes	array(int)
[	O
1	int
]	O
)	O
;	O
formatted_page	*(char)
=	O
read_from_fd	(int)->(*(char))
(	O
pipes	array(int)
[	O
0	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
pipes	array(int)
[	O
0	int
]	O
)	O
;	O
wait	(*(int))->(int)
(	O
&	O
formatter_status	int
)	O
;	O
}	O
else	O
{	O
close	*((*(void))->(int))
(	O
pipes	array(int)
[	O
0	int
]	O
)	O
;	O
freopen	(*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
NULL_DEVICE	*(char)
,	O
"w"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
freopen	(*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
NULL_DEVICE	*(char)
,	O
"r"	*(char)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
dup2	(int,int)->(int)
(	O
pipes	array(int)
[	O
1	int
]	O
,	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
;	O
execv	(*(char),array(*(char)))->(int)
(	O
formatter_args	array(*(char))
[	O
0	int
]	O
,	O
formatter_args	array(*(char))
)	O
;	O
close	*((*(void))->(int))
(	O
pipes	array(int)
[	O
1	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
!	O
formatted_page	*(char)
)	O
return	O
0	int
;	O
{	O
int	O
i	int
;	O
char	O
*	O
p	*(void)
;	O
p	*(void)
=	O
formatted_page	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
3	int
;	O
i	int
++	O
)	O
{	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
formatted_page	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
p	*(void)
++	O
;	O
}	O
}	O
clean_manpage	(*(char))->(void)
(	O
formatted_page	*(char)
)	O
;	O
return	O
formatted_page	*(char)
;	O
}	O
static	O
char	O
*	O
read_from_fd	(int)->(*(char))
(	O
int	O
fd	int
)	O
{	O
struct	O
timeval	struct(long,long)
timeout	struct(long,long)
;	O
char	O
*	O
buffer	*(struct)
=	O
NULL	O
;	O
int	O
bsize	int
=	O
0	int
;	O
int	O
bindex	int
=	O
0	int
;	O
int	O
select_result	int
;	O
fd_set	struct(array(long))
read_fds	struct(array(long))
;	O
timeout	struct(long,long)
.	O
tv_sec	long
=	O
15	int
;	O
timeout	struct(long,long)
.	O
tv_usec	long
=	O
0	int
;	O
FD_ZERO	O
(	O
&	O
read_fds	struct(array(long))
)	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
read_fds	struct(array(long))
)	O
;	O
select_result	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
fd	int
+	O
1	int
,	O
fd_set_cast	O
(	O
&	O
read_fds	struct(array(long))
)	O
,	O
0	int
,	O
0	int
,	O
&	O
timeout	struct(long,long)
)	O
;	O
switch	O
(	O
select_result	int
)	O
{	O
case	O
0	int
:	O
case	O
-	O
1	int
:	O
break	O
;	O
default	O
:	O
{	O
int	O
amount_read	int
;	O
int	O
done	int
=	O
0	int
;	O
while	O
(	O
!	O
done	int
)	O
{	O
while	O
(	O
(	O
bindex	int
+	O
1024	int
)	O
>	O
(	O
bsize	int
)	O
)	O
buffer	*(struct)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
buffer	*(struct)
,	O
(	O
bsize	int
+=	O
1024	int
)	O
)	O
;	O
buffer	*(struct)
[	O
bindex	int
]	O
=	O
'\0'	O
;	O
amount_read	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
buffer	*(struct)
+	O
bindex	int
,	O
1023	int
)	O
;	O
if	O
(	O
amount_read	int
<	O
0	int
)	O
{	O
done	int
=	O
1	int
;	O
}	O
else	O
{	O
bindex	int
+=	O
amount_read	int
;	O
buffer	*(struct)
[	O
bindex	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
amount_read	int
==	O
0	int
)	O
done	int
=	O
1	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
(	O
buffer	*(struct)
!=	O
NULL	O
)	O
&&	O
(	O
*	O
buffer	*(struct)
==	O
'\0'	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
buffer	*(struct)
)	O
;	O
buffer	*(struct)
=	O
NULL	O
;	O
}	O
return	O
buffer	*(struct)
;	O
}	O
static	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
xrefs_of_manpage	(*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct`)),*(char),*(char),*(char),int)))->(*(*(struct(*(char),*(char),*(char),int,int,long,int))))
(	O
NODE	struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*(char),*(char),*(char),int,int,long,int))),*(char),*(char),*(char),int)
*	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
)	O
{	O
SEARCH_BINDING	struct(*(char),long,long,int)
s	*(char)
;	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
*	O
refs	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
NULL	O
;	O
size_t	long
refs_index	long
=	O
0	int
;	O
size_t	long
refs_slots	long
=	O
0	int
;	O
long	O
position	long
;	O
refs	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
)	O
)	O
;	O
refs_slots	long
=	O
1	int
;	O
s	*(char)
.	O
buffer	*(struct)
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
;	O
s	*(char)
.	O
start	int
=	O
0	int
;	O
s	*(char)
.	O
flags	int
=	O
0	int
;	O
s	*(char)
.	O
end	int
=	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
nodelen	long
;	O
s	*(char)
.	O
start	int
=	O
strcspn	(*(char),*(char))->(long)
(	O
node	*(struct(*(char),*(char),*(char),*(char),long,long,long,int,*(*(struct(*`,*`,*`,int,int,long,int))),*(char),*(char),*(char),int))
->	O
contents	*(char)
,	O
"\n"	*(char)
)	O
;	O
while	O
(	O
search_forward	(*(char),*(struct(*(char),long,long,int)),*(long))->(enum(int,int,int))
(	O
"("	*(char)
,	O
&	O
s	*(char)
,	O
&	O
position	long
)	O
==	O
search_success	int
)	O
{	O
register	O
int	O
name	*(char)
,	O
name_end	int
;	O
int	O
section	int
,	O
section_end	int
;	O
name	*(char)
=	O
position	long
;	O
if	O
(	O
name	*(char)
==	O
0	int
)	O
goto	O
skip	O
;	O
else	O
name	*(char)
--	O
;	O
for	O
(	O
;	O
name	*(char)
>	O
0	int
;	O
name	*(char)
--	O
)	O
if	O
(	O
whitespace_or_newline	O
(	O
s	*(char)
.	O
buffer	*(struct)
[	O
name	*(char)
]	O
)	O
||	O
(	O
!	O
isalnum	(int)->(int)
(	O
s	*(char)
.	O
buffer	*(struct)
[	O
name	*(char)
]	O
)	O
&&	O
s	*(char)
.	O
buffer	*(struct)
[	O
name	*(char)
]	O
!=	O
'_'	O
&&	O
s	*(char)
.	O
buffer	*(struct)
[	O
name	*(char)
]	O
!=	O
'.'	O
&&	O
s	*(char)
.	O
buffer	*(struct)
[	O
name	*(char)
]	O
!=	O
'-'	O
&&	O
s	*(char)
.	O
buffer	*(struct)
[	O
name	*(char)
]	O
!=	O
'\033'	O
&&	O
s	*(char)
.	O
buffer	*(struct)
[	O
name	*(char)
]	O
!=	O
'['	O
)	O
)	O
break	O
;	O
if	O
(	O
name	*(char)
==	O
0	int
)	O
goto	O
skip	O
;	O
if	O
(	O
!	O
whitespace_or_newline	O
(	O
s	*(char)
.	O
buffer	*(struct)
[	O
name	*(char)
]	O
)	O
)	O
goto	O
skip	O
;	O
name	*(char)
++	O
;	O
if	O
(	O
name	*(char)
==	O
position	long
)	O
goto	O
skip	O
;	O
if	O
(	O
s	*(char)
.	O
buffer	*(struct)
[	O
name	*(char)
]	O
==	O
'\033'	O
&&	O
s	*(char)
.	O
buffer	*(struct)
[	O
name	*(char)
+	O
1	int
]	O
==	O
'['	O
)	O
{	O
name	*(char)
+=	O
2	int
;	O
name	*(char)
+=	O
strspn	(*(char),*(char))->(long)
(	O
s	*(char)
.	O
buffer	*(struct)
+	O
name	*(char)
,	O
"0123456789;"	*(char)
)	O
;	O
if	O
(	O
s	*(char)
.	O
buffer	*(struct)
[	O
name	*(char)
]	O
==	O
'm'	O
)	O
name	*(char)
++	O
;	O
else	O
goto	O
skip	O
;	O
}	O
for	O
(	O
name_end	int
=	O
name	*(char)
;	O
name_end	int
<	O
position	long
;	O
name_end	int
++	O
)	O
if	O
(	O
!	O
isalnum	(int)->(int)
(	O
s	*(char)
.	O
buffer	*(struct)
[	O
name_end	int
]	O
)	O
&&	O
s	*(char)
.	O
buffer	*(struct)
[	O
name_end	int
]	O
!=	O
'_'	O
&&	O
s	*(char)
.	O
buffer	*(struct)
[	O
name_end	int
]	O
!=	O
'.'	O
&&	O
s	*(char)
.	O
buffer	*(struct)
[	O
name_end	int
]	O
!=	O
'-'	O
)	O
break	O
;	O
section	int
=	O
position	long
;	O
section_end	int
=	O
0	int
;	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
s	*(char)
.	O
buffer	*(struct)
[	O
section	int
+	O
1	int
]	O
)	O
||	O
s	*(char)
.	O
buffer	*(struct)
[	O
section	int
+	O
1	int
]	O
==	O
'0'	O
)	O
;	O
else	O
if	O
(	O
!	O
s	*(char)
.	O
buffer	*(struct)
[	O
section	int
+	O
2	int
]	O
)	O
;	O
else	O
if	O
(	O
s	*(char)
.	O
buffer	*(struct)
[	O
section	int
+	O
2	int
]	O
==	O
')'	O
)	O
section_end	int
=	O
section	int
+	O
3	int
;	O
else	O
if	O
(	O
!	O
isalpha	(int)->(int)
(	O
s	*(char)
.	O
buffer	*(struct)
[	O
section	int
+	O
2	int
]	O
)	O
)	O
;	O
else	O
if	O
(	O
s	*(char)
.	O
buffer	*(struct)
[	O
section	int
+	O
3	int
]	O
==	O
')'	O
)	O
section_end	int
=	O
section	int
+	O
4	int
;	O
if	O
(	O
section_end	int
)	O
{	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
*	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
;	O
int	O
len	long
=	O
name_end	int
-	O
name	*(char)
+	O
section_end	int
-	O
section	int
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
REFERENCE	struct(*(char),*(char),*(char),int,int,long,int)
)	O
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
=	O
xcalloc	(long,long)->(*(void))
(	O
1	int
,	O
1	int
+	O
len	long
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
,	O
s	*(char)
.	O
buffer	*(struct)
+	O
name	*(char)
,	O
name_end	int
-	O
name	*(char)
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
+	O
strlen	(*(char))->(long)
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
)	O
,	O
s	*(char)
.	O
buffer	*(struct)
+	O
section	int
,	O
section_end	int
-	O
section	int
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
filename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
MANPAGE_FILE_BUFFER_NAME	*(char)
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
nodename	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
label	*(char)
)	O
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
line_number	long
=	O
0	int
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
start	int
=	O
name	*(char)
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
end	int
=	O
section_end	int
;	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
->	O
type	enum(int,int,int,int)
=	O
REFERENCE_XREF	int
;	O
add_pointer_to_array	O
(	O
entry	*(struct(*(char),*(char),*(char),int,int,long,int))
,	O
refs_index	long
,	O
refs	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
,	O
refs_slots	long
,	O
10	int
)	O
;	O
}	O
skip	O
:	O
s	*(char)
.	O
start	int
=	O
position	long
+	O
1	int
;	O
}	O
return	O
refs	*(*(struct(*(char),*(char),*(char),int,int,long,int)))
;	O
}	O
