enum	O
dict_symbol_type	enum(int,int,int)
{	O
dict_symbol_uninitialized	int
,	O
dict_symbol_attribute	int
,	O
dict_symbol_alias	int
}	O
;	O
typedef	O
struct	O
dict_symbol	struct(*(struct(*(struct(*(struct`),*(char),enum(int,int,int),union(struct`,*`))),*(char),enum(int,int,int),union(struct(*(char),int,int,int,int,*((*`,*`)->(int))),*(struct(*`,int,int,int,int,*`))))),*(char),enum(int,int,int),union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int))))))
DICT_SYMBOL	struct
;	O
struct	O
dict_symbol	struct(*(struct(*(struct(*(struct`),*(char),enum(int,int,int),union(struct`,*`))),*(char),enum(int,int,int),union(struct(*(char),int,int,int,int,*((*`,*`)->(int))),*(struct(*`,int,int,int,int,*`))))),*(char),enum(int,int,int),union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int))))))
{	O
DICT_SYMBOL	struct
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
char	O
*	O
name	*(char)
;	O
enum	O
dict_symbol_type	enum(int,int,int)
type	int
;	O
union	O
{	O
grad_dict_attr_t	struct
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
grad_dict_attr_t	struct
*	O
alias	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
}	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
;	O
}	O
;	O
static	O
grad_symtab_t	struct(int,int,int,*(*(struct(*(struct`),*(char)))),*(()->(int)))
*	O
dict_attr_tab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
;	O
static	O
grad_dict_attr_t	struct
*	O
dict_attr_index	array(*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int)))))
[	O
DICT_INDEX_SIZE	int
]	O
;	O
static	O
grad_list_t	struct
*	O
dictionary_values	*(struct)
;	O
static	O
grad_list_t	struct
*	O
dictionary_vendors	*(struct)
;	O
static	O
int	O
vendorno	int
;	O
static	O
grad_dict_attr_t	struct
*	O
dict_symbol_ptr	(*(struct(*(struct(*`,*`,enum(int,int,int),union`)),*(char),enum(int,int,int),union(struct(*`,int,int,int,int,*`),*(struct`)))))->(*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
(	O
DICT_SYMBOL	struct
*	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
)	O
{	O
switch	O
(	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
type	int
)	O
{	O
case	O
dict_symbol_uninitialized	int
:	O
grad_insist_fail	O
(	O
"uninitialized dictionary symbol found!"	*(char)
)	O
;	O
break	O
;	O
case	O
dict_symbol_attribute	int
:	O
return	O
&	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
case	O
dict_symbol_alias	int
:	O
return	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
.	O
alias	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
}	O
}	O
static	O
grad_dict_attr_t	struct
*	O
dict_attr_lookup	(*(char))->(*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
(	O
const	O
char	O
*	O
ident	*(char)
)	O
{	O
DICT_SYMBOL	struct
*	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
=	O
grad_sym_lookup	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char))->(*(void))
(	O
dict_attr_tab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
ident	*(char)
)	O
;	O
if	O
(	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
)	O
return	O
dict_symbol_ptr	(*(struct(*(struct(*`,*`,enum(int,int,int),union`)),*(char),enum(int,int,int),union(struct(*`,int,int,int,int,*`),*(struct`)))))->(*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
(	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
free_vendor	(*(void),*(void))->(int)
(	O
void	O
*	O
ptr	*(*(void))
,	O
void	O
*	O
closure	*(void)
ARG_UNUSED	O
)	O
{	O
grad_dict_vendor_t	struct(*(char),int,int)
*	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
ptr	*(*(void))
;	O
if	O
(	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
vendorname	*(char)
)	O
grad_free	(*(void))->(void)
(	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
vendorname	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
free_value	(*(void),*(void))->(int)
(	O
void	O
*	O
ptr	*(*(void))
,	O
void	O
*	O
closure	*(void)
ARG_UNUSED	O
)	O
{	O
grad_dict_value_t	struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int)
*	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
ptr	*(*(void))
;	O
grad_free	(*(void))->(void)
(	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
name	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
return	O
0	int
;	O
}	O
void	O
dict_free	()->(void)
(	O
)	O
{	O
grad_symtab_free	(*(*(struct(int,int,int,*(*`),*(()->(int))))))->(void)
(	O
&	O
dict_attr_tab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
dict_attr_index	array(*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int)))))
,	O
0	int
,	O
sizeof	O
dict_attr_index	array(*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int)))))
)	O
;	O
grad_list_destroy	(*(*(struct)),*((*(void),*(void))->(int)),*(void))->(void)
(	O
&	O
dictionary_values	*(struct)
,	O
free_value	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
grad_list_destroy	(*(*(struct)),*((*(void),*(void))->(int)),*(void))->(void)
(	O
&	O
dictionary_vendors	*(struct)
,	O
free_vendor	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
nfields	(int,int,int,*(struct(*(char),long)))->(int)
(	O
int	O
fc	int
,	O
int	O
minf	int
,	O
int	O
maxf	int
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
if	O
(	O
fc	int
<	O
minf	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
"%s"	*(char)
,	O
_	O
(	O
"too few fields"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
maxf	int
!=	O
-	O
1	int
&&	O
fc	int
>	O
maxf	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
"%s"	*(char)
,	O
_	O
(	O
"too many fields"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
addvendor	(*(char),int)->(int)
(	O
char	O
*	O
name	*(char)
,	O
int	O
value	*(char)
)	O
{	O
grad_dict_vendor_t	struct(*(char),int,int)
*	O
vval	*(struct(*(char),int,int))
;	O
vval	*(struct(*(char),int,int))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
grad_dict_vendor_t	struct(*(char),int,int)
)	O
)	O
;	O
vval	*(struct(*(char),int,int))
->	O
vendorname	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
vval	*(struct(*(char),int,int))
->	O
vendorpec	int
=	O
value	*(char)
;	O
vval	*(struct(*(char),int,int))
->	O
vendorcode	int
=	O
vendorno	int
++	O
;	O
if	O
(	O
!	O
dictionary_vendors	*(struct)
)	O
dictionary_vendors	*(struct)
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
grad_list_prepend	(*(struct),*(void))->(void)
(	O
dictionary_vendors	*(struct)
,	O
vval	*(struct(*(char),int,int))
)	O
;	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
attr_parser_tab	struct(*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int)))),int,*((*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(*(char)))->(int)))
ATTR_PARSER_TAB	struct
;	O
struct	O
attr_parser_tab	struct(*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int)))),int,*((*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(*(char)))->(int)))
{	O
ATTR_PARSER_TAB	struct
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
grad_attr_parser_fp	*((*(struct),*(*(char)))->(int))
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
}	O
;	O
static	O
ATTR_PARSER_TAB	struct
*	O
attr_parser_tab	struct(*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int)))),int,*((*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(*(char)))->(int)))
;	O
static	O
grad_attr_parser_fp	*((*(struct),*(*(char)))->(int))
dict_find_parser	(int)->(*((*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(*(char)))->(int)))
(	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
{	O
ATTR_PARSER_TAB	struct
*	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
;	O
for	O
(	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
=	O
attr_parser_tab	struct(*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int)))),int,*((*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(*(char)))->(int)))
;	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
;	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
=	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
if	O
(	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
==	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
return	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
->	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
return	O
NULL	O
;	O
}	O
void	O
dict_register_parser	(int,*((*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(*(char)))->(int)))->(void)
(	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
,	O
grad_attr_parser_fp	*((*(struct),*(*(char)))->(int))
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
)	O
{	O
ATTR_PARSER_TAB	struct
*	O
e	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
e	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
)	O
)	O
;	O
e	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
e	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
->	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
=	O
fun	*((*(void),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))->(int))
;	O
e	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
attr_parser_tab	struct(*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int)))),int,*((*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(*(char)))->(int)))
;	O
attr_parser_tab	struct(*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int)))),int,*((*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(*(char)))->(int)))
=	O
e	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
;	O
}	O
static	O
void	O
parser_tab_init	()->(void)
(	O
)	O
{	O
if	O
(	O
!	O
attr_parser_tab	struct(*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int)))),int,*((*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(*(char)))->(int)))
)	O
{	O
dict_register_parser	(int,*((*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(*(char)))->(int)))->(void)
(	O
242	int
,	O
grad_ascend_parse_filter	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(*(char)))->(int)
)	O
;	O
dict_register_parser	(int,*((*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(*(char)))->(int)))->(void)
(	O
243	int
,	O
grad_ascend_parse_filter	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(*(char)))->(int)
)	O
;	O
}	O
}	O
static	O
void	O
parser_tab_free	()->(void)
(	O
)	O
{	O
ATTR_PARSER_TAB	struct
*	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
=	O
attr_parser_tab	struct(*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int)))),int,*((*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(*(char)))->(int)))
;	O
while	O
(	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
)	O
{	O
ATTR_PARSER_TAB	struct
*	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
->	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
grad_free	(*(void))->(void)
(	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
)	O
;	O
ep	*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int))))
=	O
next	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
}	O
attr_parser_tab	struct(*(struct(*(struct(*(struct`),int,*((*`,*`)->(int)))),int,*((*(struct`),*(*`))->(int)))),int,*((*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(*(char)))->(int)))
=	O
NULL	O
;	O
}	O
static	O
int	O
parse_dict	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
;	O
static	O
grad_keyword_t	struct
type_kw	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"string"	*(char)
,	O
GRAD_TYPE_STRING	int
}	O
,	O
{	O
"integer"	*(char)
,	O
GRAD_TYPE_INTEGER	int
}	O
,	O
{	O
"ipaddr"	*(char)
,	O
GRAD_TYPE_IPADDR	int
}	O
,	O
{	O
"date"	*(char)
,	O
GRAD_TYPE_DATE	int
}	O
}	O
;	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
{	O
int	O
vendor	int
;	O
grad_locus_t	struct(*(char),long)
begin_locus	struct(*(char),long)
;	O
int	O
errcnt	long
;	O
}	O
;	O
static	O
int	O
_dict_include	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
*	O
pd	*(struct(int,struct(*(char),long),int))
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
if	O
(	O
nfields	(int,int,int,*(struct(*(char),long)))->(int)
(	O
fc	int
,	O
2	int
,	O
2	int
,	O
loc	struct(*(char),long)
)	O
)	O
return	O
0	int
;	O
parse_dict	(*(char))->(int)
(	O
fv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_flags	(*(*(char)),*(int),*(struct(*(char),long)))->(int)
(	O
char	O
*	O
*	O
ptr	*(*(void))
,	O
int	O
*	O
flags	int
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
int	O
i	int
;	O
char	O
*	O
p	*(struct)
;	O
for	O
(	O
p	*(struct)
=	O
*	O
ptr	*(*(void))
+	O
1	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
GRAD_CF_MAX	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
*	O
p	*(struct)
==	O
0	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"missing ]"	*(char)
)	O
,	O
*	O
p	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
switch	O
(	O
*	O
p	*(struct)
++	O
)	O
{	O
case	O
'C'	O
:	O
case	O
'L'	O
:	O
*	O
flags	int
|=	O
GRAD_AF_LHS	O
(	O
i	int
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
*	O
flags	int
&=	O
~	O
GRAD_AF_LHS	O
(	O
i	int
)	O
;	O
break	O
;	O
case	O
']'	O
:	O
p	*(struct)
--	O
;	O
goto	O
stop	O
;	O
default	O
:	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"invalid syntax flag %c"	*(char)
)	O
,	O
p	*(struct)
[	O
-	O
1	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
switch	O
(	O
*	O
p	*(struct)
++	O
)	O
{	O
case	O
'R'	O
:	O
*	O
flags	int
|=	O
GRAD_AF_RHS	O
(	O
i	int
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
*	O
flags	int
&=	O
~	O
GRAD_AF_RHS	O
(	O
i	int
)	O
;	O
break	O
;	O
default	O
:	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"invalid syntax flag %c"	*(char)
)	O
,	O
p	*(struct)
[	O
-	O
1	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
stop	O
:	O
for	O
(	O
;	O
i	int
<	O
GRAD_CF_MAX	int
;	O
i	int
++	O
)	O
*	O
flags	int
|=	O
GRAD_AF_LHS	O
(	O
i	int
)	O
|	O
GRAD_AF_RHS	O
(	O
i	int
)	O
;	O
*	O
ptr	*(*(void))
=	O
p	*(struct)
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_attr_properties	(*(struct(*(char),long)),*(char),*(int),*(int))->(int)
(	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
,	O
char	O
*	O
str	*(char)
,	O
int	O
*	O
flags	int
,	O
int	O
*	O
prop	int
)	O
{	O
int	O
errcnt	long
=	O
0	int
;	O
char	O
*	O
p	*(struct)
;	O
for	O
(	O
p	*(struct)
=	O
str	*(char)
;	O
*	O
p	*(struct)
;	O
p	*(struct)
++	O
)	O
{	O
switch	O
(	O
*	O
p	*(struct)
)	O
{	O
case	O
'C'	O
:	O
case	O
'L'	O
:	O
*	O
flags	int
|=	O
GRAD_AF_LHS	O
(	O
GRAD_CF_USERS	int
)	O
|	O
GRAD_AF_LHS	O
(	O
GRAD_CF_HINTS	int
)	O
|	O
GRAD_AF_LHS	O
(	O
GRAD_CF_HUNTGROUPS	int
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
*	O
flags	int
|=	O
GRAD_AF_RHS	O
(	O
GRAD_CF_USERS	int
)	O
|	O
GRAD_AF_RHS	O
(	O
GRAD_CF_HINTS	int
)	O
|	O
GRAD_AF_RHS	O
(	O
GRAD_CF_HUNTGROUPS	int
)	O
;	O
break	O
;	O
case	O
'['	O
:	O
if	O
(	O
parse_flags	(*(*(char)),*(int),*(struct(*(char),long)))->(int)
(	O
&	O
p	*(struct)
,	O
flags	int
,	O
loc	struct(*(char),long)
)	O
)	O
{	O
while	O
(	O
*	O
++	O
p	*(struct)
)	O
;	O
--	O
p	*(struct)
;	O
errcnt	long
++	O
;	O
}	O
break	O
;	O
case	O
'='	O
:	O
GRAD_SET_ADDITIVITY	O
(	O
*	O
prop	int
,	O
GRAD_AP_ADD_REPLACE	int
)	O
;	O
break	O
;	O
case	O
'+'	O
:	O
GRAD_SET_ADDITIVITY	O
(	O
*	O
prop	int
,	O
GRAD_AP_ADD_APPEND	int
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
GRAD_SET_ADDITIVITY	O
(	O
*	O
prop	int
,	O
GRAD_AP_ADD_NONE	int
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
*	O
prop	int
|=	O
GRAD_AP_PROPAGATE	int
;	O
break	O
;	O
case	O
'l'	O
:	O
*	O
flags	int
&=	O
~	O
GRAD_AP_INTERNAL	int
;	O
break	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
*	O
prop	int
|=	O
GRAD_AP_USER_FLAG	O
(	O
*	O
p	*(struct)
-	O
'0'	O
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
*	O
prop	int
|=	O
GRAD_AP_BINARY_STRING	int
;	O
break	O
;	O
case	O
'E'	O
:	O
*	O
prop	int
|=	O
GRAD_AP_ENCRYPT_RFC2138	int
;	O
break	O
;	O
case	O
'T'	O
:	O
*	O
prop	int
|=	O
GRAD_AP_ENCRYPT_RFC2868	int
;	O
break	O
;	O
case	O
'c'	O
:	O
break	O
;	O
default	O
:	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"invalid flag %c"	*(char)
)	O
,	O
*	O
p	*(struct)
)	O
;	O
errcnt	long
++	O
;	O
break	O
;	O
}	O
}	O
return	O
errcnt	long
;	O
}	O
static	O
void	O
set_default_attr_properties	(int,*(int),*(int))->(void)
(	O
int	O
value	*(char)
,	O
int	O
*	O
flags	int
,	O
int	O
*	O
prop	int
)	O
{	O
*	O
flags	int
=	O
GRAD_AF_DEFAULT_FLAGS	O
;	O
*	O
prop	int
=	O
GRAD_AP_DEFAULT_ADD	O
;	O
if	O
(	O
GRAD_VENDOR_CODE	O
(	O
value	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
value	*(char)
>	O
255	int
)	O
*	O
flags	int
|=	O
GRAD_AP_INTERNAL	int
;	O
else	O
if	O
(	O
value	*(char)
==	O
DA_USER_PASSWORD	int
||	O
value	*(char)
==	O
DA_USER_PASSWORD	int
)	O
*	O
prop	int
|=	O
GRAD_AP_ENCRYPT_RFC2138	int
;	O
}	O
}	O
static	O
int	O
_dict_attribute	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
*	O
pd	*(struct(int,struct(*(char),long),int))
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
DICT_SYMBOL	struct
*	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
;	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
int	O
type	int
;	O
int	O
vendor	int
=	O
0	int
;	O
unsigned	O
value	*(char)
;	O
char	O
*	O
p	*(struct)
;	O
grad_attr_parser_fp	*((*(struct),*(*(char)))->(int))
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
NULL	O
;	O
int	O
flags	int
;	O
int	O
prop	int
;	O
if	O
(	O
nfields	(int,int,int,*(struct(*(char),long)))->(int)
(	O
fc	int
,	O
4	int
,	O
6	int
,	O
loc	struct(*(char),long)
)	O
)	O
return	O
0	int
;	O
GRAD_DEBUG7	O
(	O
100	int
,	O
"%s:%lu: ATTR_NAME=%s ATTR_VALUE=%s ATTR_TYPE=%s ATTR_VENDOR=%s ATTR_FLAGS=%s"	*(char)
,	O
loc	struct(*(char),long)
->	O
file	*(char)
,	O
loc	struct(*(char),long)
->	O
line	long
,	O
ATTR_NAME	O
,	O
ATTR_VALUE	O
,	O
ATTR_TYPE	O
,	O
HAS_VENDOR	O
(	O
fc	int
,	O
fv	*(*(char))
)	O
?	O
ATTR_VENDOR	O
:	O
pd	*(struct(int,struct(*(char),long),int))
->	O
vendor	int
?	O
"BLOCK"	*(char)
:	O
"N/A"	*(char)
,	O
HAS_FLAGS	O
(	O
fc	int
,	O
fv	*(*(char))
)	O
?	O
ATTR_FLAGS	O
:	O
"N/A"	*(char)
)	O
;	O
value	*(char)
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
ATTR_VALUE	O
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"value not a number (near %s)"	*(char)
)	O
,	O
p	*(struct)
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ATTR_TYPE	O
,	O
"abinary"	*(char)
)	O
==	O
0	int
)	O
{	O
type	int
=	O
GRAD_TYPE_STRING	int
;	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
dict_find_parser	(int)->(*((*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(*(char)))->(int)))
(	O
value	*(char)
)	O
;	O
if	O
(	O
!	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_WARN	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"no parser registered for this attribute"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
type	int
=	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
type_kw	array(struct(*(char),int))
,	O
ATTR_TYPE	O
,	O
GRAD_TYPE_INVALID	O
)	O
;	O
if	O
(	O
type	int
==	O
GRAD_TYPE_INVALID	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
"%s"	*(char)
,	O
_	O
(	O
"invalid type"	*(char)
)	O
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
HAS_VENDOR	O
(	O
fc	int
,	O
fv	*(*(char))
)	O
)	O
{	O
if	O
(	O
(	O
vendor	int
=	O
grad_vendor_name_to_id	(*(char))->(int)
(	O
ATTR_VENDOR	O
)	O
)	O
==	O
0	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"unknown vendor"	*(char)
)	O
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
pd	*(struct(int,struct(*(char),long),int))
->	O
vendor	int
)	O
vendor	int
=	O
pd	*(struct(int,struct(*(char),long),int))
->	O
vendor	int
;	O
value	*(char)
|=	O
(	O
vendor	int
<<	O
16	int
)	O
;	O
set_default_attr_properties	(int,*(int),*(int))->(void)
(	O
value	*(char)
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
;	O
if	O
(	O
HAS_FLAGS	O
(	O
fc	int
,	O
fv	*(*(char))
)	O
)	O
{	O
int	O
rc	int
=	O
parse_attr_properties	(*(struct(*(char),long)),*(char),*(int),*(int))->(int)
(	O
loc	struct(*(char),long)
,	O
ATTR_FLAGS	O
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
}	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
=	O
grad_sym_lookup_or_install	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char),int)->(*(void))
(	O
dict_attr_tab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
ATTR_NAME	O
,	O
1	int
)	O
;	O
switch	O
(	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
type	int
)	O
{	O
case	O
dict_symbol_uninitialized	int
:	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
type	int
=	O
dict_symbol_attribute	int
;	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
&	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
break	O
;	O
case	O
dict_symbol_attribute	int
:	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_WARN	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"Redefining attribute %s"	*(char)
)	O
,	O
ATTR_NAME	O
)	O
;	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
&	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
break	O
;	O
case	O
dict_symbol_alias	int
:	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_WARN	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"Redefining alias %s"	*(char)
)	O
,	O
ATTR_NAME	O
)	O
;	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
.	O
alias	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
}	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
name	*(char)
=	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
name	*(char)
;	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
value	*(char)
=	O
value	*(char)
;	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
type	int
=	O
type	int
;	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
prop	int
=	O
flags	int
|	O
prop	int
;	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
parser	*((*(struct),*(*(char)))->(int))
=	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
if	O
(	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
value	*(char)
>=	O
0	int
&&	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
value	*(char)
<	O
DICT_INDEX_SIZE	int
)	O
dict_attr_index	array(*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int)))))
[	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
value	*(char)
]	O
=	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_dict_alias	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
*	O
pd	*(struct(int,struct(*(char),long),int))
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
DICT_SYMBOL	struct
*	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
;	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
if	O
(	O
nfields	(int,int,int,*(struct(*(char),long)))->(int)
(	O
fc	int
,	O
3	int
,	O
3	int
,	O
loc	struct(*(char),long)
)	O
)	O
return	O
0	int
;	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
dict_attr_lookup	(*(char))->(*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
(	O
fv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"Attribute %s is not defined"	*(char)
)	O
,	O
fv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
=	O
grad_sym_lookup_or_install	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*(char),int)->(*(void))
(	O
dict_attr_tab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
fv	*(*(char))
[	O
2	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
type	int
!=	O
dict_symbol_uninitialized	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"Symbol %s already declared"	*(char)
)	O
,	O
fv	*(*(char))
[	O
2	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
type	int
=	O
dict_symbol_alias	int
;	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
.	O
alias	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_dict_property	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
*	O
pd	*(struct(int,struct(*(char),long),int))
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
int	O
i	int
;	O
int	O
flags	int
;	O
int	O
prop	int
;	O
if	O
(	O
nfields	(int,int,int,*(struct(*(char),long)))->(int)
(	O
fc	int
,	O
3	int
,	O
-	O
1	int
,	O
loc	struct(*(char),long)
)	O
)	O
return	O
0	int
;	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
dict_attr_lookup	(*(char))->(*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
(	O
fv	*(*(char))
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"Attribute %s is not defined"	*(char)
)	O
,	O
fv	*(*(char))
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
fc	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
fv	*(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
)	O
{	O
case	O
'+'	O
:	O
flags	int
=	O
prop	int
=	O
0	int
;	O
if	O
(	O
parse_attr_properties	(*(struct(*(char),long)),*(char),*(int),*(int))->(int)
(	O
loc	struct(*(char),long)
,	O
fv	*(*(char))
[	O
i	int
]	O
+	O
1	int
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
)	O
{	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
break	O
;	O
}	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
prop	int
|=	O
flags	int
|	O
prop	int
;	O
break	O
;	O
case	O
'-'	O
:	O
flags	int
=	O
prop	int
=	O
0	int
;	O
if	O
(	O
parse_attr_properties	(*(struct(*(char),long)),*(char),*(int),*(int))->(int)
(	O
loc	struct(*(char),long)
,	O
fv	*(*(char))
[	O
i	int
]	O
+	O
1	int
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
)	O
{	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
break	O
;	O
}	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
prop	int
&=	O
~	O
(	O
flags	int
|	O
prop	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
i	int
>	O
2	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"PROPERTY syntax error"	*(char)
)	O
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
}	O
else	O
{	O
set_default_attr_properties	(int,*(int),*(int))->(void)
(	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
value	*(char)
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
;	O
if	O
(	O
parse_attr_properties	(*(struct(*(char),long)),*(char),*(int),*(int))->(int)
(	O
loc	struct(*(char),long)
,	O
fv	*(*(char))
[	O
i	int
]	O
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
==	O
0	int
)	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
prop	int
=	O
flags	int
|	O
prop	int
;	O
else	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
break	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_dict_value	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
*	O
pd	*(struct(int,struct(*(char),long),int))
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
grad_dict_value_t	struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int)
*	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
;	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
char	O
*	O
p	*(struct)
;	O
int	O
value	*(char)
;	O
if	O
(	O
nfields	(int,int,int,*(struct(*(char),long)))->(int)
(	O
fc	int
,	O
4	int
,	O
4	int
,	O
loc	struct(*(char),long)
)	O
)	O
return	O
0	int
;	O
value	*(char)
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
VALUE_NUM	O
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"value not a number (near %s)"	*(char)
)	O
,	O
p	*(struct)
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
dict_attr_lookup	(*(char))->(*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
(	O
VALUE_ATTR	O
)	O
;	O
if	O
(	O
!	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"Attribute %s is not defined"	*(char)
)	O
,	O
VALUE_ATTR	O
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
prop	int
|=	O
GRAD_AP_TRANSLATE	int
;	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
grad_dict_value_t	struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int)
)	O
)	O
;	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
->	O
name	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
VALUE_NAME	O
)	O
;	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
->	O
value	*(char)
=	O
value	*(char)
;	O
if	O
(	O
!	O
dictionary_values	*(struct)
)	O
dictionary_values	*(struct)
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
grad_list_append	(*(struct),*(void))->(void)
(	O
dictionary_values	*(struct)
,	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_dict_vendor	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
*	O
pd	*(struct(int,struct(*(char),long),int))
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
int	O
value	*(char)
;	O
char	O
*	O
p	*(struct)
;	O
if	O
(	O
nfields	(int,int,int,*(struct(*(char),long)))->(int)
(	O
fc	int
,	O
3	int
,	O
3	int
,	O
loc	struct(*(char),long)
)	O
)	O
return	O
1	int
;	O
value	*(char)
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
VENDOR_VALUE	O
,	O
&	O
p	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(struct)
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"value not a number (near %s)"	*(char)
)	O
,	O
p	*(struct)
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
addvendor	(*(char),int)->(int)
(	O
VENDOR_NAME	O
,	O
value	*(char)
)	O
<	O
0	int
)	O
{	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
_dict_begin	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(void)
(	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
*	O
pd	*(struct(int,struct(*(char),long),int))
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
if	O
(	O
pd	*(struct(int,struct(*(char),long),int))
->	O
vendor	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"blocks cannot be nested"	*(char)
)	O
)	O
;	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
&	O
pd	*(struct(int,struct(*(char),long),int))
->	O
begin_locus	struct(*(char),long)
,	O
_	O
(	O
"block opened here"	*(char)
)	O
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
;	O
}	O
if	O
(	O
nfields	(int,int,int,*(struct(*(char),long)))->(int)
(	O
fc	int
,	O
3	int
,	O
4	int
,	O
loc	struct(*(char),long)
)	O
)	O
{	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
fv	*(*(char))
[	O
1	int
]	O
,	O
"VENDOR"	*(char)
)	O
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"block syntax: expected `VENDOR' but found `%s'"	*(char)
)	O
,	O
fv	*(*(char))
[	O
1	int
]	O
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
;	O
}	O
if	O
(	O
fc	int
==	O
4	int
&&	O
_dict_vendor	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
-	O
1	int
,	O
fv	*(*(char))
+	O
1	int
,	O
loc	struct(*(char),long)
)	O
)	O
return	O
;	O
if	O
(	O
(	O
pd	*(struct(int,struct(*(char),long),int))
->	O
vendor	int
=	O
grad_vendor_name_to_id	(*(char))->(int)
(	O
fv	*(*(char))
[	O
2	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"unknown vendor"	*(char)
)	O
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
;	O
}	O
pd	*(struct(int,struct(*(char),long),int))
->	O
begin_locus	struct(*(char),long)
=	O
*	O
loc	struct(*(char),long)
;	O
GRAD_DEBUG4	O
(	O
1	int
,	O
"%s:%lu: BEGIN VENDOR %s (%d)"	*(char)
,	O
loc	struct(*(char),long)
->	O
file	*(char)
,	O
loc	struct(*(char),long)
->	O
line	long
,	O
fv	*(*(char))
[	O
2	int
]	O
,	O
pd	*(struct(int,struct(*(char),long),int))
->	O
vendor	int
)	O
;	O
}	O
static	O
void	O
_dict_end	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(void)
(	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
*	O
pd	*(struct(int,struct(*(char),long),int))
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
if	O
(	O
!	O
pd	*(struct(int,struct(*(char),long),int))
->	O
vendor	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
_	O
(	O
"unexpected END"	*(char)
)	O
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
}	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"END VENDOR %d"	*(char)
,	O
pd	*(struct(int,struct(*(char),long),int))
->	O
vendor	int
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
->	O
vendor	int
=	O
0	int
;	O
}	O
static	O
void	O
_dict_begin_vendor	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(void)
(	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
*	O
pd	*(struct(int,struct(*(char),long),int))
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
char	O
*	O
args	*(struct)
[	O
4	int
]	O
;	O
if	O
(	O
nfields	(int,int,int,*(struct(*(char),long)))->(int)
(	O
fc	int
,	O
2	int
,	O
2	int
,	O
loc	struct(*(char),long)
)	O
)	O
{	O
pd	*(struct(int,struct(*(char),long),int))
->	O
errcnt	long
++	O
;	O
return	O
;	O
}	O
args	*(struct)
[	O
0	int
]	O
=	O
"BEGIN"	*(char)
;	O
args	*(struct)
[	O
1	int
]	O
=	O
"VENDOR"	*(char)
;	O
args	*(struct)
[	O
2	int
]	O
=	O
fv	*(*(char))
[	O
1	int
]	O
;	O
args	*(struct)
[	O
3	int
]	O
=	O
NULL	O
;	O
_dict_begin	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(void)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
3	int
,	O
args	*(struct)
,	O
loc	struct(*(char),long)
)	O
;	O
}	O
static	O
void	O
_dict_end_vendor	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(void)
(	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
*	O
pd	*(struct(int,struct(*(char),long),int))
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
_dict_end	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(void)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
,	O
fv	*(*(char))
,	O
loc	struct(*(char),long)
)	O
;	O
}	O
enum	O
{	O
KW_INCLUDE	int
,	O
KW_ATTRIBUTE	int
,	O
KW_ALIAS	int
,	O
KW_VALUE	int
,	O
KW_VENDOR	int
,	O
KW_PROPERTY	int
,	O
KW_BEGIN	int
,	O
KW_BEGIN_VENDOR	int
,	O
KW_END_VENDOR	int
,	O
KW_END	int
}	O
;	O
static	O
grad_keyword_t	struct
dict_kw	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"$INCLUDE"	*(char)
,	O
KW_INCLUDE	int
}	O
,	O
{	O
"ATTRIBUTE"	*(char)
,	O
KW_ATTRIBUTE	int
}	O
,	O
{	O
"ALIAS"	*(char)
,	O
KW_ALIAS	int
}	O
,	O
{	O
"VALUE"	*(char)
,	O
KW_VALUE	int
}	O
,	O
{	O
"VENDOR"	*(char)
,	O
KW_VENDOR	int
}	O
,	O
{	O
"PROPERTY"	*(char)
,	O
KW_PROPERTY	int
}	O
,	O
{	O
"BEGIN"	*(char)
,	O
KW_BEGIN	int
}	O
,	O
{	O
"END"	*(char)
,	O
KW_END	int
}	O
,	O
{	O
"BEGIN-VENDOR"	*(char)
,	O
KW_BEGIN_VENDOR	int
}	O
,	O
{	O
"END-VENDOR"	*(char)
,	O
KW_END_VENDOR	int
}	O
,	O
{	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
int	O
parse_dict_entry	(*(void),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
void	O
*	O
closure	*(void)
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	*(*(char))
,	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
)	O
{	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
*	O
pd	*(struct(int,struct(*(char),long),int))
=	O
closure	*(void)
;	O
switch	O
(	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
dict_kw	array(struct(*(char),int))
,	O
KEYWORD	O
,	O
-	O
1	int
)	O
)	O
{	O
case	O
KW_INCLUDE	int
:	O
_dict_include	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
,	O
fv	*(*(char))
,	O
loc	struct(*(char),long)
)	O
;	O
break	O
;	O
case	O
KW_ATTRIBUTE	int
:	O
_dict_attribute	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
,	O
fv	*(*(char))
,	O
loc	struct(*(char),long)
)	O
;	O
break	O
;	O
case	O
KW_ALIAS	int
:	O
_dict_alias	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
,	O
fv	*(*(char))
,	O
loc	struct(*(char),long)
)	O
;	O
break	O
;	O
case	O
KW_VALUE	int
:	O
_dict_value	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
,	O
fv	*(*(char))
,	O
loc	struct(*(char),long)
)	O
;	O
break	O
;	O
case	O
KW_VENDOR	int
:	O
_dict_vendor	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
,	O
fv	*(*(char))
,	O
loc	struct(*(char),long)
)	O
;	O
break	O
;	O
case	O
KW_PROPERTY	int
:	O
_dict_property	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(int)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
,	O
fv	*(*(char))
,	O
loc	struct(*(char),long)
)	O
;	O
break	O
;	O
case	O
KW_BEGIN	int
:	O
_dict_begin	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(void)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
,	O
fv	*(*(char))
,	O
loc	struct(*(char),long)
)	O
;	O
break	O
;	O
case	O
KW_END	int
:	O
_dict_end	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(void)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
,	O
fv	*(*(char))
,	O
loc	struct(*(char),long)
)	O
;	O
break	O
;	O
case	O
KW_BEGIN_VENDOR	int
:	O
_dict_begin_vendor	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(void)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
,	O
fv	*(*(char))
,	O
loc	struct(*(char),long)
)	O
;	O
break	O
;	O
case	O
KW_END_VENDOR	int
:	O
_dict_end_vendor	(*(struct(int,struct(*(char),long),int)),int,*(*(char)),*(struct(*(char),long)))->(void)
(	O
pd	*(struct(int,struct(*(char),long),int))
,	O
fc	int
,	O
fv	*(*(char))
,	O
loc	struct(*(char),long)
)	O
;	O
break	O
;	O
default	O
:	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
loc	struct(*(char),long)
,	O
"%s"	*(char)
,	O
_	O
(	O
"unknown keyword"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_dict	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
char	O
*	O
path	*(char)
;	O
int	O
rc	int
;	O
struct	O
parse_data	struct(int,struct(*(char),long),int)
pd	*(struct(int,struct(*(char),long),int))
;	O
pd	*(struct(int,struct(*(char),long),int))
.	O
errcnt	long
=	O
0	int
;	O
pd	*(struct(int,struct(*(char),long),int))
.	O
vendor	int
=	O
0	int
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'/'	O
)	O
path	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
else	O
path	*(char)
=	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
grad_config_dir	*(char)
,	O
name	*(char)
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"parsing %s"	*(char)
,	O
path	*(char)
)	O
;	O
rc	int
=	O
grad_read_raddb_file	(*(char),int,*(char),*((*(void),int,*(*(char)),*(struct(*`,long)))->(int)),*(void))->(int)
(	O
path	*(char)
,	O
1	int
,	O
NULL	O
,	O
parse_dict_entry	(*(void),int,*(*(char)),*(struct(*(char),long)))->(int)
,	O
&	O
pd	*(struct(int,struct(*(char),long),int))
)	O
;	O
if	O
(	O
pd	*(struct(int,struct(*(char),long),int))
.	O
vendor	int
)	O
{	O
grad_log_loc	(int,*(struct(*(char),long)),*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
&	O
pd	*(struct(int,struct(*(char),long),int))
.	O
begin_locus	struct(*(char),long)
,	O
_	O
(	O
"BEGIN without END"	*(char)
)	O
)	O
;	O
pd	*(struct(int,struct(*(char),long),int))
.	O
vendor	int
=	O
0	int
;	O
pd	*(struct(int,struct(*(char),long),int))
.	O
errcnt	long
++	O
;	O
}	O
if	O
(	O
pd	*(struct(int,struct(*(char),long),int))
.	O
errcnt	long
)	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_NOTICE	int
,	O
dngettext	(*(char),*(char),*(char),long)->(*(char))
(	O
PACKAGE	*(char)
,	O
"%s: %d error"	*(char)
,	O
"%s: %d errors"	*(char)
,	O
pd	*(struct(int,struct(*(char),long),int))
.	O
errcnt	long
)	O
,	O
path	*(char)
,	O
pd	*(struct(int,struct(*(char),long),int))
.	O
errcnt	long
)	O
;	O
grad_free	(*(void))->(void)
(	O
path	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
grad_dict_init	()->(int)
(	O
)	O
{	O
parser_tab_free	()->(void)
(	O
)	O
;	O
dict_free	()->(void)
(	O
)	O
;	O
parser_tab_init	()->(void)
(	O
)	O
;	O
dict_attr_tab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
=	O
grad_symtab_create	(int,*(()->(int)))->(*(struct(int,int,int,*(*(struct`)),*(()->(int)))))
(	O
sizeof	O
(	O
DICT_SYMBOL	struct
)	O
,	O
NULL	O
)	O
;	O
vendorno	int
=	O
1	int
;	O
return	O
parse_dict	(*(char))->(int)
(	O
RADIUS_DICTIONARY	*(char)
)	O
;	O
}	O
void	O
grad_dict_free	()->(void)
(	O
)	O
{	O
parser_tab_free	()->(void)
(	O
)	O
;	O
dict_free	()->(void)
(	O
)	O
;	O
}	O
struct	O
attr_value	struct(int,*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int)))))
{	O
unsigned	O
value	*(char)
;	O
grad_dict_attr_t	struct
*	O
da	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
}	O
;	O
static	O
int	O
attrval_cmp	(*(void),*(struct(*(struct(*`,*`)),*(char))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
grad_symbol_t	struct
*	O
s	*(*(char))
)	O
{	O
struct	O
attr_value	struct(int,*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int)))))
*	O
av	*(struct(int,*(struct(*(char),int,int,int,int,*((*`,*`)->(int))))))
=	O
data	*(void)
;	O
DICT_SYMBOL	struct
*	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
=	O
(	O
DICT_SYMBOL	struct
*	O
)	O
s	*(*(char))
;	O
if	O
(	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
type	int
==	O
dict_symbol_attribute	int
&&	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
.	O
value	*(char)
==	O
av	*(struct(int,*(struct(*(char),int,int,int,int,*((*`,*`)->(int))))))
->	O
value	*(char)
)	O
{	O
av	*(struct(int,*(struct(*(char),int,int,int,int,*((*`,*`)->(int))))))
->	O
da	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
&	O
sym	*(*(struct(*(struct(*`,*`)),*(char))))
->	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
.	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
grad_dict_attr_t	struct
*	O
grad_attr_number_to_dict	(int)->(*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
(	O
int	O
attribute	int
)	O
{	O
struct	O
attr_value	struct(int,*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int)))))
av	*(struct(int,*(struct(*(char),int,int,int,int,*((*`,*`)->(int))))))
;	O
if	O
(	O
attribute	int
>=	O
0	int
&&	O
attribute	int
<	O
DICT_INDEX_SIZE	int
)	O
return	O
dict_attr_index	array(*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int)))))
[	O
attribute	int
]	O
;	O
av	*(struct(int,*(struct(*(char),int,int,int,int,*((*`,*`)->(int))))))
.	O
value	*(char)
=	O
attribute	int
;	O
av	*(struct(int,*(struct(*(char),int,int,int,int,*((*`,*`)->(int))))))
.	O
da	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
=	O
NULL	O
;	O
grad_symtab_iterate	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*((*(void),*(struct(*`,*`)))->(int)),*(void))->(void)
(	O
dict_attr_tab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
attrval_cmp	(*(void),*(struct(*(struct(*`,*`)),*(char))))->(int)
,	O
&	O
av	*(struct(int,*(struct(*(char),int,int,int,int,*((*`,*`)->(int))))))
)	O
;	O
return	O
av	*(struct(int,*(struct(*(char),int,int,int,int,*((*`,*`)->(int))))))
.	O
da	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
}	O
grad_dict_attr_t	struct
*	O
grad_attr_name_to_dict	(*(char))->(*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
(	O
const	O
char	O
*	O
attrname	*(char)
)	O
{	O
return	O
dict_attr_lookup	(*(char))->(*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
(	O
attrname	*(char)
)	O
;	O
}	O
struct	O
val_lookup	struct(*(char),*(char),int)
{	O
const	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
attrname	*(char)
;	O
int	O
number	int
;	O
}	O
;	O
static	O
int	O
valname_cmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
data	*(void)
)	O
{	O
const	O
grad_dict_value_t	struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int)
*	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
=	O
item	*(void)
;	O
const	O
struct	O
val_lookup	struct(*(char),*(char),int)
*	O
d	*(char)
=	O
data	*(void)
;	O
if	O
(	O
d	*(char)
->	O
number	int
==	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
value	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
->	O
name	*(char)
,	O
d	*(char)
->	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
grad_dict_value_t	struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int)
*	O
grad_value_name_to_value	(*(char),int)->(*(struct(*(char),*(struct(*`,int,int,int,int,*`)),int)))
(	O
const	O
char	O
*	O
valname	*(char)
,	O
int	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
)	O
{	O
struct	O
val_lookup	struct(*(char),*(char),int)
data	*(void)
;	O
data	*(void)
.	O
name	*(char)
=	O
valname	*(char)
;	O
data	*(void)
.	O
number	int
=	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
return	O
grad_list_locate	(*(struct),*(void),*((*(void),*(void))->(int)))->(*(void))
(	O
dictionary_values	*(struct)
,	O
&	O
data	*(void)
,	O
valname_cmp	(*(void),*(void))->(int)
)	O
;	O
}	O
static	O
int	O
valnum_cmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
data	*(void)
)	O
{	O
const	O
grad_dict_value_t	struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int)
*	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
=	O
item	*(void)
;	O
const	O
struct	O
val_lookup	struct(*(char),*(char),int)
*	O
d	*(char)
=	O
data	*(void)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
d	*(char)
->	O
attrname	*(char)
,	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
->	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
->	O
name	*(char)
)	O
==	O
0	int
&&	O
d	*(char)
->	O
number	int
==	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
->	O
value	*(char)
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
grad_dict_value_t	struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int)
*	O
grad_value_lookup	(int,*(char))->(*(struct(*(char),*(struct(*`,int,int,int,int,*`)),int)))
(	O
grad_uint32_t	int
value	*(char)
,	O
char	O
*	O
attrname	*(char)
)	O
{	O
struct	O
val_lookup	struct(*(char),*(char),int)
data	*(void)
;	O
data	*(void)
.	O
number	int
=	O
value	*(char)
;	O
data	*(void)
.	O
attrname	*(char)
=	O
attrname	*(char)
;	O
return	O
grad_list_locate	(*(struct),*(void),*((*(void),*(void))->(int)))->(*(void))
(	O
dictionary_values	*(struct)
,	O
&	O
data	*(void)
,	O
valnum_cmp	(*(void),*(void))->(int)
)	O
;	O
}	O
static	O
int	O
code_cmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
data	*(void)
)	O
{	O
const	O
grad_dict_vendor_t	struct(*(char),int,int)
*	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
=	O
item	*(void)
;	O
const	O
int	O
*	O
code	char
=	O
data	*(void)
;	O
return	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
->	O
vendorcode	int
!=	O
*	O
code	char
;	O
}	O
int	O
grad_vendor_id_to_pec	(int)->(int)
(	O
int	O
code	char
)	O
{	O
grad_dict_vendor_t	struct(*(char),int,int)
*	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_list_locate	(*(struct),*(void),*((*(void),*(void))->(int)))->(*(void))
(	O
dictionary_vendors	*(struct)
,	O
&	O
code	char
,	O
code_cmp	(*(void),*(void))->(int)
)	O
;	O
return	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
?	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
vendorpec	int
:	O
0	int
;	O
}	O
static	O
int	O
pec_cmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
data	*(void)
)	O
{	O
const	O
grad_dict_vendor_t	struct(*(char),int,int)
*	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
=	O
item	*(void)
;	O
const	O
int	O
*	O
pec	*(int)
=	O
data	*(void)
;	O
return	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
->	O
vendorpec	int
!=	O
*	O
pec	*(int)
;	O
}	O
int	O
grad_vendor_pec_to_id	(int)->(int)
(	O
int	O
pec	*(int)
)	O
{	O
grad_dict_vendor_t	struct(*(char),int,int)
*	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_list_locate	(*(struct),*(void),*((*(void),*(void))->(int)))->(*(void))
(	O
dictionary_vendors	*(struct)
,	O
&	O
pec	*(int)
,	O
pec_cmp	(*(void),*(void))->(int)
)	O
;	O
return	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
?	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
vendorcode	int
:	O
0	int
;	O
}	O
char	O
*	O
grad_vendor_pec_to_name	(int)->(*(char))
(	O
int	O
pec	*(int)
)	O
{	O
grad_dict_vendor_t	struct(*(char),int,int)
*	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_list_locate	(*(struct),*(void),*((*(void),*(void))->(int)))->(*(void))
(	O
dictionary_vendors	*(struct)
,	O
&	O
pec	*(int)
,	O
pec_cmp	(*(void),*(void))->(int)
)	O
;	O
return	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
?	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
vendorname	*(char)
:	O
NULL	O
;	O
}	O
static	O
int	O
vendor_cmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
data	*(void)
)	O
{	O
const	O
grad_dict_vendor_t	struct(*(char),int,int)
*	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
=	O
item	*(void)
;	O
const	O
char	O
*	O
s	*(*(char))
=	O
data	*(void)
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
v	union(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
->	O
vendorname	*(char)
,	O
s	*(*(char))
)	O
;	O
}	O
int	O
grad_vendor_name_to_id	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
grad_dict_vendor_t	struct(*(char),int,int)
*	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
;	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
=	O
grad_list_locate	(*(struct),*(void),*((*(void),*(void))->(int)))->(*(void))
(	O
dictionary_vendors	*(struct)
,	O
name	*(char)
,	O
vendor_cmp	(*(void),*(void))->(int)
)	O
;	O
return	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
?	O
vp	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
vendorcode	int
:	O
0	int
;	O
}	O
struct	O
dict_iterator	struct(*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int)),*(void))
{	O
dict_iterator_fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
void	O
*	O
closure	*(void)
;	O
}	O
;	O
int	O
dict_iter_helper	(*(void),*(struct(*(struct(*`,*`)),*(char))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
grad_symbol_t	struct
*	O
symbol	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
)	O
{	O
struct	O
dict_iterator	struct(*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int)),*(void))
*	O
p	*(struct)
=	O
data	*(void)
;	O
DICT_SYMBOL	struct
*	O
dsym	*(struct(*(struct(*(struct`),*(char),enum(int,int,int),union(struct`,*`))),*(char),enum(int,int,int),union(struct(*(char),int,int,int,int,*((*`,*`)->(int))),*(struct(*`,int,int,int,int,*`)))))
=	O
(	O
DICT_SYMBOL	struct
*	O
)	O
symbol	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
;	O
grad_dict_attr_t	struct
*	O
attr	*(struct(*(char),int,int,int,int,*((*(struct`),*(*`))->(int))))
;	O
return	O
p	*(struct)
->	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
(	O
p	*(struct)
->	O
closure	*(void)
,	O
dsym	*(struct(*(struct(*(struct`),*(char),enum(int,int,int),union(struct`,*`))),*(char),enum(int,int,int),union(struct(*(char),int,int,int,int,*((*`,*`)->(int))),*(struct(*`,int,int,int,int,*`)))))
->	O
name	*(char)
,	O
dict_symbol_ptr	(*(struct(*(struct(*`,*`,enum(int,int,int),union`)),*(char),enum(int,int,int),union(struct(*`,int,int,int,int,*`),*(struct`)))))->(*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))
(	O
dsym	*(struct(*(struct(*(struct`),*(char),enum(int,int,int),union(struct`,*`))),*(char),enum(int,int,int),union(struct(*(char),int,int,int,int,*((*`,*`)->(int))),*(struct(*`,int,int,int,int,*`)))))
)	O
)	O
;	O
}	O
void	O
grad_dictionary_iterate	(*((*(void),*(char),*(struct(*`,int,int,int,int,*`)))->(int)),*(void))->(void)
(	O
dict_iterator_fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
void	O
*	O
closure	*(void)
)	O
{	O
static	O
struct	O
dict_iterator	struct(*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int)),*(void))
d	*(char)
;	O
d	*(char)
.	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
d	*(char)
.	O
closure	*(void)
=	O
closure	*(void)
;	O
grad_symtab_iterate	(*(struct(int,int,int,*(*(struct`)),*(()->(int)))),*((*(void),*(struct(*`,*`)))->(int)),*(void))->(void)
(	O
dict_attr_tab	*(struct(int,int,int,*(*(struct(*`,*`))),*(()->(int))))
,	O
dict_iter_helper	(*(void),*(struct(*(struct(*`,*`)),*(char))))->(int)
,	O
&	O
d	*(char)
)	O
;	O
}	O
struct	O
dict_value_iterator	struct(*((*(void),*(struct(*(char),*(struct`),int)))->(int)),*(void))
{	O
dict_value_iterator_fp	*((*(void),*(struct(*(char),*(struct`),int)))->(int))
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
void	O
*	O
closure	*(void)
;	O
}	O
;	O
static	O
int	O
dict_value_iter_helper	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
dict_value_iterator	struct(*((*(void),*(struct(*(char),*(struct`),int)))->(int)),*(void))
*	O
p	*(struct)
=	O
data	*(void)
;	O
return	O
p	*(struct)
->	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
(	O
p	*(struct)
->	O
closure	*(void)
,	O
item	*(void)
)	O
;	O
}	O
void	O
grad_dictionary_value_iterate	(*((*(void),*(struct(*`,*`,int)))->(int)),*(void))->(void)
(	O
dict_value_iterator_fp	*((*(void),*(struct(*(char),*(struct`),int)))->(int))
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
void	O
*	O
closure	*(void)
)	O
{	O
static	O
struct	O
dict_value_iterator	struct(*((*(void),*(struct(*(char),*(struct`),int)))->(int)),*(void))
d	*(char)
;	O
d	*(char)
.	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
d	*(char)
.	O
closure	*(void)
=	O
closure	*(void)
;	O
grad_list_iterate	(*(struct),*((*(void),*(void))->(int)),*(void))->(void)
(	O
dictionary_values	*(struct)
,	O
dict_value_iter_helper	(*(void),*(void))->(int)
,	O
&	O
d	*(char)
)	O
;	O
}	O
