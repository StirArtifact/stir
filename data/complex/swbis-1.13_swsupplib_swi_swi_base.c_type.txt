void	O
swi_vbase_init	(*(void),int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
void	O
*	O
derived	*(void)
,	O
int	O
type	enum(int,int,int,int)
,	O
SWHEADER	struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char))))
*	O
index	(*(char),int)->(*(char))
,	O
SWPATH_EX	struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char))
*	O
current	*(char)
)	O
{	O
SWI_BASE	struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),int,char,*(char))
*	O
base	int
=	O
&	O
(	O
(	O
(	O
SWI_BASE_Derived_	struct(struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*`,int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),int,char,*(char)))
*	O
)	O
derived	*(void)
)	O
->	O
baseM	struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),int,char,*(char))
)	O
;	O
int	O
current_file_offset	int
;	O
char	O
*	O
tag	*(char)
;	O
char	O
*	O
number	*(char)
;	O
int	O
ret	int
;	O
base	int
->	O
id_startM	char
=	O
SWI_BASE_ID_BEGIN	int
;	O
base	int
->	O
type_idM	char
=	O
type	enum(int,int,int,int)
;	O
base	int
->	O
is_activeM	int
=	O
0	int
;	O
base	int
->	O
b_tagM	*(char)
=	O
NULL	O
;	O
base	int
->	O
create_timeM	long
=	O
0	int
;	O
base	int
->	O
mod_timeM	long
=	O
0	int
;	O
base	int
->	O
global_headerM	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
=	O
index	(*(char),int)->(*(char))
;	O
base	int
->	O
verboseM	int
=	O
1	int
;	O
base	int
->	O
swveridM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
=	O
swverid_open	(*(char),*(char))->(*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)))
(	O
NULL	O
,	O
NULL	O
)	O
;	O
base	int
->	O
id_endM	char
=	O
SWI_BASE_ID_END	int
;	O
base	int
->	O
numberM	*(char)
=	O
NULL	O
;	O
if	O
(	O
index	(*(char),int)->(*(char))
&&	O
current	*(char)
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
SWI_I_TYPE_PROD	char
)	O
swverid_set_namespace	(*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(char))->(void)
(	O
base	int
->	O
swveridM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
,	O
SW_A_product	*(char)
)	O
;	O
else	O
swverid_set_namespace	(*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(char))->(void)
(	O
base	int
->	O
swveridM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
,	O
SW_A_fileset	*(char)
)	O
;	O
ret	int
=	O
swi_com_set_header_index	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(int,int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char))),*(int))->(int)
(	O
index	(*(char),int)->(*(char))
,	O
current	*(char)
,	O
&	O
(	O
base	int
->	O
header_indexM	int
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"swinstall:  Fatal: the section of the Global INDEX file belonging\n"	*(char)
"swinstall:  Fatal: to a package file could not be determined.\n"	*(char)
)	O
;	O
}	O
SWLIB_ASSERT	O
(	O
ret	int
==	O
0	int
)	O
;	O
current_file_offset	int
=	O
swheader_get_current_offset	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))))->(int)
(	O
index	(*(char),int)->(*(char))
)	O
;	O
swheader_set_current_offset	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),int)->(void)
(	O
index	(*(char),int)->(*(char))
,	O
base	int
->	O
header_indexM	int
)	O
;	O
tag	*(char)
=	O
swheader_get_single_attribute_value	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char))->(*(char))
(	O
index	(*(char),int)->(*(char))
,	O
SW_A_tag	*(char)
)	O
;	O
swheader_set_current_offset	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),int)->(void)
(	O
index	(*(char),int)->(*(char))
,	O
current_file_offset	int
)	O
;	O
if	O
(	O
!	O
tag	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"swinstall: Fatal: tag attribute not found\n"	*(char)
)	O
;	O
}	O
SWLIB_ASSERT	O
(	O
tag	*(char)
!=	O
NULL	O
)	O
;	O
base	int
->	O
b_tagM	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
tag	*(char)
)	O
;	O
number	*(char)
=	O
swheader_get_single_attribute_value	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char))->(*(char))
(	O
index	(*(char),int)->(*(char))
,	O
SW_A_number	*(char)
)	O
;	O
if	O
(	O
number	*(char)
)	O
{	O
base	int
->	O
numberM	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
number	*(char)
)	O
;	O
}	O
else	O
{	O
base	int
->	O
numberM	*(char)
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
base	int
->	O
header_indexM	int
=	O
0	int
;	O
base	int
->	O
b_tagM	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
""	*(char)
)	O
;	O
}	O
}	O
void	O
swi_base_assert	(*(struct(char,char,int,*(char),long,long,int,*(struct(*`,*`,array(*(void)),*`,int,struct`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),int,char,*(char))))->(void)
(	O
SWI_BASE	struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),int,char,*(char))
*	O
base	int
)	O
{	O
SWLIB_ASSERT	O
(	O
base	int
->	O
id_startM	char
==	O
SWI_BASE_ID_BEGIN	int
)	O
;	O
SWLIB_ASSERT	O
(	O
base	int
->	O
id_endM	char
==	O
SWI_BASE_ID_END	int
)	O
;	O
}	O
void	O
swi_base_set_is_active	(*(struct(char,char,int,*(char),long,long,int,*(struct(*`,*`,array(*(void)),*`,int,struct`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),int,char,*(char))),int)->(void)
(	O
SWI_BASE	struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),int,char,*(char))
*	O
base	int
,	O
int	O
n	long
)	O
{	O
base	int
->	O
is_activeM	int
=	O
n	long
;	O
}	O
int	O
swi_vbase_update	(*(void),*(void))->(int)
(	O
void	O
*	O
vbase	*(void)
,	O
void	O
*	O
user_defined_parameter	*(void)
)	O
{	O
SWI_BASE	struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),int,char,*(char))
*	O
base	int
=	O
&	O
(	O
(	O
(	O
SWI_BASE_Derived_	struct(struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*`,int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),int,char,*(char)))
*	O
)	O
vbase	*(void)
)	O
->	O
baseM	struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),int,char,*(char))
)	O
;	O
swi_base_assert	(*(struct(char,char,int,*(char),long,long,int,*(struct(*`,*`,array(*(void)),*`,int,struct`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),int,char,*(char))))->(void)
(	O
base	int
)	O
;	O
base	int
->	O
is_activeM	int
=	O
1	int
;	O
if	O
(	O
base	int
->	O
create_timeM	long
==	O
0	int
)	O
{	O
time	struct(long,long)
(	O
&	O
(	O
base	int
->	O
create_timeM	long
)	O
)	O
;	O
}	O
time	struct(long,long)
(	O
&	O
(	O
base	int
->	O
mod_timeM	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swi_vbase_generate_swverid	(*(void),*(void))->(int)
(	O
void	O
*	O
derived	*(void)
,	O
void	O
*	O
user_defined_parameter	*(void)
)	O
{	O
SWI_BASE	struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),int,char,*(char))
*	O
base	int
=	O
&	O
(	O
(	O
(	O
SWI_BASE_Derived_	struct(struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*`,int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),int,char,*(char)))
*	O
)	O
derived	*(void)
)	O
->	O
baseM	struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),int,char,*(char))
)	O
;	O
int	O
current_file_offset	int
;	O
char	O
*	O
obj	*(char)
;	O
char	O
*	O
tag	*(char)
;	O
char	O
*	O
next_attr	*(char)
;	O
int	O
ret	int
;	O
swi_base_assert	(*(struct(char,char,int,*(char),long,long,int,*(struct(*`,*`,array(*(void)),*`,int,struct`,*`)),*(struct(*`,*`,*`,int,*`,int,int,*`,*`,*`,int)),int,char,*(char))))->(void)
(	O
base	int
)	O
;	O
ret	int
=	O
0	int
;	O
current_file_offset	int
=	O
swheader_get_current_offset	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))))->(int)
(	O
base	int
->	O
global_headerM	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
)	O
;	O
swheader_set_current_offset	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),int)->(void)
(	O
base	int
->	O
global_headerM	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
base	int
->	O
header_indexM	int
)	O
;	O
if	O
(	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"<<< New Object \n"	*(char)
)	O
;	O
obj	*(char)
=	O
swheader_get_current_line	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))))->(*(char))
(	O
base	int
->	O
global_headerM	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
)	O
;	O
swheaderline_write_debug	(*(char),int)->(int)
(	O
obj	*(char)
,	O
STDERR_FILENO	int
)	O
;	O
while	O
(	O
(	O
next_attr	*(char)
=	O
swheader_get_next_attribute	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))))->(*(char))
(	O
base	int
->	O
global_headerM	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
)	O
)	O
)	O
swheaderline_write_debug	(*(char),int)->(int)
(	O
next_attr	*(char)
,	O
STDERR_FILENO	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"<<<\n"	*(char)
)	O
;	O
}	O
obj	*(char)
=	O
swheader_get_current_line	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))))->(*(char))
(	O
base	int
->	O
global_headerM	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
)	O
;	O
tag	*(char)
=	O
swheader_get_single_attribute_value	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(char))->(*(char))
(	O
base	int
->	O
global_headerM	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
SW_A_tag	*(char)
)	O
;	O
if	O
(	O
swheaderline_get_type	(*(char))->(char)
(	O
obj	*(char)
)	O
!=	O
SWPARSE_MD_TYPE_OBJ	char
)	O
{	O
SWBIS_IMPL_ERROR_DIE	O
(	O
1	int
)	O
;	O
}	O
ret	int
=	O
swheader_generate_swverid	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),*(char))->(int)
(	O
base	int
->	O
global_headerM	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
base	int
->	O
swveridM	*(struct(*(char),*(char),*(char),int,*(struct(*(*`),int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*(char),*(struct`))),*(struct(*(char),*(char),*(char),*(char),*(char),char,char,char,char,int)),*(void),int))
,	O
obj	*(char)
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
base	int
->	O
verboseM	int
,	O
SWC_VERBOSE_1	int
,	O
(	O
NULL	O
)	O
,	O
STDERR_FILENO	int
,	O
"error generating version id for %s [tag=%s]\n"	*(char)
,	O
swheaderline_get_keyword	(*(char))->(*(char))
(	O
obj	*(char)
)	O
,	O
tag	*(char)
)	O
;	O
if	O
(	O
base	int
->	O
verboseM	int
>=	O
SWC_VERBOSE_8	int
)	O
{	O
obj	*(char)
=	O
swheader_get_current_line	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))))->(*(char))
(	O
base	int
->	O
global_headerM	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
)	O
;	O
swheaderline_write_debug	(*(char),int)->(int)
(	O
obj	*(char)
,	O
STDERR_FILENO	int
)	O
;	O
while	O
(	O
(	O
next_attr	*(char)
=	O
swheader_get_next_attribute	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))))->(*(char))
(	O
base	int
->	O
global_headerM	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
)	O
)	O
)	O
swheaderline_write_debug	(*(char),int)->(int)
(	O
next_attr	*(char)
,	O
STDERR_FILENO	int
)	O
;	O
}	O
}	O
swheader_set_current_offset	(*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),int)->(void)
(	O
base	int
->	O
global_headerM	*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*(void),*(int),int)->(*(char)))))
,	O
current_file_offset	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swi_vbase_set_verbose_level	(*(void),*(void))->(int)
(	O
void	O
*	O
derived	*(void)
,	O
void	O
*	O
verbose_level	int
)	O
{	O
SWI_BASE	struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),int,char,*(char))
*	O
base	int
=	O
&	O
(	O
(	O
(	O
SWI_BASE_Derived_	struct(struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*`,int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct`),int,int,*(struct`),*(struct`),*(void),int)),int,char,*(char)))
*	O
)	O
derived	*(void)
)	O
->	O
baseM	struct(char,char,int,*(char),long,long,int,*(struct(*(char),*(void),array(*(void)),*(int),int,struct(*(int),int,int),*((*`,*`,int)->(*`)))),*(struct(*(char),*(char),*(char),int,*(struct(*`,int,int,long,int)),int,int,*(struct(array(char),array(char),array(char),array(char),int,*`,*`)),*(struct(*`,*`,*`,*`,*`,char,char,char,char,int)),*(void),int)),int,char,*(char))
)	O
;	O
base	int
->	O
verboseM	int
=	O
*	O
(	O
(	O
int	O
*	O
)	O
verbose_level	int
)	O
;	O
return	O
0	int
;	O
}	O
