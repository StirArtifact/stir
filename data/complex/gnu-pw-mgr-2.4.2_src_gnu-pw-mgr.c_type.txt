static	O
char	O
*	O
dom_text	*(char)
=	O
NULL	O
;	O
static	O
char	O
const	O
*	O
dom_file_name	*(char)
=	O
NULL	O
;	O
static	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
=	O
{	O
.	O
st_size	long
=	O
0	int
}	O
;	O
static	O
off_t	long
dom_text_len	long
=	O
0	int
;	O
static	O
char	O
*	O
load_file	(*(char))->(*(char))
(	O
char	O
const	O
*	O
fname	*(char)
)	O
{	O
char	O
*	O
txt	*(char)
;	O
char	O
*	O
scn	*(char)
;	O
size_t	long
sz	long
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
fname	*(char)
,	O
&	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
fserr	(int,*(char),*(char))->(void)
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
"stat"	*(char)
,	O
fname	*(char)
)	O
;	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
=	O
4096	int
;	O
txt	*(char)
=	O
malloc	(long)->(*(void))
(	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
;	O
txt	*(char)
[	O
0	int
]	O
=	O
NUL	char
;	O
return	O
txt	*(char)
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
fserr	(int,*(char),*(char))->(void)
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
"stat"	*(char)
,	O
fname	*(char)
)	O
;	O
}	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fname	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
fserr	(int,*(char),*(char))->(void)
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
"fopen 'r'"	*(char)
,	O
fname	*(char)
)	O
;	O
sz	long
=	O
(	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
+	O
4096	int
)	O
&	O
~	O
4096	int
;	O
txt	*(char)
=	O
scn	*(char)
=	O
malloc	(long)->(*(void))
(	O
sz	long
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
rdsz	long
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
scn	*(char)
,	O
1	int
,	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
rdsz	long
==	O
0	int
)	O
break	O
;	O
scn	*(char)
+=	O
rdsz	long
;	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
-=	O
rdsz	long
;	O
if	O
(	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
==	O
0	int
)	O
break	O
;	O
}	O
*	O
scn	*(char)
=	O
NUL	char
;	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
=	O
sz	long
;	O
dom_text_len	long
=	O
(	O
scn	*(char)
-	O
txt	*(char)
)	O
;	O
dom_text	*(char)
=	O
txt	*(char)
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
txt	*(char)
;	O
}	O
static	O
void	O
set_confirm_value	(*(char),long,*(char),long,*(char))->(void)
(	O
char	O
*	O
buf	array(char)
,	O
size_t	long
bsz	long
,	O
unsigned	O
char	O
*	O
data	*(char)
,	O
size_t	long
d_len	long
,	O
char	O
const	O
*	O
pwd_id_str	*(char)
)	O
{	O
const	O
int	O
buf_off	int
=	O
CONFIRM_LEN	int
+	O
1	int
;	O
assert	O
(	O
bsz	long
>	O
(	O
buf_off	int
*	O
2	int
)	O
)	O
;	O
base64_encode	(*(char),long,*(char),long)->(void)
(	O
(	O
char	O
*	O
)	O
data	*(char)
,	O
d_len	long
,	O
buf	array(char)
,	O
buf_off	int
)	O
;	O
buf	array(char)
[	O
buf_off	int
-	O
1	int
]	O
=	O
buf	array(char)
[	O
buf_off	int
]	O
=	O
' '	O
;	O
{	O
union	O
{	O
uintptr_t	long
data	*(char)
[	O
256	int
/	O
(	O
NBBY	int
*	O
sizeof	O
(	O
uintptr_t	long
)	O
)	O
]	O
;	O
unsigned	O
char	O
sha_buf	array(char)
[	O
256	int
/	O
NBBY	int
]	O
;	O
}	O
sum	union(array(long),array(char))
;	O
struct	O
sha256_ctx	struct(array(int),array(int),long,array(int))
ctx	*(struct(int,array(char)))
;	O
sha256_init_ctx	(*(struct(array(int),array(int),long,array(int))))->(void)
(	O
&	O
ctx	*(struct(int,array(char)))
)	O
;	O
sha256_process_bytes	(*(void),long,*(struct(array(int),array(int),long,array(int))))->(void)
(	O
pwd_id_str	*(char)
,	O
strlen	(*(char))->(long)
(	O
pwd_id_str	*(char)
)	O
+	O
1	int
,	O
&	O
ctx	*(struct(int,array(char)))
)	O
;	O
sha256_process_bytes	(*(void),long,*(struct(array(int),array(int),long,array(int))))->(void)
(	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
,	O
strlen	(*(char))->(long)
(	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
)	O
+	O
1	int
,	O
&	O
ctx	*(struct(int,array(char)))
)	O
;	O
sha256_finish_ctx	(*(struct(array(int),array(int),long,array(int))),*(void))->(*(void))
(	O
&	O
ctx	*(struct(int,array(char)))
,	O
sum	union(array(long),array(char))
.	O
sha_buf	array(char)
)	O
;	O
base64_encode	(*(char),long,*(char),long)->(void)
(	O
(	O
char	O
*	O
)	O
sum	union(array(long),array(char))
.	O
sha_buf	array(char)
,	O
sizeof	O
(	O
sum	union(array(long),array(char))
.	O
sha_buf	array(char)
)	O
,	O
buf	array(char)
+	O
buf_off	int
+	O
1	int
,	O
bsz	long
-	O
buf_off	int
-	O
1	int
)	O
;	O
}	O
buf	array(char)
[	O
buf_off	int
+	O
CONFIRM_LEN	int
+	O
1	int
]	O
=	O
NUL	char
;	O
fix_lower_only_pw	(*(char))->(void)
(	O
buf	array(char)
)	O
;	O
buf	array(char)
[	O
buf_off	int
-	O
1	int
]	O
=	O
buf	array(char)
[	O
buf_off	int
]	O
=	O
' '	O
;	O
}	O
static	O
void	O
adjust_pw	(*(char),long,*(char),long,*(char))->(void)
(	O
char	O
*	O
buf	array(char)
,	O
size_t	long
bsz	long
,	O
unsigned	O
char	O
*	O
data	*(char)
,	O
size_t	long
d_len	long
,	O
char	O
const	O
*	O
pwd_id_str	*(char)
)	O
{	O
char	O
*	O
dta	*(char)
=	O
(	O
char	O
*	O
)	O
data	*(char)
;	O
unsigned	O
int	O
cclass	int
=	O
OPT_VALUE_CCLASS	O
&	O
(	O
CCLASS_NO_ALPHA	int
|	O
CCLASS_NO_SPECIAL	int
)	O
;	O
if	O
(	O
cclass	int
==	O
(	O
CCLASS_NO_ALPHA	int
|	O
CCLASS_NO_SPECIAL	int
)	O
)	O
{	O
static	O
uint32_t	int
const	O
bytes_per_val	int
=	O
7	int
;	O
uint32_t	int
mx	int
=	O
(	O
d_len	long
/	O
sizeof	O
(	O
uintptr_t	long
)	O
)	O
*	O
bytes_per_val	int
;	O
if	O
(	O
OPT_VALUE_LENGTH	O
>	O
mx	int
)	O
die	(int,*(char))->(void)
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
pin_too_big	O
,	O
(	O
uint32_t	int
)	O
OPT_VALUE_LENGTH	O
,	O
mx	int
)	O
;	O
fix_digit_pw	(*(char),*(long))->(void)
(	O
buf	array(char)
,	O
(	O
uintptr_t	long
*	O
)	O
(	O
uintptr_t	long
)	O
data	*(char)
)	O
;	O
}	O
else	O
{	O
base64_encode	(*(char),long,*(char),long)->(void)
(	O
dta	*(char)
,	O
d_len	long
,	O
buf	array(char)
,	O
bsz	long
)	O
;	O
buf	array(char)
[	O
OPT_VALUE_LENGTH	O
]	O
=	O
NUL	char
;	O
if	O
(	O
cclass	int
==	O
CCLASS_NO_ALPHA	int
)	O
fix_no_alpha_pw	(*(char))->(void)
(	O
buf	array(char)
)	O
;	O
else	O
fix_std_pw	(*(char))->(void)
(	O
buf	array(char)
)	O
;	O
}	O
}	O
static	O
void	O
get_dft_pw	(*(char),long,*(char),*(char),*(char))->(void)
(	O
char	O
*	O
buf	array(char)
,	O
size_t	long
bsz	long
,	O
char	O
const	O
*	O
tag	*(char)
,	O
char	O
const	O
*	O
txt	*(char)
,	O
char	O
const	O
*	O
pwd_id_str	*(char)
)	O
{	O
union	O
{	O
uintptr_t	long
data	*(char)
[	O
256	int
/	O
(	O
NBBY	int
*	O
sizeof	O
(	O
uintptr_t	long
)	O
)	O
]	O
;	O
unsigned	O
char	O
sha_buf	array(char)
[	O
256	int
/	O
NBBY	int
]	O
;	O
}	O
sum	union(array(long),array(char))
;	O
struct	O
sha256_ctx	struct(array(int),array(int),long,array(int))
ctx	*(struct(int,array(char)))
;	O
sha256_init_ctx	(*(struct(array(int),array(int),long,array(int))))->(void)
(	O
&	O
ctx	*(struct(int,array(char)))
)	O
;	O
sha256_process_bytes	(*(void),long,*(struct(array(int),array(int),long,array(int))))->(void)
(	O
tag	*(char)
,	O
strlen	(*(char))->(long)
(	O
tag	*(char)
)	O
+	O
1	int
,	O
&	O
ctx	*(struct(int,array(char)))
)	O
;	O
sha256_process_bytes	(*(void),long,*(struct(array(int),array(int),long,array(int))))->(void)
(	O
txt	*(char)
,	O
strlen	(*(char))->(long)
(	O
txt	*(char)
)	O
+	O
1	int
,	O
&	O
ctx	*(struct(int,array(char)))
)	O
;	O
sha256_process_bytes	(*(void),long,*(struct(array(int),array(int),long,array(int))))->(void)
(	O
pwd_id_str	*(char)
,	O
strlen	(*(char))->(long)
(	O
pwd_id_str	*(char)
)	O
+	O
1	int
,	O
&	O
ctx	*(struct(int,array(char)))
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
CONFIRM	O
)	O
)	O
sha256_process_bytes	(*(void),long,*(struct(array(int),array(int),long,array(int))))->(void)
(	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
,	O
strlen	(*(char))->(long)
(	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
)	O
+	O
1	int
,	O
&	O
ctx	*(struct(int,array(char)))
)	O
;	O
sha256_finish_ctx	(*(struct(array(int),array(int),long,array(int))),*(void))->(*(void))
(	O
&	O
ctx	*(struct(int,array(char)))
,	O
sum	union(array(long),array(char))
.	O
sha_buf	array(char)
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
CONFIRM	O
)	O
)	O
set_confirm_value	(*(char),long,*(char),long,*(char))->(void)
(	O
buf	array(char)
,	O
bsz	long
,	O
sum	union(array(long),array(char))
.	O
sha_buf	array(char)
,	O
sizeof	O
(	O
sum	union(array(long),array(char))
.	O
sha_buf	array(char)
)	O
,	O
pwd_id_str	*(char)
)	O
;	O
else	O
adjust_pw	(*(char),long,*(char),long,*(char))->(void)
(	O
buf	array(char)
,	O
bsz	long
,	O
sum	union(array(long),array(char))
.	O
sha_buf	array(char)
,	O
sizeof	O
(	O
sum	union(array(long),array(char))
.	O
sha_buf	array(char)
)	O
,	O
pwd_id_str	*(char)
)	O
;	O
}	O
static	O
void	O
get_pbkdf2_pw	(*(char),long,*(char),*(char),*(char))->(void)
(	O
char	O
*	O
buf	array(char)
,	O
size_t	long
bsz	long
,	O
char	O
const	O
*	O
tag	*(char)
,	O
char	O
const	O
*	O
salt	*(char)
,	O
char	O
const	O
*	O
pwd_id_str	*(char)
)	O
{	O
size_t	long
const	O
stag_len	long
=	O
strlen	(*(char))->(long)
(	O
tag	*(char)
)	O
+	O
1	int
;	O
size_t	long
const	O
salt_len	long
=	O
strlen	(*(char))->(long)
(	O
salt	*(char)
)	O
+	O
1	int
;	O
size_t	long
const	O
pwid_len	long
=	O
strlen	(*(char))->(long)
(	O
pwd_id_str	*(char)
)	O
+	O
1	int
;	O
size_t	long
const	O
conf_len	long
=	O
HAVE_OPT	O
(	O
CONFIRM	O
)	O
?	O
(	O
strlen	(*(char))->(long)
(	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
)	O
+	O
1	int
)	O
:	O
0	int
;	O
size_t	long
const	O
hash_src_len	long
=	O
stag_len	long
+	O
pwid_len	long
+	O
conf_len	long
;	O
size_t	long
const	O
hash_out_len	long
=	O
4	int
+	O
(	O
(	O
bsz	long
*	O
6	int
)	O
>>	O
3	int
)	O
;	O
char	O
*	O
hash_source	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
hash_src_len	long
)	O
;	O
char	O
*	O
hash_output	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
hash_out_len	long
)	O
;	O
Gc_rc	enum(int,int,int,int,int,int,int,int,int)
rc	enum(int,int,int,int,int,int,int,int,int)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hash_source	*(char)
,	O
tag	*(char)
,	O
stag_len	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hash_source	*(char)
+	O
stag_len	long
,	O
pwd_id_str	*(char)
,	O
pwid_len	long
)	O
;	O
if	O
(	O
conf_len	long
>	O
0	int
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hash_source	*(char)
+	O
stag_len	long
+	O
pwid_len	long
,	O
OPT_ARG	O
(	O
CONFIRM	O
)	O
,	O
conf_len	long
)	O
;	O
rc	enum(int,int,int,int,int,int,int,int,int)
=	O
gc_pbkdf2_sha1	(*(char),long,*(char),long,int,*(char),long)->(enum(int,int,int,int,int,int,int,int,int))
(	O
hash_source	*(char)
,	O
hash_src_len	long
,	O
salt	*(char)
,	O
salt_len	long
,	O
OPT_VALUE_PBKDF2	O
,	O
hash_output	*(char)
,	O
hash_out_len	long
)	O
;	O
if	O
(	O
rc	enum(int,int,int,int,int,int,int,int,int)
!=	O
GC_OK	int
)	O
die	(int,*(char))->(void)
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
pbkdf2_err_fmt	O
,	O
rc	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
CONFIRM	O
)	O
)	O
set_confirm_value	(*(char),long,*(char),long,*(char))->(void)
(	O
buf	array(char)
,	O
bsz	long
,	O
(	O
unsigned	O
char	O
*	O
)	O
hash_output	*(char)
,	O
hash_out_len	long
,	O
pwd_id_str	*(char)
)	O
;	O
else	O
adjust_pw	(*(char),long,*(char),long,*(char))->(void)
(	O
buf	array(char)
,	O
bsz	long
,	O
(	O
unsigned	O
char	O
*	O
)	O
hash_output	*(char)
,	O
hash_out_len	long
,	O
pwd_id_str	*(char)
)	O
;	O
}	O
static	O
void	O
print_pwid_header	(*(char))->(void)
(	O
char	O
const	O
*	O
pwd_id_str	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
pwid_hdr_fmt	O
,	O
pwd_id_str	*(char)
,	O
ENABLED_OPT	O
(	O
SHARED	O
)	O
?	O
pwid_shared	O
:	O
""	*(char)
)	O
;	O
}	O
static	O
void	O
print_pwid_status	(*(char))->(void)
(	O
char	O
const	O
*	O
pwd_id_str	*(char)
)	O
{	O
bool	bool
have_data	bool
=	O
false	int
;	O
if	O
(	O
HAVE_OPT	O
(	O
LOGIN_ID	O
)	O
)	O
{	O
have_data	bool
=	O
true	int
;	O
print_pwid_header	(*(char))->(void)
(	O
pwd_id_str	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
pwst_str_fmt	O
,	O
"login-id"	*(char)
,	O
OPT_ARG	O
(	O
LOGIN_ID	O
)	O
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
LENGTH	O
)	O
)	O
{	O
if	O
(	O
!	O
have_data	bool
)	O
{	O
print_pwid_header	(*(char))->(void)
(	O
pwd_id_str	*(char)
)	O
;	O
have_data	bool
=	O
true	int
;	O
}	O
printf	(*(char))->(int)
(	O
pwst_dig_fmt	O
,	O
"length"	*(char)
,	O
(	O
unsigned	O
int	O
)	O
OPT_VALUE_LENGTH	O
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
PBKDF2	O
)	O
||	O
(	O
OPT_VALUE_LENGTH	O
>	O
(	O
MIN_BUF_LEN	O
-	O
8	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
have_data	bool
)	O
{	O
print_pwid_header	(*(char))->(void)
(	O
pwd_id_str	*(char)
)	O
;	O
have_data	bool
=	O
true	int
;	O
}	O
if	O
(	O
ENABLED_OPT	O
(	O
PBKDF2	O
)	O
||	O
(	O
OPT_VALUE_LENGTH	O
>	O
(	O
MIN_BUF_LEN	O
-	O
8	int
)	O
)	O
)	O
printf	(*(char))->(int)
(	O
pwst_dig_fmt	O
,	O
"pbkdf2 ct"	*(char)
,	O
(	O
unsigned	O
int	O
)	O
OPT_VALUE_PBKDF2	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
pwst_str_fmt	O
,	O
"pbkdf2"	*(char)
,	O
"not used"	*(char)
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
SPECIALS	O
)	O
)	O
{	O
if	O
(	O
!	O
have_data	bool
)	O
{	O
print_pwid_header	(*(char))->(void)
(	O
pwd_id_str	*(char)
)	O
;	O
have_data	bool
=	O
true	int
;	O
}	O
printf	(*(char))->(int)
(	O
pwst_str_fmt	O
,	O
"spec chars"	*(char)
,	O
OPT_ARG	O
(	O
SPECIALS	O
)	O
)	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
CCLASS	O
)	O
)	O
{	O
char	O
const	O
*	O
names	array(*(char))
;	O
if	O
(	O
!	O
have_data	bool
)	O
{	O
print_pwid_header	(*(char))->(void)
(	O
pwd_id_str	*(char)
)	O
;	O
have_data	bool
=	O
true	int
;	O
}	O
doOptCclass	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
OPTPROC_RETURN_VALNAME	O
,	O
&	O
DESC	O
(	O
CCLASS	O
)	O
)	O
;	O
names	array(*(char))
=	O
DESC	O
(	O
CCLASS	O
)	O
.	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argString	*(char)
;	O
printf	(*(char))->(int)
(	O
pwst_str_fmt	O
,	O
"ch-class"	*(char)
,	O
names	array(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
(	O
void	O
*	O
)	O
names	array(*(char))
)	O
;	O
}	O
if	O
(	O
!	O
have_data	bool
)	O
printf	(*(char))->(int)
(	O
"The %s password id has all default settings\n"	*(char)
,	O
pwd_id_str	*(char)
)	O
;	O
else	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
PBKDF2	O
)	O
)	O
printf	(*(char))->(int)
(	O
pwst_dig_dft	O
,	O
"pbkdf2 ct"	*(char)
,	O
(	O
unsigned	O
int	O
)	O
OPT_VALUE_PBKDF2	O
)	O
;	O
}	O
static	O
void	O
select_chars	(*(char))->(void)
(	O
unsigned	O
char	O
*	O
txtbuf	*(char)
)	O
{	O
int	O
const	O
len	long
=	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
txtbuf	*(char)
)	O
;	O
char	O
*	O
pn	*(char)
=	O
NULL	O
;	O
char	O
const	O
*	O
p	*(void)
=	O
OPT_ARG	O
(	O
SELECT_CHARS	O
)	O
;	O
char	O
buf	array(char)
[	O
64	int
]	O
,	O
*	O
pd	*(char)
=	O
buf	array(char)
;	O
int	O
const	O
lim	int
=	O
(	O
len	long
>	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
?	O
sizeof	O
(	O
buf	array(char)
)	O
:	O
len	long
;	O
errno	O
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
long	O
v	union(array(char),int,int,long,long,*(void))
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
p	*(void)
,	O
&	O
pn	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
(	O
errno	O
!=	O
0	int
)	O
||	O
(	O
v	union(array(char),int,int,long,long,*(void))
<	O
1	int
)	O
||	O
(	O
v	union(array(char),int,int,long,long,*(void))
>	O
len	long
)	O
)	O
die	(int,*(char))->(void)
(	O
GNU_PW_MGR_EXIT_BAD_SELECT_CHARS	int
,	O
OPT_ARG	O
(	O
SELECT_CHARS	O
)	O
)	O
;	O
*	O
(	O
pd	*(char)
++	O
)	O
=	O
txtbuf	*(char)
[	O
v	union(array(char),int,int,long,long,*(void))
-	O
1	int
]	O
;	O
if	O
(	O
pd	*(char)
>=	O
buf	array(char)
+	O
lim	int
)	O
die	(int,*(char))->(void)
(	O
GNU_PW_MGR_EXIT_BAD_SELECT_CHARS	int
,	O
OPT_ARG	O
(	O
SELECT_CHARS	O
)	O
)	O
;	O
p	*(void)
=	O
pn	*(char)
+	O
strspn	(*(char),*(char))->(long)
(	O
pn	*(char)
,	O
" ,"	*(char)
)	O
;	O
if	O
(	O
*	O
p	*(void)
==	O
NUL	char
)	O
break	O
;	O
}	O
*	O
pd	*(char)
=	O
NUL	char
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
(	O
char	O
*	O
)	O
txtbuf	*(char)
,	O
buf	array(char)
)	O
;	O
}	O
static	O
bool	bool
print_one_pwid	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))),*(char))->(bool)
(	O
tOptionValue	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))
const	O
*	O
seed_opt	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
,	O
char	O
const	O
*	O
pwd_id_str	*(char)
)	O
{	O
if	O
(	O
seed_opt	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
->	O
valType	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
OPARG_TYPE_HIERARCHY	int
)	O
die	(int,*(char))->(void)
(	O
GNU_PW_MGR_EXIT_BAD_SEED	int
,	O
bad_seed	O
)	O
;	O
{	O
tOptionValue	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))
const	O
*	O
ver	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
=	O
optionGetValue	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))),*(char))->(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))))
(	O
seed_opt	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
,	O
s_ver_z	O
)	O
;	O
if	O
(	O
(	O
ver	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
==	O
NULL	O
)	O
||	O
(	O
ver	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
->	O
valType	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
OPARG_TYPE_NUMERIC	int
)	O
)	O
{	O
tOptionValue	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))
const	O
*	O
tag	*(char)
=	O
optionGetValue	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))),*(char))->(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))))
(	O
seed_opt	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
,	O
tag_z	O
)	O
;	O
warning_msg	(*(char))->(void)
(	O
too_old_z	O
,	O
tag	*(char)
->	O
v	union(array(char),int,int,long,long,*(void))
.	O
strVal	array(char)
)	O
;	O
return	O
false	int
;	O
}	O
}	O
{	O
tOptionValue	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))
const	O
*	O
sec	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
=	O
optionGetValue	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))),*(char))->(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))))
(	O
seed_opt	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
,	O
sec_pw_id	O
)	O
;	O
if	O
(	O
(	O
sec	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
==	O
NULL	O
)	O
!=	O
(	O
!	O
HAVE_OPT	O
(	O
SHARED	O
)	O
)	O
)	O
return	O
false	int
;	O
}	O
tOptionValue	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))
const	O
*	O
tag	*(char)
=	O
optionGetValue	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))),*(char))->(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))))
(	O
seed_opt	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
,	O
tag_z	O
)	O
;	O
tOptionValue	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))
const	O
*	O
txt	*(char)
=	O
optionGetValue	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))),*(char))->(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))))
(	O
seed_opt	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
,	O
text_z	O
)	O
;	O
if	O
(	O
(	O
tag	*(char)
->	O
valType	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
OPARG_TYPE_STRING	int
)	O
||	O
(	O
tag	*(char)
->	O
valType	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
OPARG_TYPE_STRING	int
)	O
)	O
die	(int,*(char))->(void)
(	O
GNU_PW_MGR_EXIT_BAD_SEED	int
,	O
bad_seed	O
)	O
;	O
size_t	long
buf_len	long
=	O
(	O
OPT_VALUE_LENGTH	O
>	O
(	O
MIN_BUF_LEN	O
-	O
8	int
)	O
)	O
?	O
OPT_VALUE_LENGTH	O
+	O
16	int
:	O
MIN_BUF_LEN	O
;	O
unsigned	O
char	O
*	O
txtbuf	*(char)
=	O
scribble_get	(long)->(*(void))
(	O
buf_len	long
)	O
;	O
if	O
(	O
(	O
OPT_VALUE_PBKDF2	O
==	O
0	int
)	O
||	O
!	O
ENABLED_OPT	O
(	O
PBKDF2	O
)	O
||	O
(	O
OPT_VALUE_LENGTH	O
>	O
(	O
MIN_BUF_LEN	O
-	O
8	int
)	O
)	O
)	O
get_dft_pw	(*(char),long,*(char),*(char),*(char))->(void)
(	O
(	O
char	O
*	O
)	O
txtbuf	*(char)
,	O
buf_len	long
,	O
tag	*(char)
->	O
v	union(array(char),int,int,long,long,*(void))
.	O
strVal	array(char)
,	O
txt	*(char)
->	O
v	union(array(char),int,int,long,long,*(void))
.	O
strVal	array(char)
,	O
pwd_id_str	*(char)
)	O
;	O
else	O
get_pbkdf2_pw	(*(char),long,*(char),*(char),*(char))->(void)
(	O
(	O
char	O
*	O
)	O
txtbuf	*(char)
,	O
buf_len	long
,	O
tag	*(char)
->	O
v	union(array(char),int,int,long,long,*(void))
.	O
strVal	array(char)
,	O
txt	*(char)
->	O
v	union(array(char),int,int,long,long,*(void))
.	O
strVal	array(char)
,	O
pwd_id_str	*(char)
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
SELECT_CHARS	O
)	O
)	O
select_chars	(*(char))->(void)
(	O
txtbuf	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
pw_fmt	O
,	O
tag	*(char)
->	O
v	union(array(char),int,int,long,long,*(void))
.	O
strVal	array(char)
,	O
txtbuf	*(char)
)	O
;	O
return	O
true	int
;	O
}	O
static	O
void	O
print_pwid	(*(char))->(void)
(	O
char	O
const	O
*	O
pwd_id_str	*(char)
)	O
{	O
tOptionValue	struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))
const	O
*	O
ov	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
=	O
optionFindValue	(*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(char))->(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))))
(	O
&	O
DESC	O
(	O
SEED	O
)	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
bool	bool
printed_pw	bool
=	O
false	int
;	O
if	O
(	O
*	O
pwd_id_str	*(char)
==	O
NUL	char
)	O
die	(int,*(char))->(void)
(	O
GNU_PW_MGR_EXIT_NO_PWID	int
,	O
no_pwid	O
)	O
;	O
set_pwid_opts	(*(char))->(void)
(	O
pwd_id_str	*(char)
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
STATUS	O
)	O
)	O
{	O
print_pwid_status	(*(char))->(void)
(	O
pwd_id_str	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
DELETE	O
)	O
)	O
{	O
remove_pwid	(*(char))->(void)
(	O
pwd_id_str	*(char)
)	O
;	O
return	O
;	O
}	O
scribble_free	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
NO_HEADER	O
)	O
)	O
{	O
char	O
const	O
*	O
hdr_type	*(char)
=	O
hdr_normal	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
CONFIRM	O
)	O
)	O
{	O
pbkdf2_date	*(char)
=	O
""	*(char)
;	O
hdr_type	*(char)
=	O
hdr_confirm	O
;	O
}	O
if	O
(	O
HAVE_OPT	O
(	O
LOGIN_ID	O
)	O
)	O
printf	(*(char))->(int)
(	O
hdr_hint	O
,	O
OPT_ARG	O
(	O
LOGIN_ID	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
pw_hdr_fmt	O
,	O
hdr_type	*(char)
,	O
pbkdf2_date	*(char)
)	O
;	O
}	O
do	O
{	O
printed_pw	bool
|=	O
print_one_pwid	(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))),*(char))->(bool)
(	O
ov	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
,	O
pwd_id_str	*(char)
)	O
;	O
ov	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
=	O
optionFindNextValue	(*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))),*(char),*(char))->(*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void)))))
(	O
&	O
DESC	O
(	O
SEED	O
)	O
,	O
ov	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
while	O
(	O
ov	*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(char),union(array(char),int,int,long,long,*(void))))
!=	O
NULL	O
)	O
;	O
if	O
(	O
!	O
printed_pw	bool
)	O
die	(int,*(char))->(void)
(	O
GNU_PW_MGR_EXIT_NO_SEED	int
,	O
no_passwords	O
,	O
ENABLED_OPT	O
(	O
SHARED	O
)	O
?	O
sec_pw_type	O
:	O
""	*(char)
)	O
;	O
update_pwid_opts	(*(char))->(void)
(	O
pwd_id_str	*(char)
)	O
;	O
}	O
static	O
char	O
const	O
*	O
assemble_arg	(int,*(*(char)))->(*(char))
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
char	O
*	O
res	*(char)
,	O
*	O
scan	*(char)
;	O
size_t	long
len	long
=	O
argc	int
;	O
int	O
ct	int
=	O
argc	int
;	O
while	O
(	O
--	O
ct	int
>=	O
0	int
)	O
len	long
+=	O
strlen	(*(char))->(long)
(	O
argv	*(*(char))
[	O
ct	int
]	O
)	O
;	O
scan	*(char)
=	O
res	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	long
)	O
;	O
if	O
(	O
res	*(char)
==	O
NULL	O
)	O
nomem_err	(long,*(char))->(void)
(	O
len	long
,	O
"password id"	*(char)
)	O
;	O
ct	int
=	O
argc	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
len	long
=	O
strlen	(*(char))->(long)
(	O
*	O
argv	*(*(char))
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
scan	*(char)
,	O
*	O
(	O
argv	*(*(char))
++	O
)	O
,	O
len	long
)	O
;	O
scan	*(char)
+=	O
len	long
;	O
if	O
(	O
--	O
ct	int
<=	O
0	int
)	O
break	O
;	O
*	O
(	O
scan	*(char)
++	O
)	O
=	O
' '	O
;	O
}	O
*	O
scan	*(char)
=	O
NUL	char
;	O
return	O
res	*(char)
;	O
}	O
static	O
char	O
*	O
trim	(*(char))->(*(char))
(	O
char	O
*	O
in	*(char)
)	O
{	O
char	O
*	O
res	*(char)
;	O
while	O
(	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
int	O
)	O
*	O
in	*(char)
)	O
)	O
in	*(char)
++	O
;	O
res	*(char)
=	O
in	*(char)
;	O
in	*(char)
+=	O
strlen	(*(char))->(long)
(	O
in	*(char)
)	O
;	O
while	O
(	O
(	O
in	*(char)
>	O
res	*(char)
)	O
&&	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
int	O
)	O
(	O
in	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
)	O
in	*(char)
--	O
;	O
*	O
in	*(char)
=	O
NUL	char
;	O
return	O
res	*(char)
;	O
}	O
static	O
void	O
stdin_pwid	()->(void)
(	O
void	O
)	O
{	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
orig_term	struct(int,int,int,int,char,array(char),int,int)
;	O
bool	bool
restore_stdin	bool
=	O
false	int
;	O
static	O
char	O
const	O
stdio_funs	array(char)
[	O
]	O
=	O
"tcgetattr/tcsetattr/fputs/fflush/fread"	*(char)
;	O
char	O
pwid	array(char)
[	O
4096	int
]	O
;	O
do	O
{	O
if	O
(	O
isatty	(int)->(int)
(	O
STDIN_FILENO	int
)	O
&&	O
isatty	(int)->(int)
(	O
STDOUT_FILENO	int
)	O
)	O
{	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
noecho_term	struct(int,int,int,int,char,array(char),int,int)
;	O
if	O
(	O
tcgetattr	(int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
STDIN_FILENO	int
,	O
&	O
orig_term	struct(int,int,int,int,char,array(char),int,int)
)	O
!=	O
0	int
)	O
break	O
;	O
noecho_term	struct(int,int,int,int,char,array(char),int,int)
=	O
orig_term	struct(int,int,int,int,char,array(char),int,int)
;	O
noecho_term	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	int
&=	O
~	O
ECHO	int
;	O
if	O
(	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
STDIN_FILENO	int
,	O
TCSAFLUSH	int
,	O
&	O
noecho_term	struct(int,int,int,int,char,array(char),int,int)
)	O
!=	O
0	int
)	O
break	O
;	O
restore_stdin	bool
=	O
true	int
;	O
if	O
(	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pw_prompt	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
<	O
0	int
)	O
break	O
;	O
if	O
(	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
pwid	array(char)
,	O
sizeof	O
(	O
pwid	array(char)
)	O
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
pwid	array(char)
)	O
break	O
;	O
print_pwid	(*(char))->(void)
(	O
trim	(*(char))->(*(char))
(	O
pwid	array(char)
)	O
)	O
;	O
if	O
(	O
restore_stdin	bool
)	O
(	O
void	O
)	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
STDIN_FILENO	int
,	O
TCSAFLUSH	int
,	O
&	O
orig_term	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
return	O
;	O
}	O
while	O
(	O
0	int
)	O
;	O
if	O
(	O
restore_stdin	bool
)	O
(	O
void	O
)	O
tcsetattr	(int,int,*(struct(int,int,int,int,char,array(char),int,int)))->(int)
(	O
STDIN_FILENO	int
,	O
TCSAFLUSH	int
,	O
&	O
orig_term	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
fserr	(int,*(char),*(char))->(void)
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
stdio_funs	array(char)
,	O
stdin_out_z	O
)	O
;	O
}	O
static	O
void	O
list_domains	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
dom_text	*(char)
==	O
NULL	O
)	O
(	O
void	O
)	O
load_file	(*(char))->(*(char))
(	O
dom_file_name	*(char)
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
dom_text	*(char)
,	O
1	int
,	O
dom_text_len	long
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
write_dom_file	()->(void)
(	O
void	O
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
if	O
(	O
dom_text_len	long
==	O
0	int
)	O
return	O
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
dom_file_name	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
fserr	(int,*(char),*(char))->(void)
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
"fopen 'w'"	*(char)
,	O
dom_file_name	*(char)
)	O
;	O
size_t	long
wrlen	long
=	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
dom_text	*(char)
,	O
1	int
,	O
dom_text_len	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
wrlen	long
!=	O
dom_text_len	long
)	O
fserr	(int,*(char),*(char))->(void)
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
"fwrite"	*(char)
,	O
dom_file_name	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
insert_domain	(*(char))->(void)
(	O
char	O
const	O
*	O
dom	*(char)
)	O
{	O
static	O
char	O
const	O
end_dom_mark	array(char)
[	O
]	O
=	O
"</domain>\n"	*(char)
;	O
static	O
char	O
const	O
dom_entry_fmt	array(char)
[	O
]	O
=	O
"<domain time=%-10.10lu%s"	*(char)
;	O
static	O
unsigned	O
long	O
const	O
secs_per_day	long
=	O
60UL	int
*	O
60UL	int
*	O
24UL	int
;	O
static	O
size_t	long
base_size	long
=	O
sizeof	O
(	O
end_dom_mark	array(char)
)	O
+	O
sizeof	O
(	O
dom_entry_fmt	array(char)
)	O
;	O
char	O
buf	array(char)
[	O
256	int
]	O
=	O
">"	*(char)
;	O
size_t	long
dom_len	long
=	O
strlen	(*(char))->(long)
(	O
dom	*(char)
)	O
;	O
unsigned	O
long	O
cap_time	long
=	O
(	O
unsigned	O
long	O
)	O
time	(*(long))->(long)
(	O
NULL	O
)	O
/	O
secs_per_day	long
;	O
if	O
(	O
dom_len	long
+	O
sizeof	O
(	O
end_dom_mark	array(char)
)	O
+	O
1	int
>	O
sizeof	O
(	O
buf	array(char)
)	O
)	O
return	O
;	O
if	O
(	O
dom_text	*(char)
==	O
NULL	O
)	O
(	O
void	O
)	O
load_file	(*(char))->(*(char))
(	O
dom_file_name	*(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	array(char)
+	O
1	int
,	O
dom	*(char)
,	O
dom_len	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	array(char)
+	O
1	int
+	O
dom_len	long
,	O
end_dom_mark	array(char)
,	O
sizeof	O
(	O
end_dom_mark	array(char)
)	O
)	O
;	O
char	O
*	O
dom_entry	*(char)
=	O
strstr	(*(char),*(char))->(*(char))
(	O
dom_text	*(char)
,	O
buf	array(char)
)	O
;	O
if	O
(	O
dom_entry	*(char)
!=	O
NULL	O
)	O
{	O
dom_entry	*(char)
-=	O
10	int
;	O
int	O
ct	int
=	O
sprintf	(*(char),*(char))->(int)
(	O
dom_entry	*(char)
,	O
"%-10.10lu"	*(char)
,	O
cap_time	long
)	O
;	O
assert	O
(	O
ct	int
==	O
10	int
)	O
;	O
dom_entry	*(char)
[	O
10	int
]	O
=	O
'>'	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
dom_text_len	long
+	O
dom_len	long
+	O
base_size	long
)	O
>=	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
{	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
+=	O
4096	int
;	O
dom_text	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
dom_text	*(char)
,	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
;	O
if	O
(	O
dom_text	*(char)
==	O
NULL	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buf	array(char)
,	O
"%lu"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
dom_file_stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
;	O
fserr	(int,*(char),*(char))->(void)
(	O
GNU_PW_MGR_EXIT_NO_MEM	int
,	O
"realloc"	*(char)
,	O
buf	array(char)
)	O
;	O
}	O
}	O
dom_entry	*(char)
=	O
dom_text	*(char)
+	O
dom_text_len	long
;	O
dom_text_len	long
+=	O
sprintf	(*(char),*(char))->(int)
(	O
dom_entry	*(char)
,	O
dom_entry_fmt	array(char)
,	O
cap_time	long
,	O
buf	array(char)
)	O
;	O
}	O
}	O
static	O
void	O
proc_dom_opts	(int)->(void)
(	O
int	O
rem_arg_ct	int
)	O
{	O
int	O
ct	int
=	O
STACKCT_OPT	O
(	O
DOMAIN	O
)	O
;	O
char	O
const	O
*	O
*	O
dom_list	*(*(char))
=	O
STACKLST_OPT	O
(	O
DOMAIN	O
)	O
;	O
bool	bool
list_doms	bool
=	O
false	int
;	O
bool	bool
new_entry	bool
=	O
false	int
;	O
dom_file_name	*(char)
=	O
find_dom_file	()->(*(char))
(	O
)	O
;	O
dom_text	*(char)
=	O
load_file	(*(char))->(*(char))
(	O
dom_file_name	*(char)
)	O
;	O
do	O
{	O
char	O
const	O
*	O
dom	*(char)
=	O
*	O
(	O
dom_list	*(*(char))
++	O
)	O
;	O
if	O
(	O
(	O
*	O
dom	*(char)
==	O
'-'	O
)	O
&&	O
(	O
dom	*(char)
[	O
1	int
]	O
==	O
NUL	char
)	O
)	O
list_doms	bool
=	O
true	int
;	O
else	O
{	O
insert_domain	(*(char))->(void)
(	O
dom	*(char)
)	O
;	O
new_entry	bool
=	O
true	int
;	O
}	O
}	O
while	O
(	O
--	O
ct	int
>	O
0	int
)	O
;	O
if	O
(	O
new_entry	bool
)	O
write_dom_file	()->(void)
(	O
)	O
;	O
if	O
(	O
list_doms	bool
)	O
list_domains	()->(void)
(	O
)	O
;	O
if	O
(	O
rem_arg_ct	int
<=	O
0	int
)	O
exit	(int)->(void)
(	O
GNU_PW_MGR_EXIT_SUCCESS	int
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
scribble_init	()->(void)
(	O
)	O
;	O
fix_options	(*(int),*(*(*(char))))->(void)
(	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
{	O
int	O
ct	int
=	O
optionProcess	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int,*(*(char)))->(int)
(	O
&	O
gnu_pw_mgrOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
,	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
argc	int
-=	O
ct	int
;	O
argv	*(*(char))
+=	O
ct	int
;	O
}	O
if	O
(	O
gnu_pw_mgrOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
.	O
pOptDesc	*(struct)
[	O
INDEX_OPT_LOAD_OPTS	int
]	O
.	O
optOccCt	short
!=	O
1	int
)	O
die	(int,*(char))->(void)
(	O
GNU_PW_MGR_EXIT_INVALID	int
,	O
had_load_opts	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
DOMAIN	O
)	O
)	O
proc_dom_opts	(int)->(void)
(	O
argc	int
)	O
;	O
if	O
(	O
argc	int
>	O
0	int
)	O
{	O
char	O
const	O
*	O
arg	*(char)
;	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
SEED	O
)	O
)	O
die	(int,*(char))->(void)
(	O
GNU_PW_MGR_EXIT_NO_SEED	int
,	O
no_seeds	O
)	O
;	O
if	O
(	O
HAVE_OPT	O
(	O
TEXT	O
)	O
||	O
HAVE_OPT	O
(	O
TAG	O
)	O
)	O
usage_message	(*(char))->(void)
(	O
tag_pwid_conflict	O
)	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
arg	*(char)
=	O
*	O
argv	*(*(char))
;	O
else	O
arg	*(char)
=	O
assemble_arg	(int,*(*(char)))->(*(char))
(	O
argc	int
,	O
argv	*(*(char))
)	O
;	O
print_pwid	(*(char))->(void)
(	O
arg	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
TAG	O
)	O
)	O
{	O
if	O
(	O
!	O
HAVE_OPT	O
(	O
DOMAIN	O
)	O
)	O
stdin_pwid	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
HAVE_OPT	O
(	O
TEXT	O
)	O
)	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
SHARED	O
)	O
&&	O
!	O
ENABLED_OPT	O
(	O
SHARED	O
)	O
)	O
usage_message	(*(char))->(void)
(	O
disable_second	O
)	O
;	O
add_seed	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
HAVE_OPT	O
(	O
SHARED	O
)	O
)	O
usage_message	(*(char))->(void)
(	O
shared_removal	O
)	O
;	O
rm_seed	()->(void)
(	O
)	O
;	O
}	O
secure_cfg_file	()->(void)
(	O
)	O
;	O
scribble_deinit	()->(void)
(	O
)	O
;	O
return	O
GNU_PW_MGR_EXIT_SUCCESS	int
;	O
}	O
