object	O
sLcompile	int
,	O
sLload	O
,	O
sLeval	O
,	O
sKcompile_toplevel	O
,	O
sKload_toplevel	O
,	O
sKexecute	O
;	O
object	O
sLprogn	int
;	O
object	O
sLwarn	int
;	O
object	O
sSAinhibit_macro_specialA	int
;	O
object	O
sLtypep	int
;	O
static	O
void	O
FFN	(int)->(int)
(	O
Fdefun	int
)	O
(	O
object	O
args	int
)	O
{	O
object	O
name	O
;	O
object	O
body	int
,	O
form	O
;	O
if	O
(	O
endp	()->(int)
(	O
args	int
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
args	int
)	O
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
args	int
)	O
;	O
if	O
(	O
MMcadr	()->(int)
(	O
args	int
)	O
!=	O
Cnil	O
&&	O
type_of	()->(int)
(	O
MMcadr	()->(int)
(	O
args	int
)	O
)	O
!=	O
t_cons	O
)	O
FEerror	()->(int)
(	O
"~S is an illegal lambda-list."	*(char)
,	O
1	int
,	O
MMcadr	()->(int)
(	O
args	int
)	O
)	O
;	O
name	O
=	O
MMcar	()->(int)
(	O
args	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
name	O
)	O
!=	O
t_symbol	O
)	O
not_a_symbol	()->(int)
(	O
name	O
)	O
;	O
if	O
(	O
name	O
->	O
s	O
.	O
s_sfdef	O
!=	O
NOT_SPECIAL	O
)	O
{	O
if	O
(	O
name	O
->	O
s	O
.	O
s_mflag	O
)	O
{	O
if	O
(	O
symbol_value	()->(int)
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
name	O
->	O
s	O
.	O
s_sfdef	O
=	O
NOT_SPECIAL	O
;	O
}	O
else	O
if	O
(	O
symbol_value	()->(int)
(	O
sSAinhibit_macro_specialA	int
)	O
!=	O
Cnil	O
)	O
FEerror	()->(int)
(	O
"~S, a special form, cannot be redefined."	*(char)
,	O
1	int
,	O
name	O
)	O
;	O
}	O
if	O
(	O
name	O
->	O
s	O
.	O
s_hpack	O
==	O
lisp_package	O
&&	O
name	O
->	O
s	O
.	O
s_gfdef	O
!=	O
OBJNULL	O
&&	O
!	O
raw_image	O
)	O
{	O
vs_push	()->(int)
(	O
make_simple_string	()->(int)
(	O
"~S is being redefined."	*(char)
)	O
)	O
;	O
ifuncall2	()->(int)
(	O
sLwarn	int
,	O
vs_head	O
,	O
name	O
)	O
;	O
vs_popp	O
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
if	O
(	O
lex_env	O
[	O
0	int
]	O
==	O
Cnil	O
&&	O
lex_env	O
[	O
1	int
]	O
==	O
Cnil	O
&&	O
lex_env	O
[	O
2	int
]	O
==	O
Cnil	O
)	O
{	O
vs_push	()->(int)
(	O
MMcons	()->(int)
(	O
sLlambda_block	O
,	O
args	int
)	O
)	O
;	O
}	O
else	O
{	O
vs_push	()->(int)
(	O
MMcons	()->(int)
(	O
lex_env	O
[	O
2	int
]	O
,	O
args	int
)	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
lex_env	O
[	O
1	int
]	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
lex_env	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
sLlambda_block_closure	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
{	O
object	O
fname	O
=	O
clear_compiler_properties	O
(	O
name	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
fname	O
->	O
s	O
.	O
s_gfdef	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
fname	O
->	O
s	O
.	O
s_mflag	O
=	O
FALSE	O
;	O
}	O
vs_base	O
[	O
0	int
]	O
=	O
name	O
;	O
for	O
(	O
body	int
=	O
MMcddr	()->(int)
(	O
args	int
)	O
;	O
!	O
endp	()->(int)
(	O
body	int
)	O
;	O
body	int
=	O
body	int
->	O
c	O
.	O
c_cdr	O
)	O
{	O
form	O
=	O
macro_expand	()->(int)
(	O
body	int
->	O
c	O
.	O
c_car	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
form	O
)	O
==	O
t_string	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
body	int
->	O
c	O
.	O
c_cdr	O
)	O
)	O
break	O
;	O
vs_push	()->(int)
(	O
form	O
)	O
;	O
name	O
->	O
s	O
.	O
s_plist	O
=	O
putf	()->(int)
(	O
name	O
->	O
s	O
.	O
s_plist	O
,	O
form	O
,	O
sSfunction_documentation	O
)	O
;	O
vs_popp	O
;	O
break	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
form	O
)	O
!=	O
t_cons	O
||	O
form	O
->	O
c	O
.	O
c_car	O
!=	O
sLdeclare	O
)	O
break	O
;	O
}	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
siLAmake_special	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_sym	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
(	O
enum	O
stype	O
)	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_stype	O
==	O
stp_constant	O
)	O
FEerror	()->(int)
(	O
"~S is a constant."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_stype	O
=	O
(	O
short	O
)	O
stp_special	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
siLAmake_constant	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
2	int
)	O
;	O
check_type_sym	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
(	O
enum	O
stype	O
)	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_stype	O
==	O
stp_special	O
)	O
FEerror	()->(int)
(	O
"The argument ~S to DEFCONSTANT is a special variable."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_stype	O
=	O
(	O
short	O
)	O
stp_constant	O
;	O
vs_base	O
[	O
0	int
]	O
->	O
s	O
.	O
s_dbind	O
=	O
vs_base	O
[	O
1	int
]	O
;	O
vs_popp	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Feval_when	int
)	O
(	O
object	O
arg	int
)	O
{	O
object	O
*	O
base	O
=	O
vs_base	O
;	O
object	O
ss	O
;	O
bool	O
flag	O
=	O
FALSE	O
;	O
if	O
(	O
endp	()->(int)
(	O
arg	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
arg	int
)	O
;	O
for	O
(	O
ss	O
=	O
MMcar	()->(int)
(	O
arg	int
)	O
;	O
!	O
endp	()->(int)
(	O
ss	O
)	O
;	O
ss	O
=	O
MMcdr	()->(int)
(	O
ss	O
)	O
)	O
if	O
(	O
MMcar	()->(int)
(	O
ss	O
)	O
==	O
sLeval	O
||	O
(	O
MMcar	()->(int)
(	O
ss	O
)	O
==	O
sKexecute	O
)	O
)	O
flag	O
=	O
TRUE	O
;	O
else	O
if	O
(	O
MMcar	()->(int)
(	O
ss	O
)	O
!=	O
sLload	O
&&	O
MMcar	()->(int)
(	O
ss	O
)	O
!=	O
sLcompile	int
&&	O
MMcar	()->(int)
(	O
ss	O
)	O
!=	O
sKload_toplevel	O
&&	O
MMcar	()->(int)
(	O
ss	O
)	O
!=	O
sKcompile_toplevel	O
)	O
FEinvalid_form	()->(int)
(	O
"~S is an undefined situation for EVAL-WHEN."	*(char)
,	O
MMcar	()->(int)
(	O
ss	O
)	O
)	O
;	O
if	O
(	O
flag	O
)	O
{	O
vs_push	()->(int)
(	O
make_cons	()->(int)
(	O
sLprogn	int
,	O
MMcdr	()->(int)
(	O
arg	int
)	O
)	O
)	O
;	O
eval	()->(int)
(	O
vs_head	O
)	O
;	O
}	O
else	O
{	O
vs_base	O
=	O
base	O
;	O
vs_top	O
=	O
base	O
+	O
1	int
;	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fload_time_value	int
)	O
(	O
object	O
arg	int
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
arg	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
arg	int
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
arg	int
)	O
)	O
&&	O
!	O
endp	()->(int)
(	O
MMcddr	()->(int)
(	O
arg	int
)	O
)	O
)	O
FEtoo_many_argumentsF	()->(int)
(	O
arg	int
)	O
;	O
vs_push	()->(int)
(	O
MMcar	()->(int)
(	O
arg	int
)	O
)	O
;	O
eval	()->(int)
(	O
vs_head	O
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fdeclare	int
)	O
(	O
object	O
arg	int
)	O
{	O
FEerror	()->(int)
(	O
"DECLARE appeared in an invalid position."	*(char)
,	O
0	int
)	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Flocally	int
)	O
(	O
object	O
body	int
)	O
{	O
object	O
*	O
oldlex	O
=	O
lex_env	O
;	O
lex_copy	()->(int)
(	O
)	O
;	O
body	int
=	O
find_special	()->(int)
(	O
body	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vs_push	()->(int)
(	O
body	int
)	O
;	O
Fprogn	()->(int)
(	O
body	int
)	O
;	O
lex_env	O
=	O
oldlex	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fthe	int
)	O
(	O
object	O
args	int
)	O
{	O
object	O
*	O
vs	O
;	O
if	O
(	O
endp	()->(int)
(	O
args	int
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
args	int
)	O
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
args	int
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcddr	()->(int)
(	O
args	int
)	O
)	O
)	O
FEtoo_many_argumentsF	()->(int)
(	O
args	int
)	O
;	O
eval	()->(int)
(	O
MMcadr	()->(int)
(	O
args	int
)	O
)	O
;	O
args	int
=	O
MMcar	()->(int)
(	O
args	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
args	int
)	O
==	O
t_cons	O
&&	O
MMcar	()->(int)
(	O
args	int
)	O
==	O
sLvalues	O
)	O
{	O
vs	O
=	O
vs_base	O
;	O
for	O
(	O
args	int
=	O
MMcdr	()->(int)
(	O
args	int
)	O
;	O
!	O
endp	()->(int)
(	O
args	int
)	O
;	O
args	int
=	O
MMcdr	()->(int)
(	O
args	int
)	O
,	O
vs	O
++	O
)	O
{	O
if	O
(	O
vs	O
>=	O
vs_top	O
)	O
FEerror	()->(int)
(	O
"Too many return values."	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
ifuncall2	()->(int)
(	O
sLtypep	int
,	O
*	O
vs	O
,	O
MMcar	()->(int)
(	O
args	int
)	O
)	O
==	O
Cnil	O
)	O
FEwrong_type_argument	()->(int)
(	O
MMcar	()->(int)
(	O
args	int
)	O
,	O
*	O
vs	O
)	O
;	O
}	O
if	O
(	O
vs	O
<	O
vs_top	O
)	O
FEerror	()->(int)
(	O
"Too few return values."	*(char)
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ifuncall2	()->(int)
(	O
sLtypep	int
,	O
vs_base	O
[	O
0	int
]	O
,	O
args	int
)	O
==	O
Cnil	O
)	O
FEwrong_type_argument	()->(int)
(	O
args	int
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
}	O
DEF_ORDINARY	()->(int)
(	O
"LDB"	*(char)
,	O
sLldb	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"LDB-TEST"	*(char)
,	O
sLldb_test	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"DPB"	*(char)
,	O
sLdpb	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"DEPOSIT-FIELD"	*(char)
,	O
sLdeposit_field	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"COMPILE"	*(char)
,	O
sLcompile	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"COMPILE-TOPLEVEL"	*(char)
,	O
sKcompile_toplevel	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"DECLARE"	*(char)
,	O
sLdeclare	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"EVAL"	*(char)
,	O
sLeval	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"EXECUTE"	*(char)
,	O
sKexecute	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"FUNCTION-DOCUMENTATION"	*(char)
,	O
sSfunction_documentation	O
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"LOAD"	*(char)
,	O
sLload	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"LOAD-TOPLEVEL"	*(char)
,	O
sKload_toplevel	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"PROGN"	*(char)
,	O
sLprogn	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"TYPEP"	*(char)
,	O
sLtypep	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"VALUES"	*(char)
,	O
sLvalues	O
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"VARIABLE-DOCUMENTATION"	*(char)
,	O
sSvariable_documentation	O
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEF_ORDINARY	()->(int)
(	O
"WARN"	*(char)
,	O
sLwarn	int
,	O
LISP	O
,	O
""	*(char)
)	O
;	O
void	O
gcl_init_toplevel	()->(void)
(	O
void	O
)	O
{	O
make_special_form	()->(int)
(	O
"DEFUN"	*(char)
,	O
Fdefun	int
)	O
;	O
make_si_function	()->(int)
(	O
"*MAKE-SPECIAL"	*(char)
,	O
siLAmake_special	int
)	O
;	O
make_si_function	()->(int)
(	O
"*MAKE-CONSTANT"	*(char)
,	O
siLAmake_constant	int
)	O
;	O
make_special_form	()->(int)
(	O
"EVAL-WHEN"	*(char)
,	O
Feval_when	int
)	O
;	O
make_special_form	()->(int)
(	O
"LOAD-TIME-VALUE"	*(char)
,	O
Fload_time_value	int
)	O
;	O
make_special_form	()->(int)
(	O
"THE"	*(char)
,	O
Fthe	int
)	O
;	O
sLdeclare	O
=	O
make_special_form	()->(int)
(	O
"DECLARE"	*(char)
,	O
Fdeclare	int
)	O
;	O
make_special_form	()->(int)
(	O
"LOCALLY"	*(char)
,	O
Flocally	int
)	O
;	O
}	O
