GEN	O
mulsi	()->(int)
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
;	O
GEN	O
y	int
;	O
{	O
TEMPVARS	O
plong	int
s	int
=	O
signe	O
(	O
y	int
)	O
,	O
ly	O
=	O
lgef	O
(	O
y	int
)	O
,	O
i	O
;	O
GEN	O
z	O
,	O
zp	O
,	O
yp	O
;	O
ulong	O
hiremainder	O
;	O
if	O
(	O
(	O
!	O
x	int
)	O
||	O
(	O
!	O
s	int
)	O
)	O
return	O
gzero	O
;	O
if	O
(	O
x	int
<	O
0	int
)	O
{	O
s	int
=	O
-	O
s	int
;	O
x	int
=	O
-	O
x	int
;	O
if	O
(	O
x	int
<	O
0	int
)	O
{	O
return	O
mulii	O
(	O
stoi	()->(int)
(	O
1	int
<<	O
31	int
)	O
,	O
y	int
)	O
;	O
}	O
}	O
z	O
=	O
cgeti	()->(int)
(	O
ly	O
+	O
1	int
)	O
;	O
hiremainder	O
=	O
0	int
;	O
MP_START_LOW	O
(	O
yp	O
,	O
y	int
,	O
ly	O
)	O
;	O
MP_START_LOW	O
(	O
zp	O
,	O
z	O
,	O
ly	O
+	O
1	int
)	O
;	O
i	O
=	O
MP_COUNT_LG	O
(	O
ly	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
i	O
)	O
{	O
MP_NEXT_UP	O
(	O
zp	O
)	O
=	O
addmul	O
(	O
x	int
,	O
MP_NEXT_UP	O
(	O
yp	O
)	O
)	O
;	O
}	O
if	O
(	O
hiremainder	O
)	O
{	O
MP_NEXT_UP	O
(	O
zp	O
)	O
=	O
hiremainder	O
;	O
setlgef	O
(	O
z	O
,	O
ly	O
+	O
1	int
)	O
;	O
}	O
else	O
{	O
avma	O
+=	O
4	int
;	O
z	O
[	O
1	int
]	O
=	O
z	O
[	O
0	int
]	O
-	O
1	int
;	O
z	O
++	O
;	O
setlgef	O
(	O
z	O
,	O
ly	O
)	O
;	O
}	O
setsigne	()->(int)
(	O
z	O
,	O
s	int
)	O
;	O
return	O
z	O
;	O
}	O
int	O
expi	O
(	O
x	int
)	O
GEN	O
x	int
;	O
{	O
plong	int
lx	O
=	O
x	int
[	O
1	int
]	O
&	O
0xffff	int
;	O
return	O
lx	O
==	O
2	int
?	O
-	O
8388608	int
:	O
(	O
(	O
lx	O
-	O
2	int
)	O
<<	O
5	int
)	O
-	O
bfffo	O
(	O
x	int
[	O
2	int
]	O
)	O
-	O
1	int
;	O
}	O
GEN	O
addsi	O
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
;	O
GEN	O
y	int
;	O
{	O
plong	int
sx	O
,	O
sy	O
,	O
ly	O
,	O
p	O
,	O
i	O
;	O
ulong	O
overflow	O
;	O
GEN	O
z	O
;	O
TEMPVARS	O
if	O
(	O
!	O
x	int
)	O
return	O
icopy	()->(int)
(	O
y	int
)	O
;	O
sy	O
=	O
signe	O
(	O
y	int
)	O
;	O
if	O
(	O
!	O
sy	O
)	O
return	O
stoi	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
x	int
<	O
0	int
)	O
{	O
sx	O
=	O
-	O
1	int
;	O
x	int
=	O
-	O
x	int
;	O
if	O
(	O
x	int
<	O
0	int
)	O
return	O
addii	()->(int)
(	O
MOST_NEGS	array(int)
,	O
y	int
)	O
;	O
}	O
else	O
sx	O
=	O
1	int
;	O
ly	O
=	O
lgef	O
(	O
y	int
)	O
;	O
if	O
(	O
sx	O
==	O
sy	O
)	O
{	O
p	O
=	O
addll	O
(	O
x	int
,	O
y	int
[	O
ly	O
-	O
1	int
]	O
)	O
;	O
if	O
(	O
overflow	O
)	O
{	O
z	O
=	O
cgeti	()->(int)
(	O
ly	O
+	O
1	int
)	O
;	O
z	O
[	O
ly	O
]	O
=	O
p	O
;	O
for	O
(	O
i	O
=	O
ly	O
-	O
1	int
;	O
(	O
i	O
>	O
2	int
)	O
&&	O
(	O
y	int
[	O
i	O
-	O
1	int
]	O
==	O
0xffffffff	int
)	O
;	O
i	O
--	O
)	O
z	O
[	O
i	O
]	O
=	O
0	int
;	O
if	O
(	O
i	O
>	O
2	int
)	O
{	O
z	O
[	O
i	O
]	O
=	O
y	int
[	O
i	O
-	O
1	int
]	O
+	O
1	int
;	O
i	O
--	O
;	O
while	O
(	O
i	O
>=	O
3	int
)	O
{	O
z	O
[	O
i	O
]	O
=	O
y	int
[	O
i	O
-	O
1	int
]	O
;	O
i	O
--	O
;	O
}	O
z	O
[	O
2	int
]	O
=	O
z	O
[	O
1	int
]	O
=	O
z	O
[	O
0	int
]	O
-	O
1	int
;	O
z	O
++	O
;	O
avma	O
+=	O
4	int
;	O
}	O
else	O
{	O
z	O
[	O
2	int
]	O
=	O
1	int
;	O
z	O
[	O
1	int
]	O
=	O
z	O
[	O
0	int
]	O
;	O
}	O
}	O
else	O
{	O
z	O
=	O
cgeti	()->(int)
(	O
ly	O
)	O
;	O
z	O
[	O
ly	O
-	O
1	int
]	O
=	O
p	O
;	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<	O
ly	O
-	O
1	int
;	O
i	O
++	O
)	O
z	O
[	O
i	O
]	O
=	O
y	int
[	O
i	O
]	O
;	O
}	O
setsigne	()->(int)
(	O
z	O
,	O
sx	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ly	O
==	O
3	int
)	O
{	O
if	O
(	O
(	O
ulong	O
)	O
y	int
[	O
2	int
]	O
>	O
(	O
ulong	O
)	O
x	int
)	O
{	O
z	O
=	O
cgeti	()->(int)
(	O
3	int
)	O
;	O
z	O
[	O
1	int
]	O
=	O
(	O
sy	O
<<	O
24	int
)	O
+	O
3	int
;	O
z	O
[	O
2	int
]	O
=	O
y	int
[	O
2	int
]	O
-	O
x	int
;	O
return	O
z	O
;	O
}	O
if	O
(	O
y	int
[	O
2	int
]	O
==	O
x	int
)	O
return	O
gzero	O
;	O
z	O
=	O
cgeti	()->(int)
(	O
3	int
)	O
;	O
z	O
[	O
1	int
]	O
=	O
(	O
(	O
-	O
sy	O
)	O
<<	O
24	int
)	O
+	O
3	int
;	O
z	O
[	O
2	int
]	O
=	O
x	int
-	O
y	int
[	O
2	int
]	O
;	O
return	O
z	O
;	O
}	O
p	O
=	O
subll	O
(	O
y	int
[	O
ly	O
-	O
1	int
]	O
,	O
x	int
)	O
;	O
if	O
(	O
overflow	O
)	O
{	O
z	O
=	O
cgeti	()->(int)
(	O
ly	O
)	O
;	O
z	O
[	O
ly	O
-	O
1	int
]	O
=	O
p	O
;	O
for	O
(	O
i	O
=	O
ly	O
-	O
2	int
;	O
!	O
(	O
y	int
[	O
i	O
]	O
)	O
;	O
i	O
--	O
)	O
z	O
[	O
i	O
]	O
=	O
0xffffffff	int
;	O
z	O
[	O
i	O
]	O
=	O
y	int
[	O
i	O
]	O
-	O
1	int
;	O
if	O
(	O
(	O
i	O
>	O
2	int
)	O
||	O
z	O
[	O
i	O
]	O
)	O
{	O
i	O
--	O
;	O
for	O
(	O
;	O
i	O
>=	O
1	int
;	O
i	O
--	O
)	O
z	O
[	O
i	O
]	O
=	O
y	int
[	O
i	O
]	O
;	O
}	O
else	O
{	O
z	O
[	O
2	int
]	O
=	O
z	O
[	O
1	int
]	O
=	O
z	O
[	O
0	int
]	O
-	O
1	int
;	O
z	O
++	O
;	O
avma	O
+=	O
4	int
;	O
setsigne	()->(int)
(	O
z	O
,	O
sy	O
)	O
;	O
}	O
}	O
else	O
{	O
z	O
=	O
cgeti	()->(int)
(	O
ly	O
)	O
;	O
z	O
[	O
ly	O
-	O
1	int
]	O
=	O
p	O
;	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<	O
ly	O
-	O
1	int
;	O
i	O
++	O
)	O
z	O
[	O
i	O
]	O
=	O
y	int
[	O
i	O
]	O
;	O
}	O
}	O
return	O
z	O
;	O
}	O
GEN	O
addii	()->(int)
(	O
x	int
,	O
y	int
)	O
GEN	O
x	int
,	O
y	int
;	O
{	O
plong	int
sx	O
,	O
sy	O
,	O
sz	O
,	O
lx	O
,	O
ly	O
,	O
i	O
,	O
j	O
,	O
p	O
;	O
GEN	O
z	O
,	O
xp	O
,	O
yp	O
,	O
zp	O
,	O
xpp	O
,	O
xhigh	O
;	O
TEMPVARS	O
ulong	O
overflow	O
;	O
lx	O
=	O
lgef	O
(	O
x	int
)	O
;	O
ly	O
=	O
lgef	O
(	O
y	int
)	O
;	O
if	O
(	O
lx	O
<	O
ly	O
)	O
{	O
z	O
=	O
x	int
;	O
x	int
=	O
y	int
;	O
y	int
=	O
z	O
;	O
sx	O
=	O
lx	O
;	O
lx	O
=	O
ly	O
;	O
ly	O
=	O
sx	O
;	O
}	O
if	O
(	O
0	int
==	O
(	O
sy	O
=	O
signe	O
(	O
y	int
)	O
)	O
)	O
return	O
icopy	()->(int)
(	O
x	int
)	O
;	O
sx	O
=	O
signe	O
(	O
x	int
)	O
;	O
if	O
(	O
sx	O
==	O
sy	O
)	O
{	O
z	O
=	O
cgeti	()->(int)
(	O
lx	O
+	O
1	int
)	O
;	O
overflow	O
=	O
0	int
;	O
MP_START_LOW	O
(	O
zp	O
,	O
z	O
,	O
lx	O
+	O
1	int
)	O
;	O
MP_START_LOW	O
(	O
xp	O
,	O
x	int
,	O
lx	O
)	O
;	O
MP_START_LOW	O
(	O
yp	O
,	O
y	int
,	O
ly	O
)	O
;	O
i	O
=	O
MP_COUNT_LG	O
(	O
ly	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
i	O
)	O
{	O
ADDLLX	O
(	O
MP_NEXT_UP	O
(	O
xp	O
)	O
,	O
MP_NEXT_UP	O
(	O
yp	O
)	O
,	O
MP_NEXT_UP	O
(	O
zp	O
)	O
)	O
;	O
}	O
if	O
(	O
overflow	O
)	O
{	O
GEN	O
xhigh	O
=	O
&	O
MP_HIGH	O
(	O
x	int
,	O
lx	O
)	O
;	O
again	O
:	O
{	O
GEN	O
xpp	O
=	O
&	O
MP_NEXT_UP	O
(	O
xp	O
)	O
;	O
if	O
(	O
xpp	O
>=	O
xhigh	O
)	O
{	O
if	O
(	O
*	O
xpp	O
==	O
0xffffffff	int
)	O
{	O
MP_NEXT_UP	O
(	O
zp	O
)	O
=	O
0	int
;	O
goto	O
again	O
;	O
}	O
else	O
{	O
MP_NEXT_UP	O
(	O
zp	O
)	O
=	O
*	O
xpp	O
+	O
1	int
;	O
while	O
(	O
(	O
xpp	O
=	O
&	O
MP_NEXT_UP	O
(	O
xp	O
)	O
)	O
>=	O
xhigh	O
)	O
{	O
MP_NEXT_UP	O
(	O
zp	O
)	O
=	O
*	O
xpp	O
;	O
}	O
z	O
[	O
1	int
]	O
=	O
z	O
[	O
0	int
]	O
-	O
1	int
;	O
z	O
[	O
2	int
]	O
=	O
x	int
[	O
1	int
]	O
;	O
z	O
++	O
;	O
avma	O
+=	O
4	int
;	O
}	O
}	O
else	O
{	O
z	O
[	O
2	int
]	O
=	O
1	int
;	O
z	O
[	O
1	int
]	O
=	O
x	int
[	O
1	int
]	O
+	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
j	O
=	O
COUNT	O
(	O
lx	O
-	O
ly	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
j	O
)	O
{	O
MP_NEXT_UP	O
(	O
zp	O
)	O
=	O
MP_NEXT_UP	O
(	O
xp	O
)	O
;	O
}	O
z	O
[	O
1	int
]	O
=	O
z	O
[	O
0	int
]	O
-	O
1	int
;	O
z	O
[	O
2	int
]	O
=	O
x	int
[	O
1	int
]	O
;	O
z	O
++	O
;	O
avma	O
+=	O
4	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
lx	O
==	O
ly	O
)	O
{	O
j	O
=	O
MP_COUNT_LG	O
(	O
lx	O
)	O
;	O
MP_START_HIGH	O
(	O
xp	O
,	O
x	int
,	O
lx	O
)	O
;	O
MP_START_HIGH	O
(	O
yp	O
,	O
y	int
,	O
lx	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
j	O
)	O
{	O
ulong	O
tx	O
=	O
MP_NEXT_DOWN	O
(	O
xp	O
)	O
;	O
ulong	O
ty	O
=	O
MP_NEXT_DOWN	O
(	O
yp	O
)	O
;	O
if	O
(	O
ty	O
>	O
tx	O
)	O
{	O
z	O
=	O
x	int
;	O
x	int
=	O
y	int
;	O
y	int
=	O
z	O
;	O
sz	O
=	O
sx	O
;	O
sx	O
=	O
sy	O
;	O
sy	O
=	O
sz	O
;	O
goto	O
DIFFER	O
;	O
}	O
else	O
if	O
(	O
tx	O
>	O
ty	O
)	O
{	O
goto	O
DIFFER	O
;	O
}	O
}	O
SAME	O
:	O
return	O
gzero	O
;	O
DIFFER	O
:	O
;	O
}	O
z	O
=	O
cgeti	()->(int)
(	O
lx	O
)	O
;	O
overflow	O
=	O
0	int
;	O
MP_START_LOW	O
(	O
xp	O
,	O
x	int
,	O
lx	O
)	O
;	O
MP_START_LOW	O
(	O
yp	O
,	O
y	int
,	O
ly	O
)	O
;	O
MP_START_LOW	O
(	O
zp	O
,	O
z	O
,	O
lx	O
)	O
;	O
i	O
=	O
MP_COUNT_LG	O
(	O
ly	O
)	O
;	O
i	O
=	O
MP_COUNT_LG	O
(	O
ly	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
i	O
)	O
{	O
SUBLLX	O
(	O
MP_NEXT_UP	O
(	O
xp	O
)	O
,	O
MP_NEXT_UP	O
(	O
yp	O
)	O
,	O
MP_NEXT_UP	O
(	O
zp	O
)	O
)	O
;	O
}	O
if	O
(	O
overflow	O
)	O
{	O
ulong	O
tx	O
;	O
while	O
(	O
(	O
tx	O
=	O
MP_NEXT_UP	O
(	O
xp	O
)	O
)	O
==	O
0	int
)	O
MP_NEXT_UP	O
(	O
zp	O
)	O
=	O
0xffffffff	int
;	O
if	O
(	O
xp	O
>=	O
(	O
xhigh	O
=	O
&	O
MP_HIGH	O
(	O
x	int
,	O
lx	O
)	O
)	O
)	O
{	O
MP_NEXT_UP	O
(	O
zp	O
)	O
=	O
tx	O
-	O
1	int
;	O
while	O
(	O
(	O
xpp	O
=	O
&	O
MP_NEXT_UP	O
(	O
xp	O
)	O
)	O
>=	O
xhigh	O
)	O
{	O
MP_NEXT_UP	O
(	O
zp	O
)	O
=	O
*	O
xpp	O
;	O
}	O
}	O
}	O
else	O
{	O
i	O
=	O
COUNT	O
(	O
lx	O
-	O
ly	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
i	O
)	O
MP_NEXT_UP	O
(	O
zp	O
)	O
=	O
MP_NEXT_UP	O
(	O
xp	O
)	O
;	O
}	O
if	O
(	O
z	O
[	O
2	int
]	O
)	O
z	O
[	O
1	int
]	O
=	O
x	int
[	O
1	int
]	O
;	O
else	O
{	O
zp	O
=	O
&	O
z	O
[	O
3	int
]	O
;	O
while	O
(	O
*	O
zp	O
==	O
0	int
)	O
{	O
zp	O
++	O
;	O
}	O
zp	O
-=	O
2	int
;	O
i	O
=	O
zp	O
-	O
z	O
;	O
zp	O
[	O
1	int
]	O
=	O
(	O
zp	O
[	O
0	int
]	O
=	O
z	O
[	O
0	int
]	O
-	O
i	O
)	O
;	O
z	O
=	O
zp	O
;	O
setsigne	()->(int)
(	O
z	O
,	O
sx	O
)	O
;	O
avma	O
+=	O
(	O
i	O
<<	O
2	int
)	O
;	O
}	O
}	O
return	O
z	O
;	O
}	O
GEN	O
mulss	(int,int)->(int)
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
,	O
y	int
;	O
{	O
plong	int
s	int
,	O
p1	int
;	O
GEN	O
z	O
;	O
ulong	O
hiremainder	O
;	O
if	O
(	O
(	O
!	O
x	int
)	O
||	O
(	O
!	O
y	int
)	O
)	O
return	O
gzero	O
;	O
s	int
=	O
1	int
;	O
if	O
(	O
x	int
<	O
0	int
)	O
{	O
s	int
=	O
-	O
1	int
;	O
x	int
=	O
-	O
x	int
;	O
if	O
(	O
x	int
<	O
0	int
)	O
return	O
mulsi	()->(int)
(	O
y	int
,	O
stoi	()->(int)
(	O
x	int
)	O
)	O
;	O
}	O
if	O
(	O
y	int
<	O
0	int
)	O
{	O
s	int
=	O
-	O
s	int
;	O
y	int
=	O
-	O
y	int
;	O
if	O
(	O
y	int
<	O
0	int
)	O
return	O
mulsi	()->(int)
(	O
(	O
s	int
>	O
0	int
?	O
x	int
:	O
-	O
x	int
)	O
,	O
ABS_MOST_NEGS	array(int)
)	O
;	O
}	O
p1	int
=	O
mulll	()->(int)
(	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
hiremainder	O
)	O
{	O
z	O
=	O
cgeti	()->(int)
(	O
4	int
)	O
;	O
z	O
[	O
2	int
]	O
=	O
hiremainder	O
;	O
z	O
[	O
3	int
]	O
=	O
p1	int
;	O
}	O
else	O
{	O
z	O
=	O
cgeti	()->(int)
(	O
3	int
)	O
;	O
z	O
[	O
2	int
]	O
=	O
p1	int
;	O
}	O
z	O
[	O
1	int
]	O
=	O
z	O
[	O
0	int
]	O
;	O
setsigne	()->(int)
(	O
z	O
,	O
s	int
)	O
;	O
return	O
z	O
;	O
}	O
GEN	O
mulii	O
(	O
x	int
,	O
y	int
)	O
GEN	O
x	int
,	O
y	int
;	O
{	O
plong	int
i	O
,	O
j	O
,	O
lx	O
=	O
lgef	O
(	O
x	int
)	O
,	O
ly	O
=	O
lgef	O
(	O
y	int
)	O
,	O
sx	O
,	O
sy	O
,	O
lz	O
,	O
p1	int
,	O
p2	O
;	O
GEN	O
z	O
;	O
TEMPVARS	O
GEN	O
zz	O
,	O
yy	O
,	O
zp	O
,	O
xx	O
;	O
GEN	O
ylow	O
;	O
ulong	O
hiremainder	O
;	O
ulong	O
overflow	O
;	O
sx	O
=	O
signe	O
(	O
x	int
)	O
;	O
if	O
(	O
!	O
sx	O
)	O
return	O
gzero	O
;	O
sy	O
=	O
signe	O
(	O
y	int
)	O
;	O
if	O
(	O
!	O
sy	O
)	O
return	O
gzero	O
;	O
if	O
(	O
sy	O
<	O
0	int
)	O
sx	O
=	O
-	O
sx	O
;	O
if	O
(	O
lx	O
>	O
ly	O
)	O
{	O
z	O
=	O
x	int
;	O
x	int
=	O
y	int
;	O
y	int
=	O
z	O
;	O
lz	O
=	O
lx	O
;	O
lx	O
=	O
ly	O
;	O
ly	O
=	O
lz	O
;	O
}	O
lz	O
=	O
lx	O
+	O
ly	O
-	O
2	int
;	O
if	O
(	O
lz	O
>=	O
0x10000	int
)	O
err	()->(int)
(	O
muler1	O
)	O
;	O
z	O
=	O
cgeti	()->(int)
(	O
lz	O
)	O
;	O
z	O
[	O
1	int
]	O
=	O
z	O
[	O
0	int
]	O
;	O
setsigne	()->(int)
(	O
z	O
,	O
sx	O
)	O
;	O
MP_START_LOW	O
(	O
xx	O
,	O
x	int
,	O
lx	O
)	O
;	O
p1	int
=	O
MP_NEXT_UP	O
(	O
xx	O
)	O
;	O
hiremainder	O
=	O
0	int
;	O
i	O
=	O
COUNT	O
(	O
ly	O
-	O
2	int
)	O
;	O
MP_START_LOW	O
(	O
yy	O
,	O
y	int
,	O
ly	O
)	O
;	O
MP_START_LOW	O
(	O
zz	O
,	O
z	O
,	O
lz	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
i	O
)	O
{	O
MP_NEXT_UP	O
(	O
zz	O
)	O
=	O
addmul	O
(	O
p1	int
,	O
MP_NEXT_UP	O
(	O
yy	O
)	O
)	O
;	O
}	O
MP_NEXT_UP	O
(	O
zz	O
)	O
=	O
hiremainder	O
;	O
MP_START_LOW	O
(	O
zz	O
,	O
z	O
,	O
lz	O
)	O
;	O
MP_START_LOW	O
(	O
ylow	O
,	O
y	int
,	O
ly	O
)	O
;	O
ly	O
=	O
COUNT	O
(	O
ly	O
-	O
MP_CODE_WORDS	O
)	O
;	O
lx	O
-=	O
MP_CODE_WORDS	O
;	O
while	O
(	O
--	O
lx	O
>	O
0	int
)	O
{	O
plong	int
tem	O
;	O
register	O
plong	int
p11	O
;	O
p11	O
=	O
MP_NEXT_UP	O
(	O
xx	O
)	O
;	O
i	O
=	O
ly	O
;	O
yy	O
=	O
ylow	O
;	O
zp	O
=	O
&	O
MP_NEXT_UP	O
(	O
zz	O
)	O
;	O
tem	O
=	O
0	int
;	O
{	O
int	O
ZerO	O
=	O
0	int
;	O
WHILE_COUNT	O
(	O
--	O
i	O
)	O
{	O
p2	O
=	O
MP_NEXT_UP	O
(	O
yy	O
)	O
;	O
p2	O
=	O
mulul	O
(	O
p2	O
,	O
p11	O
,	O
hiremainder	O
)	O
;	O
MP_NEXT_UP	O
(	O
zp	O
)	O
;	O
p2	O
=	O
add_carry	O
(	O
p2	O
,	O
*	O
zp	O
,	O
hiremainder	O
)	O
;	O
p2	O
=	O
add_carry	O
(	O
p2	O
,	O
tem	O
,	O
hiremainder	O
)	O
;	O
*	O
zp	O
=	O
p2	O
;	O
tem	O
=	O
hiremainder	O
;	O
}	O
}	O
MP_NEXT_UP	O
(	O
zp	O
)	O
=	O
hiremainder	O
;	O
}	O
if	O
(	O
!	O
MP_HIGH	O
(	O
z	O
,	O
lz	O
)	O
)	O
{	O
z	O
[	O
2	int
]	O
=	O
z	O
[	O
1	int
]	O
-	O
1	int
;	O
z	O
[	O
1	int
]	O
=	O
z	O
[	O
0	int
]	O
-	O
1	int
;	O
z	O
++	O
;	O
avma	O
+=	O
4	int
;	O
}	O
return	O
z	O
;	O
}	O
GEN	O
confrac	O
(	O
x	int
)	O
GEN	O
x	int
;	O
{	O
plong	int
lx	O
=	O
lg	O
(	O
x	int
)	O
,	O
ex	O
=	O
-	O
expo	O
(	O
x	int
)	O
-	O
1	int
,	O
ex1	O
,	O
av	O
=	O
avma	O
,	O
ly	O
,	O
ey	O
;	O
plong	int
lr	O
,	O
nbdec	O
,	O
k	O
,	O
i	O
,	O
j	O
;	O
ulong	O
hiremainder	O
;	O
GEN	O
y	int
,	O
res	O
;	O
TEMPVARS	O
ey	O
=	O
(	O
(	O
lx	O
-	O
2	int
)	O
<<	O
5	int
)	O
+	O
ex	O
;	O
ly	O
=	O
(	O
ey	O
+	O
63	int
)	O
>>	O
5	int
;	O
y	int
=	O
cgeti	()->(int)
(	O
ly	O
)	O
;	O
ex1	O
=	O
ex	O
>>	O
5	int
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
ex1	O
;	O
i	O
++	O
)	O
y	int
[	O
i	O
]	O
=	O
0	int
;	O
ex	O
&=	O
31	int
;	O
if	O
(	O
!	O
ex	O
)	O
for	O
(	O
j	O
=	O
2	int
;	O
j	O
<	O
lx	O
;	O
j	O
++	O
)	O
y	int
[	O
i	O
++	O
]	O
=	O
x	int
[	O
j	O
]	O
;	O
else	O
{	O
k	O
=	O
0	int
;	O
for	O
(	O
j	O
=	O
2	int
;	O
j	O
<	O
lx	O
;	O
j	O
++	O
)	O
{	O
y	int
[	O
i	O
++	O
]	O
=	O
shiftlr	O
(	O
x	int
[	O
j	O
]	O
,	O
ex	O
)	O
+	O
k	O
;	O
k	O
=	O
hiremainder	O
;	O
}	O
y	int
[	O
ly	O
-	O
2	int
]	O
=	O
k	O
;	O
}	O
y	int
[	O
ly	O
-	O
1	int
]	O
=	O
0	int
;	O
nbdec	O
=	O
ey	O
*	O
0.30103	int
+	O
1	int
;	O
lr	O
=	O
(	O
nbdec	O
+	O
17	int
)	O
/	O
9	int
;	O
res	O
=	O
cgeti	()->(int)
(	O
lr	O
)	O
;	O
*	O
res	O
=	O
nbdec	O
;	O
for	O
(	O
j	O
=	O
1	int
;	O
j	O
<	O
lr	O
;	O
j	O
++	O
)	O
{	O
hiremainder	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
ly	O
-	O
1	int
;	O
i	O
>=	O
0	int
;	O
i	O
--	O
)	O
y	int
[	O
i	O
]	O
=	O
addmul	O
(	O
y	int
[	O
i	O
]	O
,	O
1000000000	int
)	O
;	O
res	O
[	O
j	O
]	O
=	O
hiremainder	O
;	O
}	O
avma	O
=	O
av	O
;	O
return	O
res	O
;	O
}	O
GEN	O
divss	()->(int)
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
,	O
y	int
;	O
{	O
plong	int
p1	int
;	O
if	O
(	O
!	O
y	int
)	O
err	()->(int)
(	O
diver1	O
)	O
;	O
if	O
(	O
x	int
==	O
(	O
1	int
<<	O
31	int
)	O
)	O
return	O
divis	()->(int)
(	O
stoi	()->(int)
(	O
x	int
)	O
,	O
y	int
)	O
;	O
hiremainder	O
=	O
0	int
;	O
p1	int
=	O
divll	()->(int)
(	O
(	O
ulong	O
)	O
abs	O
(	O
x	int
)	O
,	O
(	O
ulong	O
)	O
abs	O
(	O
y	int
)	O
)	O
;	O
if	O
(	O
y	int
<	O
0	int
)	O
{	O
hiremainder	O
=	O
-	O
(	O
(	O
plong	int
)	O
hiremainder	O
)	O
;	O
p1	int
=	O
-	O
p1	int
;	O
}	O
if	O
(	O
x	int
<	O
0	int
)	O
p1	int
=	O
-	O
p1	int
;	O
return	O
stoi	()->(int)
(	O
p1	int
)	O
;	O
}	O
GEN	O
modss	(int,int)->(int)
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
,	O
y	int
;	O
{	O
plong	int
y1	int
;	O
ulong	O
hiremainder	O
;	O
if	O
(	O
!	O
y	int
)	O
err	()->(int)
(	O
moder1	O
)	O
;	O
if	O
(	O
x	int
==	O
(	O
1	int
<<	O
31	int
)	O
)	O
return	O
modis	()->(int)
(	O
stoi	()->(int)
(	O
x	int
)	O
,	O
y	int
)	O
;	O
hiremainder	O
=	O
0	int
;	O
divll	()->(int)
(	O
abs	O
(	O
x	int
)	O
,	O
y1	int
=	O
abs	O
(	O
y	int
)	O
)	O
;	O
if	O
(	O
!	O
hiremainder	O
)	O
return	O
gzero	O
;	O
return	O
(	O
(	O
(	O
plong	int
)	O
hiremainder	O
)	O
<	O
0	int
)	O
?	O
stoi	()->(int)
(	O
y1	int
-	O
hiremainder	O
)	O
:	O
stoi	()->(int)
(	O
hiremainder	O
)	O
;	O
}	O
GEN	O
resss	(int,int)->(int)
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
,	O
y	int
;	O
{	O
ulong	O
hiremainder	O
;	O
if	O
(	O
!	O
y	int
)	O
err	()->(int)
(	O
reser1	O
)	O
;	O
hiremainder	O
=	O
0	int
;	O
divll	()->(int)
(	O
abs	O
(	O
x	int
)	O
,	O
abs	O
(	O
y	int
)	O
)	O
;	O
return	O
(	O
y	int
<	O
0	int
)	O
?	O
stoi	()->(int)
(	O
-	O
(	O
(	O
plong	int
)	O
hiremainder	O
)	O
)	O
:	O
stoi	()->(int)
(	O
hiremainder	O
)	O
;	O
}	O
GEN	O
divsi	O
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
;	O
GEN	O
y	int
;	O
{	O
plong	int
s	int
=	O
signe	O
(	O
y	int
)	O
,	O
ly	O
=	O
lgef	O
(	O
y	int
)	O
,	O
p1	int
;	O
if	O
(	O
!	O
s	int
)	O
err	()->(int)
(	O
diver2	O
)	O
;	O
if	O
(	O
(	O
!	O
x	int
)	O
||	O
(	O
ly	O
>	O
3	int
)	O
||	O
(	O
y	int
[	O
2	int
]	O
<	O
0	int
)	O
)	O
{	O
hiremainder	O
=	O
x	int
;	O
return	O
gzero	O
;	O
}	O
if	O
(	O
x	int
==	O
1	int
<<	O
31	int
)	O
return	O
divii	O
(	O
stoi	()->(int)
(	O
x	int
)	O
,	O
y	int
)	O
;	O
hiremainder	O
=	O
0	int
;	O
p1	int
=	O
divll	()->(int)
(	O
abs	O
(	O
x	int
)	O
,	O
y	int
[	O
2	int
]	O
)	O
;	O
if	O
(	O
signe	O
(	O
y	int
)	O
<	O
0	int
)	O
{	O
hiremainder	O
=	O
-	O
(	O
(	O
plong	int
)	O
hiremainder	O
)	O
;	O
p1	int
=	O
-	O
p1	int
;	O
}	O
if	O
(	O
x	int
<	O
0	int
)	O
p1	int
=	O
-	O
p1	int
;	O
return	O
stoi	()->(int)
(	O
p1	int
)	O
;	O
}	O
GEN	O
divis	()->(int)
(	O
y	int
,	O
x	int
)	O
plong	int
x	int
;	O
GEN	O
y	int
;	O
{	O
ulong	O
hi	O
;	O
plong	int
s	int
=	O
signe	O
(	O
y	int
)	O
,	O
ly	O
=	O
lgef	O
(	O
y	int
)	O
,	O
i	O
,	O
d	O
;	O
GEN	O
z	O
;	O
if	O
(	O
!	O
x	int
)	O
err	()->(int)
(	O
diver4	O
)	O
;	O
if	O
(	O
!	O
s	int
)	O
{	O
hiremainder	O
=	O
0	int
;	O
return	O
gzero	O
;	O
}	O
if	O
(	O
x	int
<	O
0	int
)	O
{	O
s	int
=	O
-	O
s	int
;	O
x	int
=	O
-	O
x	int
;	O
if	O
(	O
x	int
<	O
0	int
)	O
return	O
divii	O
(	O
y	int
,	O
stoi	()->(int)
(	O
x	int
)	O
)	O
;	O
}	O
if	O
(	O
(	O
ulong	O
)	O
x	int
>	O
(	O
ulong	O
)	O
y	int
[	O
2	int
]	O
)	O
{	O
if	O
(	O
ly	O
==	O
3	int
)	O
{	O
hiremainder	O
=	O
itos	O
(	O
y	int
)	O
;	O
return	O
gzero	O
;	O
}	O
else	O
{	O
z	O
=	O
cgeti	()->(int)
(	O
ly	O
-	O
1	int
)	O
;	O
d	O
=	O
1	int
;	O
hi	O
=	O
y	int
[	O
2	int
]	O
;	O
}	O
}	O
else	O
{	O
z	O
=	O
cgeti	()->(int)
(	O
ly	O
)	O
;	O
d	O
=	O
0	int
;	O
hi	O
=	O
0	int
;	O
}	O
for	O
(	O
i	O
=	O
d	O
+	O
2	int
;	O
i	O
<	O
ly	O
;	O
i	O
++	O
)	O
z	O
[	O
i	O
-	O
d	O
]	O
=	O
divul	O
(	O
y	int
[	O
i	O
]	O
,	O
x	int
,	O
hi	O
)	O
;	O
z	O
[	O
1	int
]	O
=	O
z	O
[	O
0	int
]	O
;	O
setsigne	()->(int)
(	O
z	O
,	O
s	int
)	O
;	O
hiremainder	O
=	O
(	O
s	int
<	O
0	int
?	O
-	O
(	O
(	O
plong	int
)	O
hi	O
)	O
:	O
hi	O
)	O
;	O
return	O
z	O
;	O
}	O
GEN	O
dvmdii	O
(	O
x	int
,	O
y	int
,	O
z	O
)	O
GEN	O
x	int
,	O
y	int
,	O
*	O
z	O
;	O
{	O
plong	int
av	O
,	O
lx	O
,	O
ly	O
,	O
lz	O
,	O
i	O
,	O
j	O
,	O
dec	O
,	O
sh	O
,	O
k	O
,	O
k1	O
,	O
sx	O
=	O
signe	O
(	O
x	int
)	O
,	O
sy	O
=	O
signe	O
(	O
y	int
)	O
;	O
plong	int
saux	O
,	O
k3	O
,	O
k4	O
,	O
av1	O
,	O
flk4	O
;	O
ulong	O
si	O
,	O
qp	O
;	O
GEN	O
p1	int
,	O
p2	O
,	O
p3	O
,	O
p4	O
,	O
xp	O
,	O
p1p	O
,	O
p2p	O
,	O
pp	O
;	O
TEMPVARS	O
ulong	O
hiremainder	O
,	O
overflow	O
;	O
if	O
(	O
!	O
sy	O
)	O
err	()->(int)
(	O
dvmer1	O
)	O
;	O
if	O
(	O
!	O
sx	O
)	O
{	O
if	O
(	O
(	O
(	O
plong	int
)	O
z	O
==	O
0xffffffff	int
)	O
||	O
(	O
(	O
plong	int
)	O
z	O
==	O
0	int
)	O
)	O
return	O
gzero	O
;	O
*	O
z	O
=	O
gzero	O
;	O
return	O
gzero	O
;	O
}	O
lx	O
=	O
lgef	O
(	O
x	int
)	O
;	O
ly	O
=	O
lgef	O
(	O
y	int
)	O
;	O
lz	O
=	O
lx	O
-	O
ly	O
;	O
if	O
(	O
lz	O
<	O
0	int
)	O
{	O
if	O
(	O
(	O
plong	int
)	O
z	O
==	O
0xffffffff	int
)	O
return	O
icopy	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
z	O
==	O
0	int
)	O
return	O
gzero	O
;	O
*	O
z	O
=	O
icopy	()->(int)
(	O
x	int
)	O
;	O
return	O
gzero	O
;	O
}	O
av	O
=	O
avma	O
;	O
if	O
(	O
sx	O
<	O
0	int
)	O
sy	O
=	O
-	O
sy	O
;	O
if	O
(	O
ly	O
==	O
3	int
)	O
{	O
int	O
lgp1	O
;	O
si	O
=	O
y	int
[	O
2	int
]	O
;	O
MP_START_HIGH	O
(	O
xp	O
,	O
x	int
,	O
lx	O
)	O
;	O
if	O
(	O
si	O
>	O
(	O
ulong	O
)	O
MP_HIGH	O
(	O
x	int
,	O
lx	O
)	O
)	O
{	O
lgp1	O
=	O
lx	O
-	O
1	int
;	O
hiremainder	O
=	O
MP_NEXT_DOWN	O
(	O
xp	O
)	O
;	O
}	O
else	O
{	O
lgp1	O
=	O
lx	O
;	O
hiremainder	O
=	O
0	int
;	O
}	O
p1	int
=	O
cgeti	()->(int)
(	O
lgp1	O
)	O
;	O
i	O
=	O
MP_COUNT_LG	O
(	O
lgp1	O
)	O
;	O
MP_START_HIGH	O
(	O
p1p	O
,	O
p1	int
,	O
lgp1	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
i	O
)	O
{	O
MP_NEXT_DOWN	O
(	O
p1p	O
)	O
=	O
divll	()->(int)
(	O
MP_NEXT_DOWN	O
(	O
xp	O
)	O
,	O
si	O
)	O
;	O
}	O
if	O
(	O
(	O
plong	int
)	O
z	O
==	O
0xffffffff	int
)	O
{	O
avma	O
=	O
av	O
;	O
if	O
(	O
!	O
hiremainder	O
)	O
return	O
gzero	O
;	O
p2	O
=	O
cgeti	()->(int)
(	O
3	int
)	O
;	O
p2	O
[	O
1	int
]	O
=	O
(	O
sx	O
<<	O
24	int
)	O
+	O
3	int
;	O
p2	O
[	O
2	int
]	O
=	O
hiremainder	O
;	O
return	O
p2	O
;	O
}	O
if	O
(	O
lgp1	O
!=	O
2	int
)	O
{	O
p1	int
[	O
1	int
]	O
=	O
p1	int
[	O
0	int
]	O
;	O
setsigne	()->(int)
(	O
p1	int
,	O
sy	O
)	O
;	O
}	O
else	O
{	O
avma	O
=	O
av	O
;	O
p1	int
=	O
gzero	O
;	O
}	O
if	O
(	O
z	O
==	O
0	int
)	O
return	O
p1	int
;	O
if	O
(	O
!	O
hiremainder	O
)	O
*	O
z	O
=	O
gzero	O
;	O
else	O
{	O
p2	O
=	O
cgeti	()->(int)
(	O
3	int
)	O
;	O
p2	O
[	O
1	int
]	O
=	O
(	O
sx	O
<<	O
24	int
)	O
+	O
3	int
;	O
p2	O
[	O
2	int
]	O
=	O
hiremainder	O
;	O
*	O
z	O
=	O
p2	O
;	O
}	O
return	O
p1	int
;	O
}	O
else	O
{	O
p1	int
=	O
cgeti	()->(int)
(	O
lx	O
)	O
;	O
sh	O
=	O
bfffo	O
(	O
y	int
[	O
2	int
]	O
)	O
;	O
if	O
(	O
sh	O
)	O
{	O
GEN	O
p2p	O
,	O
yp	O
;	O
MP_START_HIGH	O
(	O
yp	O
,	O
y	int
,	O
ly	O
)	O
;	O
p2	O
=	O
cgeti	()->(int)
(	O
ly	O
)	O
;	O
k	O
=	O
shiftl	O
(	O
MP_NEXT_DOWN	O
(	O
yp	O
)	O
,	O
sh	O
)	O
;	O
MP_START_HIGH	O
(	O
p2p	O
,	O
p2	O
,	O
ly	O
)	O
;	O
i	O
=	O
MP_COUNT_LG	O
(	O
ly	O
-	O
1	int
)	O
;	O
WHILE_COUNT	O
(	O
--	O
i	O
)	O
{	O
k1	O
=	O
shiftl	O
(	O
MP_NEXT_DOWN	O
(	O
yp	O
)	O
,	O
sh	O
)	O
;	O
MP_NEXT_DOWN	O
(	O
p2p	O
)	O
=	O
k	O
+	O
hiremainder	O
;	O
k	O
=	O
k1	O
;	O
}	O
MP_NEXT_DOWN	O
(	O
p2p	O
)	O
=	O
k	O
;	O
k	O
=	O
0	int
;	O
MP_START_HIGH	O
(	O
xp	O
,	O
x	int
,	O
lx	O
)	O
;	O
MP_START_HIGH	O
(	O
p1p	O
,	O
p1	int
,	O
lx	O
)	O
;	O
MP_NEXT_UP	O
(	O
p1p	O
)	O
;	O
i	O
=	O
MP_COUNT_LG	O
(	O
lx	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
i	O
)	O
{	O
k1	O
=	O
shiftl	O
(	O
MP_NEXT_DOWN	O
(	O
xp	O
)	O
,	O
sh	O
)	O
;	O
MP_NEXT_DOWN	O
(	O
p1p	O
)	O
=	O
k	O
+	O
hiremainder	O
;	O
k	O
=	O
k1	O
;	O
}	O
MP_NEXT_DOWN	O
(	O
p1p	O
)	O
=	O
k	O
;	O
}	O
else	O
{	O
MP_START_HIGH	O
(	O
xp	O
,	O
x	int
,	O
lx	O
)	O
;	O
MP_START_HIGH	O
(	O
p1p	O
,	O
p1	int
,	O
lx	O
)	O
;	O
MP_NEXT_UP	O
(	O
p1p	O
)	O
;	O
MP_NEXT_DOWN	O
(	O
p1p	O
)	O
=	O
0	int
;	O
j	O
=	O
MP_COUNT_LG	O
(	O
lx	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
j	O
)	O
{	O
MP_NEXT_DOWN	O
(	O
p1p	O
)	O
=	O
MP_NEXT_DOWN	O
(	O
xp	O
)	O
;	O
}	O
p2	O
=	O
y	int
;	O
}	O
si	O
=	O
p2	O
[	O
2	int
]	O
;	O
saux	O
=	O
p2	O
[	O
3	int
]	O
;	O
MP_START_HIGH	O
(	O
p1p	O
,	O
p1	int
,	O
lx	O
)	O
;	O
MP_NEXT_UP	O
(	O
p1p	O
)	O
;	O
i	O
=	O
COUNT	O
(	O
lz	O
+	O
1	int
)	O
;	O
WHILE_COUNT	O
(	O
--	O
i	O
)	O
{	O
GEN	O
pp	O
;	O
if	O
(	O
MP_NEXT_DOWN	O
(	O
p1p	O
)	O
==	O
si	O
)	O
{	O
qp	O
=	O
0xffffffff	int
;	O
k	O
=	O
addll	O
(	O
si	O
,	O
*	O
p1p	O
)	O
;	O
}	O
else	O
{	O
hiremainder	O
=	O
p1p	O
[	O
-	O
1	int
]	O
;	O
qp	O
=	O
divll	()->(int)
(	O
*	O
p1p	O
,	O
si	O
)	O
;	O
overflow	O
=	O
0	int
;	O
k	O
=	O
hiremainder	O
;	O
}	O
if	O
(	O
!	O
overflow	O
)	O
{	O
k1	O
=	O
mulll	()->(int)
(	O
qp	O
,	O
saux	O
)	O
;	O
k3	O
=	O
subll	O
(	O
k1	O
,	O
p1p	O
[	O
1	int
]	O
)	O
;	O
k4	O
=	O
subllx	O
(	O
hiremainder	O
,	O
k	O
)	O
;	O
while	O
(	O
(	O
!	O
overflow	O
)	O
&&	O
k4	O
)	O
{	O
qp	O
--	O
;	O
k3	O
=	O
subll	O
(	O
k3	O
,	O
saux	O
)	O
;	O
k4	O
=	O
subllx	O
(	O
k4	O
,	O
si	O
)	O
;	O
}	O
}	O
hiremainder	O
=	O
0	int
;	O
j	O
=	O
MP_COUNT_LG	O
(	O
ly	O
)	O
;	O
MP_START_LOW	O
(	O
pp	O
,	O
p1p	O
,	O
ly	O
-	O
2	int
)	O
;	O
MP_START_LOW	O
(	O
p2p	O
,	O
p2	O
,	O
ly	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
j	O
)	O
{	O
GEN	O
ppp	O
;	O
k1	O
=	O
addmul	O
(	O
qp	O
,	O
MP_NEXT_UP	O
(	O
p2p	O
)	O
)	O
;	O
ppp	O
=	O
&	O
MP_NEXT_UP	O
(	O
pp	O
)	O
;	O
*	O
ppp	O
=	O
subll	O
(	O
*	O
ppp	O
,	O
k1	O
)	O
;	O
hiremainder	O
+=	O
overflow	O
;	O
}	O
if	O
(	O
(	O
ulong	O
)	O
p1p	O
[	O
-	O
1	int
]	O
<	O
(	O
ulong	O
)	O
hiremainder	O
)	O
{	O
overflow	O
=	O
0	int
;	O
qp	O
--	O
;	O
j	O
=	O
MP_COUNT_LG	O
(	O
ly	O
)	O
;	O
MP_START_LOW	O
(	O
pp	O
,	O
p1p	O
,	O
ly	O
-	O
2	int
)	O
;	O
MP_START_LOW	O
(	O
p2p	O
,	O
p2	O
,	O
ly	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
j	O
)	O
{	O
GEN	O
ppp	O
=	O
&	O
MP_NEXT_UP	O
(	O
pp	O
)	O
;	O
ADDLLX	O
(	O
*	O
ppp	O
,	O
MP_NEXT_UP	O
(	O
p2p	O
)	O
,	O
*	O
ppp	O
)	O
;	O
}	O
}	O
p1p	O
[	O
-	O
1	int
]	O
=	O
qp	O
;	O
}	O
av1	O
=	O
avma	O
;	O
if	O
(	O
(	O
plong	int
)	O
z	O
!=	O
0xffffffff	int
)	O
{	O
ulong	O
lgp3	O
=	O
lz	O
+	O
2	int
;	O
MP_START_LOW	O
(	O
p1p	O
,	O
p1	int
,	O
lgp3	O
)	O
;	O
if	O
(	O
p1	int
[	O
1	int
]	O
)	O
{	O
lgp3	O
++	O
;	O
}	O
else	O
if	O
(	O
lz	O
==	O
0	int
)	O
sy	O
=	O
0	int
;	O
p3	O
=	O
cgeti	()->(int)
(	O
lgp3	O
)	O
;	O
MP_START_LOW	O
(	O
pp	O
,	O
p3	O
,	O
lgp3	O
)	O
;	O
j	O
=	O
MP_COUNT_LG	O
(	O
lgp3	O
)	O
;	O
WHILE_COUNT	O
(	O
--	O
j	O
)	O
{	O
MP_NEXT_UP	O
(	O
pp	O
)	O
=	O
MP_NEXT_UP	O
(	O
p1p	O
)	O
;	O
}	O
if	O
(	O
lgp3	O
<	O
3	int
)	O
{	O
p3	O
[	O
1	int
]	O
=	O
2	int
;	O
}	O
else	O
{	O
p3	O
[	O
1	int
]	O
=	O
p3	O
[	O
0	int
]	O
;	O
setsigne	()->(int)
(	O
p3	O
,	O
sy	O
)	O
;	O
}	O
}	O
if	O
(	O
z	O
!=	O
0	int
)	O
{	O
for	O
(	O
j	O
=	O
lz	O
+	O
2	int
;	O
(	O
j	O
<	O
lx	O
)	O
&&	O
(	O
!	O
p1	int
[	O
j	O
]	O
)	O
;	O
j	O
++	O
)	O
;	O
if	O
(	O
j	O
==	O
lx	O
)	O
p4	O
=	O
icopy	()->(int)
(	O
gzero	O
)	O
;	O
else	O
{	O
p4	O
=	O
cgeti	()->(int)
(	O
lx	O
-	O
j	O
+	O
2	int
)	O
;	O
p4	O
[	O
1	int
]	O
=	O
p4	O
[	O
0	int
]	O
;	O
if	O
(	O
!	O
sh	O
)	O
for	O
(	O
i	O
=	O
2	int
;	O
j	O
<	O
lx	O
;	O
j	O
++	O
,	O
i	O
++	O
)	O
p4	O
[	O
i	O
]	O
=	O
p1	int
[	O
j	O
]	O
;	O
else	O
{	O
hiremainder	O
=	O
0	int
;	O
k1	O
=	O
shiftlr	O
(	O
p1	int
[	O
j	O
++	O
]	O
,	O
sh	O
)	O
;	O
k	O
=	O
hiremainder	O
;	O
if	O
(	O
k1	O
)	O
{	O
p4	O
[	O
2	int
]	O
=	O
k1	O
;	O
dec	O
=	O
1	int
;	O
}	O
else	O
{	O
p4	O
[	O
1	int
]	O
=	O
p4	O
[	O
0	int
]	O
-	O
1	int
;	O
p4	O
++	O
;	O
avma	O
+=	O
4	int
;	O
p4	O
[	O
1	int
]	O
=	O
p4	O
[	O
0	int
]	O
;	O
dec	O
=	O
0	int
;	O
}	O
for	O
(	O
i	O
=	O
2	int
+	O
dec	O
;	O
j	O
<	O
lx	O
;	O
j	O
++	O
,	O
i	O
++	O
)	O
{	O
p4	O
[	O
i	O
]	O
=	O
shiftlr	O
(	O
p1	int
[	O
j	O
]	O
,	O
sh	O
)	O
+	O
k	O
;	O
k	O
=	O
hiremainder	O
;	O
}	O
}	O
setsigne	()->(int)
(	O
p4	O
,	O
sx	O
)	O
;	O
}	O
}	O
if	O
(	O
(	O
plong	int
)	O
z	O
==	O
0xffffffff	int
)	O
return	O
gerepile	O
(	O
av	O
,	O
av1	O
,	O
p4	O
)	O
;	O
if	O
(	O
(	O
plong	int
)	O
z	O
==	O
0	int
)	O
return	O
gerepile	O
(	O
av	O
,	O
av1	O
,	O
p3	O
)	O
;	O
dec	O
=	O
lpile	O
(	O
av	O
,	O
av1	O
,	O
0	int
)	O
>>	O
2	int
;	O
*	O
z	O
=	O
p4	O
+	O
dec	O
;	O
return	O
p3	O
+	O
dec	O
;	O
}	O
}	O
