extern	O
int	O
swparse_outputfd	int
;	O
int	O
swparse_construct_attribute	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char),int,int,char,int)->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
uxfio_ofd	int
,	O
char	O
*	O
src	*(char)
,	O
int	O
cmd	int
,	O
int	O
level	int
,	O
char	O
s_keytype	char
,	O
int	O
form_flag	int
)	O
;	O
static	O
int	O
do_indent_only	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
outputfd	int
,	O
int	O
level	int
)	O
;	O
static	O
int	O
do_not_warn_utf	int
;	O
static	O
void	O
squash_non_ascii_chars	(*(char))->(void)
(	O
unsigned	O
char	O
*	O
ptr	*(char)
)	O
{	O
unsigned	O
char	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
;	O
s	*(struct(*(char),*(char),int,int,int,char,int))
=	O
ptr	*(char)
;	O
while	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
)	O
{	O
if	O
(	O
*	O
s	*(struct(*(char),*(char),int,int,int,char,int))
<=	O
127	int
)	O
{	O
;	O
}	O
else	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
,	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+	O
1	int
,	O
(	O
size_t	long
)	O
(	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
(	O
s	*(struct(*(char),*(char),int,int,int,char,int))
+	O
1	int
)	O
)	O
+	O
1	int
)	O
)	O
;	O
}	O
s	*(struct(*(char),*(char),int,int,int,char,int))
++	O
;	O
}	O
}	O
static	O
void	O
check_keyword	(*(char))->(void)
(	O
char	O
*	O
w	*(char)
)	O
{	O
}	O
static	O
int	O
check_ignores	(*(char),*(*(char)))->(int)
(	O
char	O
*	O
line	*(char)
,	O
char	O
*	O
*	O
ignores	*(*(char))
)	O
{	O
char	O
*	O
*	O
sp	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
=	O
ignores	*(*(char))
;	O
while	O
(	O
*	O
sp	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
line	*(char)
,	O
*	O
sp	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
,	O
strlen	(*(char))->(long)
(	O
*	O
sp	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
)	O
)	O
==	O
0	int
)	O
return	O
1	int
;	O
sp	*(struct(int,int,int,int,*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(struct(*(char),*(char),int,int,int,char,int)),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(int,int,*(struct`),*(struct`))),int,int,int))
++	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
do_indent_only	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
outputfd	int
,	O
int	O
level	int
)	O
{	O
char	O
*	O
keyword	*(char)
=	O
strob_get_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
char	O
*	O
value	int
=	O
strchr	(*(char),int)->(*(char))
(	O
strob_get_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
)	O
,	O
(	O
int	O
)	O
' '	O
)	O
;	O
if	O
(	O
value	int
)	O
{	O
*	O
value	int
=	O
'\0'	O
;	O
value	int
++	O
;	O
return	O
swdef_write_attribute	(*(char),*(char),int,int,int,int)->(int)
(	O
keyword	*(char)
,	O
value	int
,	O
level	int
,	O
0	int
,	O
'A'	O
,	O
outputfd	int
)	O
;	O
}	O
else	O
{	O
return	O
swdef_write_attribute	(*(char),*(char),int,int,int,int)->(int)
(	O
keyword	*(char)
,	O
value	int
,	O
level	int
,	O
(	O
int	O
)	O
0	int
,	O
'O'	O
,	O
outputfd	int
)	O
;	O
}	O
}	O
int	O
swparse_write_attribute_att	(int,*(char),*(char),int,int)->(int)
(	O
int	O
outputfd	int
,	O
char	O
*	O
key	*(char)
,	O
char	O
*	O
val	array(int)
,	O
int	O
level	int
,	O
int	O
form_flag	int
)	O
{	O
int	O
ret	int
,	O
newlen	*(int)
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
;	O
char	O
*	O
p	*(char)
;	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
12	int
)	O
;	O
check_keyword	(*(char))->(void)
(	O
key	*(char)
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
key	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
" "	*(char)
)	O
;	O
swparse_expand_n	(*(*(void)),*(int),*(char))->(int)
(	O
(	O
void	O
*	O
*	O
)	O
(	O
&	O
p	*(char)
)	O
,	O
&	O
newlen	*(int)
,	O
val	array(int)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
p	*(char)
)	O
;	O
if	O
(	O
p	*(char)
)	O
swbis_free	O
(	O
p	*(char)
)	O
;	O
ret	int
=	O
swparse_construct_attribute	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char),int,int,char,int)->(int)
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
outputfd	int
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
,	O
SWPARSE_ACMD_EMIT	int
,	O
level	int
,	O
SWPARSE_MD_TYPE_ATT	char
,	O
form_flag	int
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swparse_ignore_attribute	(int,int,*(char))->(int)
(	O
int	O
filetype	*(char)
,	O
int	O
location	int
,	O
char	O
*	O
line	*(char)
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
char	O
*	O
psf_file_ignores	array(*(char))
[	O
]	O
=	O
{	O
"cksum "	*(char)
,	O
"compressed_cksum "	*(char)
,	O
"compressed_size "	*(char)
,	O
"compression_state "	*(char)
,	O
"compression_type "	*(char)
,	O
"size "	*(char)
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
char	O
*	O
psf_fileset_ignores	array(*(char))
[	O
]	O
=	O
{	O
"location "	*(char)
,	O
"media_sequence_number "	*(char)
,	O
"size "	*(char)
,	O
"state "	*(char)
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
char	O
*	O
psf_bundle_ignores	array(*(char))
[	O
]	O
=	O
{	O
"location "	*(char)
,	O
"qualifier "	*(char)
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
char	O
*	O
psf_distribution_ignores	array(*(char))
[	O
]	O
=	O
{	O
"uuid "	*(char)
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
char	O
*	O
info_file_ignores	array(*(char))
[	O
]	O
=	O
{	O
"source "	*(char)
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
char	O
*	O
index_ignores	array(*(char))
[	O
]	O
=	O
{	O
"size "	*(char)
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
;	O
if	O
(	O
filetype	*(char)
==	O
SWPARSE_SWDEF_FILETYPE_INFO	int
)	O
{	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_FILE	int
)	O
{	O
ret	int
=	O
check_ignores	(*(char),*(*(char)))->(int)
(	O
line	*(char)
,	O
info_file_ignores	array(*(char))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
filetype	*(char)
==	O
SWPARSE_SWDEF_FILETYPE_PSF	int
)	O
{	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_FILE	int
)	O
{	O
ret	int
=	O
check_ignores	(*(char),*(*(char)))->(int)
(	O
line	*(char)
,	O
psf_file_ignores	array(*(char))
)	O
;	O
}	O
else	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_CONTROL_FILE	int
)	O
{	O
ret	int
=	O
check_ignores	(*(char),*(*(char)))->(int)
(	O
line	*(char)
,	O
psf_file_ignores	array(*(char))
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
ret	int
=	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
line	*(char)
,	O
"result "	*(char)
,	O
strlen	(*(char))->(long)
(	O
"result "	*(char)
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_FILESET	int
)	O
{	O
ret	int
=	O
check_ignores	(*(char),*(*(char)))->(int)
(	O
line	*(char)
,	O
psf_fileset_ignores	array(*(char))
)	O
;	O
}	O
else	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_BUNDLE	int
)	O
{	O
ret	int
=	O
check_ignores	(*(char),*(*(char)))->(int)
(	O
line	*(char)
,	O
psf_bundle_ignores	array(*(char))
)	O
;	O
}	O
else	O
if	O
(	O
location	int
==	O
SWPARSE_ILOC_DISTRIBUTION	int
)	O
{	O
ret	int
=	O
check_ignores	(*(char),*(*(char)))->(int)
(	O
line	*(char)
,	O
psf_distribution_ignores	array(*(char))
)	O
;	O
}	O
}	O
else	O
if	O
(	O
filetype	*(char)
==	O
SWPARSE_SWDEF_FILETYPE_INDEX	int
)	O
{	O
ret	int
=	O
check_ignores	(*(char),*(*(char)))->(int)
(	O
line	*(char)
,	O
index_ignores	array(*(char))
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
swparse_write_attribute_obj	(int,*(char),int,int)->(int)
(	O
int	O
outputfd	int
,	O
char	O
*	O
key	*(char)
,	O
int	O
level	int
,	O
int	O
form_flag	int
)	O
{	O
int	O
ret	int
;	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
;	O
check_keyword	(*(char))->(void)
(	O
key	*(char)
)	O
;	O
if	O
(	O
form_flag	int
&	O
SWPARSE_FORM_INDENT	O
)	O
{	O
return	O
swdef_write_keyword	(*(char),int,int,int)->(int)
(	O
key	*(char)
,	O
level	int
,	O
'O'	O
,	O
outputfd	int
)	O
;	O
}	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
12	int
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
key	*(char)
)	O
;	O
ret	int
=	O
swparse_construct_attribute	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char),int,int,char,int)->(int)
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
outputfd	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
SWPARSE_ACMD_EMIT	int
,	O
level	int
,	O
SWPARSE_MD_TYPE_OBJ	char
,	O
form_flag	int
)	O
;	O
strob_close	(*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
return	O
ret	int
;	O
}	O
void	O
swparse_set_do_not_warn_utf	()->(void)
(	O
void	O
)	O
{	O
do_not_warn_utf	int
=	O
1	int
;	O
}	O
void	O
swparse_unset_do_not_warn_utf	()->(void)
(	O
void	O
)	O
{	O
do_not_warn_utf	int
=	O
0	int
;	O
}	O
int	O
swparse_construct_attribute	(*(struct(*(char),*(char),int,int,int,char,int)),int,*(char),int,int,char,int)->(int)
(	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
outputfd	int
,	O
char	O
*	O
src	*(char)
,	O
int	O
cmd	int
,	O
int	O
level	int
,	O
char	O
s_keytype	char
,	O
int	O
form_flag	int
)	O
{	O
static	O
STROB	struct(*(char),*(char),int,int,int,char,int)
*	O
ustore	*(struct(*(char),*(char),int,int,int,char,int))
;	O
char	O
*	O
ptr	*(char)
,	O
*	O
eptr	*(char)
;	O
char	O
*	O
p	*(char)
;	O
char	O
l_swws	array(char)
[	O
]	O
=	O
"                                       "	*(char)
;	O
int	O
newlen	*(int)
,	O
ret	int
=	O
0	int
,	O
value_length	int
;	O
int	O
extra_len	int
;	O
if	O
(	O
level	int
>	O
10	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
form_flag	int
&	O
SWPARSE_FORM_INDENT	O
)	O
&&	O
cmd	int
==	O
SWPARSE_ACMD_EMIT	int
)	O
{	O
return	O
do_indent_only	(*(struct(*(char),*(char),int,int,int,char,int)),int,int)->(int)
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
outputfd	int
,	O
level	int
)	O
;	O
}	O
l_swws	array(char)
[	O
level	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
form_flag	int
&	O
SWPARSE_FORM_MKUP	O
)	O
||	O
(	O
(	O
form_flag	int
&	O
SWPARSE_FORM_ALL	O
)	O
==	O
0	int
)	O
)	O
{	O
extra_len	int
=	O
0	int
;	O
}	O
else	O
{	O
extra_len	int
=	O
SWPARSE_MKUP_RES	int
;	O
}	O
if	O
(	O
cmd	int
==	O
SWPARSE_ACMD_COPY	int
)	O
{	O
swparse_expand_n	(*(*(void)),*(int),*(char))->(int)
(	O
(	O
void	O
*	O
*	O
)	O
(	O
&	O
p	*(char)
)	O
,	O
&	O
newlen	*(int)
,	O
src	*(char)
)	O
;	O
strob_strcpy	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
p	*(char)
)	O
;	O
swbis_free	O
(	O
p	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
cmd	int
==	O
SWPARSE_ACMD_CAT	int
)	O
{	O
swparse_expand_n	(*(*(void)),*(int),*(char))->(int)
(	O
(	O
void	O
*	O
*	O
)	O
(	O
&	O
p	*(char)
)	O
,	O
&	O
newlen	*(int)
,	O
src	*(char)
)	O
;	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
p	*(char)
)	O
;	O
swbis_free	O
(	O
p	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
cmd	int
==	O
SWPARSE_ACMD_EMIT	int
)	O
{	O
int	O
memlen	int
;	O
ptr	*(char)
=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
if	O
(	O
!	O
strlen	(*(char))->(long)
(	O
ptr	*(char)
)	O
)	O
{	O
strob_strcat	(*(struct(*(char),*(char),int,int,int,char,int)),*(char))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
"\"\""	*(char)
)	O
;	O
ptr	*(char)
=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
}	O
swlib_process_hex_escapes	(*(char))->(int)
(	O
ptr	*(char)
)	O
;	O
if	O
(	O
utf8_valid	(*(char),int)->(int)
(	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
ptr	*(char)
,	O
(	O
unsigned	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ptr	*(char)
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
ustore	*(struct(*(char),*(char),int,int,int,char,int))
)	O
ustore	*(struct(*(char),*(char),int,int,int,char,int))
=	O
strob_open	(long)->(*(struct(*(char),*(char),int,int,int,char,int)))
(	O
100	int
)	O
;	O
swlib_expand_escapes	(*(*(char)),*(int),*(char),*(struct(*(char),*(char),int,int,int,char,int)))->(int)
(	O
NULL	O
,	O
NULL	O
,	O
ptr	*(char)
,	O
ustore	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
if	O
(	O
do_not_warn_utf	int
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: warning: invalid UTF-8 characters: %s\n"	*(char)
,	O
swlib_utilname_get	()->(*(char))
(	O
)	O
,	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
ustore	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
}	O
memlen	int
=	O
strlen	(*(char))->(long)
(	O
ptr	*(char)
)	O
+	O
level	int
+	O
6	int
+	O
extra_len	int
;	O
eptr	*(char)
=	O
malloc	(long)->(*(void))
(	O
memlen	int
)	O
;	O
strob_setlen	(*(struct(*(char),*(char),int,int,int,char,int)),int)->(int)
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
,	O
memlen	int
)	O
;	O
ptr	*(char)
=	O
strob_str	(*(struct(*(char),*(char),int,int,int,char,int)))->(*(char))
(	O
strb	*(struct(*(char),*(char),int,int,int,char,int))
)	O
;	O
if	O
(	O
form_flag	int
&	O
SWPARSE_FORM_MKUP	O
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
eptr	*(char)
,	O
memlen	int
,	O
"%c%02d%s%s\n"	*(char)
,	O
s_keytype	char
,	O
level	int
,	O
l_swws	array(char)
,	O
ptr	*(char)
)	O
;	O
eptr	*(char)
[	O
memlen	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
form_flag	int
&	O
SWPARSE_FORM_MKUP_LEN	O
)	O
{	O
p	*(char)
=	O
ptr	*(char)
;	O
while	O
(	O
*	O
p	*(char)
&&	O
!	O
isspace	(int)->(int)
(	O
(	O
int	O
)	O
*	O
p	*(char)
)	O
)	O
p	*(char)
++	O
;	O
p	*(char)
++	O
;	O
value_length	int
=	O
strlen	(*(char))->(long)
(	O
p	*(char)
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
eptr	*(char)
,	O
memlen	int
,	O
"%-"	*(char)
SWPARSE_MKUP_LEN_WIDTH_C	*(char)
"d %c%02d %s\n"	*(char)
,	O
value_length	int
,	O
s_keytype	char
,	O
level	int
,	O
ptr	*(char)
)	O
;	O
eptr	*(char)
[	O
memlen	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
ret	int
=	O
uxfio_write	(int,*(void),long)->(long)
(	O
outputfd	int
,	O
eptr	*(char)
,	O
strlen	(*(char))->(long)
(	O
eptr	*(char)
)	O
)	O
;	O
swbis_free	O
(	O
eptr	*(char)
)	O
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
swparse_print_filename	(*(char),int,*(char),*(char),*(char),int)->(int)
(	O
char	O
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
len	int
,	O
char	O
*	O
filetype	*(char)
,	O
char	O
*	O
ws_level_string	*(char)
,	O
char	O
*	O
lex_filename	*(char)
,	O
int	O
form_flag	int
)	O
{	O
int	O
value_length	int
;	O
if	O
(	O
form_flag	int
&	O
SWPARSE_FORM_MKUP	O
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
len	int
,	O
"F%02d %s%s %s\n"	*(char)
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ws_level_string	*(char)
)	O
+	O
1	int
,	O
ws_level_string	*(char)
,	O
filetype	*(char)
,	O
lex_filename	*(char)
)	O
;	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
uxfio_write	(int,*(void),long)->(long)
(	O
swparse_outputfd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
strlen	(*(char))->(long)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
}	O
else	O
{	O
value_length	int
=	O
strlen	(*(char))->(long)
(	O
lex_filename	*(char)
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
len	int
,	O
"%-"	*(char)
SWPARSE_MKUP_LEN_WIDTH_C	*(char)
"d F%02d %s%s %s\n"	*(char)
,	O
(	O
int	O
)	O
value_length	int
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ws_level_string	*(char)
)	O
+	O
1	int
,	O
ws_level_string	*(char)
,	O
filetype	*(char)
,	O
lex_filename	*(char)
)	O
;	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
uxfio_write	(int,*(void),long)->(long)
(	O
swparse_outputfd	int
,	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
strlen	(*(char))->(long)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swparse_print_filename_by_fd	(*(char),int,int,*(char),*(char),*(char),int)->(int)
(	O
char	O
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
int	O
len	int
,	O
int	O
fd	int
,	O
char	O
*	O
filetype	*(char)
,	O
char	O
*	O
ws_level_string	*(char)
,	O
char	O
*	O
lex_filename	*(char)
,	O
int	O
form_flag	int
)	O
{	O
{	O
swparse_outputfd	int
=	O
fd	int
;	O
return	O
swparse_print_filename	(*(char),int,*(char),*(char),*(char),int)->(int)
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
len	int
,	O
filetype	*(char)
,	O
ws_level_string	*(char)
,	O
lex_filename	*(char)
,	O
form_flag	int
)	O
;	O
}	O
}	O
int	O
utf8_valid	(*(char),int)->(int)
(	O
const	O
unsigned	O
char	O
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
,	O
unsigned	O
int	O
len	int
)	O
{	O
const	O
unsigned	O
char	O
*	O
endbuf	*(char)
=	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
+	O
len	int
;	O
unsigned	O
char	O
byte2mask	char
=	O
0x00	int
,	O
c	int
;	O
int	O
trailing	int
=	O
0	int
;	O
while	O
(	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
!=	O
endbuf	*(char)
)	O
{	O
c	int
=	O
*	O
buf	*(struct(*(char),*(char),int,int,int,char,int))
++	O
;	O
if	O
(	O
trailing	int
)	O
{	O
if	O
(	O
(	O
c	int
&	O
0xC0	int
)	O
==	O
0x80	int
)	O
{	O
if	O
(	O
byte2mask	char
)	O
{	O
if	O
(	O
c	int
&	O
byte2mask	char
)	O
byte2mask	char
=	O
0x00	int
;	O
else	O
return	O
0	int
;	O
}	O
trailing	int
--	O
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
c	int
&	O
0x80	int
)	O
==	O
0x00	int
)	O
continue	O
;	O
else	O
if	O
(	O
(	O
c	int
&	O
0xE0	int
)	O
==	O
0xC0	int
)	O
if	O
(	O
c	int
&	O
0x1E	int
)	O
trailing	int
=	O
1	int
;	O
else	O
return	O
0	int
;	O
else	O
if	O
(	O
(	O
c	int
&	O
0xF0	int
)	O
==	O
0xE0	int
)	O
{	O
if	O
(	O
!	O
(	O
c	int
&	O
0x0F	int
)	O
)	O
byte2mask	char
=	O
0x20	int
;	O
trailing	int
=	O
2	int
;	O
}	O
else	O
if	O
(	O
(	O
c	int
&	O
0xF8	int
)	O
==	O
0xF0	int
)	O
{	O
if	O
(	O
!	O
(	O
c	int
&	O
0x07	int
)	O
)	O
byte2mask	char
=	O
0x30	int
;	O
trailing	int
=	O
3	int
;	O
}	O
else	O
if	O
(	O
(	O
c	int
&	O
0xFC	int
)	O
==	O
0xF8	int
)	O
{	O
if	O
(	O
!	O
(	O
c	int
&	O
0x03	int
)	O
)	O
byte2mask	char
=	O
0x38	int
;	O
trailing	int
=	O
4	int
;	O
}	O
else	O
if	O
(	O
(	O
c	int
&	O
0xFE	int
)	O
==	O
0xFC	int
)	O
{	O
if	O
(	O
!	O
(	O
c	int
&	O
0x01	int
)	O
)	O
byte2mask	char
=	O
0x3C	int
;	O
trailing	int
=	O
5	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
}	O
return	O
trailing	int
==	O
0	int
;	O
}	O
