int	O
outputting_stabs_line_debug	O
=	O
0	int
;	O
static	O
void	O
generate_asm_file	O
(	O
int	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
in_dot_func_p	O
=	O
FALSE	O
;	O
static	O
const	O
char	O
*	O
current_function_label	O
;	O
unsigned	O
int	O
get_stab_string_offset	O
(	O
const	O
char	O
*	O
string	*(char)
,	O
const	O
char	O
*	O
stabstr_secname	O
,	O
bfd_boolean	int
free_stabstr_secname	O
)	O
{	O
unsigned	O
int	O
length	O
;	O
unsigned	O
int	O
retval	O
;	O
segT	O
save_seg	O
;	O
subsegT	O
save_subseg	O
;	O
segT	O
seg	O
;	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
!	O
SEPARATE_STAB_SECTIONS	O
)	O
abort	()->(void)
(	O
)	O
;	O
length	O
=	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
;	O
save_seg	O
=	O
now_seg	O
;	O
save_subseg	O
=	O
now_subseg	O
;	O
seg	O
=	O
subseg_new	O
(	O
stabstr_secname	O
,	O
0	int
)	O
;	O
if	O
(	O
free_stabstr_secname	O
&&	O
seg	O
->	O
name	*(char)
!=	O
stabstr_secname	O
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
stabstr_secname	O
)	O
;	O
retval	O
=	O
seg_info	O
(	O
seg	O
)	O
->	O
stabu	O
.	O
stab_string_size	O
;	O
if	O
(	O
retval	O
<=	O
0	int
)	O
{	O
p	*(void)
=	O
frag_more	O
(	O
1	int
)	O
;	O
*	O
p	*(void)
=	O
0	int
;	O
retval	O
=	O
seg_info	O
(	O
seg	O
)	O
->	O
stabu	O
.	O
stab_string_size	O
=	O
1	int
;	O
bfd_set_section_flags	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int)->(int)
(	O
seg	O
,	O
SEC_READONLY	O
|	O
SEC_DEBUGGING	O
)	O
;	O
}	O
if	O
(	O
length	O
>	O
0	int
)	O
{	O
p	*(void)
=	O
frag_more	O
(	O
length	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
string	*(char)
)	O
;	O
seg_info	O
(	O
seg	O
)	O
->	O
stabu	O
.	O
stab_string_size	O
+=	O
length	O
+	O
1	int
;	O
}	O
else	O
retval	O
=	O
0	int
;	O
subseg_set	O
(	O
save_seg	O
,	O
save_subseg	O
)	O
;	O
return	O
retval	O
;	O
}	O
static	O
void	O
s_stab_generic	O
(	O
int	O
what	O
,	O
const	O
char	O
*	O
stab_secname	O
,	O
const	O
char	O
*	O
stabstr_secname	O
,	O
const	O
char	O
*	O
stab_secname_obstack_end	O
)	O
{	O
long	O
longint	O
;	O
const	O
char	O
*	O
string	*(char)
;	O
char	O
*	O
saved_string_obstack_end	O
;	O
int	O
type	char
;	O
int	O
other	O
;	O
int	O
desc	O
;	O
if	O
(	O
what	O
!=	O
's'	O
)	O
{	O
string	*(char)
=	O
""	*(char)
;	O
saved_string_obstack_end	O
=	O
0	int
;	O
}	O
else	O
{	O
int	O
length	O
;	O
string	*(char)
=	O
demand_copy_C_string	O
(	O
&	O
length	O
)	O
;	O
if	O
(	O
string	*(char)
==	O
NULL	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
".stab%c: missing string"	*(char)
)	O
,	O
what	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
saved_string_obstack_end	O
=	O
obstack_next_free	O
(	O
&	O
notes	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
input_line_pointer	O
++	O
;	O
else	O
{	O
as_warn	O
(	O
_	O
(	O
".stab%c: missing comma"	*(char)
)	O
,	O
what	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
get_absolute_expression_and_terminator	O
(	O
&	O
longint	O
)	O
!=	O
','	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
".stab%c: missing comma"	*(char)
)	O
,	O
what	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
type	char
=	O
longint	O
;	O
if	O
(	O
get_absolute_expression_and_terminator	O
(	O
&	O
longint	O
)	O
!=	O
','	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
".stab%c: missing comma"	*(char)
)	O
,	O
what	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
other	O
=	O
longint	O
;	O
desc	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
if	O
(	O
(	O
desc	O
>	O
0xffff	int
)	O
||	O
(	O
desc	O
<	O
-	O
0x8000	int
)	O
)	O
as_warn	O
(	O
_	O
(	O
".stab%c: description field '%x' too big, try a different debug format"	*(char)
)	O
,	O
what	O
,	O
desc	O
)	O
;	O
if	O
(	O
what	O
==	O
's'	O
||	O
what	O
==	O
'n'	O
)	O
{	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
".stab%c: missing comma"	*(char)
)	O
,	O
what	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
input_line_pointer	O
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
if	O
(	O
listing	O
)	O
{	O
switch	O
(	O
type	char
)	O
{	O
case	O
N_SLINE	O
:	O
listing_source_line	O
(	O
(	O
unsigned	O
int	O
)	O
desc	O
)	O
;	O
break	O
;	O
case	O
N_SO	O
:	O
case	O
N_SOL	O
:	O
listing_source_file	O
(	O
string	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
SEPARATE_STAB_SECTIONS	O
)	O
{	O
segT	O
saved_seg	O
=	O
now_seg	O
;	O
subsegT	O
saved_subseg	O
=	O
now_subseg	O
;	O
fragS	O
*	O
saved_frag	O
=	O
frag_now	O
;	O
valueT	O
dot	O
;	O
segT	O
seg	O
;	O
unsigned	O
int	O
stroff	O
;	O
char	O
*	O
p	*(void)
;	O
static	O
segT	O
cached_sec	O
;	O
dot	O
=	O
frag_now_fix	O
(	O
)	O
;	O
if	O
(	O
cached_sec	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
cached_sec	O
->	O
name	*(char)
,	O
stab_secname	O
)	O
==	O
0	int
)	O
{	O
seg	O
=	O
cached_sec	O
;	O
subseg_set	O
(	O
seg	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
seg	O
=	O
subseg_new	O
(	O
stab_secname	O
,	O
0	int
)	O
;	O
cached_sec	O
=	O
seg	O
;	O
}	O
if	O
(	O
!	O
seg_info	O
(	O
seg	O
)	O
->	O
hadone	O
)	O
{	O
bfd_set_section_flags	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int)->(int)
(	O
seg	O
,	O
SEC_READONLY	O
|	O
SEC_RELOC	O
|	O
SEC_DEBUGGING	O
)	O
;	O
INIT_STAB_SECTION	O
(	O
seg	O
)	O
;	O
seg_info	O
(	O
seg	O
)	O
->	O
hadone	O
=	O
1	int
;	O
}	O
stroff	O
=	O
get_stab_string_offset	O
(	O
string	*(char)
,	O
stabstr_secname	O
,	O
stab_secname_obstack_end	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
saved_string_obstack_end	O
!=	O
NULL	O
&&	O
saved_string_obstack_end	O
==	O
obstack_next_free	O
(	O
&	O
notes	O
)	O
)	O
obstack_free	O
(	O
&	O
notes	O
,	O
string	*(char)
)	O
;	O
if	O
(	O
seg	O
->	O
name	*(char)
!=	O
stab_secname	O
&&	O
stab_secname_obstack_end	O
!=	O
NULL	O
&&	O
stab_secname_obstack_end	O
==	O
obstack_next_free	O
(	O
&	O
notes	O
)	O
)	O
obstack_free	O
(	O
&	O
notes	O
,	O
stab_secname	O
)	O
;	O
p	*(void)
=	O
frag_more	O
(	O
8	int
)	O
;	O
md_number_to_chars	O
(	O
p	*(void)
,	O
(	O
valueT	O
)	O
stroff	O
,	O
4	int
)	O
;	O
md_number_to_chars	O
(	O
p	*(void)
+	O
4	int
,	O
(	O
valueT	O
)	O
type	char
,	O
1	int
)	O
;	O
md_number_to_chars	O
(	O
p	*(void)
+	O
5	int
,	O
(	O
valueT	O
)	O
other	O
,	O
1	int
)	O
;	O
md_number_to_chars	O
(	O
p	*(void)
+	O
6	int
,	O
(	O
valueT	O
)	O
desc	O
,	O
2	int
)	O
;	O
if	O
(	O
what	O
==	O
's'	O
||	O
what	O
==	O
'n'	O
)	O
{	O
cons	O
(	O
4	int
)	O
;	O
input_line_pointer	O
--	O
;	O
}	O
else	O
{	O
symbolS	O
*	O
symbol	*(struct)
;	O
expressionS	O
exp	O
;	O
symbol	*(struct)
=	O
symbol_temp_new	O
(	O
saved_seg	O
,	O
dot	O
,	O
saved_frag	O
)	O
;	O
exp	O
.	O
X_op	O
=	O
O_symbol	O
;	O
exp	O
.	O
X_add_symbol	O
=	O
symbol	*(struct)
;	O
exp	O
.	O
X_add_number	O
=	O
0	int
;	O
emit_expr	O
(	O
&	O
exp	O
,	O
4	int
)	O
;	O
}	O
subseg_set	O
(	O
saved_seg	O
,	O
saved_subseg	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
stab_secname_obstack_end	O
!=	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
stabstr_secname	O
)	O
;	O
if	O
(	O
stab_secname_obstack_end	O
==	O
obstack_next_free	O
(	O
&	O
notes	O
)	O
)	O
obstack_free	O
(	O
&	O
notes	O
,	O
stab_secname	O
)	O
;	O
}	O
abort	()->(void)
(	O
)	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_stab	O
(	O
int	O
what	O
)	O
{	O
s_stab_generic	O
(	O
what	O
,	O
STAB_SECTION_NAME	O
,	O
STAB_STRING_SECTION_NAME	O
,	O
NULL	O
)	O
;	O
}	O
void	O
s_xstab	O
(	O
int	O
what	O
)	O
{	O
int	O
length	O
;	O
char	O
*	O
stab_secname	O
,	O
*	O
stabstr_secname	O
,	O
*	O
stab_secname_obstack_end	O
;	O
stab_secname	O
=	O
demand_copy_C_string	O
(	O
&	O
length	O
)	O
;	O
stab_secname_obstack_end	O
=	O
obstack_next_free	O
(	O
&	O
notes	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
input_line_pointer	O
++	O
;	O
else	O
{	O
as_bad	O
(	O
_	O
(	O
"comma missing in .xstabs"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
stabstr_secname	O
=	O
concat	O
(	O
stab_secname	O
,	O
"str"	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
s_stab_generic	O
(	O
what	O
,	O
stab_secname	O
,	O
stabstr_secname	O
,	O
stab_secname_obstack_end	O
)	O
;	O
}	O
void	O
stabs_generate_asm_file	O
(	O
void	O
)	O
{	O
const	O
char	O
*	O
file	*(void)
;	O
unsigned	O
int	O
lineno	*(struct(int,union(*(struct),long)))
;	O
file	*(void)
=	O
as_where	O
(	O
&	O
lineno	*(struct(int,union(*(struct),long)))
)	O
;	O
if	O
(	O
use_gnu_debug_info_extensions	O
)	O
{	O
const	O
char	O
*	O
dir	*(char)
;	O
char	O
*	O
dir2	O
;	O
dir	*(char)
=	O
remap_debug_filename	O
(	O
getpwd	O
(	O
)	O
)	O
;	O
dir2	O
=	O
concat	O
(	O
dir	*(char)
,	O
"/"	*(char)
,	O
NULL	O
)	O
;	O
generate_asm_file	O
(	O
N_SO	O
,	O
dir2	O
)	O
;	O
free	(*(void))->(void)
(	O
dir2	O
)	O
;	O
xfree	O
(	O
(	O
char	O
*	O
)	O
dir	*(char)
)	O
;	O
}	O
generate_asm_file	O
(	O
N_SO	O
,	O
file	*(void)
)	O
;	O
}	O
static	O
void	O
generate_asm_file	O
(	O
int	O
type	char
,	O
const	O
char	O
*	O
file	*(void)
)	O
{	O
static	O
char	O
*	O
last_file	O
;	O
static	O
int	O
label_count	O
;	O
char	O
sym	*(struct)
[	O
30	int
]	O
;	O
char	O
*	O
buf	*(void)
;	O
const	O
char	O
*	O
tmp	O
=	O
file	*(void)
;	O
const	O
char	O
*	O
file_endp	O
=	O
file	*(void)
+	O
strlen	(*(char))->(long)
(	O
file	*(void)
)	O
;	O
char	O
*	O
bufp	O
;	O
if	O
(	O
last_file	O
!=	O
NULL	O
&&	O
filename_cmp	O
(	O
last_file	O
,	O
file	*(void)
)	O
==	O
0	int
)	O
return	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
sym	*(struct)
,	O
"%sF%d"	*(char)
,	O
FAKE_LABEL_NAME	O
,	O
label_count	O
)	O
;	O
++	O
label_count	O
;	O
bufp	O
=	O
buf	*(void)
=	O
XNEWVEC	O
(	O
char	O
,	O
2	int
*	O
strlen	(*(char))->(long)
(	O
file	*(void)
)	O
+	O
strlen	(*(char))->(long)
(	O
sym	*(struct)
)	O
+	O
12	int
)	O
;	O
*	O
bufp	O
++	O
=	O
'"'	O
;	O
while	O
(	O
tmp	O
<	O
file_endp	O
)	O
{	O
const	O
char	O
*	O
bslash	O
=	O
strchr	(*(char),int)->(*(char))
(	O
tmp	O
,	O
'\\'	O
)	O
;	O
size_t	long
len	long
=	O
bslash	O
!=	O
NULL	O
?	O
bslash	O
-	O
tmp	O
+	O
1	int
:	O
file_endp	O
-	O
tmp	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
bufp	O
,	O
tmp	O
,	O
len	long
)	O
;	O
tmp	O
+=	O
len	long
;	O
bufp	O
+=	O
len	long
;	O
if	O
(	O
bslash	O
!=	O
NULL	O
)	O
*	O
bufp	O
++	O
=	O
'\\'	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
bufp	O
,	O
"\",%d,0,0,%s\n"	*(char)
,	O
type	char
,	O
sym	*(struct)
)	O
;	O
temp_ilp	O
(	O
buf	*(void)
)	O
;	O
s_stab	O
(	O
's'	O
)	O
;	O
restore_ilp	O
(	O
)	O
;	O
colon	O
(	O
sym	*(struct)
)	O
;	O
if	O
(	O
last_file	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
last_file	O
)	O
;	O
last_file	O
=	O
xstrdup	O
(	O
file	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
}	O
void	O
stabs_generate_asm_lineno	O
(	O
void	O
)	O
{	O
static	O
int	O
label_count	O
;	O
const	O
char	O
*	O
file	*(void)
;	O
unsigned	O
int	O
lineno	*(struct(int,union(*(struct),long)))
;	O
char	O
*	O
buf	*(void)
;	O
char	O
sym	*(struct)
[	O
30	int
]	O
;	O
static	O
unsigned	O
int	O
prev_lineno	O
=	O
-	O
1	int
;	O
static	O
char	O
*	O
prev_file	O
=	O
NULL	O
;	O
file	*(void)
=	O
as_where	O
(	O
&	O
lineno	*(struct(int,union(*(struct),long)))
)	O
;	O
if	O
(	O
prev_file	O
==	O
NULL	O
)	O
{	O
prev_file	O
=	O
xstrdup	O
(	O
file	*(void)
)	O
;	O
prev_lineno	O
=	O
lineno	*(struct(int,union(*(struct),long)))
;	O
}	O
else	O
if	O
(	O
lineno	*(struct(int,union(*(struct),long)))
==	O
prev_lineno	O
&&	O
filename_cmp	O
(	O
file	*(void)
,	O
prev_file	O
)	O
==	O
0	int
)	O
{	O
return	O
;	O
}	O
else	O
{	O
prev_lineno	O
=	O
lineno	*(struct(int,union(*(struct),long)))
;	O
if	O
(	O
filename_cmp	O
(	O
file	*(void)
,	O
prev_file	O
)	O
!=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
prev_file	O
)	O
;	O
prev_file	O
=	O
xstrdup	O
(	O
file	*(void)
)	O
;	O
}	O
}	O
outputting_stabs_line_debug	O
=	O
1	int
;	O
generate_asm_file	O
(	O
N_SOL	O
,	O
file	*(void)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
sym	*(struct)
,	O
"%sL%d"	*(char)
,	O
FAKE_LABEL_NAME	O
,	O
label_count	O
)	O
;	O
++	O
label_count	O
;	O
if	O
(	O
in_dot_func_p	O
)	O
{	O
buf	*(void)
=	O
XNEWVEC	O
(	O
char	O
,	O
100	int
+	O
strlen	(*(char))->(long)
(	O
current_function_label	O
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
"%d,0,%d,%s-%s\n"	*(char)
,	O
N_SLINE	O
,	O
lineno	*(struct(int,union(*(struct),long)))
,	O
sym	*(struct)
,	O
current_function_label	O
)	O
;	O
}	O
else	O
{	O
buf	*(void)
=	O
XNEWVEC	O
(	O
char	O
,	O
100	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
"%d,0,%d,%s\n"	*(char)
,	O
N_SLINE	O
,	O
lineno	*(struct(int,union(*(struct),long)))
,	O
sym	*(struct)
)	O
;	O
}	O
temp_ilp	O
(	O
buf	*(void)
)	O
;	O
s_stab	O
(	O
'n'	O
)	O
;	O
restore_ilp	O
(	O
)	O
;	O
colon	O
(	O
sym	*(struct)
)	O
;	O
outputting_stabs_line_debug	O
=	O
0	int
;	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
}	O
void	O
stabs_generate_asm_func	O
(	O
const	O
char	O
*	O
funcname	O
,	O
const	O
char	O
*	O
startlabname	O
)	O
{	O
static	O
bfd_boolean	int
void_emitted_p	O
=	O
FALSE	O
;	O
char	O
*	O
buf	*(void)
;	O
unsigned	O
int	O
lineno	*(struct(int,union(*(struct),long)))
;	O
if	O
(	O
!	O
void_emitted_p	O
)	O
{	O
temp_ilp	O
(	O
(	O
char	O
*	O
)	O
"\"void:t1=1\",128,0,0,0"	*(char)
)	O
;	O
s_stab	O
(	O
's'	O
)	O
;	O
restore_ilp	O
(	O
)	O
;	O
void_emitted_p	O
=	O
TRUE	int
;	O
}	O
as_where	O
(	O
&	O
lineno	*(struct(int,union(*(struct),long)))
)	O
;	O
if	O
(	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
buf	*(void)
,	O
"\"%s:F1\",%d,0,%d,%s"	*(char)
,	O
funcname	O
,	O
N_FUN	O
,	O
lineno	*(struct(int,union(*(struct),long)))
+	O
1	int
,	O
startlabname	O
)	O
==	O
-	O
1	int
)	O
as_fatal	O
(	O
"%s"	*(char)
,	O
xstrerror	O
(	O
errno	O
)	O
)	O
;	O
temp_ilp	O
(	O
buf	*(void)
)	O
;	O
s_stab	O
(	O
's'	O
)	O
;	O
restore_ilp	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
current_function_label	O
=	O
xstrdup	O
(	O
startlabname	O
)	O
;	O
in_dot_func_p	O
=	O
TRUE	int
;	O
}	O
void	O
stabs_generate_asm_endfunc	O
(	O
const	O
char	O
*	O
funcname	O
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
startlabname	O
)	O
{	O
static	O
int	O
label_count	O
;	O
char	O
*	O
buf	*(void)
;	O
char	O
sym	*(struct)
[	O
30	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
sym	*(struct)
,	O
"%sendfunc%d"	*(char)
,	O
FAKE_LABEL_NAME	O
,	O
label_count	O
)	O
;	O
++	O
label_count	O
;	O
colon	O
(	O
sym	*(struct)
)	O
;	O
if	O
(	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
buf	*(void)
,	O
"\"\",%d,0,0,%s-%s"	*(char)
,	O
N_FUN	O
,	O
sym	*(struct)
,	O
startlabname	O
)	O
==	O
-	O
1	int
)	O
as_fatal	O
(	O
"%s"	*(char)
,	O
xstrerror	O
(	O
errno	O
)	O
)	O
;	O
temp_ilp	O
(	O
buf	*(void)
)	O
;	O
s_stab	O
(	O
's'	O
)	O
;	O
restore_ilp	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
in_dot_func_p	O
=	O
FALSE	O
;	O
current_function_label	O
=	O
NULL	O
;	O
}	O
