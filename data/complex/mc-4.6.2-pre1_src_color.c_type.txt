int	O
disable_colors	int
=	O
0	int
;	O
int	O
use_colors	int
=	O
0	int
;	O
int	O
dialog_colors	array(int)
[	O
4	int
]	O
;	O
int	O
alarm_colors	array(int)
[	O
4	int
]	O
;	O
struct	O
colorpair	struct(*(char),*(char),*(char))
{	O
const	O
char	O
*	O
name	*(char)
;	O
CTYPE	O
fg	*(char)
;	O
CTYPE	O
bg	*(char)
;	O
}	O
;	O
static	O
struct	O
colorpair	struct(*(char),*(char),*(char))
color_map	array(struct(*(char),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"normal="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"selected="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"marked="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"markselect="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"errors="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"menu="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"reverse="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"dnormal="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"dfocus="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"dhotnormal="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"dhotfocus="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"viewunderline="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"menusel="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"menuhot="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"menuhotsel="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"helpnormal="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"helpitalic="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"helpbold="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"helplink="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"helpslink="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"gauge="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"input="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"directory="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"executable="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"link="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"stalelink="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"device="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"special="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"core="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"editnormal="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"editbold="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"editmarked="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"editwhitespace="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"errdhotnormal="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"errdhotfocus="	*(char)
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
struct	O
color_table_s	struct(*(char),int)
{	O
const	O
char	O
*	O
name	*(char)
;	O
int	O
value	*(void)
;	O
}	O
;	O
static	O
struct	O
color_table_s	struct(*(char),int)
const	O
color_table	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"black"	*(char)
,	O
COLOR_BLACK	int
}	O
,	O
{	O
"gray"	*(char)
,	O
COLOR_BLACK	int
|	O
A_BOLD	int
}	O
,	O
{	O
"red"	*(char)
,	O
COLOR_RED	int
}	O
,	O
{	O
"brightred"	*(char)
,	O
COLOR_RED	int
|	O
A_BOLD	int
}	O
,	O
{	O
"green"	*(char)
,	O
COLOR_GREEN	int
}	O
,	O
{	O
"brightgreen"	*(char)
,	O
COLOR_GREEN	int
|	O
A_BOLD	int
}	O
,	O
{	O
"brown"	*(char)
,	O
COLOR_YELLOW	int
}	O
,	O
{	O
"yellow"	*(char)
,	O
COLOR_YELLOW	int
|	O
A_BOLD	int
}	O
,	O
{	O
"blue"	*(char)
,	O
COLOR_BLUE	int
}	O
,	O
{	O
"brightblue"	*(char)
,	O
COLOR_BLUE	int
|	O
A_BOLD	int
}	O
,	O
{	O
"magenta"	*(char)
,	O
COLOR_MAGENTA	int
}	O
,	O
{	O
"brightmagenta"	*(char)
,	O
COLOR_MAGENTA	int
|	O
A_BOLD	int
}	O
,	O
{	O
"cyan"	*(char)
,	O
COLOR_CYAN	int
}	O
,	O
{	O
"brightcyan"	*(char)
,	O
COLOR_CYAN	int
|	O
A_BOLD	int
}	O
,	O
{	O
"lightgray"	*(char)
,	O
COLOR_WHITE	int
}	O
,	O
{	O
"white"	*(char)
,	O
COLOR_WHITE	int
|	O
A_BOLD	int
}	O
,	O
{	O
"default"	*(char)
,	O
0	int
}	O
}	O
;	O
static	O
const	O
char	O
*	O
default_colors	*(char)
=	O
"normal=lightgray,blue:"	*(char)
"selected=black,cyan:"	*(char)
"marked=yellow,blue:"	*(char)
"markselect=yellow,cyan:"	*(char)
"errors=white,red:"	*(char)
"menu=white,cyan:"	*(char)
"reverse=black,lightgray:"	*(char)
"dnormal=black,lightgray:"	*(char)
"dfocus=black,cyan:"	*(char)
"dhotnormal=blue,lightgray:"	*(char)
"dhotfocus=blue,cyan:"	*(char)
"viewunderline=brightred,blue:"	*(char)
"menuhot=yellow,cyan:"	*(char)
"menusel=white,black:"	*(char)
"menuhotsel=yellow,black:"	*(char)
"helpnormal=black,lightgray:"	*(char)
"helpitalic=red,lightgray:"	*(char)
"helpbold=blue,lightgray:"	*(char)
"helplink=black,cyan:"	*(char)
"helpslink=yellow,blue:"	*(char)
"gauge=white,black:"	*(char)
"input=black,cyan:"	*(char)
"directory=white,blue:"	*(char)
"executable=brightgreen,blue:"	*(char)
"link=lightgray,blue:"	*(char)
"stalelink=brightred,blue:"	*(char)
"device=brightmagenta,blue:"	*(char)
"core=red,blue:"	*(char)
"special=black,blue:"	*(char)
"editnormal=lightgray,blue:"	*(char)
"editbold=yellow,blue:"	*(char)
"editmarked=black,cyan:"	*(char)
"editwhitespace=brightblue,blue:"	*(char)
"errdhotnormal=yellow,red:"	*(char)
"errdhotfocus=yellow,lightgray"	*(char)
;	O
static	O
void	O
get_color	(*(char),*(*(char)))->(void)
(	O
const	O
char	O
*	O
cpp	*(char)
,	O
CTYPE	O
*	O
colp	*(*(char))
)	O
{	O
size_t	long
i	array(int)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
ELEMENTS	O
(	O
color_table	array(struct(*(char),int))
)	O
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cpp	*(char)
,	O
color_name	O
(	O
i	array(int)
)	O
)	O
==	O
0	int
)	O
{	O
*	O
colp	*(*(char))
=	O
color_value	O
(	O
i	array(int)
)	O
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
get_two_colors	(*(*(char)),*(struct(*(char),*(char),*(char))))->(void)
(	O
char	O
*	O
*	O
cpp	*(char)
,	O
struct	O
colorpair	struct(*(char),*(char),*(char))
*	O
colorpairp	*(struct(*(char),*(char),*(char)))
)	O
{	O
char	O
*	O
p	*(void)
=	O
*	O
cpp	*(char)
;	O
int	O
state	*(int)
;	O
state	*(int)
=	O
0	int
;	O
for	O
(	O
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
{	O
if	O
(	O
*	O
p	*(void)
==	O
':'	O
)	O
{	O
*	O
p	*(void)
=	O
0	int
;	O
get_color	(*(char),*(*(char)))->(void)
(	O
*	O
cpp	*(char)
,	O
state	*(int)
?	O
&	O
colorpairp	*(struct(*(char),*(char),*(char)))
->	O
bg	*(char)
:	O
&	O
colorpairp	*(struct(*(char),*(char),*(char)))
->	O
fg	*(char)
)	O
;	O
*	O
p	*(void)
=	O
':'	O
;	O
*	O
cpp	*(char)
=	O
p	*(void)
+	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
*	O
p	*(void)
==	O
','	O
)	O
{	O
state	*(int)
=	O
1	int
;	O
*	O
p	*(void)
=	O
0	int
;	O
get_color	(*(char),*(*(char)))->(void)
(	O
*	O
cpp	*(char)
,	O
&	O
colorpairp	*(struct(*(char),*(char),*(char)))
->	O
fg	*(char)
)	O
;	O
*	O
p	*(void)
=	O
','	O
;	O
*	O
cpp	*(char)
=	O
p	*(void)
+	O
1	int
;	O
}	O
}	O
get_color	(*(char),*(*(char)))->(void)
(	O
*	O
cpp	*(char)
,	O
state	*(int)
?	O
&	O
colorpairp	*(struct(*(char),*(char),*(char)))
->	O
bg	*(char)
:	O
&	O
colorpairp	*(struct(*(char),*(char),*(char)))
->	O
fg	*(char)
)	O
;	O
}	O
static	O
void	O
configure_colors_string	(*(char))->(void)
(	O
const	O
char	O
*	O
the_color_string	*(char)
)	O
{	O
char	O
*	O
color_string	*(char)
,	O
*	O
p	*(void)
;	O
size_t	long
i	array(int)
;	O
int	O
found	int
;	O
if	O
(	O
!	O
the_color_string	*(char)
)	O
return	O
;	O
p	*(void)
=	O
color_string	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
the_color_string	*(char)
)	O
;	O
while	O
(	O
color_string	*(char)
&&	O
*	O
color_string	*(char)
)	O
{	O
while	O
(	O
*	O
color_string	*(char)
==	O
' '	O
||	O
*	O
color_string	*(char)
==	O
'\t'	O
)	O
color_string	*(char)
++	O
;	O
found	int
=	O
0	int
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
ELEMENTS	O
(	O
color_map	array(struct(*(char),*(char),*(char)))
)	O
;	O
i	array(int)
++	O
)	O
{	O
int	O
klen	int
;	O
if	O
(	O
!	O
color_map	array(struct(*(char),*(char),*(char)))
[	O
i	array(int)
]	O
.	O
name	*(char)
)	O
continue	O
;	O
klen	int
=	O
strlen	(*(char))->(long)
(	O
color_map	array(struct(*(char),*(char),*(char)))
[	O
i	array(int)
]	O
.	O
name	*(char)
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
color_string	*(char)
,	O
color_map	array(struct(*(char),*(char),*(char)))
[	O
i	array(int)
]	O
.	O
name	*(char)
,	O
klen	int
)	O
==	O
0	int
)	O
{	O
color_string	*(char)
+=	O
klen	int
;	O
get_two_colors	(*(*(char)),*(struct(*(char),*(char),*(char))))->(void)
(	O
&	O
color_string	*(char)
,	O
&	O
color_map	array(struct(*(char),*(char),*(char)))
[	O
i	array(int)
]	O
)	O
;	O
found	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
found	int
)	O
{	O
while	O
(	O
*	O
color_string	*(char)
&&	O
*	O
color_string	*(char)
!=	O
':'	O
)	O
color_string	*(char)
++	O
;	O
if	O
(	O
*	O
color_string	*(char)
)	O
color_string	*(char)
++	O
;	O
}	O
}	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
static	O
void	O
configure_colors	()->(void)
(	O
void	O
)	O
{	O
extern	O
char	O
*	O
command_line_colors	*(char)
;	O
configure_colors_string	(*(char))->(void)
(	O
default_colors	*(char)
)	O
;	O
configure_colors_string	(*(char))->(void)
(	O
setup_color_string	array(char)
)	O
;	O
configure_colors_string	(*(char))->(void)
(	O
term_color_string	array(char)
)	O
;	O
configure_colors_string	(*(char))->(void)
(	O
getenv	(*(char))->(*(char))
(	O
"MC_COLOR_TABLE"	*(char)
)	O
)	O
;	O
configure_colors_string	(*(char))->(void)
(	O
command_line_colors	*(char)
)	O
;	O
}	O
static	O
void	O
load_dialog_colors	()->(void)
(	O
void	O
)	O
{	O
dialog_colors	array(int)
[	O
0	int
]	O
=	O
COLOR_NORMAL	O
;	O
dialog_colors	array(int)
[	O
1	int
]	O
=	O
COLOR_FOCUS	O
;	O
dialog_colors	array(int)
[	O
2	int
]	O
=	O
COLOR_HOT_NORMAL	O
;	O
dialog_colors	array(int)
[	O
3	int
]	O
=	O
COLOR_HOT_FOCUS	O
;	O
alarm_colors	array(int)
[	O
0	int
]	O
=	O
ERROR_COLOR	O
;	O
alarm_colors	array(int)
[	O
1	int
]	O
=	O
REVERSE_COLOR	O
;	O
alarm_colors	array(int)
[	O
2	int
]	O
=	O
ERROR_HOT_NORMAL	O
;	O
alarm_colors	array(int)
[	O
3	int
]	O
=	O
ERROR_HOT_FOCUS	O
;	O
}	O
void	O
init_colors	()->(void)
(	O
void	O
)	O
{	O
size_t	long
i	array(int)
;	O
int	O
hascolors	int
;	O
hascolors	int
=	O
has_colors	()->(int)
(	O
)	O
;	O
if	O
(	O
!	O
disable_colors	int
&&	O
hascolors	int
)	O
{	O
use_colors	int
=	O
1	int
;	O
}	O
if	O
(	O
use_colors	int
)	O
{	O
start_color	O
(	O
)	O
;	O
configure_colors	()->(void)
(	O
)	O
;	O
if	O
(	O
use_colors	int
)	O
{	O
SLtt_set_color	(int,*(char),*(char),*(char))->(int)
(	O
DEFAULT_COLOR_INDEX	int
,	O
NULL	O
,	O
"default"	*(char)
,	O
"default"	*(char)
)	O
;	O
}	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
ELEMENTS	O
(	O
color_map	array(struct(*(char),*(char),*(char)))
)	O
;	O
i	array(int)
++	O
)	O
{	O
if	O
(	O
!	O
color_map	array(struct(*(char),*(char),*(char)))
[	O
i	array(int)
]	O
.	O
name	*(char)
)	O
continue	O
;	O
mc_init_pair	(int,*(char),*(char))->(void)
(	O
i	array(int)
+	O
1	int
,	O
color_map_fg	O
(	O
i	array(int)
)	O
,	O
color_map_bg	O
(	O
i	array(int)
)	O
)	O
;	O
}	O
}	O
load_dialog_colors	()->(void)
(	O
)	O
;	O
}	O
static	O
int	O
max_index	int
=	O
0	int
;	O
static	O
int	O
alloc_color_pair	(*(char),*(char))->(int)
(	O
CTYPE	O
foreground	*(char)
,	O
CTYPE	O
background	*(char)
)	O
{	O
mc_init_pair	(int,*(char),*(char))->(void)
(	O
++	O
max_index	int
,	O
foreground	*(char)
,	O
background	*(char)
)	O
;	O
return	O
max_index	int
;	O
}	O
static	O
struct	O
colors_avail	struct(*(struct(*(struct(*(struct`),*(char),*(char),int)),*(char),*(char),int)),*(char),*(char),int)
{	O
struct	O
colors_avail	struct(*(struct(*(struct(*(struct`),*(char),*(char),int)),*(char),*(char),int)),*(char),*(char),int)
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
char	O
*	O
fg	*(char)
,	O
*	O
bg	*(char)
;	O
int	O
index	(*(char),int)->(*(char))
;	O
}	O
c	int
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
void	O
mc_init_pair	(int,*(char),*(char))->(void)
(	O
int	O
index	(*(char),int)->(*(char))
,	O
CTYPE	O
foreground	*(char)
,	O
CTYPE	O
background	*(char)
)	O
{	O
if	O
(	O
!	O
background	*(char)
)	O
background	*(char)
=	O
"default"	*(char)
;	O
if	O
(	O
!	O
foreground	*(char)
)	O
foreground	*(char)
=	O
"default"	*(char)
;	O
SLtt_set_color	(int,*(char),*(char),*(char))->(int)
(	O
index	(*(char),int)->(*(char))
,	O
""	*(char)
,	O
(	O
char	O
*	O
)	O
foreground	*(char)
,	O
(	O
char	O
*	O
)	O
background	*(char)
)	O
;	O
if	O
(	O
index	(*(char),int)->(*(char))
>	O
max_index	int
)	O
max_index	int
=	O
index	(*(char),int)->(*(char))
;	O
}	O
int	O
try_alloc_color_pair	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
fg	*(char)
,	O
const	O
char	O
*	O
bg	*(char)
)	O
{	O
struct	O
colors_avail	struct(*(struct(*(struct(*(struct`),*(char),*(char),int)),*(char),*(char),int)),*(char),*(char),int)
*	O
p	*(void)
=	O
&	O
c	int
;	O
c	int
.	O
index	(*(char),int)->(*(char))
=	O
EDITOR_NORMAL_COLOR_INDEX	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
(	O
(	O
fg	*(char)
&&	O
p	*(void)
->	O
fg	*(char)
)	O
?	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
fg	*(char)
,	O
p	*(void)
->	O
fg	*(char)
)	O
:	O
fg	*(char)
==	O
p	*(void)
->	O
fg	*(char)
)	O
!=	O
0	int
&&	O
(	O
(	O
bg	*(char)
&&	O
p	*(void)
->	O
bg	*(char)
)	O
?	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
bg	*(char)
,	O
p	*(void)
->	O
bg	*(char)
)	O
:	O
bg	*(char)
==	O
p	*(void)
->	O
bg	*(char)
)	O
!=	O
0	int
)	O
return	O
p	*(void)
->	O
index	(*(char),int)->(*(char))
;	O
if	O
(	O
!	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
break	O
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
g_new	O
(	O
struct	O
colors_avail	struct(*(struct(*(struct(*(struct`),*(char),*(char),int)),*(char),*(char),int)),*(char),*(char),int)
,	O
1	int
)	O
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
0	int
;	O
p	*(void)
->	O
fg	*(char)
=	O
fg	*(char)
?	O
g_strdup	(*(char))->(*(char))
(	O
fg	*(char)
)	O
:	O
0	int
;	O
p	*(void)
->	O
bg	*(char)
=	O
bg	*(char)
?	O
g_strdup	(*(char))->(*(char))
(	O
bg	*(char)
)	O
:	O
0	int
;	O
if	O
(	O
!	O
fg	*(char)
)	O
fg	*(char)
=	O
color_map	array(struct(*(char),*(char),*(char)))
[	O
EDITOR_NORMAL_COLOR_INDEX	int
-	O
1	int
]	O
.	O
fg	*(char)
;	O
if	O
(	O
!	O
bg	*(char)
)	O
bg	*(char)
=	O
color_map	array(struct(*(char),*(char),*(char)))
[	O
EDITOR_NORMAL_COLOR_INDEX	int
-	O
1	int
]	O
.	O
bg	*(char)
;	O
p	*(void)
->	O
index	(*(char),int)->(*(char))
=	O
alloc_color_pair	(*(char),*(char))->(int)
(	O
fg	*(char)
,	O
bg	*(char)
)	O
;	O
return	O
p	*(void)
->	O
index	(*(char),int)->(*(char))
;	O
}	O
void	O
done_colors	()->(void)
(	O
void	O
)	O
{	O
struct	O
colors_avail	struct(*(struct(*(struct(*(struct`),*(char),*(char),int)),*(char),*(char),int)),*(char),*(char),int)
*	O
p	*(void)
,	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
for	O
(	O
p	*(void)
=	O
c	int
.	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
p	*(void)
;	O
p	*(void)
=	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
->	O
fg	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
->	O
bg	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
c	int
.	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
}	O
