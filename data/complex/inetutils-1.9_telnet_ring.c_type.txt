static	O
unsigned	O
long	O
ring_clock	long
=	O
0	int
;	O
int	O
ring_init	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(int)
(	O
Ring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
unsigned	O
char	O
*	O
buffer	*(char)
,	O
int	O
count	int
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
char	O
*	O
)	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
0	int
,	O
sizeof	O
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
;	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
size	int
=	O
count	int
;	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
=	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
=	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
bottom	*(char)
=	O
buffer	*(char)
;	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
top	*(char)
=	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
bottom	*(char)
+	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
size	int
;	O
return	O
1	int
;	O
}	O
void	O
ring_mark	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(void)
(	O
Ring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
{	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
=	O
ring_decrement	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
,	O
1	int
)	O
;	O
}	O
int	O
ring_at_mark	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
Ring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
{	O
if	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
==	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
{	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
void	O
ring_clear_mark	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(void)
(	O
Ring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
{	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
=	O
0	int
;	O
}	O
void	O
ring_supplied	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),int)->(void)
(	O
Ring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
int	O
count	int
)	O
{	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
=	O
ring_increment	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
,	O
count	int
)	O
;	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supplytime	long
=	O
++	O
ring_clock	long
;	O
}	O
void	O
ring_consumed	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),int)->(void)
(	O
Ring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
int	O
count	int
)	O
{	O
if	O
(	O
count	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
&&	O
(	O
ring_subtract	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
<	O
count	int
)	O
)	O
{	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
=	O
0	int
;	O
}	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
=	O
ring_increment	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
,	O
count	int
)	O
;	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consumetime	long
=	O
++	O
ring_clock	long
;	O
if	O
(	O
ring_empty	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
)	O
{	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
=	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
=	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
bottom	*(char)
;	O
}	O
}	O
int	O
ring_empty_count	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
Ring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
{	O
if	O
(	O
ring_empty	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
)	O
{	O
return	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
size	int
;	O
}	O
else	O
{	O
return	O
ring_subtract	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
)	O
;	O
}	O
}	O
int	O
ring_empty_consecutive	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
Ring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
{	O
if	O
(	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
<	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
)	O
||	O
ring_empty	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
)	O
{	O
return	O
ring_subtract	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
top	*(char)
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
)	O
;	O
}	O
else	O
{	O
return	O
ring_subtract	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
)	O
;	O
}	O
}	O
int	O
ring_full_count	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
Ring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
{	O
if	O
(	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
==	O
0	int
)	O
||	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
==	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
)	O
{	O
if	O
(	O
ring_full	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
)	O
{	O
return	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
size	int
;	O
}	O
else	O
{	O
return	O
ring_subtract	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
return	O
ring_subtract	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
;	O
}	O
}	O
int	O
ring_full_consecutive	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
Ring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
{	O
if	O
(	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
==	O
0	int
)	O
||	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
==	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
<	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
||	O
ring_full	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
)	O
{	O
return	O
ring_subtract	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
top	*(char)
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
;	O
}	O
else	O
{	O
return	O
ring_subtract	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
<	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
{	O
return	O
ring_subtract	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
top	*(char)
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
;	O
}	O
else	O
{	O
return	O
ring_subtract	O
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
mark	*(char)
,	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
consume	*(char)
)	O
;	O
}	O
}	O
}	O
void	O
ring_supply_data	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),*(char),int)->(void)
(	O
Ring	struct(*(char),*(char),*(char),*(char),*(char),int,long,long)
*	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
unsigned	O
char	O
*	O
buffer	*(char)
,	O
int	O
count	int
)	O
{	O
int	O
i	int
;	O
while	O
(	O
count	int
)	O
{	O
i	int
=	O
MIN	O
(	O
count	int
,	O
ring_empty_consecutive	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)))->(int)
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
)	O
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
->	O
supply	*(char)
,	O
buffer	*(char)
,	O
i	int
)	O
;	O
ring_supplied	(*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long)),int)->(void)
(	O
ring	*(struct(*(char),*(char),*(char),*(char),*(char),int,long,long))
,	O
i	int
)	O
;	O
count	int
-=	O
i	int
;	O
buffer	*(char)
+=	O
i	int
;	O
}	O
}	O
