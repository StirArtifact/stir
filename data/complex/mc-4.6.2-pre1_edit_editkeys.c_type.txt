static	O
const	O
edit_key_map_type	struct(long,long)
cooledit_key_map	array(struct(long,long))
[	O
]	O
=	O
{	O
{	O
ALT	O
(	O
'b'	O
)	O
,	O
CK_Match_Bracket	int
}	O
,	O
{	O
ALT	O
(	O
'm'	O
)	O
,	O
CK_Mail	int
}	O
,	O
{	O
XCTRL	O
(	O
'f'	O
)	O
,	O
CK_Save_Block	int
}	O
,	O
{	O
XCTRL	O
(	O
'n'	O
)	O
,	O
CK_New	int
}	O
,	O
{	O
XCTRL	O
(	O
'p'	O
)	O
,	O
CK_Pipe_Block	O
(	O
1	int
)	O
}	O
,	O
{	O
XCTRL	O
(	O
'x'	O
)	O
,	O
CK_Word_Right	int
}	O
,	O
{	O
XCTRL	O
(	O
'y'	O
)	O
,	O
CK_Delete_Line	int
}	O
,	O
{	O
XCTRL	O
(	O
'z'	O
)	O
,	O
CK_Word_Left	int
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
edit_key_map_type	struct(long,long)
emacs_key_map	array(struct(long,long))
[	O
]	O
=	O
{	O
{	O
ALT	O
(	O
'$'	O
)	O
,	O
CK_Pipe_Block	O
(	O
1	int
)	O
}	O
,	O
{	O
ALT	O
(	O
'b'	O
)	O
,	O
CK_Word_Left	int
}	O
,	O
{	O
ALT	O
(	O
'f'	O
)	O
,	O
CK_Word_Right	int
}	O
,	O
{	O
ALT	O
(	O
'v'	O
)	O
,	O
CK_Page_Up	int
}	O
,	O
{	O
ALT	O
(	O
'w'	O
)	O
,	O
CK_XStore	int
}	O
,	O
{	O
XCTRL	O
(	O
'@'	O
)	O
,	O
CK_Mark	int
}	O
,	O
{	O
XCTRL	O
(	O
'a'	O
)	O
,	O
CK_Home	int
}	O
,	O
{	O
XCTRL	O
(	O
'b'	O
)	O
,	O
CK_Left	int
}	O
,	O
{	O
XCTRL	O
(	O
'e'	O
)	O
,	O
CK_End	int
}	O
,	O
{	O
XCTRL	O
(	O
'f'	O
)	O
,	O
CK_Right	int
}	O
,	O
{	O
XCTRL	O
(	O
'g'	O
)	O
,	O
CK_Ignore_Key	int
}	O
,	O
{	O
XCTRL	O
(	O
'n'	O
)	O
,	O
CK_Down	int
}	O
,	O
{	O
XCTRL	O
(	O
'p'	O
)	O
,	O
CK_Up	int
}	O
,	O
{	O
XCTRL	O
(	O
's'	O
)	O
,	O
CK_Find	int
}	O
,	O
{	O
XCTRL	O
(	O
'v'	O
)	O
,	O
CK_Page_Down	int
}	O
,	O
{	O
XCTRL	O
(	O
'w'	O
)	O
,	O
CK_XCut	int
}	O
,	O
{	O
XCTRL	O
(	O
'y'	O
)	O
,	O
CK_XPaste	int
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
edit_key_map_type	struct(long,long)
common_key_map	array(struct(long,long))
[	O
]	O
=	O
{	O
{	O
'\n'	O
,	O
CK_Enter	int
}	O
,	O
{	O
'\t'	O
,	O
CK_Tab	int
}	O
,	O
{	O
ESC_CHAR	char
,	O
CK_Exit	int
}	O
,	O
{	O
KEY_BACKSPACE	int
,	O
CK_BackSpace	int
}	O
,	O
{	O
KEY_DC	int
,	O
CK_Delete	int
}	O
,	O
{	O
KEY_DOWN	int
,	O
CK_Down	int
}	O
,	O
{	O
KEY_END	int
,	O
CK_End	int
}	O
,	O
{	O
KEY_HOME	int
,	O
CK_Home	int
}	O
,	O
{	O
KEY_IC	int
,	O
CK_Toggle_Insert	int
}	O
,	O
{	O
KEY_LEFT	int
,	O
CK_Left	int
}	O
,	O
{	O
KEY_NPAGE	int
,	O
CK_Page_Down	int
}	O
,	O
{	O
KEY_PPAGE	int
,	O
CK_Page_Up	int
}	O
,	O
{	O
KEY_RIGHT	int
,	O
CK_Right	int
}	O
,	O
{	O
KEY_UP	int
,	O
CK_Up	int
}	O
,	O
{	O
ALT	O
(	O
'\n'	O
)	O
,	O
CK_Return	int
}	O
,	O
{	O
ALT	O
(	O
'\t'	O
)	O
,	O
CK_Complete_Word	int
}	O
,	O
{	O
ALT	O
(	O
'l'	O
)	O
,	O
CK_Goto	int
}	O
,	O
{	O
ALT	O
(	O
'L'	O
)	O
,	O
CK_Goto	int
}	O
,	O
{	O
ALT	O
(	O
'p'	O
)	O
,	O
CK_Paragraph_Format	int
}	O
,	O
{	O
ALT	O
(	O
't'	O
)	O
,	O
CK_Sort	int
}	O
,	O
{	O
ALT	O
(	O
'u'	O
)	O
,	O
CK_ExtCmd	int
}	O
,	O
{	O
ALT	O
(	O
'<'	O
)	O
,	O
CK_Beginning_Of_Text	int
}	O
,	O
{	O
ALT	O
(	O
'>'	O
)	O
,	O
CK_End_Of_Text	int
}	O
,	O
{	O
ALT	O
(	O
KEY_BACKSPACE	int
)	O
,	O
CK_Delete_Word_Left	int
}	O
,	O
{	O
XCTRL	O
(	O
'k'	O
)	O
,	O
CK_Delete_To_Line_End	int
}	O
,	O
{	O
XCTRL	O
(	O
'l'	O
)	O
,	O
CK_Refresh	int
}	O
,	O
{	O
XCTRL	O
(	O
'o'	O
)	O
,	O
CK_Shell	int
}	O
,	O
{	O
XCTRL	O
(	O
's'	O
)	O
,	O
CK_Toggle_Syntax	int
}	O
,	O
{	O
XCTRL	O
(	O
'u'	O
)	O
,	O
CK_Undo	int
}	O
,	O
{	O
XCTRL	O
(	O
't'	O
)	O
,	O
CK_Select_Codepage	int
}	O
,	O
{	O
XCTRL	O
(	O
'q'	O
)	O
,	O
CK_Insert_Literal	int
}	O
,	O
{	O
XCTRL	O
(	O
'a'	O
)	O
,	O
CK_Execute_Macro	int
}	O
,	O
{	O
XCTRL	O
(	O
'r'	O
)	O
,	O
CK_Begin_End_Macro	int
}	O
,	O
{	O
KEY_F	O
(	O
1	int
)	O
,	O
CK_Help	int
}	O
,	O
{	O
KEY_F	O
(	O
2	int
)	O
,	O
CK_Save	int
}	O
,	O
{	O
KEY_F	O
(	O
3	int
)	O
,	O
CK_Mark	int
}	O
,	O
{	O
KEY_F	O
(	O
4	int
)	O
,	O
CK_Replace	int
}	O
,	O
{	O
KEY_F	O
(	O
5	int
)	O
,	O
CK_Copy	int
}	O
,	O
{	O
KEY_F	O
(	O
6	int
)	O
,	O
CK_Move	int
}	O
,	O
{	O
KEY_F	O
(	O
7	int
)	O
,	O
CK_Find	int
}	O
,	O
{	O
KEY_F	O
(	O
8	int
)	O
,	O
CK_Remove	int
}	O
,	O
{	O
KEY_F	O
(	O
10	int
)	O
,	O
CK_Exit	int
}	O
,	O
{	O
KEY_F	O
(	O
11	int
)	O
,	O
CK_User_Menu	int
}	O
,	O
{	O
KEY_F	O
(	O
12	int
)	O
,	O
CK_Save_As	int
}	O
,	O
{	O
KEY_F	O
(	O
13	int
)	O
,	O
CK_Column_Mark	int
}	O
,	O
{	O
KEY_F	O
(	O
14	int
)	O
,	O
CK_Replace_Again	int
}	O
,	O
{	O
KEY_F	O
(	O
15	int
)	O
,	O
CK_Insert_File	int
}	O
,	O
{	O
KEY_F	O
(	O
17	int
)	O
,	O
CK_Find_Again	int
}	O
,	O
{	O
KEY_F	O
(	O
19	int
)	O
,	O
CK_Pipe_Block	O
(	O
0	int
)	O
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_PPAGE	int
,	O
CK_Page_Up_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_NPAGE	int
,	O
CK_Page_Down_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_LEFT	int
,	O
CK_Left_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_RIGHT	int
,	O
CK_Right_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_UP	int
,	O
CK_Up_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DOWN	int
,	O
CK_Down_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_HOME	int
,	O
CK_Home_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_END	int
,	O
CK_End_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_IC	int
,	O
CK_XPaste	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DC	int
,	O
CK_XCut	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
'\n'	O
,	O
CK_Return	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
(	O
KEY_F	O
(	O
2	int
)	O
)	O
,	O
CK_Save_As	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
(	O
KEY_F	O
(	O
4	int
)	O
)	O
,	O
CK_Replace_Again	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
(	O
KEY_F	O
(	O
7	int
)	O
)	O
,	O
CK_Find_Again	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_BACKSPACE	int
,	O
CK_Undo	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_PPAGE	int
,	O
CK_Beginning_Of_Text	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_NPAGE	int
,	O
CK_End_Of_Text	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_HOME	int
,	O
CK_Beginning_Of_Text	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_END	int
,	O
CK_End_Of_Text	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
CK_Scroll_Up	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
CK_Scroll_Down	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
CK_Word_Left	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
CK_Word_Right	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_IC	int
,	O
CK_XStore	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DC	int
,	O
CK_Remove	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_PPAGE	int
,	O
CK_Beginning_Of_Text_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_NPAGE	int
,	O
CK_End_Of_Text_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
CK_Word_Left_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
CK_Word_Right_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
CK_Scroll_Up_Highlight	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
CK_Scroll_Down_Highlight	int
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
int	O
edit_translate_key	(*(struct),long,*(int),*(int))->(int)
(	O
WEdit	struct
*	O
edit	*(struct)
,	O
long	O
x_key	long
,	O
int	O
*	O
cmd	*(int)
,	O
int	O
*	O
ch	int
)	O
{	O
int	O
command	*(char)
=	O
CK_Insert_Char	O
;	O
int	O
char_for_insertion	int
=	O
-	O
1	int
;	O
int	O
i	array(int)
=	O
0	int
;	O
int	O
extmod	int
=	O
0	int
;	O
const	O
edit_key_map_type	struct(long,long)
*	O
key_map	*(struct(long,long))
=	O
NULL	O
;	O
switch	O
(	O
edit_key_emulation	int
)	O
{	O
case	O
EDIT_KEY_EMULATION_NORMAL	int
:	O
key_map	*(struct(long,long))
=	O
cooledit_key_map	array(struct(long,long))
;	O
break	O
;	O
case	O
EDIT_KEY_EMULATION_EMACS	int
:	O
key_map	*(struct(long,long))
=	O
emacs_key_map	array(struct(long,long))
;	O
if	O
(	O
x_key	long
==	O
XCTRL	O
(	O
'x'	O
)	O
)	O
{	O
int	O
ext_key	int
;	O
ext_key	int
=	O
edit_raw_key_query	(*(char),*(char),int)->(int)
(	O
" Ctrl-X "	*(char)
,	O
_	O
(	O
" Emacs key: "	*(char)
)	O
,	O
0	int
)	O
;	O
switch	O
(	O
ext_key	int
)	O
{	O
case	O
's'	O
:	O
command	*(char)
=	O
CK_Save	int
;	O
goto	O
fin	O
;	O
case	O
'x'	O
:	O
command	*(char)
=	O
CK_Exit	int
;	O
goto	O
fin	O
;	O
case	O
'k'	O
:	O
command	*(char)
=	O
CK_New	int
;	O
goto	O
fin	O
;	O
case	O
'e'	O
:	O
command	*(char)
=	O
CK_Macro	O
(	O
edit_raw_key_query	(*(char),*(char),int)->(int)
(	O
_	O
(	O
" Execute Macro "	*(char)
)	O
,	O
_	O
(	O
" Press macro hotkey: "	*(char)
)	O
,	O
1	int
)	O
)	O
;	O
if	O
(	O
command	*(char)
==	O
CK_Macro	O
(	O
0	int
)	O
)	O
command	*(char)
=	O
CK_Insert_Char	O
;	O
goto	O
fin	O
;	O
}	O
goto	O
fin	O
;	O
}	O
break	O
;	O
case	O
EDIT_KEY_EMULATION_USER	int
:	O
if	O
(	O
edit	*(struct)
->	O
user_map	*(struct(long,long))
!=	O
NULL	O
)	O
{	O
if	O
(	O
edit	*(struct)
->	O
extmod	int
&&	O
edit	*(struct)
->	O
ext_map	*(struct(long,long))
!=	O
NULL	O
)	O
{	O
key_map	*(struct(long,long))
=	O
edit	*(struct)
->	O
ext_map	*(struct(long,long))
;	O
extmod	int
=	O
1	int
;	O
}	O
else	O
{	O
key_map	*(struct(long,long))
=	O
edit	*(struct)
->	O
user_map	*(struct(long,long))
;	O
}	O
edit	*(struct)
->	O
extmod	int
=	O
0	int
;	O
}	O
else	O
{	O
key_map	*(struct(long,long))
=	O
edit	*(struct)
->	O
user_map	*(struct(long,long))
=	O
cooledit_key_map	array(struct(long,long))
;	O
}	O
break	O
;	O
}	O
assert	O
(	O
key_map	*(struct(long,long))
!=	O
NULL	O
)	O
;	O
if	O
(	O
x_key	long
<	O
256	int
&&	O
!	O
extmod	int
)	O
{	O
int	O
c	int
=	O
convert_from_input_c	O
(	O
x_key	long
)	O
;	O
if	O
(	O
is_printable	(int)->(int)
(	O
c	int
)	O
)	O
{	O
char_for_insertion	int
=	O
c	int
;	O
goto	O
fin	O
;	O
}	O
}	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
key_map	*(struct(long,long))
[	O
i	array(int)
]	O
.	O
key	*(void)
!=	O
0	int
&&	O
key_map	*(struct(long,long))
[	O
i	array(int)
]	O
.	O
key	*(void)
!=	O
x_key	long
;	O
i	array(int)
++	O
)	O
continue	O
;	O
if	O
(	O
key_map	*(struct(long,long))
[	O
i	array(int)
]	O
.	O
key	*(void)
!=	O
0	int
)	O
{	O
command	*(char)
=	O
key_map	*(struct(long,long))
[	O
i	array(int)
]	O
.	O
command	*(char)
;	O
goto	O
fin	O
;	O
}	O
key_map	*(struct(long,long))
=	O
common_key_map	array(struct(long,long))
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
key_map	*(struct(long,long))
[	O
i	array(int)
]	O
.	O
key	*(void)
!=	O
0	int
&&	O
key_map	*(struct(long,long))
[	O
i	array(int)
]	O
.	O
key	*(void)
!=	O
x_key	long
;	O
i	array(int)
++	O
)	O
continue	O
;	O
if	O
(	O
key_map	*(struct(long,long))
[	O
i	array(int)
]	O
.	O
key	*(void)
!=	O
0	int
)	O
{	O
command	*(char)
=	O
key_map	*(struct(long,long))
[	O
i	array(int)
]	O
.	O
command	*(char)
;	O
goto	O
fin	O
;	O
}	O
if	O
(	O
x_key	long
&	O
ALT	O
(	O
0	int
)	O
)	O
{	O
command	*(char)
=	O
CK_Macro	O
(	O
x_key	long
-	O
ALT	O
(	O
0	int
)	O
)	O
;	O
goto	O
fin	O
;	O
}	O
if	O
(	O
x_key	long
<	O
' '	O
)	O
{	O
command	*(char)
=	O
CK_Macro	O
(	O
x_key	long
)	O
;	O
goto	O
fin	O
;	O
}	O
fin	O
:	O
*	O
cmd	*(int)
=	O
command	*(char)
;	O
*	O
ch	int
=	O
char_for_insertion	int
;	O
if	O
(	O
command	*(char)
==	O
CK_Insert_Char	O
&&	O
char_for_insertion	int
==	O
-	O
1	int
)	O
{	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
