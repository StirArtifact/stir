static	O
inline	O
void	O
rusage_add	(*(struct),*(struct))->(void)
(	O
struct	O
rusage	O
*	O
acc	*(struct)
,	O
const	O
struct	O
rusage	O
*	O
b	*(struct)
)	O
{	O
timeradd	()->(int)
(	O
&	O
acc	*(struct)
->	O
ru_utime	O
,	O
&	O
b	*(struct)
->	O
ru_utime	O
,	O
&	O
acc	*(struct)
->	O
ru_utime	O
)	O
;	O
timeradd	()->(int)
(	O
&	O
acc	*(struct)
->	O
ru_stime	O
,	O
&	O
b	*(struct)
->	O
ru_stime	O
,	O
&	O
acc	*(struct)
->	O
ru_stime	O
)	O
;	O
acc	*(struct)
->	O
ru_maxrss	O
+=	O
b	*(struct)
->	O
ru_maxrss	O
;	O
acc	*(struct)
->	O
ru_ixrss	O
+=	O
b	*(struct)
->	O
ru_ixrss	O
;	O
acc	*(struct)
->	O
ru_idrss	O
+=	O
b	*(struct)
->	O
ru_idrss	O
;	O
acc	*(struct)
->	O
ru_isrss	O
+=	O
b	*(struct)
->	O
ru_isrss	O
;	O
acc	*(struct)
->	O
ru_minflt	O
+=	O
b	*(struct)
->	O
ru_minflt	O
;	O
acc	*(struct)
->	O
ru_majflt	O
+=	O
b	*(struct)
->	O
ru_majflt	O
;	O
acc	*(struct)
->	O
ru_nswap	O
+=	O
b	*(struct)
->	O
ru_nswap	O
;	O
acc	*(struct)
->	O
ru_inblock	O
+=	O
b	*(struct)
->	O
ru_inblock	O
;	O
acc	*(struct)
->	O
ru_oublock	O
+=	O
b	*(struct)
->	O
ru_oublock	O
;	O
acc	*(struct)
->	O
ru_msgsnd	O
+=	O
b	*(struct)
->	O
ru_msgsnd	O
;	O
acc	*(struct)
->	O
ru_msgrcv	O
+=	O
b	*(struct)
->	O
ru_msgrcv	O
;	O
acc	*(struct)
->	O
ru_nsignals	O
+=	O
b	*(struct)
->	O
ru_nsignals	O
;	O
acc	*(struct)
->	O
ru_nvcsw	O
+=	O
b	*(struct)
->	O
ru_nvcsw	O
;	O
acc	*(struct)
->	O
ru_nivcsw	O
+=	O
b	*(struct)
->	O
ru_nivcsw	O
;	O
}	O
void	O
sample_rusage	(*(struct))->(void)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
struct	O
task_basic_info	O
bi	struct
;	O
struct	O
task_events_info	O
ei	struct
;	O
struct	O
task_thread_times_info	O
tti	struct
;	O
mach_msg_type_number_t	O
count	O
;	O
error_t	O
err	O
;	O
count	O
=	O
TASK_BASIC_INFO_COUNT	O
;	O
err	O
=	O
task_info	()->(int)
(	O
p	*(struct)
->	O
p_task	O
,	O
TASK_BASIC_INFO	O
,	O
(	O
task_info_t	O
)	O
&	O
bi	struct
,	O
&	O
count	O
)	O
;	O
if	O
(	O
err	O
)	O
memset	O
(	O
&	O
bi	struct
,	O
0	int
,	O
sizeof	O
bi	struct
)	O
;	O
count	O
=	O
TASK_EVENTS_INFO_COUNT	O
;	O
err	O
=	O
task_info	()->(int)
(	O
p	*(struct)
->	O
p_task	O
,	O
TASK_EVENTS_INFO	O
,	O
(	O
task_info_t	O
)	O
&	O
ei	struct
,	O
&	O
count	O
)	O
;	O
if	O
(	O
err	O
)	O
memset	O
(	O
&	O
ei	struct
,	O
0	int
,	O
sizeof	O
ei	struct
)	O
;	O
count	O
=	O
TASK_THREAD_TIMES_INFO_COUNT	O
;	O
err	O
=	O
task_info	()->(int)
(	O
p	*(struct)
->	O
p_task	O
,	O
TASK_THREAD_TIMES_INFO	O
,	O
(	O
task_info_t	O
)	O
&	O
tti	struct
,	O
&	O
count	O
)	O
;	O
if	O
(	O
err	O
)	O
memset	O
(	O
&	O
tti	struct
,	O
0	int
,	O
sizeof	O
tti	struct
)	O
;	O
time_value_add	()->(int)
(	O
&	O
bi	struct
.	O
user_time	O
,	O
&	O
tti	struct
.	O
user_time	O
)	O
;	O
time_value_add	()->(int)
(	O
&	O
bi	struct
.	O
system_time	O
,	O
&	O
tti	struct
.	O
system_time	O
)	O
;	O
memset	O
(	O
&	O
p	*(struct)
->	O
p_rusage	O
,	O
0	int
,	O
sizeof	O
(	O
struct	O
rusage	O
)	O
)	O
;	O
p	*(struct)
->	O
p_rusage	O
.	O
ru_utime	O
.	O
tv_sec	long
=	O
bi	struct
.	O
user_time	O
.	O
seconds	O
;	O
p	*(struct)
->	O
p_rusage	O
.	O
ru_utime	O
.	O
tv_usec	long
=	O
bi	struct
.	O
user_time	O
.	O
microseconds	O
;	O
p	*(struct)
->	O
p_rusage	O
.	O
ru_stime	O
.	O
tv_sec	long
=	O
bi	struct
.	O
system_time	O
.	O
seconds	O
;	O
p	*(struct)
->	O
p_rusage	O
.	O
ru_stime	O
.	O
tv_usec	long
=	O
bi	struct
.	O
system_time	O
.	O
microseconds	O
;	O
p	*(struct)
->	O
p_rusage	O
.	O
ru_majflt	O
=	O
ei	struct
.	O
pageins	O
;	O
p	*(struct)
->	O
p_rusage	O
.	O
ru_minflt	O
=	O
ei	struct
.	O
faults	O
-	O
ei	struct
.	O
pageins	O
;	O
p	*(struct)
->	O
p_rusage	O
.	O
ru_msgsnd	O
=	O
ei	struct
.	O
messages_sent	O
;	O
p	*(struct)
->	O
p_rusage	O
.	O
ru_msgrcv	O
=	O
ei	struct
.	O
messages_received	O
;	O
}	O
static	O
inline	O
int	O
waiter_cares	(int,int,int,int)->(int)
(	O
pid_t	int
wait_pid	int
,	O
pid_t	int
mypgrp	int
,	O
pid_t	int
pid	int
,	O
pid_t	int
pgrp	int
)	O
{	O
return	O
(	O
wait_pid	int
==	O
pid	int
||	O
wait_pid	int
==	O
-	O
pgrp	int
||	O
wait_pid	int
==	O
WAIT_ANY	O
||	O
(	O
wait_pid	int
==	O
WAIT_MYPGRP	O
&&	O
pgrp	int
==	O
mypgrp	int
)	O
)	O
;	O
}	O
void	O
alert_parent	(*(struct))->(void)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
rusage_add	(*(struct),*(struct))->(void)
(	O
&	O
p	*(struct)
->	O
p_parent	O
->	O
p_child_rusage	O
,	O
&	O
p	*(struct)
->	O
p_rusage	O
)	O
;	O
send_signal	()->(int)
(	O
p	*(struct)
->	O
p_parent	O
->	O
p_msgport	O
,	O
SIGCHLD	O
,	O
p	*(struct)
->	O
p_parent	O
->	O
p_task	O
)	O
;	O
if	O
(	O
!	O
p	*(struct)
->	O
p_exiting	O
)	O
{	O
p	*(struct)
->	O
p_status	O
=	O
W_EXITCODE	()->(int)
(	O
0	int
,	O
SIGKILL	O
)	O
;	O
p	*(struct)
->	O
p_sigcode	O
=	O
-	O
1	int
;	O
}	O
if	O
(	O
p	*(struct)
->	O
p_parent	O
->	O
p_waiting	O
)	O
{	O
pthread_cond_broadcast	()->(int)
(	O
&	O
p	*(struct)
->	O
p_parent	O
->	O
p_wakeup	O
)	O
;	O
p	*(struct)
->	O
p_parent	O
->	O
p_waiting	O
=	O
0	int
;	O
}	O
}	O
kern_return_t	O
S_proc_wait	(*(struct),int,int,int,int,*(int),*(int),*(struct),*(int))->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
mach_port_t	O
reply_port	int
,	O
mach_msg_type_name_t	O
reply_port_type	int
,	O
pid_t	int
pid	int
,	O
int	O
options	int
,	O
int	O
*	O
status	*(int)
,	O
int	O
*	O
sigcode	*(int)
,	O
struct	O
rusage	O
*	O
ru	*(struct)
,	O
pid_t	int
*	O
pid_status	*(int)
)	O
{	O
int	O
cancel	int
;	O
int	O
reap	()->(int)
(	O
struct	O
proc	O
*	O
child	*(struct)
)	O
{	O
if	O
(	O
child	*(struct)
->	O
p_waited	O
||	O
(	O
!	O
child	*(struct)
->	O
p_dead	O
&&	O
(	O
!	O
child	*(struct)
->	O
p_stopped	O
||	O
!	O
(	O
child	*(struct)
->	O
p_traced	O
||	O
(	O
options	int
&	O
WUNTRACED	O
)	O
)	O
)	O
)	O
)	O
return	O
0	int
;	O
child	*(struct)
->	O
p_waited	O
=	O
1	int
;	O
*	O
status	*(int)
=	O
child	*(struct)
->	O
p_status	O
;	O
*	O
sigcode	*(int)
=	O
child	*(struct)
->	O
p_sigcode	O
;	O
*	O
ru	*(struct)
=	O
child	*(struct)
->	O
p_rusage	O
;	O
*	O
pid_status	*(int)
=	O
child	*(struct)
->	O
p_pid	O
;	O
if	O
(	O
child	*(struct)
->	O
p_dead	O
)	O
complete_exit	O
(	O
child	*(struct)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
start_over	O
:	O
if	O
(	O
!	O
p	*(struct)
->	O
p_ochild	O
)	O
return	O
ECHILD	O
;	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
struct	O
proc	O
*	O
child	*(struct)
=	O
pid_find_allow_zombie	()->(int)
(	O
pid	int
)	O
;	O
if	O
(	O
!	O
child	*(struct)
||	O
child	*(struct)
->	O
p_parent	O
!=	O
p	*(struct)
)	O
return	O
ECHILD	O
;	O
if	O
(	O
reap	()->(int)
(	O
child	*(struct)
)	O
)	O
return	O
0	int
;	O
}	O
else	O
{	O
struct	O
proc	O
*	O
child	*(struct)
;	O
int	O
had_a_match	int
=	O
pid	int
==	O
0	int
;	O
for	O
(	O
child	*(struct)
=	O
p	*(struct)
->	O
p_ochild	O
;	O
child	*(struct)
;	O
child	*(struct)
=	O
child	*(struct)
->	O
p_sib	O
)	O
if	O
(	O
waiter_cares	(int,int,int,int)->(int)
(	O
pid	int
,	O
p	*(struct)
->	O
p_pgrp	O
->	O
pg_pgid	O
,	O
child	*(struct)
->	O
p_pid	O
,	O
child	*(struct)
->	O
p_pgrp	O
->	O
pg_pgid	O
)	O
)	O
{	O
if	O
(	O
reap	()->(int)
(	O
child	*(struct)
)	O
)	O
return	O
0	int
;	O
had_a_match	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
had_a_match	int
)	O
return	O
ECHILD	O
;	O
}	O
if	O
(	O
options	int
&	O
WNOHANG	O
)	O
return	O
EWOULDBLOCK	O
;	O
p	*(struct)
->	O
p_waiting	O
=	O
1	int
;	O
cancel	int
=	O
pthread_hurd_cond_wait_np	()->(int)
(	O
&	O
p	*(struct)
->	O
p_wakeup	O
,	O
&	O
global_lock	O
)	O
;	O
if	O
(	O
p	*(struct)
->	O
p_dead	O
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
cancel	int
)	O
return	O
EINTR	O
;	O
goto	O
start_over	O
;	O
}	O
kern_return_t	O
S_proc_mark_stop	(*(struct),int,int)->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
int	O
signo	int
,	O
int	O
sigcode	*(int)
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
p	*(struct)
->	O
p_stopped	O
=	O
1	int
;	O
p	*(struct)
->	O
p_status	O
=	O
W_STOPCODE	()->(int)
(	O
signo	int
)	O
;	O
p	*(struct)
->	O
p_sigcode	O
=	O
sigcode	*(int)
;	O
p	*(struct)
->	O
p_waited	O
=	O
0	int
;	O
if	O
(	O
p	*(struct)
->	O
p_parent	O
->	O
p_waiting	O
)	O
{	O
pthread_cond_broadcast	()->(int)
(	O
&	O
p	*(struct)
->	O
p_parent	O
->	O
p_wakeup	O
)	O
;	O
p	*(struct)
->	O
p_parent	O
->	O
p_waiting	O
=	O
0	int
;	O
}	O
if	O
(	O
!	O
p	*(struct)
->	O
p_parent	O
->	O
p_nostopcld	O
)	O
send_signal	()->(int)
(	O
p	*(struct)
->	O
p_parent	O
->	O
p_msgport	O
,	O
SIGCHLD	O
,	O
p	*(struct)
->	O
p_parent	O
->	O
p_task	O
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_mark_exit	(*(struct),int,int)->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
int	O
status	*(int)
,	O
int	O
sigcode	*(int)
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
if	O
(	O
WIFSTOPPED	()->(int)
(	O
status	*(int)
)	O
)	O
return	O
EINVAL	O
;	O
sample_rusage	(*(struct))->(void)
(	O
p	*(struct)
)	O
;	O
if	O
(	O
p	*(struct)
->	O
p_exiting	O
)	O
return	O
EBUSY	O
;	O
p	*(struct)
->	O
p_exiting	O
=	O
1	int
;	O
p	*(struct)
->	O
p_status	O
=	O
status	*(int)
;	O
p	*(struct)
->	O
p_sigcode	O
=	O
sigcode	*(int)
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_mark_cont	(*(struct))->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
p	*(struct)
->	O
p_stopped	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_mark_traced	(*(struct))->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
p	*(struct)
->	O
p_traced	O
=	O
1	int
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
S_proc_mod_stopchild	(*(struct),int)->(int)
(	O
struct	O
proc	O
*	O
p	*(struct)
,	O
int	O
value	int
)	O
{	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
EOPNOTSUPP	O
;	O
p	*(struct)
->	O
p_nostopcld	O
=	O
!	O
value	int
;	O
return	O
0	int
;	O
}	O
