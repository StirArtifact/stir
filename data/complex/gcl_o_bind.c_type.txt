static	O
void	O
illegal_lambda	()->(void)
(	O
void	O
)	O
;	O
struct	O
nil3	struct(array(int))
{	O
object	O
nil3_self	array(int)
[	O
3	int
]	O
;	O
}	O
three_nils	struct(array(int))
;	O
struct	O
nil6	struct(array(int))
{	O
object	O
nil6_self	array(int)
[	O
6	int
]	O
;	O
}	O
six_nils	struct(array(int))
;	O
struct	O
required	struct(int,int)
{	O
object	O
req_var	int
;	O
object	O
req_spp	int
;	O
}	O
;	O
struct	O
optional	struct(int,int,int,int,int)
{	O
object	O
opt_var	int
;	O
object	O
opt_spp	int
;	O
object	O
opt_init	int
;	O
object	O
opt_svar	int
;	O
object	O
opt_svar_spp	int
;	O
}	O
;	O
struct	O
rest	struct(int,int)
{	O
object	O
rest_var	int
;	O
object	O
rest_spp	int
;	O
}	O
;	O
struct	O
keyword	struct(int,int,int,int,int,int,int,int)
{	O
object	O
key_word	int
;	O
object	O
key_var	int
;	O
object	O
key_spp	int
;	O
object	O
key_init	int
;	O
object	O
key_svar	int
;	O
object	O
key_svar_spp	int
;	O
object	O
key_val	int
;	O
object	O
key_svar_val	int
;	O
}	O
;	O
struct	O
aux	struct(int,int,int)
{	O
object	O
aux_var	int
;	O
object	O
aux_spp	int
;	O
object	O
aux_init	int
;	O
}	O
;	O
void	O
lambda_bind	(*(int))->(void)
(	O
object	O
*	O
arg_top	*(int)
)	O
{	O
object	O
temporary	O
;	O
object	O
lambda	O
,	O
lambda_list	O
,	O
body	int
,	O
form	O
=	O
Cnil	O
,	O
x	O
,	O
ds	O
,	O
vs	O
,	O
v	O
;	O
int	O
narg	int
,	O
i	int
,	O
j	int
;	O
object	O
*	O
base	*(int)
=	O
vs_base	O
;	O
struct	O
required	struct(int,int)
*	O
required	struct(int,int)
;	O
int	O
nreq	int
;	O
struct	O
optional	struct(int,int,int,int,int)
*	O
optional	struct(int,int,int,int,int)
=	O
NULL	O
;	O
int	O
nopt	int
;	O
struct	O
rest	struct(int,int)
*	O
rest	struct(int,int)
=	O
NULL	O
;	O
bool	O
rest_flag	O
;	O
struct	O
keyword	struct(int,int,int,int,int,int,int,int)
*	O
keyword	struct(int,int,int,int,int,int,int,int)
=	O
NULL	O
;	O
bool	O
key_flag	O
;	O
bool	O
allow_other_keys_flag	O
,	O
other_keys_appeared	O
;	O
int	O
nkey	int
;	O
struct	O
aux	struct(int,int,int)
*	O
aux	struct(int,int,int)
=	O
NULL	O
;	O
int	O
naux	int
;	O
bool	O
special_processed	O
;	O
vs_mark	O
;	O
bds_check	O
;	O
lambda	O
=	O
vs_head	O
;	O
if	O
(	O
type_of	()->(int)
(	O
lambda	O
)	O
!=	O
t_cons	O
)	O
FEerror	()->(int)
(	O
"No lambda list."	*(char)
,	O
0	int
)	O
;	O
lambda_list	O
=	O
lambda	O
->	O
c	O
.	O
c_car	O
;	O
body	int
=	O
lambda	O
->	O
c	O
.	O
c_cdr	O
;	O
required	struct(int,int)
=	O
(	O
struct	O
required	struct(int,int)
*	O
)	O
vs_top	O
;	O
nreq	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
lambda_list	O
)	O
)	O
goto	O
REQUIRED_ONLY	O
;	O
x	O
=	O
lambda_list	O
->	O
c	O
.	O
c_car	O
;	O
lambda_list	O
=	O
lambda_list	O
->	O
c	O
.	O
c_cdr	O
;	O
check_symbol	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
x	O
==	O
ANDallow_other_keys	O
)	O
illegal_lambda	()->(void)
(	O
)	O
;	O
if	O
(	O
x	O
==	O
ANDoptional	O
)	O
{	O
nopt	int
=	O
nkey	int
=	O
naux	int
=	O
0	int
;	O
rest_flag	O
=	O
key_flag	O
=	O
allow_other_keys_flag	O
=	O
FALSE	O
;	O
goto	O
OPTIONAL	O
;	O
}	O
if	O
(	O
x	O
==	O
ANDrest	O
)	O
{	O
nopt	int
=	O
nkey	int
=	O
naux	int
=	O
0	int
;	O
key_flag	O
=	O
allow_other_keys_flag	O
=	O
FALSE	O
;	O
goto	O
REST	O
;	O
}	O
if	O
(	O
x	O
==	O
ANDkey	O
)	O
{	O
nopt	int
=	O
nkey	int
=	O
naux	int
=	O
0	int
;	O
rest_flag	O
=	O
allow_other_keys_flag	O
=	O
FALSE	O
;	O
goto	O
KEYWORD	O
;	O
}	O
if	O
(	O
x	O
==	O
ANDaux	O
)	O
{	O
nopt	int
=	O
nkey	int
=	O
naux	int
=	O
0	int
;	O
rest_flag	O
=	O
key_flag	O
=	O
allow_other_keys_flag	O
=	O
FALSE	O
;	O
goto	O
AUX_L	O
;	O
}	O
if	O
(	O
(	O
enum	O
stype	O
)	O
x	O
->	O
s	O
.	O
s_stype	O
==	O
stp_constant	O
)	O
FEerror	()->(int)
(	O
"~S is not a variable."	*(char)
,	O
1	int
,	O
x	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
nreq	int
++	O
;	O
}	O
OPTIONAL	O
:	O
optional	struct(int,int,int,int,int)
=	O
(	O
struct	O
optional	struct(int,int,int,int,int)
*	O
)	O
vs_top	O
;	O
for	O
(	O
;	O
;	O
nopt	int
++	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
lambda_list	O
)	O
)	O
goto	O
SEARCH_DECLARE	O
;	O
x	O
=	O
lambda_list	O
->	O
c	O
.	O
c_car	O
;	O
lambda_list	O
=	O
lambda_list	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	O
)	O
==	O
t_cons	O
)	O
{	O
check_symbol	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
check_var	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
x	O
=	O
x	O
->	O
c	O
.	O
c_cdr	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
)	O
)	O
{	O
*	O
(	O
struct	O
nil3	struct(array(int))
*	O
)	O
vs_top	O
=	O
three_nils	struct(array(int))
;	O
vs_top	O
+=	O
3	int
;	O
continue	O
;	O
}	O
vs_push	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
x	O
=	O
x	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
)	O
)	O
{	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
continue	O
;	O
}	O
check_symbol	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
check_var	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
x	O
->	O
c	O
.	O
c_cdr	O
)	O
)	O
illegal_lambda	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
check_symbol	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
x	O
==	O
ANDoptional	O
||	O
x	O
==	O
ANDallow_other_keys	O
)	O
illegal_lambda	()->(void)
(	O
)	O
;	O
if	O
(	O
x	O
==	O
ANDrest	O
)	O
goto	O
REST	O
;	O
if	O
(	O
x	O
==	O
ANDkey	O
)	O
goto	O
KEYWORD	O
;	O
if	O
(	O
x	O
==	O
ANDaux	O
)	O
goto	O
AUX_L	O
;	O
check_var	()->(int)
(	O
x	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
)	O
;	O
*	O
(	O
struct	O
nil6	struct(array(int))
*	O
)	O
vs_top	O
=	O
six_nils	struct(array(int))
;	O
vs_top	O
+=	O
4	int
;	O
}	O
}	O
REST	O
:	O
rest	struct(int,int)
=	O
(	O
struct	O
rest	struct(int,int)
*	O
)	O
vs_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
lambda_list	O
)	O
)	O
illegal_lambda	()->(void)
(	O
)	O
;	O
check_symbol	()->(int)
(	O
lambda_list	O
->	O
c	O
.	O
c_car	O
)	O
;	O
check_var	()->(int)
(	O
lambda_list	O
->	O
c	O
.	O
c_car	O
)	O
;	O
rest_flag	O
=	O
TRUE	O
;	O
vs_push	()->(int)
(	O
lambda_list	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
lambda_list	O
=	O
lambda_list	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
endp	()->(int)
(	O
lambda_list	O
)	O
)	O
goto	O
SEARCH_DECLARE	O
;	O
x	O
=	O
lambda_list	O
->	O
c	O
.	O
c_car	O
;	O
lambda_list	O
=	O
lambda_list	O
->	O
c	O
.	O
c_cdr	O
;	O
check_symbol	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
x	O
==	O
ANDoptional	O
||	O
x	O
==	O
ANDrest	O
||	O
x	O
==	O
ANDallow_other_keys	O
)	O
illegal_lambda	()->(void)
(	O
)	O
;	O
if	O
(	O
x	O
==	O
ANDkey	O
)	O
goto	O
KEYWORD	O
;	O
if	O
(	O
x	O
==	O
ANDaux	O
)	O
goto	O
AUX_L	O
;	O
illegal_lambda	()->(void)
(	O
)	O
;	O
KEYWORD	O
:	O
keyword	struct(int,int,int,int,int,int,int,int)
=	O
(	O
struct	O
keyword	struct(int,int,int,int,int,int,int,int)
*	O
)	O
vs_top	O
;	O
key_flag	O
=	O
TRUE	O
;	O
for	O
(	O
;	O
;	O
nkey	int
++	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
lambda_list	O
)	O
)	O
goto	O
SEARCH_DECLARE	O
;	O
x	O
=	O
lambda_list	O
->	O
c	O
.	O
c_car	O
;	O
lambda_list	O
=	O
lambda_list	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	O
)	O
==	O
t_cons	O
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
==	O
t_cons	O
)	O
{	O
if	O
(	O
!	O
keywordp	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_car	O
)	O
)	O
FEunexpected_keyword	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_car	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_cdr	O
)	O
)	O
illegal_lambda	()->(void)
(	O
)	O
;	O
check_symbol	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_cdr	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_cdr	O
->	O
c	O
.	O
c_car	O
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_cdr	O
->	O
c	O
.	O
c_cdr	O
)	O
)	O
illegal_lambda	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
check_symbol	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
check_var	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
intern	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
,	O
keyword_package	O
)	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
}	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
x	O
=	O
x	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
)	O
)	O
{	O
*	O
(	O
struct	O
nil6	struct(array(int))
*	O
)	O
vs_top	O
=	O
six_nils	struct(array(int))
;	O
vs_top	O
+=	O
5	int
;	O
continue	O
;	O
}	O
vs_push	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
x	O
=	O
x	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
)	O
)	O
{	O
*	O
(	O
struct	O
nil6	struct(array(int))
*	O
)	O
vs_top	O
=	O
six_nils	struct(array(int))
;	O
vs_top	O
+=	O
4	int
;	O
continue	O
;	O
}	O
check_symbol	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
check_var	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
x	O
->	O
c	O
.	O
c_cdr	O
)	O
)	O
illegal_lambda	()->(void)
(	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
check_symbol	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
x	O
==	O
ANDallow_other_keys	O
)	O
{	O
allow_other_keys_flag	O
=	O
TRUE	O
;	O
if	O
(	O
endp	()->(int)
(	O
lambda_list	O
)	O
)	O
goto	O
SEARCH_DECLARE	O
;	O
x	O
=	O
lambda_list	O
->	O
c	O
.	O
c_car	O
;	O
lambda_list	O
=	O
lambda_list	O
->	O
c	O
.	O
c_cdr	O
;	O
}	O
if	O
(	O
x	O
==	O
ANDoptional	O
||	O
x	O
==	O
ANDrest	O
||	O
x	O
==	O
ANDkey	O
||	O
x	O
==	O
ANDallow_other_keys	O
)	O
illegal_lambda	()->(void)
(	O
)	O
;	O
if	O
(	O
x	O
==	O
ANDaux	O
)	O
goto	O
AUX_L	O
;	O
check_var	()->(int)
(	O
x	O
)	O
;	O
vs_push	()->(int)
(	O
intern	()->(int)
(	O
x	O
,	O
keyword_package	O
)	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
)	O
;	O
*	O
(	O
struct	O
nil6	struct(array(int))
*	O
)	O
vs_top	O
=	O
six_nils	struct(array(int))
;	O
vs_top	O
+=	O
6	int
;	O
}	O
}	O
AUX_L	O
:	O
aux	struct(int,int,int)
=	O
(	O
struct	O
aux	struct(int,int,int)
*	O
)	O
vs_top	O
;	O
for	O
(	O
;	O
;	O
naux	int
++	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
lambda_list	O
)	O
)	O
goto	O
SEARCH_DECLARE	O
;	O
x	O
=	O
lambda_list	O
->	O
c	O
.	O
c_car	O
;	O
lambda_list	O
=	O
lambda_list	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	O
)	O
==	O
t_cons	O
)	O
{	O
check_symbol	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
check_var	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
x	O
=	O
x	O
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
endp	()->(int)
(	O
x	O
)	O
)	O
{	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
continue	O
;	O
}	O
vs_push	()->(int)
(	O
x	O
->	O
c	O
.	O
c_car	O
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
x	O
->	O
c	O
.	O
c_cdr	O
)	O
)	O
illegal_lambda	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
check_symbol	()->(int)
(	O
x	O
)	O
;	O
if	O
(	O
x	O
==	O
ANDoptional	O
||	O
x	O
==	O
ANDrest	O
||	O
x	O
==	O
ANDkey	O
||	O
x	O
==	O
ANDallow_other_keys	O
||	O
x	O
==	O
ANDaux	O
)	O
illegal_lambda	()->(void)
(	O
)	O
;	O
check_var	()->(int)
(	O
x	O
)	O
;	O
vs_push	()->(int)
(	O
x	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
}	O
SEARCH_DECLARE	O
:	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
for	O
(	O
;	O
!	O
endp	()->(int)
(	O
body	int
)	O
;	O
body	int
=	O
body	int
->	O
c	O
.	O
c_cdr	O
)	O
{	O
form	O
=	O
body	int
->	O
c	O
.	O
c_car	O
;	O
form	O
=	O
macro_expand	()->(int)
(	O
form	O
)	O
;	O
vs_head	O
=	O
form	O
;	O
if	O
(	O
type_of	()->(int)
(	O
form	O
)	O
==	O
t_string	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
body	int
->	O
c	O
.	O
c_cdr	O
)	O
)	O
break	O
;	O
continue	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
form	O
)	O
!=	O
t_cons	O
||	O
!	O
isdeclare	O
(	O
form	O
->	O
c	O
.	O
c_car	O
)	O
)	O
break	O
;	O
for	O
(	O
ds	O
=	O
form	O
->	O
c	O
.	O
c_cdr	O
;	O
!	O
endp	()->(int)
(	O
ds	O
)	O
;	O
ds	O
=	O
ds	O
->	O
c	O
.	O
c_cdr	O
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
ds	O
->	O
c	O
.	O
c_car	O
)	O
!=	O
t_cons	O
)	O
illegal_declare	()->(int)
(	O
form	O
)	O
;	O
if	O
(	O
ds	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_car	O
==	O
sLspecial	O
)	O
{	O
vs	O
=	O
ds	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_cdr	O
;	O
for	O
(	O
;	O
!	O
endp	()->(int)
(	O
vs	O
)	O
;	O
vs	O
=	O
vs	O
->	O
c	O
.	O
c_cdr	O
)	O
{	O
v	O
=	O
vs	O
->	O
c	O
.	O
c_car	O
;	O
check_symbol	()->(int)
(	O
v	O
)	O
;	O
special_processed	O
=	O
FALSE	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nreq	int
;	O
i	int
++	O
)	O
if	O
(	O
required	struct(int,int)
[	O
i	int
]	O
.	O
req_var	int
==	O
v	O
)	O
{	O
required	struct(int,int)
[	O
i	int
]	O
.	O
req_spp	int
=	O
Ct	O
;	O
special_processed	O
=	O
TRUE	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nopt	int
;	O
i	int
++	O
)	O
if	O
(	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_var	int
==	O
v	O
)	O
{	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_spp	int
=	O
Ct	O
;	O
special_processed	O
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_svar	int
==	O
v	O
)	O
{	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_svar_spp	int
=	O
Ct	O
;	O
special_processed	O
=	O
TRUE	O
;	O
}	O
if	O
(	O
rest_flag	O
&&	O
rest	struct(int,int)
->	O
rest_var	int
==	O
v	O
)	O
{	O
rest	struct(int,int)
->	O
rest_spp	int
=	O
Ct	O
;	O
special_processed	O
=	O
TRUE	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nkey	int
;	O
i	int
++	O
)	O
if	O
(	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_var	int
==	O
v	O
)	O
{	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_spp	int
=	O
Ct	O
;	O
special_processed	O
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_svar	int
==	O
v	O
)	O
{	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_svar_spp	int
=	O
Ct	O
;	O
special_processed	O
=	O
TRUE	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
naux	int
;	O
i	int
++	O
)	O
if	O
(	O
aux	struct(int,int,int)
[	O
i	int
]	O
.	O
aux_var	int
==	O
v	O
)	O
{	O
aux	struct(int,int,int)
[	O
i	int
]	O
.	O
aux_spp	int
=	O
Ct	O
;	O
special_processed	O
=	O
TRUE	O
;	O
}	O
if	O
(	O
special_processed	O
)	O
continue	O
;	O
lex_env	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
MMcons	()->(int)
(	O
v	O
,	O
Cnil	O
)	O
,	O
lex_env	O
[	O
0	int
]	O
)	O
;	O
}	O
}	O
}	O
}	O
narg	int
=	O
arg_top	*(int)
-	O
base	*(int)
;	O
if	O
(	O
narg	int
<	O
nreq	int
)	O
{	O
if	O
(	O
nopt	int
==	O
0	int
&&	O
!	O
rest_flag	O
&&	O
!	O
key_flag	O
)	O
{	O
vs_base	O
=	O
base	*(int)
;	O
vs_top	O
=	O
arg_top	*(int)
;	O
check_arg_failed	()->(int)
(	O
nreq	int
)	O
;	O
}	O
FEtoo_few_arguments	()->(int)
(	O
base	*(int)
,	O
arg_top	*(int)
)	O
;	O
}	O
if	O
(	O
!	O
rest_flag	O
&&	O
!	O
key_flag	O
&&	O
narg	int
>	O
nreq	int
+	O
nopt	int
)	O
{	O
if	O
(	O
nopt	int
==	O
0	int
)	O
{	O
vs_base	O
=	O
base	*(int)
;	O
vs_top	O
=	O
arg_top	*(int)
;	O
check_arg_failed	()->(int)
(	O
nreq	int
)	O
;	O
}	O
FEtoo_many_arguments	()->(int)
(	O
base	*(int)
,	O
arg_top	*(int)
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nreq	int
;	O
i	int
++	O
)	O
bind_var	()->(int)
(	O
required	struct(int,int)
[	O
i	int
]	O
.	O
req_var	int
,	O
base	*(int)
[	O
i	int
]	O
,	O
required	struct(int,int)
[	O
i	int
]	O
.	O
req_spp	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nopt	int
;	O
i	int
++	O
)	O
if	O
(	O
nreq	int
+	O
i	int
<	O
narg	int
)	O
{	O
bind_var	()->(int)
(	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_var	int
,	O
base	*(int)
[	O
nreq	int
+	O
i	int
]	O
,	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_spp	int
)	O
;	O
if	O
(	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_svar	int
!=	O
Cnil	O
)	O
bind_var	()->(int)
(	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_svar	int
,	O
Ct	O
,	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_svar_spp	int
)	O
;	O
}	O
else	O
{	O
eval_assign	()->(int)
(	O
temporary	O
,	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_init	int
)	O
;	O
bind_var	()->(int)
(	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_var	int
,	O
temporary	O
,	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_spp	int
)	O
;	O
if	O
(	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_svar	int
!=	O
Cnil	O
)	O
bind_var	()->(int)
(	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_svar	int
,	O
Cnil	O
,	O
optional	struct(int,int,int,int,int)
[	O
i	int
]	O
.	O
opt_svar_spp	int
)	O
;	O
}	O
if	O
(	O
rest_flag	O
)	O
{	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
for	O
(	O
i	int
=	O
narg	int
,	O
j	int
=	O
nreq	int
+	O
nopt	int
;	O
--	O
i	int
>=	O
j	int
;	O
)	O
vs_head	O
=	O
make_cons	()->(int)
(	O
base	*(int)
[	O
i	int
]	O
,	O
vs_head	O
)	O
;	O
bind_var	()->(int)
(	O
rest	struct(int,int)
->	O
rest_var	int
,	O
vs_head	O
,	O
rest	struct(int,int)
->	O
rest_spp	int
)	O
;	O
}	O
if	O
(	O
key_flag	O
)	O
{	O
i	int
=	O
narg	int
-	O
nreq	int
-	O
nopt	int
;	O
if	O
(	O
i	int
>=	O
0	int
&&	O
i	int
%	O
2	int
!=	O
0	int
)	O
FEunexpected_keyword	()->(int)
(	O
Cnil	O
)	O
;	O
other_keys_appeared	O
=	O
FALSE	O
;	O
for	O
(	O
i	int
=	O
nreq	int
+	O
nopt	int
;	O
i	int
<	O
narg	int
;	O
i	int
+=	O
2	int
)	O
{	O
if	O
(	O
!	O
keywordp	()->(int)
(	O
base	*(int)
[	O
i	int
]	O
)	O
)	O
FEunexpected_keyword	()->(int)
(	O
base	*(int)
[	O
i	int
]	O
)	O
;	O
if	O
(	O
base	*(int)
[	O
i	int
]	O
==	O
sKallow_other_keys	O
&&	O
base	*(int)
[	O
i	int
+	O
1	int
]	O
!=	O
Cnil	O
)	O
allow_other_keys_flag	O
=	O
TRUE	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nkey	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
j	int
]	O
.	O
key_word	int
==	O
base	*(int)
[	O
i	int
]	O
)	O
{	O
if	O
(	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
j	int
]	O
.	O
key_svar_val	int
!=	O
Cnil	O
)	O
goto	O
NEXT_ARG	O
;	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
j	int
]	O
.	O
key_val	int
=	O
base	*(int)
[	O
i	int
+	O
1	int
]	O
;	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
j	int
]	O
.	O
key_svar_val	int
=	O
Ct	O
;	O
goto	O
NEXT_ARG	O
;	O
}	O
}	O
other_keys_appeared	O
=	O
TRUE	O
;	O
NEXT_ARG	O
:	O
continue	O
;	O
}	O
if	O
(	O
other_keys_appeared	O
&&	O
!	O
allow_other_keys_flag	O
)	O
FEunexpected_keyword	()->(int)
(	O
Ct	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nkey	int
;	O
i	int
++	O
)	O
if	O
(	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_svar_val	int
!=	O
Cnil	O
)	O
{	O
bind_var	()->(int)
(	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_var	int
,	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_val	int
,	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_spp	int
)	O
;	O
if	O
(	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_svar	int
!=	O
Cnil	O
)	O
bind_var	()->(int)
(	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_svar	int
,	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_svar_val	int
,	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_svar_spp	int
)	O
;	O
}	O
else	O
{	O
eval_assign	()->(int)
(	O
temporary	O
,	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_init	int
)	O
;	O
bind_var	()->(int)
(	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_var	int
,	O
temporary	O
,	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_spp	int
)	O
;	O
if	O
(	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_svar	int
!=	O
Cnil	O
)	O
bind_var	()->(int)
(	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_svar	int
,	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_svar_val	int
,	O
keyword	struct(int,int,int,int,int,int,int,int)
[	O
i	int
]	O
.	O
key_svar_spp	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
naux	int
;	O
i	int
++	O
)	O
{	O
eval_assign	()->(int)
(	O
temporary	O
,	O
aux	struct(int,int,int)
[	O
i	int
]	O
.	O
aux_init	int
)	O
;	O
bind_var	()->(int)
(	O
aux	struct(int,int,int)
[	O
i	int
]	O
.	O
aux_var	int
,	O
temporary	O
,	O
aux	struct(int,int,int)
[	O
i	int
]	O
.	O
aux_spp	int
)	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
body	int
)	O
!=	O
t_cons	O
||	O
body	int
->	O
c	O
.	O
c_car	O
==	O
form	O
)	O
{	O
vs_reset	O
;	O
vs_head	O
=	O
body	int
;	O
}	O
else	O
{	O
body	int
=	O
make_cons	()->(int)
(	O
form	O
,	O
body	int
->	O
c	O
.	O
c_cdr	O
)	O
;	O
vs_reset	O
;	O
vs_head	O
=	O
body	int
;	O
}	O
return	O
;	O
REQUIRED_ONLY	O
:	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
for	O
(	O
;	O
!	O
endp	()->(int)
(	O
body	int
)	O
;	O
body	int
=	O
body	int
->	O
c	O
.	O
c_cdr	O
)	O
{	O
form	O
=	O
body	int
->	O
c	O
.	O
c_car	O
;	O
vs_head	O
=	O
form	O
=	O
macro_expand	()->(int)
(	O
form	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
form	O
)	O
==	O
t_string	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
body	int
->	O
c	O
.	O
c_cdr	O
)	O
)	O
break	O
;	O
continue	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
form	O
)	O
!=	O
t_cons	O
||	O
!	O
isdeclare	O
(	O
form	O
->	O
c	O
.	O
c_car	O
)	O
)	O
break	O
;	O
for	O
(	O
ds	O
=	O
form	O
->	O
c	O
.	O
c_cdr	O
;	O
!	O
endp	()->(int)
(	O
ds	O
)	O
;	O
ds	O
=	O
ds	O
->	O
c	O
.	O
c_cdr	O
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
ds	O
->	O
c	O
.	O
c_car	O
)	O
!=	O
t_cons	O
)	O
illegal_declare	()->(int)
(	O
form	O
)	O
;	O
if	O
(	O
ds	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_car	O
==	O
sLspecial	O
)	O
{	O
vs	O
=	O
ds	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_cdr	O
;	O
for	O
(	O
;	O
!	O
endp	()->(int)
(	O
vs	O
)	O
;	O
vs	O
=	O
vs	O
->	O
c	O
.	O
c_cdr	O
)	O
{	O
v	O
=	O
vs	O
->	O
c	O
.	O
c_car	O
;	O
check_symbol	()->(int)
(	O
v	O
)	O
;	O
special_processed	O
=	O
FALSE	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nreq	int
;	O
i	int
++	O
)	O
if	O
(	O
required	struct(int,int)
[	O
i	int
]	O
.	O
req_var	int
==	O
v	O
)	O
{	O
required	struct(int,int)
[	O
i	int
]	O
.	O
req_spp	int
=	O
Ct	O
;	O
special_processed	O
=	O
TRUE	O
;	O
}	O
if	O
(	O
special_processed	O
)	O
continue	O
;	O
temporary	O
=	O
MMcons	()->(int)
(	O
v	O
,	O
Cnil	O
)	O
;	O
lex_env	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
temporary	O
,	O
lex_env	O
[	O
0	int
]	O
)	O
;	O
}	O
}	O
}	O
}	O
narg	int
=	O
arg_top	*(int)
-	O
base	*(int)
;	O
if	O
(	O
narg	int
!=	O
nreq	int
)	O
{	O
vs_base	O
=	O
base	*(int)
;	O
vs_top	O
=	O
arg_top	*(int)
;	O
check_arg_failed	()->(int)
(	O
nreq	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nreq	int
;	O
i	int
++	O
)	O
bind_var	()->(int)
(	O
required	struct(int,int)
[	O
i	int
]	O
.	O
req_var	int
,	O
base	*(int)
[	O
i	int
]	O
,	O
required	struct(int,int)
[	O
i	int
]	O
.	O
req_spp	int
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
body	int
)	O
!=	O
t_cons	O
||	O
body	int
->	O
c	O
.	O
c_car	O
==	O
form	O
)	O
{	O
vs_reset	O
;	O
vs_head	O
=	O
body	int
;	O
}	O
else	O
{	O
body	int
=	O
make_cons	()->(int)
(	O
form	O
,	O
body	int
->	O
c	O
.	O
c_cdr	O
)	O
;	O
vs_reset	O
;	O
vs_head	O
=	O
body	int
;	O
}	O
}	O
void	O
bind_var	()->(int)
(	O
object	O
var	int
,	O
object	O
val	int
,	O
object	O
spp	int
)	O
{	O
object	O
temporary	O
;	O
vs_mark	O
;	O
switch	O
(	O
var	int
->	O
s	O
.	O
s_stype	O
)	O
{	O
case	O
stp_constant	O
:	O
FEerror	()->(int)
(	O
"Cannot bind the constant ~S."	*(char)
,	O
1	int
,	O
var	int
)	O
;	O
case	O
stp_special	O
:	O
bds_bind	()->(int)
(	O
var	int
,	O
val	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
spp	int
!=	O
Cnil	O
)	O
{	O
temporary	O
=	O
MMcons	()->(int)
(	O
var	int
,	O
Cnil	O
)	O
;	O
lex_env	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
temporary	O
,	O
lex_env	O
[	O
0	int
]	O
)	O
;	O
bds_bind	()->(int)
(	O
var	int
,	O
val	int
)	O
;	O
}	O
else	O
{	O
temporary	O
=	O
MMcons	()->(int)
(	O
val	int
,	O
Cnil	O
)	O
;	O
temporary	O
=	O
MMcons	()->(int)
(	O
var	int
,	O
temporary	O
)	O
;	O
lex_env	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
temporary	O
,	O
lex_env	O
[	O
0	int
]	O
)	O
;	O
}	O
break	O
;	O
}	O
vs_reset	O
;	O
}	O
static	O
void	O
illegal_lambda	()->(void)
(	O
void	O
)	O
{	O
FEerror	()->(int)
(	O
"Illegal lambda expression."	*(char)
,	O
0	int
)	O
;	O
}	O
object	O
find_special	(int,*(struct),*(struct))->(int)
(	O
object	O
body	int
,	O
struct	O
bind_temp	O
*	O
start	*(struct)
,	O
struct	O
bind_temp	O
*	O
end	*(struct)
)	O
{	O
object	O
temporary	O
;	O
object	O
form	O
=	O
Cnil	O
;	O
object	O
ds	O
,	O
vs	O
,	O
v	O
;	O
struct	O
bind_temp	O
*	O
bt	*(struct)
;	O
bool	O
special_processed	O
;	O
vs_mark	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
for	O
(	O
;	O
!	O
endp	()->(int)
(	O
body	int
)	O
;	O
body	int
=	O
body	int
->	O
c	O
.	O
c_cdr	O
)	O
{	O
form	O
=	O
body	int
->	O
c	O
.	O
c_car	O
;	O
form	O
=	O
macro_expand	()->(int)
(	O
form	O
)	O
;	O
vs_head	O
=	O
form	O
;	O
if	O
(	O
type_of	()->(int)
(	O
form	O
)	O
==	O
t_string	O
)	O
{	O
if	O
(	O
endp	()->(int)
(	O
body	int
->	O
c	O
.	O
c_cdr	O
)	O
)	O
break	O
;	O
continue	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
form	O
)	O
!=	O
t_cons	O
||	O
!	O
isdeclare	O
(	O
form	O
->	O
c	O
.	O
c_car	O
)	O
)	O
break	O
;	O
for	O
(	O
ds	O
=	O
form	O
->	O
c	O
.	O
c_cdr	O
;	O
!	O
endp	()->(int)
(	O
ds	O
)	O
;	O
ds	O
=	O
ds	O
->	O
c	O
.	O
c_cdr	O
)	O
{	O
if	O
(	O
type_of	()->(int)
(	O
ds	O
->	O
c	O
.	O
c_car	O
)	O
!=	O
t_cons	O
)	O
illegal_declare	()->(int)
(	O
form	O
)	O
;	O
if	O
(	O
ds	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_car	O
==	O
sLspecial	O
)	O
{	O
vs	O
=	O
ds	O
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_cdr	O
;	O
for	O
(	O
;	O
!	O
endp	()->(int)
(	O
vs	O
)	O
;	O
vs	O
=	O
vs	O
->	O
c	O
.	O
c_cdr	O
)	O
{	O
v	O
=	O
vs	O
->	O
c	O
.	O
c_car	O
;	O
check_symbol	()->(int)
(	O
v	O
)	O
;	O
special_processed	O
=	O
FALSE	O
;	O
for	O
(	O
bt	*(struct)
=	O
start	*(struct)
;	O
bt	*(struct)
<	O
end	*(struct)
;	O
bt	*(struct)
++	O
)	O
if	O
(	O
bt	*(struct)
->	O
bt_var	O
==	O
v	O
)	O
{	O
bt	*(struct)
->	O
bt_spp	O
=	O
Ct	O
;	O
special_processed	O
=	O
TRUE	O
;	O
}	O
if	O
(	O
special_processed	O
)	O
continue	O
;	O
temporary	O
=	O
MMcons	()->(int)
(	O
v	O
,	O
Cnil	O
)	O
;	O
lex_env	O
[	O
0	int
]	O
=	O
MMcons	()->(int)
(	O
temporary	O
,	O
lex_env	O
[	O
0	int
]	O
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
body	int
!=	O
Cnil	O
&&	O
body	int
->	O
c	O
.	O
c_car	O
!=	O
form	O
)	O
body	int
=	O
make_cons	()->(int)
(	O
form	O
,	O
body	int
->	O
c	O
.	O
c_cdr	O
)	O
;	O
vs_reset	O
;	O
return	O
(	O
body	int
)	O
;	O
}	O
object	O
let_bind	(int,*(struct),*(struct))->(int)
(	O
object	O
body	int
,	O
struct	O
bind_temp	O
*	O
start	*(struct)
,	O
struct	O
bind_temp	O
*	O
end	*(struct)
)	O
{	O
struct	O
bind_temp	O
*	O
bt	*(struct)
;	O
bds_check	O
;	O
vs_push	()->(int)
(	O
find_special	(int,*(struct),*(struct))->(int)
(	O
body	int
,	O
start	*(struct)
,	O
end	*(struct)
)	O
)	O
;	O
for	O
(	O
bt	*(struct)
=	O
start	*(struct)
;	O
bt	*(struct)
<	O
end	*(struct)
;	O
bt	*(struct)
++	O
)	O
{	O
eval_assign	()->(int)
(	O
bt	*(struct)
->	O
bt_init	O
,	O
bt	*(struct)
->	O
bt_init	O
)	O
;	O
}	O
for	O
(	O
bt	*(struct)
=	O
start	*(struct)
;	O
bt	*(struct)
<	O
end	*(struct)
;	O
bt	*(struct)
++	O
)	O
{	O
bind_var	()->(int)
(	O
bt	*(struct)
->	O
bt_var	O
,	O
bt	*(struct)
->	O
bt_init	O
,	O
bt	*(struct)
->	O
bt_spp	O
)	O
;	O
}	O
return	O
(	O
vs_pop	O
)	O
;	O
}	O
object	O
letA_bind	(int,*(struct),*(struct))->(int)
(	O
object	O
body	int
,	O
struct	O
bind_temp	O
*	O
start	*(struct)
,	O
struct	O
bind_temp	O
*	O
end	*(struct)
)	O
{	O
struct	O
bind_temp	O
*	O
bt	*(struct)
;	O
bds_check	O
;	O
vs_push	()->(int)
(	O
find_special	(int,*(struct),*(struct))->(int)
(	O
body	int
,	O
start	*(struct)
,	O
end	*(struct)
)	O
)	O
;	O
for	O
(	O
bt	*(struct)
=	O
start	*(struct)
;	O
bt	*(struct)
<	O
end	*(struct)
;	O
bt	*(struct)
++	O
)	O
{	O
eval_assign	()->(int)
(	O
bt	*(struct)
->	O
bt_init	O
,	O
bt	*(struct)
->	O
bt_init	O
)	O
;	O
bind_var	()->(int)
(	O
bt	*(struct)
->	O
bt_var	O
,	O
bt	*(struct)
->	O
bt_init	O
,	O
bt	*(struct)
->	O
bt_spp	O
)	O
;	O
}	O
return	O
(	O
vs_pop	O
)	O
;	O
}	O
void	O
parse_key	(*(int),int,int,int)->(void)
(	O
object	O
*	O
base	*(int)
,	O
bool	O
rest	struct(int,int)
,	O
bool	O
allow_other_keys	int
,	O
int	O
n	int
,	O
...	O
)	O
{	O
object	O
temporary	O
;	O
va_list	O
ap	int
;	O
object	O
other_key	O
=	O
OBJNULL	O
;	O
int	O
narg	int
,	O
error_flag	int
=	O
0	int
,	O
allow_other_keys_found	int
=	O
0	int
;	O
object	O
*	O
v	O
,	O
k	O
,	O
*	O
top	O
;	O
register	O
int	O
i	int
;	O
narg	int
=	O
vs_top	O
-	O
base	*(int)
;	O
if	O
(	O
narg	int
<=	O
0	int
)	O
{	O
if	O
(	O
rest	struct(int,int)
)	O
{	O
base	*(int)
[	O
0	int
]	O
=	O
Cnil	O
;	O
base	*(int)
++	O
;	O
}	O
top	O
=	O
base	*(int)
+	O
n	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
base	*(int)
[	O
i	int
]	O
=	O
Cnil	O
;	O
top	O
[	O
i	int
]	O
=	O
Cnil	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
narg	int
%	O
2	int
!=	O
0	int
)	O
FEunexpected_keyword	()->(int)
(	O
Cnil	O
)	O
;	O
if	O
(	O
narg	int
==	O
2	int
)	O
{	O
k	O
=	O
base	*(int)
[	O
0	int
]	O
;	O
if	O
(	O
!	O
keywordp	()->(int)
(	O
k	O
)	O
)	O
FEunexpected_keyword	()->(int)
(	O
k	O
)	O
;	O
if	O
(	O
k	O
==	O
sKallow_other_keys	O
&&	O
!	O
allow_other_keys_found	int
)	O
{	O
allow_other_keys_found	int
=	O
1	int
;	O
if	O
(	O
base	*(int)
[	O
1	int
]	O
!=	O
Cnil	O
)	O
allow_other_keys	int
=	O
TRUE	O
;	O
}	O
temporary	O
=	O
base	*(int)
[	O
1	int
]	O
;	O
if	O
(	O
rest	struct(int,int)
)	O
base	*(int)
++	O
;	O
top	O
=	O
base	*(int)
+	O
n	int
;	O
other_key	O
=	O
k	O
==	O
sKallow_other_keys	O
?	O
OBJNULL	O
:	O
k	O
;	O
va_start	O
(	O
ap	int
,	O
n	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
==	O
k	O
)	O
{	O
base	*(int)
[	O
i	int
]	O
=	O
temporary	O
;	O
top	O
[	O
i	int
]	O
=	O
Ct	O
;	O
other_key	O
=	O
OBJNULL	O
;	O
}	O
else	O
{	O
base	*(int)
[	O
i	int
]	O
=	O
Cnil	O
;	O
top	O
[	O
i	int
]	O
=	O
Cnil	O
;	O
}	O
}	O
va_end	O
(	O
ap	int
)	O
;	O
if	O
(	O
rest	struct(int,int)
)	O
{	O
temporary	O
=	O
make_cons	()->(int)
(	O
temporary	O
,	O
Cnil	O
)	O
;	O
base	*(int)
[	O
-	O
1	int
]	O
=	O
make_cons	()->(int)
(	O
k	O
,	O
temporary	O
)	O
;	O
}	O
if	O
(	O
other_key	O
!=	O
OBJNULL	O
&&	O
!	O
allow_other_keys	int
)	O
FEunexpected_keyword	()->(int)
(	O
other_key	O
)	O
;	O
return	O
;	O
}	O
va_start	O
(	O
ap	int
,	O
n	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
k	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
k	O
->	O
s	O
.	O
s_stype	O
=	O
NOT_YET	int
;	O
k	O
->	O
s	O
.	O
s_dbind	O
=	O
Cnil	O
;	O
}	O
va_end	O
(	O
ap	int
)	O
;	O
for	O
(	O
v	O
=	O
base	*(int)
;	O
v	O
<	O
vs_top	O
;	O
v	O
+=	O
2	int
)	O
{	O
k	O
=	O
v	O
[	O
0	int
]	O
;	O
if	O
(	O
!	O
keywordp	()->(int)
(	O
k	O
)	O
)	O
{	O
error_flag	int
=	O
NOT_KEYWORD	int
;	O
other_key	O
=	O
k	O
;	O
continue	O
;	O
}	O
if	O
(	O
k	O
->	O
s	O
.	O
s_stype	O
==	O
NOT_YET	int
)	O
{	O
k	O
->	O
s	O
.	O
s_dbind	O
=	O
v	O
[	O
1	int
]	O
;	O
k	O
->	O
s	O
.	O
s_stype	O
=	O
FOUND	int
;	O
}	O
else	O
if	O
(	O
k	O
->	O
s	O
.	O
s_stype	O
==	O
FOUND	int
)	O
{	O
;	O
}	O
else	O
if	O
(	O
other_key	O
==	O
OBJNULL	O
&&	O
k	O
!=	O
sKallow_other_keys	O
)	O
other_key	O
=	O
k	O
;	O
if	O
(	O
k	O
==	O
sKallow_other_keys	O
&&	O
!	O
allow_other_keys_found	int
)	O
{	O
allow_other_keys_found	int
=	O
1	int
;	O
if	O
(	O
v	O
[	O
1	int
]	O
!=	O
Cnil	O
)	O
allow_other_keys	int
=	O
TRUE	O
;	O
}	O
}	O
if	O
(	O
rest	struct(int,int)
)	O
{	O
top	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
base	*(int)
++	O
;	O
while	O
(	O
base	*(int)
<	O
vs_top	O
)	O
stack_cons	()->(int)
(	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
}	O
top	O
=	O
base	*(int)
+	O
n	int
;	O
va_start	O
(	O
ap	int
,	O
n	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
k	O
=	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
;	O
base	*(int)
[	O
i	int
]	O
=	O
k	O
->	O
s	O
.	O
s_dbind	O
;	O
top	O
[	O
i	int
]	O
=	O
k	O
->	O
s	O
.	O
s_stype	O
==	O
FOUND	int
?	O
Ct	O
:	O
Cnil	O
;	O
k	O
->	O
s	O
.	O
s_dbind	O
=	O
k	O
;	O
k	O
->	O
s	O
.	O
s_stype	O
=	O
(	O
short	O
)	O
stp_constant	O
;	O
}	O
va_end	O
(	O
ap	int
)	O
;	O
if	O
(	O
error_flag	int
==	O
NOT_KEYWORD	int
)	O
FEunexpected_keyword	()->(int)
(	O
other_key	O
)	O
;	O
if	O
(	O
other_key	O
!=	O
OBJNULL	O
&&	O
!	O
allow_other_keys	int
)	O
FEunexpected_keyword	()->(int)
(	O
other_key	O
)	O
;	O
}	O
void	O
check_other_key	(int,int)->(void)
(	O
object	O
l	int
,	O
int	O
n	int
,	O
...	O
)	O
{	O
va_list	O
ap	int
;	O
object	O
other_key	O
=	O
OBJNULL	O
;	O
object	O
k	O
;	O
int	O
i	int
;	O
bool	O
allow_other_keys	int
=	O
FALSE	O
;	O
for	O
(	O
;	O
!	O
endp	()->(int)
(	O
l	int
)	O
;	O
l	int
=	O
l	int
->	O
c	O
.	O
c_cdr	O
->	O
c	O
.	O
c_cdr	O
)	O
{	O
k	O
=	O
l	int
->	O
c	O
.	O
c_car	O
;	O
if	O
(	O
!	O
keywordp	()->(int)
(	O
k	O
)	O
)	O
FEunexpected_keyword	()->(int)
(	O
k	O
)	O
;	O
if	O
(	O
endp	()->(int)
(	O
l	int
->	O
c	O
.	O
c_cdr	O
)	O
)	O
FEunexpected_keyword	()->(int)
(	O
Cnil	O
)	O
;	O
if	O
(	O
k	O
==	O
sKallow_other_keys	O
&&	O
l	int
->	O
c	O
.	O
c_cdr	O
->	O
c	O
.	O
c_car	O
!=	O
Cnil	O
)	O
{	O
allow_other_keys	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
char	O
buf	array(char)
[	O
100	int
]	O
;	O
bzero	O
(	O
buf	array(char)
,	O
n	int
)	O
;	O
va_start	O
(	O
ap	int
,	O
n	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
va_arg	()->(int)
(	O
ap	int
,	O
object	O
)	O
==	O
k	O
&&	O
buf	array(char)
[	O
i	int
]	O
==	O
0	int
)	O
{	O
buf	array(char)
[	O
i	int
]	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
va_end	O
(	O
ap	int
)	O
;	O
if	O
(	O
i	int
>=	O
n	int
)	O
other_key	O
=	O
k	O
;	O
}	O
}	O
if	O
(	O
other_key	O
!=	O
OBJNULL	O
&&	O
!	O
allow_other_keys	int
)	O
FEunexpected_keyword	()->(int)
(	O
other_key	O
)	O
;	O
}	O
object	O
Cstd_key_defaults	array(int)
[	O
15	int
]	O
=	O
{	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
,	O
Cnil	O
}	O
;	O
int	O
parse_key_new_new	(int,*(int),*(struct),int,int)->(int)
(	O
int	O
n	int
,	O
object	O
*	O
base	*(int)
,	O
struct	O
key	O
*	O
keys	*(struct)
,	O
object	O
first	int
,	O
va_list	O
ap	int
)	O
{	O
object	O
*	O
new	O
;	O
COERCE_VA_LIST_KR_NEW	()->(int)
(	O
new	O
,	O
first	int
,	O
ap	int
,	O
n	int
)	O
;	O
new	O
=	O
new	O
+	O
n	int
;	O
{	O
int	O
j	int
=	O
keys	*(struct)
->	O
n	int
;	O
object	O
*	O
p	O
=	O
(	O
object	O
*	O
)	O
(	O
keys	*(struct)
->	O
defaults	O
)	O
;	O
while	O
(	O
--	O
j	int
>=	O
0	int
)	O
base	*(int)
[	O
j	int
]	O
=	O
p	O
[	O
j	int
]	O
;	O
}	O
{	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
{	O
int	O
allow	int
=	O
keys	*(struct)
->	O
allow_other_keys	int
;	O
object	O
k	O
;	O
if	O
(	O
!	O
allow	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
n	int
;	O
i	int
>	O
0	int
&&	O
new	O
[	O
-	O
i	int
]	O
!=	O
sKallow_other_keys	O
;	O
i	int
-=	O
2	int
)	O
;	O
if	O
(	O
i	int
>	O
0	int
&&	O
new	O
[	O
-	O
i	int
+	O
1	int
]	O
!=	O
Cnil	O
)	O
allow	int
=	O
1	int
;	O
}	O
top	O
:	O
while	O
(	O
n	int
>=	O
2	int
)	O
{	O
int	O
i	int
=	O
keys	*(struct)
->	O
n	int
;	O
iobject	O
*	O
ke	O
=	O
keys	*(struct)
->	O
keys	*(struct)
;	O
new	O
=	O
new	O
-	O
2	int
;	O
k	O
=	O
*	O
new	O
;	O
while	O
(	O
--	O
i	int
>=	O
0	int
)	O
{	O
if	O
(	O
(	O
*	O
(	O
ke	O
++	O
)	O
)	O
.	O
o	O
==	O
k	O
)	O
{	O
base	*(int)
[	O
i	int
]	O
=	O
new	O
[	O
1	int
]	O
;	O
n	int
=	O
n	int
-	O
2	int
;	O
goto	O
top	O
;	O
}	O
}	O
if	O
(	O
allow	int
||	O
k	O
==	O
sKallow_other_keys	O
)	O
n	int
=	O
n	int
-	O
2	int
;	O
else	O
goto	O
error	O
;	O
}	O
if	O
(	O
n	int
!=	O
0	int
)	O
FEunexpected_keyword	()->(int)
(	O
Cnil	O
)	O
;	O
return	O
0	int
;	O
error	O
:	O
FEunexpected_keyword	()->(int)
(	O
k	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
int	O
parse_key_rest_new	(int,int,*(int),*(struct),int,int)->(int)
(	O
object	O
rest	struct(int,int)
,	O
int	O
n	int
,	O
object	O
*	O
base	*(int)
,	O
struct	O
key	O
*	O
keys	*(struct)
,	O
object	O
first	int
,	O
va_list	O
ap	int
)	O
{	O
object	O
*	O
new	O
;	O
COERCE_VA_LIST_KR_NEW	()->(int)
(	O
new	O
,	O
first	int
,	O
ap	int
,	O
n	int
)	O
;	O
{	O
object	O
*	O
p	O
=	O
new	O
;	O
int	O
m	int
=	O
n	int
;	O
while	O
(	O
--	O
m	int
>=	O
0	int
)	O
{	O
rest	struct(int,int)
->	O
c	O
.	O
c_car	O
=	O
*	O
p	O
++	O
;	O
rest	struct(int,int)
=	O
rest	struct(int,int)
->	O
c	O
.	O
c_cdr	O
;	O
}	O
}	O
new	O
=	O
new	O
+	O
n	int
;	O
{	O
int	O
j	int
=	O
keys	*(struct)
->	O
n	int
;	O
object	O
*	O
p	O
=	O
(	O
object	O
*	O
)	O
(	O
keys	*(struct)
->	O
defaults	O
)	O
;	O
while	O
(	O
--	O
j	int
>=	O
0	int
)	O
base	*(int)
[	O
j	int
]	O
=	O
p	O
[	O
j	int
]	O
;	O
}	O
{	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
{	O
int	O
allow	int
=	O
keys	*(struct)
->	O
allow_other_keys	int
;	O
object	O
k	O
;	O
if	O
(	O
!	O
allow	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
n	int
;	O
i	int
>	O
0	int
&&	O
new	O
[	O
-	O
i	int
]	O
!=	O
sKallow_other_keys	O
;	O
i	int
-=	O
2	int
)	O
;	O
if	O
(	O
i	int
>	O
0	int
&&	O
new	O
[	O
-	O
i	int
+	O
1	int
]	O
!=	O
Cnil	O
)	O
allow	int
=	O
1	int
;	O
}	O
top	O
:	O
while	O
(	O
n	int
>=	O
2	int
)	O
{	O
int	O
i	int
=	O
keys	*(struct)
->	O
n	int
;	O
iobject	O
*	O
ke	O
=	O
keys	*(struct)
->	O
keys	*(struct)
;	O
new	O
=	O
new	O
-	O
2	int
;	O
k	O
=	O
*	O
new	O
;	O
while	O
(	O
--	O
i	int
>=	O
0	int
)	O
{	O
if	O
(	O
(	O
*	O
(	O
ke	O
++	O
)	O
)	O
.	O
o	O
==	O
k	O
)	O
{	O
base	*(int)
[	O
i	int
]	O
=	O
new	O
[	O
1	int
]	O
;	O
n	int
=	O
n	int
-	O
2	int
;	O
goto	O
top	O
;	O
}	O
}	O
if	O
(	O
allow	int
||	O
k	O
==	O
sKallow_other_keys	O
)	O
n	int
=	O
n	int
-	O
2	int
;	O
else	O
goto	O
error	O
;	O
}	O
if	O
(	O
n	int
!=	O
0	int
)	O
FEunexpected_keyword	()->(int)
(	O
Cnil	O
)	O
;	O
return	O
0	int
;	O
error	O
:	O
FEunexpected_keyword	()->(int)
(	O
k	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
void	O
set_key_struct	(*(struct),int)->(void)
(	O
struct	O
key	O
*	O
ks	*(struct)
,	O
object	O
data	int
)	O
{	O
int	O
i	int
=	O
ks	*(struct)
->	O
n	int
;	O
while	O
(	O
--	O
i	int
>=	O
0	int
)	O
{	O
ks	*(struct)
->	O
keys	*(struct)
[	O
i	int
]	O
.	O
o	O
=	O
data	int
->	O
cfd	O
.	O
cfd_self	O
[	O
ks	*(struct)
->	O
keys	*(struct)
[	O
i	int
]	O
.	O
i	int
]	O
;	O
if	O
(	O
ks	*(struct)
->	O
defaults	O
!=	O
(	O
void	O
*	O
)	O
Cstd_key_defaults	array(int)
)	O
{	O
fixnum	O
m	int
=	O
ks	*(struct)
->	O
defaults	O
[	O
i	int
]	O
.	O
i	int
;	O
ks	*(struct)
->	O
defaults	O
[	O
i	int
]	O
.	O
o	O
=	O
(	O
m	int
==	O
-	O
2	int
?	O
Cnil	O
:	O
m	int
==	O
-	O
1	int
?	O
OBJNULL	O
:	O
data	int
->	O
cfd	O
.	O
cfd_self	O
[	O
m	int
]	O
)	O
;	O
}	O
}	O
}	O
DEF_ORDINARY	()->(int)
(	O
"ALLOW-OTHER-KEYS"	*(char)
,	O
sKallow_other_keys	O
,	O
KEYWORD	O
,	O
""	*(char)
)	O
;	O
void	O
gcl_init_bind	()->(void)
(	O
void	O
)	O
{	O
ANDoptional	O
=	O
make_ordinary	()->(int)
(	O
"&OPTIONAL"	*(char)
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
ANDoptional	O
)	O
;	O
ANDrest	O
=	O
make_ordinary	()->(int)
(	O
"&REST"	*(char)
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
ANDrest	O
)	O
;	O
ANDkey	O
=	O
make_ordinary	()->(int)
(	O
"&KEY"	*(char)
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
ANDkey	O
)	O
;	O
ANDallow_other_keys	O
=	O
make_ordinary	()->(int)
(	O
"&ALLOW-OTHER-KEYS"	*(char)
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
ANDallow_other_keys	O
)	O
;	O
ANDaux	O
=	O
make_ordinary	()->(int)
(	O
"&AUX"	*(char)
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
ANDaux	O
)	O
;	O
make_constant	()->(int)
(	O
"LAMBDA-LIST-KEYWORDS"	*(char)
,	O
make_cons	()->(int)
(	O
ANDoptional	O
,	O
make_cons	()->(int)
(	O
ANDrest	O
,	O
make_cons	()->(int)
(	O
ANDkey	O
,	O
make_cons	()->(int)
(	O
ANDallow_other_keys	O
,	O
make_cons	()->(int)
(	O
ANDaux	O
,	O
make_cons	()->(int)
(	O
make_ordinary	()->(int)
(	O
"&WHOLE"	*(char)
)	O
,	O
make_cons	()->(int)
(	O
make_ordinary	()->(int)
(	O
"&ENVIRONMENT"	*(char)
)	O
,	O
make_cons	()->(int)
(	O
make_ordinary	()->(int)
(	O
"&BODY"	*(char)
)	O
,	O
Cnil	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LAMBDA-PARAMETERS-LIMIT"	*(char)
,	O
make_fixnum	()->(int)
(	O
64	int
)	O
)	O
;	O
three_nils	struct(array(int))
.	O
nil3_self	array(int)
[	O
0	int
]	O
=	O
Cnil	O
;	O
three_nils	struct(array(int))
.	O
nil3_self	array(int)
[	O
1	int
]	O
=	O
Cnil	O
;	O
three_nils	struct(array(int))
.	O
nil3_self	array(int)
[	O
2	int
]	O
=	O
Cnil	O
;	O
six_nils	struct(array(int))
.	O
nil6_self	array(int)
[	O
0	int
]	O
=	O
Cnil	O
;	O
six_nils	struct(array(int))
.	O
nil6_self	array(int)
[	O
1	int
]	O
=	O
Cnil	O
;	O
six_nils	struct(array(int))
.	O
nil6_self	array(int)
[	O
2	int
]	O
=	O
Cnil	O
;	O
six_nils	struct(array(int))
.	O
nil6_self	array(int)
[	O
3	int
]	O
=	O
Cnil	O
;	O
six_nils	struct(array(int))
.	O
nil6_self	array(int)
[	O
4	int
]	O
=	O
Cnil	O
;	O
six_nils	struct(array(int))
.	O
nil6_self	array(int)
[	O
5	int
]	O
=	O
Cnil	O
;	O
}	O
