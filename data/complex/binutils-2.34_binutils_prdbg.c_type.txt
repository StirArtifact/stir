struct	O
pr_handle	O
{	O
FILE	struct
*	O
f	O
;	O
unsigned	O
int	O
indent	O
;	O
struct	O
pr_stack	O
*	O
stack	O
;	O
int	O
parameter	O
;	O
char	O
*	O
filename	*(char)
;	O
bfd	struct
*	O
abfd	*(struct)
;	O
asymbol	struct(*(struct),*(char),long,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct(*`,long,long,*`)),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct(struct`,*`)),*(struct),*(struct(*`,*`,long,int,*`,union`)),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),union(*(void),long))
*	O
*	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
;	O
char	O
*	O
(	O
*	O
demangler	O
)	O
(	O
bfd	struct
*	O
,	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
}	O
;	O
struct	O
pr_stack	O
{	O
struct	O
pr_stack	O
*	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
char	O
*	O
type	enum(int,int,int,int)
;	O
enum	O
debug_visibility	O
visibility	O
;	O
const	O
char	O
*	O
method	O
;	O
const	O
char	O
*	O
flavor	O
;	O
char	O
*	O
parents	O
;	O
int	O
num_parents	O
;	O
}	O
;	O
static	O
void	O
indent	O
(	O
struct	O
pr_handle	O
*	O
)	O
;	O
static	O
bfd_boolean	int
push_type	O
(	O
struct	O
pr_handle	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
prepend_type	O
(	O
struct	O
pr_handle	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
append_type	O
(	O
struct	O
pr_handle	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
substitute_type	O
(	O
struct	O
pr_handle	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
indent_type	O
(	O
struct	O
pr_handle	O
*	O
)	O
;	O
static	O
char	O
*	O
pop_type	O
(	O
struct	O
pr_handle	O
*	O
)	O
;	O
static	O
void	O
print_vma	O
(	O
bfd_vma	long
,	O
char	O
*	O
,	O
bfd_boolean	int
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
pr_fix_visibility	O
(	O
struct	O
pr_handle	O
*	O
,	O
enum	O
debug_visibility	O
)	O
;	O
static	O
bfd_boolean	int
pr_start_compilation_unit	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_start_source	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_empty_type	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_void_type	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_int_type	O
(	O
void	O
*	O
,	O
unsigned	O
int	O
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
pr_float_type	O
(	O
void	O
*	O
,	O
unsigned	O
int	O
)	O
;	O
static	O
bfd_boolean	int
pr_complex_type	O
(	O
void	O
*	O
,	O
unsigned	O
int	O
)	O
;	O
static	O
bfd_boolean	int
pr_bool_type	O
(	O
void	O
*	O
,	O
unsigned	O
int	O
)	O
;	O
static	O
bfd_boolean	int
pr_enum_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
bfd_signed_vma	long
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_pointer_type	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_function_type	O
(	O
void	O
*	O
,	O
int	O
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
pr_reference_type	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_range_type	O
(	O
void	O
*	O
,	O
bfd_signed_vma	long
,	O
bfd_signed_vma	long
)	O
;	O
static	O
bfd_boolean	int
pr_array_type	O
(	O
void	O
*	O
,	O
bfd_signed_vma	long
,	O
bfd_signed_vma	long
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
pr_set_type	O
(	O
void	O
*	O
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
pr_offset_type	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_method_type	O
(	O
void	O
*	O
,	O
bfd_boolean	int
,	O
int	O
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
pr_const_type	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_volatile_type	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_start_struct_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
unsigned	O
int	O
,	O
bfd_boolean	int
,	O
unsigned	O
int	O
)	O
;	O
static	O
bfd_boolean	int
pr_struct_field	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
,	O
bfd_vma	long
,	O
enum	O
debug_visibility	O
)	O
;	O
static	O
bfd_boolean	int
pr_end_struct_type	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_start_class_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
unsigned	O
int	O
,	O
bfd_boolean	int
,	O
unsigned	O
int	O
,	O
bfd_boolean	int
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
pr_class_static_member	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_visibility	O
)	O
;	O
static	O
bfd_boolean	int
pr_class_baseclass	O
(	O
void	O
*	O
,	O
bfd_vma	long
,	O
bfd_boolean	int
,	O
enum	O
debug_visibility	O
)	O
;	O
static	O
bfd_boolean	int
pr_class_start_method	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_class_method_variant	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_visibility	O
,	O
bfd_boolean	int
,	O
bfd_boolean	int
,	O
bfd_vma	long
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
pr_class_static_method_variant	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_visibility	O
,	O
bfd_boolean	int
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
pr_class_end_method	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_end_class_type	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_typedef_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_tag_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
unsigned	O
int	O
,	O
enum	O
debug_type_kind	O
)	O
;	O
static	O
bfd_boolean	int
pr_typdef	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_tag	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_int_constant	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
pr_float_constant	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
double	O
)	O
;	O
static	O
bfd_boolean	int
pr_typed_constant	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
pr_variable	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_var_kind	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
pr_start_function	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
pr_function_parameter	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_parm_kind	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
pr_start_block	O
(	O
void	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
pr_end_block	O
(	O
void	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
pr_end_function	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
pr_lineno	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
unsigned	O
long	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
append_parent	O
(	O
struct	O
pr_handle	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
tg_fix_visibility	O
(	O
struct	O
pr_handle	O
*	O
,	O
enum	O
debug_visibility	O
)	O
;	O
static	O
void	O
find_address_in_section	O
(	O
bfd	struct
*	O
,	O
asection	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*(struct`),long))),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))))
*	O
,	O
void	O
*	O
)	O
;	O
static	O
void	O
translate_addresses	O
(	O
bfd	struct
*	O
,	O
char	O
*	O
,	O
FILE	struct
*	O
,	O
asymbol	struct(*(struct),*(char),long,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct(*`,long,long,*`)),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct(struct`,*`)),*(struct),*(struct(*`,*`,long,int,*`,union`)),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),union(*(void),long))
*	O
*	O
)	O
;	O
static	O
const	O
char	O
*	O
visibility_name	O
(	O
enum	O
debug_visibility	O
)	O
;	O
static	O
bfd_boolean	int
tg_start_compilation_unit	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
tg_start_source	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
tg_enum_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
*	O
,	O
bfd_signed_vma	long
*	O
)	O
;	O
static	O
bfd_boolean	int
tg_start_struct_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
unsigned	O
int	O
,	O
bfd_boolean	int
,	O
unsigned	O
int	O
)	O
;	O
static	O
bfd_boolean	int
pr_struct_field	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
,	O
bfd_vma	long
,	O
enum	O
debug_visibility	O
)	O
;	O
static	O
bfd_boolean	int
tg_struct_field	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
,	O
bfd_vma	long
,	O
enum	O
debug_visibility	O
)	O
;	O
static	O
bfd_boolean	int
tg_struct_field	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
,	O
bfd_vma	long
,	O
enum	O
debug_visibility	O
)	O
;	O
static	O
bfd_boolean	int
tg_end_struct_type	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
tg_start_class_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
unsigned	O
int	O
,	O
bfd_boolean	int
,	O
unsigned	O
int	O
,	O
bfd_boolean	int
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
tg_class_static_member	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_visibility	O
)	O
;	O
static	O
bfd_boolean	int
tg_class_baseclass	O
(	O
void	O
*	O
,	O
bfd_vma	long
,	O
bfd_boolean	int
,	O
enum	O
debug_visibility	O
)	O
;	O
static	O
bfd_boolean	int
tg_class_method_variant	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_visibility	O
,	O
bfd_boolean	int
,	O
bfd_boolean	int
,	O
bfd_vma	long
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
tg_class_static_method_variant	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_visibility	O
,	O
bfd_boolean	int
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
tg_end_class_type	O
(	O
void	O
*	O
)	O
;	O
static	O
bfd_boolean	int
tg_tag_type	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
unsigned	O
int	O
,	O
enum	O
debug_type_kind	O
)	O
;	O
static	O
bfd_boolean	int
tg_typdef	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
tg_tag	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
tg_int_constant	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
tg_float_constant	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
double	O
)	O
;	O
static	O
bfd_boolean	int
tg_typed_constant	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
tg_variable	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_var_kind	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
tg_start_function	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
bfd_boolean	int
)	O
;	O
static	O
bfd_boolean	int
tg_function_parameter	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
enum	O
debug_parm_kind	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
tg_start_block	O
(	O
void	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
tg_end_block	O
(	O
void	O
*	O
,	O
bfd_vma	long
)	O
;	O
static	O
bfd_boolean	int
tg_lineno	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
unsigned	O
long	O
,	O
bfd_vma	long
)	O
;	O
static	O
const	O
struct	O
debug_write_fns	O
pr_fns	O
=	O
{	O
pr_start_compilation_unit	O
,	O
pr_start_source	O
,	O
pr_empty_type	O
,	O
pr_void_type	O
,	O
pr_int_type	O
,	O
pr_float_type	O
,	O
pr_complex_type	O
,	O
pr_bool_type	O
,	O
pr_enum_type	O
,	O
pr_pointer_type	O
,	O
pr_function_type	O
,	O
pr_reference_type	O
,	O
pr_range_type	O
,	O
pr_array_type	O
,	O
pr_set_type	O
,	O
pr_offset_type	O
,	O
pr_method_type	O
,	O
pr_const_type	O
,	O
pr_volatile_type	O
,	O
pr_start_struct_type	O
,	O
pr_struct_field	O
,	O
pr_end_struct_type	O
,	O
pr_start_class_type	O
,	O
pr_class_static_member	O
,	O
pr_class_baseclass	O
,	O
pr_class_start_method	O
,	O
pr_class_method_variant	O
,	O
pr_class_static_method_variant	O
,	O
pr_class_end_method	O
,	O
pr_end_class_type	O
,	O
pr_typedef_type	O
,	O
pr_tag_type	O
,	O
pr_typdef	O
,	O
pr_tag	O
,	O
pr_int_constant	O
,	O
pr_float_constant	O
,	O
pr_typed_constant	O
,	O
pr_variable	O
,	O
pr_start_function	O
,	O
pr_function_parameter	O
,	O
pr_start_block	O
,	O
pr_end_block	O
,	O
pr_end_function	O
,	O
pr_lineno	O
}	O
;	O
static	O
const	O
struct	O
debug_write_fns	O
tg_fns	O
=	O
{	O
tg_start_compilation_unit	O
,	O
tg_start_source	O
,	O
pr_empty_type	O
,	O
pr_void_type	O
,	O
pr_int_type	O
,	O
pr_float_type	O
,	O
pr_complex_type	O
,	O
pr_bool_type	O
,	O
tg_enum_type	O
,	O
pr_pointer_type	O
,	O
pr_function_type	O
,	O
pr_reference_type	O
,	O
pr_range_type	O
,	O
pr_array_type	O
,	O
pr_set_type	O
,	O
pr_offset_type	O
,	O
pr_method_type	O
,	O
pr_const_type	O
,	O
pr_volatile_type	O
,	O
tg_start_struct_type	O
,	O
tg_struct_field	O
,	O
tg_end_struct_type	O
,	O
tg_start_class_type	O
,	O
tg_class_static_member	O
,	O
tg_class_baseclass	O
,	O
pr_class_start_method	O
,	O
tg_class_method_variant	O
,	O
tg_class_static_method_variant	O
,	O
pr_class_end_method	O
,	O
tg_end_class_type	O
,	O
pr_typedef_type	O
,	O
tg_tag_type	O
,	O
tg_typdef	O
,	O
tg_tag	O
,	O
tg_int_constant	O
,	O
tg_float_constant	O
,	O
tg_typed_constant	O
,	O
tg_variable	O
,	O
tg_start_function	O
,	O
tg_function_parameter	O
,	O
tg_start_block	O
,	O
tg_end_block	O
,	O
pr_end_function	O
,	O
tg_lineno	O
}	O
;	O
static	O
int	O
demangle_flags	O
=	O
DMGL_ANSI	O
|	O
DMGL_PARAMS	O
;	O
bfd_boolean	int
print_debugging_info	O
(	O
FILE	struct
*	O
f	O
,	O
void	O
*	O
dhandle	O
,	O
bfd	struct
*	O
abfd	*(struct)
,	O
asymbol	struct(*(struct),*(char),long,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct(*`,long,long,*`)),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct(struct`,*`)),*(struct),*(struct(*`,*`,long,int,*`,union`)),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),union(*(void),long))
*	O
*	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
,	O
char	O
*	O
(	O
*	O
demangler	O
)	O
(	O
struct	O
bfd	struct
*	O
,	O
const	O
char	O
*	O
,	O
int	O
)	O
,	O
bfd_boolean	int
as_tags	O
)	O
{	O
struct	O
pr_handle	O
info	*(void)
;	O
info	*(void)
.	O
f	O
=	O
f	O
;	O
info	*(void)
.	O
indent	O
=	O
0	int
;	O
info	*(void)
.	O
stack	O
=	O
NULL	O
;	O
info	*(void)
.	O
parameter	O
=	O
0	int
;	O
info	*(void)
.	O
filename	*(char)
=	O
NULL	O
;	O
info	*(void)
.	O
abfd	*(struct)
=	O
abfd	*(struct)
;	O
info	*(void)
.	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
=	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
;	O
info	*(void)
.	O
demangler	O
=	O
demangler	O
;	O
if	O
(	O
as_tags	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"!_TAG_FILE_FORMAT\t2\t/extended format/\n"	*(char)
,	O
f	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"!_TAG_FILE_SORTED\t0\t/0=unsorted, 1=sorted/\n"	*(char)
,	O
f	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"!_TAG_PROGRAM_AUTHOR\tIan Lance Taylor, Salvador E. Tropea and others\t//\n"	*(char)
,	O
f	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"!_TAG_PROGRAM_NAME\tobjdump\t/From GNU binutils/\n"	*(char)
,	O
f	O
)	O
;	O
}	O
return	O
as_tags	O
?	O
debug_write	O
(	O
dhandle	O
,	O
&	O
tg_fns	O
,	O
(	O
void	O
*	O
)	O
&	O
info	*(void)
)	O
:	O
debug_write	O
(	O
dhandle	O
,	O
&	O
pr_fns	O
,	O
(	O
void	O
*	O
)	O
&	O
info	*(void)
)	O
;	O
}	O
static	O
void	O
indent	O
(	O
struct	O
pr_handle	O
*	O
info	*(void)
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
info	*(void)
->	O
indent	O
;	O
i	*(struct)
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
info	*(void)
->	O
f	O
)	O
;	O
}	O
static	O
bfd_boolean	int
push_type	O
(	O
struct	O
pr_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
type	enum(int,int,int,int)
)	O
{	O
struct	O
pr_stack	O
*	O
n	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
n	O
=	O
(	O
struct	O
pr_stack	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
*	O
n	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
n	O
,	O
0	int
,	O
sizeof	O
*	O
n	O
)	O
;	O
n	O
->	O
type	enum(int,int,int,int)
=	O
xstrdup	O
(	O
type	enum(int,int,int,int)
)	O
;	O
n	O
->	O
visibility	O
=	O
DEBUG_VISIBILITY_IGNORE	O
;	O
n	O
->	O
method	O
=	O
NULL	O
;	O
n	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
info	*(void)
->	O
stack	O
;	O
info	*(void)
->	O
stack	O
=	O
n	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
prepend_type	O
(	O
struct	O
pr_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
{	O
char	O
*	O
n	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
n	O
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
strlen	(*(char))->(long)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
+	O
strlen	(*(char))->(long)
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
+	O
1	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
n	O
,	O
"%s%s"	*(char)
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
;	O
free	(*(void))->(void)
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
;	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
=	O
n	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
append_type	O
(	O
struct	O
pr_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
{	O
unsigned	O
int	O
len	long
;	O
if	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
;	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
=	O
(	O
char	O
*	O
)	O
xrealloc	O
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
,	O
len	long
+	O
strlen	(*(char))->(long)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
+	O
len	long
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
append_parent	O
(	O
struct	O
pr_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
{	O
unsigned	O
int	O
len	long
;	O
if	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
len	long
=	O
info	*(void)
->	O
stack	O
->	O
parents	O
?	O
strlen	(*(char))->(long)
(	O
info	*(void)
->	O
stack	O
->	O
parents	O
)	O
:	O
0	int
;	O
info	*(void)
->	O
stack	O
->	O
parents	O
=	O
(	O
char	O
*	O
)	O
xrealloc	O
(	O
info	*(void)
->	O
stack	O
->	O
parents	O
,	O
len	long
+	O
strlen	(*(char))->(long)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
info	*(void)
->	O
stack	O
->	O
parents	O
+	O
len	long
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
substitute_type	O
(	O
struct	O
pr_handle	O
*	O
info	*(void)
,	O
const	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
{	O
char	O
*	O
u	union(long,*(struct))
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
u	union(long,*(struct))
=	O
strchr	(*(char),int)->(*(char))
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
,	O
'|'	O
)	O
;	O
if	O
(	O
u	union(long,*(struct))
!=	O
NULL	O
)	O
{	O
char	O
*	O
n	O
;	O
n	O
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
strlen	(*(char))->(long)
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
+	O
strlen	(*(char))->(long)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
n	O
,	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
,	O
u	union(long,*(struct))
-	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
n	O
+	O
(	O
u	union(long,*(struct))
-	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
n	O
,	O
u	union(long,*(struct))
+	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
;	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
=	O
n	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
'|'	O
)	O
!=	O
NULL	O
&&	O
(	O
strchr	(*(char),int)->(*(char))
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
,	O
'{'	O
)	O
!=	O
NULL	O
||	O
strchr	(*(char),int)->(*(char))
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
,	O
'('	O
)	O
!=	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
prepend_type	O
(	O
info	*(void)
,	O
"("	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
")"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
'\0'	O
)	O
return	O
TRUE	int
;	O
return	O
(	O
append_type	O
(	O
info	*(void)
,	O
" "	*(char)
)	O
&&	O
append_type	O
(	O
info	*(void)
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
indent_type	O
(	O
struct	O
pr_handle	O
*	O
info	*(void)
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
info	*(void)
->	O
indent	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
char	O
*	O
pop_type	O
(	O
struct	O
pr_handle	O
*	O
info	*(void)
)	O
{	O
struct	O
pr_stack	O
*	O
o	O
;	O
char	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
o	O
=	O
info	*(void)
->	O
stack	O
;	O
info	*(void)
->	O
stack	O
=	O
o	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
o	O
->	O
type	enum(int,int,int,int)
;	O
free	(*(void))->(void)
(	O
o	O
)	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
static	O
void	O
print_vma	O
(	O
bfd_vma	long
vma	long
,	O
char	O
*	O
buf	*(void)
,	O
bfd_boolean	int
unsignedp	O
,	O
bfd_boolean	int
hexp	O
)	O
{	O
if	O
(	O
sizeof	O
(	O
vma	long
)	O
<=	O
sizeof	O
(	O
unsigned	O
long	O
)	O
)	O
{	O
if	O
(	O
hexp	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
"0x%lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
vma	long
)	O
;	O
else	O
if	O
(	O
unsignedp	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
"%lu"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
vma	long
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
,	O
"%ld"	*(char)
,	O
(	O
long	O
)	O
vma	long
)	O
;	O
}	O
else	O
{	O
buf	*(void)
[	O
0	int
]	O
=	O
'0'	O
;	O
buf	*(void)
[	O
1	int
]	O
=	O
'x'	O
;	O
sprintf_vma	O
(	O
buf	*(void)
+	O
2	int
,	O
vma	long
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
pr_start_compilation_unit	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
assert	O
(	O
info	*(void)
->	O
indent	O
==	O
0	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s:\n"	*(char)
,	O
filename	*(char)
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_start_source	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
assert	O
(	O
info	*(void)
->	O
indent	O
==	O
0	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
" %s:\n"	*(char)
,	O
filename	*(char)
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_empty_type	O
(	O
void	O
*	O
p	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
return	O
push_type	O
(	O
info	*(void)
,	O
"<undefined>"	*(char)
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_void_type	O
(	O
void	O
*	O
p	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
return	O
push_type	O
(	O
info	*(void)
,	O
"void"	*(char)
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_int_type	O
(	O
void	O
*	O
p	*(void)
,	O
unsigned	O
int	O
size	int
,	O
bfd_boolean	int
unsignedp	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
ab	O
[	O
40	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
ab	O
,	O
"%sint%d"	*(char)
,	O
unsignedp	O
?	O
"u"	*(char)
:	O
""	*(char)
,	O
size	int
*	O
8	int
)	O
;	O
return	O
push_type	O
(	O
info	*(void)
,	O
ab	O
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_float_type	O
(	O
void	O
*	O
p	*(void)
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
ab	O
[	O
40	int
]	O
;	O
if	O
(	O
size	int
==	O
4	int
)	O
return	O
push_type	O
(	O
info	*(void)
,	O
"float"	*(char)
)	O
;	O
else	O
if	O
(	O
size	int
==	O
8	int
)	O
return	O
push_type	O
(	O
info	*(void)
,	O
"double"	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
ab	O
,	O
"float%d"	*(char)
,	O
size	int
*	O
8	int
)	O
;	O
return	O
push_type	O
(	O
info	*(void)
,	O
ab	O
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_complex_type	O
(	O
void	O
*	O
p	*(void)
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
if	O
(	O
!	O
pr_float_type	O
(	O
p	*(void)
,	O
size	int
)	O
)	O
return	O
FALSE	O
;	O
return	O
prepend_type	O
(	O
info	*(void)
,	O
"complex "	*(char)
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_bool_type	O
(	O
void	O
*	O
p	*(void)
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
ab	O
[	O
40	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
ab	O
,	O
"bool%d"	*(char)
,	O
size	int
*	O
8	int
)	O
;	O
return	O
push_type	O
(	O
info	*(void)
,	O
ab	O
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_enum_type	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
tag	O
,	O
const	O
char	O
*	O
*	O
names	O
,	O
bfd_signed_vma	long
*	O
values	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
unsigned	O
int	O
i	*(struct)
;	O
bfd_signed_vma	long
val	array(int)
;	O
if	O
(	O
!	O
push_type	O
(	O
info	*(void)
,	O
"enum "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
tag	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
tag	O
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
" "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"{ "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
names	O
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"/* undefined */"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
val	array(int)
=	O
0	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
names	O
[	O
i	*(struct)
]	O
!=	O
NULL	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
i	*(struct)
>	O
0	int
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
", "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
names	O
[	O
i	*(struct)
]	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
values	O
[	O
i	*(struct)
]	O
!=	O
val	array(int)
)	O
{	O
char	O
ab	O
[	O
22	int
]	O
;	O
print_vma	O
(	O
values	O
[	O
i	*(struct)
]	O
,	O
ab	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" = "	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
ab	O
)	O
)	O
return	O
FALSE	O
;	O
val	array(int)
=	O
values	O
[	O
i	*(struct)
]	O
;	O
}	O
++	O
val	array(int)
;	O
}	O
}	O
return	O
append_type	O
(	O
info	*(void)
,	O
" }"	*(char)
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_pointer_type	O
(	O
void	O
*	O
p	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
strchr	(*(char),int)->(*(char))
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
,	O
'|'	O
)	O
;	O
if	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
!=	O
NULL	O
&&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
[	O
1	int
]	O
==	O
'['	O
)	O
return	O
substitute_type	O
(	O
info	*(void)
,	O
"(*|)"	*(char)
)	O
;	O
return	O
substitute_type	O
(	O
info	*(void)
,	O
"*|"	*(char)
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_function_type	O
(	O
void	O
*	O
p	*(void)
,	O
int	O
argcount	O
,	O
bfd_boolean	int
varargs	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
*	O
arg_types	O
;	O
unsigned	O
int	O
len	long
;	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
len	long
=	O
10	int
;	O
if	O
(	O
argcount	O
<=	O
0	int
)	O
{	O
arg_types	O
=	O
NULL	O
;	O
len	long
+=	O
15	int
;	O
}	O
else	O
{	O
int	O
i	*(struct)
;	O
arg_types	O
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	O
(	O
argcount	O
*	O
sizeof	O
*	O
arg_types	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
argcount	O
-	O
1	int
;	O
i	*(struct)
>=	O
0	int
;	O
i	*(struct)
--	O
)	O
{	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
""	*(char)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
arg_types	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
arg_types	O
[	O
i	*(struct)
]	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
arg_types	O
[	O
i	*(struct)
]	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
arg_types	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
len	long
+=	O
strlen	(*(char))->(long)
(	O
arg_types	O
[	O
i	*(struct)
]	O
)	O
+	O
2	int
;	O
}	O
if	O
(	O
varargs	O
)	O
len	long
+=	O
5	int
;	O
}	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
len	long
)	O
;	O
LITSTRCPY	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"(|) ("	*(char)
)	O
;	O
if	O
(	O
argcount	O
<	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"/* unknown */"	*(char)
)	O
;	O
else	O
{	O
int	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
argcount	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
i	*(struct)
>	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
", "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
arg_types	O
[	O
i	*(struct)
]	O
)	O
;	O
}	O
if	O
(	O
varargs	O
)	O
{	O
if	O
(	O
i	*(struct)
>	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
", "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"..."	*(char)
)	O
;	O
}	O
if	O
(	O
argcount	O
>	O
0	int
)	O
free	(*(void))->(void)
(	O
arg_types	O
)	O
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
")"	*(char)
)	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
return	O
FALSE	O
;	O
free	(*(void))->(void)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_reference_type	O
(	O
void	O
*	O
p	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
return	O
substitute_type	O
(	O
info	*(void)
,	O
"&|"	*(char)
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_range_type	O
(	O
void	O
*	O
p	*(void)
,	O
bfd_signed_vma	long
lower	O
,	O
bfd_signed_vma	long
upper	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
abl	O
[	O
22	int
]	O
,	O
abu	O
[	O
22	int
]	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
""	*(char)
)	O
)	O
return	O
FALSE	O
;	O
print_vma	O
(	O
lower	O
,	O
abl	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
print_vma	O
(	O
upper	O
,	O
abu	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
return	O
(	O
prepend_type	O
(	O
info	*(void)
,	O
"range ("	*(char)
)	O
&&	O
append_type	O
(	O
info	*(void)
,	O
"):"	*(char)
)	O
&&	O
append_type	O
(	O
info	*(void)
,	O
abl	O
)	O
&&	O
append_type	O
(	O
info	*(void)
,	O
":"	*(char)
)	O
&&	O
append_type	O
(	O
info	*(void)
,	O
abu	O
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_array_type	O
(	O
void	O
*	O
p	*(void)
,	O
bfd_signed_vma	long
lower	O
,	O
bfd_signed_vma	long
upper	O
,	O
bfd_boolean	int
stringp	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
range_type	O
;	O
char	O
abl	O
[	O
22	int
]	O
,	O
abu	O
[	O
22	int
]	O
,	O
ab	O
[	O
50	int
]	O
;	O
range_type	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
range_type	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
lower	O
==	O
0	int
)	O
{	O
if	O
(	O
upper	O
==	O
-	O
1	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
ab	O
,	O
"|[]"	*(char)
)	O
;	O
else	O
{	O
print_vma	O
(	O
upper	O
+	O
1	int
,	O
abu	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
ab	O
,	O
"|[%s]"	*(char)
,	O
abu	O
)	O
;	O
}	O
}	O
else	O
{	O
print_vma	O
(	O
lower	O
,	O
abl	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
print_vma	O
(	O
upper	O
,	O
abu	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
ab	O
,	O
"|[%s:%s]"	*(char)
,	O
abl	O
,	O
abu	O
)	O
;	O
}	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
ab	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
range_type	O
,	O
"int"	*(char)
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
":"	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
range_type	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
stringp	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" /* string */"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_set_type	O
(	O
void	O
*	O
p	*(void)
,	O
bfd_boolean	int
bitstringp	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
""	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
prepend_type	O
(	O
info	*(void)
,	O
"set { "	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
" }"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
bitstringp	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"/* bitstring */"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_offset_type	O
(	O
void	O
*	O
p	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
""	*(char)
)	O
)	O
return	O
FALSE	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
substitute_type	O
(	O
info	*(void)
,	O
""	*(char)
)	O
&&	O
prepend_type	O
(	O
info	*(void)
,	O
" "	*(char)
)	O
&&	O
prepend_type	O
(	O
info	*(void)
,	O
t	O
)	O
&&	O
append_type	O
(	O
info	*(void)
,	O
"::|"	*(char)
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_method_type	O
(	O
void	O
*	O
p	*(void)
,	O
bfd_boolean	int
domain	O
,	O
int	O
argcount	O
,	O
bfd_boolean	int
varargs	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
unsigned	O
int	O
len	long
;	O
char	O
*	O
domain_type	O
;	O
char	O
*	O
*	O
arg_types	O
;	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
len	long
=	O
10	int
;	O
if	O
(	O
!	O
domain	O
)	O
domain_type	O
=	O
NULL	O
;	O
else	O
{	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
""	*(char)
)	O
)	O
return	O
FALSE	O
;	O
domain_type	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
domain_type	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
domain_type	O
,	O
"class "	*(char)
)	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
domain_type	O
+	O
sizeof	O
"class "	*(char)
-	O
1	int
,	O
' '	O
)	O
==	O
NULL	O
)	O
domain_type	O
+=	O
sizeof	O
"class "	*(char)
-	O
1	int
;	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
domain_type	O
,	O
"union class "	*(char)
)	O
&&	O
(	O
strchr	(*(char),int)->(*(char))
(	O
domain_type	O
+	O
sizeof	O
"union class "	*(char)
-	O
1	int
,	O
' '	O
)	O
==	O
NULL	O
)	O
)	O
domain_type	O
+=	O
sizeof	O
"union class "	*(char)
-	O
1	int
;	O
len	long
+=	O
strlen	(*(char))->(long)
(	O
domain_type	O
)	O
;	O
}	O
if	O
(	O
argcount	O
<=	O
0	int
)	O
{	O
arg_types	O
=	O
NULL	O
;	O
len	long
+=	O
15	int
;	O
}	O
else	O
{	O
int	O
i	*(struct)
;	O
arg_types	O
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	O
(	O
argcount	O
*	O
sizeof	O
*	O
arg_types	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
argcount	O
-	O
1	int
;	O
i	*(struct)
>=	O
0	int
;	O
i	*(struct)
--	O
)	O
{	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
""	*(char)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
arg_types	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
arg_types	O
[	O
i	*(struct)
]	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
arg_types	O
[	O
i	*(struct)
]	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
arg_types	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
len	long
+=	O
strlen	(*(char))->(long)
(	O
arg_types	O
[	O
i	*(struct)
]	O
)	O
+	O
2	int
;	O
}	O
if	O
(	O
varargs	O
)	O
len	long
+=	O
5	int
;	O
}	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
len	long
)	O
;	O
if	O
(	O
!	O
domain	O
)	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
'\0'	O
;	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
domain_type	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"::| ("	*(char)
)	O
;	O
if	O
(	O
argcount	O
<	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"/* unknown */"	*(char)
)	O
;	O
else	O
{	O
int	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
argcount	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
i	*(struct)
>	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
", "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
arg_types	O
[	O
i	*(struct)
]	O
)	O
;	O
}	O
if	O
(	O
varargs	O
)	O
{	O
if	O
(	O
i	*(struct)
>	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
", "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"..."	*(char)
)	O
;	O
}	O
if	O
(	O
argcount	O
>	O
0	int
)	O
free	(*(void))->(void)
(	O
arg_types	O
)	O
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
")"	*(char)
)	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
return	O
FALSE	O
;	O
free	(*(void))->(void)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_const_type	O
(	O
void	O
*	O
p	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
return	O
substitute_type	O
(	O
info	*(void)
,	O
"const |"	*(char)
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_volatile_type	O
(	O
void	O
*	O
p	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
return	O
substitute_type	O
(	O
info	*(void)
,	O
"volatile |"	*(char)
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_start_struct_type	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
tag	O
,	O
unsigned	O
int	O
id	int
,	O
bfd_boolean	int
structp	O
,	O
unsigned	O
int	O
size	int
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
info	*(void)
->	O
indent	O
+=	O
2	int
;	O
if	O
(	O
!	O
push_type	O
(	O
info	*(void)
,	O
structp	O
?	O
"struct "	*(char)
:	O
"union "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
tag	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
tag	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
char	O
idbuf	O
[	O
20	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
idbuf	O
,	O
"%%anon%u"	*(char)
,	O
id	int
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
idbuf	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" {"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
size	int
!=	O
0	int
||	O
tag	O
!=	O
NULL	O
)	O
{	O
char	O
ab	O
[	O
30	int
]	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" /*"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
size	int
!=	O
0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
ab	O
,	O
" size %u"	*(char)
,	O
size	int
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
ab	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
tag	O
!=	O
NULL	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
ab	O
,	O
" id %u"	*(char)
,	O
id	int
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
ab	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" */"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"\n"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
stack	O
->	O
visibility	O
=	O
DEBUG_VISIBILITY_PUBLIC	O
;	O
return	O
indent_type	O
(	O
info	*(void)
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_fix_visibility	O
(	O
struct	O
pr_handle	O
*	O
info	*(void)
,	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
const	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
NULL	O
;	O
char	O
*	O
t	O
;	O
unsigned	O
int	O
len	long
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
info	*(void)
->	O
stack	O
->	O
visibility	O
==	O
visibility	O
)	O
return	O
TRUE	int
;	O
switch	O
(	O
visibility	O
)	O
{	O
case	O
DEBUG_VISIBILITY_PUBLIC	O
:	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
"public"	*(char)
;	O
break	O
;	O
case	O
DEBUG_VISIBILITY_PRIVATE	O
:	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
"private"	*(char)
;	O
break	O
;	O
case	O
DEBUG_VISIBILITY_PROTECTED	O
:	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
"protected"	*(char)
;	O
break	O
;	O
case	O
DEBUG_VISIBILITY_IGNORE	O
:	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
"/* ignore */"	*(char)
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
t	O
=	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
t	O
)	O
;	O
assert	O
(	O
t	O
[	O
len	long
-	O
1	int
]	O
==	O
' '	O
)	O
;	O
t	O
[	O
len	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
":\n"	*(char)
)	O
||	O
!	O
indent_type	O
(	O
info	*(void)
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
stack	O
->	O
visibility	O
=	O
visibility	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_struct_field	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
bfd_vma	long
bitpos	int
,	O
bfd_vma	long
bitsize	int
,	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
char	O
*	O
t	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"; /* "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
bitsize	int
!=	O
0	int
)	O
{	O
print_vma	O
(	O
bitsize	int
,	O
ab	O
,	O
TRUE	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"bitsize "	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
ab	O
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
", "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
print_vma	O
(	O
bitpos	int
,	O
ab	O
,	O
TRUE	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"bitpos "	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
ab	O
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
" */\n"	*(char)
)	O
||	O
!	O
indent_type	O
(	O
info	*(void)
)	O
)	O
return	O
FALSE	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
pr_fix_visibility	O
(	O
info	*(void)
,	O
visibility	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
append_type	O
(	O
info	*(void)
,	O
t	O
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_end_struct_type	O
(	O
void	O
*	O
p	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
assert	O
(	O
info	*(void)
->	O
indent	O
>=	O
2	int
)	O
;	O
info	*(void)
->	O
indent	O
-=	O
2	int
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
+	O
strlen	(*(char))->(long)
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
-	O
2	int
;	O
assert	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
[	O
0	int
]	O
==	O
' '	O
&&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
[	O
1	int
]	O
==	O
' '	O
&&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
[	O
2	int
]	O
==	O
'\0'	O
)	O
;	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
++	O
=	O
'}'	O
;	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
'\0'	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_start_class_type	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
tag	O
,	O
unsigned	O
int	O
id	int
,	O
bfd_boolean	int
structp	O
,	O
unsigned	O
int	O
size	int
,	O
bfd_boolean	int
vptr	O
,	O
bfd_boolean	int
ownvptr	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
tv	O
=	O
NULL	O
;	O
info	*(void)
->	O
indent	O
+=	O
2	int
;	O
if	O
(	O
vptr	O
&&	O
!	O
ownvptr	O
)	O
{	O
tv	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
tv	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
push_type	O
(	O
info	*(void)
,	O
structp	O
?	O
"class "	*(char)
:	O
"union class "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
tag	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
tag	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
char	O
idbuf	O
[	O
20	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
idbuf	O
,	O
"%%anon%u"	*(char)
,	O
id	int
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
idbuf	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" {"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
size	int
!=	O
0	int
||	O
vptr	O
||	O
ownvptr	O
||	O
tag	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" /*"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
size	int
!=	O
0	int
)	O
{	O
char	O
ab	O
[	O
20	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
ab	O
,	O
"%u"	*(char)
,	O
size	int
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" size "	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
ab	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
vptr	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" vtable "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
ownvptr	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"self "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
tv	O
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
" "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
tag	O
!=	O
NULL	O
)	O
{	O
char	O
ab	O
[	O
30	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
ab	O
,	O
" id %u"	*(char)
,	O
id	int
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
ab	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" */"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
info	*(void)
->	O
stack	O
->	O
visibility	O
=	O
DEBUG_VISIBILITY_PRIVATE	O
;	O
return	O
(	O
append_type	O
(	O
info	*(void)
,	O
"\n"	*(char)
)	O
&&	O
indent_type	O
(	O
info	*(void)
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_class_static_member	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
physname	O
,	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
prepend_type	O
(	O
info	*(void)
,	O
"static "	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
"; /* "	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
physname	O
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
" */\n"	*(char)
)	O
||	O
!	O
indent_type	O
(	O
info	*(void)
)	O
)	O
return	O
FALSE	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
pr_fix_visibility	O
(	O
info	*(void)
,	O
visibility	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
append_type	O
(	O
info	*(void)
,	O
t	O
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_class_baseclass	O
(	O
void	O
*	O
p	*(void)
,	O
bfd_vma	long
bitpos	int
,	O
bfd_boolean	int
is_virtual	O
,	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
const	O
char	O
*	O
prefix	O
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
*	O
l	O
,	O
*	O
n	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
&&	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
!=	O
NULL	O
)	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
""	*(char)
)	O
)	O
return	O
FALSE	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
t	O
,	O
"class "	*(char)
)	O
)	O
t	O
+=	O
sizeof	O
"class "	*(char)
-	O
1	int
;	O
if	O
(	O
!	O
push_type	O
(	O
info	*(void)
,	O
t	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
is_virtual	O
)	O
{	O
if	O
(	O
!	O
prepend_type	O
(	O
info	*(void)
,	O
"virtual "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
switch	O
(	O
visibility	O
)	O
{	O
case	O
DEBUG_VISIBILITY_PUBLIC	O
:	O
prefix	O
=	O
"public "	*(char)
;	O
break	O
;	O
case	O
DEBUG_VISIBILITY_PROTECTED	O
:	O
prefix	O
=	O
"protected "	*(char)
;	O
break	O
;	O
case	O
DEBUG_VISIBILITY_PRIVATE	O
:	O
prefix	O
=	O
"private "	*(char)
;	O
break	O
;	O
default	O
:	O
prefix	O
=	O
"/* unknown visibility */ "	*(char)
;	O
break	O
;	O
}	O
if	O
(	O
!	O
prepend_type	O
(	O
info	*(void)
,	O
prefix	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
bitpos	int
!=	O
0	int
)	O
{	O
print_vma	O
(	O
bitpos	int
,	O
ab	O
,	O
TRUE	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" /* bitpos "	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
ab	O
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
" */"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
strchr	(*(char),int)->(*(char))
(	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
type	enum(int,int,int,int)
,	O
'{'	O
)	O
;	O
assert	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
!=	O
NULL	O
)	O
;	O
--	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
for	O
(	O
l	O
=	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
type	enum(int,int,int,int)
;	O
l	O
!=	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
l	O
++	O
)	O
if	O
(	O
*	O
l	O
==	O
':'	O
)	O
break	O
;	O
if	O
(	O
!	O
prepend_type	O
(	O
info	*(void)
,	O
l	O
==	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
?	O
" : "	*(char)
:	O
", "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
n	O
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
strlen	(*(char))->(long)
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
+	O
strlen	(*(char))->(long)
(	O
t	O
)	O
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
n	O
,	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
-	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
n	O
+	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
-	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
,	O
t	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
n	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
free	(*(void))->(void)
(	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
;	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
=	O
n	O
;	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_class_start_method	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
info	*(void)
->	O
stack	O
->	O
method	O
=	O
name	*(char)
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_class_method_variant	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
physname	O
,	O
enum	O
debug_visibility	O
visibility	O
,	O
bfd_boolean	int
constp	O
,	O
bfd_boolean	int
volatilep	O
,	O
bfd_vma	long
voffset	O
,	O
bfd_boolean	int
context	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
method_type	O
;	O
char	O
*	O
context_type	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
!=	O
NULL	O
)	O
;	O
if	O
(	O
volatilep	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" volatile"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
constp	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" const"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
(	O
context	O
?	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
method	O
:	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
method	O
)	O
)	O
)	O
return	O
FALSE	O
;	O
method_type	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
method_type	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
context	O
)	O
context_type	O
=	O
NULL	O
;	O
else	O
{	O
context_type	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
context_type	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
pr_fix_visibility	O
(	O
info	*(void)
,	O
visibility	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
method_type	O
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
" /* "	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
physname	O
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
" "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
context	O
||	O
voffset	O
!=	O
0	int
)	O
{	O
char	O
ab	O
[	O
22	int
]	O
;	O
if	O
(	O
context	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"context "	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
context_type	O
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
" "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
print_vma	O
(	O
voffset	O
,	O
ab	O
,	O
TRUE	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"voffset "	*(char)
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
ab	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
(	O
append_type	O
(	O
info	*(void)
,	O
" */;\n"	*(char)
)	O
&&	O
indent_type	O
(	O
info	*(void)
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_class_static_method_variant	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
physname	O
,	O
enum	O
debug_visibility	O
visibility	O
,	O
bfd_boolean	int
constp	O
,	O
bfd_boolean	int
volatilep	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
method_type	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
!=	O
NULL	O
)	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
method	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
volatilep	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" volatile"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
constp	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" const"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
prepend_type	O
(	O
info	*(void)
,	O
"static "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
method	O
)	O
)	O
return	O
FALSE	O
;	O
method_type	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
method_type	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
pr_fix_visibility	O
(	O
info	*(void)
,	O
visibility	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
(	O
append_type	O
(	O
info	*(void)
,	O
method_type	O
)	O
&&	O
append_type	O
(	O
info	*(void)
,	O
" /* "	*(char)
)	O
&&	O
append_type	O
(	O
info	*(void)
,	O
physname	O
)	O
&&	O
append_type	O
(	O
info	*(void)
,	O
" */;\n"	*(char)
)	O
&&	O
indent_type	O
(	O
info	*(void)
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_class_end_method	O
(	O
void	O
*	O
p	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
info	*(void)
->	O
stack	O
->	O
method	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_end_class_type	O
(	O
void	O
*	O
p	*(void)
)	O
{	O
return	O
pr_end_struct_type	O
(	O
p	*(void)
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_typedef_type	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
return	O
push_type	O
(	O
info	*(void)
,	O
name	*(char)
)	O
;	O
}	O
static	O
bfd_boolean	int
pr_tag_type	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
unsigned	O
int	O
id	int
,	O
enum	O
debug_type_kind	O
kind	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
const	O
char	O
*	O
t	O
,	O
*	O
tag	O
;	O
char	O
idbuf	O
[	O
22	int
]	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
DEBUG_KIND_STRUCT	O
:	O
t	O
=	O
"struct "	*(char)
;	O
break	O
;	O
case	O
DEBUG_KIND_UNION	O
:	O
t	O
=	O
"union "	*(char)
;	O
break	O
;	O
case	O
DEBUG_KIND_ENUM	O
:	O
t	O
=	O
"enum "	*(char)
;	O
break	O
;	O
case	O
DEBUG_KIND_CLASS	O
:	O
t	O
=	O
"class "	*(char)
;	O
break	O
;	O
case	O
DEBUG_KIND_UNION_CLASS	O
:	O
t	O
=	O
"union class "	*(char)
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
push_type	O
(	O
info	*(void)
,	O
t	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
tag	O
=	O
name	*(char)
;	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
idbuf	O
,	O
"%%anon%u"	*(char)
,	O
id	int
)	O
;	O
tag	O
=	O
idbuf	O
;	O
}	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
tag	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
&&	O
kind	O
!=	O
DEBUG_KIND_ENUM	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
idbuf	O
,	O
" /* id %u */"	*(char)
,	O
id	int
)	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
idbuf	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_typdef	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
indent	O
(	O
info	*(void)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"typedef %s;\n"	*(char)
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
free	(*(void))->(void)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_tag	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
indent	O
(	O
info	*(void)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s;\n"	*(char)
,	O
t	O
)	O
;	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_int_constant	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
bfd_vma	long
val	array(int)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
indent	O
(	O
info	*(void)
)	O
;	O
print_vma	O
(	O
val	array(int)
,	O
ab	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"const int %s = %s;\n"	*(char)
,	O
name	*(char)
,	O
ab	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_float_constant	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
double	O
val	array(int)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
indent	O
(	O
info	*(void)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"const double %s = %g;\n"	*(char)
,	O
name	*(char)
,	O
val	array(int)
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_typed_constant	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
bfd_vma	long
val	array(int)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
indent	O
(	O
info	*(void)
)	O
;	O
print_vma	O
(	O
val	array(int)
,	O
ab	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"const %s %s = %s;\n"	*(char)
,	O
t	O
,	O
name	*(char)
,	O
ab	O
)	O
;	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_variable	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
enum	O
debug_var_kind	O
kind	O
,	O
bfd_vma	long
val	array(int)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
indent	O
(	O
info	*(void)
)	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
DEBUG_STATIC	O
:	O
case	O
DEBUG_LOCAL_STATIC	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"static "	*(char)
)	O
;	O
break	O
;	O
case	O
DEBUG_REGISTER	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"register "	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
print_vma	O
(	O
val	array(int)
,	O
ab	O
,	O
TRUE	int
,	O
TRUE	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s /* %s */;\n"	*(char)
,	O
t	O
,	O
ab	O
)	O
;	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_start_function	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
bfd_boolean	int
global	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
indent	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
!	O
global	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"static "	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s ("	*(char)
,	O
t	O
)	O
;	O
info	*(void)
->	O
parameter	O
=	O
1	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_function_parameter	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
enum	O
debug_parm_kind	O
kind	O
,	O
bfd_vma	long
val	array(int)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
if	O
(	O
kind	O
==	O
DEBUG_PARM_REFERENCE	O
||	O
kind	O
==	O
DEBUG_PARM_REF_REG	O
)	O
{	O
if	O
(	O
!	O
pr_reference_type	O
(	O
p	*(void)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
info	*(void)
->	O
parameter	O
!=	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
", "	*(char)
)	O
;	O
if	O
(	O
kind	O
==	O
DEBUG_PARM_REG	O
||	O
kind	O
==	O
DEBUG_PARM_REF_REG	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"register "	*(char)
)	O
;	O
print_vma	O
(	O
val	array(int)
,	O
ab	O
,	O
TRUE	int
,	O
TRUE	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s /* %s */"	*(char)
,	O
t	O
,	O
ab	O
)	O
;	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
++	O
info	*(void)
->	O
parameter	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_start_block	O
(	O
void	O
*	O
p	*(void)
,	O
bfd_vma	long
addr	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
if	O
(	O
info	*(void)
->	O
parameter	O
>	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
")\n"	*(char)
)	O
;	O
info	*(void)
->	O
parameter	O
=	O
0	int
;	O
}	O
indent	O
(	O
info	*(void)
)	O
;	O
print_vma	O
(	O
addr	*(void)
,	O
ab	O
,	O
TRUE	int
,	O
TRUE	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"{ /* %s */\n"	*(char)
,	O
ab	O
)	O
;	O
info	*(void)
->	O
indent	O
+=	O
2	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_lineno	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
filename	*(char)
,	O
unsigned	O
long	O
lineno	*(struct(int,union(*(struct),long)))
,	O
bfd_vma	long
addr	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
indent	O
(	O
info	*(void)
)	O
;	O
print_vma	O
(	O
addr	*(void)
,	O
ab	O
,	O
TRUE	int
,	O
TRUE	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"/* file %s line %lu addr %s */\n"	*(char)
,	O
filename	*(char)
,	O
lineno	*(struct(int,union(*(struct),long)))
,	O
ab	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_end_block	O
(	O
void	O
*	O
p	*(void)
,	O
bfd_vma	long
addr	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
info	*(void)
->	O
indent	O
-=	O
2	int
;	O
indent	O
(	O
info	*(void)
)	O
;	O
print_vma	O
(	O
addr	*(void)
,	O
ab	O
,	O
TRUE	int
,	O
TRUE	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"} /* %s */\n"	*(char)
,	O
ab	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
pr_end_function	O
(	O
void	O
*	O
p	*(void)
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_vma	long
pc	O
;	O
static	O
const	O
char	O
*	O
filename	*(char)
;	O
static	O
const	O
char	O
*	O
functionname	O
;	O
static	O
unsigned	O
int	O
line	O
;	O
static	O
bfd_boolean	int
found	O
;	O
static	O
void	O
find_address_in_section	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
asection	struct(*(char),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*(struct`),long))),int,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))),union(*(struct),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`)))))
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
void	O
*	O
data	*(void)
)	O
{	O
bfd_vma	long
vma	long
;	O
bfd_size_type	long
size	int
;	O
asymbol	struct(*(struct),*(char),long,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct(*`,long,long,*`)),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct(struct`,*`)),*(struct),*(struct(*`,*`,long,int,*`,union`)),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),union(*(void),long))
*	O
*	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
=	O
(	O
asymbol	struct(*(struct),*(char),long,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct(*`,long,long,*`)),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct(struct`,*`)),*(struct),*(struct(*`,*`,long,int,*`,union`)),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),union(*(void),long))
*	O
*	O
)	O
data	*(void)
;	O
if	O
(	O
found	O
)	O
return	O
;	O
if	O
(	O
(	O
bfd_section_flags	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))->(int)
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
&	O
SEC_ALLOC	O
)	O
==	O
0	int
)	O
return	O
;	O
vma	long
=	O
bfd_section_vma	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))->(long)
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
if	O
(	O
pc	O
<	O
vma	long
)	O
return	O
;	O
size	int
=	O
bfd_section_size	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))->(long)
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
if	O
(	O
pc	O
>=	O
vma	long
+	O
size	int
)	O
return	O
;	O
found	O
=	O
bfd_find_nearest_line	O
(	O
abfd	*(struct)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
,	O
pc	O
-	O
vma	long
,	O
&	O
filename	*(char)
,	O
&	O
functionname	O
,	O
&	O
line	O
)	O
;	O
}	O
static	O
void	O
translate_addresses	O
(	O
bfd	struct
*	O
abfd	*(struct)
,	O
char	O
*	O
addr_hex	O
,	O
FILE	struct
*	O
f	O
,	O
asymbol	struct(*(struct),*(char),long,int,*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct(*`,long,long,*`)),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct(struct`,*`)),*(struct),*(struct(*`,*`,long,int,*`,union`)),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),union(*(void),long))
*	O
*	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
)	O
{	O
pc	O
=	O
bfd_scan_vma	(*(char),*(*(char)),int)->(long)
(	O
addr_hex	O
,	O
NULL	O
,	O
16	int
)	O
;	O
found	O
=	O
FALSE	O
;	O
bfd_map_over_sections	(*(struct),*((*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(void))->(void)),*(void))->(void)
(	O
abfd	*(struct)
,	O
find_address_in_section	O
,	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
)	O
;	O
if	O
(	O
!	O
found	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	O
,	O
"??"	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	O
,	O
"%u"	*(char)
,	O
line	O
)	O
;	O
}	O
static	O
bfd_boolean	int
tg_start_compilation_unit	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
fname	O
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
free	(*(void))->(void)
(	O
info	*(void)
->	O
filename	*(char)
)	O
;	O
info	*(void)
->	O
filename	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
fname	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_start_source	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
fname	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
free	(*(void))->(void)
(	O
info	*(void)
->	O
filename	*(char)
)	O
;	O
info	*(void)
->	O
filename	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
fname	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_enum_type	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
tag	O
,	O
const	O
char	O
*	O
*	O
names	O
,	O
bfd_signed_vma	long
*	O
values	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
unsigned	O
int	O
i	*(struct)
;	O
const	O
char	O
*	O
name	*(char)
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
if	O
(	O
!	O
pr_enum_type	O
(	O
p	*(void)
,	O
tag	O
,	O
names	O
,	O
values	O
)	O
)	O
return	O
FALSE	O
;	O
name	*(char)
=	O
tag	O
?	O
tag	O
:	O
"unknown"	*(char)
;	O
if	O
(	O
tag	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:e\ttype:%s\n"	*(char)
,	O
tag	O
,	O
info	*(void)
->	O
filename	*(char)
,	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
names	O
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
names	O
[	O
i	*(struct)
]	O
!=	O
NULL	O
;	O
i	*(struct)
++	O
)	O
{	O
print_vma	O
(	O
values	O
[	O
i	*(struct)
]	O
,	O
ab	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:g\tenum:%s\tvalue:%s\n"	*(char)
,	O
names	O
[	O
i	*(struct)
]	O
,	O
info	*(void)
->	O
filename	*(char)
,	O
name	*(char)
,	O
ab	O
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_start_struct_type	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
tag	O
,	O
unsigned	O
int	O
id	int
,	O
bfd_boolean	int
structp	O
,	O
unsigned	O
int	O
size	int
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
const	O
char	O
*	O
name	*(char)
;	O
char	O
idbuf	O
[	O
20	int
]	O
;	O
if	O
(	O
tag	O
!=	O
NULL	O
)	O
name	*(char)
=	O
tag	O
;	O
else	O
{	O
name	*(char)
=	O
idbuf	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
idbuf	O
,	O
"%%anon%u"	*(char)
,	O
id	int
)	O
;	O
}	O
if	O
(	O
!	O
push_type	O
(	O
info	*(void)
,	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
stack	O
->	O
flavor	O
=	O
structp	O
?	O
"struct"	*(char)
:	O
"union"	*(char)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:%c\n"	*(char)
,	O
name	*(char)
,	O
info	*(void)
->	O
filename	*(char)
,	O
info	*(void)
->	O
stack	O
->	O
flavor	O
[	O
0	int
]	O
)	O
;	O
info	*(void)
->	O
stack	O
->	O
visibility	O
=	O
DEBUG_VISIBILITY_PUBLIC	O
;	O
return	O
indent_type	O
(	O
info	*(void)
)	O
;	O
}	O
static	O
bfd_boolean	int
tg_fix_visibility	O
(	O
struct	O
pr_handle	O
*	O
info	*(void)
,	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
info	*(void)
->	O
stack	O
->	O
visibility	O
==	O
visibility	O
)	O
return	O
TRUE	int
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
->	O
visibility	O
!=	O
DEBUG_VISIBILITY_IGNORE	O
)	O
;	O
info	*(void)
->	O
stack	O
->	O
visibility	O
=	O
visibility	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_struct_field	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
bfd_vma	long
bitpos	int
ATTRIBUTE_UNUSED	O
,	O
bfd_vma	long
bitsize	int
ATTRIBUTE_UNUSED	O
,	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
tg_fix_visibility	O
(	O
info	*(void)
,	O
visibility	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
name	*(char)
[	O
0	int
]	O
)	O
return	O
TRUE	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:m\ttype:%s\t%s:%s\taccess:%s\n"	*(char)
,	O
name	*(char)
,	O
info	*(void)
->	O
filename	*(char)
,	O
t	O
,	O
info	*(void)
->	O
stack	O
->	O
flavor	O
,	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
,	O
visibility_name	O
(	O
visibility	O
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_end_struct_type	O
(	O
void	O
*	O
p	*(void)
ATTRIBUTE_UNUSED	O
)	O
{	O
assert	O
(	O
(	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
)	O
->	O
stack	O
!=	O
NULL	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_start_class_type	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
tag	O
,	O
unsigned	O
int	O
id	int
,	O
bfd_boolean	int
structp	O
,	O
unsigned	O
int	O
size	int
,	O
bfd_boolean	int
vptr	O
,	O
bfd_boolean	int
ownvptr	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
tv	O
=	O
NULL	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
char	O
idbuf	O
[	O
20	int
]	O
;	O
info	*(void)
->	O
indent	O
+=	O
2	int
;	O
if	O
(	O
vptr	O
&&	O
!	O
ownvptr	O
)	O
{	O
tv	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
tv	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
tag	O
!=	O
NULL	O
)	O
name	*(char)
=	O
tag	O
;	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
idbuf	O
,	O
"%%anon%u"	*(char)
,	O
id	int
)	O
;	O
name	*(char)
=	O
idbuf	O
;	O
}	O
if	O
(	O
!	O
push_type	O
(	O
info	*(void)
,	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
stack	O
->	O
flavor	O
=	O
structp	O
?	O
"class"	*(char)
:	O
"union class"	*(char)
;	O
info	*(void)
->	O
stack	O
->	O
parents	O
=	O
NULL	O
;	O
info	*(void)
->	O
stack	O
->	O
num_parents	O
=	O
0	int
;	O
if	O
(	O
size	int
!=	O
0	int
||	O
vptr	O
||	O
ownvptr	O
||	O
tag	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
vptr	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" vtable "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
ownvptr	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"self "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
tv	O
)	O
||	O
!	O
append_type	O
(	O
info	*(void)
,	O
" "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
}	O
info	*(void)
->	O
stack	O
->	O
visibility	O
=	O
DEBUG_VISIBILITY_PRIVATE	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_class_static_member	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
physname	O
ATTRIBUTE_UNUSED	O
,	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
int	O
len_var	O
,	O
len_class	O
;	O
char	O
*	O
full_name	O
;	O
len_var	O
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
len_class	O
=	O
strlen	(*(char))->(long)
(	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
type	enum(int,int,int,int)
)	O
;	O
full_name	O
=	O
(	O
char	O
*	O
)	O
xmalloc	O
(	O
len_var	O
+	O
len_class	O
+	O
3	int
)	O
;	O
if	O
(	O
!	O
full_name	O
)	O
return	O
FALSE	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
full_name	O
,	O
"%s::%s"	*(char)
,	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
type	enum(int,int,int,int)
,	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
full_name	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
full_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
prepend_type	O
(	O
info	*(void)
,	O
"static "	*(char)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
full_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
full_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
tg_fix_visibility	O
(	O
info	*(void)
,	O
visibility	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
free	(*(void))->(void)
(	O
full_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:x\ttype:%s\tclass:%s\taccess:%s\n"	*(char)
,	O
name	*(char)
,	O
info	*(void)
->	O
filename	*(char)
,	O
t	O
,	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
,	O
visibility_name	O
(	O
visibility	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
free	(*(void))->(void)
(	O
full_name	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_class_baseclass	O
(	O
void	O
*	O
p	*(void)
,	O
bfd_vma	long
bitpos	int
ATTRIBUTE_UNUSED	O
,	O
bfd_boolean	int
is_virtual	O
,	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
const	O
char	O
*	O
prefix	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
&&	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
!=	O
NULL	O
)	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
CONST_STRNEQ	O
(	O
t	O
,	O
"class "	*(char)
)	O
)	O
t	O
+=	O
sizeof	O
"class "	*(char)
-	O
1	int
;	O
if	O
(	O
!	O
push_type	O
(	O
info	*(void)
,	O
t	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
is_virtual	O
)	O
{	O
if	O
(	O
!	O
prepend_type	O
(	O
info	*(void)
,	O
"virtual "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
switch	O
(	O
visibility	O
)	O
{	O
case	O
DEBUG_VISIBILITY_PUBLIC	O
:	O
prefix	O
=	O
"public "	*(char)
;	O
break	O
;	O
case	O
DEBUG_VISIBILITY_PROTECTED	O
:	O
prefix	O
=	O
"protected "	*(char)
;	O
break	O
;	O
case	O
DEBUG_VISIBILITY_PRIVATE	O
:	O
prefix	O
=	O
"private "	*(char)
;	O
break	O
;	O
default	O
:	O
prefix	O
=	O
"/* unknown visibility */ "	*(char)
;	O
break	O
;	O
}	O
if	O
(	O
!	O
prepend_type	O
(	O
info	*(void)
,	O
prefix	O
)	O
)	O
return	O
FALSE	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
info	*(void)
->	O
stack	O
->	O
num_parents	O
&&	O
!	O
append_parent	O
(	O
info	*(void)
,	O
", "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
append_parent	O
(	O
info	*(void)
,	O
t	O
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
stack	O
->	O
num_parents	O
++	O
;	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_class_method_variant	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
physname	O
ATTRIBUTE_UNUSED	O
,	O
enum	O
debug_visibility	O
visibility	O
,	O
bfd_boolean	int
constp	O
,	O
bfd_boolean	int
volatilep	O
,	O
bfd_vma	long
voffset	O
ATTRIBUTE_UNUSED	O
,	O
bfd_boolean	int
context	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
method_type	O
;	O
char	O
*	O
context_type	O
;	O
char	O
*	O
method_name	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
!=	O
NULL	O
)	O
;	O
if	O
(	O
volatilep	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" volatile"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
constp	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" const"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
method_name	O
=	O
strdup	(*(char))->(*(char))
(	O
context	O
?	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
method	O
:	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
method	O
)	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
method_name	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
method_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
method_type	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
method_type	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
method_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
context	O
)	O
context_type	O
=	O
NULL	O
;	O
else	O
{	O
context_type	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
context_type	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
method_type	O
)	O
;	O
free	(*(void))->(void)
(	O
method_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
!	O
tg_fix_visibility	O
(	O
info	*(void)
,	O
visibility	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
method_type	O
)	O
;	O
free	(*(void))->(void)
(	O
method_name	O
)	O
;	O
free	(*(void))->(void)
(	O
context_type	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:p\ttype:%s\tclass:%s\n"	*(char)
,	O
method_name	O
,	O
info	*(void)
->	O
filename	*(char)
,	O
method_type	O
,	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
)	O
;	O
free	(*(void))->(void)
(	O
method_type	O
)	O
;	O
free	(*(void))->(void)
(	O
method_name	O
)	O
;	O
free	(*(void))->(void)
(	O
context_type	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_class_static_method_variant	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
physname	O
ATTRIBUTE_UNUSED	O
,	O
enum	O
debug_visibility	O
visibility	O
,	O
bfd_boolean	int
constp	O
,	O
bfd_boolean	int
volatilep	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
method_type	O
;	O
char	O
*	O
method_name	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
!=	O
NULL	O
)	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
!=	O
NULL	O
)	O
;	O
assert	O
(	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
method	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
volatilep	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" volatile"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
constp	O
)	O
{	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
" const"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
prepend_type	O
(	O
info	*(void)
,	O
"static "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
method_name	O
=	O
strdup	(*(char))->(*(char))
(	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
method	O
)	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
info	*(void)
->	O
stack	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
->	O
method	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
method_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
method_type	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
method_type	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
method_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
tg_fix_visibility	O
(	O
info	*(void)
,	O
visibility	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
method_type	O
)	O
;	O
free	(*(void))->(void)
(	O
method_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:p\ttype:%s\tclass:%s\taccess:%s\n"	*(char)
,	O
method_name	O
,	O
info	*(void)
->	O
filename	*(char)
,	O
method_type	O
,	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
,	O
visibility_name	O
(	O
visibility	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
method_type	O
)	O
;	O
free	(*(void))->(void)
(	O
method_name	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_end_class_type	O
(	O
void	O
*	O
p	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:c\ttype:%s"	*(char)
,	O
info	*(void)
->	O
stack	O
->	O
type	enum(int,int,int,int)
,	O
info	*(void)
->	O
filename	*(char)
,	O
info	*(void)
->	O
stack	O
->	O
flavor	O
)	O
;	O
if	O
(	O
info	*(void)
->	O
stack	O
->	O
num_parents	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"\tinherits:%s"	*(char)
,	O
info	*(void)
->	O
stack	O
->	O
parents	O
)	O
;	O
free	(*(void))->(void)
(	O
info	*(void)
->	O
stack	O
->	O
parents	O
)	O
;	O
}	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
info	*(void)
->	O
f	O
)	O
;	O
return	O
tg_end_struct_type	O
(	O
p	*(void)
)	O
;	O
}	O
static	O
bfd_boolean	int
tg_tag_type	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
unsigned	O
int	O
id	int
,	O
enum	O
debug_type_kind	O
kind	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
const	O
char	O
*	O
t	O
,	O
*	O
tag	O
;	O
char	O
idbuf	O
[	O
20	int
]	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
DEBUG_KIND_STRUCT	O
:	O
t	O
=	O
"struct "	*(char)
;	O
break	O
;	O
case	O
DEBUG_KIND_UNION	O
:	O
t	O
=	O
"union "	*(char)
;	O
break	O
;	O
case	O
DEBUG_KIND_ENUM	O
:	O
t	O
=	O
"enum "	*(char)
;	O
break	O
;	O
case	O
DEBUG_KIND_CLASS	O
:	O
t	O
=	O
"class "	*(char)
;	O
break	O
;	O
case	O
DEBUG_KIND_UNION_CLASS	O
:	O
t	O
=	O
"union class "	*(char)
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
push_type	O
(	O
info	*(void)
,	O
t	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
tag	O
=	O
name	*(char)
;	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
idbuf	O
,	O
"%%anon%u"	*(char)
,	O
id	int
)	O
;	O
tag	O
=	O
idbuf	O
;	O
}	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
tag	O
)	O
)	O
return	O
FALSE	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_typdef	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:t\ttype:%s\n"	*(char)
,	O
name	*(char)
,	O
info	*(void)
->	O
filename	*(char)
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
free	(*(void))->(void)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_tag	O
(	O
void	O
*	O
p	*(void)
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	*(char)
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_int_constant	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
bfd_vma	long
val	array(int)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
indent	O
(	O
info	*(void)
)	O
;	O
print_vma	O
(	O
val	array(int)
,	O
ab	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:v\ttype:const int\tvalue:%s\n"	*(char)
,	O
name	*(char)
,	O
info	*(void)
->	O
filename	*(char)
,	O
ab	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_float_constant	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
double	O
val	array(int)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
indent	O
(	O
info	*(void)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:v\ttype:const double\tvalue:%g\n"	*(char)
,	O
name	*(char)
,	O
info	*(void)
->	O
filename	*(char)
,	O
val	array(int)
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_typed_constant	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
bfd_vma	long
val	array(int)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
char	O
ab	O
[	O
22	int
]	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
indent	O
(	O
info	*(void)
)	O
;	O
print_vma	O
(	O
val	array(int)
,	O
ab	O
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:v\ttype:const %s\tvalue:%s\n"	*(char)
,	O
name	*(char)
,	O
info	*(void)
->	O
filename	*(char)
,	O
t	O
,	O
ab	O
)	O
;	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_variable	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
enum	O
debug_var_kind	O
kind	O
,	O
bfd_vma	long
val	array(int)
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
,	O
*	O
dname	O
,	O
*	O
from_class	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
dname	O
=	O
NULL	O
;	O
if	O
(	O
info	*(void)
->	O
demangler	O
)	O
dname	O
=	O
info	*(void)
->	O
demangler	O
(	O
info	*(void)
->	O
abfd	*(struct)
,	O
name	*(char)
,	O
demangle_flags	O
)	O
;	O
from_class	O
=	O
NULL	O
;	O
if	O
(	O
dname	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
sep	O
;	O
sep	O
=	O
strstr	(*(char),*(char))->(*(char))
(	O
dname	O
,	O
"::"	*(char)
)	O
;	O
if	O
(	O
sep	O
)	O
{	O
*	O
sep	O
=	O
0	int
;	O
name	*(char)
=	O
sep	O
+	O
2	int
;	O
from_class	O
=	O
dname	O
;	O
}	O
else	O
name	*(char)
=	O
dname	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t0;\"\tkind:v\ttype:%s"	*(char)
,	O
name	*(char)
,	O
info	*(void)
->	O
filename	*(char)
,	O
t	O
)	O
;	O
switch	O
(	O
kind	O
)	O
{	O
case	O
DEBUG_STATIC	O
:	O
case	O
DEBUG_LOCAL_STATIC	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"\tfile:"	*(char)
)	O
;	O
break	O
;	O
case	O
DEBUG_REGISTER	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"\tregister:"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
from_class	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"\tclass:%s"	*(char)
,	O
from_class	O
)	O
;	O
if	O
(	O
dname	O
)	O
free	(*(void))->(void)
(	O
dname	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"\n"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_start_function	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
bfd_boolean	int
global	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
dname	O
;	O
if	O
(	O
!	O
global	O
)	O
info	*(void)
->	O
stack	O
->	O
flavor	O
=	O
"static"	*(char)
;	O
else	O
info	*(void)
->	O
stack	O
->	O
flavor	O
=	O
NULL	O
;	O
dname	O
=	O
NULL	O
;	O
if	O
(	O
info	*(void)
->	O
demangler	O
)	O
dname	O
=	O
info	*(void)
->	O
demangler	O
(	O
info	*(void)
->	O
abfd	*(struct)
,	O
name	*(char)
,	O
demangle_flags	O
)	O
;	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
dname	O
?	O
dname	O
:	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
stack	O
->	O
method	O
=	O
NULL	O
;	O
if	O
(	O
dname	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
sep	O
;	O
sep	O
=	O
strstr	(*(char),*(char))->(*(char))
(	O
dname	O
,	O
"::"	*(char)
)	O
;	O
if	O
(	O
sep	O
)	O
{	O
info	*(void)
->	O
stack	O
->	O
method	O
=	O
dname	O
;	O
*	O
sep	O
=	O
0	int
;	O
name	*(char)
=	O
sep	O
+	O
2	int
;	O
}	O
else	O
{	O
info	*(void)
->	O
stack	O
->	O
method	O
=	O
""	*(char)
;	O
name	*(char)
=	O
dname	O
;	O
}	O
sep	O
=	O
strchr	(*(char),int)->(*(char))
(	O
name	*(char)
,	O
'('	O
)	O
;	O
if	O
(	O
sep	O
)	O
*	O
sep	O
=	O
0	int
;	O
}	O
info	*(void)
->	O
stack	O
->	O
parents	O
=	O
strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
info	*(void)
->	O
stack	O
->	O
method	O
&&	O
!	O
append_type	O
(	O
info	*(void)
,	O
"("	*(char)
)	O
)	O
return	O
FALSE	O
;	O
info	*(void)
->	O
parameter	O
=	O
1	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_function_parameter	O
(	O
void	O
*	O
p	*(void)
,	O
const	O
char	O
*	O
name	*(char)
,	O
enum	O
debug_parm_kind	O
kind	O
,	O
bfd_vma	long
val	array(int)
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
*	O
t	O
;	O
if	O
(	O
kind	O
==	O
DEBUG_PARM_REFERENCE	O
||	O
kind	O
==	O
DEBUG_PARM_REF_REG	O
)	O
{	O
if	O
(	O
!	O
pr_reference_type	O
(	O
p	*(void)
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
substitute_type	O
(	O
info	*(void)
,	O
name	*(char)
)	O
)	O
return	O
FALSE	O
;	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
info	*(void)
->	O
stack	O
->	O
method	O
)	O
{	O
if	O
(	O
info	*(void)
->	O
parameter	O
!=	O
1	int
&&	O
!	O
append_type	O
(	O
info	*(void)
,	O
", "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
kind	O
==	O
DEBUG_PARM_REG	O
||	O
kind	O
==	O
DEBUG_PARM_REF_REG	O
)	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
"register "	*(char)
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
append_type	O
(	O
info	*(void)
,	O
t	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
free	(*(void))->(void)
(	O
t	O
)	O
;	O
++	O
info	*(void)
->	O
parameter	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_start_block	O
(	O
void	O
*	O
p	*(void)
,	O
bfd_vma	long
addr	*(void)
)	O
{	O
struct	O
pr_handle	O
*	O
info	*(void)
=	O
(	O
struct	O
pr_handle	O
*	O
)	O
p	*(void)
;	O
char	O
ab	O
[	O
22	int
]	O
,	O
kind	O
,	O
*	O
partof	O
;	O
char	O
*	O
t	O
;	O
bfd_boolean	int
local	O
;	O
if	O
(	O
info	*(void)
->	O
parameter	O
>	O
0	int
)	O
{	O
info	*(void)
->	O
parameter	O
=	O
0	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"%s\t%s\t"	*(char)
,	O
info	*(void)
->	O
stack	O
->	O
parents	O
,	O
info	*(void)
->	O
filename	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
info	*(void)
->	O
stack	O
->	O
parents	O
)	O
;	O
print_vma	O
(	O
addr	*(void)
,	O
ab	O
,	O
TRUE	int
,	O
TRUE	int
)	O
;	O
translate_addresses	O
(	O
info	*(void)
->	O
abfd	*(struct)
,	O
ab	O
,	O
info	*(void)
->	O
f	O
,	O
info	*(void)
->	O
syms	*(*(struct(*(struct(*`,*`,*`,*`,*`,*`,long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*`,long,long,struct`,*`,*`,int,int,long,*`,int,int,*`,*`,*`,*`,*`,*`,union`,union`,*`,*`,*`)),*(char),long,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),union(*(void),long))))
)	O
;	O
local	O
=	O
info	*(void)
->	O
stack	O
->	O
flavor	O
!=	O
NULL	O
;	O
if	O
(	O
info	*(void)
->	O
stack	O
->	O
method	O
&&	O
*	O
info	*(void)
->	O
stack	O
->	O
method	O
)	O
{	O
kind	O
=	O
'm'	O
;	O
partof	O
=	O
(	O
char	O
*	O
)	O
info	*(void)
->	O
stack	O
->	O
method	O
;	O
}	O
else	O
{	O
kind	O
=	O
'f'	O
;	O
partof	O
=	O
NULL	O
;	O
if	O
(	O
!	O
info	*(void)
->	O
stack	O
->	O
method	O
&&	O
!	O
append_type	O
(	O
info	*(void)
,	O
")"	*(char)
)	O
)	O
return	O
FALSE	O
;	O
}	O
t	O
=	O
pop_type	O
(	O
info	*(void)
)	O
;	O
if	O
(	O
t	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
";\"\tkind:%c\ttype:%s"	*(char)
,	O
kind	O
,	O
t	O
)	O
;	O
if	O
(	O
local	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\tfile:"	*(char)
,	O
info	*(void)
->	O
f	O
)	O
;	O
if	O
(	O
partof	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
info	*(void)
->	O
f	O
,	O
"\tclass:%s"	*(char)
,	O
partof	O
)	O
;	O
free	(*(void))->(void)
(	O
partof	O
)	O
;	O
}	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
info	*(void)
->	O
f	O
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_lineno	O
(	O
void	O
*	O
p	*(void)
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
fname	O
ATTRIBUTE_UNUSED	O
,	O
unsigned	O
long	O
lineno	*(struct(int,union(*(struct),long)))
ATTRIBUTE_UNUSED	O
,	O
bfd_vma	long
addr	*(void)
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
tg_end_block	O
(	O
void	O
*	O
p	*(void)
ATTRIBUTE_UNUSED	O
,	O
bfd_vma	long
addr	*(void)
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
visibility_name	O
(	O
enum	O
debug_visibility	O
visibility	O
)	O
{	O
const	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
switch	O
(	O
visibility	O
)	O
{	O
case	O
DEBUG_VISIBILITY_PUBLIC	O
:	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
"public"	*(char)
;	O
break	O
;	O
case	O
DEBUG_VISIBILITY_PRIVATE	O
:	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
"private"	*(char)
;	O
break	O
;	O
case	O
DEBUG_VISIBILITY_PROTECTED	O
:	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
"protected"	*(char)
;	O
break	O
;	O
case	O
DEBUG_VISIBILITY_IGNORE	O
:	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
"/* ignore */"	*(char)
;	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
return	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
}	O
