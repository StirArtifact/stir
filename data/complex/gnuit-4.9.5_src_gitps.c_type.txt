static	O
char	O
*	O
PSFields	array(*(char))
[	O
PS_FIELDS	int
]	O
=	O
{	O
"TitleForeground"	*(char)
,	O
"TitleBackground"	*(char)
,	O
"TitleBrightness"	*(char)
,	O
"HeaderForeground"	*(char)
,	O
"HeaderBackground"	*(char)
,	O
"HeaderBrightness"	*(char)
,	O
"ScreenForeground"	*(char)
,	O
"ScreenBackground"	*(char)
,	O
"ScreenBrightness"	*(char)
,	O
"StatusForeground"	*(char)
,	O
"StatusBackground"	*(char)
,	O
"StatusBrightness"	*(char)
}	O
;	O
static	O
int	O
PSColors	array(int)
[	O
PS_FIELDS	int
]	O
=	O
{	O
CYAN	int
,	O
BLUE	int
,	O
ON	int
,	O
CYAN	int
,	O
RED	int
,	O
ON	int
,	O
BLACK	int
,	O
CYAN	int
,	O
OFF	int
,	O
CYAN	int
,	O
BLUE	int
,	O
ON	int
}	O
;	O
extern	O
int	O
LinuxConsole	int
;	O
int	O
AnsiColors	int
=	O
ON	int
;	O
char	O
color_section	array(char)
[	O
]	O
=	O
"[GITPS-Color]"	*(char)
;	O
char	O
monochrome_section	array(char)
[	O
]	O
=	O
"[GITPS-Monochrome]"	*(char)
;	O
int	O
processes	int
;	O
int	O
PID_index	int
;	O
char	O
*	O
g_home	*(char)
;	O
char	O
*	O
g_program	*(char)
;	O
char	O
*	O
program_name	*(char)
;	O
char	O
*	O
ps_cmd	*(char)
;	O
char	O
*	O
temporary_directory	*(char)
;	O
char	O
header_text	array(char)
[	O
MAX_LINE	int
]	O
;	O
int	O
UseLastScreenChar	int
;	O
int	O
StartupScrollStep	int
;	O
int	O
RefreshAfterKill	int
;	O
char	O
*	O
stdout_log_name	*(char)
;	O
char	O
*	O
stderr_log_name	*(char)
;	O
char	O
*	O
stdout_log_template	*(char)
;	O
char	O
*	O
stderr_log_template	*(char)
;	O
char	O
*	O
*	O
ps_vect	*(*(char))
;	O
char	O
*	O
screen	*(char)
;	O
char	O
*	O
global_buf	*(char)
;	O
int	O
first_on_screen	int
,	O
current_process	int
,	O
scroll_step	int
;	O
static	O
int	O
horizontal_offset	int
=	O
0	int
;	O
window_t	struct(int,int,int,int,int,int)
*	O
title_window	*(struct(int,int,int,int,int,int))
,	O
*	O
header_window	*(struct(int,int,int,int,int,int))
,	O
*	O
processes_window	*(struct(int,int,int,int,int,int))
,	O
*	O
status_window	*(struct(int,int,int,int,int,int))
;	O
static	O
char	O
*	O
title_text	*(char)
;	O
static	O
char	O
*	O
help	*(char)
;	O
static	O
char	O
no_perm	array(char)
[	O
]	O
=	O
"not owner !"	*(char)
;	O
static	O
char	O
no_proc	array(char)
[	O
]	O
=	O
"no such process ! (REFRESH recommended)"	*(char)
;	O
typedef	O
struct	O
{	O
char	O
signame	array(char)
[	O
10	int
]	O
;	O
int	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
;	O
}	O
xsignal_t	struct(array(char),int)
;	O
int	O
signal_type	int
=	O
0	int
;	O
static	O
xsignal_t	struct(array(char),int)
sigdesc	array(struct(array(char),int))
[	O
]	O
=	O
{	O
{	O
"SIGALRM  "	*(char)
,	O
SIGALRM	int
}	O
,	O
{	O
"SIGABRT  "	*(char)
,	O
SIGABRT	int
}	O
,	O
{	O
"SIGBUS   "	*(char)
,	O
SIGBUS	int
}	O
,	O
{	O
"SIGCHLD  "	*(char)
,	O
SIGCHLD	int
}	O
,	O
{	O
"SIGCLD   "	*(char)
,	O
SIGCLD	O
}	O
,	O
{	O
"SIGCONT  "	*(char)
,	O
SIGCONT	int
}	O
,	O
{	O
"SIGFPE   "	*(char)
,	O
SIGFPE	int
}	O
,	O
{	O
"SIGHUP   "	*(char)
,	O
SIGHUP	int
}	O
,	O
{	O
"SIGILL   "	*(char)
,	O
SIGILL	int
}	O
,	O
{	O
"SIGINT   "	*(char)
,	O
SIGINT	int
}	O
,	O
{	O
"SIGIO    "	*(char)
,	O
SIGIO	O
}	O
,	O
{	O
"SIGIOT   "	*(char)
,	O
SIGIOT	O
}	O
,	O
{	O
"SIGKILL  "	*(char)
,	O
SIGKILL	int
}	O
,	O
{	O
"SIGPIPE  "	*(char)
,	O
SIGPIPE	int
}	O
,	O
{	O
"SIGPOLL  "	*(char)
,	O
SIGPOLL	int
}	O
,	O
{	O
"SIGPROF  "	*(char)
,	O
SIGPROF	int
}	O
,	O
{	O
"SIGPWR   "	*(char)
,	O
SIGPWR	int
}	O
,	O
{	O
"SIGQUIT  "	*(char)
,	O
SIGQUIT	int
}	O
,	O
{	O
"SIGSEGV  "	*(char)
,	O
SIGSEGV	int
}	O
,	O
{	O
"SIGSTOP  "	*(char)
,	O
SIGSTOP	int
}	O
,	O
{	O
"SIGSYS   "	*(char)
,	O
SIGSYS	int
}	O
,	O
{	O
"SIGTERM  "	*(char)
,	O
SIGTERM	int
}	O
,	O
{	O
"SIGSTKFLT"	*(char)
,	O
SIGSTKFLT	int
}	O
,	O
{	O
"SIGTRAP  "	*(char)
,	O
SIGTRAP	int
}	O
,	O
{	O
"SIGTSTP  "	*(char)
,	O
SIGTSTP	int
}	O
,	O
{	O
"SIGTTIN  "	*(char)
,	O
SIGTTIN	int
}	O
,	O
{	O
"SIGTTOU  "	*(char)
,	O
SIGTTOU	int
}	O
,	O
{	O
"SIGURG   "	*(char)
,	O
SIGURG	int
}	O
,	O
{	O
"SIGUSR1  "	*(char)
,	O
SIGUSR1	int
}	O
,	O
{	O
"SIGUSR2  "	*(char)
,	O
SIGUSR2	int
}	O
,	O
{	O
"SIGVTALRM"	*(char)
,	O
SIGVTALRM	int
}	O
,	O
{	O
"SIGWINCH "	*(char)
,	O
SIGWINCH	int
}	O
,	O
{	O
"SIGXCPU  "	*(char)
,	O
SIGXCPU	int
}	O
,	O
{	O
"SIGXFSZ  "	*(char)
,	O
SIGXFSZ	int
}	O
,	O
}	O
;	O
char	O
built_in	array(array(char))
[	O
BUILTIN_OPERATIONS	int
]	O
[	O
MAX_BUILTIN_NAME	int
]	O
=	O
{	O
"previous-line"	*(char)
,	O
"next-line"	*(char)
,	O
"scroll-down"	*(char)
,	O
"scroll-up"	*(char)
,	O
"beginning-of-list"	*(char)
,	O
"end-of-list"	*(char)
,	O
"next-signal"	*(char)
,	O
"SIGALRM"	*(char)
,	O
"SIGABRT"	*(char)
,	O
"SIGBUS"	*(char)
,	O
"SIGCHLD"	*(char)
,	O
"SIGCLD"	*(char)
,	O
"SIGCONT"	*(char)
,	O
"SIGEMT"	*(char)
,	O
"SIGFPE"	*(char)
,	O
"SIGHUP"	*(char)
,	O
"SIGILL"	*(char)
,	O
"SIGINFO"	*(char)
,	O
"SIGINT"	*(char)
,	O
"SIGIO"	*(char)
,	O
"SIGIOT"	*(char)
,	O
"SIGKILL"	*(char)
,	O
"SIGPIPE"	*(char)
,	O
"SIGPOLL"	*(char)
,	O
"SIGPROF"	*(char)
,	O
"SIGPWR"	*(char)
,	O
"SIGQUIT"	*(char)
,	O
"SIGSEGV"	*(char)
,	O
"SIGSTOP"	*(char)
,	O
"SIGSYS"	*(char)
,	O
"SIGTERM"	*(char)
,	O
"SIGTRAP"	*(char)
,	O
"SIGTSTP"	*(char)
,	O
"SIGTTIN"	*(char)
,	O
"SIGTTOU"	*(char)
,	O
"SIGURG"	*(char)
,	O
"SIGUSR1"	*(char)
,	O
"SIGUSR2"	*(char)
,	O
"SIGVTALRM"	*(char)
,	O
"SIGWINCH"	*(char)
,	O
"SIGXCPU"	*(char)
,	O
"SIGXFSZ"	*(char)
,	O
"kill-process"	*(char)
,	O
"refresh"	*(char)
,	O
"exit"	*(char)
,	O
"hard-refresh"	*(char)
,	O
"SIGSTKFLT"	*(char)
,	O
"horizontal-scroll-left"	*(char)
,	O
"horizontal-scroll-right"	*(char)
,	O
}	O
;	O
void	O
remove_log	()->(void)
(	O
)	O
{	O
if	O
(	O
stdout_log_name	*(char)
)	O
unlink	(*(char))->(int)
(	O
stdout_log_name	*(char)
)	O
;	O
if	O
(	O
stderr_log_name	*(char)
)	O
unlink	(*(char))->(int)
(	O
stderr_log_name	*(char)
)	O
;	O
}	O
void	O
set_title	()->(void)
(	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
global_buf	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
global_buf	*(char)
,	O
title_text	*(char)
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
title_text	*(char)
)	O
)	O
)	O
;	O
tty_colors	(int,int,int)->(void)
(	O
TitleBrightness	O
,	O
TitleForeground	O
,	O
TitleBackground	O
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
title_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
title_window	*(struct(int,int,int,int,int,int))
,	O
global_buf	*(char)
,	O
tty_columns	int
)	O
;	O
}	O
void	O
set_header	()->(void)
(	O
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
global_buf	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
global_buf	*(char)
+	O
2	int
,	O
header_text	array(char)
,	O
min	O
(	O
tty_columns	int
-	O
2	int
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
header_text	array(char)
)	O
)	O
)	O
;	O
tty_colors	(int,int,int)->(void)
(	O
HeaderBrightness	O
,	O
HeaderForeground	O
,	O
HeaderBackground	O
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
header_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
header_window	*(struct(int,int,int,int,int,int))
,	O
global_buf	*(char)
,	O
tty_columns	int
)	O
;	O
}	O
void	O
set_status	(*(char))->(void)
(	O
what	*(char)
)	O
char	O
*	O
what	*(char)
;	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
global_buf	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
if	O
(	O
what	*(char)
)	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
global_buf	*(char)
,	O
what	*(char)
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
what	*(char)
)	O
)	O
)	O
;	O
else	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
global_buf	*(char)
,	O
help	*(char)
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
help	*(char)
)	O
)	O
)	O
;	O
tty_colors	(int,int,int)->(void)
(	O
StatusBrightness	O
,	O
StatusForeground	O
,	O
StatusBackground	O
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
tty_columns	int
<	O
(	O
int	O
)	O
(	O
(	O
sizeof	O
(	O
sigdesc	array(struct(array(char),int))
[	O
0	int
]	O
.	O
signame	array(char)
)	O
-	O
1	int
)	O
+	O
1	int
)	O
)	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
global_buf	*(char)
,	O
tty_columns	int
)	O
;	O
else	O
{	O
global_buf	*(char)
[	O
tty_columns	int
-	O
1	int
-	O
(	O
sizeof	O
(	O
sigdesc	array(struct(array(char),int))
[	O
0	int
]	O
.	O
signame	array(char)
)	O
-	O
1	int
)	O
-	O
1	int
]	O
=	O
' '	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
global_buf	*(char)
,	O
tty_columns	int
-	O
(	O
sizeof	O
(	O
sigdesc	array(struct(array(char),int))
[	O
0	int
]	O
.	O
signame	array(char)
)	O
-	O
1	int
)	O
-	O
1	int
)	O
;	O
}	O
}	O
void	O
set_signal	(int)->(void)
(	O
index	(*(char),int)->(*(char))
)	O
int	O
index	(*(char),int)->(*(char))
;	O
{	O
int	O
i	int
,	O
len	int
=	O
sizeof	O
(	O
sigdesc	array(struct(array(char),int))
[	O
0	int
]	O
.	O
signame	array(char)
)	O
-	O
1	int
;	O
if	O
(	O
index	(*(char),int)->(*(char))
>=	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
sigdesc	array(struct(array(char),int))
)	O
/	O
sizeof	O
(	O
xsignal_t	struct(array(char),int)
)	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
sigdesc	array(struct(array(char),int))
[	O
i	int
]	O
.	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
==	O
index	(*(char),int)->(*(char))
)	O
{	O
signal_type	int
=	O
i	int
;	O
break	O
;	O
}	O
if	O
(	O
tty_columns	int
>	O
len	int
)	O
{	O
tty_colors	(int,int,int)->(void)
(	O
StatusBrightness	O
,	O
WHITE	int
,	O
StatusBackground	O
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
tty_columns	int
-	O
len	int
-	O
1	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
sigdesc	array(struct(array(char),int))
[	O
signal_type	int
]	O
.	O
signame	array(char)
,	O
len	int
)	O
;	O
window_putc	(*(struct(int,int,int,int,int,int)),int)->(int)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
' '	O
)	O
;	O
}	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
tty_columns	int
-	O
1	int
)	O
;	O
}	O
void	O
report_undefined_key	()->(void)
(	O
)	O
{	O
char	O
*	O
prev	*(char)
=	O
tty_get_previous_key_seq	()->(*(char))
(	O
)	O
;	O
size_t	long
length	long
=	O
strlen	(*(char))->(long)
(	O
prev	*(char)
)	O
;	O
if	O
(	O
length	long
&&	O
(	O
prev	*(char)
[	O
length	long
-	O
1	int
]	O
!=	O
key_INTERRUPT	O
)	O
)	O
{	O
char	O
*	O
str	*(char)
=	O
(	O
char	O
*	O
)	O
tty_key_machine2human	(*(char))->(*(char))
(	O
tty_get_previous_key_seq	()->(*(char))
(	O
)	O
)	O
;	O
char	O
*	O
buf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
128	int
+	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%s: not defined."	*(char)
,	O
str	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
global_buf	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
global_buf	*(char)
,	O
buf	*(char)
,	O
min	O
(	O
tty_columns	int
,	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
)	O
)	O
;	O
xfree	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
tty_colors	(int,int,int)->(void)
(	O
ON	int
,	O
WHITE	int
,	O
RED	int
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
global_buf	*(char)
,	O
tty_columns	int
)	O
;	O
tty_beep	()->(void)
(	O
)	O
;	O
tty_update	()->(void)
(	O
)	O
;	O
sleep	(int)->(int)
(	O
1	int
)	O
;	O
}	O
else	O
tty_beep	()->(void)
(	O
)	O
;	O
set_status	(*(char))->(void)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
set_signal	(int)->(void)
(	O
-	O
1	int
)	O
;	O
tty_update	()->(void)
(	O
)	O
;	O
}	O
void	O
free_ps_list	()->(void)
(	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
processes	int
;	O
i	int
++	O
)	O
{	O
xfree	(*(void))->(void)
(	O
ps_vect	*(*(char))
[	O
i	int
]	O
)	O
;	O
ps_vect	*(*(char))
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
}	O
char	O
*	O
read_ps_line	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(*(char))
(	O
ps_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	*(char)
)	O
FILE	struct
*	O
ps_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
line	*(char)
;	O
{	O
int	O
c	int
;	O
char	O
*	O
ok	*(char)
;	O
size_t	long
lastchar	long
;	O
ok	*(char)
=	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
line	*(char)
,	O
MAX_LINE	int
-	O
1	int
,	O
ps_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ok	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
line	*(char)
[	O
lastchar	long
=	O
strlen	(*(char))->(long)
(	O
line	*(char)
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
line	*(char)
[	O
lastchar	long
]	O
=	O
0	int
;	O
else	O
while	O
(	O
(	O
c	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ps_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
'\n'	O
&&	O
c	int
!=	O
EOF	O
)	O
;	O
return	O
ok	*(char)
;	O
}	O
int	O
get_PID_index	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
ps_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
FILE	struct
*	O
ps_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
{	O
int	O
i	int
;	O
char	O
*	O
h	*(char)
=	O
header_text	array(char)
;	O
if	O
(	O
read_ps_line	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(*(char))
(	O
ps_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
header_text	array(char)
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
strstr	(*(char),*(char))->(*(char))
(	O
header_text	array(char)
,	O
"PID"	*(char)
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
;	O
i	int
++	O
)	O
{	O
while	O
(	O
isspace	(int)->(int)
(	O
(	O
int	O
)	O
*	O
h	*(char)
)	O
)	O
h	*(char)
++	O
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
h	*(char)
,	O
"PID"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
return	O
i	int
;	O
while	O
(	O
!	O
isspace	(int)->(int)
(	O
(	O
int	O
)	O
*	O
h	*(char)
)	O
)	O
h	*(char)
++	O
;	O
}	O
}	O
int	O
kill_process	(int)->(int)
(	O
process_index	int
)	O
int	O
process_index	int
;	O
{	O
int	O
i	int
;	O
char	O
*	O
p	*(void)
;	O
char	O
pidstr	array(char)
[	O
128	int
]	O
;	O
int	O
pidnum	int
;	O
assert	O
(	O
process_index	int
<	O
processes	int
)	O
;	O
p	*(void)
=	O
ps_vect	*(*(char))
[	O
process_index	int
]	O
;	O
assert	O
(	O
p	*(void)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
PID_index	int
;	O
i	int
++	O
)	O
{	O
while	O
(	O
isspace	(int)->(int)
(	O
(	O
int	O
)	O
*	O
p	*(void)
)	O
)	O
p	*(void)
++	O
;	O
while	O
(	O
!	O
isspace	(int)->(int)
(	O
(	O
int	O
)	O
*	O
p	*(void)
)	O
)	O
p	*(void)
++	O
;	O
}	O
i	int
=	O
0	int
;	O
while	O
(	O
isspace	(int)->(int)
(	O
(	O
int	O
)	O
*	O
p	*(void)
)	O
)	O
p	*(void)
++	O
;	O
while	O
(	O
!	O
isspace	(int)->(int)
(	O
(	O
int	O
)	O
*	O
p	*(void)
)	O
)	O
pidstr	array(char)
[	O
i	int
++	O
]	O
=	O
*	O
p	*(void)
++	O
;	O
pidstr	array(char)
[	O
i	int
]	O
=	O
0	int
;	O
pidnum	int
=	O
atoi	(*(char))->(int)
(	O
pidstr	array(char)
)	O
;	O
if	O
(	O
pidnum	int
)	O
return	O
!	O
kill	(int,int)->(int)
(	O
atoi	(*(char))->(int)
(	O
pidstr	array(char)
)	O
,	O
sigdesc	array(struct(array(char),int))
[	O
signal_type	int
]	O
.	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
)	O
;	O
else	O
return	O
-	O
1	int
;	O
}	O
void	O
build_ps_list	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
ps_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
FILE	struct
*	O
ps_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
{	O
int	O
i	int
;	O
char	O
line	*(char)
[	O
MAX_LINE	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
read_ps_line	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(*(char))
(	O
ps_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
line	*(char)
)	O
;	O
i	int
++	O
)	O
{	O
ps_vect	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
ps_vect	*(*(char))
,	O
(	O
i	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
ps_vect	*(*(char))
[	O
i	int
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
line	*(char)
)	O
;	O
}	O
processes	int
=	O
i	int
;	O
}	O
void	O
update_process	(int,int)->(void)
(	O
process	int
,	O
update_color	int
)	O
int	O
process	int
,	O
update_color	int
;	O
{	O
assert	O
(	O
process	int
<	O
processes	int
)	O
;	O
int	O
ps_length	int
,	O
visible_length	int
,	O
offset	long
;	O
ps_length	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ps_vect	*(*(char))
[	O
process	int
]	O
)	O
;	O
visible_length	int
=	O
(	O
tty_columns	int
-	O
2	int
)	O
;	O
if	O
(	O
visible_length	int
>=	O
ps_length	int
)	O
offset	long
=	O
0	int
;	O
else	O
offset	long
=	O
min	O
(	O
horizontal_offset	int
,	O
(	O
ps_length	int
-	O
visible_length	int
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
global_buf	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
global_buf	*(char)
+	O
2	int
,	O
(	O
ps_vect	*(*(char))
[	O
process	int
]	O
+	O
offset	long
)	O
,	O
min	O
(	O
visible_length	int
,	O
strlen	(*(char))->(long)
(	O
ps_vect	*(*(char))
[	O
process	int
]	O
+	O
offset	long
)	O
)	O
)	O
;	O
global_buf	*(char)
[	O
0	int
]	O
=	O
(	O
process	int
==	O
current_process	int
)	O
?	O
'>'	O
:	O
' '	O
;	O
global_buf	*(char)
[	O
1	int
]	O
=	O
' '	O
;	O
if	O
(	O
update_color	int
)	O
{	O
tty_brightness	(int)->(void)
(	O
ScreenBrightness	O
)	O
;	O
if	O
(	O
process	int
==	O
current_process	int
)	O
{	O
tty_foreground	(int)->(void)
(	O
ScreenBackground	O
)	O
;	O
tty_background	(int)->(void)
(	O
ScreenForeground	O
)	O
;	O
}	O
else	O
{	O
tty_foreground	(int)->(void)
(	O
ScreenForeground	O
)	O
;	O
tty_background	(int)->(void)
(	O
ScreenBackground	O
)	O
;	O
}	O
}	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
processes_window	*(struct(int,int,int,int,int,int))
,	O
process	int
-	O
first_on_screen	int
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
processes_window	*(struct(int,int,int,int,int,int))
,	O
global_buf	*(char)
,	O
tty_columns	int
)	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
tty_columns	int
-	O
1	int
)	O
;	O
}	O
void	O
update_all	()->(void)
(	O
)	O
{	O
int	O
i	int
;	O
tty_colors	(int,int,int)->(void)
(	O
ScreenBrightness	O
,	O
ScreenForeground	O
,	O
ScreenBackground	O
)	O
;	O
if	O
(	O
tty_lines	int
<=	O
4	int
)	O
return	O
;	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
processes_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
first_on_screen	int
;	O
i	int
<	O
processes	int
&&	O
(	O
i	int
-	O
first_on_screen	int
<	O
tty_lines	int
-	O
3	int
)	O
;	O
i	int
++	O
)	O
if	O
(	O
i	int
!=	O
current_process	int
)	O
update_process	(int,int)->(void)
(	O
i	int
,	O
OFF	int
)	O
;	O
else	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
processes_window	*(struct(int,int,int,int,int,int))
,	O
i	int
-	O
first_on_screen	int
,	O
0	int
)	O
;	O
update_process	(int,int)->(void)
(	O
current_process	int
,	O
ON	int
)	O
;	O
tty_colors	(int,int,int)->(void)
(	O
ScreenBrightness	O
,	O
ScreenForeground	O
,	O
ScreenBackground	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
global_buf	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
for	O
(	O
;	O
i	int
-	O
first_on_screen	int
<	O
tty_lines	int
-	O
3	int
;	O
i	int
++	O
)	O
{	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
processes_window	*(struct(int,int,int,int,int,int))
,	O
i	int
-	O
first_on_screen	int
,	O
0	int
)	O
;	O
window_puts	(*(struct(int,int,int,int,int,int)),*(char),int)->(int)
(	O
processes_window	*(struct(int,int,int,int,int,int))
,	O
global_buf	*(char)
,	O
tty_columns	int
)	O
;	O
}	O
window_goto	(*(struct(int,int,int,int,int,int)),int,int)->(void)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
tty_columns	int
-	O
1	int
)	O
;	O
}	O
void	O
clean_up	()->(void)
(	O
)	O
{	O
tty_end_cursorapp	()->(void)
(	O
)	O
;	O
tty_end	(*(char))->(void)
(	O
NULL	O
)	O
;	O
remove_log	()->(void)
(	O
)	O
;	O
}	O
void	O
fatal	(*(char))->(void)
(	O
postmsg	*(char)
)	O
char	O
*	O
postmsg	*(char)
;	O
{	O
clean_up	()->(void)
(	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: fatal error: %s.\n"	*(char)
,	O
g_program	*(char)
,	O
postmsg	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
int	O
ps	(*(*(char)))->(int)
(	O
args	*(*(char))
)	O
char	O
*	O
*	O
args	*(*(char))
;	O
{	O
FILE	struct
*	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
,	O
*	O
stderr_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
int	O
stdout_log_fd	int
,	O
stderr_log_fd	int
;	O
remove_log	()->(void)
(	O
)	O
;	O
int	O
old_stdout	int
=	O
dup	(int)->(int)
(	O
1	int
)	O
;	O
int	O
old_stderr	int
=	O
dup	(int)->(int)
(	O
2	int
)	O
;	O
close	*((*(void))->(int))
(	O
1	int
)	O
;	O
close	*((*(void))->(int))
(	O
2	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
stdout_log_name	*(char)
,	O
stdout_log_template	*(char)
)	O
;	O
stdout_log_fd	int
=	O
mkstemp	(*(char))->(int)
(	O
stdout_log_name	*(char)
)	O
;	O
if	O
(	O
stdout_log_fd	int
!=	O
-	O
1	int
)	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
stdout_log_fd	int
,	O
"w"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
stderr_log_name	*(char)
,	O
stderr_log_template	*(char)
)	O
;	O
stderr_log_fd	int
=	O
mkstemp	(*(char))->(int)
(	O
stderr_log_name	*(char)
)	O
;	O
if	O
(	O
stderr_log_fd	int
!=	O
-	O
1	int
)	O
stderr_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
stderr_log_fd	int
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
||	O
!	O
stderr_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
if	O
(	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
stderr_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
remove_log	()->(void)
(	O
)	O
;	O
dup	(int)->(int)
(	O
old_stdout	int
)	O
;	O
dup	(int)->(int)
(	O
old_stderr	int
)	O
;	O
close	*((*(void))->(int))
(	O
old_stdout	int
)	O
;	O
close	*((*(void))->(int))
(	O
old_stderr	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: cannot write temp file: %s.\n"	*(char)
,	O
g_program	*(char)
,	O
(	O
(	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
?	O
stdout_log_name	*(char)
:	O
stderr_log_name	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
ps_cmd	*(char)
)	O
xfree	(*(void))->(void)
(	O
ps_cmd	*(char)
)	O
;	O
if	O
(	O
args	*(*(char))
)	O
{	O
int	O
i	int
,	O
bytes	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
args	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
bytes	int
+=	O
1	int
+	O
strlen	(*(char))->(long)
(	O
args	*(*(char))
[	O
i	int
]	O
)	O
;	O
ps_cmd	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
16	int
+	O
bytes	int
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
ps_cmd	*(char)
,	O
"ps"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
args	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
ps_cmd	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
ps_cmd	*(char)
,	O
args	*(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
}	O
else	O
ps_cmd	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
"ps"	*(char)
)	O
;	O
if	O
(	O
system	(*(char))->(int)
(	O
ps_cmd	*(char)
)	O
!=	O
0	int
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
remove_log	()->(void)
(	O
)	O
;	O
dup	(int)->(int)
(	O
old_stdout	int
)	O
;	O
dup	(int)->(int)
(	O
old_stderr	int
)	O
;	O
close	*((*(void))->(int))
(	O
old_stdout	int
)	O
;	O
close	*((*(void))->(int))
(	O
old_stderr	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: invalid command line for ps(1).\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the command was: `%s'.\n"	*(char)
,	O
g_program	*(char)
,	O
ps_cmd	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: see the ps(1) man page for details.\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
dup	(int)->(int)
(	O
old_stdout	int
)	O
;	O
dup	(int)->(int)
(	O
old_stderr	int
)	O
;	O
close	*((*(void))->(int))
(	O
old_stdout	int
)	O
;	O
close	*((*(void))->(int))
(	O
old_stderr	int
)	O
;	O
return	O
1	int
;	O
}	O
int	O
read_keys	(int)->(int)
(	O
keys	int
)	O
int	O
keys	int
;	O
{	O
char	O
*	O
contents	*(char)
;	O
char	O
key_seq	*(char)
[	O
80	int
]	O
;	O
int	O
i	int
,	O
j	int
,	O
need_conversion	int
;	O
for	O
(	O
i	int
=	O
keys	int
;	O
i	int
<	O
MAX_KEYS	int
;	O
i	int
++	O
)	O
{	O
configuration_getvarinfo	(*(char),*(*(char)),int,int)->(void)
(	O
key_seq	*(char)
,	O
&	O
contents	*(char)
,	O
1	int
,	O
NO_SEEK	int
)	O
;	O
if	O
(	O
*	O
key_seq	*(char)
==	O
0	int
)	O
break	O
;	O
if	O
(	O
*	O
key_seq	*(char)
!=	O
'^'	O
)	O
{	O
char	O
*	O
key_seq_ptr	*(char)
=	O
tty_get_symbol_key_seq	(*(char))->(*(char))
(	O
key_seq	*(char)
)	O
;	O
if	O
(	O
key_seq_ptr	*(char)
)	O
{	O
if	O
(	O
*	O
key_seq_ptr	*(char)
==	O
'\0'	O
)	O
continue	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
key_seq	*(char)
,	O
key_seq_ptr	*(char)
)	O
;	O
need_conversion	int
=	O
0	int
;	O
}	O
else	O
{	O
need_conversion	int
=	O
1	int
;	O
}	O
}	O
else	O
need_conversion	int
=	O
1	int
;	O
if	O
(	O
contents	*(char)
==	O
NULL	O
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
BUILTIN_OPERATIONS	int
;	O
j	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
contents	*(char)
,	O
built_in	array(array(char))
[	O
j	int
]	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
j	int
<	O
BUILTIN_OPERATIONS	int
)	O
{	O
if	O
(	O
!	O
need_conversion	int
||	O
tty_key_human2machine	(*(char))->(*(char))
(	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	*(char)
)	O
)	O
tty_key_list_insert	(*(char),*(void))->(void)
(	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	*(char)
,	O
built_in	array(array(char))
[	O
j	int
]	O
)	O
;	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: invalid built-in operation: %s.\n"	*(char)
,	O
g_program	*(char)
,	O
contents	*(char)
)	O
;	O
}	O
return	O
i	int
;	O
}	O
void	O
resize	(int)->(void)
(	O
resize_required	int
)	O
int	O
resize_required	int
;	O
{	O
int	O
display_title	int
=	O
OFF	int
;	O
int	O
display_header	int
=	O
OFF	int
;	O
int	O
display_processes	int
=	O
OFF	int
;	O
int	O
old_tty_lines	int
=	O
tty_lines	int
;	O
int	O
old_tty_columns	int
=	O
tty_columns	int
;	O
tty_resize	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
resize_required	int
)	O
if	O
(	O
tty_lines	int
==	O
old_tty_lines	int
&&	O
tty_columns	int
==	O
old_tty_columns	int
)	O
return	O
;	O
if	O
(	O
LinuxConsole	int
)	O
screen	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
screen	*(char)
,	O
4	int
+	O
tty_columns	int
*	O
tty_lines	int
*	O
2	int
)	O
;	O
global_buf	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
global_buf	*(char)
,	O
tty_columns	int
+	O
1	int
)	O
;	O
current_process	int
=	O
min	O
(	O
current_process	int
,	O
processes	int
-	O
1	int
)	O
;	O
first_on_screen	int
=	O
max	O
(	O
0	int
,	O
current_process	int
-	O
(	O
tty_lines	int
-	O
3	int
)	O
+	O
1	int
)	O
;	O
assert	O
(	O
first_on_screen	int
>=	O
0	int
)	O
;	O
window_resize	(*(struct(int,int,int,int,int,int)),int,int,int,int)->(void)
(	O
status_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
tty_lines	int
-	O
1	int
,	O
1	int
,	O
tty_columns	int
)	O
;	O
if	O
(	O
tty_lines	int
>=	O
2	int
)	O
display_title	int
=	O
ON	int
;	O
if	O
(	O
tty_lines	int
>=	O
3	int
)	O
display_header	int
=	O
ON	int
;	O
if	O
(	O
tty_lines	int
>=	O
5	int
)	O
{	O
display_processes	int
=	O
ON	int
;	O
if	O
(	O
StartupScrollStep	int
<=	O
0	int
||	O
StartupScrollStep	int
>=	O
(	O
tty_lines	int
-	O
3	int
)	O
-	O
1	int
)	O
scroll_step	int
=	O
(	O
tty_lines	int
-	O
3	int
)	O
/	O
2	int
;	O
else	O
scroll_step	int
=	O
StartupScrollStep	int
;	O
}	O
window_resize	(*(struct(int,int,int,int,int,int)),int,int,int,int)->(void)
(	O
title_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
0	int
,	O
display_title	int
?	O
1	int
:	O
0	int
,	O
tty_columns	int
)	O
;	O
window_resize	(*(struct(int,int,int,int,int,int)),int,int,int,int)->(void)
(	O
header_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
1	int
,	O
display_header	int
?	O
1	int
:	O
0	int
,	O
tty_columns	int
)	O
;	O
window_resize	(*(struct(int,int,int,int,int,int)),int,int,int,int)->(void)
(	O
processes_window	*(struct(int,int,int,int,int,int))
,	O
0	int
,	O
2	int
,	O
display_processes	int
?	O
(	O
tty_lines	int
-	O
3	int
)	O
:	O
0	int
,	O
tty_columns	int
)	O
;	O
}	O
void	O
refresh	(int)->(void)
(	O
signum	int
)	O
int	O
signum	int
;	O
{	O
current_process	int
=	O
min	O
(	O
current_process	int
,	O
processes	int
-	O
1	int
)	O
;	O
resize	(int)->(void)
(	O
0	int
)	O
;	O
if	O
(	O
signum	int
==	O
SIGCONT	int
)	O
{	O
tty_set_mode	(int)->(void)
(	O
TTY_NONCANONIC	int
)	O
;	O
tty_defaults	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
tty_lines	int
==	O
4	int
)	O
{	O
tty_defaults	()->(void)
(	O
)	O
;	O
tty_clear	()->(void)
(	O
)	O
;	O
}	O
set_title	()->(void)
(	O
)	O
;	O
set_header	()->(void)
(	O
)	O
;	O
set_status	(*(char))->(void)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
set_signal	(int)->(void)
(	O
-	O
1	int
)	O
;	O
update_all	()->(void)
(	O
)	O
;	O
tty_update	()->(void)
(	O
)	O
;	O
if	O
(	O
signum	int
==	O
SIGCONT	int
)	O
tty_update_title	(*(char))->(void)
(	O
ps_cmd	*(char)
)	O
;	O
}	O
void	O
hide	()->(void)
(	O
)	O
{	O
tty_set_mode	(int)->(void)
(	O
TTY_CANONIC	int
)	O
;	O
tty_defaults	()->(void)
(	O
)	O
;	O
tty_put_screen	(*(char))->(void)
(	O
screen	*(char)
)	O
;	O
}	O
void	O
clock_refresh	()->(void)
(	O
)	O
{	O
}	O
void	O
usage	()->(void)
(	O
)	O
{	O
printf	(*(char))->(int)
(	O
"usage: %s [-hvilcbp]\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" -h         print this help message\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" -v         print the version number\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" -c         use ANSI colors\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" -b         don't use ANSI colors\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" -l         don't use the last screen character\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" -p         pass the remaining arguments to ps(1)\n"	*(char)
)	O
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
argc	int
,	O
argv	array(*(char))
)	O
int	O
argc	int
;	O
char	O
*	O
argv	array(*(char))
[	O
]	O
;	O
{	O
char	O
*	O
tmp	*(char)
;	O
int	O
key	int
,	O
keys	int
;	O
tty_key_t	struct(*(char),*(struct(*(char),*(struct(*`,*`,*`)),*(void))),*(void))
*	O
ks	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
;	O
FILE	struct
*	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
repeat_count	int
;	O
char	O
*	O
*	O
arguments	*(*(char))
;	O
int	O
i	int
,	O
no_of_arguments	int
,	O
exit_code	int
=	O
0	int
;	O
int	O
need_update	int
,	O
need_update_all	int
,	O
old_current_process	int
;	O
int	O
c	int
,	O
ansi_colors	int
=	O
-	O
1	int
,	O
use_last_screen_character	int
=	O
ON	int
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
signals_init	()->(void)
(	O
)	O
;	O
program_name	*(char)
=	O
g_program	*(char)
=	O
argv	array(*(char))
[	O
0	int
]	O
;	O
g_home	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"HOME"	*(char)
)	O
;	O
if	O
(	O
g_home	*(char)
==	O
NULL	O
)	O
g_home	*(char)
=	O
"."	*(char)
;	O
compute_directories	()->(void)
(	O
)	O
;	O
get_login_name	()->(void)
(	O
)	O
;	O
if	O
(	O
getenv	(*(char))->(*(char))
(	O
"COLORTERM"	*(char)
)	O
!=	O
NULL	O
)	O
ansi_colors	int
=	O
ON	int
;	O
while	O
(	O
(	O
c	int
=	O
getopt	(int,*(*(char)),*(char))->(int)
(	O
argc	int
,	O
argv	array(*(char))
,	O
"hvcblp"	*(char)
)	O
)	O
!=	O
-	O
1	int
)	O
switch	O
(	O
c	int
)	O
{	O
case	O
'h'	O
:	O
usage	()->(void)
(	O
)	O
;	O
return	O
0	int
;	O
case	O
'v'	O
:	O
printf	(*(char))->(int)
(	O
"%s %s\n"	*(char)
,	O
PRODUCT	*(char)
,	O
VERSION	*(char)
)	O
;	O
return	O
0	int
;	O
case	O
'c'	O
:	O
ansi_colors	int
=	O
ON	int
;	O
break	O
;	O
case	O
'b'	O
:	O
ansi_colors	int
=	O
OFF	int
;	O
break	O
;	O
case	O
'l'	O
:	O
use_last_screen_character	int
=	O
OFF	int
;	O
break	O
;	O
case	O
'p'	O
:	O
goto	O
done	O
;	O
case	O
'?'	O
:	O
return	O
1	int
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: unknown error\n"	*(char)
,	O
g_program	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
done	O
:	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
no_of_arguments	int
=	O
argc	int
-	O
optind	int
;	O
arguments	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
no_of_arguments	int
+	O
1	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
no_of_arguments	int
;	O
i	int
++	O
)	O
arguments	*(*(char))
[	O
i	int
]	O
=	O
argv	array(*(char))
[	O
optind	int
++	O
]	O
;	O
arguments	*(*(char))
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
else	O
arguments	*(*(char))
=	O
NULL	O
;	O
title_text	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
PRODUCT	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
VERSION	*(char)
)	O
+	O
64	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
title_text	*(char)
,	O
" %s %s - Process Viewer/Killer"	*(char)
,	O
PRODUCT	*(char)
,	O
VERSION	*(char)
)	O
;	O
tty_init	(int)->(void)
(	O
TTY_FULL_INPUT	int
)	O
;	O
common_configuration_init	()->(void)
(	O
)	O
;	O
use_section	(*(char))->(void)
(	O
"[GITPS-Keys]"	*(char)
)	O
;	O
keys	int
=	O
read_keys	(int)->(int)
(	O
0	int
)	O
;	O
configuration_end	()->(void)
(	O
)	O
;	O
specific_configuration_init	()->(int)
(	O
)	O
;	O
use_section	(*(char))->(void)
(	O
"[Setup]"	*(char)
)	O
;	O
temporary_directory	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TMPDIR"	*(char)
)	O
;	O
if	O
(	O
temporary_directory	*(char)
==	O
NULL	O
)	O
temporary_directory	*(char)
=	O
"/tmp"	*(char)
;	O
if	O
(	O
ansi_colors	int
==	O
-	O
1	int
)	O
AnsiColors	int
=	O
get_flag_var	(*(char),int)->(int)
(	O
"AnsiColors"	*(char)
,	O
OFF	int
)	O
;	O
else	O
AnsiColors	int
=	O
ansi_colors	int
;	O
if	O
(	O
use_last_screen_character	int
)	O
UseLastScreenChar	int
=	O
get_flag_var	(*(char),int)->(int)
(	O
"UseLastScreenChar"	*(char)
,	O
OFF	int
)	O
;	O
else	O
UseLastScreenChar	int
=	O
OFF	int
;	O
tty_set_last_char_flag	(int)->(void)
(	O
UseLastScreenChar	int
)	O
;	O
StartupScrollStep	int
=	O
get_int_var	(*(char),int)->(int)
(	O
"StartupScrollStep"	*(char)
,	O
(	O
tty_lines	int
-	O
3	int
)	O
/	O
2	int
)	O
;	O
use_section	(*(char))->(void)
(	O
"[GITPS-Setup]"	*(char)
)	O
;	O
help	*(char)
=	O
get_string_var	(*(char),*(char))->(*(char))
(	O
"Help"	*(char)
,	O
""	*(char)
)	O
;	O
RefreshAfterKill	int
=	O
get_flag_var	(*(char),int)->(int)
(	O
"RefreshAfterKill"	*(char)
,	O
ON	int
)	O
;	O
use_section	(*(char))->(void)
(	O
AnsiColors	int
?	O
color_section	array(char)
:	O
monochrome_section	array(char)
)	O
;	O
get_colorset_var	(*(int),array(*(char)),int)->(void)
(	O
PSColors	array(int)
,	O
PSFields	array(*(char))
,	O
PS_FIELDS	int
)	O
;	O
use_section	(*(char))->(void)
(	O
"[GITPS-Keys]"	*(char)
)	O
;	O
keys	int
=	O
read_keys	(int)->(int)
(	O
keys	int
)	O
;	O
if	O
(	O
keys	int
==	O
MAX_KEYS	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: too many key sequences; only %d are allowed.\n"	*(char)
,	O
g_program	*(char)
,	O
MAX_KEYS	int
)	O
;	O
configuration_end	()->(void)
(	O
)	O
;	O
stdout_log_template	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
32	int
+	O
strlen	(*(char))->(long)
(	O
temporary_directory	*(char)
)	O
+	O
1	int
)	O
;	O
stderr_log_template	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
32	int
+	O
strlen	(*(char))->(long)
(	O
temporary_directory	*(char)
)	O
+	O
1	int
)	O
;	O
stdout_log_name	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
32	int
+	O
strlen	(*(char))->(long)
(	O
temporary_directory	*(char)
)	O
+	O
1	int
)	O
;	O
stderr_log_name	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
32	int
+	O
strlen	(*(char))->(long)
(	O
temporary_directory	*(char)
)	O
+	O
1	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
stdout_log_template	*(char)
,	O
"%s/gitps.1.XXXXXX"	*(char)
,	O
temporary_directory	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
stderr_log_template	*(char)
,	O
"%s/gitps.2.XXXXXX"	*(char)
,	O
temporary_directory	*(char)
)	O
;	O
if	O
(	O
ps	(*(*(char)))->(int)
(	O
arguments	*(*(char))
)	O
==	O
0	int
)	O
return	O
1	int
;	O
tty_start_cursorapp	()->(void)
(	O
)	O
;	O
title_window	*(struct(int,int,int,int,int,int))
=	O
window_init	()->(*(struct(int,int,int,int,int,int)))
(	O
)	O
;	O
header_window	*(struct(int,int,int,int,int,int))
=	O
window_init	()->(*(struct(int,int,int,int,int,int)))
(	O
)	O
;	O
processes_window	*(struct(int,int,int,int,int,int))
=	O
window_init	()->(*(struct(int,int,int,int,int,int)))
(	O
)	O
;	O
status_window	*(struct(int,int,int,int,int,int))
=	O
window_init	()->(*(struct(int,int,int,int,int,int)))
(	O
)	O
;	O
resize	(int)->(void)
(	O
0	int
)	O
;	O
tty_get_screen	(*(char))->(void)
(	O
screen	*(char)
)	O
;	O
tty_set_mode	(int)->(void)
(	O
TTY_NONCANONIC	int
)	O
;	O
tty_defaults	()->(void)
(	O
)	O
;	O
signal_handlers	(int)->(void)
(	O
ON	int
)	O
;	O
first_on_screen	int
=	O
current_process	int
=	O
0	int
;	O
tty_update_title	(*(char))->(void)
(	O
ps_cmd	*(char)
)	O
;	O
set_signal	(int)->(void)
(	O
SIGTERM	int
)	O
;	O
restart	O
:	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
stdout_log_name	*(char)
,	O
"r"	*(char)
)	O
;	O
remove_log	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
PID_index	int
=	O
get_PID_index	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
==	O
-	O
1	int
)	O
{	O
exit_code	int
=	O
1	int
;	O
goto	O
end	O
;	O
}	O
free_ps_list	()->(void)
(	O
)	O
;	O
build_ps_list	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout_log	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
refresh	(int)->(void)
(	O
0	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
(	O
ks	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
=	O
tty_get_key	(*(int))->(*(struct(*(char),*(struct(*`,*`,*`)),*(void))))
(	O
&	O
repeat_count	int
)	O
)	O
==	O
NULL	O
)	O
report_undefined_key	()->(void)
(	O
)	O
;	O
set_status	(*(char))->(void)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
set_signal	(int)->(void)
(	O
-	O
1	int
)	O
;	O
key	int
=	O
(	O
(	O
char	O
*	O
)	O
ks	*(struct(*(char),*(struct(*(char),*(struct`),*(void))),*(void)))
->	O
aux_data	*(void)
-	O
(	O
char	O
*	O
)	O
built_in	array(array(char))
)	O
/	O
MAX_BUILTIN_NAME	int
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
BUILTIN_previous_line	int
:	O
need_update_all	int
=	O
need_update	int
=	O
0	int
;	O
while	O
(	O
repeat_count	int
--	O
)	O
{	O
if	O
(	O
current_process	int
!=	O
0	int
)	O
current_process	int
--	O
;	O
else	O
break	O
;	O
if	O
(	O
current_process	int
+	O
1	int
==	O
first_on_screen	int
)	O
{	O
first_on_screen	int
=	O
max	O
(	O
0	int
,	O
first_on_screen	int
-	O
scroll_step	int
)	O
;	O
need_update_all	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
need_update	int
)	O
update_process	(int,int)->(void)
(	O
current_process	int
+	O
1	int
,	O
ON	int
)	O
;	O
need_update	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
need_update_all	int
)	O
update_all	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
need_update	int
)	O
update_process	(int,int)->(void)
(	O
current_process	int
,	O
ON	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_next_line	int
:	O
need_update_all	int
=	O
need_update	int
=	O
0	int
;	O
while	O
(	O
repeat_count	int
--	O
)	O
{	O
if	O
(	O
current_process	int
<	O
processes	int
-	O
1	int
)	O
current_process	int
++	O
;	O
else	O
break	O
;	O
if	O
(	O
current_process	int
-	O
first_on_screen	int
>=	O
tty_lines	int
-	O
3	int
)	O
{	O
first_on_screen	int
=	O
min	O
(	O
first_on_screen	int
+	O
scroll_step	int
,	O
processes	int
-	O
1	int
-	O
(	O
tty_lines	int
-	O
3	int
)	O
+	O
1	int
)	O
;	O
need_update_all	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
need_update	int
)	O
update_process	(int,int)->(void)
(	O
current_process	int
-	O
1	int
,	O
ON	int
)	O
;	O
need_update	int
=	O
1	int
;	O
}	O
if	O
(	O
need_update_all	int
)	O
update_all	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
need_update	int
)	O
update_process	(int,int)->(void)
(	O
current_process	int
,	O
ON	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_scroll_down	int
:	O
if	O
(	O
current_process	int
==	O
0	int
)	O
break	O
;	O
old_current_process	int
=	O
current_process	int
;	O
if	O
(	O
current_process	int
<	O
tty_lines	int
-	O
3	int
)	O
current_process	int
=	O
first_on_screen	int
=	O
0	int
;	O
else	O
{	O
current_process	int
-=	O
tty_lines	int
-	O
3	int
;	O
first_on_screen	int
=	O
max	O
(	O
0	int
,	O
first_on_screen	int
-	O
(	O
tty_lines	int
-	O
3	int
)	O
)	O
;	O
}	O
if	O
(	O
processes	int
>	O
tty_lines	int
-	O
3	int
)	O
update_all	()->(void)
(	O
)	O
;	O
else	O
{	O
update_process	(int,int)->(void)
(	O
old_current_process	int
,	O
ON	int
)	O
;	O
update_process	(int,int)->(void)
(	O
current_process	int
,	O
ON	int
)	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_scroll_up	int
:	O
if	O
(	O
current_process	int
==	O
processes	int
-	O
1	int
)	O
break	O
;	O
old_current_process	int
=	O
current_process	int
;	O
if	O
(	O
processes	int
-	O
1	int
-	O
first_on_screen	int
<	O
tty_lines	int
-	O
3	int
)	O
current_process	int
=	O
processes	int
-	O
1	int
;	O
else	O
if	O
(	O
processes	int
-	O
1	int
-	O
current_process	int
<	O
tty_lines	int
-	O
3	int
)	O
{	O
current_process	int
=	O
processes	int
-	O
1	int
;	O
first_on_screen	int
=	O
processes	int
-	O
1	int
-	O
(	O
tty_lines	int
-	O
3	int
)	O
+	O
1	int
;	O
}	O
else	O
{	O
current_process	int
+=	O
tty_lines	int
-	O
3	int
;	O
first_on_screen	int
=	O
min	O
(	O
first_on_screen	int
+	O
tty_lines	int
-	O
3	int
,	O
(	O
processes	int
-	O
1	int
)	O
-	O
(	O
tty_lines	int
-	O
3	int
)	O
+	O
1	int
)	O
;	O
}	O
if	O
(	O
processes	int
>	O
tty_lines	int
-	O
3	int
)	O
update_all	()->(void)
(	O
)	O
;	O
else	O
{	O
update_process	(int,int)->(void)
(	O
old_current_process	int
,	O
ON	int
)	O
;	O
update_process	(int,int)->(void)
(	O
current_process	int
,	O
ON	int
)	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_horizontal_scroll_left	int
:	O
horizontal_offset	int
--	O
;	O
if	O
(	O
horizontal_offset	int
<	O
0	int
)	O
horizontal_offset	int
=	O
0	int
;	O
update_all	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_horizontal_scroll_right	int
:	O
horizontal_offset	int
++	O
;	O
update_all	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_beginning_of_list	int
:	O
if	O
(	O
current_process	int
==	O
0	int
)	O
break	O
;	O
current_process	int
=	O
first_on_screen	int
=	O
0	int
;	O
update_all	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_end_of_list	int
:	O
if	O
(	O
current_process	int
==	O
processes	int
-	O
1	int
)	O
break	O
;	O
current_process	int
=	O
processes	int
-	O
1	int
;	O
first_on_screen	int
=	O
max	O
(	O
0	int
,	O
(	O
processes	int
-	O
1	int
)	O
-	O
(	O
tty_lines	int
-	O
3	int
)	O
+	O
1	int
)	O
;	O
update_all	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_next_signal	int
:	O
signal_type	int
++	O
;	O
signal_type	int
%=	O
sizeof	O
(	O
sigdesc	array(struct(array(char),int))
)	O
/	O
sizeof	O
(	O
xsignal_t	struct(array(char),int)
)	O
;	O
set_signal	(int)->(void)
(	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGALRM	int
:	O
set_signal	(int)->(void)
(	O
SIGALRM	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGABRT	int
:	O
set_signal	(int)->(void)
(	O
SIGABRT	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGBUS	int
:	O
set_signal	(int)->(void)
(	O
SIGBUS	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGCHLD	int
:	O
set_signal	(int)->(void)
(	O
SIGCHLD	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGCLD	int
:	O
set_signal	(int)->(void)
(	O
SIGCLD	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGCONT	int
:	O
set_signal	(int)->(void)
(	O
SIGCONT	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGFPE	int
:	O
set_signal	(int)->(void)
(	O
SIGFPE	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGHUP	int
:	O
set_signal	(int)->(void)
(	O
SIGHUP	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGILL	int
:	O
set_signal	(int)->(void)
(	O
SIGILL	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGINT	int
:	O
set_signal	(int)->(void)
(	O
SIGINT	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGIO	int
:	O
set_signal	(int)->(void)
(	O
SIGIO	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGIOT	int
:	O
set_signal	(int)->(void)
(	O
SIGIOT	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGKILL	int
:	O
set_signal	(int)->(void)
(	O
SIGKILL	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGPIPE	int
:	O
set_signal	(int)->(void)
(	O
SIGPIPE	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGPOLL	int
:	O
set_signal	(int)->(void)
(	O
SIGPOLL	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGPROF	int
:	O
set_signal	(int)->(void)
(	O
SIGPROF	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGPWR	int
:	O
set_signal	(int)->(void)
(	O
SIGPWR	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGQUIT	int
:	O
set_signal	(int)->(void)
(	O
SIGQUIT	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGSEGV	int
:	O
set_signal	(int)->(void)
(	O
SIGSEGV	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGSTOP	int
:	O
set_signal	(int)->(void)
(	O
SIGSTOP	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGSYS	int
:	O
set_signal	(int)->(void)
(	O
SIGSYS	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGTERM	int
:	O
set_signal	(int)->(void)
(	O
SIGTERM	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGTRAP	int
:	O
set_signal	(int)->(void)
(	O
SIGTRAP	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGTSTP	int
:	O
set_signal	(int)->(void)
(	O
SIGTSTP	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGTTIN	int
:	O
set_signal	(int)->(void)
(	O
SIGTTIN	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGTTOU	int
:	O
set_signal	(int)->(void)
(	O
SIGTTOU	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGURG	int
:	O
set_signal	(int)->(void)
(	O
SIGURG	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGUSR1	int
:	O
set_signal	(int)->(void)
(	O
SIGUSR1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGUSR2	int
:	O
set_signal	(int)->(void)
(	O
SIGUSR2	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGVTALRM	int
:	O
set_signal	(int)->(void)
(	O
SIGVTALRM	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGWINCH	int
:	O
set_signal	(int)->(void)
(	O
SIGWINCH	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGXCPU	int
:	O
set_signal	(int)->(void)
(	O
SIGXCPU	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGXFSZ	int
:	O
set_signal	(int)->(void)
(	O
SIGXFSZ	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_SIGSTKFLT	int
:	O
set_signal	(int)->(void)
(	O
SIGSTKFLT	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_hard_refresh	int
:	O
tty_touch	()->(void)
(	O
)	O
;	O
case	O
BUILTIN_refresh	int
:	O
ps	(*(*(char)))->(int)
(	O
arguments	*(*(char))
)	O
;	O
goto	O
restart	O
;	O
case	O
BUILTIN_exit	int
:	O
goto	O
end	O
;	O
case	O
BUILTIN_kill_process	int
:	O
if	O
(	O
kill_process	(int)->(int)
(	O
current_process	int
)	O
)	O
{	O
if	O
(	O
RefreshAfterKill	int
)	O
{	O
struct	O
timespec	struct(long,long)
tv	struct(long,long)
;	O
tv	struct(long,long)
.	O
tv_sec	long
=	O
0	int
;	O
tv	struct(long,long)
.	O
tv_nsec	long
=	O
5	int
*	O
1000	int
*	O
1000	int
;	O
nanosleep	(*(struct(long,long)),*(struct(long,long)))->(int)
(	O
&	O
tv	struct(long,long)
,	O
NULL	O
)	O
;	O
ps	(*(*(char)))->(int)
(	O
arguments	*(*(char))
)	O
;	O
goto	O
restart	O
;	O
}	O
}	O
else	O
{	O
int	O
e	int
=	O
errno	O
;	O
tty_beep	()->(void)
(	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
global_buf	*(char)
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
tmp	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
16	int
+	O
strlen	(*(char))->(long)
(	O
(	O
e	int
==	O
EPERM	int
)	O
?	O
no_perm	array(char)
:	O
no_proc	array(char)
)	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
tmp	*(char)
,	O
"Error: %s"	*(char)
,	O
(	O
e	int
==	O
EPERM	int
)	O
?	O
no_perm	array(char)
:	O
no_proc	array(char)
)	O
;	O
set_status	(*(char))->(void)
(	O
tmp	*(char)
)	O
;	O
tty_update	()->(void)
(	O
)	O
;	O
xfree	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
errno	O
=	O
0	int
;	O
tty_get_key	(*(int))->(*(struct(*(char),*(struct(*`,*`,*`)),*(void))))
(	O
NULL	O
)	O
;	O
set_status	(*(char))->(void)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
set_signal	(int)->(void)
(	O
-	O
1	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
report_undefined_key	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
}	O
end	O
:	O
remove_log	()->(void)
(	O
)	O
;	O
tty_set_mode	(int)->(void)
(	O
TTY_CANONIC	int
)	O
;	O
tty_end	(*(char))->(void)
(	O
screen	*(char)
)	O
;	O
return	O
exit_code	int
;	O
}	O
