void	O
*	O
grad_malloc	(long)->(*(void))
(	O
size_t	long
size	int
)	O
{	O
char	O
*	O
p	*(struct)
;	O
p	*(struct)
=	O
malloc	(long)->(*(void))
(	O
size	int
+	O
EXTRA	int
)	O
;	O
GRAD_DEBUG2	O
(	O
10	int
,	O
"malloc(%d) = %p"	*(char)
,	O
size	int
,	O
p	*(struct)
)	O
;	O
if	O
(	O
p	*(struct)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
p	*(struct)
,	O
0	int
,	O
size	int
)	O
;	O
}	O
return	O
p	*(struct)
;	O
}	O
void	O
*	O
grad_realloc	(*(void),long)->(*(void))
(	O
void	O
*	O
ptr	*(*(void))
,	O
size_t	long
size	int
)	O
{	O
if	O
(	O
!	O
ptr	*(*(void))
)	O
return	O
grad_malloc	(long)->(*(void))
(	O
size	int
)	O
;	O
else	O
{	O
ptr	*(*(void))
=	O
realloc	(*(void),long)->(*(void))
(	O
ptr	*(*(void))
,	O
size	int
)	O
;	O
}	O
return	O
ptr	*(*(void))
;	O
}	O
void	O
grad_free	(*(void))->(void)
(	O
void	O
*	O
ptr	*(*(void))
)	O
{	O
if	O
(	O
!	O
ptr	*(*(void))
)	O
return	O
;	O
GRAD_DEBUG1	O
(	O
10	int
,	O
"free(%p)"	*(char)
,	O
ptr	*(*(void))
)	O
;	O
free	(*(void))->(void)
(	O
ptr	*(*(void))
)	O
;	O
}	O
void	O
grad_destroy	(*(*(void)))->(void)
(	O
void	O
*	O
*	O
pptr	*(*(char))
)	O
{	O
if	O
(	O
*	O
pptr	*(*(char))
)	O
{	O
grad_free	(*(void))->(void)
(	O
*	O
pptr	*(*(char))
)	O
;	O
*	O
pptr	*(*(char))
=	O
NULL	O
;	O
}	O
}	O
void	O
*	O
grad_emalloc	(long)->(*(void))
(	O
size_t	long
size	int
)	O
{	O
char	O
*	O
p	*(struct)
;	O
p	*(struct)
=	O
grad_malloc	(long)->(*(void))
(	O
size	int
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
,	O
_	O
(	O
"low core: aborting"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
return	O
p	*(struct)
;	O
}	O
void	O
*	O
grad_erealloc	(*(void),long)->(*(void))
(	O
void	O
*	O
ptr	*(*(void))
,	O
size_t	long
size	int
)	O
{	O
ptr	*(*(void))
=	O
grad_realloc	(*(void),long)->(*(void))
(	O
ptr	*(*(void))
,	O
size	int
)	O
;	O
if	O
(	O
!	O
ptr	*(*(void))
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
,	O
_	O
(	O
"low core: aborting"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
return	O
ptr	*(*(void))
;	O
}	O
char	O
*	O
grad_estrdup	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(*(char))
)	O
{	O
char	O
*	O
p	*(struct)
;	O
if	O
(	O
!	O
s	*(*(char))
)	O
return	O
NULL	O
;	O
p	*(struct)
=	O
grad_emalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
s	*(*(char))
)	O
+	O
1	int
)	O
;	O
return	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(struct)
,	O
s	*(*(char))
)	O
;	O
}	O
char	O
*	O
grad_string_replace	(*(*(char)),*(char))->(*(char))
(	O
char	O
*	O
*	O
str	*(char)
,	O
const	O
char	O
*	O
new_value	*(char)
)	O
{	O
char	O
*	O
p	*(struct)
=	O
*	O
str	*(char)
;	O
*	O
str	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
new_value	*(char)
)	O
;	O
if	O
(	O
p	*(struct)
)	O
grad_free	(*(void))->(void)
(	O
p	*(struct)
)	O
;	O
return	O
*	O
str	*(char)
;	O
}	O
