PSTRLEX	array(char)
vrgszlexArgs	O
[	O
ARGS_MAX	O
]	O
;	O
typedef	O
struct	O
tagKM	O
{	O
PSTR	*(char)
szKeyword	O
;	O
int	O
iKWCode	O
;	O
WORD	int
fContext	O
;	O
}	O
KM	O
,	O
*	O
PKM	O
;	O
KM	O
vrgkmKeywordMap	O
[	O
]	O
=	O
{	O
{	O
"Level"	*(char)
,	O
KM_LEVEL	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"Experiment"	*(char)
,	O
KM_EXPERIMENT	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"Simulation"	*(char)
,	O
KM_EXPERIMENT	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"OutputFile"	*(char)
,	O
KM_OUTPUTFILE	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"MCMC"	*(char)
,	O
KM_MCMC	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"OptimalDesign"	*(char)
,	O
KM_OPTDESIGN	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"MonteCarlo"	*(char)
,	O
KM_MONTECARLO	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"Distrib"	*(char)
,	O
KM_MCVARY	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"Likelihood"	*(char)
,	O
KM_MCVARY	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"Density"	*(char)
,	O
KM_MCVARY	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"MCVary"	*(char)
,	O
KM_MCVARY	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"InvTemperature"	*(char)
,	O
KM_TEMPERATURE	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"Perks"	*(char)
,	O
KM_TEMPERATURE	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"SetPoints"	*(char)
,	O
KM_SETPOINTS	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"Integrate"	*(char)
,	O
KM_INTEGRATE	O
,	O
CN_GLOBAL	O
|	O
CN_EXPERIMENT	O
}	O
,	O
{	O
"Simulate"	*(char)
,	O
KM_SIMULATE	O
,	O
CN_GLOBAL	O
|	O
CN_EXPERIMENT	O
}	O
,	O
{	O
"StartTime"	*(char)
,	O
KM_STARTTIME	O
,	O
CN_GLOBAL	O
|	O
CN_EXPERIMENT	O
}	O
,	O
{	O
"Print"	*(char)
,	O
KM_PRINT	O
,	O
CN_EXPERIMENT	O
}	O
,	O
{	O
"Prediction"	*(char)
,	O
KM_PRINT	O
,	O
CN_EXPERIMENT	O
}	O
,	O
{	O
"PrintStep"	*(char)
,	O
KM_PRINTSTEP	O
,	O
CN_EXPERIMENT	O
}	O
,	O
{	O
"Data"	*(char)
,	O
KM_DATA	O
,	O
CN_EXPERIMENT	O
}	O
,	O
{	O
"SimType"	*(char)
,	O
KM_SIMTYPE	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"End"	*(char)
,	O
KM_END	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"END"	*(char)
,	O
KM_END	O
,	O
CN_GLOBAL	O
}	O
,	O
{	O
"DefaultSim"	*(char)
,	O
KM_DEFAULTSIM	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"No"	*(char)
,	O
KM_NO	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Yes"	*(char)
,	O
KM_YES	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Beta"	*(char)
,	O
KM_BETA	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Binomial"	*(char)
,	O
KM_BINOMIAL	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"BinomialBeta"	*(char)
,	O
KM_BINOMIALBETA	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Cauchy"	*(char)
,	O
KM_CAUCHY	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Chi2"	*(char)
,	O
KM_CHI2	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Exponential"	*(char)
,	O
KM_EXPONENTIAL	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Gamma"	*(char)
,	O
KM_GGAMMA	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"GenLogNormal"	*(char)
,	O
KM_GENLOGNORMAL	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"HalfCauchy"	*(char)
,	O
KM_HALFCAUCHY	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"HalfNormal"	*(char)
,	O
KM_HALFNORMAL	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"InvGamma"	*(char)
,	O
KM_INVGGAMMA	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"LogNormal"	*(char)
,	O
KM_LOGNORMAL	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"LogNormal_v"	*(char)
,	O
KM_LOGNORMALV	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"LogUniform"	*(char)
,	O
KM_LOGUNIFORM	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Normal"	*(char)
,	O
KM_NORMAL	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Normal_cv"	*(char)
,	O
KM_NORMALCV	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Normal_v"	*(char)
,	O
KM_NORMALV	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Piecewise"	*(char)
,	O
KM_PIECEWISE	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Poisson"	*(char)
,	O
KM_POISSON	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"StudentT"	*(char)
,	O
KM_STUDENTT	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"TruncInvGamma"	*(char)
,	O
KM_TRUNCINVGGAMMA	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"TruncLogNormal"	*(char)
,	O
KM_TRUNCLOGNORMAL	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"TruncLogNormal_v"	*(char)
,	O
KM_TRUNCLOGNORMALV	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"TruncNormal"	*(char)
,	O
KM_TRUNCNORMAL	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"TruncNormal_cv"	*(char)
,	O
KM_TRUNCNORMALCV	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"TruncNormal_v"	*(char)
,	O
KM_TRUNCNORMALV	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Uniform"	*(char)
,	O
KM_UNIFORM	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"UserSpecifiedLL"	*(char)
,	O
KM_USERLL	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Prediction"	*(char)
,	O
KM_PREDICTION	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Data"	*(char)
,	O
KM_DATA	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Euler"	*(char)
,	O
KM_EULER	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Lsodes"	*(char)
,	O
KM_LSODES	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"LSODES"	*(char)
,	O
KM_LSODES	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Cvodes"	*(char)
,	O
KM_CVODES	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"CVODES"	*(char)
,	O
KM_CVODES	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Forward"	*(char)
,	O
KM_FORWARD	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Backward"	*(char)
,	O
KM_BACKWARD	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Replace"	*(char)
,	O
KM_REPLACE	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Add"	*(char)
,	O
KM_ADD	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
"Multiply"	*(char)
,	O
KM_MULTIPLY	O
,	O
CN_FUNCARG	O
}	O
,	O
{	O
""	*(char)
,	O
0	int
,	O
CN_ALL	O
}	O
}	O
;	O
int	O
GetKeywordCode	O
(	O
PSTR	*(char)
szKeyword	O
,	O
PINT	*(int)
pfContext	O
)	O
{	O
PKM	O
pkm	O
=	O
&	O
vrgkmKeywordMap	O
[	O
0	int
]	O
;	O
while	O
(	O
*	O
pkm	O
->	O
szKeyword	O
&&	O
MyStrcmp	O
(	O
szKeyword	O
,	O
pkm	O
->	O
szKeyword	O
)	O
)	O
pkm	O
++	O
;	O
if	O
(	O
pfContext	O
)	O
*	O
pfContext	O
=	O
pkm	O
->	O
fContext	O
;	O
return	O
(	O
pkm	O
->	O
iKWCode	O
)	O
;	O
}	O
int	O
GetKeywordCode_in_context	O
(	O
PSTR	*(char)
szKeyword	O
,	O
WORD	int
fContext	O
)	O
{	O
PKM	O
pkm	O
=	O
&	O
vrgkmKeywordMap	O
[	O
0	int
]	O
;	O
while	O
(	O
*	O
pkm	O
->	O
szKeyword	O
&&	O
!	O
(	O
(	O
pkm	O
->	O
fContext	O
==	O
fContext	O
)	O
&&	O
!	O
MyStrcmp	O
(	O
szKeyword	O
,	O
pkm	O
->	O
szKeyword	O
)	O
)	O
)	O
pkm	O
++	O
;	O
return	O
(	O
pkm	O
->	O
iKWCode	O
)	O
;	O
}	O
PSTR	*(char)
GetKeyword	O
(	O
int	O
iKWCode	O
)	O
{	O
PKM	O
pkm	O
=	O
&	O
vrgkmKeywordMap	O
[	O
0	int
]	O
;	O
while	O
(	O
*	O
pkm	O
->	O
szKeyword	O
&&	O
iKWCode	O
!=	O
pkm	O
->	O
iKWCode	O
)	O
pkm	O
++	O
;	O
return	O
(	O
pkm	O
->	O
szKeyword	O
)	O
;	O
}	O
BOOL	int
YesNoFromLex	O
(	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
int	O
ikwcode	O
=	O
GetKeywordCode	O
(	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
BOOL	int
bReturn	O
;	O
bReturn	O
=	O
(	O
!	O
isalpha	(int)->(int)
(	O
szLex	*(char)
[	O
0	int
]	O
)	O
?	O
atoi	(*(char))->(int)
(	O
szLex	*(char)
)	O
:	O
ikwcode	O
==	O
KM_YES	O
?	O
TRUE	O
:	O
ikwcode	O
==	O
KM_NO	O
?	O
FALSE	O
:	O
FALSE	O
)	O
;	O
return	O
bReturn	O
;	O
}	O
long	O
ImFromLex	O
(	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
int	O
ikwcode	O
=	O
GetKeywordCode	O
(	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
long	O
lReturn	O
;	O
lReturn	O
=	O
(	O
!	O
isalpha	(int)->(int)
(	O
szLex	*(char)
[	O
0	int
]	O
)	O
?	O
atoi	(*(char))->(int)
(	O
szLex	*(char)
)	O
:	O
ikwcode	O
==	O
KM_LSODES	O
?	O
IAL_LSODES	O
:	O
ikwcode	O
==	O
KM_CVODES	O
?	O
IAL_CVODES	O
:	O
ikwcode	O
==	O
KM_EULER	O
?	O
IAL_EULER	O
:	O
0	int
)	O
;	O
if	O
(	O
!	O
lReturn	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Warning: Unknown integrator specification (%s) -\n"	*(char)
"         Switching to Lsodes with default options\n\n"	*(char)
,	O
szLex	*(char)
)	O
;	O
lReturn	O
=	O
IAL_DEFAULT	O
;	O
}	O
if	O
(	O
ikwcode	O
==	O
KM_CVODES	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Warning: Cvodes libraries are not available -\n"	*(char)
"         Switching to Lsodes with default options\n\n"	*(char)
)	O
;	O
lReturn	O
=	O
IAL_DEFAULT	O
;	O
}	O
return	O
(	O
lReturn	O
)	O
;	O
}	O
int	O
McvFromLex	O
(	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
int	O
ikwcode	O
=	O
GetKeywordCode	O
(	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
int	O
iReturn	O
;	O
iReturn	O
=	O
(	O
ikwcode	O
==	O
KM_UNIFORM	O
?	O
MCV_UNIFORM	O
:	O
ikwcode	O
==	O
KM_LOGUNIFORM	O
?	O
MCV_LOGUNIFORM	O
:	O
ikwcode	O
==	O
KM_BETA	O
?	O
MCV_BETA	O
:	O
ikwcode	O
==	O
KM_NORMAL	O
?	O
MCV_NORMAL	O
:	O
ikwcode	O
==	O
KM_HALFNORMAL	O
?	O
MCV_HALFNORMAL	O
:	O
ikwcode	O
==	O
KM_LOGNORMAL	O
?	O
MCV_LOGNORMAL	O
:	O
ikwcode	O
==	O
KM_TRUNCNORMAL	O
?	O
MCV_TRUNCNORMAL	O
:	O
ikwcode	O
==	O
KM_TRUNCLOGNORMAL	O
?	O
MCV_TRUNCLOGNORMAL	O
:	O
ikwcode	O
==	O
KM_CHI2	O
?	O
MCV_CHI2	O
:	O
ikwcode	O
==	O
KM_BINOMIAL	O
?	O
MCV_BINOMIAL	O
:	O
ikwcode	O
==	O
KM_PIECEWISE	O
?	O
MCV_PIECEWISE	O
:	O
ikwcode	O
==	O
KM_EXPONENTIAL	O
?	O
MCV_EXPONENTIAL	O
:	O
ikwcode	O
==	O
KM_GGAMMA	O
?	O
MCV_GGAMMA	O
:	O
ikwcode	O
==	O
KM_POISSON	O
?	O
MCV_POISSON	O
:	O
ikwcode	O
==	O
KM_INVGGAMMA	O
?	O
MCV_INVGGAMMA	O
:	O
ikwcode	O
==	O
KM_TRUNCINVGGAMMA	O
?	O
MCV_TRUNCINVGGAMMA	O
:	O
ikwcode	O
==	O
KM_NORMALV	O
?	O
MCV_NORMALV	O
:	O
ikwcode	O
==	O
KM_NORMALCV	O
?	O
MCV_NORMALCV	O
:	O
ikwcode	O
==	O
KM_LOGNORMALV	O
?	O
MCV_LOGNORMALV	O
:	O
ikwcode	O
==	O
KM_TRUNCNORMALV	O
?	O
MCV_TRUNCNORMALV	O
:	O
ikwcode	O
==	O
KM_TRUNCNORMALCV	O
?	O
MCV_TRUNCNORMALCV	O
:	O
ikwcode	O
==	O
KM_TRUNCLOGNORMALV	O
?	O
MCV_TRUNCLOGNORMALV	O
:	O
ikwcode	O
==	O
KM_BINOMIALBETA	O
?	O
MCV_BINOMIALBETA	O
:	O
ikwcode	O
==	O
KM_GENLOGNORMAL	O
?	O
MCV_GENLOGNORMAL	O
:	O
ikwcode	O
==	O
KM_STUDENTT	O
?	O
MCV_STUDENTT	O
:	O
ikwcode	O
==	O
KM_CAUCHY	O
?	O
MCV_CAUCHY	O
:	O
ikwcode	O
==	O
KM_HALFCAUCHY	O
?	O
MCV_HALFCAUCHY	O
:	O
ikwcode	O
==	O
KM_USERLL	O
?	O
MCV_USERLL	O
:	O
(	O
-	O
1	int
)	O
)	O
;	O
return	O
iReturn	O
;	O
}	O
int	O
GetTerminator	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
int	O
iErr	O
;	O
if	O
(	O
(	O
iErr	O
=	O
!	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_STMTTERM	O
)	O
)	O
)	O
{	O
szLex	*(char)
[	O
1	int
]	O
=	O
CH_STMTTERM	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_EXPECTED	O
,	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
iErr	O
)	O
;	O
}	O
BOOL	int
GetSimType	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
{	O
static	O
int	O
vrgiAtArgTypes	O
[	O
NAT_ARGS	O
]	O
=	O
{	O
LX_IDENTIFIER	O
}	O
;	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pInfo	*(void)
;	O
int	O
iAT	O
=	O
AT_DEFAULTSIM	O
;	O
int	O
iKwCode	O
=	O
0	int
;	O
BOOL	int
bErr	O
=	O
!	O
GetFuncArgs	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),int,*(int),*(char))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
NAT_ARGS	O
,	O
vrgiAtArgTypes	O
,	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
bErr	O
)	O
{	O
iKwCode	O
=	O
GetKeywordCode	O
(	O
vrgszlexArgs	O
[	O
0	int
]	O
,	O
NULL	O
)	O
;	O
switch	O
(	O
iKwCode	O
)	O
{	O
case	O
KM_MONTECARLO	O
:	O
iAT	O
=	O
AT_MONTECARLO	O
;	O
break	O
;	O
case	O
KM_SETPOINTS	O
:	O
iAT	O
=	O
AT_SETPOINTS	O
;	O
break	O
;	O
case	O
KM_MCMC	O
:	O
iAT	O
=	O
AT_MCMC	O
;	O
break	O
;	O
case	O
KM_OPTDESIGN	O
:	O
iAT	O
=	O
AT_OPTDESIGN	O
;	O
break	O
;	O
case	O
KM_DEFAULTSIM	O
:	O
iAT	O
=	O
AT_DEFAULTSIM	O
;	O
break	O
;	O
default	O
:	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_SPECERR	O
|	O
RE_FATAL	O
,	O
"Unknown SimType "	*(char)
,	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
printf	(*(char))->(int)
(	O
"Syntax: %s (Normal | MonteCarlo | SetPoints | MCMC)\n"	*(char)
"  -- if not specified, the first spec section will be used.\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_SIMTYPE	O
)	O
)	O
;	O
if	O
(	O
!	O
bErr	O
)	O
panal	O
->	O
iType	int
=	O
iAT	O
;	O
return	O
(	O
bErr	O
)	O
;	O
}	O
BOOL	int
GetPerks	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
PGIBBSDATA	O
pgd	O
)	O
{	O
int	O
iType	int
;	O
int	O
i	O
;	O
BOOL	int
bOK	O
=	O
TRUE	O
;	O
BOOL	int
bErr	O
=	O
FALSE	O
;	O
if	O
(	O
(	O
bErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_LPAREN	O
)	O
)	O
)	O
goto	O
Exit_GetPerks	O
;	O
if	O
(	O
(	O
bErr	O
=	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_INTEGER	O
)	O
)	O
)	O
goto	O
Exit_GetPerks	O
;	O
pgd	O
->	O
nPerks	O
=	O
atoi	(*(char))->(int)
(	O
szLex	*(char)
)	O
;	O
if	O
(	O
(	O
bErr	O
=	O
(	O
pgd	O
->	O
nPerks	O
<=	O
0	int
)	O
)	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"positive-integer"	*(char)
,	O
szLex	*(char)
)	O
;	O
goto	O
Exit_GetPerks	O
;	O
}	O
pgd	O
->	O
endT	O
=	O
pgd	O
->	O
nPerks	O
-	O
1	int
;	O
if	O
(	O
!	O
(	O
pgd	O
->	O
rgdPerks	O
=	O
InitdVector	(long)->(*(double))
(	O
pgd	O
->	O
nPerks	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetPerks"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pgd	O
->	O
rgdlnPi	O
=	O
InitdVector	(long)->(*(double))
(	O
pgd	O
->	O
nPerks	O
)	O
)	O
||	O
!	O
(	O
pgd	O
->	O
rglCount	O
=	O
InitlVector	(long)->(*(long))
(	O
pgd	O
->	O
nPerks	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetPerks"	*(char)
,	O
NULL	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
pgd	O
->	O
nPerks	O
&&	O
bOK	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
!	O
(	O
bOK	O
=	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
)	O
)	O
{	O
szLex	*(char)
[	O
0	int
]	O
=	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
++	O
;	O
szLex	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
","	*(char)
,	O
szLex	*(char)
)	O
;	O
}	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
(	O
bOK	O
&=	O
(	O
iType	int
&	O
LX_NUMBER	O
)	O
>	O
0	int
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"number"	*(char)
,	O
szLex	*(char)
)	O
;	O
pgd	O
->	O
rgdPerks	O
[	O
i	O
]	O
=	O
atof	(*(char))->(double)
(	O
szLex	*(char)
)	O
;	O
pgd	O
->	O
rgdlnPi	O
[	O
i	O
]	O
=	O
0	int
;	O
pgd	O
->	O
rglCount	O
[	O
i	O
]	O
=	O
0	int
;	O
if	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
i	O
]	O
<	O
0	int
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"positive inverse temperature"	*(char)
,	O
szLex	*(char)
)	O
;	O
if	O
(	O
(	O
i	O
>	O
0	int
)	O
&&	O
(	O
pgd	O
->	O
rgdPerks	O
[	O
i	O
]	O
<=	O
pgd	O
->	O
rgdPerks	O
[	O
i	O
-	O
1	int
]	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_SPECERR	O
|	O
RE_FATAL	O
,	O
"Inverse temperatures out of order"	*(char)
,	O
NULL	O
)	O
;	O
}	O
bErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_RPAREN	O
)	O
;	O
Exit_GetPerks	O
:	O
if	O
(	O
bErr	O
)	O
printf	(*(char))->(int)
(	O
"Syntax: Inverse temperatures (nPerks, "	*(char)
"<n increasing inverse temperature values >= 0>)\n\n"	*(char)
)	O
;	O
return	O
(	O
!	O
bErr	O
)	O
;	O
}	O
BOOL	int
GetIntegrate	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PINTSPEC	*(struct(int,long,long,long,double,double,long,long,long,long,*(long),*(double),double))
pis	O
)	O
{	O
static	O
int	O
vrgiIntArgTypes	O
[	O
NINT_ARGS	O
]	O
=	O
{	O
LX_IDENTIFIER	O
,	O
LX_NUMBER	O
,	O
LX_NUMBER	O
,	O
LX_INTEGER	O
}	O
;	O
BOOL	int
bErr	O
=	O
!	O
GetFuncArgs	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),int,*(int),*(char))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
NINT_ARGS	O
,	O
vrgiIntArgTypes	O
,	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
bErr	O
)	O
{	O
pis	O
->	O
iAlgo	int
=	O
ImFromLex	O
(	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
pis	O
->	O
iAlgo	int
==	O
IAL_LSODES	O
)	O
{	O
pis	O
->	O
dRtol	double
=	O
atof	(*(char))->(double)
(	O
vrgszlexArgs	O
[	O
1	int
]	O
)	O
;	O
pis	O
->	O
dAtol	double
=	O
atof	(*(char))->(double)
(	O
vrgszlexArgs	O
[	O
2	int
]	O
)	O
;	O
pis	O
->	O
iMf	long
=	O
atoi	(*(char))->(int)
(	O
vrgszlexArgs	O
[	O
3	int
]	O
)	O
;	O
switch	O
(	O
pis	O
->	O
iMf	long
)	O
{	O
case	O
0	int
:	O
pis	O
->	O
iMf	long
=	O
10	int
;	O
break	O
;	O
case	O
1	int
:	O
pis	O
->	O
iMf	long
=	O
222	int
;	O
break	O
;	O
case	O
2	int
:	O
pis	O
->	O
iMf	long
=	O
121	int
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"Error: method flag must be 0, 1 or 2 for Lsodes - "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"Exiting\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
break	O
;	O
}	O
pis	O
->	O
iDSFlag	long
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
pis	O
->	O
iAlgo	int
==	O
IAL_CVODES	O
)	O
{	O
pis	O
->	O
dRtol	double
=	O
atof	(*(char))->(double)
(	O
vrgszlexArgs	O
[	O
1	int
]	O
)	O
;	O
pis	O
->	O
dAtol	double
=	O
atof	(*(char))->(double)
(	O
vrgszlexArgs	O
[	O
2	int
]	O
)	O
;	O
pis	O
->	O
iMf	long
=	O
atoi	(*(char))->(int)
(	O
vrgszlexArgs	O
[	O
3	int
]	O
)	O
;	O
if	O
(	O
pis	O
->	O
iMf	long
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
"Using CVODES serial\n\n"	*(char)
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Warning: last flag for Cvodes is currently ignored.\n\n"	*(char)
)	O
;	O
pis	O
->	O
iMf	long
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
pis	O
->	O
iAlgo	int
==	O
IAL_EULER	O
)	O
{	O
pis	O
->	O
dTStep	double
=	O
atof	(*(char))->(double)
(	O
vrgszlexArgs	O
[	O
1	int
]	O
)	O
;	O
if	O
(	O
pis	O
->	O
dTStep	double
<=	O
0	int
)	O
printf	(*(char))->(int)
(	O
"Warning: Time step specified is null or negative -\n"	*(char)
"         Resetting to 1\n\n"	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Error: Unknown integration method: %s - Exiting\n\n"	*(char)
,	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Syntax: %s (Lsodes, Relative tolerance, Absolute tolerance, "	*(char)
"Method)\n"	*(char)
"        or %s (CVODES, Relative tolerance, Absolute tolerance, "	*(char)
"0)\n"	*(char)
"        or %s (Euler, Time step, 0, 0)\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_INTEGRATE	O
)	O
,	O
GetKeyword	O
(	O
KM_INTEGRATE	O
)	O
,	O
GetKeyword	O
(	O
KM_INTEGRATE	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
return	O
(	O
bErr	O
)	O
;	O
}	O
int	O
OneDToArray	O
(	O
PVOID	*(void)
pData	*(void)
,	O
PVOID	*(void)
pInfo	*(void)
)	O
{	O
PDOUBLE	*(double)
*	O
ppdArrayVal	O
=	O
(	O
PDOUBLE	*(double)
*	O
)	O
pInfo	*(void)
;	O
*	O
(	O
*	O
ppdArrayVal	O
)	O
++	O
=	O
*	O
(	O
PDOUBLE	*(double)
)	O
pData	*(void)
;	O
return	O
0	int
;	O
}	O
void	O
DListToArray	O
(	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
PLONG	*(long)
pcDouble	O
,	O
PDOUBLE	*(double)
*	O
ppDouble	O
)	O
{	O
PDOUBLE	*(double)
pdTmp	O
;	O
*	O
pcDouble	O
=	O
ListLength	O
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
;	O
if	O
(	O
!	O
(	O
pdTmp	O
=	O
*	O
ppDouble	O
=	O
InitdVector	(long)->(*(double))
(	O
*	O
pcDouble	O
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"DListToArray"	*(char)
,	O
NULL	O
)	O
;	O
ForAllList	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void))->(int)),*(void))->(int)
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
&	O
OneDToArray	O
,	O
(	O
PVOID	*(void)
)	O
&	O
pdTmp	O
)	O
;	O
}	O
BOOL	int
GetListOfTimes	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
int	O
nRecs	O
,	O
PPRINTREC	*(struct(*(char),long,long,*(double)))
*	O
ppr	O
,	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plistTimes	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
PDOUBLE	*(double)
pdTmp	O
;	O
int	O
iNLI	O
,	O
i	O
,	O
j	O
;	O
BOOL	int
bErr	O
;	O
do	O
{	O
if	O
(	O
!	O
(	O
pdTmp	O
=	O
InitdVector	(long)->(*(double))
(	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
NULL	O
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetListOfTimes"	*(char)
,	O
NULL	O
)	O
;	O
*	O
pdTmp	O
=	O
atof	(*(char))->(double)
(	O
szLex	*(char)
)	O
;	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
plistTimes	O
,	O
(	O
PVOID	*(void)
)	O
pdTmp	O
)	O
;	O
}	O
while	O
(	O
(	O
iNLI	O
=	O
NextListItem	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),int,int,char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_NUMBER	O
,	O
1	int
,	O
CH_RPAREN	O
)	O
)	O
>	O
0	int
)	O
;	O
if	O
(	O
!	O
iNLI	O
)	O
bErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_RPAREN	O
)	O
||	O
!	O
ListLength	O
(	O
plistTimes	O
)	O
;	O
else	O
{	O
bErr	O
=	O
TRUE	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
"number"	*(char)
,	O
szLex	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
bErr	O
)	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nRecs	O
;	O
++	O
i	O
)	O
DListToArray	O
(	O
plistTimes	O
,	O
&	O
ppr	O
[	O
i	O
]	O
->	O
cTimes	long
,	O
&	O
ppr	O
[	O
i	O
]	O
->	O
pdTimes	*(double)
)	O
;	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
&	O
plistTimes	O
,	O
NULL	O
,	O
TRUE	O
)	O
;	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<	O
ppr	O
[	O
0	int
]	O
->	O
cTimes	long
&&	O
!	O
bErr	O
;	O
i	O
++	O
)	O
if	O
(	O
(	O
bErr	O
=	O
(	O
*	O
(	O
ppr	O
[	O
0	int
]	O
->	O
pdTimes	*(double)
+	O
i	O
)	O
<=	O
*	O
(	O
ppr	O
[	O
0	int
]	O
->	O
pdTimes	*(double)
+	O
i	O
-	O
1	int
)	O
)	O
)	O
)	O
{	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
nRecs	O
;	O
++	O
j	O
)	O
free	(*(void))->(void)
(	O
ppr	O
[	O
j	O
]	O
->	O
pdTimes	*(double)
)	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_SPECERR	O
|	O
RE_FATAL	O
,	O
"Times out of order"	*(char)
,	O
NULL	O
)	O
;	O
}	O
return	O
(	O
bErr	O
)	O
;	O
}	O
BOOL	int
GetListOfData	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PDATAREC	*(struct(*(char),long,long,*(double)))
pda	O
,	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plistData	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
PDOUBLE	*(double)
pdTmp	O
;	O
int	O
iNLI	O
;	O
BOOL	int
bErr	O
;	O
while	O
(	O
(	O
iNLI	O
=	O
NextListItem	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),int,int,char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_NUMBER	O
,	O
1	int
,	O
CH_RPAREN	O
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
!	O
(	O
pdTmp	O
=	O
InitdVector	(long)->(*(double))
(	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetListOfData"	*(char)
,	O
NULL	O
)	O
;	O
*	O
pdTmp	O
=	O
atof	(*(char))->(double)
(	O
szLex	*(char)
)	O
;	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
plistData	O
,	O
(	O
PVOID	*(void)
)	O
pdTmp	O
)	O
;	O
}	O
if	O
(	O
!	O
iNLI	O
)	O
bErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_RPAREN	O
)	O
||	O
!	O
ListLength	O
(	O
plistData	O
)	O
;	O
else	O
{	O
bErr	O
=	O
TRUE	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
"number"	*(char)
,	O
szLex	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
bErr	O
)	O
DListToArray	O
(	O
plistData	O
,	O
&	O
pda	O
->	O
cData	long
,	O
&	O
pda	O
->	O
pdData	*(double)
)	O
;	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
&	O
plistData	O
,	O
NULL	O
,	O
TRUE	O
)	O
;	O
return	O
(	O
bErr	O
)	O
;	O
}	O
BOOL	int
bGavePrintUsage	O
=	O
FALSE	O
;	O
BOOL	int
GetPrint	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
)	O
{	O
PPRINTREC	*(struct(*(char),long,long,*(double)))
pprintrec	O
[	O
MAX_PRINT_VARS	O
]	O
;	O
BOOL	int
bErr	O
=	O
FALSE	O
;	O
HVAR	long
hvar	long
;	O
int	O
nVars	O
=	O
0	int
,	O
n	int
,	O
iLex	O
;	O
long	O
i	O
,	O
iLB	O
,	O
iUB	O
;	O
PSTRLEX	array(char)
szTmp	O
;	O
if	O
(	O
!	O
(	O
bErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_LPAREN	O
)	O
)	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
iLex	O
)	O
;	O
if	O
(	O
iLex	O
!=	O
LX_IDENTIFIER	O
)	O
break	O
;	O
iLB	O
=	O
iUB	O
=	O
-	O
1	int
;	O
if	O
(	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
'['	O
)	O
)	O
GetArrayBounds	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(long),*(long))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
&	O
iLB	O
,	O
&	O
iUB	O
)	O
;	O
if	O
(	O
iUB	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
nVars	O
==	O
MAX_PRINT_VARS	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_TOOMANYPVARS	O
|	O
RE_FATAL	O
,	O
"GetPrint"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
bErr	O
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szLex	*(char)
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_UNDEFINED	O
|	O
RE_FATAL	O
,	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pprintrec	O
[	O
nVars	O
]	O
=	O
(	O
PPRINTREC	*(struct(*(char),long,long,*(double)))
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
PRINTREC	struct(*(char),long,long,*(double))
)	O
)	O
)	O
||	O
!	O
(	O
pprintrec	O
[	O
nVars	O
]	O
->	O
szOutputName	*(char)
=	O
(	O
PSTR	*(char)
)	O
malloc	(long)->(*(void))
(	O
MyStrlen	O
(	O
szLex	*(char)
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetPrint"	*(char)
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
pprintrec	O
[	O
nVars	O
]	O
->	O
szOutputName	*(char)
,	O
szLex	*(char)
)	O
;	O
pprintrec	O
[	O
nVars	O
]	O
->	O
hvar	long
=	O
hvar	long
;	O
assert	O
(	O
pprintrec	O
[	O
nVars	O
]	O
)	O
;	O
++	O
nVars	O
;	O
}	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	O
=	O
iLB	O
;	O
i	O
<	O
iUB	O
;	O
i	O
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
szTmp	O
,	O
"%s_%ld"	*(char)
,	O
szLex	*(char)
,	O
i	O
)	O
;	O
if	O
(	O
nVars	O
==	O
MAX_PRINT_VARS	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_TOOMANYPVARS	O
|	O
RE_FATAL	O
,	O
"GetPrint"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
bErr	O
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szTmp	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_UNDEFINED	O
|	O
RE_FATAL	O
,	O
szTmp	O
,	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pprintrec	O
[	O
nVars	O
]	O
=	O
(	O
PPRINTREC	*(struct(*(char),long,long,*(double)))
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
PRINTREC	struct(*(char),long,long,*(double))
)	O
)	O
)	O
||	O
!	O
(	O
pprintrec	O
[	O
nVars	O
]	O
->	O
szOutputName	*(char)
=	O
(	O
PSTR	*(char)
)	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
szTmp	O
)	O
+	O
1	int
)	O
)	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetPrint"	*(char)
,	O
NULL	O
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
pprintrec	O
[	O
nVars	O
]	O
->	O
szOutputName	*(char)
,	O
szTmp	O
)	O
;	O
pprintrec	O
[	O
nVars	O
]	O
->	O
hvar	long
=	O
hvar	long
;	O
assert	O
(	O
pprintrec	O
[	O
nVars	O
]	O
)	O
;	O
++	O
nVars	O
;	O
}	O
if	O
(	O
i	O
==	O
(	O
iUB	O
-	O
1	int
)	O
)	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
','	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
nVars	O
<	O
1	int
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
"identifier"	*(char)
,	O
szLex	*(char)
)	O
;	O
bErr	O
=	O
GetListOfTimes	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
nVars	O
,	O
pprintrec	O
,	O
szLex	*(char)
)	O
;	O
if	O
(	O
bErr	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nVars	O
;	O
++	O
n	int
)	O
{	O
free	(*(void))->(void)
(	O
pprintrec	O
[	O
n	int
]	O
->	O
szOutputName	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pprintrec	O
[	O
n	int
]	O
)	O
;	O
}	O
}	O
else	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nVars	O
;	O
++	O
n	int
)	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
pos	O
->	O
plistPrintRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
(	O
PVOID	*(void)
)	O
pprintrec	O
[	O
n	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
bErr	O
)	O
bErr	O
=	O
GetTerminator	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
!	O
bGavePrintUsage	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Syntax: %s (<Identifiers>, Time1, Time2, ...)\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_PRINT	O
)	O
)	O
;	O
bGavePrintUsage	O
=	O
TRUE	O
;	O
}	O
}	O
return	O
(	O
bErr	O
)	O
;	O
}	O
BOOL	int
bGavePrintStepUsage	O
=	O
FALSE	O
;	O
BOOL	int
GetPrintStep	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
)	O
{	O
PPRINTREC	*(struct(*(char),long,long,*(double)))
pprintrec	O
[	O
MAX_PRINT_VARS	O
]	O
;	O
BOOL	int
bErr	O
=	O
FALSE	O
,	O
bOK	O
=	O
TRUE	O
;	O
HVAR	long
hvar	long
=	O
0	int
;	O
int	O
nVars	O
=	O
0	int
,	O
n	int
,	O
iLex	O
;	O
long	O
i	O
,	O
iLB	O
,	O
iUB	O
;	O
double	O
dStart	O
=	O
0	int
,	O
dEnd	O
=	O
0	int
,	O
dStep	O
=	O
0	int
,	O
dTmp	O
;	O
PSTRLEX	array(char)
szTmp	O
;	O
bErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_LPAREN	O
)	O
;	O
if	O
(	O
bErr	O
)	O
goto	O
Exit_GetPrintStep	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
iLex	O
)	O
;	O
if	O
(	O
iLex	O
!=	O
LX_IDENTIFIER	O
)	O
break	O
;	O
iLB	O
=	O
iUB	O
=	O
-	O
1	int
;	O
if	O
(	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
'['	O
)	O
)	O
GetArrayBounds	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(long),*(long))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
&	O
iLB	O
,	O
&	O
iUB	O
)	O
;	O
if	O
(	O
iUB	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
nVars	O
==	O
MAX_PRINT_VARS	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_TOOMANYPVARS	O
|	O
RE_FATAL	O
,	O
"GetPrint"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
bErr	O
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szLex	*(char)
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_UNDEFINED	O
|	O
RE_FATAL	O
,	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pprintrec	O
[	O
nVars	O
]	O
=	O
(	O
PPRINTREC	*(struct(*(char),long,long,*(double)))
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
PRINTREC	struct(*(char),long,long,*(double))
)	O
)	O
)	O
||	O
!	O
(	O
pprintrec	O
[	O
nVars	O
]	O
->	O
szOutputName	*(char)
=	O
(	O
PSTR	*(char)
)	O
malloc	(long)->(*(void))
(	O
MyStrlen	O
(	O
szLex	*(char)
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetPrint"	*(char)
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
pprintrec	O
[	O
nVars	O
]	O
->	O
szOutputName	*(char)
,	O
szLex	*(char)
)	O
;	O
pprintrec	O
[	O
nVars	O
]	O
->	O
hvar	long
=	O
hvar	long
;	O
assert	O
(	O
pprintrec	O
[	O
nVars	O
]	O
)	O
;	O
++	O
nVars	O
;	O
}	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	O
=	O
iLB	O
;	O
i	O
<	O
iUB	O
;	O
i	O
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
szTmp	O
,	O
"%s_%ld"	*(char)
,	O
szLex	*(char)
,	O
i	O
)	O
;	O
if	O
(	O
nVars	O
==	O
MAX_PRINT_VARS	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_TOOMANYPVARS	O
|	O
RE_FATAL	O
,	O
"GetPrint"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
bErr	O
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szTmp	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_UNDEFINED	O
|	O
RE_FATAL	O
,	O
szTmp	O
,	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pprintrec	O
[	O
nVars	O
]	O
=	O
(	O
PPRINTREC	*(struct(*(char),long,long,*(double)))
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
PRINTREC	struct(*(char),long,long,*(double))
)	O
)	O
)	O
||	O
!	O
(	O
pprintrec	O
[	O
nVars	O
]	O
->	O
szOutputName	*(char)
=	O
(	O
PSTR	*(char)
)	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
szTmp	O
)	O
+	O
1	int
)	O
)	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetPrint"	*(char)
,	O
NULL	O
)	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
pprintrec	O
[	O
nVars	O
]	O
->	O
szOutputName	*(char)
,	O
szTmp	O
)	O
;	O
pprintrec	O
[	O
nVars	O
]	O
->	O
hvar	long
=	O
hvar	long
;	O
assert	O
(	O
pprintrec	O
[	O
nVars	O
]	O
)	O
;	O
++	O
nVars	O
;	O
}	O
if	O
(	O
i	O
==	O
(	O
iUB	O
-	O
1	int
)	O
)	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
','	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
nVars	O
<	O
1	int
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
"identifier"	*(char)
,	O
szLex	*(char)
)	O
;	O
bErr	O
=	O
TRUE	O
;	O
goto	O
Exit_GetPrintStep	O
;	O
}	O
dStart	O
=	O
atof	(*(char))->(double)
(	O
szLex	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
bOK	O
=	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
","	*(char)
,	O
szLex	*(char)
)	O
;	O
if	O
(	O
(	O
bErr	O
=	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_NUMBER	O
)	O
)	O
)	O
goto	O
Exit_GetPrintStep	O
;	O
dEnd	O
=	O
atof	(*(char))->(double)
(	O
szLex	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
bOK	O
=	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
","	*(char)
,	O
szLex	*(char)
)	O
;	O
if	O
(	O
(	O
bErr	O
=	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_NUMBER	O
)	O
)	O
)	O
goto	O
Exit_GetPrintStep	O
;	O
dStep	O
=	O
atof	(*(char))->(double)
(	O
szLex	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
bOK	O
=	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_RPAREN	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
")"	*(char)
,	O
szLex	*(char)
)	O
;	O
if	O
(	O
(	O
bErr	O
=	O
(	O
dEnd	O
<=	O
dStart	O
)	O
)	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_SPECERR	O
,	O
"End_time must be > Start_time"	*(char)
,	O
NULL	O
)	O
;	O
goto	O
Exit_GetPrintStep	O
;	O
}	O
else	O
if	O
(	O
(	O
bErr	O
=	O
(	O
dStep	O
>	O
(	O
dEnd	O
-	O
dStart	O
)	O
)	O
)	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_SPECERR	O
,	O
"Time_step too large"	*(char)
,	O
NULL	O
)	O
;	O
goto	O
Exit_GetPrintStep	O
;	O
}	O
dTmp	O
=	O
1	int
+	O
ceil	(double)->(double)
(	O
(	O
dEnd	O
-	O
dStart	O
)	O
/	O
dStep	O
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nVars	O
;	O
++	O
n	int
)	O
{	O
if	O
(	O
dTmp	O
<	O
LONG_MAX	O
)	O
pprintrec	O
[	O
n	int
]	O
->	O
cTimes	long
=	O
(	O
long	O
)	O
dTmp	O
;	O
else	O
pprintrec	O
[	O
n	int
]	O
->	O
cTimes	long
=	O
LONG_MAX	O
;	O
}	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nVars	O
;	O
++	O
n	int
)	O
{	O
if	O
(	O
!	O
(	O
pprintrec	O
[	O
n	int
]	O
->	O
pdTimes	*(double)
=	O
InitdVector	(long)->(*(double))
(	O
pprintrec	O
[	O
n	int
]	O
->	O
cTimes	long
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetPrintStep"	*(char)
,	O
NULL	O
)	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
pprintrec	O
[	O
n	int
]	O
->	O
cTimes	long
-	O
1	int
;	O
i	O
++	O
)	O
pprintrec	O
[	O
n	int
]	O
->	O
pdTimes	*(double)
[	O
i	O
]	O
=	O
dStart	O
+	O
(	O
i	O
*	O
dStep	O
)	O
;	O
pprintrec	O
[	O
n	int
]	O
->	O
pdTimes	*(double)
[	O
pprintrec	O
[	O
n	int
]	O
->	O
cTimes	long
-	O
1	int
]	O
=	O
dEnd	O
;	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
pos	O
->	O
plistPrintRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
(	O
PVOID	*(void)
)	O
pprintrec	O
[	O
n	int
]	O
)	O
;	O
}	O
Exit_GetPrintStep	O
:	O
if	O
(	O
bErr	O
)	O
if	O
(	O
!	O
bGavePrintStepUsage	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Syntax: %s (<Identifiers>, Start_time, End_time, Time_step)\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_PRINTSTEP	O
)	O
)	O
;	O
bGavePrintStepUsage	O
=	O
TRUE	O
;	O
}	O
return	O
(	O
bErr	O
)	O
;	O
}	O
BOOL	int
bGaveDataUsage	O
=	O
FALSE	O
;	O
BOOL	int
GetData	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
)	O
{	O
PDATAREC	*(struct(*(char),long,long,*(double)))
pdatarec	O
;	O
BOOL	int
bErr	O
=	O
FALSE	O
;	O
HVAR	long
hvar	long
;	O
if	O
(	O
!	O
(	O
bErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_LPAREN	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
(	O
bErr	O
=	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_IDENTIFIER	O
)	O
)	O
)	O
{	O
if	O
(	O
(	O
bErr	O
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szLex	*(char)
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_UNDEFINED	O
,	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pdatarec	O
=	O
(	O
PDATAREC	*(struct(*(char),long,long,*(double)))
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
DATAREC	struct(*(char),long,long,*(double))
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetData"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pdatarec	O
->	O
szDataName	*(char)
=	O
(	O
PSTR	*(char)
)	O
malloc	(long)->(*(void))
(	O
MyStrlen	O
(	O
szLex	*(char)
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetData"	*(char)
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
pdatarec	O
->	O
szDataName	*(char)
,	O
szLex	*(char)
)	O
;	O
assert	O
(	O
pdatarec	O
)	O
;	O
pdatarec	O
->	O
hvar	long
=	O
hvar	long
;	O
bErr	O
=	O
GetListOfData	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
pdatarec	O
,	O
szLex	*(char)
)	O
;	O
if	O
(	O
bErr	O
)	O
{	O
free	(*(void))->(void)
(	O
pdatarec	O
->	O
szDataName	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pdatarec	O
)	O
;	O
}	O
else	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
pos	O
->	O
plistDataRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
(	O
PVOID	*(void)
)	O
pdatarec	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
bErr	O
)	O
bErr	O
=	O
GetTerminator	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
!	O
bGaveDataUsage	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Syntax: %s (identifier, Time1, Time2, ...)\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_DATA	O
)	O
)	O
;	O
bGaveDataUsage	O
=	O
TRUE	O
;	O
}	O
}	O
return	O
(	O
bErr	O
)	O
;	O
}	O
BOOL	int
GetStringArg	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
*	O
pszArg	O
,	O
PSTR	*(char)
szLex	*(char)
,	O
BOOL	int
bDelim	O
)	O
{	O
BOOL	int
bErr	O
;	O
assert	O
(	O
szLex	*(char)
)	O
;	O
if	O
(	O
bDelim	O
)	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
;	O
bErr	O
=	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_STRING	O
)	O
;	O
if	O
(	O
!	O
bErr	O
)	O
{	O
if	O
(	O
szLex	*(char)
[	O
0	int
]	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
pszArg	O
=	O
(	O
PSTR	*(char)
)	O
malloc	(long)->(*(void))
(	O
MyStrlen	O
(	O
szLex	*(char)
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetStringArg"	*(char)
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
*	O
pszArg	O
,	O
szLex	*(char)
)	O
;	O
}	O
else	O
*	O
pszArg	O
=	O
NULL	O
;	O
}	O
return	O
(	O
bErr	O
)	O
;	O
}	O
BOOL	int
GetOutputFile	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
PANALYSIS	O
panal	O
)	O
{	O
BOOL	int
bErr	O
=	O
FALSE	O
;	O
bErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_LPAREN	O
)	O
||	O
GetStringArg	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
&	O
panal	O
->	O
szOutfilename	O
,	O
szLex	*(char)
,	O
FALSE	O
)	O
;	O
if	O
(	O
!	O
bErr	O
)	O
{	O
panal	O
->	O
bAllocatedFileName	O
=	O
TRUE	O
;	O
bErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_RPAREN	O
)	O
;	O
}	O
if	O
(	O
!	O
bErr	O
)	O
bErr	O
=	O
GetTerminator	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"Syntax: %s (szOutputFilename)\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_OUTPUTFILE	O
)	O
)	O
;	O
return	O
(	O
bErr	O
)	O
;	O
}	O
BOOL	int
bGaveSimulateUsage	O
=	O
FALSE	O
;	O
BOOL	int
GetSimulate	O
(	O
)	O
{	O
if	O
(	O
!	O
bGaveSimulateUsage	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Warning: %s statements are obsolete and ignored.\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_SIMULATE	O
)	O
)	O
;	O
bGaveSimulateUsage	O
=	O
TRUE	O
;	O
}	O
return	O
(	O
1	int
)	O
;	O
}	O
BOOL	int
bGaveSrtTUsage	O
=	O
FALSE	O
;	O
BOOL	int
GetStartTime	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PEXPERIMENT	O
pexp	O
)	O
{	O
static	O
int	O
vrgiSimArgTypes	O
[	O
1	int
]	O
=	O
{	O
LX_NUMBER	O
|	O
LX_IDENTIFIER	O
}	O
;	O
BOOL	int
bErr	O
=	O
!	O
GetFuncArgs	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),int,*(int),*(char))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
1	int
,	O
vrgiSimArgTypes	O
,	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
bErr	O
)	O
{	O
if	O
(	O
!	O
DefDepParm	(*(char),*(double),*(long))->(int)
(	O
vrgszlexArgs	O
[	O
0	int
]	O
,	O
&	O
pexp	O
->	O
dT0	double
,	O
&	O
pexp	O
->	O
hT0	long
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_EXPECTED	O
,	O
"StartTime spec"	*(char)
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
bGaveSrtTUsage	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Syntax: %s (InitialTime)\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_STARTTIME	O
)	O
)	O
;	O
bGaveSrtTUsage	O
=	O
TRUE	O
;	O
}	O
}	O
return	O
(	O
bErr	O
)	O
;	O
}	O
BOOL	int
GetMCMCSpec	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PEXPERIMENT	O
pexp	O
)	O
{	O
static	O
int	O
vrgiGibbsArgTypes	O
[	O
NMCMC_ARGS	O
]	O
=	O
{	O
LX_STRING	O
,	O
LX_STRING	O
,	O
LX_STRING	O
,	O
LX_INTEGER	O
,	O
LX_INTEGER	O
,	O
LX_INTEGER	O
,	O
LX_INTEGER	O
,	O
LX_NUMBER	O
}	O
;	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pInfo	*(void)
;	O
BOOL	int
bErr	O
=	O
!	O
GetFuncArgs	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),int,*(int),*(char))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
NMCMC_ARGS	O
,	O
vrgiGibbsArgTypes	O
,	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
;	O
static	O
char	O
vszGibbsOutDefault	O
[	O
]	O
=	O
"MCMC.default.out"	*(char)
;	O
if	O
(	O
!	O
bErr	O
)	O
{	O
if	O
(	O
*	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
{	O
if	O
(	O
!	O
(	O
panal	O
->	O
gd	O
.	O
szGout	O
=	O
(	O
PSTR	*(char)
)	O
malloc	(long)->(*(void))
(	O
MyStrlen	O
(	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetMCMCSpec"	*(char)
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
panal	O
->	O
gd	O
.	O
szGout	O
,	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
;	O
panal	O
->	O
bAllocatedFileName	O
=	O
TRUE	O
;	O
}	O
else	O
panal	O
->	O
gd	O
.	O
szGout	O
=	O
vszGibbsOutDefault	O
;	O
if	O
(	O
*	O
vrgszlexArgs	O
[	O
1	int
]	O
)	O
{	O
if	O
(	O
!	O
(	O
panal	O
->	O
gd	O
.	O
szGrestart	O
=	O
(	O
PSTR	*(char)
)	O
malloc	(long)->(*(void))
(	O
MyStrlen	O
(	O
vrgszlexArgs	O
[	O
1	int
]	O
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetMCMCSpec"	*(char)
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
panal	O
->	O
gd	O
.	O
szGrestart	O
,	O
vrgszlexArgs	O
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
panal	O
->	O
gd	O
.	O
szGrestart	O
!=	O
NULL	O
&&	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
panal	O
->	O
gd	O
.	O
szGout	O
,	O
panal	O
->	O
gd	O
.	O
szGrestart	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTISRESTART	O
|	O
RE_FATAL	O
,	O
"GetMCMCSpec"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
*	O
vrgszlexArgs	O
[	O
2	int
]	O
)	O
{	O
if	O
(	O
!	O
(	O
panal	O
->	O
gd	O
.	O
szGdata	O
=	O
(	O
PSTR	*(char)
)	O
malloc	(long)->(*(void))
(	O
MyStrlen	O
(	O
vrgszlexArgs	O
[	O
2	int
]	O
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetMCMCSpec"	*(char)
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
panal	O
->	O
gd	O
.	O
szGdata	O
,	O
vrgszlexArgs	O
[	O
2	int
]	O
)	O
;	O
}	O
panal	O
->	O
gd	O
.	O
nMaxIter	O
=	O
atol	(*(char))->(long)
(	O
vrgszlexArgs	O
[	O
3	int
]	O
)	O
;	O
panal	O
->	O
gd	O
.	O
nSimTypeFlag	O
=	O
atol	(*(char))->(long)
(	O
vrgszlexArgs	O
[	O
4	int
]	O
)	O
;	O
panal	O
->	O
gd	O
.	O
nPrintFreq	O
=	O
atol	(*(char))->(long)
(	O
vrgszlexArgs	O
[	O
5	int
]	O
)	O
;	O
panal	O
->	O
gd	O
.	O
nPrintIter	O
=	O
atol	(*(char))->(long)
(	O
vrgszlexArgs	O
[	O
6	int
]	O
)	O
;	O
panal	O
->	O
dSeed	double
=	O
atof	(*(char))->(double)
(	O
vrgszlexArgs	O
[	O
7	int
]	O
)	O
;	O
if	O
(	O
(	O
(	O
panal	O
->	O
gd	O
.	O
nSimTypeFlag	O
==	O
1	int
)	O
&&	O
(	O
panal	O
->	O
gd	O
.	O
szGrestart	O
==	O
NULL	O
)	O
)	O
||	O
(	O
(	O
panal	O
->	O
gd	O
.	O
nSimTypeFlag	O
==	O
2	int
)	O
&&	O
(	O
panal	O
->	O
gd	O
.	O
szGrestart	O
==	O
NULL	O
)	O
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: if simTypeFlag is one or two a restart file must be "	*(char)
"given - Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
"Syntax:\n%s (szOut, szRestart, szData, "	*(char)
"nMaxIters, simTypeFlag, nPrintFreq,\n"	*(char)
"      nIterToPrint, dSeed)\nExiting.\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_MCMC	O
)	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
bErr	O
)	O
panal	O
->	O
iType	int
=	O
AT_MCMC	O
;	O
return	O
(	O
!	O
bErr	O
)	O
;	O
}	O
BOOL	int
GetOptDSpec	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PANALYSIS	O
panal	O
,	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
PMCVAR	O
pMCVar	O
;	O
HVAR	long
hvar	long
;	O
int	O
iErr	O
=	O
0	int
;	O
int	O
iNLI	O
;	O
int	O
ikwcode	O
;	O
if	O
(	O
(	O
iErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_LPAREN	O
)	O
||	O
GetStringArg	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
&	O
panal	O
->	O
gd	O
.	O
szGout	O
,	O
szLex	*(char)
,	O
FALSE	O
)	O
||	O
GetStringArg	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
&	O
panal	O
->	O
gd	O
.	O
szGrestart	O
,	O
szLex	*(char)
,	O
TRUE	O
)	O
)	O
)	O
{	O
goto	O
Exit_GetOptDSpec	O
;	O
}	O
else	O
{	O
panal	O
->	O
bAllocatedFileName	O
=	O
TRUE	O
;	O
}	O
if	O
(	O
!	O
panal	O
->	O
gd	O
.	O
szGrestart	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_SPECERR	O
|	O
RE_FATAL	O
,	O
"Missing restart file"	*(char)
,	O
NULL	O
)	O
;	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
;	O
if	O
(	O
(	O
iErr	O
=	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_INTEGER	O
)	O
)	O
)	O
goto	O
Exit_GetOptDSpec	O
;	O
panal	O
->	O
mc	O
.	O
nRuns	O
=	O
atol	(*(char))->(long)
(	O
szLex	*(char)
)	O
;	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
;	O
if	O
(	O
(	O
iErr	O
=	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_NUMBER	O
)	O
)	O
)	O
goto	O
Exit_GetOptDSpec	O
;	O
panal	O
->	O
dSeed	double
=	O
atof	(*(char))->(double)
(	O
szLex	*(char)
)	O
;	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
;	O
if	O
(	O
(	O
iErr	O
=	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_IDENTIFIER	O
)	O
)	O
)	O
goto	O
Exit_GetOptDSpec	O
;	O
ikwcode	O
=	O
GetKeywordCode	O
(	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
ikwcode	O
==	O
KM_FORWARD	O
)	O
panal	O
->	O
mc	O
.	O
style	O
=	O
forward	O
;	O
else	O
if	O
(	O
ikwcode	O
==	O
KM_BACKWARD	O
)	O
panal	O
->	O
mc	O
.	O
style	O
=	O
backward	O
;	O
else	O
{	O
iErr	O
=	O
TRUE	O
;	O
goto	O
Exit_GetOptDSpec	O
;	O
}	O
while	O
(	O
(	O
iNLI	O
=	O
NextListItem	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),int,int,char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_IDENTIFIER	O
,	O
1	int
,	O
CH_RPAREN	O
)	O
)	O
>	O
0	int
)	O
{	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szLex	*(char)
)	O
;	O
if	O
(	O
(	O
iErr	O
=	O
(	O
!	O
hvar	long
||	O
IsInput	(long)->(int)
(	O
hvar	long
)	O
)	O
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
pMCVar	O
=	O
(	O
PMCVAR	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
MCVAR	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetOptDSpec"	*(char)
,	O
NULL	O
)	O
;	O
pMCVar	O
->	O
hvar	long
=	O
hvar	long
;	O
pMCVar	O
->	O
iType	int
=	O
MCV_SETPOINTS	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
0.0	int
;	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
panal	O
->	O
mc	O
.	O
plistMCVars	O
,	O
pMCVar	O
)	O
;	O
}	O
panal	O
->	O
mc	O
.	O
nSetParms	O
=	O
ListLength	O
(	O
panal	O
->	O
mc	O
.	O
plistMCVars	O
)	O
;	O
if	O
(	O
panal	O
->	O
mc	O
.	O
nSetParms	O
==	O
0	int
)	O
{	O
iErr	O
=	O
TRUE	O
;	O
printf	(*(char))->(int)
(	O
"\nError: you must specify a list of parameters to read.\n\n"	*(char)
)	O
;	O
goto	O
Exit_GetOptDSpec	O
;	O
}	O
if	O
(	O
!	O
iNLI	O
)	O
iErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_RPAREN	O
)	O
;	O
else	O
{	O
iErr	O
=	O
TRUE	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
"identifier"	*(char)
,	O
szLex	*(char)
)	O
;	O
}	O
Exit_GetOptDSpec	O
:	O
;	O
if	O
(	O
iErr	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Syntax:\n"	*(char)
"%s (\"Output_File\", \"Param_Sample_File\", nSamples, "	*(char)
"random_seed, <Forward or Backward>, "	*(char)
"<param-id-list...>)\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_OPTDESIGN	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"Exiting...\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
else	O
panal	O
->	O
iType	int
=	O
AT_OPTDESIGN	O
;	O
return	O
(	O
iErr	O
)	O
;	O
}	O
BOOL	int
bGaveMCVaryUsage	O
=	O
FALSE	O
;	O
int	O
GetDistribSpec	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PANALYSIS	O
panal	O
,	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
;	O
PMCVAR	O
pMCVar	O
=	O
NULL	O
;	O
HVAR	long
hvar	long
;	O
int	O
n	int
,	O
iErr	O
=	O
0	int
;	O
PSTRLEX	array(char)
szDummy	O
;	O
if	O
(	O
panal	O
->	O
iType	int
&&	O
!	O
(	O
(	O
panal	O
->	O
iType	int
==	O
AT_MONTECARLO	O
)	O
||	O
(	O
panal	O
->	O
iType	int
==	O
AT_SETPOINTS	O
)	O
||	O
(	O
panal	O
->	O
iType	int
==	O
AT_OPTDESIGN	O
)	O
||	O
(	O
panal	O
->	O
iType	int
==	O
AT_MCMC	O
)	O
)	O
)	O
{	O
EatStatement	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
goto	O
Exit_MCVarySpec	O
;	O
}	O
if	O
(	O
(	O
iErr	O
=	O
(	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_LPAREN	O
)	O
||	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_IDENTIFIER	O
)	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
GetKeywordCode	O
(	O
szLex	*(char)
,	O
NULL	O
)	O
==	O
KM_DATA	O
)	O
{	O
if	O
(	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_LPAREN	O
)	O
)	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_IDENTIFIER	O
)	O
;	O
if	O
(	O
!	O
(	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szLex	*(char)
)	O
)	O
||	O
IsParm	(long)->(int)
(	O
hvar	long
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"input, output or state variable"	*(char)
,	O
szLex	*(char)
)	O
;	O
if	O
(	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szDummy	O
,	O
CH_RPAREN	O
)	O
)	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
iErr	O
=	O
(	O
!	O
(	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szLex	*(char)
)	O
)	O
||	O
IsInput	(long)->(int)
(	O
hvar	long
)	O
)	O
)	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
"state, output or parameter"	*(char)
,	O
szLex	*(char)
)	O
;	O
goto	O
Done_GetMCVary	O
;	O
}	O
if	O
(	O
panal	O
->	O
iCurrentDepth	O
==	O
0	int
)	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
=	O
panal	O
->	O
mc	O
.	O
plistMCVars	O
;	O
else	O
{	O
if	O
(	O
!	O
IsParm	(long)->(int)
(	O
hvar	long
)	O
)	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
=	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
]	O
->	O
plistLikes	O
;	O
else	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
=	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
]	O
->	O
plistMCVars	O
;	O
}	O
if	O
(	O
!	O
(	O
pMCVar	O
=	O
(	O
PMCVAR	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
MCVAR	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetDistribSpec"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pMCVar	O
->	O
pszName	O
=	O
(	O
PSTR	*(char)
)	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
szLex	*(char)
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetDistribSpec"	*(char)
,	O
NULL	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
pMCVar	O
->	O
pszName	O
,	O
szLex	*(char)
)	O
;	O
pMCVar	O
->	O
hvar	long
=	O
hvar	long
;	O
pMCVar	O
->	O
pdVal	O
=	O
&	O
(	O
pMCVar	O
->	O
dVal	double
)	O
;	O
pMCVar	O
->	O
iDepth	O
=	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
;	O
pMCVar	O
->	O
plistDependents	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
pMCVar	O
->	O
bExptIsDep	O
=	O
pMCVar	O
->	O
bIsFixed	O
=	O
FALSE	O
;	O
pMCVar	O
->	O
lJumps	O
=	O
pMCVar	O
->	O
lCount	O
=	O
0	int
;	O
pMCVar	O
->	O
dKernelSD	O
=	O
INIT_KERNELSD	O
;	O
pMCVar	O
->	O
bGibbs	O
=	O
FALSE	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
4	int
;	O
n	int
++	O
)	O
{	O
pMCVar	O
->	O
hParm	O
[	O
n	int
]	O
=	O
0	int
;	O
pMCVar	O
->	O
pMCVParent	O
[	O
n	int
]	O
=	O
NULL	O
;	O
pMCVar	O
->	O
pdParm	O
[	O
n	int
]	O
=	O
&	O
(	O
pMCVar	O
->	O
dParm	O
[	O
n	int
]	O
)	O
;	O
pMCVar	O
->	O
iParmType	O
[	O
n	int
]	O
=	O
0	int
;	O
}	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
;	O
iErr	O
|=	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_IDENTIFIER	O
)	O
;	O
pMCVar	O
->	O
iType	int
=	O
McvFromLex	O
(	O
szLex	*(char)
)	O
;	O
if	O
(	O
iErr	O
|=	O
pMCVar	O
->	O
iType	int
<	O
0	int
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
"distribution-type"	*(char)
,	O
szLex	*(char)
)	O
;	O
goto	O
Done_GetMCVary	O
;	O
}	O
switch	O
(	O
pMCVar	O
->	O
iType	int
)	O
{	O
case	O
MCV_UNIFORM	O
:	O
case	O
MCV_LOGUNIFORM	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
1	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
-	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
break	O
;	O
case	O
MCV_NORMAL	O
:	O
case	O
MCV_LOGNORMAL	O
:	O
case	O
MCV_NORMALCV	O
:	O
case	O
MCV_NORMALV	O
:	O
case	O
MCV_LOGNORMALV	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
1	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_NORMAL	O
)	O
||	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_NORMALCV	O
)	O
||	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_NORMALV	O
)	O
)	O
{	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
-	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
}	O
else	O
{	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
}	O
break	O
;	O
case	O
MCV_HALFNORMAL	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
1	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
0	int
]	O
=	O
0.0	int
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_BETA	O
:	O
case	O
MCV_TRUNCNORMAL	O
:	O
case	O
MCV_TRUNCLOGNORMAL	O
:	O
case	O
MCV_TRUNCNORMALCV	O
:	O
case	O
MCV_TRUNCNORMALV	O
:	O
case	O
MCV_TRUNCLOGNORMALV	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
1	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
1.0	int
;	O
if	O
(	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_TRUNCNORMAL	O
)	O
||	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_TRUNCNORMALCV	O
)	O
||	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_TRUNCNORMALV	O
)	O
)	O
{	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
-	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
}	O
else	O
if	O
(	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_TRUNCLOGNORMAL	O
)	O
||	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_TRUNCLOGNORMALV	O
)	O
)	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
SkipWhitespace	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
if	O
(	O
(	O
pMCVar	O
->	O
iType	int
==	O
MCV_BETA	O
)	O
&&	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(char)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
==	O
CH_RPAREN	O
)	O
break	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
2	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
3	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
break	O
;	O
case	O
MCV_CHI2	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_BINOMIAL	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
1	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
0.0	int
;	O
if	O
(	O
pMCVar	O
->	O
iParmType	O
[	O
1	int
]	O
!=	O
MCVP_FIXD	O
)	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
else	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
pMCVar	O
->	O
dParm	O
[	O
1	int
]	O
;	O
break	O
;	O
case	O
MCV_PIECEWISE	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
2	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
1	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
3	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
break	O
;	O
case	O
MCV_EXPONENTIAL	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_GGAMMA	O
:	O
case	O
MCV_INVGGAMMA	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
1	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_TRUNCINVGGAMMA	O
:	O
printf	(*(char))->(int)
(	O
"Warning: The truncated inverse gamma density cannot be\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"         used in MCMC simulations if the GNU Scientific\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"         Library is not installed.\n"	*(char)
)	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
1	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
2	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
3	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
break	O
;	O
case	O
MCV_POISSON	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
0.0	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_BINOMIALBETA	O
:	O
case	O
MCV_GENLOGNORMAL	O
:	O
case	O
MCV_STUDENTT	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
1	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
2	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_CAUCHY	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
1	int
]	O
=	O
DBL_MAX	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
-	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
break	O
;	O
case	O
MCV_HALFCAUCHY	O
:	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
1	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
0	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
case	O
MCV_USERLL	O
:	O
if	O
(	O
!	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
]	O
||	O
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
!=	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
]	O
->	O
plistLikes	O
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"UserSpecifiefLL can only be used in Likelihood()."	*(char)
)	O
;	O
iErr	O
=	O
1	int
;	O
goto	O
Done_GetMCVary	O
;	O
}	O
if	O
(	O
(	O
iErr	O
=	O
GetDistribParam	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
0	int
,	O
pMCVar	O
)	O
)	O
)	O
goto	O
Done_GetMCVary	O
;	O
pMCVar	O
->	O
dParm	O
[	O
1	int
]	O
=	O
DBL_MAX	O
*	O
0.5	int
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
0	int
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
DBL_MAX	O
;	O
break	O
;	O
default	O
:	O
ReportRunTimeError	O
(	O
panal	O
,	O
RE_UNKNOWNDIST	O
|	O
RE_FATAL	O
,	O
"GetDistribSpec"	*(char)
)	O
;	O
break	O
;	O
}	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_RPAREN	O
)	O
;	O
if	O
(	O
(	O
pMCVar	O
->	O
iParmType	O
[	O
2	int
]	O
==	O
MCVP_FIXD	O
)	O
&&	O
(	O
pMCVar	O
->	O
iParmType	O
[	O
3	int
]	O
==	O
MCVP_FIXD	O
)	O
&&	O
(	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
<	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
)	O
)	O
{	O
double	O
dTmp	O
=	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
;	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
dTmp	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_MAXMIN_RANGE	O
|	O
RE_WARNING	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
!	O
iErr	O
)	O
{	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
pMCVar	O
)	O
;	O
}	O
Done_GetMCVary	O
:	O
;	O
if	O
(	O
iErr	O
)	O
{	O
if	O
(	O
pMCVar	O
)	O
free	(*(void))->(void)
(	O
pMCVar	O
)	O
;	O
if	O
(	O
!	O
bGaveMCVaryUsage	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\nSyntax: Check the syntax of %s.\n"	*(char)
,	O
GetKeyword	O
(	O
KM_MCVARY	O
)	O
)	O
;	O
bGaveMCVaryUsage	O
=	O
TRUE	O
;	O
}	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_SYNTAXERR	O
|	O
RE_FATAL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
Exit_MCVarySpec	O
:	O
;	O
return	O
(	O
iErr	O
)	O
;	O
}	O
BOOL	int
CheckDistribParam	O
(	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
HVAR	long
hvar1	O
,	O
HVAR	long
hvar2	O
)	O
{	O
int	O
n	int
;	O
PLISTELEM	*(struct(*(void),*(struct(*(void),*(struct`)))))
p	double
=	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
pleHead	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
PMCVAR	O
pMCVar	O
;	O
if	O
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
==	O
NULL	O
)	O
return	O
TRUE	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
->	O
iSize	int
;	O
++	O
n	int
)	O
{	O
pMCVar	O
=	O
(	O
PMCVAR	O
)	O
p	double
->	O
pData	*(void)
;	O
if	O
(	O
hvar2	O
==	O
pMCVar	O
->	O
hvar	long
)	O
{	O
if	O
(	O
(	O
pMCVar	O
->	O
iParmType	O
[	O
0	int
]	O
==	O
MCVP_PARM	O
)	O
&&	O
(	O
hvar1	O
==	O
pMCVar	O
->	O
hParm	O
[	O
0	int
]	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
(	O
pMCVar	O
->	O
iParmType	O
[	O
1	int
]	O
==	O
MCVP_PARM	O
)	O
&&	O
(	O
hvar1	O
==	O
pMCVar	O
->	O
hParm	O
[	O
1	int
]	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
(	O
pMCVar	O
->	O
iParmType	O
[	O
2	int
]	O
==	O
MCVP_PARM	O
)	O
&&	O
(	O
hvar1	O
==	O
pMCVar	O
->	O
hParm	O
[	O
2	int
]	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
(	O
pMCVar	O
->	O
iParmType	O
[	O
3	int
]	O
==	O
MCVP_PARM	O
)	O
&&	O
(	O
hvar1	O
==	O
pMCVar	O
->	O
hParm	O
[	O
3	int
]	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
p	double
=	O
p	double
->	O
pleNext	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
return	O
TRUE	O
;	O
}	O
int	O
GetDistribParam	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
PLIST	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
int	O
n	int
,	O
PMCVAR	O
pMCVar	O
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pInfo	*(void)
;	O
int	O
iLex	O
,	O
iCode	O
;	O
HVAR	long
hvar	long
;	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
;	O
if	O
(	O
n	int
!=	O
3	int
)	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
iLex	O
)	O
;	O
else	O
{	O
SkipWhitespace	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
iLex	O
=	O
LX_NULL	O
;	O
if	O
(	O
NextChar	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(char)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
!=	O
CH_RPAREN	O
)	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
iLex	O
)	O
;	O
}	O
if	O
(	O
iLex	O
==	O
LX_IDENTIFIER	O
)	O
{	O
iCode	O
=	O
GetKeywordCode_in_context	O
(	O
szLex	*(char)
,	O
CN_FUNCARG	O
)	O
;	O
if	O
(	O
(	O
iCode	O
==	O
KM_PREDICTION	O
)	O
||	O
(	O
iCode	O
==	O
KM_DATA	O
)	O
)	O
{	O
if	O
(	O
IsParm	(long)->(int)
(	O
pMCVar	O
->	O
hvar	long
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_BADCONTEXT	O
|	O
RE_FATAL	O
,	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_LPAREN	O
)	O
)	O
return	O
1	int
;	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
iLex	O
)	O
;	O
if	O
(	O
!	O
(	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szLex	*(char)
)	O
)	O
||	O
IsParm	(long)->(int)
(	O
hvar	long
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"input, output or state variable"	*(char)
,	O
szLex	*(char)
)	O
;	O
if	O
(	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_RPAREN	O
)	O
)	O
return	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szLex	*(char)
)	O
)	O
||	O
!	O
IsParm	(long)->(int)
(	O
hvar	long
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"parameter"	*(char)
,	O
szLex	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
(	O
panal	O
->	O
iType	int
==	O
AT_OPTDESIGN	O
)	O
&&	O
(	O
(	O
panal	O
->	O
iCurrentDepth	O
==	O
0	int
&&	O
hvar	long
==	O
pMCVar	O
->	O
hvar	long
)	O
||	O
!	O
CheckDistribParam	O
(	O
plist	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
pMCVar	O
->	O
hvar	long
,	O
hvar	long
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"valid parameter"	*(char)
,	O
szLex	*(char)
)	O
;	O
if	O
(	O
iCode	O
==	O
KM_PREDICTION	O
)	O
pMCVar	O
->	O
iParmType	O
[	O
n	int
]	O
=	O
MCVP_PRED	O
;	O
else	O
if	O
(	O
iCode	O
==	O
KM_DATA	O
)	O
pMCVar	O
->	O
iParmType	O
[	O
n	int
]	O
=	O
MCVP_DATA	O
;	O
else	O
pMCVar	O
->	O
iParmType	O
[	O
n	int
]	O
=	O
MCVP_PARM	O
;	O
pMCVar	O
->	O
hParm	O
[	O
n	int
]	O
=	O
hvar	long
;	O
}	O
else	O
if	O
(	O
iLex	O
==	O
LX_FLOAT	O
||	O
iLex	O
==	O
LX_INTEGER	O
)	O
{	O
pMCVar	O
->	O
iParmType	O
[	O
n	int
]	O
=	O
MCVP_FIXD	O
;	O
pMCVar	O
->	O
dParm	O
[	O
n	int
]	O
=	O
atof	(*(char))->(double)
(	O
szLex	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
n	int
==	O
3	int
)	O
{	O
pMCVar	O
->	O
iParmType	O
[	O
n	int
]	O
=	O
MCVP_FIXD	O
;	O
pMCVar	O
->	O
dParm	O
[	O
n	int
]	O
=	O
DBL_MAX	O
;	O
}	O
else	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
GetSetPointsSpec	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PANALYSIS	O
panal	O
,	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
PMCVAR	O
pMCVar	O
;	O
PSTRLEX	array(char)
szTmp	O
;	O
HVAR	long
hvar	long
;	O
int	O
iErr	O
=	O
0	int
;	O
int	O
iNLI	O
;	O
long	O
j	O
,	O
iLB	O
,	O
iUB	O
;	O
if	O
(	O
ListLength	O
(	O
panal	O
->	O
mc	O
.	O
plistMCVars	O
)	O
>	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: Distrib() statements can only appear after the SetPoints()"	*(char)
"specification, not before - Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
iErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_LPAREN	O
)	O
||	O
GetStringArg	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
&	O
panal	O
->	O
mc	O
.	O
szMCOutfilename	O
,	O
szLex	*(char)
,	O
FALSE	O
)	O
||	O
GetStringArg	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
&	O
panal	O
->	O
mc	O
.	O
szSetPointsFilename	O
,	O
szLex	*(char)
,	O
TRUE	O
)	O
)	O
)	O
{	O
goto	O
Exit_GetSetPointsSpec	O
;	O
}	O
else	O
{	O
panal	O
->	O
bAllocatedFileName	O
=	O
TRUE	O
;	O
}	O
if	O
(	O
!	O
panal	O
->	O
mc	O
.	O
szSetPointsFilename	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_SPECERR	O
|	O
RE_FATAL	O
,	O
"Missing setpoints file"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
MyStrcmp	O
(	O
panal	O
->	O
mc	O
.	O
szMCOutfilename	O
,	O
panal	O
->	O
mc	O
.	O
szSetPointsFilename	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_SPECERR	O
|	O
RE_FATAL	O
,	O
"Same name for 2 files"	*(char)
,	O
NULL	O
)	O
;	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
','	O
)	O
;	O
if	O
(	O
(	O
iErr	O
=	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_INTEGER	O
)	O
)	O
)	O
goto	O
Exit_GetSetPointsSpec	O
;	O
panal	O
->	O
mc	O
.	O
nRuns	O
=	O
atol	(*(char))->(long)
(	O
szLex	*(char)
)	O
;	O
while	O
(	O
(	O
iNLI	O
=	O
NextListItem	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),int,int,char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_IDENTIFIER	O
,	O
1	int
,	O
CH_RPAREN	O
)	O
)	O
>	O
0	int
)	O
{	O
iLB	O
=	O
iUB	O
=	O
-	O
1	int
;	O
if	O
(	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
'['	O
)	O
)	O
GetArrayBounds	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(long),*(long))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
&	O
iLB	O
,	O
&	O
iUB	O
)	O
;	O
if	O
(	O
iUB	O
==	O
-	O
1	int
)	O
{	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szLex	*(char)
)	O
;	O
if	O
(	O
(	O
iErr	O
=	O
(	O
!	O
hvar	long
||	O
IsInput	(long)->(int)
(	O
hvar	long
)	O
)	O
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
pMCVar	O
=	O
(	O
PMCVAR	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
MCVAR	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetSetPointsSpec"	*(char)
,	O
NULL	O
)	O
;	O
pMCVar	O
->	O
hvar	long
=	O
hvar	long
;	O
pMCVar	O
->	O
iType	int
=	O
MCV_SETPOINTS	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
0.0	int
;	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
panal	O
->	O
mc	O
.	O
plistMCVars	O
,	O
pMCVar	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
j	O
=	O
iLB	O
;	O
j	O
<	O
iUB	O
;	O
j	O
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
szTmp	O
,	O
"%s_%ld"	*(char)
,	O
szLex	*(char)
,	O
j	O
)	O
;	O
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szTmp	O
)	O
;	O
if	O
(	O
(	O
iErr	O
=	O
(	O
!	O
hvar	long
||	O
IsInput	(long)->(int)
(	O
hvar	long
)	O
)	O
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
pMCVar	O
=	O
(	O
PMCVAR	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
MCVAR	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetSetPointsSpec"	*(char)
,	O
NULL	O
)	O
;	O
pMCVar	O
->	O
hvar	long
=	O
hvar	long
;	O
pMCVar	O
->	O
iType	int
=	O
MCV_SETPOINTS	O
;	O
pMCVar	O
->	O
dParm	O
[	O
2	int
]	O
=	O
pMCVar	O
->	O
dParm	O
[	O
3	int
]	O
=	O
0.0	int
;	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
panal	O
->	O
mc	O
.	O
plistMCVars	O
,	O
pMCVar	O
)	O
;	O
}	O
}	O
}	O
panal	O
->	O
mc	O
.	O
nSetParms	O
=	O
ListLength	O
(	O
panal	O
->	O
mc	O
.	O
plistMCVars	O
)	O
;	O
if	O
(	O
panal	O
->	O
mc	O
.	O
nSetParms	O
==	O
0	int
)	O
{	O
iErr	O
=	O
TRUE	O
;	O
printf	(*(char))->(int)
(	O
"\nError: you must specify a list of parameters to read.\n\n"	*(char)
)	O
;	O
goto	O
Exit_GetSetPointsSpec	O
;	O
}	O
if	O
(	O
!	O
iNLI	O
)	O
iErr	O
=	O
(	O
(	O
szTmp	O
[	O
0	int
]	O
!=	O
CH_RPAREN	O
)	O
&&	O
(	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
CH_RPAREN	O
)	O
)	O
)	O
||	O
InitSetPoints	O
(	O
&	O
panal	O
->	O
mc	O
)	O
;	O
else	O
{	O
iErr	O
=	O
TRUE	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
"identifier"	*(char)
,	O
szLex	*(char)
)	O
;	O
}	O
Exit_GetSetPointsSpec	O
:	O
;	O
if	O
(	O
iErr	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Syntax:\n"	*(char)
"%s (\"OutputFile\", \"SetPtsFile\", nRuns, "	*(char)
"<param-id-list...>)\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_SETPOINTS	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"Exiting...\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
else	O
panal	O
->	O
iType	int
=	O
AT_SETPOINTS	O
;	O
return	O
(	O
iErr	O
)	O
;	O
}	O
int	O
GetMonteCarloSpec	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PANALYSIS	O
panal	O
,	O
PSTR	*(char)
szLex	*(char)
)	O
{	O
static	O
int	O
vrgiMCArgTypes	O
[	O
NMC_ARGS	O
]	O
=	O
{	O
LX_STRING	O
,	O
LX_INTEGER	O
,	O
LX_NUMBER	O
}	O
;	O
int	O
iErr	O
=	O
0	int
;	O
iErr	O
=	O
!	O
GetFuncArgs	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),int,*(int),*(char))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
NMC_ARGS	O
,	O
vrgiMCArgTypes	O
,	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
iErr	O
)	O
{	O
if	O
(	O
*	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
{	O
if	O
(	O
!	O
(	O
panal	O
->	O
mc	O
.	O
szMCOutfilename	O
=	O
(	O
PSTR	*(char)
)	O
malloc	(long)->(*(void))
(	O
MyStrlen	O
(	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
+	O
1	int
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetMonteCarloSpec"	*(char)
,	O
NULL	O
)	O
;	O
MyStrcpy	O
(	O
panal	O
->	O
mc	O
.	O
szMCOutfilename	O
,	O
vrgszlexArgs	O
[	O
0	int
]	O
)	O
;	O
panal	O
->	O
bAllocatedFileName	O
=	O
TRUE	O
;	O
}	O
panal	O
->	O
mc	O
.	O
nRuns	O
=	O
atol	(*(char))->(long)
(	O
vrgszlexArgs	O
[	O
1	int
]	O
)	O
;	O
panal	O
->	O
dSeed	double
=	O
atof	(*(char))->(double)
(	O
vrgszlexArgs	O
[	O
2	int
]	O
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"Syntax: %s (szOutfilename, nRuns, dSeed)\n\n"	*(char)
,	O
GetKeyword	O
(	O
KM_MONTECARLO	O
)	O
)	O
;	O
if	O
(	O
!	O
iErr	O
)	O
panal	O
->	O
iType	int
=	O
AT_MONTECARLO	O
;	O
return	O
(	O
iErr	O
)	O
;	O
}	O
BOOL	int
GetParmMod	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTRLEX	array(char)
szLex	*(char)
)	O
{	O
HVAR	long
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szLex	*(char)
)	O
;	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pInfo	*(void)
;	O
PEXPERIMENT	O
pexp	O
=	O
panal	O
->	O
pexpCurrent	O
;	O
PSTRLEX	array(char)
szPunct	O
;	O
int	O
iErr	O
;	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
pvarmod	O
;	O
if	O
(	O
(	O
iErr	O
=	O
!	O
hvar	long
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
"model-variable"	*(char)
,	O
szLex	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pvarmod	O
=	O
(	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
VARMODIFICATION	struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))))
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetParmMod"	*(char)
,	O
NULL	O
)	O
;	O
pvarmod	O
->	O
hvar	long
=	O
hvar	long
;	O
if	O
(	O
!	O
GetOptPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szPunct	O
,	O
'='	O
)	O
)	O
{	O
iErr	O
=	O
szPunct	O
[	O
1	int
]	O
=	O
'='	O
;	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_EXPECTED	O
,	O
szPunct	O
,	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
IsInput	(long)->(int)
(	O
hvar	long
)	O
)	O
{	O
if	O
(	O
!	O
(	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
=	O
(	O
PIFN	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
IFN	struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetParmMod"	*(char)
,	O
NULL	O
)	O
;	O
iErr	O
=	O
!	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
||	O
!	O
GetInputFn	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
NULL	O
,	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
)	O
;	O
if	O
(	O
iErr	O
)	O
{	O
free	(*(void))->(void)
(	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
)	O
;	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
iErr	O
=	O
ENextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),int)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
LX_NUMBER	O
)	O
)	O
)	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
dVal	double
=	O
atof	(*(char))->(double)
(	O
szLex	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
iErr	O
)	O
{	O
if	O
(	O
panal	O
->	O
iCurrentDepth	O
==	O
0	int
||	O
panal	O
->	O
wContext	O
==	O
CN_EXPERIMENT	O
)	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
pexp	O
->	O
plistParmMods	O
,	O
pvarmod	O
)	O
;	O
else	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
]	O
->	O
plistVars	O
,	O
pvarmod	O
)	O
;	O
iErr	O
=	O
GetTerminator	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
)	O
;	O
}	O
else	O
free	(*(void))->(void)
(	O
pvarmod	O
)	O
;	O
}	O
return	O
(	O
(	O
BOOL	int
)	O
iErr	O
)	O
;	O
}	O
BOOL	int
GetParmMod2	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTRLEX	array(char)
szLex	*(char)
,	O
PSTREQN	array(char)
szEqn	*(char)
)	O
{	O
int	O
iErr	O
;	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
pvarmod	O
;	O
HVAR	long
hvar	long
=	O
GetVarHandle	(*(char))->(long)
(	O
szLex	*(char)
)	O
;	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pInfo	*(void)
;	O
PEXPERIMENT	O
pexp	O
=	O
panal	O
->	O
pexpCurrent	O
;	O
if	O
(	O
(	O
iErr	O
=	O
!	O
hvar	long
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
,	O
"model-variable"	*(char)
,	O
szLex	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
!	O
(	O
pvarmod	O
=	O
(	O
PVARMOD	*(struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*`,*`,*`,*`,long,*`)))))
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
VARMODIFICATION	struct(long,union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))))
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetParmMod"	*(char)
,	O
NULL	O
)	O
;	O
pvarmod	O
->	O
hvar	long
=	O
hvar	long
;	O
if	O
(	O
IsInput	(long)->(int)
(	O
hvar	long
)	O
)	O
{	O
if	O
(	O
!	O
(	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
=	O
(	O
PIFN	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
IFN	struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"GetParmMod"	*(char)
,	O
NULL	O
)	O
;	O
iErr	O
=	O
!	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
||	O
!	O
GetInputFn	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
NULL	O
,	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
)	O
;	O
if	O
(	O
iErr	O
)	O
{	O
free	(*(void))->(void)
(	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
)	O
;	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
pvarmod	O
->	O
uvar	union(double,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))
.	O
dVal	double
=	O
atof	(*(char))->(double)
(	O
szEqn	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
iErr	O
)	O
{	O
if	O
(	O
panal	O
->	O
iCurrentDepth	O
==	O
0	int
||	O
panal	O
->	O
wContext	O
==	O
CN_EXPERIMENT	O
)	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
pexp	O
->	O
plistParmMods	O
,	O
pvarmod	O
)	O
;	O
else	O
QueueListItem	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*(void))->(void)
(	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
]	O
->	O
plistVars	O
,	O
pvarmod	O
)	O
;	O
}	O
else	O
free	(*(void))->(void)
(	O
pvarmod	O
)	O
;	O
}	O
return	O
(	O
(	O
BOOL	int
)	O
iErr	O
)	O
;	O
}	O
void	O
NewExperiment	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
{	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pInfo	*(void)
;	O
PLEVEL	O
plevel	O
;	O
int	O
n	int
;	O
if	O
(	O
panal	O
->	O
iCurrentDepth	O
<	O
0	int
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"Level statement"	*(char)
,	O
"Simulation"	*(char)
)	O
;	O
}	O
if	O
(	O
panal	O
->	O
iCurrentDepth	O
==	O
0	int
)	O
{	O
panal	O
->	O
expGlobal	O
.	O
iExp	O
++	O
;	O
panal	O
->	O
pexpCurrent	O
=	O
panal	O
->	O
rgpExps	O
[	O
panal	O
->	O
expGlobal	O
.	O
iExp	O
-	O
1	int
]	O
=	O
(	O
PEXPERIMENT	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
EXPERIMENT	O
)	O
)	O
;	O
if	O
(	O
!	O
panal	O
->	O
pexpCurrent	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"NewExperiment()"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
panal	O
->	O
rank	int
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
"Reading experiment %d.\n"	*(char)
,	O
panal	O
->	O
expGlobal	O
.	O
iExp	O
)	O
;	O
}	O
else	O
{	O
plevel	O
=	O
panal	O
->	O
pLevels	O
[	O
panal	O
->	O
iInstances	O
-	O
1	int
]	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
;	O
++	O
n	int
)	O
{	O
plevel	O
=	O
plevel	O
->	O
pLevels	O
[	O
plevel	O
->	O
iInstances	O
-	O
1	int
]	O
;	O
}	O
if	O
(	O
plevel	O
->	O
iInstances	O
==	O
MAX_INSTANCES	O
-	O
1	int
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_TOOMANYINST	O
|	O
RE_FATAL	O
,	O
"NewExperiment"	*(char)
,	O
NULL	O
)	O
;	O
n	int
=	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
]	O
->	O
iInstances	O
++	O
;	O
if	O
(	O
!	O
(	O
plevel	O
=	O
plevel	O
->	O
pLevels	O
[	O
n	int
]	O
=	O
(	O
PLEVEL	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
LEVEL	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"NewExperiment"	*(char)
,	O
NULL	O
)	O
;	O
plevel	O
->	O
iInstances	O
=	O
0	int
;	O
plevel	O
->	O
iSequence	O
=	O
n	int
+	O
1	int
;	O
plevel	O
->	O
iDepth	O
=	O
panal	O
->	O
iCurrentDepth	O
;	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
++	O
]	O
=	O
plevel	O
;	O
if	O
(	O
panal	O
->	O
iDepth	O
<	O
panal	O
->	O
iCurrentDepth	O
)	O
panal	O
->	O
iDepth	O
=	O
panal	O
->	O
iCurrentDepth	O
;	O
plevel	O
->	O
nMCVars	O
=	O
plevel	O
->	O
nFixedVars	O
=	O
plevel	O
->	O
nLikes	O
=	O
0	int
;	O
plevel	O
->	O
plistVars	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
plevel	O
->	O
plistMCVars	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
plevel	O
->	O
plistLikes	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
if	O
(	O
!	O
(	O
plevel	O
->	O
pexpt	O
=	O
(	O
PEXPERIMENT	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
EXPERIMENT	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"NewExperiment"	*(char)
,	O
NULL	O
)	O
;	O
panal	O
->	O
pexpCurrent	O
=	O
plevel	O
->	O
pexpt	O
;	O
panal	O
->	O
pexpCurrent	O
->	O
iExp	O
=	O
panal	O
->	O
expGlobal	O
.	O
iExp	O
=	O
++	O
panal	O
->	O
iExpts	O
;	O
panal	O
->	O
wContext	O
=	O
CN_EXPERIMENT	O
;	O
if	O
(	O
panal	O
->	O
rank	int
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
"Simulation %d - depth %d, instance %d\n"	*(char)
,	O
panal	O
->	O
iExpts	O
,	O
panal	O
->	O
iCurrentDepth	O
,	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
-	O
2	int
]	O
->	O
iInstances	O
)	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
panal	O
->	O
pexpCurrent	O
,	O
&	O
panal	O
->	O
expGlobal	O
,	O
sizeof	O
(	O
EXPERIMENT	O
)	O
)	O
;	O
panal	O
->	O
wContext	O
=	O
CN_EXPERIMENT	O
;	O
panal	O
->	O
pexpCurrent	O
->	O
plistParmMods	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
panal	O
->	O
pexpCurrent	O
->	O
os	O
.	O
plistPrintRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
panal	O
->	O
pexpCurrent	O
->	O
os	O
.	O
plistDataRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
}	O
BOOL	int
EndExperiment	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PANALYSIS	O
panal	O
)	O
{	O
BOOL	int
bReturn	O
;	O
bReturn	O
=	O
!	O
ErrorsReported	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
if	O
(	O
!	O
bReturn	O
)	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_ERRORSINEXP	O
|	O
RE_FATAL	O
,	O
(	O
PSTR	*(char)
)	O
&	O
panal	O
->	O
pexpCurrent	O
->	O
iExp	O
,	O
NULL	O
)	O
;	O
ClearErrors	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
panal	O
->	O
rgpExps	O
[	O
--	O
panal	O
->	O
expGlobal	O
.	O
iExp	O
]	O
=	O
NULL	O
;	O
free	(*(void))->(void)
(	O
panal	O
->	O
pexpCurrent	O
)	O
;	O
}	O
else	O
{	O
PrepareOutSpec	O
(	O
panal	O
->	O
pexpCurrent	O
)	O
;	O
}	O
panal	O
->	O
pexpCurrent	O
=	O
&	O
panal	O
->	O
expGlobal	O
;	O
panal	O
->	O
wContext	O
=	O
CN_GLOBAL	O
;	O
if	O
(	O
panal	O
->	O
iType	int
==	O
AT_MCMC	O
&&	O
panal	O
->	O
iCurrentDepth	O
--	O
==	O
0	int
)	O
return	O
FALSE	O
;	O
return	O
(	O
bReturn	O
)	O
;	O
}	O
int	O
SetLevel	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
{	O
PSTRLEX	array(char)
szPunct	O
;	O
PANALYSIS	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pInfo	*(void)
;	O
PLEVEL	O
plevel	O
;	O
BYTE	char
n	int
;	O
if	O
(	O
panal	O
->	O
iType	int
!=	O
AT_MCMC	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_TYPENOTMCMC	O
|	O
RE_FATAL	O
,	O
"SetLevel"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
panal	O
->	O
iCurrentDepth	O
==	O
MAX_LEVELS	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_TOOMANYLEVELS	O
|	O
RE_FATAL	O
,	O
"SetLevel"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
panal	O
->	O
wContext	O
==	O
CN_EXPERIMENT	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEVINEXPT	O
|	O
RE_FATAL	O
,	O
"SetLevel"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szPunct	O
,	O
CH_LBRACE	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
panal	O
->	O
iCurrentDepth	O
==	O
0	int
)	O
{	O
plevel	O
=	O
panal	O
->	O
pLevels	O
[	O
panal	O
->	O
iInstances	O
++	O
]	O
=	O
(	O
PLEVEL	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
LEVEL	O
)	O
)	O
;	O
if	O
(	O
plevel	O
==	O
NULL	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"SetLevel"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
panal	O
->	O
iInstances	O
>	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: only one top level is allowed - Exiting.\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
plevel	O
->	O
iSequence	O
=	O
panal	O
->	O
iInstances	O
;	O
if	O
(	O
panal	O
->	O
rank	int
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
"New level - depth 1, instance %d\n"	*(char)
,	O
panal	O
->	O
iInstances	O
)	O
;	O
}	O
else	O
{	O
plevel	O
=	O
panal	O
->	O
pLevels	O
[	O
panal	O
->	O
iInstances	O
-	O
1	int
]	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
;	O
++	O
n	int
)	O
plevel	O
=	O
plevel	O
->	O
pLevels	O
[	O
plevel	O
->	O
iInstances	O
-	O
1	int
]	O
;	O
if	O
(	O
plevel	O
->	O
iInstances	O
==	O
MAX_INSTANCES	O
-	O
1	int
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_TOOMANYINST	O
|	O
RE_FATAL	O
,	O
"SetLevel"	*(char)
,	O
NULL	O
)	O
;	O
n	int
=	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
]	O
->	O
iInstances	O
++	O
;	O
plevel	O
=	O
plevel	O
->	O
pLevels	O
[	O
n	int
]	O
=	O
(	O
PLEVEL	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
LEVEL	O
)	O
)	O
;	O
if	O
(	O
plevel	O
==	O
NULL	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OUTOFMEM	O
|	O
RE_FATAL	O
,	O
"SetLevel"	*(char)
,	O
NULL	O
)	O
;	O
plevel	O
->	O
iSequence	O
=	O
n	int
+	O
1	int
;	O
if	O
(	O
panal	O
->	O
rank	int
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
"New level - depth %d, instance %d\n"	*(char)
,	O
panal	O
->	O
iCurrentDepth	O
+	O
1	int
,	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
-	O
1	int
]	O
->	O
iInstances	O
)	O
;	O
}	O
plevel	O
->	O
iInstances	O
=	O
0	int
;	O
plevel	O
->	O
iDepth	O
=	O
panal	O
->	O
iCurrentDepth	O
;	O
panal	O
->	O
pCurrentLevel	O
[	O
panal	O
->	O
iCurrentDepth	O
++	O
]	O
=	O
plevel	O
;	O
if	O
(	O
panal	O
->	O
iDepth	O
<	O
panal	O
->	O
iCurrentDepth	O
)	O
panal	O
->	O
iDepth	O
=	O
panal	O
->	O
iCurrentDepth	O
;	O
plevel	O
->	O
nMCVars	O
=	O
plevel	O
->	O
nFixedVars	O
=	O
plevel	O
->	O
nLikes	O
=	O
0	int
;	O
plevel	O
->	O
plistVars	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
plevel	O
->	O
plistMCVars	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
plevel	O
->	O
plistLikes	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
plevel	O
->	O
pexpt	O
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
BOOL	int
EndLevel	O
(	O
PANALYSIS	O
panal	O
)	O
{	O
if	O
(	O
panal	O
->	O
iCurrentDepth	O
--	O
==	O
0	int
)	O
return	O
FALSE	O
;	O
return	O
TRUE	O
;	O
}	O
void	O
FreeLevels	O
(	O
PANALYSIS	O
panal	O
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
panal	O
->	O
iInstances	O
;	O
n	int
++	O
)	O
if	O
(	O
panal	O
->	O
pLevels	O
[	O
n	int
]	O
!=	O
NULL	O
)	O
FreeOneLevel	O
(	O
panal	O
->	O
pLevels	O
[	O
n	int
]	O
)	O
;	O
if	O
(	O
panal	O
->	O
bAllocatedFileName	O
)	O
free	(*(void))->(void)
(	O
panal	O
->	O
gd	O
.	O
szGout	O
)	O
;	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
&	O
panal	O
->	O
mc	O
.	O
plistMCVars	O
,	O
NULL	O
,	O
TRUE	O
)	O
;	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
&	O
panal	O
->	O
expGlobal	O
.	O
plistParmMods	O
,	O
NULL	O
,	O
TRUE	O
)	O
;	O
free	(*(void))->(void)
(	O
panal	O
->	O
expGlobal	O
.	O
is	O
.	O
iwork	*(long)
)	O
;	O
free	(*(void))->(void)
(	O
panal	O
->	O
expGlobal	O
.	O
is	O
.	O
rwork	*(double)
)	O
;	O
free	(*(void))->(void)
(	O
panal	O
->	O
modelinfo	O
.	O
pStateHvar	O
)	O
;	O
free	(*(void))->(void)
(	O
panal	O
)	O
;	O
}	O
int	O
FreeMCVar	O
(	O
PVOID	*(void)
pData	*(void)
,	O
PVOID	*(void)
pUserInfo	*(void)
)	O
{	O
PMCVAR	O
pMCVar	O
=	O
(	O
PMCVAR	O
)	O
pData	*(void)
;	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
&	O
pMCVar	O
->	O
plistDependents	O
,	O
NULL	O
,	O
TRUE	O
)	O
;	O
free	(*(void))->(void)
(	O
pMCVar	O
->	O
pszName	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
FreeDataRec	O
(	O
PVOID	*(void)
pData	*(void)
,	O
PVOID	*(void)
pUserInfo	*(void)
)	O
{	O
PDATAREC	*(struct(*(char),long,long,*(double)))
pDataRecord	O
=	O
(	O
PDATAREC	*(struct(*(char),long,long,*(double)))
)	O
pData	*(void)
;	O
free	(*(void))->(void)
(	O
pDataRecord	O
->	O
szDataName	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pDataRecord	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
FreePrintRec	O
(	O
PVOID	*(void)
pData	*(void)
,	O
PVOID	*(void)
pUserInfo	*(void)
)	O
{	O
PPRINTREC	*(struct(*(char),long,long,*(double)))
pPrintRecord	O
=	O
(	O
PPRINTREC	*(struct(*(char),long,long,*(double)))
)	O
pData	*(void)
;	O
free	(*(void))->(void)
(	O
pPrintRecord	O
->	O
pdTimes	*(double)
)	O
;	O
free	(*(void))->(void)
(	O
pPrintRecord	O
->	O
szOutputName	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
pPrintRecord	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
FreeOneLevel	O
(	O
PLEVEL	O
plevel	O
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
plevel	O
->	O
iInstances	O
;	O
n	int
++	O
)	O
if	O
(	O
plevel	O
->	O
pLevels	O
[	O
n	int
]	O
!=	O
NULL	O
)	O
FreeOneLevel	O
(	O
plevel	O
->	O
pLevels	O
[	O
n	int
]	O
)	O
;	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
&	O
plevel	O
->	O
plistVars	O
,	O
NULL	O
,	O
TRUE	O
)	O
;	O
ForAllList	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void))->(int)),*(void))->(int)
(	O
plevel	O
->	O
plistMCVars	O
,	O
&	O
FreeMCVar	O
,	O
NULL	O
)	O
;	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
&	O
plevel	O
->	O
plistMCVars	O
,	O
NULL	O
,	O
TRUE	O
)	O
;	O
ForAllList	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void))->(int)),*(void))->(int)
(	O
plevel	O
->	O
plistLikes	O
,	O
&	O
FreeMCVar	O
,	O
NULL	O
)	O
;	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
&	O
plevel	O
->	O
plistLikes	O
,	O
NULL	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
plevel	O
->	O
pexpt	O
!=	O
NULL	O
)	O
{	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
&	O
plevel	O
->	O
pexpt	O
->	O
plistParmMods	O
,	O
&	O
FreeVarMod	O
,	O
FALSE	O
)	O
;	O
POUTSPEC	*(struct(int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),int,*(struct(*(struct`),*(struct`),int)),*(*(char)),*(long),*(int),*(int),*(*(double)),*(*(double)),int,*(double),*(int),*(*(double))))
pos	O
=	O
&	O
plevel	O
->	O
pexpt	O
->	O
os	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
pszOutputNames	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
phvar_out	*(long)
)	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
pcOutputTimes	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
piCurrentOut	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
prgdOutputTimes	*(*(double))
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
pos	O
->	O
nOutputs	int
;	O
n	int
++	O
)	O
free	(*(void))->(void)
(	O
pos	O
->	O
prgdOutputVals	*(*(double))
[	O
n	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
prgdOutputVals	*(*(double))
)	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
rgdDistinctTimes	*(double)
)	O
;	O
ForAllList	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)),*((*(void),*(void))->(int)),*(void))->(int)
(	O
pos	O
->	O
plistPrintRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
&	O
FreePrintRec	O
,	O
NULL	O
)	O
;	O
FreeList	(*(*(struct(*(struct`),*(struct`),int))),*((*(void))->(void)),int)->(void)
(	O
&	O
pos	O
->	O
plistPrintRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
,	O
NULL	O
,	O
FALSE	O
)	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
plistPrintRecs	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),int))
)	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
pcData	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
phvar_dat	*(long)
)	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
pszDataNames	*(*(char))
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
pos	O
->	O
nData	int
;	O
n	int
++	O
)	O
free	(*(void))->(void)
(	O
pos	O
->	O
prgdDataVals	*(*(double))
[	O
n	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
pos	O
->	O
prgdDataVals	*(*(double))
)	O
;	O
free	(*(void))->(void)
(	O
plevel	O
->	O
pexpt	O
)	O
;	O
}	O
if	O
(	O
plevel	O
->	O
nFixedVars	O
>	O
0	int
)	O
free	(*(void))->(void)
(	O
plevel	O
->	O
rgpFixedVars	O
)	O
;	O
if	O
(	O
plevel	O
->	O
nMCVars	O
>	O
0	int
)	O
free	(*(void))->(void)
(	O
plevel	O
->	O
rgpMCVars	O
)	O
;	O
free	(*(void))->(void)
(	O
plevel	O
->	O
rgpLikes	O
)	O
;	O
free	(*(void))->(void)
(	O
plevel	O
)	O
;	O
}	O
void	O
ProcessWord	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
PSTR	*(char)
szLex	*(char)
,	O
PSTR	*(char)
szEqn	*(char)
)	O
{	O
int	O
iErr	O
=	O
0	int
;	O
int	O
iKWCode	O
,	O
fContext	O
;	O
long	O
i	O
,	O
iLB	O
,	O
iUB	O
;	O
PSTREQN	array(char)
szEqnU	*(char)
;	O
PSTRLEX	array(char)
szTmp	O
;	O
PANALYSIS	O
panal	O
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
||	O
!	O
szLex	*(char)
||	O
!	O
szLex	*(char)
[	O
0	int
]	O
||	O
!	O
szEqn	*(char)
)	O
return	O
;	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pInfo	*(void)
;	O
iKWCode	O
=	O
GetKeywordCode	O
(	O
szLex	*(char)
,	O
&	O
fContext	O
)	O
;	O
assert	O
(	O
panal	O
->	O
wContext	O
!=	O
CN_END	O
)	O
;	O
if	O
(	O
(	O
iErr	O
=	O
(	O
iKWCode	O
&&	O
!	O
(	O
fContext	O
&	O
panal	O
->	O
wContext	O
)	O
)	O
)	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_BADCONTEXT	O
,	O
szLex	*(char)
,	O
NULL	O
)	O
;	O
else	O
{	O
switch	O
(	O
iKWCode	O
)	O
{	O
default	O
:	O
iLB	O
=	O
iUB	O
=	O
-	O
1	int
;	O
if	O
(	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
'['	O
)	O
)	O
GetArrayBounds	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(long),*(long))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
&	O
iLB	O
,	O
&	O
iUB	O
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
szTmp	O
,	O
"="	*(char)
)	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
--	O
;	O
if	O
(	O
iUB	O
==	O
-	O
1	int
)	O
{	O
iErr	O
=	O
GetParmMod	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
GetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
'='	O
)	O
)	O
{	O
GetStatement	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szEqn	*(char)
)	O
;	O
for	O
(	O
i	O
=	O
iLB	O
;	O
i	O
<	O
iUB	O
;	O
i	O
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
szTmp	O
,	O
"%s_%ld"	*(char)
,	O
szLex	*(char)
,	O
i	O
)	O
;	O
UnrollEquation	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),long,*(char),*(char))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
i	O
,	O
szEqn	*(char)
,	O
szEqnU	*(char)
)	O
;	O
iErr	O
=	O
GetParmMod2	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
szEqnU	*(char)
)	O
;	O
if	O
(	O
iErr	O
)	O
break	O
;	O
}	O
}	O
else	O
{	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_LEXEXPECTED	O
|	O
RE_FATAL	O
,	O
"= or ["	*(char)
,	O
NULL	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
KM_PRINT	O
:	O
iErr	O
=	O
GetPrint	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
panal	O
->	O
pexpCurrent	O
->	O
os	O
)	O
;	O
break	O
;	O
case	O
KM_PRINTSTEP	O
:	O
iErr	O
=	O
GetPrintStep	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
panal	O
->	O
pexpCurrent	O
->	O
os	O
)	O
;	O
break	O
;	O
case	O
KM_EXPERIMENT	O
:	O
if	O
(	O
!	O
(	O
iErr	O
=	O
EGetPunct	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),*(char),char)->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szTmp	O
,	O
CH_LBRACE	O
)	O
)	O
)	O
NewExperiment	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
break	O
;	O
case	O
KM_LEVEL	O
:	O
iErr	O
=	O
SetLevel	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
break	O
;	O
case	O
KM_MCVARY	O
:	O
iErr	O
=	O
GetDistribSpec	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
panal	O
,	O
szLex	*(char)
)	O
;	O
break	O
;	O
case	O
KM_OUTPUTFILE	O
:	O
if	O
(	O
panal	O
->	O
szOutfilename	O
)	O
EatStatement	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
else	O
iErr	O
=	O
GetOutputFile	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
panal	O
)	O
;	O
break	O
;	O
case	O
KM_DATA	O
:	O
iErr	O
=	O
GetData	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
panal	O
->	O
pexpCurrent	O
->	O
os	O
)	O
;	O
break	O
;	O
case	O
KM_INTEGRATE	O
:	O
iErr	O
=	O
GetIntegrate	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
&	O
panal	O
->	O
pexpCurrent	O
->	O
is	O
)	O
;	O
break	O
;	O
case	O
KM_MCMC	O
:	O
iErr	O
=	O
GetMCMCSpec	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
panal	O
->	O
pexpCurrent	O
)	O
;	O
break	O
;	O
case	O
KM_OPTDESIGN	O
:	O
iErr	O
=	O
GetOptDSpec	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
panal	O
,	O
szLex	*(char)
)	O
;	O
break	O
;	O
case	O
KM_MONTECARLO	O
:	O
iErr	O
=	O
GetMonteCarloSpec	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
panal	O
,	O
szLex	*(char)
)	O
;	O
break	O
;	O
case	O
KM_SETPOINTS	O
:	O
iErr	O
=	O
GetSetPointsSpec	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
panal	O
,	O
szLex	*(char)
)	O
;	O
break	O
;	O
case	O
KM_SIMULATE	O
:	O
iErr	O
=	O
GetSimulate	O
(	O
)	O
;	O
break	O
;	O
case	O
KM_STARTTIME	O
:	O
iErr	O
=	O
GetStartTime	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
panal	O
->	O
pexpCurrent	O
)	O
;	O
break	O
;	O
case	O
KM_SIMTYPE	O
:	O
iErr	O
=	O
GetSimType	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
break	O
;	O
case	O
KM_TEMPERATURE	O
:	O
iErr	O
=	O
GetPerks	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
panal	O
->	O
gd	O
)	O
;	O
break	O
;	O
case	O
KM_END	O
:	O
panal	O
->	O
wContext	O
=	O
CN_END	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
iErr	O
)	O
EatStatement	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
}	O
BOOL	int
ReadAnalysis	O
(	O
PINPUTBUF	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
{	O
PSTRLEX	array(char)
szLex	*(char)
;	O
PSTREQN	array(char)
szEqn	*(char)
;	O
int	O
iLexType	O
;	O
BOOL	int
bReturn	O
=	O
TRUE	O
;	O
PANALYSIS	O
panal	O
;	O
if	O
(	O
!	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
return	O
(	O
FALSE	O
)	O
;	O
panal	O
=	O
(	O
PANALYSIS	O
)	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pInfo	*(void)
;	O
panal	O
->	O
iDepth	O
=	O
panal	O
->	O
iCurrentDepth	O
=	O
panal	O
->	O
iInstances	O
=	O
0	int
;	O
panal	O
->	O
mc	O
.	O
plistMCVars	O
=	O
InitList	()->(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),int)))
(	O
)	O
;	O
do	O
{	O
NextLex	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))),array(char),*(int))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
&	O
iLexType	O
)	O
;	O
switch	O
(	O
iLexType	O
)	O
{	O
case	O
LX_NULL	O
:	O
if	O
(	O
panal	O
->	O
wContext	O
!=	O
CN_GLOBAL	O
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_WARNING	O
,	O
NULL	O
,	O
"Unexpected end of file"	*(char)
)	O
;	O
if	O
(	O
panal	O
->	O
wContext	O
==	O
CN_EXPERIMENT	O
)	O
bReturn	O
&=	O
EndExperiment	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
panal	O
)	O
;	O
panal	O
->	O
wContext	O
=	O
CN_END	O
;	O
break	O
;	O
case	O
LX_IDENTIFIER	O
:	O
ProcessWord	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
szLex	*(char)
,	O
szEqn	*(char)
)	O
;	O
break	O
;	O
case	O
LX_PUNCT	O
:	O
if	O
(	O
szLex	*(char)
[	O
0	int
]	O
==	O
CH_STMTTERM	O
)	O
break	O
;	O
else	O
if	O
(	O
szLex	*(char)
[	O
0	int
]	O
==	O
CH_RBRACE	O
)	O
{	O
if	O
(	O
panal	O
->	O
wContext	O
&	O
CN_EXPERIMENT	O
)	O
{	O
bReturn	O
&=	O
EndExperiment	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
panal	O
)	O
;	O
break	O
;	O
}	O
else	O
{	O
bReturn	O
&=	O
EndLevel	O
(	O
panal	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
szLex	*(char)
[	O
0	int
]	O
==	O
CH_COMMENT	O
)	O
{	O
SkipComment	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(void)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
;	O
break	O
;	O
}	O
default	O
:	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_UNEXPECTED	O
,	O
szLex	*(char)
,	O
"* Ignoring"	*(char)
)	O
;	O
break	O
;	O
case	O
LX_INTEGER	O
:	O
case	O
LX_FLOAT	O
:	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_UNEXPNUMBER	O
,	O
szLex	*(char)
,	O
"* Ignoring"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
while	O
(	O
panal	O
->	O
wContext	O
!=	O
CN_END	O
&&	O
(	O
*	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
->	O
pbufCur	*(char)
||	O
FillBuffer	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),int,int,int,*(void))))->(int)
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
)	O
!=	O
EOF	O
)	O
)	O
;	O
if	O
(	O
panal	O
->	O
iCurrentDepth	O
!=	O
0	int
)	O
ReportError	O
(	O
pibIn	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),int,int,int,*(void)))
,	O
RE_OPENLEVEL	O
|	O
RE_FATAL	O
,	O
"ReadAnalysis"	*(char)
,	O
NULL	O
)	O
;	O
return	O
(	O
bReturn	O
)	O
;	O
}	O
