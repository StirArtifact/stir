static	O
int	O
find_backfilling_move	(int,int,*(int),array(int))->(int)
(	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
int	O
*	O
backfill_move	*(int)
,	O
int	O
forbidden_moves	*(int)
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
int	O
filllib_confirm_safety	(int,int,*(int))->(int)
(	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
int	O
*	O
defense_point	*(int)
)	O
;	O
static	O
int	O
living_neighbor	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
dragon	int
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
analyze_neighbor	(int,*(int),*(int))->(void)
(	O
int	O
pos	int
,	O
int	O
*	O
found_black	*(int)
,	O
int	O
*	O
found_white	*(int)
)	O
{	O
switch	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
{	O
case	O
EMPTY	int
:	O
if	O
(	O
!	O
(	O
*	O
found_black	*(int)
)	O
&&	O
living_neighbor	(int,int)->(int)
(	O
pos	int
,	O
BLACK	int
)	O
&&	O
safe_move	(int,int)->(int)
(	O
pos	int
,	O
WHITE	int
)	O
!=	O
WIN	int
)	O
*	O
found_black	*(int)
=	O
1	int
;	O
if	O
(	O
!	O
(	O
*	O
found_white	*(int)
)	O
&&	O
living_neighbor	(int,int)->(int)
(	O
pos	int
,	O
WHITE	int
)	O
&&	O
safe_move	(int,int)->(int)
(	O
pos	int
,	O
BLACK	int
)	O
!=	O
WIN	int
)	O
*	O
found_white	*(int)
=	O
1	int
;	O
break	O
;	O
case	O
BLACK	int
:	O
if	O
(	O
!	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
inessential	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
safety	int
!=	O
INESSENTIAL	int
)	O
{	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
||	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
UNKNOWN	int
)	O
*	O
found_black	*(int)
=	O
1	int
;	O
else	O
*	O
found_white	*(int)
=	O
1	int
;	O
}	O
break	O
;	O
case	O
WHITE	int
:	O
if	O
(	O
!	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
inessential	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
safety	int
!=	O
INESSENTIAL	int
)	O
{	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
||	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
UNKNOWN	int
)	O
*	O
found_white	*(int)
=	O
1	int
;	O
else	O
*	O
found_black	*(int)
=	O
1	int
;	O
}	O
break	O
;	O
}	O
}	O
int	O
fill_liberty	(*(int),int)->(int)
(	O
int	O
*	O
move	*(int)
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
defense_point	*(int)
;	O
int	O
potential_color	array(int)
[	O
BOARDMAX	O
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
potential_color	array(int)
,	O
0	int
,	O
sizeof	O
(	O
potential_color	array(int)
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
)	O
continue	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
inessential	int
||	O
DRAGON2	O
(	O
pos	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
)	O
continue	O
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
ALIVE	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
potential_color	array(int)
[	O
pos2	int
]	O
|=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
12	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array(int)
[	O
k	int
%	O
8	int
]	O
;	O
if	O
(	O
k	int
>=	O
8	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
d	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
d	int
*=	O
2	int
;	O
}	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
d	int
]	O
==	O
EMPTY	int
)	O
potential_color	array(int)
[	O
pos	int
+	O
d	int
]	O
|=	O
board	*(char)
[	O
pos	int
]	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
found_white	*(int)
=	O
0	int
;	O
int	O
found_black	*(int)
=	O
0	int
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
potential_color	array(int)
[	O
pos	int
]	O
!=	O
GRAY	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
d	int
)	O
)	O
analyze_neighbor	(int,*(int),*(int))->(void)
(	O
pos	int
+	O
d	int
,	O
&	O
found_black	*(int)
,	O
&	O
found_white	*(int)
)	O
;	O
}	O
if	O
(	O
!	O
(	O
found_white	*(int)
&&	O
found_black	*(int)
)	O
)	O
continue	O
;	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Considering move at %1m.\n"	*(char)
,	O
pos	int
)	O
;	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
==	O
WIN	int
)	O
{	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Tactically safe.\n"	*(char)
)	O
;	O
if	O
(	O
filllib_confirm_safety	(int,int,*(int))->(int)
(	O
pos	int
,	O
color	int
,	O
&	O
defense_point	*(int)
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Safety confirmed.\n"	*(char)
)	O
;	O
*	O
move	*(int)
=	O
pos	int
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
defense_point	*(int)
!=	O
NO_MOVE	O
&&	O
is_legal	(int,int)->(int)
(	O
defense_point	*(int)
,	O
color	int
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Safety not confirmed, but %1m defends.\n"	*(char)
,	O
defense_point	*(int)
)	O
;	O
*	O
move	*(int)
=	O
defense_point	*(int)
;	O
return	O
1	int
;	O
}	O
else	O
{	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Safety not confirmed, discarded.\n"	*(char)
)	O
;	O
TRACE	O
(	O
"Warning: Blunder detected in fill_liberty().\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
"fill_liberty"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
int	O
forbidden_moves	*(int)
[	O
BOARDMAX	O
]	O
;	O
popgo	()->(void)
(	O
)	O
;	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Legal but not safe, looking for backfilling move.\n"	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
forbidden_moves	*(int)
,	O
0	int
,	O
sizeof	O
(	O
forbidden_moves	*(int)
)	O
)	O
;	O
while	O
(	O
find_backfilling_move	(int,int,*(int),array(int))->(int)
(	O
pos	int
,	O
color	int
,	O
move	*(int)
,	O
forbidden_moves	*(int)
)	O
)	O
{	O
forbidden_moves	*(int)
[	O
*	O
move	*(int)
]	O
=	O
1	int
;	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Backfilling move at %1m.\n"	*(char)
,	O
*	O
move	*(int)
)	O
;	O
if	O
(	O
!	O
is_legal	(int,int)->(int)
(	O
*	O
move	*(int)
,	O
color	int
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Was illegal, discarded.\n"	*(char)
)	O
;	O
*	O
move	*(int)
=	O
NO_MOVE	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
filllib_confirm_safety	(int,int,*(int))->(int)
(	O
*	O
move	*(int)
,	O
color	int
,	O
&	O
defense_point	*(int)
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Safety not confirmed, discarded.\n"	*(char)
)	O
;	O
*	O
move	*(int)
=	O
NO_MOVE	O
;	O
continue	O
;	O
}	O
return	O
1	int
;	O
}	O
if	O
(	O
does_capture_something	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Not tactically safe, but captures stones.\n"	*(char)
)	O
;	O
if	O
(	O
!	O
filllib_confirm_safety	(int,int,*(int))->(int)
(	O
pos	int
,	O
color	int
,	O
&	O
defense_point	*(int)
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Safety not confirmed, discarded.\n"	*(char)
)	O
;	O
continue	O
;	O
}	O
*	O
move	*(int)
=	O
pos	int
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Illegal, looking for back-capture.\n"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
d	int
]	O
==	O
other	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
+	O
d	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
==	O
WIN	int
)	O
{	O
*	O
move	*(int)
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
+	O
d	int
]	O
.	O
attack_points	array(int)
[	O
0	int
]	O
;	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Found at %1m.\n"	*(char)
,	O
*	O
move	*(int)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Nothing found, looking for ko back-capture.\n"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
d	int
]	O
==	O
other	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
+	O
d	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
is_legal	(int,int)->(int)
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
+	O
d	int
]	O
.	O
attack_points	array(int)
[	O
0	int
]	O
,	O
color	int
)	O
)	O
{	O
*	O
move	*(int)
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
+	O
d	int
]	O
.	O
attack_points	array(int)
[	O
0	int
]	O
;	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Found at %1m.\n"	*(char)
,	O
*	O
move	*(int)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Nothing found, looking for threat to back-capture.\n"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
d	int
]	O
==	O
other	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
+	O
d	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
if	O
(	O
findlib	(int,int,*(int))->(int)
(	O
pos	int
+	O
d	int
,	O
2	int
,	O
libs	*(int)
)	O
>	O
1	int
)	O
{	O
if	O
(	O
is_legal	(int,int)->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
color	int
)	O
)	O
*	O
move	*(int)
=	O
libs	*(int)
[	O
0	int
]	O
;	O
else	O
if	O
(	O
is_legal	(int,int)->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
color	int
)	O
)	O
*	O
move	*(int)
=	O
libs	*(int)
[	O
1	int
]	O
;	O
else	O
continue	O
;	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: Found at %1m.\n"	*(char)
,	O
*	O
move	*(int)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
}	O
}	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"Filllib: No move found.\n"	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
static	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
static	O
int	O
find_backfilling_move	(int,int,*(int),array(int))->(int)
(	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
int	O
*	O
backfill_move	*(int)
,	O
int	O
forbidden_moves	*(int)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
liberties	*(int)
;	O
int	O
neighbors	int
;	O
int	O
found_one	int
=	O
0	int
;	O
int	O
apos	int
=	O
NO_MOVE	O
;	O
int	O
bpos	int
=	O
NO_MOVE	O
;	O
int	O
extra_pop	int
=	O
0	int
;	O
int	O
success	int
=	O
0	int
;	O
int	O
acode	int
;	O
int	O
saved_move	int
=	O
NO_MOVE	O
;	O
int	O
opponent_libs	int
;	O
DEBUG	O
(	O
DEBUG_FILLLIB	int
,	O
"find_backfilling_move for %C %1m\n"	*(char)
,	O
color	int
,	O
move	*(int)
)	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_FILLLIB	int
)	O
dump_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
"find_backfilling_move"	*(char)
,	O
move	*(int)
)	O
)	O
return	O
0	int
;	O
acode	int
=	O
attack	(int,*(int))->(int)
(	O
move	*(int)
,	O
&	O
apos	int
)	O
;	O
gg_assert	O
(	O
acode	int
!=	O
0	int
&&	O
apos	int
!=	O
NO_MOVE	O
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
move	*(int)
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
neighbors	int
=	O
chainlinks	(int,array(int))->(int)
(	O
move	*(int)
,	O
adjs	array(int)
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
for	O
(	O
opponent_libs	int
=	O
1	int
;	O
opponent_libs	int
<=	O
1	int
;	O
opponent_libs	int
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
opponent_libs	int
<	O
5	int
&&	O
countlib	(int)->(int)
(	O
adjs	array(int)
[	O
k	int
]	O
)	O
!=	O
opponent_libs	int
)	O
continue	O
;	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
adjs	array(int)
[	O
k	int
]	O
,	O
&	O
bpos	int
)	O
==	O
WIN	int
)	O
{	O
if	O
(	O
forbidden_moves	*(int)
[	O
bpos	int
]	O
)	O
continue	O
;	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
bpos	int
,	O
adjs	array(int)
[	O
k	int
]	O
)	O
)	O
{	O
*	O
backfill_move	*(int)
=	O
bpos	int
;	O
return	O
1	int
;	O
}	O
else	O
saved_move	int
=	O
bpos	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
found_one	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
forbidden_moves	*(int)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
&&	O
safe_move	(int,int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
color	int
)	O
==	O
WIN	int
)	O
{	O
*	O
backfill_move	*(int)
=	O
libs	*(int)
[	O
k	int
]	O
;	O
found_one	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
found_one	int
)	O
{	O
for	O
(	O
opponent_libs	int
=	O
2	int
;	O
opponent_libs	int
<=	O
5	int
;	O
opponent_libs	int
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
opponent_libs	int
<	O
5	int
&&	O
countlib	(int)->(int)
(	O
adjs	array(int)
[	O
k	int
]	O
)	O
!=	O
opponent_libs	int
)	O
continue	O
;	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
adjs	array(int)
[	O
k	int
]	O
,	O
&	O
bpos	int
)	O
==	O
WIN	int
)	O
{	O
if	O
(	O
forbidden_moves	*(int)
[	O
bpos	int
]	O
)	O
continue	O
;	O
if	O
(	O
liberty_of_string	(int,int)->(int)
(	O
bpos	int
,	O
adjs	array(int)
[	O
k	int
]	O
)	O
)	O
{	O
*	O
backfill_move	*(int)
=	O
bpos	int
;	O
return	O
1	int
;	O
}	O
else	O
saved_move	int
=	O
bpos	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
found_one	int
)	O
{	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
"find_backfilling_move"	*(char)
,	O
move	*(int)
)	O
;	O
find_proper_superstring_liberties	(int,*(int),*(int),int)->(void)
(	O
move	*(int)
,	O
&	O
liberties	*(int)
,	O
libs	*(int)
,	O
0	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
forbidden_moves	*(int)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
&&	O
safe_move	(int,int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
color	int
)	O
==	O
WIN	int
)	O
{	O
*	O
backfill_move	*(int)
=	O
libs	*(int)
[	O
k	int
]	O
;	O
found_one	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
found_one	int
)	O
{	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
"find_backfilling_move"	*(char)
,	O
move	*(int)
)	O
;	O
superstring_chainlinks	(int,*(int),array(int),int)->(void)
(	O
move	*(int)
,	O
&	O
neighbors	int
,	O
adjs	array(int)
,	O
4	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
adjs	array(int)
[	O
k	int
]	O
,	O
&	O
bpos	int
)	O
==	O
WIN	int
)	O
{	O
if	O
(	O
!	O
forbidden_moves	*(int)
[	O
bpos	int
]	O
&&	O
liberty_of_string	(int,int)->(int)
(	O
bpos	int
,	O
adjs	array(int)
[	O
k	int
]	O
)	O
)	O
{	O
*	O
backfill_move	*(int)
=	O
bpos	int
;	O
return	O
1	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
found_one	int
)	O
{	O
ASSERT1	O
(	O
!	O
forbidden_moves	*(int)
[	O
*	O
backfill_move	*(int)
]	O
,	O
*	O
backfill_move	*(int)
)	O
;	O
if	O
(	O
!	O
trymove	(int,int,*(char),int)->(int)
(	O
*	O
backfill_move	*(int)
,	O
color	int
,	O
"find_backfilling_move"	*(char)
,	O
move	*(int)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
apos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
"find_backfilling_move"	*(char)
,	O
move	*(int)
)	O
)	O
extra_pop	int
=	O
1	int
;	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
move	*(int)
,	O
color	int
)	O
==	O
WIN	int
)	O
success	int
=	O
1	int
;	O
else	O
success	int
=	O
find_backfilling_move	(int,int,*(int),array(int))->(int)
(	O
move	*(int)
,	O
color	int
,	O
backfill_move	*(int)
,	O
forbidden_moves	*(int)
)	O
;	O
if	O
(	O
extra_pop	int
)	O
popgo	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
!	O
success	int
&&	O
saved_move	int
!=	O
NO_MOVE	O
)	O
{	O
ASSERT1	O
(	O
!	O
forbidden_moves	*(int)
[	O
saved_move	int
]	O
,	O
saved_move	int
)	O
;	O
*	O
backfill_move	*(int)
=	O
saved_move	int
;	O
success	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
success	int
)	O
*	O
backfill_move	*(int)
=	O
NO_MOVE	O
;	O
return	O
success	int
;	O
}	O
static	O
int	O
filllib_confirm_safety	(int,int,*(int))->(int)
(	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
int	O
*	O
defense_point	*(int)
)	O
{	O
int	O
k	int
;	O
int	O
apos	int
=	O
NO_MOVE	O
;	O
int	O
save_verbose	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
gg_assert	O
(	O
defense_point	*(int)
!=	O
NULL	O
)	O
;	O
*	O
defense_point	*(int)
=	O
NO_MOVE	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
color	int
)	O
{	O
apos	int
=	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
;	O
break	O
;	O
}	O
if	O
(	O
apos	int
==	O
NO_MOVE	O
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
!	O
play_attack_defend_n	(int,int,int)->(int)
(	O
color	int
,	O
0	int
,	O
1	int
,	O
move	*(int)
,	O
pos2	int
)	O
)	O
{	O
int	O
adj	array(int)
;	O
adj	array(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
pos2	int
,	O
adjs	array(int)
)	O
;	O
if	O
(	O
adj	array(int)
==	O
0	int
)	O
return	O
0	int
;	O
apos	int
=	O
adjs	array(int)
[	O
0	int
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
apos	int
==	O
NO_MOVE	O
)	O
{	O
for	O
(	O
k	int
=	O
4	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
color	int
)	O
{	O
apos	int
=	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
apos	int
==	O
NO_MOVE	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
move	*(int)
+	O
2	int
*	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
color	int
)	O
{	O
apos	int
=	O
move	*(int)
+	O
2	int
*	O
delta	array(int)
[	O
k	int
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
apos	int
==	O
NO_MOVE	O
)	O
return	O
0	int
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
if	O
(	O
!	O
owl_does_defend	(int,int,*(int))->(int)
(	O
move	*(int)
,	O
apos	int
,	O
NULL	O
)	O
)	O
return	O
0	int
;	O
verbose	int
=	O
save_verbose	int
;	O
return	O
confirm_safety	(int,int,*(int),array(char))->(int)
(	O
move	*(int)
,	O
color	int
,	O
defense_point	*(int)
,	O
NULL	O
)	O
;	O
}	O
