struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
{	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int)
style	enum(int,int,int,int,int,int,int)
;	O
unsigned	O
int	O
quote_these_too	array(int)
[	O
(	O
UCHAR_MAX	O
/	O
INT_BITS	O
)	O
+	O
1	int
]	O
;	O
}	O
;	O
char	O
const	O
*	O
const	O
quoting_style_args	array(*(char))
[	O
]	O
=	O
{	O
"literal"	*(char)
,	O
"shell"	*(char)
,	O
"shell-always"	*(char)
,	O
"c"	*(char)
,	O
"escape"	*(char)
,	O
"locale"	*(char)
,	O
"clocale"	*(char)
,	O
0	int
}	O
;	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int)
const	O
quoting_style_vals	array(enum(int,int,int,int,int,int,int))
[	O
]	O
=	O
{	O
literal_quoting_style	int
,	O
shell_quoting_style	int
,	O
shell_always_quoting_style	int
,	O
c_quoting_style	int
,	O
escape_quoting_style	int
,	O
locale_quoting_style	int
,	O
clocale_quoting_style	int
}	O
;	O
static	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
default_quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
;	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
*	O
clone_quoting_options	(*(struct))->(*(struct))
(	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
*	O
o	*(struct)
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
*	O
p	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
p	*(void)
)	O
;	O
*	O
p	*(void)
=	O
*	O
(	O
o	*(struct)
?	O
o	*(struct)
:	O
&	O
default_quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
)	O
;	O
errno	O
=	O
e	int
;	O
return	O
p	*(void)
;	O
}	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int)
get_quoting_style	(*(struct))->(enum(int,int,int,int,int,int,int))
(	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
*	O
o	*(struct)
)	O
{	O
return	O
(	O
o	*(struct)
?	O
o	*(struct)
:	O
&	O
default_quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
)	O
->	O
style	enum(int,int,int,int,int,int,int)
;	O
}	O
void	O
set_quoting_style	(*(struct),enum(int,int,int,int,int,int,int))->(void)
(	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
*	O
o	*(struct)
,	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int)
s	enum(int,int,int,int,int,int,int)
)	O
{	O
(	O
o	*(struct)
?	O
o	*(struct)
:	O
&	O
default_quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
)	O
->	O
style	enum(int,int,int,int,int,int,int)
=	O
s	enum(int,int,int,int,int,int,int)
;	O
}	O
int	O
set_char_quoting	(*(struct),char,int)->(int)
(	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
*	O
o	*(struct)
,	O
char	O
c	char
,	O
int	O
i	int
)	O
{	O
unsigned	O
char	O
uc	char
=	O
c	char
;	O
unsigned	O
int	O
*	O
p	*(void)
=	O
(	O
o	*(struct)
?	O
o	*(struct)
:	O
&	O
default_quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
)	O
->	O
quote_these_too	array(int)
+	O
uc	char
/	O
INT_BITS	O
;	O
int	O
shift	int
=	O
uc	char
%	O
INT_BITS	O
;	O
int	O
r	int
=	O
(	O
*	O
p	*(void)
>>	O
shift	int
)	O
&	O
1	int
;	O
*	O
p	*(void)
^=	O
(	O
(	O
i	int
&	O
1	int
)	O
^	O
r	int
)	O
<<	O
shift	int
;	O
return	O
r	int
;	O
}	O
static	O
char	O
const	O
*	O
gettext_quote	(*(char),enum(int,int,int,int,int,int,int))->(*(char))
(	O
char	O
const	O
*	O
msgid	*(char)
,	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int)
s	enum(int,int,int,int,int,int,int)
)	O
{	O
char	O
const	O
*	O
translation	*(char)
=	O
_	O
(	O
msgid	*(char)
)	O
;	O
if	O
(	O
translation	*(char)
==	O
msgid	*(char)
&&	O
s	enum(int,int,int,int,int,int,int)
==	O
clocale_quoting_style	int
)	O
translation	*(char)
=	O
"\""	*(char)
;	O
return	O
translation	*(char)
;	O
}	O
static	O
size_t	long
quotearg_buffer_restyled	(*(char),long,*(char),long,enum(int,int,int,int,int,int,int),*(struct(enum(int,int,int,int,int,int,int),array(int))))->(long)
(	O
char	O
*	O
buffer	*(char)
,	O
size_t	long
buffersize	long
,	O
char	O
const	O
*	O
arg	*(char)
,	O
size_t	long
argsize	long
,	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int)
quoting_style	enum(int,int,int,int,int,int,int)
,	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
const	O
*	O
o	*(struct)
)	O
{	O
size_t	long
i	int
;	O
size_t	long
len	long
=	O
0	int
;	O
char	O
const	O
*	O
quote_string	*(char)
=	O
0	int
;	O
size_t	long
quote_string_len	long
=	O
0	int
;	O
bool	bool
backslash_escapes	bool
=	O
false	int
;	O
bool	bool
unibyte_locale	bool
=	O
MB_CUR_MAX	O
==	O
1	int
;	O
switch	O
(	O
quoting_style	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
c_quoting_style	int
:	O
STORE	O
(	O
'"'	O
)	O
;	O
backslash_escapes	bool
=	O
true	int
;	O
quote_string	*(char)
=	O
"\""	*(char)
;	O
quote_string_len	long
=	O
1	int
;	O
break	O
;	O
case	O
escape_quoting_style	int
:	O
backslash_escapes	bool
=	O
true	int
;	O
break	O
;	O
case	O
locale_quoting_style	int
:	O
case	O
clocale_quoting_style	int
:	O
{	O
char	O
const	O
*	O
left	*(char)
=	O
gettext_quote	(*(char),enum(int,int,int,int,int,int,int))->(*(char))
(	O
N_	O
(	O
"`"	*(char)
)	O
,	O
quoting_style	enum(int,int,int,int,int,int,int)
)	O
;	O
char	O
const	O
*	O
right	*(char)
=	O
gettext_quote	(*(char),enum(int,int,int,int,int,int,int))->(*(char))
(	O
N_	O
(	O
"'"	*(char)
)	O
,	O
quoting_style	enum(int,int,int,int,int,int,int)
)	O
;	O
for	O
(	O
quote_string	*(char)
=	O
left	*(char)
;	O
*	O
quote_string	*(char)
;	O
quote_string	*(char)
++	O
)	O
STORE	O
(	O
*	O
quote_string	*(char)
)	O
;	O
backslash_escapes	bool
=	O
true	int
;	O
quote_string	*(char)
=	O
right	*(char)
;	O
quote_string_len	long
=	O
strlen	(*(char))->(long)
(	O
quote_string	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
shell_always_quoting_style	int
:	O
STORE	O
(	O
'\''	O
)	O
;	O
quote_string	*(char)
=	O
"'"	*(char)
;	O
quote_string_len	long
=	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
!	O
(	O
argsize	long
==	O
SIZE_MAX	O
?	O
arg	*(char)
[	O
i	int
]	O
==	O
'\0'	O
:	O
i	int
==	O
argsize	long
)	O
;	O
i	int
++	O
)	O
{	O
unsigned	O
char	O
c	char
;	O
unsigned	O
char	O
esc	char
;	O
if	O
(	O
backslash_escapes	bool
&&	O
quote_string_len	long
&&	O
i	int
+	O
quote_string_len	long
<=	O
argsize	long
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
arg	*(char)
+	O
i	int
,	O
quote_string	*(char)
,	O
quote_string_len	long
)	O
==	O
0	int
)	O
STORE	O
(	O
'\\'	O
)	O
;	O
c	char
=	O
arg	*(char)
[	O
i	int
]	O
;	O
switch	O
(	O
c	char
)	O
{	O
case	O
'\0'	O
:	O
if	O
(	O
backslash_escapes	bool
)	O
{	O
STORE	O
(	O
'\\'	O
)	O
;	O
STORE	O
(	O
'0'	O
)	O
;	O
STORE	O
(	O
'0'	O
)	O
;	O
c	char
=	O
'0'	O
;	O
}	O
break	O
;	O
case	O
'?'	O
:	O
switch	O
(	O
quoting_style	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
shell_quoting_style	int
:	O
goto	O
use_shell_always_quoting_style	O
;	O
case	O
c_quoting_style	int
:	O
if	O
(	O
i	int
+	O
2	int
<	O
argsize	long
&&	O
arg	*(char)
[	O
i	int
+	O
1	int
]	O
==	O
'?'	O
)	O
switch	O
(	O
arg	*(char)
[	O
i	int
+	O
2	int
]	O
)	O
{	O
case	O
'!'	O
:	O
case	O
'\''	O
:	O
case	O
'('	O
:	O
case	O
')'	O
:	O
case	O
'-'	O
:	O
case	O
'/'	O
:	O
case	O
'<'	O
:	O
case	O
'='	O
:	O
case	O
'>'	O
:	O
c	char
=	O
arg	*(char)
[	O
i	int
+	O
2	int
]	O
;	O
i	int
+=	O
2	int
;	O
STORE	O
(	O
'?'	O
)	O
;	O
STORE	O
(	O
'\\'	O
)	O
;	O
STORE	O
(	O
'?'	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
'\a'	O
:	O
esc	char
=	O
'a'	O
;	O
goto	O
c_escape	O
;	O
case	O
'\b'	O
:	O
esc	char
=	O
'b'	O
;	O
goto	O
c_escape	O
;	O
case	O
'\f'	O
:	O
esc	char
=	O
'f'	O
;	O
goto	O
c_escape	O
;	O
case	O
'\n'	O
:	O
esc	char
=	O
'n'	O
;	O
goto	O
c_and_shell_escape	O
;	O
case	O
'\r'	O
:	O
esc	char
=	O
'r'	O
;	O
goto	O
c_and_shell_escape	O
;	O
case	O
'\t'	O
:	O
esc	char
=	O
't'	O
;	O
goto	O
c_and_shell_escape	O
;	O
case	O
'\v'	O
:	O
esc	char
=	O
'v'	O
;	O
goto	O
c_escape	O
;	O
case	O
'\\'	O
:	O
esc	char
=	O
c	char
;	O
goto	O
c_and_shell_escape	O
;	O
c_and_shell_escape	O
:	O
if	O
(	O
quoting_style	enum(int,int,int,int,int,int,int)
==	O
shell_quoting_style	int
)	O
goto	O
use_shell_always_quoting_style	O
;	O
c_escape	O
:	O
if	O
(	O
backslash_escapes	bool
)	O
{	O
c	char
=	O
esc	char
;	O
goto	O
store_escape	O
;	O
}	O
break	O
;	O
case	O
'{'	O
:	O
case	O
'}'	O
:	O
if	O
(	O
!	O
(	O
argsize	long
==	O
SIZE_MAX	O
?	O
arg	*(char)
[	O
1	int
]	O
==	O
'\0'	O
:	O
argsize	long
==	O
1	int
)	O
)	O
break	O
;	O
case	O
'#'	O
:	O
case	O
'~'	O
:	O
if	O
(	O
i	int
!=	O
0	int
)	O
break	O
;	O
case	O
' '	O
:	O
case	O
'!'	O
:	O
case	O
'"'	O
:	O
case	O
'$'	O
:	O
case	O
'&'	O
:	O
case	O
'('	O
:	O
case	O
')'	O
:	O
case	O
'*'	O
:	O
case	O
';'	O
:	O
case	O
'<'	O
:	O
case	O
'='	O
:	O
case	O
'>'	O
:	O
case	O
'['	O
:	O
case	O
'^'	O
:	O
case	O
'`'	O
:	O
case	O
'|'	O
:	O
if	O
(	O
quoting_style	enum(int,int,int,int,int,int,int)
==	O
shell_quoting_style	int
)	O
goto	O
use_shell_always_quoting_style	O
;	O
break	O
;	O
case	O
'\''	O
:	O
switch	O
(	O
quoting_style	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
shell_quoting_style	int
:	O
goto	O
use_shell_always_quoting_style	O
;	O
case	O
shell_always_quoting_style	int
:	O
STORE	O
(	O
'\''	O
)	O
;	O
STORE	O
(	O
'\\'	O
)	O
;	O
STORE	O
(	O
'\''	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
'%'	O
:	O
case	O
'+'	O
:	O
case	O
','	O
:	O
case	O
'-'	O
:	O
case	O
'.'	O
:	O
case	O
'/'	O
:	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
case	O
':'	O
:	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'C'	O
:	O
case	O
'D'	O
:	O
case	O
'E'	O
:	O
case	O
'F'	O
:	O
case	O
'G'	O
:	O
case	O
'H'	O
:	O
case	O
'I'	O
:	O
case	O
'J'	O
:	O
case	O
'K'	O
:	O
case	O
'L'	O
:	O
case	O
'M'	O
:	O
case	O
'N'	O
:	O
case	O
'O'	O
:	O
case	O
'P'	O
:	O
case	O
'Q'	O
:	O
case	O
'R'	O
:	O
case	O
'S'	O
:	O
case	O
'T'	O
:	O
case	O
'U'	O
:	O
case	O
'V'	O
:	O
case	O
'W'	O
:	O
case	O
'X'	O
:	O
case	O
'Y'	O
:	O
case	O
'Z'	O
:	O
case	O
']'	O
:	O
case	O
'_'	O
:	O
case	O
'a'	O
:	O
case	O
'b'	O
:	O
case	O
'c'	O
:	O
case	O
'd'	O
:	O
case	O
'e'	O
:	O
case	O
'f'	O
:	O
case	O
'g'	O
:	O
case	O
'h'	O
:	O
case	O
'i'	O
:	O
case	O
'j'	O
:	O
case	O
'k'	O
:	O
case	O
'l'	O
:	O
case	O
'm'	O
:	O
case	O
'n'	O
:	O
case	O
'o'	O
:	O
case	O
'p'	O
:	O
case	O
'q'	O
:	O
case	O
'r'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
case	O
'v'	O
:	O
case	O
'w'	O
:	O
case	O
'x'	O
:	O
case	O
'y'	O
:	O
case	O
'z'	O
:	O
break	O
;	O
default	O
:	O
{	O
size_t	long
m	long
;	O
bool	bool
printable	bool
;	O
if	O
(	O
unibyte_locale	bool
)	O
{	O
m	long
=	O
1	int
;	O
printable	bool
=	O
isprint	(int)->(int)
(	O
c	char
)	O
!=	O
0	int
;	O
}	O
else	O
{	O
mbstate_t	struct(int,union(int,array(char)))
mbstate	struct(int,union(int,array(char)))
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
mbstate	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
mbstate	struct(int,union(int,array(char)))
)	O
;	O
m	long
=	O
0	int
;	O
printable	bool
=	O
true	int
;	O
if	O
(	O
argsize	long
==	O
SIZE_MAX	O
)	O
argsize	long
=	O
strlen	(*(char))->(long)
(	O
arg	*(char)
)	O
;	O
do	O
{	O
wchar_t	int
w	int
;	O
size_t	long
bytes	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
w	int
,	O
&	O
arg	*(char)
[	O
i	int
+	O
m	long
]	O
,	O
argsize	long
-	O
(	O
i	int
+	O
m	long
)	O
,	O
&	O
mbstate	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
bytes	long
==	O
0	int
)	O
break	O
;	O
else	O
if	O
(	O
bytes	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
printable	bool
=	O
false	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
bytes	long
==	O
(	O
size_t	long
)	O
-	O
2	int
)	O
{	O
printable	bool
=	O
false	int
;	O
while	O
(	O
i	int
+	O
m	long
<	O
argsize	long
&&	O
arg	*(char)
[	O
i	int
+	O
m	long
]	O
)	O
m	long
++	O
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
'['	O
==	O
0x5b	int
&&	O
quoting_style	enum(int,int,int,int,int,int,int)
==	O
shell_quoting_style	int
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
1	int
;	O
j	long
<	O
bytes	long
;	O
j	long
++	O
)	O
switch	O
(	O
arg	*(char)
[	O
i	int
+	O
m	long
+	O
j	long
]	O
)	O
{	O
case	O
'['	O
:	O
case	O
'\\'	O
:	O
case	O
'^'	O
:	O
case	O
'`'	O
:	O
case	O
'|'	O
:	O
goto	O
use_shell_always_quoting_style	O
;	O
}	O
}	O
if	O
(	O
!	O
iswprint	(int)->(int)
(	O
w	int
)	O
)	O
printable	bool
=	O
false	int
;	O
m	long
+=	O
bytes	long
;	O
}	O
}	O
while	O
(	O
!	O
mbsinit	(*(struct(int,union(int,array(char)))))->(int)
(	O
&	O
mbstate	struct(int,union(int,array(char)))
)	O
)	O
;	O
}	O
if	O
(	O
1	int
<	O
m	long
||	O
(	O
backslash_escapes	bool
&&	O
!	O
printable	bool
)	O
)	O
{	O
size_t	long
ilim	long
=	O
i	int
+	O
m	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
backslash_escapes	bool
&&	O
!	O
printable	bool
)	O
{	O
STORE	O
(	O
'\\'	O
)	O
;	O
STORE	O
(	O
'0'	O
+	O
(	O
c	char
>>	O
6	int
)	O
)	O
;	O
STORE	O
(	O
'0'	O
+	O
(	O
(	O
c	char
>>	O
3	int
)	O
&	O
7	int
)	O
)	O
;	O
c	char
=	O
'0'	O
+	O
(	O
c	char
&	O
7	int
)	O
;	O
}	O
if	O
(	O
ilim	long
<=	O
i	int
+	O
1	int
)	O
break	O
;	O
STORE	O
(	O
c	char
)	O
;	O
c	char
=	O
arg	*(char)
[	O
++	O
i	int
]	O
;	O
}	O
goto	O
store_c	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
(	O
backslash_escapes	bool
&&	O
o	*(struct)
->	O
quote_these_too	array(int)
[	O
c	char
/	O
INT_BITS	O
]	O
&	O
(	O
1	int
<<	O
(	O
c	char
%	O
INT_BITS	O
)	O
)	O
)	O
)	O
goto	O
store_c	O
;	O
store_escape	O
:	O
STORE	O
(	O
'\\'	O
)	O
;	O
store_c	O
:	O
STORE	O
(	O
c	char
)	O
;	O
}	O
if	O
(	O
i	int
==	O
0	int
&&	O
quoting_style	enum(int,int,int,int,int,int,int)
==	O
shell_quoting_style	int
)	O
goto	O
use_shell_always_quoting_style	O
;	O
if	O
(	O
quote_string	*(char)
)	O
for	O
(	O
;	O
*	O
quote_string	*(char)
;	O
quote_string	*(char)
++	O
)	O
STORE	O
(	O
*	O
quote_string	*(char)
)	O
;	O
if	O
(	O
len	long
<	O
buffersize	long
)	O
buffer	*(char)
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
len	long
;	O
use_shell_always_quoting_style	O
:	O
return	O
quotearg_buffer_restyled	(*(char),long,*(char),long,enum(int,int,int,int,int,int,int),*(struct(enum(int,int,int,int,int,int,int),array(int))))->(long)
(	O
buffer	*(char)
,	O
buffersize	long
,	O
arg	*(char)
,	O
argsize	long
,	O
shell_always_quoting_style	int
,	O
o	*(struct)
)	O
;	O
}	O
size_t	long
quotearg_buffer	(*(char),long,*(char),long,*(struct))->(long)
(	O
char	O
*	O
buffer	*(char)
,	O
size_t	long
buffersize	long
,	O
char	O
const	O
*	O
arg	*(char)
,	O
size_t	long
argsize	long
,	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
const	O
*	O
o	*(struct)
)	O
{	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
const	O
*	O
p	*(void)
=	O
o	*(struct)
?	O
o	*(struct)
:	O
&	O
default_quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
;	O
int	O
e	int
=	O
errno	O
;	O
size_t	long
r	int
=	O
quotearg_buffer_restyled	(*(char),long,*(char),long,enum(int,int,int,int,int,int,int),*(struct(enum(int,int,int,int,int,int,int),array(int))))->(long)
(	O
buffer	*(char)
,	O
buffersize	long
,	O
arg	*(char)
,	O
argsize	long
,	O
p	*(void)
->	O
style	enum(int,int,int,int,int,int,int)
,	O
p	*(void)
)	O
;	O
errno	O
=	O
e	int
;	O
return	O
r	int
;	O
}	O
char	O
*	O
quotearg_alloc	(*(char),long,*(struct))->(*(char))
(	O
char	O
const	O
*	O
arg	*(char)
,	O
size_t	long
argsize	long
,	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
const	O
*	O
o	*(struct)
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
size_t	long
bufsize	long
=	O
quotearg_buffer	(*(char),long,*(char),long,*(struct))->(long)
(	O
0	int
,	O
0	int
,	O
arg	*(char)
,	O
argsize	long
,	O
o	*(struct)
)	O
+	O
1	int
;	O
char	O
*	O
buf	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
bufsize	long
)	O
;	O
quotearg_buffer	(*(char),long,*(char),long,*(struct))->(long)
(	O
buf	*(char)
,	O
bufsize	long
,	O
arg	*(char)
,	O
argsize	long
,	O
o	*(struct)
)	O
;	O
errno	O
=	O
e	int
;	O
return	O
buf	*(char)
;	O
}	O
static	O
char	O
*	O
quotearg_n_options	(int,*(char),long,*(struct(enum(int,int,int,int,int,int,int),array(int))))->(*(char))
(	O
int	O
n	int
,	O
char	O
const	O
*	O
arg	*(char)
,	O
size_t	long
argsize	long
,	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
const	O
*	O
options	*(struct(enum(int,int,int,int,int,int,int),array(int)))
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
static	O
char	O
slot0	array(char)
[	O
256	int
]	O
;	O
static	O
unsigned	O
int	O
nslots	int
=	O
1	int
;	O
unsigned	O
int	O
n0	int
=	O
n	int
;	O
struct	O
slotvec	struct(long,*(char))
{	O
size_t	long
size	long
;	O
char	O
*	O
val	*(char)
;	O
}	O
;	O
static	O
struct	O
slotvec	struct(long,*(char))
slotvec0	struct(long,*(char))
=	O
{	O
sizeof	O
slot0	array(char)
,	O
slot0	array(char)
}	O
;	O
static	O
struct	O
slotvec	struct(long,*(char))
*	O
slotvec	struct(long,*(char))
=	O
&	O
slotvec0	struct(long,*(char))
;	O
if	O
(	O
n	int
<	O
0	int
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
nslots	int
<=	O
n0	int
)	O
{	O
size_t	long
n1	long
=	O
n0	int
+	O
1	int
;	O
if	O
(	O
xalloc_oversized	O
(	O
n1	long
,	O
sizeof	O
*	O
slotvec	struct(long,*(char))
)	O
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
if	O
(	O
slotvec	struct(long,*(char))
==	O
&	O
slotvec0	struct(long,*(char))
)	O
{	O
slotvec	struct(long,*(char))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
*	O
slotvec	struct(long,*(char))
)	O
;	O
*	O
slotvec	struct(long,*(char))
=	O
slotvec0	struct(long,*(char))
;	O
}	O
slotvec	struct(long,*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
slotvec	struct(long,*(char))
,	O
n1	long
*	O
sizeof	O
*	O
slotvec	struct(long,*(char))
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
slotvec	struct(long,*(char))
+	O
nslots	int
,	O
0	int
,	O
(	O
n1	long
-	O
nslots	int
)	O
*	O
sizeof	O
*	O
slotvec	struct(long,*(char))
)	O
;	O
nslots	int
=	O
n1	long
;	O
}	O
{	O
size_t	long
size	long
=	O
slotvec	struct(long,*(char))
[	O
n	int
]	O
.	O
size	long
;	O
char	O
*	O
val	*(char)
=	O
slotvec	struct(long,*(char))
[	O
n	int
]	O
.	O
val	*(char)
;	O
size_t	long
qsize	long
=	O
quotearg_buffer	(*(char),long,*(char),long,*(struct))->(long)
(	O
val	*(char)
,	O
size	long
,	O
arg	*(char)
,	O
argsize	long
,	O
options	*(struct(enum(int,int,int,int,int,int,int),array(int)))
)	O
;	O
if	O
(	O
size	long
<=	O
qsize	long
)	O
{	O
slotvec	struct(long,*(char))
[	O
n	int
]	O
.	O
size	long
=	O
size	long
=	O
qsize	long
+	O
1	int
;	O
if	O
(	O
val	*(char)
!=	O
slot0	array(char)
)	O
free	(*(void))->(void)
(	O
val	*(char)
)	O
;	O
slotvec	struct(long,*(char))
[	O
n	int
]	O
.	O
val	*(char)
=	O
val	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
size	long
)	O
;	O
quotearg_buffer	(*(char),long,*(char),long,*(struct))->(long)
(	O
val	*(char)
,	O
size	long
,	O
arg	*(char)
,	O
argsize	long
,	O
options	*(struct(enum(int,int,int,int,int,int,int),array(int)))
)	O
;	O
}	O
errno	O
=	O
e	int
;	O
return	O
val	*(char)
;	O
}	O
}	O
char	O
*	O
quotearg_n	(int,*(char))->(*(char))
(	O
int	O
n	int
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
return	O
quotearg_n_options	(int,*(char),long,*(struct(enum(int,int,int,int,int,int,int),array(int))))->(*(char))
(	O
n	int
,	O
arg	*(char)
,	O
SIZE_MAX	O
,	O
&	O
default_quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
)	O
;	O
}	O
char	O
*	O
quotearg	(*(char))->(*(char))
(	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
return	O
quotearg_n	(int,*(char))->(*(char))
(	O
0	int
,	O
arg	*(char)
)	O
;	O
}	O
static	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
quoting_options_from_style	(enum(int,int,int,int,int,int,int))->(struct(enum(int,int,int,int,int,int,int),array(int)))
(	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int)
style	enum(int,int,int,int,int,int,int)
)	O
{	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
o	*(struct)
;	O
o	*(struct)
.	O
style	enum(int,int,int,int,int,int,int)
=	O
style	enum(int,int,int,int,int,int,int)
;	O
memset	(*(void),int,long)->(*(void))
(	O
o	*(struct)
.	O
quote_these_too	array(int)
,	O
0	int
,	O
sizeof	O
o	*(struct)
.	O
quote_these_too	array(int)
)	O
;	O
return	O
o	*(struct)
;	O
}	O
char	O
*	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int),*(char))->(*(char))
(	O
int	O
n	int
,	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int)
s	enum(int,int,int,int,int,int,int)
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
const	O
o	*(struct)
=	O
quoting_options_from_style	(enum(int,int,int,int,int,int,int))->(struct(enum(int,int,int,int,int,int,int),array(int)))
(	O
s	enum(int,int,int,int,int,int,int)
)	O
;	O
return	O
quotearg_n_options	(int,*(char),long,*(struct(enum(int,int,int,int,int,int,int),array(int))))->(*(char))
(	O
n	int
,	O
arg	*(char)
,	O
SIZE_MAX	O
,	O
&	O
o	*(struct)
)	O
;	O
}	O
char	O
*	O
quotearg_n_style_mem	(int,enum(int,int,int,int,int,int,int),*(char),long)->(*(char))
(	O
int	O
n	int
,	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int)
s	enum(int,int,int,int,int,int,int)
,	O
char	O
const	O
*	O
arg	*(char)
,	O
size_t	long
argsize	long
)	O
{	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
const	O
o	*(struct)
=	O
quoting_options_from_style	(enum(int,int,int,int,int,int,int))->(struct(enum(int,int,int,int,int,int,int),array(int)))
(	O
s	enum(int,int,int,int,int,int,int)
)	O
;	O
return	O
quotearg_n_options	(int,*(char),long,*(struct(enum(int,int,int,int,int,int,int),array(int))))->(*(char))
(	O
n	int
,	O
arg	*(char)
,	O
argsize	long
,	O
&	O
o	*(struct)
)	O
;	O
}	O
char	O
*	O
quotearg_style	(enum(int,int,int,int,int,int,int),*(char))->(*(char))
(	O
enum	O
quoting_style	enum(int,int,int,int,int,int,int)
s	enum(int,int,int,int,int,int,int)
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
return	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
s	enum(int,int,int,int,int,int,int)
,	O
arg	*(char)
)	O
;	O
}	O
char	O
*	O
quotearg_char	(*(char),char)->(*(char))
(	O
char	O
const	O
*	O
arg	*(char)
,	O
char	O
ch	char
)	O
{	O
struct	O
quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
options	*(struct(enum(int,int,int,int,int,int,int),array(int)))
;	O
options	*(struct(enum(int,int,int,int,int,int,int),array(int)))
=	O
default_quoting_options	struct(enum(int,int,int,int,int,int,int),array(int))
;	O
set_char_quoting	(*(struct),char,int)->(int)
(	O
&	O
options	*(struct(enum(int,int,int,int,int,int,int),array(int)))
,	O
ch	char
,	O
1	int
)	O
;	O
return	O
quotearg_n_options	(int,*(char),long,*(struct(enum(int,int,int,int,int,int,int),array(int))))->(*(char))
(	O
0	int
,	O
arg	*(char)
,	O
SIZE_MAX	O
,	O
&	O
options	*(struct(enum(int,int,int,int,int,int,int),array(int)))
)	O
;	O
}	O
char	O
*	O
quotearg_colon	(*(char))->(*(char))
(	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
return	O
quotearg_char	(*(char),char)->(*(char))
(	O
arg	*(char)
,	O
':'	O
)	O
;	O
}	O
