typedef	O
size_t	long
hash_value	long
;	O
verify	O
(	O
!	O
TYPE_SIGNED	O
(	O
hash_value	long
)	O
)	O
;	O
struct	O
equivclass	struct(long,long,*(char),long)
{	O
lin	long
next	long
;	O
hash_value	long
hash	long
;	O
char	O
const	O
*	O
line	*(char)
;	O
size_t	long
length	long
;	O
}	O
;	O
static	O
lin	long
*	O
buckets	*(long)
;	O
static	O
size_t	long
nbuckets	long
;	O
static	O
struct	O
equivclass	struct(long,long,*(char),long)
*	O
equivs	*(long)
;	O
static	O
lin	long
equivs_index	long
;	O
static	O
lin	long
equivs_alloc	long
;	O
void	O
file_block_read	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),long)->(void)
(	O
struct	O
file_data	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
*	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
size	long
&&	O
!	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
eof	bool
)	O
{	O
size_t	long
s	long
=	O
block_read	(int,*(char),long)->(long)
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
desc	int
,	O
FILE_BUFFER	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
)	O
+	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
,	O
size	long
)	O
;	O
if	O
(	O
s	long
==	O
SIZE_MAX	O
)	O
pfatal_with_name	(*(char))->(void)
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
name	*(char)
)	O
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
+=	O
s	long
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
eof	bool
=	O
s	long
<	O
size	long
;	O
}	O
}	O
static	O
bool	bool
sip	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),bool)->(bool)
(	O
struct	O
file_data	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
*	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
,	O
bool	bool
skip_test	bool
)	O
{	O
if	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
desc	int
<	O
0	int
)	O
{	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
=	O
sizeof	O
(	O
word	O
)	O
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffer	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
)	O
;	O
}	O
else	O
{	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
=	O
buffer_lcm	(long,long,long)->(long)
(	O
sizeof	O
(	O
word	O
)	O
,	O
STAT_BLOCKSIZE	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
,	O
PTRDIFF_MAX	O
-	O
2	int
*	O
sizeof	O
(	O
word	O
)	O
)	O
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffer	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
)	O
;	O
if	O
(	O
!	O
skip_test	bool
)	O
{	O
file_block_read	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),long)->(void)
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
,	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
)	O
;	O
return	O
binary_file_p	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffer	*(char)
,	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
)	O
;	O
}	O
}	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
=	O
0	int
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
eof	bool
=	O
false	int
;	O
return	O
false	int
;	O
}	O
static	O
void	O
slurp	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)))->(void)
(	O
struct	O
file_data	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
*	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
)	O
{	O
size_t	long
cc	long
;	O
if	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
desc	int
<	O
0	int
)	O
{	O
return	O
;	O
}	O
if	O
(	O
S_ISREG	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
size_t	long
file_size	long
=	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
;	O
cc	long
=	O
file_size	long
+	O
2	int
*	O
sizeof	O
(	O
word	O
)	O
-	O
file_size	long
%	O
sizeof	O
(	O
word	O
)	O
;	O
if	O
(	O
file_size	long
!=	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
||	O
cc	long
<	O
file_size	long
||	O
PTRDIFF_MAX	O
<=	O
cc	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
if	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
<	O
cc	long
)	O
{	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
=	O
cc	long
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffer	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffer	*(char)
,	O
cc	long
)	O
;	O
}	O
if	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
<=	O
file_size	long
)	O
{	O
file_block_read	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),long)->(void)
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
,	O
file_size	long
+	O
1	int
-	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
)	O
;	O
if	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
<=	O
file_size	long
)	O
return	O
;	O
}	O
}	O
file_block_read	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),long)->(void)
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
,	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
-	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
)	O
;	O
if	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
)	O
{	O
while	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
==	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
2	int
-	O
sizeof	O
(	O
word	O
)	O
<	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
*=	O
2	int
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffer	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffer	*(char)
,	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
)	O
;	O
file_block_read	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),long)->(void)
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
,	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
-	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
)	O
;	O
}	O
cc	long
=	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
+	O
2	int
*	O
sizeof	O
(	O
word	O
)	O
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
=	O
cc	long
-	O
cc	long
%	O
sizeof	O
(	O
word	O
)	O
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffer	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffer	*(char)
,	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
bufsize	long
)	O
;	O
}	O
}	O
static	O
void	O
find_and_hash_each_line	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)))->(void)
(	O
struct	O
file_data	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
*	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
)	O
{	O
char	O
const	O
*	O
p	*(void)
=	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
prefix_end	*(char)
;	O
lin	long
i	long
,	O
*	O
bucket	*(long)
;	O
size_t	long
length	long
;	O
char	O
const	O
*	O
*	O
linbuf	*(*(char))
=	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
linbuf	*(*(char))
;	O
lin	long
alloc_lines	long
=	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
alloc_lines	long
;	O
lin	long
line	*(char)
=	O
0	int
;	O
lin	long
linbuf_base	long
=	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
linbuf_base	long
;	O
lin	long
*	O
cureqs	*(long)
=	O
xmalloc	(long)->(*(void))
(	O
alloc_lines	long
*	O
sizeof	O
*	O
cureqs	*(long)
)	O
;	O
struct	O
equivclass	struct(long,long,*(char),long)
*	O
eqs	*(struct(long,long,*(char),long))
=	O
equivs	*(long)
;	O
lin	long
eqs_index	long
=	O
equivs_index	long
;	O
lin	long
eqs_alloc	long
=	O
equivs_alloc	long
;	O
char	O
const	O
*	O
suffix_begin	*(char)
=	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
suffix_begin	*(char)
;	O
char	O
const	O
*	O
bufend	*(char)
=	O
FILE_BUFFER	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
)	O
+	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
;	O
bool	bool
ig_case	bool
=	O
ignore_case	bool
;	O
enum	O
DIFF_white_space	enum(int,int,int,int,int,int)
ig_white_space	enum(int,int,int,int,int,int)
=	O
ignore_white_space	enum(int,int,int,int,int,int)
;	O
bool	bool
diff_length_compare_anyway	bool
=	O
ig_white_space	enum(int,int,int,int,int,int)
!=	O
IGNORE_NO_WHITE_SPACE	int
;	O
bool	bool
same_length_diff_contents_compare_anyway	bool
=	O
diff_length_compare_anyway	bool
|	O
ig_case	bool
;	O
while	O
(	O
p	*(void)
<	O
suffix_begin	*(char)
)	O
{	O
char	O
const	O
*	O
ip	*(char)
=	O
p	*(void)
;	O
hash_value	long
h	long
=	O
0	int
;	O
unsigned	O
char	O
c	char
;	O
switch	O
(	O
ig_white_space	enum(int,int,int,int,int,int)
)	O
{	O
case	O
IGNORE_ALL_SPACE	int
:	O
while	O
(	O
(	O
c	char
=	O
*	O
p	*(void)
++	O
)	O
!=	O
'\n'	O
)	O
if	O
(	O
!	O
isspace	(int)->(int)
(	O
c	char
)	O
)	O
h	long
=	O
HASH	O
(	O
h	long
,	O
ig_case	bool
?	O
tolower	(int)->(int)
(	O
c	char
)	O
:	O
c	char
)	O
;	O
break	O
;	O
case	O
IGNORE_SPACE_CHANGE	int
:	O
while	O
(	O
(	O
c	char
=	O
*	O
p	*(void)
++	O
)	O
!=	O
'\n'	O
)	O
{	O
if	O
(	O
isspace	(int)->(int)
(	O
c	char
)	O
)	O
{	O
do	O
if	O
(	O
(	O
c	char
=	O
*	O
p	*(void)
++	O
)	O
==	O
'\n'	O
)	O
goto	O
hashing_done	O
;	O
while	O
(	O
isspace	(int)->(int)
(	O
c	char
)	O
)	O
;	O
h	long
=	O
HASH	O
(	O
h	long
,	O
' '	O
)	O
;	O
}	O
h	long
=	O
HASH	O
(	O
h	long
,	O
ig_case	bool
?	O
tolower	(int)->(int)
(	O
c	char
)	O
:	O
c	char
)	O
;	O
}	O
break	O
;	O
case	O
IGNORE_TAB_EXPANSION	int
:	O
case	O
IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE	int
:	O
case	O
IGNORE_TRAILING_SPACE	int
:	O
{	O
size_t	long
column	long
=	O
0	int
;	O
while	O
(	O
(	O
c	char
=	O
*	O
p	*(void)
++	O
)	O
!=	O
'\n'	O
)	O
{	O
if	O
(	O
ig_white_space	enum(int,int,int,int,int,int)
&	O
IGNORE_TRAILING_SPACE	int
&&	O
isspace	(int)->(int)
(	O
c	char
)	O
)	O
{	O
char	O
const	O
*	O
p1	*(char)
=	O
p	*(void)
;	O
unsigned	O
char	O
c1	char
;	O
do	O
if	O
(	O
(	O
c1	char
=	O
*	O
p1	*(char)
++	O
)	O
==	O
'\n'	O
)	O
{	O
p	*(void)
=	O
p1	*(char)
;	O
goto	O
hashing_done	O
;	O
}	O
while	O
(	O
isspace	(int)->(int)
(	O
c1	char
)	O
)	O
;	O
}	O
size_t	long
repetitions	long
=	O
1	int
;	O
if	O
(	O
ig_white_space	enum(int,int,int,int,int,int)
&	O
IGNORE_TAB_EXPANSION	int
)	O
switch	O
(	O
c	char
)	O
{	O
case	O
'\b'	O
:	O
column	long
-=	O
0	int
<	O
column	long
;	O
break	O
;	O
case	O
'\t'	O
:	O
c	char
=	O
' '	O
;	O
repetitions	long
=	O
tabsize	long
-	O
column	long
%	O
tabsize	long
;	O
column	long
=	O
(	O
column	long
+	O
repetitions	long
<	O
column	long
?	O
0	int
:	O
column	long
+	O
repetitions	long
)	O
;	O
break	O
;	O
case	O
'\r'	O
:	O
column	long
=	O
0	int
;	O
break	O
;	O
default	O
:	O
column	long
++	O
;	O
break	O
;	O
}	O
if	O
(	O
ig_case	bool
)	O
c	char
=	O
tolower	(int)->(int)
(	O
c	char
)	O
;	O
do	O
h	long
=	O
HASH	O
(	O
h	long
,	O
c	char
)	O
;	O
while	O
(	O
--	O
repetitions	long
!=	O
0	int
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
ig_case	bool
)	O
while	O
(	O
(	O
c	char
=	O
*	O
p	*(void)
++	O
)	O
!=	O
'\n'	O
)	O
h	long
=	O
HASH	O
(	O
h	long
,	O
tolower	(int)->(int)
(	O
c	char
)	O
)	O
;	O
else	O
while	O
(	O
(	O
c	char
=	O
*	O
p	*(void)
++	O
)	O
!=	O
'\n'	O
)	O
h	long
=	O
HASH	O
(	O
h	long
,	O
c	char
)	O
;	O
break	O
;	O
}	O
hashing_done	O
:	O
;	O
bucket	*(long)
=	O
&	O
buckets	*(long)
[	O
h	long
%	O
nbuckets	long
]	O
;	O
length	long
=	O
p	*(void)
-	O
ip	*(char)
-	O
1	int
;	O
if	O
(	O
p	*(void)
==	O
bufend	*(char)
&&	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
missing_newline	bool
&&	O
ROBUST_OUTPUT_STYLE	O
(	O
output_style	enum(int,int,int,int,int,int,int,int,int)
)	O
)	O
{	O
if	O
(	O
ig_white_space	enum(int,int,int,int,int,int)
<	O
IGNORE_TRAILING_SPACE	int
)	O
bucket	*(long)
=	O
&	O
buckets	*(long)
[	O
-	O
1	int
]	O
;	O
}	O
for	O
(	O
i	long
=	O
*	O
bucket	*(long)
;	O
;	O
i	long
=	O
eqs	*(struct(long,long,*(char),long))
[	O
i	long
]	O
.	O
next	long
)	O
if	O
(	O
!	O
i	long
)	O
{	O
i	long
=	O
eqs_index	long
++	O
;	O
if	O
(	O
i	long
==	O
eqs_alloc	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
(	O
2	int
*	O
sizeof	O
*	O
eqs	*(struct(long,long,*(char),long))
)	O
<=	O
eqs_alloc	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
eqs_alloc	long
*=	O
2	int
;	O
eqs	*(struct(long,long,*(char),long))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
eqs	*(struct(long,long,*(char),long))
,	O
eqs_alloc	long
*	O
sizeof	O
*	O
eqs	*(struct(long,long,*(char),long))
)	O
;	O
}	O
eqs	*(struct(long,long,*(char),long))
[	O
i	long
]	O
.	O
next	long
=	O
*	O
bucket	*(long)
;	O
eqs	*(struct(long,long,*(char),long))
[	O
i	long
]	O
.	O
hash	long
=	O
h	long
;	O
eqs	*(struct(long,long,*(char),long))
[	O
i	long
]	O
.	O
line	*(char)
=	O
ip	*(char)
;	O
eqs	*(struct(long,long,*(char),long))
[	O
i	long
]	O
.	O
length	long
=	O
length	long
;	O
*	O
bucket	*(long)
=	O
i	long
;	O
break	O
;	O
}	O
else	O
if	O
(	O
eqs	*(struct(long,long,*(char),long))
[	O
i	long
]	O
.	O
hash	long
==	O
h	long
)	O
{	O
char	O
const	O
*	O
eqline	*(char)
=	O
eqs	*(struct(long,long,*(char),long))
[	O
i	long
]	O
.	O
line	*(char)
;	O
if	O
(	O
eqs	*(struct(long,long,*(char),long))
[	O
i	long
]	O
.	O
length	long
==	O
length	long
)	O
{	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
eqline	*(char)
,	O
ip	*(char)
,	O
length	long
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
same_length_diff_contents_compare_anyway	bool
)	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
diff_length_compare_anyway	bool
)	O
continue	O
;	O
if	O
(	O
!	O
lines_differ	(*(char),*(char))->(bool)
(	O
eqline	*(char)
,	O
ip	*(char)
)	O
)	O
break	O
;	O
}	O
if	O
(	O
line	*(char)
==	O
alloc_lines	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
3	int
<=	O
alloc_lines	long
||	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
cureqs	*(long)
<=	O
2	int
*	O
alloc_lines	long
-	O
linbuf_base	long
||	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
linbuf	*(*(char))
<=	O
alloc_lines	long
-	O
linbuf_base	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
alloc_lines	long
=	O
2	int
*	O
alloc_lines	long
-	O
linbuf_base	long
;	O
cureqs	*(long)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
cureqs	*(long)
,	O
alloc_lines	long
*	O
sizeof	O
*	O
cureqs	*(long)
)	O
;	O
linbuf	*(*(char))
+=	O
linbuf_base	long
;	O
linbuf	*(*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
linbuf	*(*(char))
,	O
(	O
alloc_lines	long
-	O
linbuf_base	long
)	O
*	O
sizeof	O
*	O
linbuf	*(*(char))
)	O
;	O
linbuf	*(*(char))
-=	O
linbuf_base	long
;	O
}	O
linbuf	*(*(char))
[	O
line	*(char)
]	O
=	O
ip	*(char)
;	O
cureqs	*(long)
[	O
line	*(char)
]	O
=	O
i	long
;	O
++	O
line	*(char)
;	O
}	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered_lines	long
=	O
line	*(char)
;	O
for	O
(	O
i	long
=	O
0	int
;	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
line	*(char)
==	O
alloc_lines	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
3	int
<=	O
alloc_lines	long
||	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
cureqs	*(long)
<=	O
2	int
*	O
alloc_lines	long
-	O
linbuf_base	long
||	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
linbuf	*(*(char))
<=	O
alloc_lines	long
-	O
linbuf_base	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
alloc_lines	long
=	O
2	int
*	O
alloc_lines	long
-	O
linbuf_base	long
;	O
linbuf	*(*(char))
+=	O
linbuf_base	long
;	O
linbuf	*(*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
linbuf	*(*(char))
,	O
(	O
alloc_lines	long
-	O
linbuf_base	long
)	O
*	O
sizeof	O
*	O
linbuf	*(*(char))
)	O
;	O
linbuf	*(*(char))
-=	O
linbuf_base	long
;	O
}	O
linbuf	*(*(char))
[	O
line	*(char)
]	O
=	O
p	*(void)
;	O
if	O
(	O
p	*(void)
==	O
bufend	*(char)
)	O
{	O
if	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
missing_newline	bool
&&	O
ROBUST_OUTPUT_STYLE	O
(	O
output_style	enum(int,int,int,int,int,int,int,int,int)
)	O
)	O
linbuf	*(*(char))
[	O
line	*(char)
]	O
--	O
;	O
break	O
;	O
}	O
if	O
(	O
context	long
<=	O
i	long
&&	O
no_diff_means_no_output	bool
)	O
break	O
;	O
line	*(char)
++	O
;	O
while	O
(	O
*	O
p	*(void)
++	O
!=	O
'\n'	O
)	O
continue	O
;	O
}	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
linbuf	*(*(char))
=	O
linbuf	*(*(char))
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
valid_lines	long
=	O
line	*(char)
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
alloc_lines	long
=	O
alloc_lines	long
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
equivs	*(long)
=	O
cureqs	*(long)
;	O
equivs	*(long)
=	O
eqs	*(struct(long,long,*(char),long))
;	O
equivs_alloc	long
=	O
eqs_alloc	long
;	O
equivs_index	long
=	O
eqs_index	long
;	O
}	O
static	O
void	O
prepare_text	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)))->(void)
(	O
struct	O
file_data	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
*	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
)	O
{	O
size_t	long
buffered	long
=	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
;	O
char	O
*	O
p	*(void)
=	O
FILE_BUFFER	O
(	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
)	O
;	O
char	O
*	O
dst	*(char)
;	O
if	O
(	O
buffered	long
==	O
0	int
||	O
p	*(void)
[	O
buffered	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
missing_newline	bool
=	O
false	int
;	O
else	O
{	O
p	*(void)
[	O
buffered	long
++	O
]	O
=	O
'\n'	O
;	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
missing_newline	bool
=	O
true	int
;	O
}	O
if	O
(	O
!	O
p	*(void)
)	O
return	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
p	*(void)
+	O
buffered	long
,	O
0	int
,	O
sizeof	O
(	O
word	O
)	O
)	O
;	O
if	O
(	O
strip_trailing_cr	bool
&&	O
(	O
dst	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
p	*(void)
,	O
'\r'	O
,	O
buffered	long
)	O
)	O
)	O
{	O
char	O
const	O
*	O
src	*(char)
=	O
dst	*(char)
;	O
char	O
const	O
*	O
srclim	*(char)
=	O
p	*(void)
+	O
buffered	long
;	O
do	O
dst	*(char)
+=	O
!	O
(	O
(	O
*	O
dst	*(char)
=	O
*	O
src	*(char)
++	O
)	O
==	O
'\r'	O
&&	O
*	O
src	*(char)
==	O
'\n'	O
)	O
;	O
while	O
(	O
src	*(char)
<	O
srclim	*(char)
)	O
;	O
buffered	long
-=	O
src	*(char)
-	O
dst	*(char)
;	O
}	O
current	*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
->	O
buffered	long
=	O
buffered	long
;	O
}	O
static	O
lin	long
guess_lines	(long,long,long)->(long)
(	O
lin	long
n	long
,	O
size_t	long
s	long
,	O
size_t	long
t	long
)	O
{	O
size_t	long
guessed_bytes_per_line	long
=	O
n	long
<	O
10	int
?	O
32	int
:	O
s	long
/	O
(	O
n	long
-	O
1	int
)	O
;	O
lin	long
guessed_lines	long
=	O
MAX	O
(	O
1	int
,	O
t	long
/	O
guessed_bytes_per_line	long
)	O
;	O
return	O
MIN	O
(	O
guessed_lines	long
,	O
PTRDIFF_MAX	O
/	O
(	O
2	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
+	O
1	int
)	O
-	O
5	int
)	O
+	O
5	int
;	O
}	O
static	O
void	O
find_identical_ends	(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)))->(void)
(	O
struct	O
file_data	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
]	O
)	O
{	O
word	O
*	O
w0	*(long)
,	O
*	O
w1	*(long)
;	O
char	O
*	O
p0	*(char)
,	O
*	O
p1	*(char)
,	O
*	O
buffer0	*(char)
,	O
*	O
buffer1	*(char)
;	O
char	O
const	O
*	O
end0	*(char)
,	O
*	O
beg0	*(char)
;	O
char	O
const	O
*	O
*	O
linbuf0	*(*(char))
,	O
*	O
*	O
linbuf1	*(*(char))
;	O
lin	long
i	long
,	O
lines	long
;	O
size_t	long
n0	long
,	O
n1	long
;	O
lin	long
alloc_lines0	long
,	O
alloc_lines1	long
;	O
lin	long
buffered_prefix	long
,	O
prefix_count	long
,	O
prefix_mask	long
;	O
lin	long
middle_guess	long
,	O
suffix_guess	long
;	O
slurp	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)))->(void)
(	O
&	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
)	O
;	O
prepare_text	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)))->(void)
(	O
&	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
desc	int
!=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
desc	int
)	O
{	O
slurp	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)))->(void)
(	O
&	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
)	O
;	O
prepare_text	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)))->(void)
(	O
&	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
buffer	*(char)
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
buffer	*(char)
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
bufsize	long
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
bufsize	long
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
buffered	long
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
buffered	long
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
missing_newline	bool
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
missing_newline	bool
;	O
}	O
w0	*(long)
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
buffer	*(char)
;	O
w1	*(long)
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
buffer	*(char)
;	O
p0	*(char)
=	O
buffer0	*(char)
=	O
(	O
char	O
*	O
)	O
w0	*(long)
;	O
p1	*(char)
=	O
buffer1	*(char)
=	O
(	O
char	O
*	O
)	O
w1	*(long)
;	O
n0	long
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
buffered	long
;	O
n1	long
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
buffered	long
;	O
if	O
(	O
p0	*(char)
==	O
p1	*(char)
)	O
p0	*(char)
=	O
p1	*(char)
+=	O
n1	long
;	O
else	O
{	O
if	O
(	O
n0	long
<	O
n1	long
)	O
p0	*(char)
[	O
n0	long
]	O
=	O
~	O
p1	*(char)
[	O
n0	long
]	O
;	O
else	O
p1	*(char)
[	O
n1	long
]	O
=	O
~	O
p0	*(char)
[	O
n1	long
]	O
;	O
while	O
(	O
*	O
w0	*(long)
==	O
*	O
w1	*(long)
)	O
w0	*(long)
++	O
,	O
w1	*(long)
++	O
;	O
p0	*(char)
=	O
(	O
char	O
*	O
)	O
w0	*(long)
;	O
p1	*(char)
=	O
(	O
char	O
*	O
)	O
w1	*(long)
;	O
while	O
(	O
*	O
p0	*(char)
==	O
*	O
p1	*(char)
)	O
p0	*(char)
++	O
,	O
p1	*(char)
++	O
;	O
if	O
(	O
ROBUST_OUTPUT_STYLE	O
(	O
output_style	enum(int,int,int,int,int,int,int,int,int)
)	O
&&	O
(	O
(	O
buffer0	*(char)
+	O
n0	long
-	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
missing_newline	bool
<	O
p0	*(char)
)	O
!=	O
(	O
buffer1	*(char)
+	O
n1	long
-	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
missing_newline	bool
<	O
p1	*(char)
)	O
)	O
)	O
p0	*(char)
--	O
,	O
p1	*(char)
--	O
;	O
}	O
i	long
=	O
horizon_lines	long
;	O
while	O
(	O
p0	*(char)
!=	O
buffer0	*(char)
&&	O
(	O
p0	*(char)
[	O
-	O
1	int
]	O
!=	O
'\n'	O
||	O
i	long
--	O
)	O
)	O
p0	*(char)
--	O
,	O
p1	*(char)
--	O
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
prefix_end	*(char)
=	O
p0	*(char)
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
prefix_end	*(char)
=	O
p1	*(char)
;	O
p0	*(char)
=	O
buffer0	*(char)
+	O
n0	long
;	O
p1	*(char)
=	O
buffer1	*(char)
+	O
n1	long
;	O
if	O
(	O
!	O
ROBUST_OUTPUT_STYLE	O
(	O
output_style	enum(int,int,int,int,int,int,int,int,int)
)	O
||	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
missing_newline	bool
==	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
missing_newline	bool
)	O
{	O
end0	*(char)
=	O
p0	*(char)
;	O
beg0	*(char)
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
prefix_end	*(char)
+	O
(	O
n0	long
<	O
n1	long
?	O
0	int
:	O
n0	long
-	O
n1	long
)	O
;	O
while	O
(	O
p0	*(char)
!=	O
beg0	*(char)
)	O
if	O
(	O
*	O
--	O
p0	*(char)
!=	O
*	O
--	O
p1	*(char)
)	O
{	O
++	O
p0	*(char)
,	O
++	O
p1	*(char)
;	O
beg0	*(char)
=	O
p0	*(char)
;	O
break	O
;	O
}	O
i	long
=	O
horizon_lines	long
+	O
!	O
(	O
(	O
buffer0	*(char)
==	O
p0	*(char)
||	O
p0	*(char)
[	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
&&	O
(	O
buffer1	*(char)
==	O
p1	*(char)
||	O
p1	*(char)
[	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
)	O
;	O
while	O
(	O
i	long
--	O
&&	O
p0	*(char)
!=	O
end0	*(char)
)	O
while	O
(	O
*	O
p0	*(char)
++	O
!=	O
'\n'	O
)	O
continue	O
;	O
p1	*(char)
+=	O
p0	*(char)
-	O
beg0	*(char)
;	O
}	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
suffix_begin	*(char)
=	O
p0	*(char)
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
suffix_begin	*(char)
=	O
p1	*(char)
;	O
if	O
(	O
no_diff_means_no_output	bool
&&	O
!	O
function_regexp	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
.	O
fastmap	*(char)
&&	O
context	long
<	O
LIN_MAX	O
/	O
4	int
&&	O
context	long
<	O
n0	long
)	O
{	O
middle_guess	long
=	O
guess_lines	(long,long,long)->(long)
(	O
0	int
,	O
0	int
,	O
p0	*(char)
-	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
prefix_end	*(char)
)	O
;	O
suffix_guess	long
=	O
guess_lines	(long,long,long)->(long)
(	O
0	int
,	O
0	int
,	O
buffer0	*(char)
+	O
n0	long
-	O
p0	*(char)
)	O
;	O
for	O
(	O
prefix_count	long
=	O
1	int
;	O
prefix_count	long
<=	O
context	long
;	O
prefix_count	long
*=	O
2	int
)	O
continue	O
;	O
alloc_lines0	long
=	O
(	O
prefix_count	long
+	O
middle_guess	long
+	O
MIN	O
(	O
context	long
,	O
suffix_guess	long
)	O
)	O
;	O
}	O
else	O
{	O
prefix_count	long
=	O
0	int
;	O
alloc_lines0	long
=	O
guess_lines	(long,long,long)->(long)
(	O
0	int
,	O
0	int
,	O
n0	long
)	O
;	O
}	O
prefix_mask	long
=	O
prefix_count	long
-	O
1	int
;	O
lines	long
=	O
0	int
;	O
linbuf0	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
alloc_lines0	long
*	O
sizeof	O
*	O
linbuf0	*(*(char))
)	O
;	O
p0	*(char)
=	O
buffer0	*(char)
;	O
if	O
(	O
!	O
(	O
no_diff_means_no_output	bool
&&	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
prefix_end	*(char)
==	O
p0	*(char)
&&	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
prefix_end	*(char)
==	O
p1	*(char)
)	O
)	O
{	O
end0	*(char)
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
prefix_end	*(char)
;	O
while	O
(	O
p0	*(char)
!=	O
end0	*(char)
)	O
{	O
lin	long
l	long
=	O
lines	long
++	O
&	O
prefix_mask	long
;	O
if	O
(	O
l	long
==	O
alloc_lines0	long
)	O
{	O
if	O
(	O
PTRDIFF_MAX	O
/	O
(	O
2	int
*	O
sizeof	O
*	O
linbuf0	*(*(char))
)	O
<=	O
alloc_lines0	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
alloc_lines0	long
*=	O
2	int
;	O
linbuf0	*(*(char))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
linbuf0	*(*(char))
,	O
alloc_lines0	long
*	O
sizeof	O
*	O
linbuf0	*(*(char))
)	O
;	O
}	O
linbuf0	*(*(char))
[	O
l	long
]	O
=	O
p0	*(char)
;	O
while	O
(	O
*	O
p0	*(char)
++	O
!=	O
'\n'	O
)	O
continue	O
;	O
}	O
}	O
buffered_prefix	long
=	O
prefix_count	long
&&	O
context	long
<	O
lines	long
?	O
context	long
:	O
lines	long
;	O
middle_guess	long
=	O
guess_lines	(long,long,long)->(long)
(	O
lines	long
,	O
p0	*(char)
-	O
buffer0	*(char)
,	O
p1	*(char)
-	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
prefix_end	*(char)
)	O
;	O
suffix_guess	long
=	O
guess_lines	(long,long,long)->(long)
(	O
lines	long
,	O
p0	*(char)
-	O
buffer0	*(char)
,	O
buffer1	*(char)
+	O
n1	long
-	O
p1	*(char)
)	O
;	O
alloc_lines1	long
=	O
buffered_prefix	long
+	O
middle_guess	long
+	O
MIN	O
(	O
context	long
,	O
suffix_guess	long
)	O
;	O
if	O
(	O
alloc_lines1	long
<	O
buffered_prefix	long
||	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
linbuf1	*(*(char))
<=	O
alloc_lines1	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
linbuf1	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
alloc_lines1	long
*	O
sizeof	O
*	O
linbuf1	*(*(char))
)	O
;	O
if	O
(	O
buffered_prefix	long
!=	O
lines	long
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
buffered_prefix	long
;	O
i	long
++	O
)	O
linbuf1	*(*(char))
[	O
i	long
]	O
=	O
linbuf0	*(*(char))
[	O
(	O
lines	long
-	O
context	long
+	O
i	long
)	O
&	O
prefix_mask	long
]	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
buffered_prefix	long
;	O
i	long
++	O
)	O
linbuf0	*(*(char))
[	O
i	long
]	O
=	O
linbuf1	*(*(char))
[	O
i	long
]	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
buffered_prefix	long
;	O
i	long
++	O
)	O
linbuf1	*(*(char))
[	O
i	long
]	O
=	O
linbuf0	*(*(char))
[	O
i	long
]	O
-	O
buffer0	*(char)
+	O
buffer1	*(char)
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
linbuf	*(*(char))
=	O
linbuf0	*(*(char))
+	O
buffered_prefix	long
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
linbuf	*(*(char))
=	O
linbuf1	*(*(char))
+	O
buffered_prefix	long
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
linbuf_base	long
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
linbuf_base	long
=	O
-	O
buffered_prefix	long
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
alloc_lines	long
=	O
alloc_lines0	long
-	O
buffered_prefix	long
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
alloc_lines	long
=	O
alloc_lines1	long
-	O
buffered_prefix	long
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
prefix_lines	long
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
prefix_lines	long
=	O
lines	long
;	O
}	O
static	O
unsigned	O
char	O
const	O
prime_offset	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
5	int
,	O
3	int
,	O
3	int
,	O
9	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
19	int
,	O
15	int
,	O
1	int
,	O
5	int
,	O
1	int
,	O
3	int
,	O
9	int
,	O
3	int
,	O
15	int
,	O
3	int
,	O
39	int
,	O
5	int
,	O
39	int
,	O
57	int
,	O
3	int
,	O
35	int
,	O
1	int
,	O
5	int
,	O
9	int
,	O
41	int
,	O
31	int
,	O
5	int
,	O
25	int
,	O
45	int
,	O
7	int
,	O
87	int
,	O
21	int
,	O
11	int
,	O
57	int
,	O
17	int
,	O
55	int
,	O
21	int
,	O
115	int
,	O
59	int
,	O
81	int
,	O
27	int
,	O
129	int
,	O
47	int
,	O
111	int
,	O
33	int
,	O
55	int
,	O
5	int
,	O
13	int
,	O
27	int
,	O
55	int
,	O
93	int
,	O
1	int
,	O
57	int
,	O
25	int
}	O
;	O
verify	O
(	O
sizeof	O
(	O
size_t	long
)	O
*	O
CHAR_BIT	O
<=	O
sizeof	O
prime_offset	array(char)
)	O
;	O
bool	bool
read_files	(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),bool)->(bool)
(	O
struct	O
file_data	struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
]	O
,	O
bool	bool
pretend_binary	bool
)	O
{	O
int	O
i	long
;	O
bool	bool
skip_test	bool
=	O
text	bool
|	O
pretend_binary	bool
;	O
bool	bool
appears_binary	bool
=	O
pretend_binary	bool
|	O
sip	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),bool)->(bool)
(	O
&	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
,	O
skip_test	bool
)	O
;	O
if	O
(	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
desc	int
!=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
desc	int
)	O
appears_binary	bool
|=	O
sip	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)),bool)->(bool)
(	O
&	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
,	O
skip_test	bool
|	O
appears_binary	bool
)	O
;	O
else	O
{	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
buffer	*(char)
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
buffer	*(char)
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
bufsize	long
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
bufsize	long
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
buffered	long
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
buffered	long
;	O
}	O
if	O
(	O
appears_binary	bool
)	O
{	O
return	O
true	int
;	O
}	O
find_identical_ends	(array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)))->(void)
(	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
)	O
;	O
equivs_alloc	long
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
alloc_lines	long
+	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
alloc_lines	long
+	O
1	int
;	O
if	O
(	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
equivs	*(long)
<=	O
equivs_alloc	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
equivs	*(long)
=	O
xmalloc	(long)->(*(void))
(	O
equivs_alloc	long
*	O
sizeof	O
*	O
equivs	*(long)
)	O
;	O
equivs_index	long
=	O
1	int
;	O
for	O
(	O
i	long
=	O
9	int
;	O
(	O
size_t	long
)	O
1	int
<<	O
i	long
<	O
equivs_alloc	long
/	O
3	int
;	O
i	long
++	O
)	O
continue	O
;	O
nbuckets	long
=	O
(	O
(	O
size_t	long
)	O
1	int
<<	O
i	long
)	O
-	O
prime_offset	array(char)
[	O
i	long
]	O
;	O
if	O
(	O
PTRDIFF_MAX	O
/	O
sizeof	O
*	O
buckets	*(long)
<=	O
nbuckets	long
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
buckets	*(long)
=	O
zalloc	(long)->(*(void))
(	O
(	O
nbuckets	long
+	O
1	int
)	O
*	O
sizeof	O
*	O
buckets	*(long)
)	O
;	O
buckets	*(long)
++	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
2	int
;	O
i	long
++	O
)	O
find_and_hash_each_line	(*(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long)))->(void)
(	O
&	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
i	long
]	O
)	O
;	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
0	int
]	O
.	O
equiv_max	long
=	O
filevec	array(struct(int,*(char),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)),*(long),long,long,*(*(char)),long,long,long,long,*(char),long,*(char),*(long),*(long),*(long),long,*(char),bool,bool,long))
[	O
1	int
]	O
.	O
equiv_max	long
=	O
equivs_index	long
;	O
free	(*(void))->(void)
(	O
equivs	*(long)
)	O
;	O
free	(*(void))->(void)
(	O
buckets	*(long)
-	O
1	int
)	O
;	O
return	O
false	int
;	O
}	O
