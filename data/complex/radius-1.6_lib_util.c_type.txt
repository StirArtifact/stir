grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
grad_request_alloc	()->(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))
(	O
)	O
{	O
return	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
)	O
)	O
;	O
}	O
void	O
grad_request_free	(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))->(void)
(	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
radreq	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
{	O
grad_avl_free	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(void)
(	O
radreq	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
avlist	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
grad_free	(*(void))->(void)
(	O
radreq	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
;	O
}	O
static	O
char	O
*	O
months	array(*(char))
[	O
]	O
=	O
{	O
"Jan"	*(char)
,	O
"Feb"	*(char)
,	O
"Mar"	*(char)
,	O
"Apr"	*(char)
,	O
"May"	*(char)
,	O
"Jun"	*(char)
,	O
"Jul"	*(char)
,	O
"Aug"	*(char)
,	O
"Sep"	*(char)
,	O
"Oct"	*(char)
,	O
"Nov"	*(char)
,	O
"Dec"	*(char)
}	O
;	O
int	O
grad_parse_time_string	(*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(int)
(	O
char	O
*	O
valstr	*(char)
,	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
12	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
grad_c_strncasecmp	(*(char),*(char),long)->(int)
(	O
months	array(*(char))
[	O
i	int
]	O
,	O
valstr	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
{	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_mon	int
=	O
i	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
i	int
==	O
12	int
)	O
return	O
-	O
1	int
;	O
valstr	*(char)
+=	O
3	int
;	O
while	O
(	O
*	O
valstr	*(char)
&&	O
isspace	(int)->(int)
(	O
*	O
valstr	*(char)
)	O
)	O
valstr	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
valstr	*(char)
)	O
return	O
-	O
1	int
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_mday	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
valstr	*(char)
,	O
&	O
valstr	*(char)
,	O
10	int
)	O
;	O
while	O
(	O
*	O
valstr	*(char)
&&	O
isspace	(int)->(int)
(	O
*	O
valstr	*(char)
)	O
)	O
valstr	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
valstr	*(char)
)	O
return	O
-	O
1	int
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_year	int
=	O
strtol	(*(char),*(*(char)),int)->(long)
(	O
valstr	*(char)
,	O
&	O
valstr	*(char)
,	O
10	int
)	O
-	O
1900	int
;	O
return	O
0	int
;	O
}	O
void	O
grad_lock_file	(int,long,long,int)->(void)
(	O
int	O
fd	int
,	O
size_t	long
size	int
,	O
off_t	long
offset	long
,	O
int	O
whence	int
)	O
{	O
struct	O
flock	struct(short,short,long,long,int)
fl	struct(short,short,long,long,int)
;	O
fl	struct(short,short,long,long,int)
.	O
l_type	short
=	O
F_WRLCK	int
;	O
fl	struct(short,short,long,long,int)
.	O
l_whence	short
=	O
whence	int
;	O
fl	struct(short,short,long,long,int)
.	O
l_start	long
=	O
offset	long
;	O
fl	struct(short,short,long,long,int)
.	O
l_len	long
=	O
size	int
;	O
fcntl	(int,int)->(int)
(	O
fd	int
,	O
F_SETLKW	int
,	O
&	O
fl	struct(short,short,long,long,int)
)	O
;	O
}	O
void	O
grad_unlock_file	(int,long,long,int)->(void)
(	O
int	O
fd	int
,	O
size_t	long
size	int
,	O
off_t	long
offset	long
,	O
int	O
whence	int
)	O
{	O
struct	O
flock	struct(short,short,long,long,int)
fl	struct(short,short,long,long,int)
;	O
fl	struct(short,short,long,long,int)
.	O
l_type	short
=	O
F_UNLCK	int
;	O
fl	struct(short,short,long,long,int)
.	O
l_whence	short
=	O
whence	int
;	O
fl	struct(short,short,long,long,int)
.	O
l_start	long
=	O
offset	long
;	O
fl	struct(short,short,long,long,int)
.	O
l_len	long
=	O
size	int
;	O
fcntl	(int,int)->(int)
(	O
fd	int
,	O
F_SETLKW	int
,	O
&	O
fl	struct(short,short,long,long,int)
)	O
;	O
}	O
int	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
grad_keyword_t	struct
*	O
kw	*(struct(*(char),int))
,	O
const	O
char	O
*	O
str	*(char)
,	O
int	O
def	int
)	O
{	O
for	O
(	O
;	O
kw	*(struct(*(char),int))
->	O
name	*(char)
;	O
kw	*(struct(*(char),int))
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
kw	*(struct(*(char),int))
->	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
kw	*(struct(*(char),int))
->	O
tok	int
;	O
return	O
def	int
;	O
}	O
char	O
*	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
char	O
*	O
dir	*(char)
,	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
dir	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
char	O
*	O
p	*(struct)
=	O
grad_emalloc	(long)->(*(void))
(	O
len	int
+	O
2	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(struct)
,	O
"%s/%s"	*(char)
,	O
dir	*(char)
,	O
name	*(char)
)	O
;	O
return	O
p	*(struct)
;	O
}	O
char	O
*	O
grad_mkfilename3	(*(char),*(char),*(char))->(*(char))
(	O
char	O
*	O
dir	*(char)
,	O
char	O
*	O
subdir	*(char)
,	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
dir	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
subdir	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
char	O
*	O
p	*(struct)
=	O
grad_emalloc	(long)->(*(void))
(	O
len	int
+	O
3	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(struct)
,	O
"%s/%s/%s"	*(char)
,	O
dir	*(char)
,	O
subdir	*(char)
,	O
name	*(char)
)	O
;	O
return	O
p	*(struct)
;	O
}	O
int	O
grad_astrcat	(*(*(char)))->(int)
(	O
char	O
*	O
*	O
pptr	*(*(char))
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
size_t	long
size	int
=	O
0	int
;	O
char	O
*	O
s	*(*(char))
,	O
*	O
p	*(struct)
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
pptr	*(*(char))
)	O
;	O
while	O
(	O
(	O
s	*(*(char))
=	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
char	O
*	O
)	O
)	O
)	O
size	int
+=	O
strlen	(*(char))->(long)
(	O
s	*(*(char))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
size	int
++	O
;	O
p	*(struct)
=	O
malloc	(long)->(*(void))
(	O
size	int
)	O
;	O
if	O
(	O
!	O
p	*(struct)
)	O
return	O
1	int
;	O
*	O
p	*(struct)
=	O
0	int
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
pptr	*(*(char))
)	O
;	O
while	O
(	O
(	O
s	*(*(char))
=	O
va_arg	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
char	O
*	O
)	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
p	*(struct)
,	O
s	*(*(char))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
*	O
pptr	*(*(char))
=	O
p	*(struct)
;	O
return	O
0	int
;	O
}	O
int	O
grad_decode_backslash	(int)->(int)
(	O
int	O
c	*(void)
)	O
{	O
static	O
char	O
transtab	array(char)
[	O
]	O
=	O
"a\ab\bf\fn\nr\rt\t"	*(char)
;	O
char	O
*	O
p	*(struct)
;	O
for	O
(	O
p	*(struct)
=	O
transtab	array(char)
;	O
*	O
p	*(struct)
;	O
p	*(struct)
+=	O
2	int
)	O
{	O
if	O
(	O
*	O
p	*(struct)
==	O
c	*(void)
)	O
return	O
p	*(struct)
[	O
1	int
]	O
;	O
}	O
return	O
c	*(void)
;	O
}	O
void	O
grad_string_copy	(*(char),*(char),int)->(void)
(	O
char	O
*	O
d	*(char)
,	O
char	O
*	O
s	*(*(char))
,	O
int	O
len	int
)	O
{	O
int	O
slen	int
=	O
strlen	(*(char))->(long)
(	O
s	*(*(char))
)	O
;	O
if	O
(	O
slen	int
>	O
len	int
)	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"string too long: %s"	*(char)
)	O
,	O
s	*(*(char))
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
d	*(char)
,	O
s	*(*(char))
,	O
len	int
)	O
;	O
d	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
}	O
char	O
*	O
grad_op_to_str	(enum(int,int,int,int,int,int,int))->(*(char))
(	O
enum	O
grad_operator	enum(int,int,int,int,int,int,int)
op	enum(int,int,int,int,int,int,int)
)	O
{	O
switch	O
(	O
op	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
grad_operator_equal	int
:	O
return	O
"="	*(char)
;	O
case	O
grad_operator_not_equal	int
:	O
return	O
"!="	*(char)
;	O
case	O
grad_operator_less_than	int
:	O
return	O
"<"	*(char)
;	O
case	O
grad_operator_greater_than	int
:	O
return	O
">"	*(char)
;	O
case	O
grad_operator_less_equal	int
:	O
return	O
"<="	*(char)
;	O
case	O
grad_operator_greater_equal	int
:	O
return	O
">="	*(char)
;	O
default	O
:	O
break	O
;	O
}	O
return	O
"?"	*(char)
;	O
}	O
enum	O
grad_operator	enum(int,int,int,int,int,int,int)
grad_str_to_op	(*(char))->(enum(int,int,int,int,int,int,int))
(	O
char	O
*	O
str	*(char)
)	O
{	O
int	O
op	enum(int,int,int,int,int,int,int)
=	O
grad_operator_invalid	int
;	O
switch	O
(	O
*	O
str	*(char)
++	O
)	O
{	O
case	O
'='	O
:	O
op	enum(int,int,int,int,int,int,int)
=	O
grad_operator_equal	int
;	O
break	O
;	O
case	O
'!'	O
:	O
if	O
(	O
*	O
str	*(char)
++	O
==	O
'='	O
)	O
op	enum(int,int,int,int,int,int,int)
=	O
grad_operator_not_equal	int
;	O
break	O
;	O
case	O
'<'	O
:	O
if	O
(	O
*	O
str	*(char)
==	O
0	int
)	O
op	enum(int,int,int,int,int,int,int)
=	O
grad_operator_less_than	int
;	O
else	O
if	O
(	O
*	O
str	*(char)
++	O
==	O
'='	O
)	O
op	enum(int,int,int,int,int,int,int)
=	O
grad_operator_less_equal	int
;	O
break	O
;	O
case	O
'>'	O
:	O
if	O
(	O
*	O
str	*(char)
==	O
0	int
)	O
op	enum(int,int,int,int,int,int,int)
=	O
grad_operator_greater_than	int
;	O
else	O
if	O
(	O
*	O
str	*(char)
++	O
==	O
'='	O
)	O
op	enum(int,int,int,int,int,int,int)
=	O
grad_operator_greater_equal	int
;	O
break	O
;	O
}	O
if	O
(	O
*	O
str	*(char)
)	O
op	enum(int,int,int,int,int,int,int)
=	O
grad_operator_invalid	int
;	O
return	O
op	enum(int,int,int,int,int,int,int)
;	O
}	O
static	O
int	O
flush_seg	(*(*(char)),*(char),*(char),int)->(int)
(	O
char	O
*	O
*	O
bufp	*(*(char))
,	O
char	O
*	O
seg	*(char)
,	O
char	O
*	O
ptr	*(*(void))
,	O
int	O
runlen	int
)	O
{	O
int	O
outbytes	int
=	O
0	int
;	O
char	O
*	O
buf	*(char)
=	O
*	O
bufp	*(*(char))
;	O
if	O
(	O
ptr	*(*(void))
-	O
seg	*(char)
>=	O
runlen	int
)	O
{	O
outbytes	int
+=	O
ptr	*(*(void))
-	O
seg	*(char)
;	O
if	O
(	O
buf	*(char)
)	O
while	O
(	O
seg	*(char)
<	O
ptr	*(*(void))
)	O
*	O
buf	*(char)
++	O
=	O
*	O
seg	*(char)
++	O
;	O
}	O
else	O
{	O
outbytes	int
+=	O
4	int
*	O
(	O
ptr	*(*(void))
-	O
seg	*(char)
)	O
;	O
if	O
(	O
buf	*(char)
)	O
while	O
(	O
seg	*(char)
<	O
ptr	*(*(void))
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"\\%03o"	*(char)
,	O
*	O
(	O
u_char	char
*	O
)	O
seg	*(char)
)	O
;	O
seg	*(char)
++	O
;	O
buf	*(char)
+=	O
4	int
;	O
}	O
}	O
*	O
bufp	*(*(char))
=	O
buf	*(char)
;	O
return	O
outbytes	int
;	O
}	O
int	O
grad_format_string_visual	(*(char),int,*(char),int)->(int)
(	O
char	O
*	O
buf	*(char)
,	O
int	O
runlen	int
,	O
char	O
*	O
str	*(char)
,	O
int	O
len	int
)	O
{	O
char	O
*	O
seg	*(char)
,	O
*	O
ptr	*(*(void))
;	O
int	O
outbytes	int
=	O
0	int
;	O
seg	*(char)
=	O
NULL	O
;	O
ptr	*(*(void))
=	O
str	*(char)
;	O
while	O
(	O
len	int
)	O
{	O
if	O
(	O
isprint	(int)->(int)
(	O
*	O
ptr	*(*(void))
)	O
)	O
{	O
if	O
(	O
!	O
seg	*(char)
)	O
seg	*(char)
=	O
ptr	*(*(void))
;	O
}	O
else	O
{	O
if	O
(	O
seg	*(char)
)	O
{	O
outbytes	int
+=	O
flush_seg	(*(*(char)),*(char),*(char),int)->(int)
(	O
&	O
buf	*(char)
,	O
seg	*(char)
,	O
ptr	*(*(void))
,	O
runlen	int
)	O
;	O
seg	*(char)
=	O
NULL	O
;	O
}	O
if	O
(	O
buf	*(char)
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"\\%03o"	*(char)
,	O
*	O
(	O
u_char	char
*	O
)	O
ptr	*(*(void))
)	O
;	O
buf	*(char)
+=	O
4	int
;	O
}	O
outbytes	int
+=	O
4	int
;	O
}	O
len	int
--	O
;	O
ptr	*(*(void))
++	O
;	O
}	O
if	O
(	O
seg	*(char)
)	O
{	O
outbytes	int
+=	O
ptr	*(*(void))
-	O
seg	*(char)
;	O
if	O
(	O
buf	*(char)
)	O
while	O
(	O
seg	*(char)
<	O
ptr	*(*(void))
)	O
*	O
buf	*(char)
++	O
=	O
*	O
seg	*(char)
++	O
;	O
}	O
if	O
(	O
buf	*(char)
)	O
*	O
buf	*(char)
++	O
=	O
0	int
;	O
return	O
outbytes	int
;	O
}	O
int	O
grad_format_vendor_pair	(*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(int)
(	O
char	O
*	O
buf	*(char)
,	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
{	O
int	O
n	long
;	O
grad_uint32_t	int
vendor	int
;	O
u_char	char
*	O
ptr	*(*(void))
=	O
(	O
u_char	char
*	O
)	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
;	O
char	O
buf1	array(char)
[	O
64	int
]	O
;	O
char	O
*	O
bufp	*(*(char))
=	O
buf	*(char)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
vendor	int
,	O
ptr	*(*(void))
,	O
4	int
)	O
;	O
ptr	*(*(void))
+=	O
4	int
;	O
n	long
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf1	array(char)
,	O
sizeof	O
(	O
buf1	array(char)
)	O
,	O
"V%d"	*(char)
,	O
(	O
int	O
)	O
ntohl	(int)->(int)
(	O
vendor	int
)	O
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
bufp	*(*(char))
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
bufp	*(*(char))
,	O
buf1	array(char)
,	O
n	long
)	O
;	O
bufp	*(*(char))
+=	O
n	long
;	O
}	O
return	O
n	long
+	O
grad_format_string_visual	(*(char),int,*(char),int)->(int)
(	O
bufp	*(*(char))
,	O
4	int
,	O
ptr	*(*(void))
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strlength	O
-	O
4	int
)	O
;	O
}	O
char	O
*	O
grad_format_pair	(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),int,*(*(char)))->(*(char))
(	O
grad_avp_t	struct(*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char))))
*	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
,	O
int	O
typeflag	int
,	O
char	O
*	O
*	O
savep	*(*(char))
)	O
{	O
char	O
*	O
buf1	array(char)
=	O
NULL	O
;	O
char	O
*	O
buf2ptr	*(char)
=	O
NULL	O
;	O
char	O
buf2	array(char)
[	O
4	int
*	O
GRAD_STRING_LENGTH	int
+	O
1	int
]	O
;	O
grad_dict_value_t	struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int)
*	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
char	O
*	O
type	enum(int,int,int,int)
=	O
""	*(char)
;	O
*	O
savep	*(*(char))
=	O
NULL	O
;	O
switch	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
eval_type	enum(int,int,int)
==	O
grad_eval_const	int
?	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
type	enum(int,int,int,int)
:	O
GRAD_TYPE_STRING	int
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
if	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
attribute	int
!=	O
DA_VENDOR_SPECIFIC	int
)	O
{	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
)	O
;	O
if	O
(	O
len	int
!=	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strlength	O
-	O
1	int
)	O
len	int
=	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strlength	O
;	O
grad_format_string_visual	(*(char),int,*(char),int)->(int)
(	O
buf2	array(char)
,	O
4	int
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strvalue	O
,	O
len	int
)	O
;	O
}	O
else	O
if	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strlength	O
<	O
6	int
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf2	array(char)
,	O
sizeof	O
(	O
buf2	array(char)
)	O
,	O
"[invalid length: %d]"	*(char)
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_strlength	O
)	O
;	O
else	O
{	O
int	O
len	int
=	O
grad_format_vendor_pair	(*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(int)
(	O
NULL	O
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
buf2ptr	*(char)
=	O
malloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
buf2ptr	*(char)
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
"%s:%d: can't alloc %d bytes"	*(char)
,	O
__FILE__	O
,	O
__LINE__	O
,	O
len	int
+	O
1	int
)	O
;	O
buf2	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
}	O
else	O
grad_format_vendor_pair	(*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))->(int)
(	O
buf2ptr	*(char)
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
)	O
;	O
}	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
if	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
name	*(char)
&&	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
prop	int
&	O
GRAD_AP_TRANSLATE	int
)	O
)	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
=	O
grad_value_lookup	(int,*(char))->(*(struct(*(char),*(struct(*`,int,int,int,int,*`)),int)))
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_lvalue	O
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
name	*(char)
)	O
;	O
else	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
=	O
NULL	O
;	O
if	O
(	O
!	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf2	array(char)
,	O
sizeof	O
(	O
buf2	array(char)
)	O
,	O
"%lu"	*(char)
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_lvalue	O
)	O
;	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf2	array(char)
,	O
sizeof	O
(	O
buf2	array(char)
)	O
,	O
"%s"	*(char)
,	O
dval	*(struct(*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))),int))
->	O
name	*(char)
)	O
;	O
break	O
;	O
case	O
GRAD_TYPE_IPADDR	int
:	O
grad_ip_iptostr	(int,*(char))->(*(char))
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_lvalue	O
,	O
buf2	array(char)
)	O
;	O
break	O
;	O
case	O
GRAD_TYPE_DATE	int
:	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
buf2	array(char)
,	O
sizeof	O
(	O
buf2	array(char)
)	O
,	O
"\"%b %e %Y\""	*(char)
,	O
localtime_r	(*(long),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
(	O
time_t	long
*	O
)	O
&	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
avp_lvalue	O
,	O
&	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
)	O
;	O
break	O
;	O
default	O
:	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
buf2	array(char)
,	O
"[UNKNOWN DATATYPE]"	*(char)
,	O
sizeof	O
(	O
buf2	array(char)
)	O
)	O
;	O
}	O
if	O
(	O
typeflag	int
)	O
{	O
switch	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
GRAD_TYPE_STRING	int
:	O
type	enum(int,int,int,int)
=	O
"(STRING) "	*(char)
;	O
break	O
;	O
case	O
GRAD_TYPE_INTEGER	int
:	O
type	enum(int,int,int,int)
=	O
"(INTEGER) "	*(char)
;	O
break	O
;	O
case	O
GRAD_TYPE_IPADDR	int
:	O
type	enum(int,int,int,int)
=	O
"(IPADDR) "	*(char)
;	O
break	O
;	O
case	O
GRAD_TYPE_DATE	int
:	O
type	enum(int,int,int,int)
=	O
"(DATE) "	*(char)
;	O
break	O
;	O
}	O
}	O
if	O
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
name	*(char)
)	O
grad_astrcat	(*(*(char)))->(int)
(	O
&	O
buf1	array(char)
,	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
name	*(char)
,	O
" "	*(char)
,	O
grad_op_to_str	(enum(int,int,int,int,int,int,int))->(*(char))
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
operator	enum(int,int,int,int,int,int,int)
)	O
,	O
" "	*(char)
,	O
type	enum(int,int,int,int)
,	O
buf2ptr	*(char)
?	O
buf2ptr	*(char)
:	O
buf2	array(char)
,	O
NULL	O
)	O
;	O
else	O
{	O
char	O
buf	*(char)
[	O
INT_BUFSIZE_BOUND	O
(	O
int	O
)	O
]	O
;	O
grad_inttostr	(int,*(char),long)->(long)
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
attribute	int
,	O
buf	*(char)
,	O
sizeof	O
buf	*(char)
)	O
;	O
grad_astrcat	(*(*(char)))->(int)
(	O
&	O
buf1	array(char)
,	O
buf	*(char)
,	O
" "	*(char)
,	O
grad_op_to_str	(enum(int,int,int,int,int,int,int))->(*(char))
(	O
pair	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
->	O
operator	enum(int,int,int,int,int,int,int)
)	O
,	O
" "	*(char)
,	O
buf2ptr	*(char)
?	O
buf2ptr	*(char)
:	O
buf2	array(char)
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
buf2ptr	*(char)
)	O
free	(*(void))->(void)
(	O
buf2ptr	*(char)
)	O
;	O
*	O
savep	*(*(char))
=	O
buf1	array(char)
;	O
return	O
buf1	array(char)
;	O
}	O
int	O
grad_recompute_timeout	(*(struct(long,long)),*(struct(long,long)))->(int)
(	O
struct	O
timeval	struct(long,long)
*	O
start	*(struct(long,long))
,	O
struct	O
timeval	struct(long,long)
*	O
tval	*(struct(long,long))
)	O
{	O
struct	O
timeval	struct(long,long)
now	struct(long,long)
,	O
diff	struct(long,long)
;	O
gettimeofday	(*(struct(long,long)),*(void))->(int)
(	O
&	O
now	struct(long,long)
,	O
NULL	O
)	O
;	O
timersub	O
(	O
&	O
now	struct(long,long)
,	O
start	*(struct(long,long))
,	O
&	O
diff	struct(long,long)
)	O
;	O
if	O
(	O
timercmp	O
(	O
&	O
diff	struct(long,long)
,	O
tval	*(struct(long,long))
,	O
<	O
)	O
)	O
{	O
struct	O
timeval	struct(long,long)
tmp	struct(long,long)
;	O
timersub	O
(	O
tval	*(struct(long,long))
,	O
&	O
diff	struct(long,long)
,	O
&	O
tmp	struct(long,long)
)	O
;	O
*	O
tval	*(struct(long,long))
=	O
tmp	struct(long,long)
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
