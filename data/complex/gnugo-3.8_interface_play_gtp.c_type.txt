static	O
int	O
report_uncertainty	int
=	O
0	int
;	O
static	O
int	O
gtp_orientation	int
=	O
0	int
;	O
static	O
void	O
gtp_print_code	(int)->(void)
(	O
int	O
c	char
)	O
;	O
static	O
void	O
gtp_print_vertices2	(int,*(int))->(void)
(	O
int	O
n	int
,	O
int	O
*	O
moves	array(int)
)	O
;	O
static	O
void	O
rotate_on_input	(int,int,*(int),*(int))->(void)
(	O
int	O
ai	int
,	O
int	O
aj	int
,	O
int	O
*	O
bi	*(int)
,	O
int	O
*	O
bj	*(int)
)	O
;	O
static	O
void	O
rotate_on_output	(int,int,*(int),*(int))->(void)
(	O
int	O
ai	int
,	O
int	O
aj	int
,	O
int	O
*	O
bi	*(int)
,	O
int	O
*	O
bj	*(int)
)	O
;	O
DECLARE	O
(	O
gtp_aa_confirm_safety	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_accurate_approxlib	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_accuratelib	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_advance_random_seed	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_all_legal	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_all_move_values	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_analyze_eyegraph	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_analyze_semeai	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_analyze_semeai_after_move	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_attack	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_attack_either	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_block_off	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_break_in	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_captures	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_clear_board	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_clear_cache	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_combination_attack	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_combination_defend	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_connect	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_countlib	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_cputime	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_decrease_depths	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_defend	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_defend_both	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_disconnect	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_does_attack	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_does_defend	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_does_surround	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_dragon_data	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_dragon_status	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_dragon_stones	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_draw_search_area	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_dump_stack	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_echo	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_echo_err	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_estimate_score	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_eval_eye	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_experimental_score	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_eye_data	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_final_score	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_final_status	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_final_status_list	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_findlib	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_finish_sgftrace	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_fixed_handicap	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_followup_influence	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_genmove	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_genmove_black	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_genmove_white	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_get_connection_node_counter	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_get_handicap	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_get_komi	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_get_life_node_counter	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_get_owl_node_counter	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_get_random_seed	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_get_reading_node_counter	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_get_trymove_counter	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_gg_genmove	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_gg_undo	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_half_eye_data	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_increase_depths	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_initial_influence	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_invariant_hash	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_invariant_hash_for_moves	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_is_legal	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_is_surrounded	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_kgs_genmove_cleanup	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_known_command	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_ladder_attack	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_last_move	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_limit_search	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_list_commands	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_list_stones	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_loadsgf	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_move_influence	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_move_probabilities	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_move_reasons	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_move_uncertainty	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_move_history	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_name	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_owl_attack	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_owl_connection_defends	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_owl_defend	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_owl_does_attack	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_owl_does_defend	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_owl_substantial	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_owl_threaten_attack	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_owl_threaten_defense	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_place_free_handicap	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_play	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_playblack	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_playwhite	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_popgo	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_printsgf	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_program_version	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_protocol_version	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_query_boardsize	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_query_orientation	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_quit	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_reg_genmove	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_report_uncertainty	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_reset_connection_node_counter	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_reset_life_node_counter	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_reset_owl_node_counter	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_reset_reading_node_counter	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_reset_search_mask	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_reset_trymove_counter	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_restricted_genmove	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_same_dragon	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_set_boardsize	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_set_free_handicap	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_set_komi	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_set_level	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_set_orientation	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_set_random_seed	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_set_search_diamond	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_set_search_limit	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_showboard	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_start_sgftrace	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_surround_map	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_tactical_analyze_semeai	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_test_eyeshape	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_time_left	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_time_settings	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_top_moves	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_top_moves_black	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_top_moves_white	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_tryko	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_trymove	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_tune_move_ordering	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_unconditional_status	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_undo	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_what_color	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_worm_cutstone	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_worm_data	(*(char))->(int)
)	O
;	O
DECLARE	O
(	O
gtp_worm_stones	(*(char))->(int)
)	O
;	O
static	O
struct	O
gtp_command	struct(*(char),*((*(char))->(int)))
commands	array(struct(*(char),*((*(char))->(int))))
[	O
]	O
=	O
{	O
{	O
"aa_confirm_safety"	*(char)
,	O
gtp_aa_confirm_safety	(*(char))->(int)
}	O
,	O
{	O
"accurate_approxlib"	*(char)
,	O
gtp_accurate_approxlib	(*(char))->(int)
}	O
,	O
{	O
"accuratelib"	*(char)
,	O
gtp_accuratelib	(*(char))->(int)
}	O
,	O
{	O
"advance_random_seed"	*(char)
,	O
gtp_advance_random_seed	(*(char))->(int)
}	O
,	O
{	O
"all_legal"	*(char)
,	O
gtp_all_legal	(*(char))->(int)
}	O
,	O
{	O
"all_move_values"	*(char)
,	O
gtp_all_move_values	(*(char))->(int)
}	O
,	O
{	O
"analyze_eyegraph"	*(char)
,	O
gtp_analyze_eyegraph	(*(char))->(int)
}	O
,	O
{	O
"analyze_semeai"	*(char)
,	O
gtp_analyze_semeai	(*(char))->(int)
}	O
,	O
{	O
"analyze_semeai_after_move"	*(char)
,	O
gtp_analyze_semeai_after_move	(*(char))->(int)
}	O
,	O
{	O
"attack"	*(char)
,	O
gtp_attack	(*(char))->(int)
}	O
,	O
{	O
"attack_either"	*(char)
,	O
gtp_attack_either	(*(char))->(int)
}	O
,	O
{	O
"black"	*(char)
,	O
gtp_playblack	(*(char))->(int)
}	O
,	O
{	O
"block_off"	*(char)
,	O
gtp_block_off	(*(char))->(int)
}	O
,	O
{	O
"boardsize"	*(char)
,	O
gtp_set_boardsize	(*(char))->(int)
}	O
,	O
{	O
"break_in"	*(char)
,	O
gtp_break_in	(*(char))->(int)
}	O
,	O
{	O
"captures"	*(char)
,	O
gtp_captures	(*(char))->(int)
}	O
,	O
{	O
"clear_board"	*(char)
,	O
gtp_clear_board	(*(char))->(int)
}	O
,	O
{	O
"clear_cache"	*(char)
,	O
gtp_clear_cache	(*(char))->(int)
}	O
,	O
{	O
"color"	*(char)
,	O
gtp_what_color	(*(char))->(int)
}	O
,	O
{	O
"combination_attack"	*(char)
,	O
gtp_combination_attack	(*(char))->(int)
}	O
,	O
{	O
"combination_defend"	*(char)
,	O
gtp_combination_defend	(*(char))->(int)
}	O
,	O
{	O
"connect"	*(char)
,	O
gtp_connect	(*(char))->(int)
}	O
,	O
{	O
"countlib"	*(char)
,	O
gtp_countlib	(*(char))->(int)
}	O
,	O
{	O
"cputime"	*(char)
,	O
gtp_cputime	(*(char))->(int)
}	O
,	O
{	O
"decrease_depths"	*(char)
,	O
gtp_decrease_depths	(*(char))->(int)
}	O
,	O
{	O
"defend"	*(char)
,	O
gtp_defend	(*(char))->(int)
}	O
,	O
{	O
"defend_both"	*(char)
,	O
gtp_defend_both	(*(char))->(int)
}	O
,	O
{	O
"disconnect"	*(char)
,	O
gtp_disconnect	(*(char))->(int)
}	O
,	O
{	O
"does_attack"	*(char)
,	O
gtp_does_attack	(*(char))->(int)
}	O
,	O
{	O
"does_defend"	*(char)
,	O
gtp_does_defend	(*(char))->(int)
}	O
,	O
{	O
"does_surround"	*(char)
,	O
gtp_does_surround	(*(char))->(int)
}	O
,	O
{	O
"dragon_data"	*(char)
,	O
gtp_dragon_data	(*(char))->(int)
}	O
,	O
{	O
"dragon_status"	*(char)
,	O
gtp_dragon_status	(*(char))->(int)
}	O
,	O
{	O
"dragon_stones"	*(char)
,	O
gtp_dragon_stones	(*(char))->(int)
}	O
,	O
{	O
"draw_search_area"	*(char)
,	O
gtp_draw_search_area	(*(char))->(int)
}	O
,	O
{	O
"dump_stack"	*(char)
,	O
gtp_dump_stack	(*(char))->(int)
}	O
,	O
{	O
"echo"	*(char)
,	O
gtp_echo	(*(char))->(int)
}	O
,	O
{	O
"echo_err"	*(char)
,	O
gtp_echo_err	(*(char))->(int)
}	O
,	O
{	O
"estimate_score"	*(char)
,	O
gtp_estimate_score	(*(char))->(int)
}	O
,	O
{	O
"eval_eye"	*(char)
,	O
gtp_eval_eye	(*(char))->(int)
}	O
,	O
{	O
"experimental_score"	*(char)
,	O
gtp_experimental_score	(*(char))->(int)
}	O
,	O
{	O
"eye_data"	*(char)
,	O
gtp_eye_data	(*(char))->(int)
}	O
,	O
{	O
"final_score"	*(char)
,	O
gtp_final_score	(*(char))->(int)
}	O
,	O
{	O
"final_status"	*(char)
,	O
gtp_final_status	(*(char))->(int)
}	O
,	O
{	O
"final_status_list"	*(char)
,	O
gtp_final_status_list	(*(char))->(int)
}	O
,	O
{	O
"findlib"	*(char)
,	O
gtp_findlib	(*(char))->(int)
}	O
,	O
{	O
"finish_sgftrace"	*(char)
,	O
gtp_finish_sgftrace	(*(char))->(int)
}	O
,	O
{	O
"fixed_handicap"	*(char)
,	O
gtp_fixed_handicap	(*(char))->(int)
}	O
,	O
{	O
"followup_influence"	*(char)
,	O
gtp_followup_influence	(*(char))->(int)
}	O
,	O
{	O
"genmove"	*(char)
,	O
gtp_genmove	(*(char))->(int)
}	O
,	O
{	O
"genmove_black"	*(char)
,	O
gtp_genmove_black	(*(char))->(int)
}	O
,	O
{	O
"genmove_white"	*(char)
,	O
gtp_genmove_white	(*(char))->(int)
}	O
,	O
{	O
"get_connection_node_counter"	*(char)
,	O
gtp_get_connection_node_counter	(*(char))->(int)
}	O
,	O
{	O
"get_handicap"	*(char)
,	O
gtp_get_handicap	(*(char))->(int)
}	O
,	O
{	O
"get_komi"	*(char)
,	O
gtp_get_komi	(*(char))->(int)
}	O
,	O
{	O
"get_life_node_counter"	*(char)
,	O
gtp_get_life_node_counter	(*(char))->(int)
}	O
,	O
{	O
"get_owl_node_counter"	*(char)
,	O
gtp_get_owl_node_counter	(*(char))->(int)
}	O
,	O
{	O
"get_random_seed"	*(char)
,	O
gtp_get_random_seed	(*(char))->(int)
}	O
,	O
{	O
"get_reading_node_counter"	*(char)
,	O
gtp_get_reading_node_counter	(*(char))->(int)
}	O
,	O
{	O
"get_trymove_counter"	*(char)
,	O
gtp_get_trymove_counter	(*(char))->(int)
}	O
,	O
{	O
"gg-undo"	*(char)
,	O
gtp_gg_undo	(*(char))->(int)
}	O
,	O
{	O
"gg_genmove"	*(char)
,	O
gtp_gg_genmove	(*(char))->(int)
}	O
,	O
{	O
"half_eye_data"	*(char)
,	O
gtp_half_eye_data	(*(char))->(int)
}	O
,	O
{	O
"help"	*(char)
,	O
gtp_list_commands	(*(char))->(int)
}	O
,	O
{	O
"increase_depths"	*(char)
,	O
gtp_increase_depths	(*(char))->(int)
}	O
,	O
{	O
"initial_influence"	*(char)
,	O
gtp_initial_influence	(*(char))->(int)
}	O
,	O
{	O
"invariant_hash_for_moves"	*(char)
,	O
gtp_invariant_hash_for_moves	(*(char))->(int)
}	O
,	O
{	O
"invariant_hash"	*(char)
,	O
gtp_invariant_hash	(*(char))->(int)
}	O
,	O
{	O
"is_legal"	*(char)
,	O
gtp_is_legal	(*(char))->(int)
}	O
,	O
{	O
"is_surrounded"	*(char)
,	O
gtp_is_surrounded	(*(char))->(int)
}	O
,	O
{	O
"kgs-genmove_cleanup"	*(char)
,	O
gtp_kgs_genmove_cleanup	(*(char))->(int)
}	O
,	O
{	O
"known_command"	*(char)
,	O
gtp_known_command	(*(char))->(int)
}	O
,	O
{	O
"komi"	*(char)
,	O
gtp_set_komi	(*(char))->(int)
}	O
,	O
{	O
"ladder_attack"	*(char)
,	O
gtp_ladder_attack	(*(char))->(int)
}	O
,	O
{	O
"last_move"	*(char)
,	O
gtp_last_move	(*(char))->(int)
}	O
,	O
{	O
"level"	*(char)
,	O
gtp_set_level	(*(char))->(int)
}	O
,	O
{	O
"limit_search"	*(char)
,	O
gtp_limit_search	(*(char))->(int)
}	O
,	O
{	O
"list_commands"	*(char)
,	O
gtp_list_commands	(*(char))->(int)
}	O
,	O
{	O
"list_stones"	*(char)
,	O
gtp_list_stones	(*(char))->(int)
}	O
,	O
{	O
"loadsgf"	*(char)
,	O
gtp_loadsgf	(*(char))->(int)
}	O
,	O
{	O
"move_influence"	*(char)
,	O
gtp_move_influence	(*(char))->(int)
}	O
,	O
{	O
"move_probabilities"	*(char)
,	O
gtp_move_probabilities	(*(char))->(int)
}	O
,	O
{	O
"move_reasons"	*(char)
,	O
gtp_move_reasons	(*(char))->(int)
}	O
,	O
{	O
"move_uncertainty"	*(char)
,	O
gtp_move_uncertainty	(*(char))->(int)
}	O
,	O
{	O
"move_history"	*(char)
,	O
gtp_move_history	(*(char))->(int)
}	O
,	O
{	O
"name"	*(char)
,	O
gtp_name	(*(char))->(int)
}	O
,	O
{	O
"new_score"	*(char)
,	O
gtp_estimate_score	(*(char))->(int)
}	O
,	O
{	O
"orientation"	*(char)
,	O
gtp_set_orientation	(*(char))->(int)
}	O
,	O
{	O
"owl_attack"	*(char)
,	O
gtp_owl_attack	(*(char))->(int)
}	O
,	O
{	O
"owl_connection_defends"	*(char)
,	O
gtp_owl_connection_defends	(*(char))->(int)
}	O
,	O
{	O
"owl_defend"	*(char)
,	O
gtp_owl_defend	(*(char))->(int)
}	O
,	O
{	O
"owl_does_attack"	*(char)
,	O
gtp_owl_does_attack	(*(char))->(int)
}	O
,	O
{	O
"owl_does_defend"	*(char)
,	O
gtp_owl_does_defend	(*(char))->(int)
}	O
,	O
{	O
"owl_substantial"	*(char)
,	O
gtp_owl_substantial	(*(char))->(int)
}	O
,	O
{	O
"owl_threaten_attack"	*(char)
,	O
gtp_owl_threaten_attack	(*(char))->(int)
}	O
,	O
{	O
"owl_threaten_defense"	*(char)
,	O
gtp_owl_threaten_defense	(*(char))->(int)
}	O
,	O
{	O
"place_free_handicap"	*(char)
,	O
gtp_place_free_handicap	(*(char))->(int)
}	O
,	O
{	O
"play"	*(char)
,	O
gtp_play	(*(char))->(int)
}	O
,	O
{	O
"popgo"	*(char)
,	O
gtp_popgo	(*(char))->(int)
}	O
,	O
{	O
"printsgf"	*(char)
,	O
gtp_printsgf	(*(char))->(int)
}	O
,	O
{	O
"protocol_version"	*(char)
,	O
gtp_protocol_version	(*(char))->(int)
}	O
,	O
{	O
"query_boardsize"	*(char)
,	O
gtp_query_boardsize	(*(char))->(int)
}	O
,	O
{	O
"query_orientation"	*(char)
,	O
gtp_query_orientation	(*(char))->(int)
}	O
,	O
{	O
"quit"	*(char)
,	O
gtp_quit	(*(char))->(int)
}	O
,	O
{	O
"reg_genmove"	*(char)
,	O
gtp_reg_genmove	(*(char))->(int)
}	O
,	O
{	O
"report_uncertainty"	*(char)
,	O
gtp_report_uncertainty	(*(char))->(int)
}	O
,	O
{	O
"reset_connection_node_counter"	*(char)
,	O
gtp_reset_connection_node_counter	(*(char))->(int)
}	O
,	O
{	O
"reset_life_node_counter"	*(char)
,	O
gtp_reset_life_node_counter	(*(char))->(int)
}	O
,	O
{	O
"reset_owl_node_counter"	*(char)
,	O
gtp_reset_owl_node_counter	(*(char))->(int)
}	O
,	O
{	O
"reset_reading_node_counter"	*(char)
,	O
gtp_reset_reading_node_counter	(*(char))->(int)
}	O
,	O
{	O
"reset_search_mask"	*(char)
,	O
gtp_reset_search_mask	(*(char))->(int)
}	O
,	O
{	O
"reset_trymove_counter"	*(char)
,	O
gtp_reset_trymove_counter	(*(char))->(int)
}	O
,	O
{	O
"restricted_genmove"	*(char)
,	O
gtp_restricted_genmove	(*(char))->(int)
}	O
,	O
{	O
"same_dragon"	*(char)
,	O
gtp_same_dragon	(*(char))->(int)
}	O
,	O
{	O
"set_free_handicap"	*(char)
,	O
gtp_set_free_handicap	(*(char))->(int)
}	O
,	O
{	O
"set_random_seed"	*(char)
,	O
gtp_set_random_seed	(*(char))->(int)
}	O
,	O
{	O
"set_search_diamond"	*(char)
,	O
gtp_set_search_diamond	(*(char))->(int)
}	O
,	O
{	O
"set_search_limit"	*(char)
,	O
gtp_set_search_limit	(*(char))->(int)
}	O
,	O
{	O
"showboard"	*(char)
,	O
gtp_showboard	(*(char))->(int)
}	O
,	O
{	O
"start_sgftrace"	*(char)
,	O
gtp_start_sgftrace	(*(char))->(int)
}	O
,	O
{	O
"surround_map"	*(char)
,	O
gtp_surround_map	(*(char))->(int)
}	O
,	O
{	O
"tactical_analyze_semeai"	*(char)
,	O
gtp_tactical_analyze_semeai	(*(char))->(int)
}	O
,	O
{	O
"test_eyeshape"	*(char)
,	O
gtp_test_eyeshape	(*(char))->(int)
}	O
,	O
{	O
"time_left"	*(char)
,	O
gtp_time_left	(*(char))->(int)
}	O
,	O
{	O
"time_settings"	*(char)
,	O
gtp_time_settings	(*(char))->(int)
}	O
,	O
{	O
"top_moves"	*(char)
,	O
gtp_top_moves	(*(char))->(int)
}	O
,	O
{	O
"top_moves_black"	*(char)
,	O
gtp_top_moves_black	(*(char))->(int)
}	O
,	O
{	O
"top_moves_white"	*(char)
,	O
gtp_top_moves_white	(*(char))->(int)
}	O
,	O
{	O
"tryko"	*(char)
,	O
gtp_tryko	(*(char))->(int)
}	O
,	O
{	O
"trymove"	*(char)
,	O
gtp_trymove	(*(char))->(int)
}	O
,	O
{	O
"tune_move_ordering"	*(char)
,	O
gtp_tune_move_ordering	(*(char))->(int)
}	O
,	O
{	O
"unconditional_status"	*(char)
,	O
gtp_unconditional_status	(*(char))->(int)
}	O
,	O
{	O
"undo"	*(char)
,	O
gtp_undo	(*(char))->(int)
}	O
,	O
{	O
"version"	*(char)
,	O
gtp_program_version	(*(char))->(int)
}	O
,	O
{	O
"white"	*(char)
,	O
gtp_playwhite	(*(char))->(int)
}	O
,	O
{	O
"worm_cutstone"	*(char)
,	O
gtp_worm_cutstone	(*(char))->(int)
}	O
,	O
{	O
"worm_data"	*(char)
,	O
gtp_worm_data	(*(char))->(int)
}	O
,	O
{	O
"worm_stones"	*(char)
,	O
gtp_worm_stones	(*(char))->(int)
}	O
,	O
{	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
void	O
play_gtp	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
FILE	struct
*	O
gtp_input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
FILE	struct
*	O
gtp_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
FILE	struct
*	O
gtp_dump_commands	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
gtp_initial_orientation	int
)	O
{	O
setbuf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
gtp_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
NULL	O
)	O
;	O
gtp_internal_set_boardsize	(int)->(void)
(	O
board_size	int
)	O
;	O
gtp_orientation	int
=	O
gtp_initial_orientation	int
;	O
gtp_set_vertex_transform_hooks	(*((int,int,*(int),*(int))->(void)),*((int,int,*(int),*(int))->(void)))->(void)
(	O
rotate_on_input	(int,int,*(int),*(int))->(void)
,	O
rotate_on_output	(int,int,*(int),*(int))->(void)
)	O
;	O
init_timers	()->(void)
(	O
)	O
;	O
reset_engine	()->(void)
(	O
)	O
;	O
clearstats	()->(void)
(	O
)	O
;	O
gtp_main_loop	(array(struct(*(char),*((*(char))->(int)))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
commands	array(struct(*(char),*((*(char))->(int))))
,	O
gtp_input	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gtp_output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
gtp_dump_commands	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
showstatistics	int
)	O
showstats	()->(void)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_quit	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
return	O
GTP_QUIT	O
;	O
}	O
static	O
int	O
gtp_protocol_version	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
gtp_version	int
)	O
;	O
}	O
static	O
int	O
gtp_name	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"GNU Go"	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_program_version	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
VERSION	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_set_boardsize	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
boardsize	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d"	*(char)
,	O
&	O
boardsize	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"boardsize not an integer"	*(char)
)	O
;	O
if	O
(	O
!	O
check_boardsize	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
boardsize	int
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
gtp_version	int
==	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"unacceptable boardsize"	*(char)
)	O
;	O
else	O
return	O
gtp_failure	(*(char))->(int)
(	O
"unacceptable size"	*(char)
)	O
;	O
}	O
if	O
(	O
stones_on_board	(int)->(int)
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
0	int
)	O
update_random_seed	()->(void)
(	O
)	O
;	O
board_size	int
=	O
boardsize	int
;	O
clear_board	()->(void)
(	O
)	O
;	O
gtp_internal_set_boardsize	(int)->(void)
(	O
boardsize	int
)	O
;	O
reset_engine	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_query_boardsize	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
board_size	int
)	O
;	O
}	O
static	O
int	O
gtp_clear_board	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
if	O
(	O
stones_on_board	(int)->(int)
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
0	int
)	O
update_random_seed	()->(void)
(	O
)	O
;	O
clear_board	()->(void)
(	O
)	O
;	O
init_timers	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_set_orientation	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
orientation	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d"	*(char)
,	O
&	O
orientation	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"orientation not an integer"	*(char)
)	O
;	O
if	O
(	O
orientation	int
<	O
0	int
||	O
orientation	int
>	O
7	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"unacceptable orientation"	*(char)
)	O
;	O
clear_board	()->(void)
(	O
)	O
;	O
gtp_orientation	int
=	O
orientation	int
;	O
gtp_set_vertex_transform_hooks	(*((int,int,*(int),*(int))->(void)),*((int,int,*(int),*(int))->(void)))->(void)
(	O
rotate_on_input	(int,int,*(int),*(int))->(void)
,	O
rotate_on_output	(int,int,*(int),*(int))->(void)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_query_orientation	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
gtp_orientation	int
)	O
;	O
}	O
static	O
int	O
gtp_set_komi	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%f"	*(char)
,	O
&	O
komi	float
)	O
<	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"komi not a float"	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_get_komi	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%4.1f"	*(char)
,	O
komi	float
)	O
;	O
}	O
static	O
int	O
gtp_playblack	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
*	O
c	char
;	O
for	O
(	O
c	char
=	O
s	*(char)
;	O
*	O
c	char
;	O
c	char
++	O
)	O
*	O
c	char
=	O
tolower	(int)->(int)
(	O
(	O
int	O
)	O
*	O
c	char
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
"pass"	*(char)
,	O
4	int
)	O
==	O
0	int
)	O
{	O
i	int
=	O
-	O
1	int
;	O
j	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
!	O
is_allowed_move	(int,int)->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
BLACK	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"illegal move"	*(char)
)	O
;	O
gnugo_play_move	(int,int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
BLACK	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_playwhite	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
*	O
c	char
;	O
for	O
(	O
c	char
=	O
s	*(char)
;	O
*	O
c	char
;	O
c	char
++	O
)	O
*	O
c	char
=	O
tolower	(int)->(int)
(	O
(	O
int	O
)	O
*	O
c	char
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
"pass"	*(char)
,	O
4	int
)	O
==	O
0	int
)	O
{	O
i	int
=	O
-	O
1	int
;	O
j	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
!	O
is_allowed_move	(int,int)->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
WHITE	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"illegal move"	*(char)
)	O
;	O
gnugo_play_move	(int,int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
WHITE	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_play	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_move	(*(char),*(int),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color or coordinate"	*(char)
)	O
;	O
if	O
(	O
!	O
is_allowed_move	(int,int)->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"illegal move"	*(char)
)	O
;	O
gnugo_play_move	(int,int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_fixed_handicap	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
m	int
,	O
n	int
;	O
int	O
first	int
=	O
1	int
;	O
int	O
this_handicap	int
;	O
if	O
(	O
gtp_version	int
==	O
1	int
)	O
clear_board	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
stones_on_board	(int)->(int)
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"board not empty"	*(char)
)	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d"	*(char)
,	O
&	O
this_handicap	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"handicap not an integer"	*(char)
)	O
;	O
if	O
(	O
this_handicap	int
<	O
2	int
&&	O
(	O
gtp_version	int
>	O
1	int
||	O
this_handicap	int
!=	O
0	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid handicap"	*(char)
)	O
;	O
if	O
(	O
place_fixed_handicap	(int)->(int)
(	O
this_handicap	int
)	O
!=	O
this_handicap	int
)	O
{	O
clear_board	()->(void)
(	O
)	O
;	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid handicap"	*(char)
)	O
;	O
}	O
handicap	int
=	O
this_handicap	int
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
m	int
,	O
n	int
)	O
!=	O
EMPTY	int
)	O
{	O
if	O
(	O
!	O
first	int
)	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
else	O
first	int
=	O
0	int
;	O
gtp_mprintf	(*(char))->(void)
(	O
"%m"	*(char)
,	O
m	int
,	O
n	int
)	O
;	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_place_free_handicap	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
m	int
,	O
n	int
;	O
int	O
first	int
=	O
1	int
;	O
int	O
this_handicap	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d"	*(char)
,	O
&	O
this_handicap	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"handicap not an integer"	*(char)
)	O
;	O
if	O
(	O
stones_on_board	(int)->(int)
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"board not empty"	*(char)
)	O
;	O
if	O
(	O
this_handicap	int
<	O
2	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid handicap"	*(char)
)	O
;	O
handicap	int
=	O
place_free_handicap	(int)->(int)
(	O
this_handicap	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
m	int
,	O
n	int
)	O
!=	O
EMPTY	int
)	O
{	O
if	O
(	O
!	O
first	int
)	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
else	O
first	int
=	O
0	int
;	O
gtp_mprintf	(*(char))->(void)
(	O
"%m"	*(char)
,	O
m	int
,	O
n	int
)	O
;	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_set_free_handicap	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
n	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
k	int
;	O
if	O
(	O
stones_on_board	(int)->(int)
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"board not empty"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_BOARD	int
*	O
MAX_BOARD	int
;	O
k	int
++	O
)	O
{	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
!=	O
EMPTY	int
)	O
{	O
clear_board	()->(void)
(	O
)	O
;	O
return	O
gtp_failure	(*(char))->(int)
(	O
"repeated vertex"	*(char)
)	O
;	O
}	O
add_stone	(int,int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
BLACK	int
)	O
;	O
s	*(char)
+=	O
n	int
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%*s"	*(char)
)	O
!=	O
EOF	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
k	int
<	O
2	int
)	O
{	O
clear_board	()->(void)
(	O
)	O
;	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid handicap"	*(char)
)	O
;	O
}	O
handicap	int
=	O
k	int
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_get_handicap	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
handicap	int
)	O
;	O
}	O
static	O
int	O
gtp_loadsgf	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
filename	*(char)
[	O
GTP_BUFSIZE	int
]	O
;	O
char	O
untilstring	*(char)
[	O
GTP_BUFSIZE	int
]	O
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
;	O
Gameinfo	struct(int,int,struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))),int)
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
;	O
int	O
nread	int
;	O
int	O
color_to_move	int
;	O
nread	int
=	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%s %s"	*(char)
,	O
filename	*(char)
,	O
untilstring	*(char)
)	O
;	O
if	O
(	O
nread	int
<	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"missing filename"	*(char)
)	O
;	O
sgftree_clear	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(void)
(	O
&	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
)	O
;	O
if	O
(	O
!	O
sgftree_readfile	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(int)
(	O
&	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
,	O
filename	*(char)
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"cannot open or parse '%s'"	*(char)
,	O
filename	*(char)
)	O
;	O
if	O
(	O
nread	int
==	O
1	int
)	O
color_to_move	int
=	O
gameinfo_play_sgftree_rot	(*(struct(int,int,struct(*(struct`),*(struct`)),int)),*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char),int)->(int)
(	O
&	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
,	O
&	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
,	O
NULL	O
,	O
gtp_orientation	int
)	O
;	O
else	O
color_to_move	int
=	O
gameinfo_play_sgftree_rot	(*(struct(int,int,struct(*(struct`),*(struct`)),int)),*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char),int)->(int)
(	O
&	O
gameinfo	*(struct(int,int,struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`))),int))
,	O
&	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
,	O
untilstring	*(char)
,	O
gtp_orientation	int
)	O
;	O
if	O
(	O
color_to_move	int
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"cannot load '%s'"	*(char)
,	O
filename	*(char)
)	O
;	O
gtp_internal_set_boardsize	(int)->(void)
(	O
board_size	int
)	O
;	O
reset_engine	()->(void)
(	O
)	O
;	O
init_timers	()->(void)
(	O
)	O
;	O
sgfFreeNode	(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(void)
(	O
sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
.	O
root	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"%C"	*(char)
,	O
color_to_move	int
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_what_color	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
color_to_string	(int)->(*(char))
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_list_stones	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
=	O
EMPTY	int
;	O
int	O
vertexi	array(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
vertexj	array(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
vertices	int
=	O
0	int
;	O
if	O
(	O
!	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
color	int
)	O
{	O
vertexi	array(int)
[	O
vertices	int
]	O
=	O
i	int
;	O
vertexj	array(int)
[	O
vertices	int
++	O
]	O
=	O
j	int
;	O
}	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertices	(int,array(int),array(int))->(void)
(	O
vertices	int
,	O
vertexi	array(int)
,	O
vertexj	array(int)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_countlib	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
countlib	(int)->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_findlib	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	*(int)
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertices2	(int,*(int))->(void)
(	O
liberties	*(int)
,	O
libs	*(int)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_accuratelib	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	*(int)
;	O
if	O
(	O
!	O
gtp_decode_move	(*(char),*(int),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color or coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must be empty"	*(char)
)	O
;	O
liberties	*(int)
=	O
accuratelib	(int,int,int,*(int))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertices2	(int,*(int))->(void)
(	O
liberties	*(int)
,	O
libs	*(int)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_accurate_approxlib	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	*(int)
;	O
if	O
(	O
!	O
gtp_decode_move	(*(char),*(int),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color or coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must be empty"	*(char)
)	O
;	O
liberties	*(int)
=	O
accuratelib	(int,int,int,*(int))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertices2	(int,*(int))->(void)
(	O
liberties	*(int)
,	O
libs	*(int)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_is_legal	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_move	(*(char),*(int),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color or coordinate"	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
is_allowed_move	(int,int)->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
)	O
;	O
}	O
static	O
int	O
gtp_all_legal	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
int	O
movei	array(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
movej	array(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
moves	array(int)
=	O
0	int
;	O
if	O
(	O
!	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
&&	O
is_allowed_move	(int,int)->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
)	O
{	O
movei	array(int)
[	O
moves	array(int)
]	O
=	O
i	int
;	O
movej	array(int)
[	O
moves	array(int)
++	O
]	O
=	O
j	int
;	O
}	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertices	(int,array(int),array(int))->(void)
(	O
moves	array(int)
,	O
movei	array(int)
,	O
movej	array(int)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_captures	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
if	O
(	O
color	int
==	O
BLACK	int
)	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
white_captured	int
)	O
;	O
else	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
black_captured	int
)	O
;	O
}	O
static	O
int	O
gtp_last_move	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
pos	int
;	O
int	O
color	int
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
if	O
(	O
move_history_pointer	int
<=	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"no previous move known"	*(char)
)	O
;	O
pos	int
=	O
move_history_pos	array(int)
[	O
move_history_pointer	int
-	O
1	int
]	O
;	O
color	int
=	O
move_history_color	array(int)
[	O
move_history_pointer	int
-	O
1	int
]	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"%C %m"	*(char)
,	O
color	int
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_move_history	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
k	int
,	O
pos	int
,	O
color	int
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
move_history_pointer	int
>	O
0	int
)	O
for	O
(	O
k	int
=	O
move_history_pointer	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
color	int
=	O
move_history_color	array(int)
[	O
k	int
]	O
;	O
pos	int
=	O
move_history_pos	array(int)
[	O
k	int
]	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"%C %m\n"	*(char)
,	O
color	int
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_invariant_hash	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
Hash_data	struct(array(long))
hash	struct(array(long))
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
hashdata_calc_orientation_invariant	(*(struct(array(long))),*(char),int)->(void)
(	O
&	O
hash	struct(array(long))
,	O
board	*(char)
,	O
board_ko_pos	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%s"	*(char)
,	O
hashdata_to_string	(*(struct(array(long))))->(*(char))
(	O
&	O
hash	struct(array(long))
)	O
)	O
;	O
}	O
static	O
int	O
gtp_invariant_hash_for_moves	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
Hash_data	struct(array(long))
hash	struct(array(long))
;	O
int	O
color	int
;	O
int	O
pos	int
;	O
int	O
move_found	int
=	O
0	int
;	O
if	O
(	O
!	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
"gtp_invariant_hash_for_moves"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
hashdata_calc_orientation_invariant	(*(struct(array(long))),*(char),int)->(void)
(	O
&	O
hash	struct(array(long))
,	O
board	*(char)
,	O
board_ko_pos	int
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"%m %s\n"	*(char)
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
,	O
hashdata_to_string	(*(struct(array(long))))->(*(char))
(	O
&	O
hash	struct(array(long))
)	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
move_found	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
move_found	int
)	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_trymove	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_move	(*(char),*(int),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color or coordinate"	*(char)
)	O
;	O
if	O
(	O
!	O
trymove	(int,int,*(char),int)->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
,	O
"gtp_trymove"	*(char)
,	O
NO_MOVE	O
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"illegal move"	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_tryko	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_move	(*(char),*(int),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
||	O
POS	O
(	O
i	int
,	O
j	int
)	O
==	O
PASS_MOVE	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color or coordinate"	*(char)
)	O
;	O
if	O
(	O
!	O
tryko	(int,int,*(char))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
,	O
"gtp_tryko"	*(char)
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"illegal move"	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_popgo	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
if	O
(	O
stackp	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"Stack empty."	*(char)
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_clear_cache	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
clear_persistent_caches	()->(void)
(	O
)	O
;	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_attack	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
apos	int
;	O
int	O
attack_code	*(int)
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
attack_code	*(int)
=	O
attack	(int,*(int))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
apos	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
attack_code	*(int)
)	O
;	O
if	O
(	O
attack_code	*(int)
>	O
0	int
)	O
{	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
apos	int
)	O
,	O
J	O
(	O
apos	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_attack_either	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	*(int)
,	O
bj	*(int)
;	O
int	O
n	int
;	O
int	O
acode	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"string vertex must be empty"	*(char)
)	O
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
n	int
,	O
&	O
bi	*(int)
,	O
&	O
bj	*(int)
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"string vertex must not be empty"	*(char)
)	O
;	O
acode	int
=	O
attack_either	(int,int)->(int)
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
POS	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
acode	int
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_defend	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
dpos	int
;	O
int	O
defend_code	*(int)
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
defend_code	*(int)
=	O
find_defense	(int,*(int))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
dpos	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
defend_code	*(int)
)	O
;	O
if	O
(	O
defend_code	*(int)
>	O
0	int
)	O
{	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
dpos	int
)	O
,	O
J	O
(	O
dpos	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_does_attack	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
ti	int
,	O
tj	int
;	O
int	O
attack_code	*(int)
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ti	int
,	O
&	O
tj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ti	int
,	O
tj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"move vertex must be empty"	*(char)
)	O
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
n	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"string vertex must not be empty"	*(char)
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
attack_code	*(int)
=	O
does_attack	(int,int)->(int)
(	O
POS	O
(	O
ti	int
,	O
tj	int
)	O
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
attack_code	*(int)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_does_defend	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
ti	int
,	O
tj	int
;	O
int	O
defense_code	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ti	int
,	O
&	O
tj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ti	int
,	O
tj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"move vertex must be empty"	*(char)
)	O
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
n	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"string vertex must not be empty"	*(char)
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
defense_code	int
=	O
does_defend	(int,int)->(int)
(	O
POS	O
(	O
ti	int
,	O
tj	int
)	O
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
defense_code	int
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_ladder_attack	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
apos	int
;	O
int	O
attack_code	*(int)
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
!=	O
2	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"string must have exactly 2 liberties"	*(char)
)	O
;	O
attack_code	*(int)
=	O
simple_ladder	(int,*(int))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
apos	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
attack_code	*(int)
)	O
;	O
if	O
(	O
attack_code	*(int)
>	O
0	int
)	O
{	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
apos	int
)	O
,	O
J	O
(	O
apos	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_increase_depths	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
increase_depth_values	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_decrease_depths	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_owl_attack	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
attack_point	*(int)
;	O
int	O
attack_code	*(int)
;	O
int	O
result_certain	int
;	O
int	O
kworm	int
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
attack_code	*(int)
=	O
owl_attack	(int,*(int),*(int),*(int))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
attack_point	*(int)
,	O
&	O
result_certain	int
,	O
&	O
kworm	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
attack_code	*(int)
)	O
;	O
if	O
(	O
attack_code	*(int)
>	O
0	int
)	O
{	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
attack_point	*(int)
)	O
,	O
J	O
(	O
attack_point	*(int)
)	O
)	O
;	O
}	O
if	O
(	O
!	O
result_certain	int
&&	O
report_uncertainty	int
)	O
gtp_printf	(*(char))->(void)
(	O
" uncertain"	*(char)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_defend	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
defense_point	*(int)
;	O
int	O
defend_code	*(int)
;	O
int	O
result_certain	int
;	O
int	O
kworm	int
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
defend_code	*(int)
=	O
owl_defend	(int,*(int),*(int),*(int))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
defense_point	*(int)
,	O
&	O
result_certain	int
,	O
&	O
kworm	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
defend_code	*(int)
)	O
;	O
if	O
(	O
defend_code	*(int)
>	O
0	int
)	O
{	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
defense_point	*(int)
)	O
,	O
J	O
(	O
defense_point	*(int)
)	O
)	O
;	O
}	O
if	O
(	O
!	O
result_certain	int
&&	O
report_uncertainty	int
)	O
gtp_printf	(*(char))->(void)
(	O
" uncertain"	*(char)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_threaten_attack	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
attack_point1	int
;	O
int	O
attack_point2	int
;	O
int	O
attack_code	*(int)
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
attack_code	*(int)
=	O
owl_threaten_attack	(int,*(int),*(int))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
attack_point1	int
,	O
&	O
attack_point2	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
attack_code	*(int)
)	O
;	O
if	O
(	O
attack_code	*(int)
>	O
0	int
)	O
{	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
attack_point1	int
)	O
,	O
J	O
(	O
attack_point1	int
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
attack_point2	int
)	O
,	O
J	O
(	O
attack_point2	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_threaten_defense	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
defense_point1	int
;	O
int	O
defense_point2	int
;	O
int	O
defend_code	*(int)
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
defend_code	*(int)
=	O
owl_threaten_defense	(int,*(int),*(int))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
defense_point1	int
,	O
&	O
defense_point2	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
defend_code	*(int)
)	O
;	O
if	O
(	O
defend_code	*(int)
>	O
0	int
)	O
{	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
defense_point1	int
)	O
,	O
J	O
(	O
defense_point1	int
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
defense_point2	int
)	O
,	O
J	O
(	O
defense_point2	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_does_attack	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
ti	int
,	O
tj	int
;	O
int	O
attack_code	*(int)
;	O
int	O
kworm	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ti	int
,	O
&	O
tj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ti	int
,	O
tj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"move vertex must be empty"	*(char)
)	O
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
n	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"dragon vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
attack_code	*(int)
=	O
owl_does_attack	(int,int,*(int))->(int)
(	O
POS	O
(	O
ti	int
,	O
tj	int
)	O
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
kworm	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
attack_code	*(int)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_does_defend	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
ti	int
,	O
tj	int
;	O
int	O
defense_code	int
;	O
int	O
kworm	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ti	int
,	O
&	O
tj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ti	int
,	O
tj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"move vertex must be empty"	*(char)
)	O
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
n	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"dragon vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
defense_code	int
=	O
owl_does_defend	(int,int,*(int))->(int)
(	O
POS	O
(	O
ti	int
,	O
tj	int
)	O
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
kworm	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
defense_code	int
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_connection_defends	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	*(int)
,	O
bj	*(int)
;	O
int	O
ti	int
,	O
tj	int
;	O
int	O
defense_code	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ti	int
,	O
&	O
tj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ti	int
,	O
tj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"move vertex must be empty"	*(char)
)	O
;	O
s	*(char)
+=	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
s	*(char)
+=	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
bi	*(int)
,	O
&	O
bj	*(int)
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
||	O
BOARD	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"dragon vertex must not be empty"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
!=	O
BOARD	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"dragon vertices must have the same color"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
defense_code	int
=	O
owl_connection_defends	(int,int,int)->(int)
(	O
POS	O
(	O
ti	int
,	O
tj	int
)	O
,	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
POS	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
defense_code	int
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_defend_both	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	*(int)
,	O
bj	*(int)
;	O
int	O
n	int
;	O
int	O
dcode	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"string vertex must be empty"	*(char)
)	O
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
n	int
,	O
&	O
bi	*(int)
,	O
&	O
bj	*(int)
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"string vertex must not be empty"	*(char)
)	O
;	O
dcode	int
=	O
defend_both	(int,int)->(int)
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
POS	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
dcode	int
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_substantial	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
result	int
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
result	int
=	O
owl_substantial	(int)->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
result	int
)	O
;	O
}	O
static	O
int	O
gtp_analyze_semeai	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
k	int
;	O
int	O
dragona	int
,	O
dragonb	int
;	O
int	O
resulta	*(int)
,	O
resultb	*(int)
,	O
move	*(int)
,	O
result_certain	int
;	O
k	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
k	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
dragona	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
k	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
dragonb	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
owl_analyze_semeai	(int,int,*(int),*(int),*(int),int,*(int))->(void)
(	O
dragona	int
,	O
dragonb	int
,	O
&	O
resulta	*(int)
,	O
&	O
resultb	*(int)
,	O
&	O
move	*(int)
,	O
1	int
,	O
&	O
result_certain	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
resulta	*(int)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_code	(int)->(void)
(	O
resultb	*(int)
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
" %m"	*(char)
,	O
I	O
(	O
move	*(int)
)	O
,	O
J	O
(	O
move	*(int)
)	O
)	O
;	O
if	O
(	O
!	O
result_certain	int
&&	O
report_uncertainty	int
)	O
gtp_printf	(*(char))->(void)
(	O
" uncertain"	*(char)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_analyze_semeai_after_move	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
int	O
move	*(int)
;	O
int	O
k	int
;	O
int	O
dragona	int
,	O
dragonb	int
;	O
int	O
resulta	*(int)
,	O
resultb	*(int)
,	O
semeai_move	*(int)
,	O
result_certain	int
;	O
k	int
=	O
gtp_decode_move	(*(char),*(int),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
move	*(int)
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
k	int
==	O
0	int
||	O
move	*(int)
==	O
NO_MOVE	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color or coordinate"	*(char)
)	O
;	O
if	O
(	O
board	*(char)
[	O
move	*(int)
]	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"move vertex is not empty"	*(char)
)	O
;	O
s	*(char)
+=	O
k	int
;	O
k	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
k	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
dragona	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
dragona	int
]	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"dragon vertex must not be empty"	*(char)
)	O
;	O
s	*(char)
+=	O
k	int
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
dragonb	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
dragonb	int
]	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"dragon vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
owl_analyze_semeai_after_move	(int,int,int,int,*(int),*(int),*(int),int,*(int),int)->(void)
(	O
move	*(int)
,	O
color	int
,	O
dragona	int
,	O
dragonb	int
,	O
&	O
resulta	*(int)
,	O
&	O
resultb	*(int)
,	O
&	O
semeai_move	*(int)
,	O
1	int
,	O
&	O
result_certain	int
,	O
0	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
resulta	*(int)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_code	(int)->(void)
(	O
resultb	*(int)
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
" %m"	*(char)
,	O
I	O
(	O
semeai_move	*(int)
)	O
,	O
J	O
(	O
semeai_move	*(int)
)	O
)	O
;	O
if	O
(	O
!	O
result_certain	int
&&	O
report_uncertainty	int
)	O
gtp_printf	(*(char))->(void)
(	O
" uncertain"	*(char)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_tactical_analyze_semeai	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
k	int
;	O
int	O
dragona	int
,	O
dragonb	int
;	O
int	O
resulta	*(int)
,	O
resultb	*(int)
,	O
move	*(int)
,	O
result_certain	int
;	O
k	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
k	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
dragona	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
k	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
dragonb	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
reading_cache_clear	()->(void)
(	O
)	O
;	O
owl_analyze_semeai	(int,int,*(int),*(int),*(int),int,*(int))->(void)
(	O
dragona	int
,	O
dragonb	int
,	O
&	O
resulta	*(int)
,	O
&	O
resultb	*(int)
,	O
&	O
move	*(int)
,	O
0	int
,	O
&	O
result_certain	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
resulta	*(int)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_code	(int)->(void)
(	O
resultb	*(int)
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
" %m"	*(char)
,	O
I	O
(	O
move	*(int)
)	O
,	O
J	O
(	O
move	*(int)
)	O
)	O
;	O
if	O
(	O
!	O
result_certain	int
&&	O
report_uncertainty	int
)	O
gtp_printf	(*(char))->(void)
(	O
" uncertain"	*(char)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_connect	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	*(int)
,	O
bj	*(int)
;	O
int	O
connect_move	int
=	O
PASS_MOVE	int
;	O
int	O
result	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
n	int
,	O
&	O
bi	*(int)
,	O
&	O
bj	*(int)
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
||	O
BOARD	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
!=	O
BOARD	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertices must have same color"	*(char)
)	O
;	O
result	int
=	O
string_connect	(int,int,*(int))->(int)
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
POS	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
,	O
&	O
connect_move	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
result	int
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
gtp_mprintf	(*(char))->(void)
(	O
" %m"	*(char)
,	O
I	O
(	O
connect_move	int
)	O
,	O
J	O
(	O
connect_move	int
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_disconnect	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	*(int)
,	O
bj	*(int)
;	O
int	O
disconnect_move	int
=	O
PASS_MOVE	int
;	O
int	O
result	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
n	int
,	O
&	O
bi	*(int)
,	O
&	O
bj	*(int)
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
||	O
BOARD	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
!=	O
BOARD	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertices must have same color"	*(char)
)	O
;	O
result	int
=	O
disconnect	(int,int,*(int))->(int)
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
POS	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
,	O
&	O
disconnect_move	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
result	int
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
gtp_mprintf	(*(char))->(void)
(	O
" %m"	*(char)
,	O
I	O
(	O
disconnect_move	int
)	O
,	O
J	O
(	O
disconnect_move	int
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_break_in	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
i	int
,	O
j	int
;	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
break_move	int
=	O
PASS_MOVE	int
;	O
int	O
result	int
;	O
int	O
n	int
;	O
int	O
k	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
goal	*(char)
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
s	*(char)
+=	O
n	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_BOARD	int
*	O
MAX_BOARD	int
;	O
k	int
++	O
)	O
{	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
goal	*(char)
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
=	O
1	int
;	O
s	*(char)
+=	O
n	int
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%*s"	*(char)
)	O
!=	O
EOF	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
result	int
=	O
break_in	(int,array(char),*(int))->(int)
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
goal	*(char)
,	O
&	O
break_move	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
result	int
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
gtp_mprintf	(*(char))->(void)
(	O
" %m"	*(char)
,	O
I	O
(	O
break_move	int
)	O
,	O
J	O
(	O
break_move	int
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_block_off	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
i	int
,	O
j	int
;	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
;	O
int	O
block_move	int
=	O
PASS_MOVE	int
;	O
int	O
result	int
;	O
int	O
n	int
;	O
int	O
k	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
goal	*(char)
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
s	*(char)
+=	O
n	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_BOARD	int
*	O
MAX_BOARD	int
;	O
k	int
++	O
)	O
{	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
goal	*(char)
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
=	O
1	int
;	O
s	*(char)
+=	O
n	int
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%*s"	*(char)
)	O
!=	O
EOF	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
result	int
=	O
block_off	(int,array(char),*(int))->(int)
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
goal	*(char)
,	O
&	O
block_move	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	(int)->(void)
(	O
result	int
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
gtp_mprintf	(*(char))->(void)
(	O
" %m"	*(char)
,	O
I	O
(	O
block_move	int
)	O
,	O
J	O
(	O
block_move	int
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_eval_eye	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
m	int
,	O
n	int
;	O
struct	O
eyevalue	struct(char,char,char,char)
value	*(char)
;	O
int	O
attack_point	*(int)
;	O
int	O
defense_point	*(int)
;	O
int	O
pos	int
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
m	int
,	O
&	O
n	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
black_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
color	int
==	O
BLACK	int
)	O
{	O
pos	int
=	O
black_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
origin	int
;	O
compute_eyes	(int,*(struct(char,char,char,char)),*(int),*(int),array(struct(int,int,int,int,struct(char,char,char,char),char,char,char)),array(struct(float,char,int,array(int),int,array(int))),int)->(void)
(	O
pos	int
,	O
&	O
value	*(char)
,	O
&	O
attack_point	*(int)
,	O
&	O
defense_point	*(int)
,	O
black_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
,	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
white_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
color	int
==	O
WHITE	int
)	O
{	O
pos	int
=	O
white_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
origin	int
;	O
compute_eyes	(int,*(struct(char,char,char,char)),*(int),*(int),array(struct(int,int,int,int,struct(char,char,char,char),char,char,char)),array(struct(float,char,int,array(int),int,array(int))),int)->(void)
(	O
pos	int
,	O
&	O
value	*(char)
,	O
&	O
attack_point	*(int)
,	O
&	O
defense_point	*(int)
,	O
white_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
,	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
,	O
0	int
)	O
;	O
}	O
else	O
return	O
gtp_success	(*(char))->(int)
(	O
"-1"	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"%d %d"	*(char)
,	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
value	*(char)
)	O
,	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
value	*(char)
)	O
)	O
;	O
if	O
(	O
eye_move_urgency	(*(struct(char,char,char,char)))->(int)
(	O
&	O
value	*(char)
)	O
>	O
0	int
)	O
{	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
attack_point	*(int)
)	O
,	O
J	O
(	O
attack_point	*(int)
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
defense_point	*(int)
)	O
,	O
J	O
(	O
defense_point	*(int)
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_dragon_status	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
str	int
=	O
NO_MOVE	O
;	O
int	O
pos	int
;	O
int	O
empty_response	int
=	O
1	int
;	O
if	O
(	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
{	O
str	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
str	int
]	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%*s"	*(char)
)	O
!=	O
EOF	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
(	O
pos	int
==	O
str	int
||	O
(	O
str	int
==	O
NO_MOVE	O
&&	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
&&	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
str	int
==	O
NO_MOVE	O
)	O
gtp_mprintf	(*(char))->(void)
(	O
"%m: "	*(char)
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
)	O
gtp_printf	(*(char))->(void)
(	O
"alive\n"	*(char)
)	O
;	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
gtp_printf	(*(char))->(void)
(	O
"dead\n"	*(char)
)	O
;	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
UNKNOWN	int
)	O
gtp_printf	(*(char))->(void)
(	O
"unknown\n"	*(char)
)	O
;	O
else	O
{	O
assert	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"critical %m %m\n"	*(char)
,	O
I	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
)	O
,	O
J	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
)	O
,	O
I	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
)	O
,	O
J	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
)	O
)	O
;	O
}	O
empty_response	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
empty_response	int
)	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_same_dragon	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	*(int)
,	O
bj	*(int)
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
n	int
,	O
&	O
bi	*(int)
,	O
&	O
bj	*(int)
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
||	O
BOARD	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
dragon	int
[	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
]	O
.	O
id	int
==	O
dragon	int
[	O
POS	O
(	O
bi	*(int)
,	O
bj	*(int)
)	O
]	O
.	O
id	int
)	O
;	O
}	O
static	O
int	O
gtp_unconditional_status	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
enum	O
dragon_status	(int)->(enum)
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_WORMS	int
)	O
;	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
.	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
UNKNOWN	int
)	O
return	O
gtp_success	(*(char))->(int)
(	O
"undecided"	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%s"	*(char)
,	O
status_to_string	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
}	O
static	O
int	O
gtp_combination_attack	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
color	int
;	O
int	O
attack_point	*(int)
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_ALL	int
)	O
;	O
if	O
(	O
!	O
atari_atari	(int,*(int),array(char),int)->(int)
(	O
color	int
,	O
&	O
attack_point	*(int)
,	O
NULL	O
,	O
verbose	int
)	O
)	O
attack_point	*(int)
=	O
NO_MOVE	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
attack_point	*(int)
)	O
,	O
J	O
(	O
attack_point	*(int)
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_combination_defend	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
color	int
;	O
signed	O
char	O
defense_points	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
int	O
first	int
=	O
1	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_ALL	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
defense_points	array(int)
,	O
0	int
,	O
sizeof	O
(	O
defense_points	array(int)
)	O
)	O
;	O
if	O
(	O
!	O
atari_atari	(int,*(int),array(char),int)->(int)
(	O
color	int
,	O
NULL	O
,	O
defense_points	array(int)
,	O
verbose	int
)	O
)	O
return	O
gtp_success	(*(char))->(int)
(	O
"PASS"	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
defense_points	array(int)
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
!	O
first	int
)	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
else	O
first	int
=	O
0	int
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_aa_confirm_safety	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
color	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
n	int
;	O
int	O
minsize	int
=	O
0	int
;	O
int	O
result	int
;	O
int	O
defense_point	*(int)
=	O
NO_MOVE	O
;	O
signed	O
char	O
saved_dragons	array(char)
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
saved_worms	array(char)
[	O
BOARDMAX	O
]	O
;	O
n	int
=	O
gtp_decode_move	(*(char),*(int),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
||	O
POS	O
(	O
i	int
,	O
j	int
)	O
==	O
NO_MOVE	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color or coordinate"	*(char)
)	O
;	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
+	O
n	int
,	O
"%d"	*(char)
,	O
&	O
minsize	int
)	O
;	O
genmove	(int,*(float),*(int))->(int)
(	O
color	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
get_saved_dragons	(int,array(char))->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
saved_dragons	array(char)
)	O
;	O
get_saved_worms	(int,array(char))->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
saved_worms	array(char)
)	O
;	O
result	int
=	O
atari_atari_confirm_safety	(int,int,*(int),int,array(char),array(char))->(int)
(	O
color	int
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
defense_point	*(int)
,	O
minsize	int
,	O
saved_dragons	array(char)
,	O
saved_worms	array(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"%d"	*(char)
,	O
result	int
)	O
;	O
if	O
(	O
result	int
==	O
0	int
)	O
gtp_mprintf	(*(char))->(void)
(	O
" %m"	*(char)
,	O
I	O
(	O
defense_point	*(int)
)	O
,	O
J	O
(	O
defense_point	*(int)
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_genmove_black	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
move	*(int)
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"genmove cannot be called when stackp > 0"	*(char)
)	O
;	O
move	*(int)
=	O
genmove	(int,*(float),*(int))->(int)
(	O
BLACK	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
gnugo_play_move	(int,int)->(void)
(	O
move	*(int)
,	O
BLACK	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
move	*(int)
)	O
,	O
J	O
(	O
move	*(int)
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_genmove_white	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
move	*(int)
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"genmove cannot be called when stackp > 0"	*(char)
)	O
;	O
move	*(int)
=	O
genmove	(int,*(float),*(int))->(int)
(	O
WHITE	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
gnugo_play_move	(int,int)->(void)
(	O
move	*(int)
,	O
WHITE	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
move	*(int)
)	O
,	O
J	O
(	O
move	*(int)
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_genmove	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
move	*(int)
;	O
int	O
resign	*(int)
;	O
int	O
color	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"genmove cannot be called when stackp > 0"	*(char)
)	O
;	O
adjust_level_offset	(int)->(void)
(	O
color	int
)	O
;	O
move	*(int)
=	O
genmove	(int,*(float),*(int))->(int)
(	O
color	int
,	O
NULL	O
,	O
&	O
resign	*(int)
)	O
;	O
if	O
(	O
resign	*(int)
)	O
return	O
gtp_success	(*(char))->(int)
(	O
"resign"	*(char)
)	O
;	O
gnugo_play_move	(int,int)->(void)
(	O
move	*(int)
,	O
color	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
move	*(int)
)	O
,	O
J	O
(	O
move	*(int)
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_reg_genmove	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
move	*(int)
;	O
int	O
color	int
;	O
int	O
n	int
;	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	()->(int)
(	O
)	O
;	O
n	int
=	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"genmove cannot be called when stackp > 0"	*(char)
)	O
;	O
set_random_seed	(int)->(void)
(	O
0	int
)	O
;	O
move	*(int)
=	O
genmove_conservative	(int,*(float))->(int)
(	O
color	int
,	O
NULL	O
)	O
;	O
set_random_seed	(int)->(void)
(	O
saved_random_seed	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
move	*(int)
)	O
,	O
J	O
(	O
move	*(int)
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_gg_genmove	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
move	*(int)
;	O
int	O
color	int
;	O
int	O
n	int
;	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	()->(int)
(	O
)	O
;	O
unsigned	O
int	O
seed	int
;	O
n	int
=	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"genmove cannot be called when stackp > 0"	*(char)
)	O
;	O
seed	int
=	O
0	int
;	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
+	O
n	int
,	O
"%u"	*(char)
,	O
&	O
seed	int
)	O
;	O
set_random_seed	(int)->(void)
(	O
seed	int
)	O
;	O
move	*(int)
=	O
genmove_conservative	(int,*(float))->(int)
(	O
color	int
,	O
NULL	O
)	O
;	O
set_random_seed	(int)->(void)
(	O
saved_random_seed	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
move	*(int)
)	O
,	O
J	O
(	O
move	*(int)
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_restricted_genmove	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
move	*(int)
;	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
int	O
n	int
;	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	()->(int)
(	O
)	O
;	O
int	O
allowed_moves	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
number_allowed_moves	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
allowed_moves	array(int)
,	O
0	int
,	O
sizeof	O
(	O
allowed_moves	array(int)
)	O
)	O
;	O
n	int
=	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
s	*(char)
+=	O
n	int
;	O
while	O
(	O
1	int
)	O
{	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
allowed_moves	array(int)
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
=	O
1	int
;	O
number_allowed_moves	int
++	O
;	O
s	*(char)
+=	O
n	int
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%*s"	*(char)
)	O
!=	O
EOF	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
number_allowed_moves	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"no allowed vertex"	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"genmove cannot be called when stackp > 0"	*(char)
)	O
;	O
set_random_seed	(int)->(void)
(	O
0	int
)	O
;	O
move	*(int)
=	O
genmove_restricted	(int,array(int))->(int)
(	O
color	int
,	O
allowed_moves	array(int)
)	O
;	O
set_random_seed	(int)->(void)
(	O
saved_random_seed	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
move	*(int)
)	O
,	O
J	O
(	O
move	*(int)
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_kgs_genmove_cleanup	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
move	*(int)
;	O
int	O
color	int
;	O
int	O
n	int
;	O
int	O
save_capture_all_dead	int
=	O
capture_all_dead	int
;	O
n	int
=	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"kgs-genmove_cleanup cannot be called when stackp > 0"	*(char)
)	O
;	O
capture_all_dead	int
=	O
1	int
;	O
adjust_level_offset	(int)->(void)
(	O
color	int
)	O
;	O
move	*(int)
=	O
genmove	(int,*(float),*(int))->(int)
(	O
color	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
capture_all_dead	int
=	O
save_capture_all_dead	int
;	O
gnugo_play_move	(int,int)->(void)
(	O
move	*(int)
,	O
color	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
move	*(int)
)	O
,	O
J	O
(	O
move	*(int)
)	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_move_reasons	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be occupied"	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
list_move_reasons	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(int)
(	O
gtp_output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
==	O
0	int
)	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_all_move_values	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
print_all_move_values	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
gtp_output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_top_moves	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
k	int
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
;	O
k	int
++	O
)	O
if	O
(	O
best_move_values	array(float)
[	O
k	int
]	O
>	O
0.0	int
)	O
{	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
best_moves	array(int)
[	O
k	int
]	O
)	O
,	O
J	O
(	O
best_moves	array(int)
[	O
k	int
]	O
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
" %.2f "	*(char)
,	O
best_move_values	array(float)
[	O
k	int
]	O
)	O
;	O
}	O
gtp_printf	(*(char))->(void)
(	O
"\n\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_top_moves_white	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
k	int
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
genmove	(int,*(float),*(int))->(int)
(	O
WHITE	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
;	O
k	int
++	O
)	O
if	O
(	O
best_move_values	array(float)
[	O
k	int
]	O
>	O
0.0	int
)	O
{	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
best_moves	array(int)
[	O
k	int
]	O
)	O
,	O
J	O
(	O
best_moves	array(int)
[	O
k	int
]	O
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
" %.2f "	*(char)
,	O
best_move_values	array(float)
[	O
k	int
]	O
)	O
;	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_top_moves_black	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
k	int
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
genmove	(int,*(float),*(int))->(int)
(	O
BLACK	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
;	O
k	int
++	O
)	O
if	O
(	O
best_move_values	array(float)
[	O
k	int
]	O
>	O
0.0	int
)	O
{	O
gtp_print_vertex	(int,int)->(void)
(	O
I	O
(	O
best_moves	array(int)
[	O
k	int
]	O
)	O
,	O
J	O
(	O
best_moves	array(int)
[	O
k	int
]	O
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
" %.2f "	*(char)
,	O
best_move_values	array(float)
[	O
k	int
]	O
)	O
;	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_set_level	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
new_level	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d"	*(char)
,	O
&	O
new_level	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"level not an integer"	*(char)
)	O
;	O
set_level	(int)->(void)
(	O
new_level	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_undo	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
||	O
!	O
undo_move	(int)->(int)
(	O
1	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"cannot undo"	*(char)
)	O
;	O
reset_engine	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_gg_undo	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
number_moves	int
=	O
1	int
;	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d"	*(char)
,	O
&	O
number_moves	int
)	O
;	O
if	O
(	O
number_moves	int
<	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"can't undo a negative number of moves"	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
||	O
!	O
undo_move	(int)->(int)
(	O
number_moves	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"cannot undo"	*(char)
)	O
;	O
reset_engine	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_time_settings	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
main_time	int
,	O
byoyomi_time	int
,	O
byoyomi_stones	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d %d %d"	*(char)
,	O
&	O
main_time	int
,	O
&	O
byoyomi_time	int
,	O
&	O
byoyomi_stones	int
)	O
<	O
3	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"not three integers"	*(char)
)	O
;	O
clock_settings	(int,int,int)->(void)
(	O
main_time	int
,	O
byoyomi_time	int
,	O
byoyomi_stones	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_time_left	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
color	int
;	O
int	O
time	(*(long))->(long)
;	O
int	O
stones	*(int)
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
+	O
n	int
,	O
"%d %d"	*(char)
,	O
&	O
time	(*(long))->(long)
,	O
&	O
stones	*(int)
)	O
<	O
2	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"time and stones not two integers"	*(char)
)	O
;	O
update_time_left	(int,int,int)->(void)
(	O
color	int
,	O
time	(*(long))->(long)
,	O
stones	*(int)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
float	O
final_score	float
;	O
static	O
enum	O
dragon_status	(int)->(enum)
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
MAX_BOARD	int
]	O
[	O
MAX_BOARD	int
]	O
;	O
static	O
enum	O
dragon_status	(int)->(enum)
status_numbers	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
6	int
]	O
=	O
{	O
ALIVE	int
,	O
DEAD	int
,	O
ALIVE_IN_SEKI	int
,	O
WHITE_TERRITORY	int
,	O
BLACK_TERRITORY	int
,	O
DAME	int
}	O
;	O
static	O
const	O
char	O
*	O
status_names	array(*(char))
[	O
6	int
]	O
=	O
{	O
"alive"	*(char)
,	O
"dead"	*(char)
,	O
"seki"	*(char)
,	O
"white_territory"	*(char)
,	O
"black_territory"	*(char)
,	O
"dame"	*(char)
}	O
;	O
static	O
void	O
finish_and_score_game	(int)->(void)
(	O
int	O
seed	int
)	O
{	O
int	O
move	*(int)
;	O
int	O
i	int
,	O
j	int
;	O
int	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
int	O
pass	int
=	O
0	int
;	O
int	O
moves	array(int)
=	O
0	int
;	O
int	O
saved_board	array(array(int))
[	O
MAX_BOARD	int
]	O
[	O
MAX_BOARD	int
]	O
;	O
struct	O
board_state	struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int)
saved_pos	struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int)
;	O
static	O
int	O
current_board	array(array(int))
[	O
MAX_BOARD	int
]	O
[	O
MAX_BOARD	int
]	O
;	O
static	O
int	O
current_seed	int
=	O
-	O
1	int
;	O
int	O
cached_board	int
=	O
1	int
;	O
if	O
(	O
current_seed	int
!=	O
seed	int
)	O
{	O
current_seed	int
=	O
seed	int
;	O
cached_board	int
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
!=	O
current_board	array(array(int))
[	O
i	int
]	O
[	O
j	int
]	O
)	O
{	O
current_board	array(array(int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
;	O
cached_board	int
=	O
0	int
;	O
}	O
if	O
(	O
cached_board	int
)	O
return	O
;	O
doing_scoring	int
=	O
1	int
;	O
store_board	(*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int)))->(void)
(	O
&	O
saved_pos	struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int)
)	O
;	O
if	O
(	O
get_last_player	()->(int)
(	O
)	O
==	O
EMPTY	int
)	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
BLACK	int
;	O
else	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
OTHER_COLOR	O
(	O
get_last_player	()->(int)
(	O
)	O
)	O
;	O
do	O
{	O
move	*(int)
=	O
genmove_conservative	(int,*(float))->(int)
(	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
NULL	O
)	O
;	O
gnugo_play_move	(int,int)->(void)
(	O
move	*(int)
,	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
;	O
if	O
(	O
move	*(int)
!=	O
PASS_MOVE	int
)	O
{	O
pass	int
=	O
0	int
;	O
moves	array(int)
++	O
;	O
}	O
else	O
pass	int
++	O
;	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
OTHER_COLOR	O
(	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
)	O
;	O
}	O
while	O
(	O
pass	int
<	O
2	int
&&	O
moves	array(int)
<	O
board_size	int
*	O
board_size	int
)	O
;	O
final_score	float
=	O
aftermath_compute_score	(int,*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(float)
(	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
NULL	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
aftermath_final_status	(int,int)->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
saved_board	array(array(int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
;	O
}	O
restore_board	(*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int)))->(void)
(	O
&	O
saved_pos	struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int)
)	O
;	O
doing_scoring	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
saved_board	array(array(int))
[	O
i	int
]	O
[	O
j	int
]	O
)	O
continue	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
==	O
ALIVE	int
||	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
==	O
ALIVE_IN_SEKI	int
)	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
DAME	int
;	O
else	O
if	O
(	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
==	O
DEAD	int
)	O
{	O
if	O
(	O
saved_board	array(array(int))
[	O
i	int
]	O
[	O
j	int
]	O
==	O
BLACK	int
)	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
WHITE_TERRITORY	int
;	O
else	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
BLACK_TERRITORY	int
;	O
}	O
}	O
else	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
BLACK	int
)	O
{	O
if	O
(	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
==	O
WHITE_TERRITORY	int
)	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
DEAD	int
;	O
else	O
if	O
(	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
==	O
DAME	int
)	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
ALIVE_IN_SEKI	int
;	O
else	O
if	O
(	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
==	O
BLACK_TERRITORY	int
)	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
ALIVE	int
;	O
else	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
DEAD	int
;	O
}	O
else	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
WHITE	int
)	O
{	O
if	O
(	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
==	O
BLACK_TERRITORY	int
)	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
DEAD	int
;	O
else	O
if	O
(	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
==	O
DAME	int
)	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
ALIVE_IN_SEKI	int
;	O
else	O
if	O
(	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
==	O
WHITE_TERRITORY	int
)	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
ALIVE	int
;	O
else	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
=	O
DEAD	int
;	O
}	O
}	O
}	O
static	O
int	O
gtp_final_score	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	()->(int)
(	O
)	O
;	O
int	O
seed	int
;	O
seed	int
=	O
0	int
;	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d"	*(char)
,	O
&	O
seed	int
)	O
;	O
set_random_seed	(int)->(void)
(	O
seed	int
)	O
;	O
finish_and_score_game	(int)->(void)
(	O
seed	int
)	O
;	O
set_random_seed	(int)->(void)
(	O
saved_random_seed	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
final_score	float
>	O
0.0	int
)	O
gtp_printf	(*(char))->(void)
(	O
"W+%3.1f"	*(char)
,	O
final_score	float
)	O
;	O
else	O
if	O
(	O
final_score	float
<	O
0.0	int
)	O
gtp_printf	(*(char))->(void)
(	O
"B+%3.1f"	*(char)
,	O
-	O
final_score	float
)	O
;	O
else	O
gtp_printf	(*(char))->(void)
(	O
"0"	*(char)
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_final_status	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
seed	int
;	O
int	O
n	int
;	O
int	O
ai	int
,	O
aj	int
;	O
int	O
k	int
;	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	()->(int)
(	O
)	O
;	O
const	O
char	O
*	O
result	int
=	O
NULL	O
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
seed	int
=	O
0	int
;	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
+	O
n	int
,	O
"%d"	*(char)
,	O
&	O
seed	int
)	O
;	O
set_random_seed	(int)->(void)
(	O
seed	int
)	O
;	O
finish_and_score_game	(int)->(void)
(	O
seed	int
)	O
;	O
set_random_seed	(int)->(void)
(	O
saved_random_seed	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
6	int
;	O
k	int
++	O
)	O
if	O
(	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
ai	int
]	O
[	O
aj	int
]	O
==	O
status_numbers	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
k	int
]	O
)	O
{	O
result	int
=	O
status_names	array(*(char))
[	O
k	int
]	O
;	O
break	O
;	O
}	O
assert	O
(	O
result	int
!=	O
NULL	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
result	int
)	O
;	O
}	O
static	O
int	O
gtp_final_status_list	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
seed	int
;	O
int	O
n	int
;	O
int	O
i	int
,	O
j	int
;	O
enum	O
dragon_status	(int)->(enum)
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
UNKNOWN	int
;	O
int	O
k	int
;	O
char	O
status_string	array(char)
[	O
GTP_BUFSIZE	int
]	O
;	O
int	O
first	int
;	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	()->(int)
(	O
)	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%s %n"	*(char)
,	O
status_string	array(char)
,	O
&	O
n	int
)	O
!=	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"missing status"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
6	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
status_string	array(char)
,	O
status_names	array(*(char))
[	O
k	int
]	O
)	O
==	O
0	int
)	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
status_numbers	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
k	int
]	O
;	O
}	O
if	O
(	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
UNKNOWN	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid status"	*(char)
)	O
;	O
seed	int
=	O
0	int
;	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
+	O
n	int
,	O
"%d"	*(char)
,	O
&	O
seed	int
)	O
;	O
set_random_seed	(int)->(void)
(	O
seed	int
)	O
;	O
finish_and_score_game	(int)->(void)
(	O
seed	int
)	O
;	O
set_random_seed	(int)->(void)
(	O
saved_random_seed	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
first	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
final_status	array(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
[	O
j	int
]	O
!=	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
continue	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
!	O
first	int
)	O
gtp_printf	(*(char))->(void)
(	O
" "	*(char)
)	O
;	O
else	O
first	int
=	O
0	int
;	O
gtp_print_vertex	(int,int)->(void)
(	O
i	int
,	O
j	int
)	O
;	O
}	O
else	O
{	O
int	O
num_stones	int
;	O
int	O
stones	*(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
if	O
(	O
find_origin	(int)->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
!=	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
first	int
)	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
else	O
first	int
=	O
0	int
;	O
num_stones	int
=	O
findstones	(int,int,*(int))->(int)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
board_size	int
*	O
board_size	int
,	O
stones	*(int)
)	O
;	O
gtp_print_vertices2	(int,*(int))->(void)
(	O
num_stones	int
,	O
stones	*(int)
)	O
;	O
}	O
}	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_estimate_score	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
float	O
score	float
;	O
float	O
upper_bound	float
,	O
lower_bound	float
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
score	float
=	O
gnugo_estimate_score	(*(float),*(float))->(float)
(	O
&	O
upper_bound	float
,	O
&	O
lower_bound	float
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
score	float
>=	O
0.0	int
)	O
gtp_printf	(*(char))->(void)
(	O
"W+%3.1f (upper bound: %3.1f, lower: %3.1f)"	*(char)
,	O
score	float
,	O
upper_bound	float
,	O
lower_bound	float
)	O
;	O
else	O
if	O
(	O
score	float
<	O
0.0	int
)	O
gtp_printf	(*(char))->(void)
(	O
"B+%3.1f (upper bound: %3.1f, lower: %3.1f)"	*(char)
,	O
-	O
score	float
,	O
upper_bound	float
,	O
lower_bound	float
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_experimental_score	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
float	O
upper_bound	float
,	O
lower_bound	float
,	O
score	float
;	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
||	O
(	O
color	int
!=	O
BLACK	int
&&	O
color	int
!=	O
WHITE	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
genmove_conservative	(int,*(float))->(int)
(	O
color	int
,	O
NULL	O
)	O
;	O
gnugo_estimate_score	(*(float),*(float))->(float)
(	O
&	O
upper_bound	float
,	O
&	O
lower_bound	float
)	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_SCORING	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"upper = %3.1f, lower = %3.1f, best = %3.1f\n"	*(char)
,	O
upper_bound	float
,	O
lower_bound	float
,	O
best_move_values	array(float)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
score	float
=	O
lower_bound	float
+	O
best_move_values	array(float)
[	O
0	int
]	O
;	O
else	O
score	float
=	O
upper_bound	float
-	O
best_move_values	array(float)
[	O
0	int
]	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%3.1f"	*(char)
,	O
score	float
)	O
;	O
}	O
static	O
int	O
gtp_reset_life_node_counter	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_get_life_node_counter	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"0"	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_reset_owl_node_counter	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
reset_owl_node_counter	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_get_owl_node_counter	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
nodes	int
=	O
get_owl_node_counter	()->(int)
(	O
)	O
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
nodes	int
)	O
;	O
}	O
static	O
int	O
gtp_reset_reading_node_counter	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
reset_reading_node_counter	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_get_reading_node_counter	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
nodes	int
)	O
;	O
}	O
static	O
int	O
gtp_reset_trymove_counter	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
reset_trymove_counter	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_get_trymove_counter	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
nodes	int
=	O
get_trymove_counter	()->(int)
(	O
)	O
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
nodes	int
)	O
;	O
}	O
static	O
int	O
gtp_reset_connection_node_counter	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
reset_connection_node_counter	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_get_connection_node_counter	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
nodes	int
=	O
get_connection_node_counter	()->(int)
(	O
)	O
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
nodes	int
)	O
;	O
}	O
static	O
int	O
gtp_test_eyeshape	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
n	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
eye_vertices	*(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
eyesize	int
=	O
0	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
while	O
(	O
n	int
>	O
0	int
)	O
{	O
eye_vertices	*(int)
[	O
eyesize	int
]	O
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
eyesize	int
++	O
;	O
s	*(char)
+=	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
}	O
if	O
(	O
eyesize	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
test_eyeshape	(int,*(int))->(void)
(	O
eyesize	int
,	O
eye_vertices	*(int)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_analyze_eyegraph	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
struct	O
eyevalue	struct(char,char,char,char)
value	*(char)
;	O
char	O
analyzed_eyegraph	*(char)
[	O
1024	int
]	O
;	O
int	O
result	int
=	O
analyze_eyegraph	(*(char),*(struct),*(char))->(int)
(	O
s	*(char)
,	O
&	O
value	*(char)
,	O
analyzed_eyegraph	*(char)
)	O
;	O
if	O
(	O
result	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"failed to analyze"	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%s\n%s"	*(char)
,	O
eyevalue_to_string	(*(struct(char,char,char,char)))->(*(char))
(	O
&	O
value	*(char)
)	O
,	O
analyzed_eyegraph	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_cputime	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%.3f"	*(char)
,	O
gg_cputime	()->(double)
(	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_showboard	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
simple_showboard	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
gtp_output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
static	O
int	O
gtp_dump_stack	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
has_prefix	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
s	*(char)
,	O
const	O
char	O
*	O
prefix	*(char)
)	O
{	O
return	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
prefix	*(char)
,	O
strlen	(*(char))->(long)
(	O
prefix	*(char)
)	O
)	O
==	O
0	int
;	O
}	O
static	O
int	O
print_influence_data	(*(struct),*(char))->(int)
(	O
struct	O
influence_data	O
*	O
q	*(struct)
,	O
char	O
*	O
what_data	*(char)
)	O
{	O
float	O
white_influence	array(float)
[	O
BOARDMAX	O
]	O
;	O
float	O
black_influence	array(float)
[	O
BOARDMAX	O
]	O
;	O
float	O
white_strength	array(float)
[	O
BOARDMAX	O
]	O
;	O
float	O
black_strength	array(float)
[	O
BOARDMAX	O
]	O
;	O
float	O
white_attenuation	array(float)
[	O
BOARDMAX	O
]	O
;	O
float	O
black_attenuation	array(float)
[	O
BOARDMAX	O
]	O
;	O
float	O
white_permeability	array(float)
[	O
BOARDMAX	O
]	O
;	O
float	O
black_permeability	array(float)
[	O
BOARDMAX	O
]	O
;	O
float	O
territory_value	array(float)
[	O
BOARDMAX	O
]	O
;	O
int	O
influence_regions	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
non_territory	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
m	int
,	O
n	int
;	O
float	O
*	O
float_pointer	*(float)
=	O
NULL	O
;	O
int	O
*	O
int_pointer	*(int)
=	O
NULL	O
;	O
while	O
(	O
*	O
what_data	*(char)
==	O
' '	O
)	O
what_data	*(char)
++	O
;	O
get_influence	(*(struct),array(float),array(float),array(float),array(float),array(float),array(float),array(float),array(float),array(float),array(int),array(int))->(void)
(	O
q	*(struct)
,	O
white_influence	array(float)
,	O
black_influence	array(float)
,	O
white_strength	array(float)
,	O
black_strength	array(float)
,	O
white_attenuation	array(float)
,	O
black_attenuation	array(float)
,	O
white_permeability	array(float)
,	O
black_permeability	array(float)
,	O
territory_value	array(float)
,	O
influence_regions	array(int)
,	O
non_territory	array(int)
)	O
;	O
if	O
(	O
has_prefix	(*(char),*(char))->(int)
(	O
what_data	*(char)
,	O
"white_influence"	*(char)
)	O
)	O
float_pointer	*(float)
=	O
white_influence	array(float)
;	O
else	O
if	O
(	O
has_prefix	(*(char),*(char))->(int)
(	O
what_data	*(char)
,	O
"black_influence"	*(char)
)	O
)	O
float_pointer	*(float)
=	O
black_influence	array(float)
;	O
else	O
if	O
(	O
has_prefix	(*(char),*(char))->(int)
(	O
what_data	*(char)
,	O
"white_strength"	*(char)
)	O
)	O
float_pointer	*(float)
=	O
white_strength	array(float)
;	O
else	O
if	O
(	O
has_prefix	(*(char),*(char))->(int)
(	O
what_data	*(char)
,	O
"black_strength"	*(char)
)	O
)	O
float_pointer	*(float)
=	O
black_strength	array(float)
;	O
else	O
if	O
(	O
has_prefix	(*(char),*(char))->(int)
(	O
what_data	*(char)
,	O
"white_attenuation"	*(char)
)	O
)	O
float_pointer	*(float)
=	O
white_attenuation	array(float)
;	O
else	O
if	O
(	O
has_prefix	(*(char),*(char))->(int)
(	O
what_data	*(char)
,	O
"black_attenuation"	*(char)
)	O
)	O
float_pointer	*(float)
=	O
black_attenuation	array(float)
;	O
else	O
if	O
(	O
has_prefix	(*(char),*(char))->(int)
(	O
what_data	*(char)
,	O
"white_permeability"	*(char)
)	O
)	O
float_pointer	*(float)
=	O
white_permeability	array(float)
;	O
else	O
if	O
(	O
has_prefix	(*(char),*(char))->(int)
(	O
what_data	*(char)
,	O
"black_permeability"	*(char)
)	O
)	O
float_pointer	*(float)
=	O
black_permeability	array(float)
;	O
else	O
if	O
(	O
has_prefix	(*(char),*(char))->(int)
(	O
what_data	*(char)
,	O
"territory_value"	*(char)
)	O
)	O
float_pointer	*(float)
=	O
territory_value	array(float)
;	O
else	O
if	O
(	O
has_prefix	(*(char),*(char))->(int)
(	O
what_data	*(char)
,	O
"influence_regions"	*(char)
)	O
)	O
int_pointer	*(int)
=	O
influence_regions	array(int)
;	O
else	O
if	O
(	O
has_prefix	(*(char),*(char))->(int)
(	O
what_data	*(char)
,	O
"non_territory"	*(char)
)	O
)	O
int_pointer	*(int)
=	O
non_territory	array(int)
;	O
else	O
return	O
gtp_failure	(*(char))->(int)
(	O
"unknown influence data"	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
{	O
if	O
(	O
float_pointer	*(float)
)	O
gtp_printf	(*(char))->(void)
(	O
"%6.2f "	*(char)
,	O
float_pointer	*(float)
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
;	O
else	O
gtp_printf	(*(char))->(void)
(	O
"%2d "	*(char)
,	O
int_pointer	*(int)
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
;	O
}	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
}	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_initial_influence	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
color	int
;	O
struct	O
influence_data	O
*	O
q	*(struct)
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color"	*(char)
)	O
;	O
q	*(struct)
=	O
INITIAL_INFLUENCE	O
(	O
color	int
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_ALL	int
)	O
;	O
return	O
print_influence_data	(*(struct),*(char))->(int)
(	O
q	*(struct)
,	O
s	*(char)
+	O
n	int
)	O
;	O
}	O
static	O
int	O
gtp_move_influence	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
color	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_move	(*(char),*(int),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid move"	*(char)
)	O
;	O
prepare_move_influence_debugging	(int,int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
;	O
return	O
print_influence_data	(*(struct),*(char))->(int)
(	O
&	O
move_influence	struct
,	O
s	*(char)
+	O
n	int
)	O
;	O
}	O
static	O
int	O
gtp_move_probabilities	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
float	O
probabilities	array(float)
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
int	O
any_moves_printed	int
=	O
0	int
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
compute_move_probabilities	(array(float))->(void)
(	O
probabilities	array(float)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
probabilities	array(float)
[	O
pos	int
]	O
!=	O
0.0	int
)	O
{	O
gtp_mprintf	(*(char))->(void)
(	O
"%m "	*(char)
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"%.4f\n"	*(char)
,	O
probabilities	array(float)
[	O
pos	int
]	O
)	O
;	O
any_moves_printed	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
any_moves_printed	int
)	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_move_uncertainty	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
float	O
probabilities	array(float)
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
double	O
uncertainty	double
=	O
0.0	int
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
compute_move_probabilities	(array(float))->(void)
(	O
probabilities	array(float)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
probabilities	array(float)
[	O
pos	int
]	O
>	O
0.0	int
)	O
{	O
uncertainty	double
+=	O
-	O
1	int
*	O
(	O
(	O
double	O
)	O
probabilities	array(float)
[	O
pos	int
]	O
)	O
*	O
log	(double)->(double)
(	O
(	O
double	O
)	O
probabilities	array(float)
[	O
pos	int
]	O
)	O
/	O
log	(double)->(double)
(	O
2.0	int
)	O
;	O
}	O
}	O
gtp_printf	(*(char))->(void)
(	O
"%.4f\n\n"	*(char)
,	O
uncertainty	double
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_followup_influence	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
color	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_move	(*(char),*(int),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid move"	*(char)
)	O
;	O
prepare_move_influence_debugging	(int,int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
;	O
return	O
print_influence_data	(*(struct),*(char))->(int)
(	O
&	O
followup_influence	struct
,	O
s	*(char)
+	O
n	int
)	O
;	O
}	O
static	O
int	O
gtp_worm_data	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
int	O
m	int
,	O
n	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%*c"	*(char)
)	O
>=	O
0	int
&&	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color or coordinate"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_WORMS	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
i	int
==	O
-	O
1	int
||	O
(	O
m	int
==	O
i	int
&&	O
n	int
==	O
j	int
)	O
)	O
{	O
struct	O
worm_data	struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int))
*	O
w	int
=	O
&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
;	O
gtp_print_vertex	(int,int)->(void)
(	O
m	int
,	O
n	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
":\n"	*(char)
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"origin               %m\n"	*(char)
,	O
I	O
(	O
w	int
->	O
origin	int
)	O
,	O
J	O
(	O
w	int
->	O
origin	int
)	O
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"color                %C\n"	*(char)
,	O
w	int
->	O
color	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"size                 %d\n"	*(char)
,	O
w	int
->	O
size	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"effective_size       %.2f\n"	*(char)
,	O
w	int
->	O
effective_size	float
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"liberties            %d\n"	*(char)
,	O
w	int
->	O
liberties	*(int)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"liberties2           %d\n"	*(char)
,	O
w	int
->	O
liberties2	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"liberties3           %d\n"	*(char)
,	O
w	int
->	O
liberties3	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"liberties4           %d\n"	*(char)
,	O
w	int
->	O
liberties4	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"attack_code          %d\n"	*(char)
,	O
w	int
->	O
attack_codes	array(int)
[	O
0	int
]	O
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"attack_point         %m\n"	*(char)
,	O
I	O
(	O
w	int
->	O
attack_points	array(int)
[	O
0	int
]	O
)	O
,	O
J	O
(	O
w	int
->	O
attack_points	array(int)
[	O
0	int
]	O
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"defense_code         %d\n"	*(char)
,	O
w	int
->	O
defense_codes	array(int)
[	O
0	int
]	O
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"defense_point        %m\n"	*(char)
,	O
I	O
(	O
w	int
->	O
defense_points	array(int)
[	O
0	int
]	O
)	O
,	O
J	O
(	O
w	int
->	O
defense_points	array(int)
[	O
0	int
]	O
)	O
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"lunch                %m\n"	*(char)
,	O
I	O
(	O
w	int
->	O
lunch	int
)	O
,	O
J	O
(	O
w	int
->	O
lunch	int
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"cutstone             %d\n"	*(char)
,	O
w	int
->	O
cutstone	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"cutstone2            %d\n"	*(char)
,	O
w	int
->	O
cutstone2	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"genus                %d\n"	*(char)
,	O
w	int
->	O
genus	*(struct)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"inessential          %d\n"	*(char)
,	O
w	int
->	O
inessential	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"invincible           %d\n"	*(char)
,	O
w	int
->	O
invincible	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"unconditional_status %s\n"	*(char)
,	O
status_to_string	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
w	int
->	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
}	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_worm_stones	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
int	O
color	int
=	O
EMPTY	int
;	O
int	O
m	int
,	O
n	int
;	O
int	O
u	int
,	O
v	int
;	O
int	O
board_empty	int
=	O
1	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%*c"	*(char)
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
&&	O
!	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
}	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"worm_stones called on an empty vertex"	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
u	int
=	O
0	int
;	O
u	int
<	O
board_size	int
;	O
u	int
++	O
)	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
board_size	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
BOARD	O
(	O
u	int
,	O
v	int
)	O
==	O
EMPTY	int
||	O
(	O
color	int
!=	O
EMPTY	int
&&	O
BOARD	O
(	O
u	int
,	O
v	int
)	O
!=	O
color	int
)	O
)	O
continue	O
;	O
board_empty	int
=	O
0	int
;	O
if	O
(	O
find_origin	(int)->(int)
(	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
!=	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
continue	O
;	O
if	O
(	O
ON_BOARD2	O
(	O
i	int
,	O
j	int
)	O
&&	O
!	O
same_string	(int,int)->(int)
(	O
POS	O
(	O
u	int
,	O
v	int
)	O
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
)	O
continue	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
m	int
,	O
n	int
)	O
!=	O
EMPTY	int
&&	O
same_string	(int,int)->(int)
(	O
POS	O
(	O
m	int
,	O
n	int
)	O
,	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
)	O
gtp_mprintf	(*(char))->(void)
(	O
"%m "	*(char)
,	O
m	int
,	O
n	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
board_empty	int
)	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_worm_cutstone	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"vertex must not be empty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_WORMS	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
" %d"	*(char)
,	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
.	O
cutstone	int
)	O
;	O
}	O
static	O
int	O
gtp_dragon_data	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
int	O
m	int
,	O
n	int
;	O
int	O
newline_needed	int
=	O
0	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%*c"	*(char)
)	O
>=	O
0	int
&&	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"dragon data unavailable when stackp > 0"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
FULL_EXAMINE_DRAGONS	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
ON_BOARD2	O
(	O
i	int
,	O
j	int
)	O
&&	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
gtp_mprintf	(*(char))->(void)
(	O
"%m empty\n"	*(char)
,	O
i	int
,	O
j	int
)	O
;	O
else	O
{	O
newline_needed	int
=	O
1	int
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
(	O
m	int
==	O
i	int
&&	O
n	int
==	O
j	int
)	O
||	O
(	O
i	int
==	O
-	O
1	int
&&	O
BOARD	O
(	O
m	int
,	O
n	int
)	O
!=	O
EMPTY	int
&&	O
dragon	int
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
origin	int
==	O
POS	O
(	O
m	int
,	O
n	int
)	O
)	O
)	O
{	O
gtp_print_vertex	(int,int)->(void)
(	O
m	int
,	O
n	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
":\n"	*(char)
)	O
;	O
report_dragon	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(void)
(	O
gtp_output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
POS	O
(	O
m	int
,	O
n	int
)	O
)	O
;	O
newline_needed	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
newline_needed	int
)	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_dragon_stones	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
int	O
color	int
=	O
EMPTY	int
;	O
int	O
m	int
,	O
n	int
;	O
int	O
u	int
,	O
v	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%*c"	*(char)
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
&&	O
!	O
gtp_decode_color	(*(char),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
}	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"dragon_stones called on an empty vertex"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
u	int
=	O
0	int
;	O
u	int
<	O
board_size	int
;	O
u	int
++	O
)	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
board_size	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
BOARD	O
(	O
u	int
,	O
v	int
)	O
==	O
EMPTY	int
||	O
(	O
color	int
!=	O
EMPTY	int
&&	O
BOARD	O
(	O
u	int
,	O
v	int
)	O
!=	O
color	int
)	O
)	O
continue	O
;	O
if	O
(	O
dragon	int
[	O
POS	O
(	O
u	int
,	O
v	int
)	O
]	O
.	O
origin	int
!=	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
continue	O
;	O
if	O
(	O
ON_BOARD2	O
(	O
i	int
,	O
j	int
)	O
&&	O
dragon	int
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
.	O
origin	int
!=	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
continue	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
dragon	int
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
origin	int
==	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
gtp_mprintf	(*(char))->(void)
(	O
"%m "	*(char)
,	O
m	int
,	O
n	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
}	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_eye_data	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
color	int
=	O
EMPTY	int
;	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
struct	O
eye_data	struct(int,int,int,int,struct(char,char,char,char),char,char,char)
*	O
e	*(struct(char,char,char,char))
;	O
if	O
(	O
!	O
gtp_decode_move	(*(char),*(int),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid color or coordinate"	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"eye data unavailable when stackp > 0"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
color	int
==	O
BLACK	int
)	O
e	*(struct(char,char,char,char))
=	O
&	O
black_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
;	O
else	O
e	*(struct(char,char,char,char))
=	O
&	O
white_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"origin               %m\n"	*(char)
,	O
I	O
(	O
e	*(struct(char,char,char,char))
->	O
origin	int
)	O
,	O
J	O
(	O
e	*(struct(char,char,char,char))
->	O
origin	int
)	O
)	O
;	O
gtp_mprintf	(*(char))->(void)
(	O
"color                %C\n"	*(char)
,	O
e	*(struct(char,char,char,char))
->	O
color	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"esize                %d\n"	*(char)
,	O
e	*(struct(char,char,char,char))
->	O
esize	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"msize                %d\n"	*(char)
,	O
e	*(struct(char,char,char,char))
->	O
msize	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"value                %s\n"	*(char)
,	O
eyevalue_to_string	(*(struct(char,char,char,char)))->(*(char))
(	O
&	O
e	*(struct(char,char,char,char))
->	O
value	*(char)
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"marginal             %d\n"	*(char)
,	O
e	*(struct(char,char,char,char))
->	O
marginal	char
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"neighbors            %d\n"	*(char)
,	O
e	*(struct(char,char,char,char))
->	O
neighbors	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"marginal_neighbors   %d\n"	*(char)
,	O
e	*(struct(char,char,char,char))
->	O
marginal_neighbors	char
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_half_eye_data	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
struct	O
half_eye_data	struct(float,char,int,array(int),int,array(int))
*	O
h	*(struct(float,char,int,array(int),int,array(int)))
;	O
int	O
k	int
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"half eye data unavailable when stackp > 0"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
h	*(struct(float,char,int,array(int),int,array(int)))
=	O
&	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
;	O
gtp_printf	(*(char))->(void)
(	O
"value                %.2f\n"	*(char)
,	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
value	*(char)
)	O
;	O
if	O
(	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
type	char
==	O
HALF_EYE	int
)	O
gtp_printf	(*(char))->(void)
(	O
"type                 HALF_EYE\n"	*(char)
)	O
;	O
else	O
if	O
(	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
type	char
==	O
FALSE_EYE	int
)	O
gtp_printf	(*(char))->(void)
(	O
"type                 FALSE_EYE\n"	*(char)
)	O
;	O
else	O
gtp_printf	(*(char))->(void)
(	O
"type                 %d\n"	*(char)
,	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
type	char
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"num_attacks          %d\n"	*(char)
,	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
num_attacks	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
num_attacks	int
;	O
k	int
++	O
)	O
gtp_mprintf	(*(char))->(void)
(	O
"attack_point[%d]      %m\n"	*(char)
,	O
k	int
,	O
I	O
(	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
attack_point	*(int)
[	O
k	int
]	O
)	O
,	O
J	O
(	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
attack_point	*(int)
[	O
k	int
]	O
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"num_defenses         %d\n"	*(char)
,	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
num_defenses	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
num_defenses	int
;	O
k	int
++	O
)	O
gtp_mprintf	(*(char))->(void)
(	O
"defense_point[%d]     %m\n"	*(char)
,	O
k	int
,	O
I	O
(	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
defense_point	*(int)
[	O
k	int
]	O
)	O
,	O
J	O
(	O
h	*(struct(float,char,int,array(int),int,array(int)))
->	O
defense_point	*(int)
[	O
k	int
]	O
)	O
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
gtp_sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
;	O
static	O
int	O
gtp_start_sgftrace	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
sgffile_begindump	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(void)
(	O
&	O
gtp_sgftree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
)	O
;	O
count_variations	int
=	O
1	int
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_finish_sgftrace	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
filename	*(char)
[	O
GTP_BUFSIZE	int
]	O
;	O
int	O
nread	int
;	O
nread	int
=	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%s"	*(char)
,	O
filename	*(char)
)	O
;	O
if	O
(	O
nread	int
<	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"missing filename"	*(char)
)	O
;	O
sgffile_enddump	(*(char))->(void)
(	O
filename	*(char)
)	O
;	O
count_variations	int
=	O
0	int
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_printsgf	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
filename	*(char)
[	O
GTP_BUFSIZE	int
]	O
;	O
int	O
nread	int
;	O
int	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
if	O
(	O
get_last_player	()->(int)
(	O
)	O
==	O
EMPTY	int
)	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
BLACK	int
;	O
else	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
OTHER_COLOR	O
(	O
get_last_player	()->(int)
(	O
)	O
)	O
;	O
nread	int
=	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%s"	*(char)
,	O
filename	*(char)
)	O
;	O
if	O
(	O
nread	int
<	O
1	int
)	O
gg_snprintf	(*(char),long,*(char))->(void)
(	O
filename	*(char)
,	O
GTP_BUFSIZE	int
,	O
"%s"	*(char)
,	O
"-"	*(char)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
filename	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
{	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
sgffile_printsgf	(int,*(char))->(void)
(	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
filename	*(char)
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
else	O
{	O
sgffile_printsgf	(int,*(char))->(void)
(	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
,	O
filename	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
gtp_tune_move_ordering	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
params	array(int)
[	O
MOVE_ORDERING_PARAMETERS	int
]	O
;	O
int	O
k	int
;	O
int	O
p	int
;	O
int	O
n	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MOVE_ORDERING_PARAMETERS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d%n"	*(char)
,	O
&	O
p	int
,	O
&	O
n	int
)	O
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"incorrect arguments, expected %d integers"	*(char)
,	O
MOVE_ORDERING_PARAMETERS	int
)	O
;	O
params	array(int)
[	O
k	int
]	O
=	O
p	int
;	O
s	*(char)
+=	O
n	int
;	O
}	O
tune_move_ordering	(array(int))->(void)
(	O
params	array(int)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_echo	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
return	O
gtp_success	(*(char))->(int)
(	O
"%s"	*(char)
,	O
s	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_echo_err	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
s	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
gtp_output_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%s"	*(char)
,	O
s	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_list_commands	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
k	int
;	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
commands	array(struct(*(char),*((*(char))->(int))))
[	O
k	int
]	O
.	O
name	short
!=	O
NULL	O
;	O
k	int
++	O
)	O
gtp_printf	(*(char))->(void)
(	O
"%s\n"	*(char)
,	O
commands	array(struct(*(char),*((*(char))->(int))))
[	O
k	int
]	O
.	O
name	short
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_known_command	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
k	int
;	O
char	O
command	array(char)
[	O
GTP_BUFSIZE	int
]	O
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%s"	*(char)
,	O
command	array(char)
)	O
==	O
1	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
commands	array(struct(*(char),*((*(char))->(int))))
[	O
k	int
]	O
.	O
name	short
!=	O
NULL	O
;	O
k	int
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
command	array(char)
,	O
commands	array(struct(*(char),*((*(char))->(int))))
[	O
k	int
]	O
.	O
name	short
)	O
==	O
0	int
)	O
return	O
gtp_success	(*(char))->(int)
(	O
"true"	*(char)
)	O
;	O
}	O
return	O
gtp_success	(*(char))->(int)
(	O
"false"	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_report_uncertainty	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
"on"	*(char)
,	O
2	int
)	O
)	O
{	O
report_uncertainty	int
=	O
1	int
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(char)
,	O
"off"	*(char)
,	O
3	int
)	O
)	O
{	O
report_uncertainty	int
=	O
0	int
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid argument"	*(char)
)	O
;	O
}	O
static	O
void	O
gtp_print_code	(int)->(void)
(	O
int	O
c	char
)	O
{	O
static	O
int	O
conversion	array(int)
[	O
6	int
]	O
=	O
{	O
0	int
,	O
3	int
,	O
5	int
,	O
4	int
,	O
2	int
,	O
1	int
,	O
}	O
;	O
gtp_printf	(*(char))->(void)
(	O
"%d"	*(char)
,	O
conversion	array(int)
[	O
c	char
]	O
)	O
;	O
}	O
static	O
void	O
gtp_print_vertices2	(int,*(int))->(void)
(	O
int	O
n	int
,	O
int	O
*	O
moves	array(int)
)	O
{	O
int	O
movei	array(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
movej	array(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
{	O
movei	array(int)
[	O
k	int
]	O
=	O
I	O
(	O
moves	array(int)
[	O
k	int
]	O
)	O
;	O
movej	array(int)
[	O
k	int
]	O
=	O
J	O
(	O
moves	array(int)
[	O
k	int
]	O
)	O
;	O
}	O
gtp_print_vertices	(int,array(int),array(int))->(void)
(	O
n	int
,	O
movei	array(int)
,	O
movej	array(int)
)	O
;	O
}	O
static	O
void	O
rotate_on_input	(int,int,*(int),*(int))->(void)
(	O
int	O
ai	int
,	O
int	O
aj	int
,	O
int	O
*	O
bi	*(int)
,	O
int	O
*	O
bj	*(int)
)	O
{	O
rotate	(int,int,*(int),*(int),int,int)->(void)
(	O
ai	int
,	O
aj	int
,	O
bi	*(int)
,	O
bj	*(int)
,	O
board_size	int
,	O
gtp_orientation	int
)	O
;	O
}	O
static	O
void	O
rotate_on_output	(int,int,*(int),*(int))->(void)
(	O
int	O
ai	int
,	O
int	O
aj	int
,	O
int	O
*	O
bi	*(int)
,	O
int	O
*	O
bj	*(int)
)	O
{	O
inv_rotate	(int,int,*(int),*(int),int,int)->(void)
(	O
ai	int
,	O
aj	int
,	O
bi	*(int)
,	O
bj	*(int)
,	O
board_size	int
,	O
gtp_orientation	int
)	O
;	O
}	O
static	O
int	O
gtp_get_random_seed	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
get_random_seed	()->(int)
(	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_set_random_seed	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
seed	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d"	*(char)
,	O
&	O
seed	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid seed"	*(char)
)	O
;	O
set_random_seed	(int)->(void)
(	O
seed	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_advance_random_seed	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
;	O
int	O
games	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d"	*(char)
,	O
&	O
games	int
)	O
<	O
1	int
||	O
games	int
<	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid number of games"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
games	int
;	O
i	int
++	O
)	O
update_random_seed	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
get_random_seed	()->(int)
(	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_is_surrounded	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"dragon vertex must be nonempty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
DRAGON2	O
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
.	O
surround_status	int
)	O
;	O
}	O
static	O
int	O
gtp_does_surround	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
si	int
,	O
sj	int
,	O
di	int
,	O
dj	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
si	int
,	O
&	O
sj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
si	int
,	O
sj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"move vertex must be empty"	*(char)
)	O
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
n	int
,	O
&	O
di	int
,	O
&	O
dj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
di	int
,	O
dj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"dragon vertex must be nonempty"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
does_surround	(int,int)->(int)
(	O
POS	O
(	O
si	int
,	O
sj	int
)	O
,	O
POS	O
(	O
di	int
,	O
dj	int
)	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_surround_map	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
di	int
,	O
dj	int
,	O
mi	int
,	O
mj	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
di	int
,	O
&	O
dj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
if	O
(	O
BOARD	O
(	O
di	int
,	O
dj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"dragon vertex must not be empty"	*(char)
)	O
;	O
n	int
=	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
+	O
n	int
,	O
&	O
mi	int
,	O
&	O
mj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
silent_examine_position	(int)->(void)
(	O
EXAMINE_DRAGONS	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
"%d"	*(char)
,	O
surround_map	(int,int)->(int)
(	O
POS	O
(	O
di	int
,	O
dj	int
)	O
,	O
POS	O
(	O
mi	int
,	O
mj	int
)	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_set_search_diamond	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
!	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid coordinate"	*(char)
)	O
;	O
set_limit_search	(int)->(void)
(	O
1	int
)	O
;	O
set_search_diamond	(int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_reset_search_mask	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
reset_search_mask	()->(void)
(	O
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_limit_search	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
value	*(char)
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"%d"	*(char)
,	O
&	O
value	*(char)
)	O
<	O
1	int
)	O
return	O
gtp_failure	(*(char))->(int)
(	O
"invalid value for search limit"	*(char)
)	O
;	O
set_limit_search	(int)->(void)
(	O
value	*(char)
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_set_search_limit	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
gtp_decode_coord	(*(char),*(int),*(int))->(int)
(	O
s	*(char)
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
set_search_mask	(int,int)->(void)
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
1	int
)	O
;	O
return	O
gtp_success	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
gtp_draw_search_area	(*(char))->(int)
(	O
char	O
*	O
s	*(char)
)	O
{	O
UNUSED	O
(	O
s	*(char)
)	O
;	O
gtp_start_response	(int)->(void)
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_printf	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
draw_search_area	()->(void)
(	O
)	O
;	O
return	O
gtp_finish_response	()->(int)
(	O
)	O
;	O
}	O
