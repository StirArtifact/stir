extern	O
int	O
vnStates	O
;	O
extern	O
int	O
vnOutputs	O
;	O
extern	O
int	O
vnModelVars	O
;	O
extern	O
int	O
vnInputs	O
;	O
extern	O
int	O
vnParms	O
;	O
extern	O
double	O
vrgModelVars	O
[	O
]	O
;	O
extern	O
IFN	struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))
vrgInputs	O
[	O
]	O
;	O
extern	O
VMMAPSTRCT	O
vrgvmGlo	O
[	O
]	O
;	O
BOOL	int
vbModelReinitd	O
=	O
FALSE	O
;	O
void	O
FixupDependentInputs	O
(	O
void	O
)	O
{	O
int	O
i	O
,	O
j	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
vnInputs	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hMag	long
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dMag	double
=	O
GetVarValue	(long)->(double)
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hMag	long
)	O
;	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hTper	long
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTper	double
=	O
GetVarValue	(long)->(double)
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hTper	long
)	O
;	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hT0	long
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dT0	double
=	O
GetVarValue	(long)->(double)
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hT0	long
)	O
;	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hTexp	long
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTexp	double
=	O
GetVarValue	(long)->(double)
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hTexp	long
)	O
;	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hDecay	long
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dDecay	double
=	O
GetVarValue	(long)->(double)
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hDecay	long
)	O
;	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hNcpt	long
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dNcpt	double
=	O
GetVarValue	(long)->(double)
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
hNcpt	long
)	O
;	O
if	O
(	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_NDOSES	O
)	O
||	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_SPIKES	O
)	O
||	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_EVENTS	O
)	O
)	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
vrgInputs	O
[	O
i	O
]	O
.	O
nDoses	int
;	O
j	O
++	O
)	O
{	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
rghMags	*(long)
[	O
j	O
]	O
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgMags	*(double)
[	O
j	O
]	O
=	O
GetVarValue	(long)->(double)
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
rghMags	*(long)
[	O
j	O
]	O
)	O
;	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
rghT0s	*(long)
[	O
j	O
]	O
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgT0s	*(double)
[	O
j	O
]	O
=	O
GetVarValue	(long)->(double)
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
rghT0s	*(long)
[	O
j	O
]	O
)	O
;	O
if	O
(	O
j	O
>	O
0	int
)	O
{	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgT0s	*(double)
[	O
j	O
]	O
<=	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgT0s	*(double)
[	O
j	O
-	O
1	int
]	O
)	O
{	O
printf	(*(char))->(int)
(	O
"\nError: unordered pair of times (%g, %g) in %s "	*(char)
"statement - Exiting\n"	*(char)
,	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgT0s	*(double)
[	O
j	O
-	O
1	int
]	O
,	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgT0s	*(double)
[	O
j	O
]	O
,	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_NDOSES	O
?	O
"NDoses"	*(char)
:	O
"Spikes"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_PEREXP	O
)	O
||	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_PERTRANS	O
)	O
)	O
{	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTexp	double
=	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTper	double
;	O
}	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_PERTRANS	O
)	O
{	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
dNcpt	double
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"\nError: null or negative number of virtual compartment "	*(char)
"in PerTransit input function - Exiting\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTexp	double
=	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTper	double
;	O
}	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTexp	double
>=	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTper	double
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTexp	double
=	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTper	double
;	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_NDOSES	O
||	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_SPIKES	O
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dMag	double
=	O
1.0	int
;	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_PERDOSE	O
||	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_PERTRANS	O
||	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_PEREXP	O
)	O
{	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTexp	double
==	O
0.0	int
||	O
vrgInputs	O
[	O
i	O
]	O
.	O
dT0	double
<	O
0.0	int
||	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTper	double
<	O
0.0	int
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dMag	double
=	O
0.0	int
;	O
}	O
}	O
}	O
void	O
GetStartPeriods	O
(	O
PDOUBLE	*(double)
pdTime	*(double)
)	O
{	O
int	O
i	O
;	O
double	O
dTmp	O
,	O
dDummy	O
;	O
if	O
(	O
*	O
pdTime	*(double)
==	O
0.0	int
)	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
vnInputs	O
;	O
i	O
++	O
)	O
{	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTStartPeriod	double
=	O
0.0	int
;	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_NDOSES	O
||	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_SPIKES	O
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
=	O
0	int
;	O
}	O
else	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
vnInputs	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_NDOSES	O
||	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
==	O
IFN_SPIKES	O
)	O
{	O
for	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
=	O
0	int
;	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
<	O
vrgInputs	O
[	O
i	O
]	O
.	O
nDoses	int
;	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
++	O
)	O
if	O
(	O
*	O
pdTime	*(double)
<	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgT0s	*(double)
[	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
]	O
)	O
break	O
;	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
--	O
;	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
<	O
0	int
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTper	double
==	O
0.0	int
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTStartPeriod	double
=	O
0.0	int
;	O
else	O
{	O
dTmp	O
=	O
(	O
*	O
pdTime	*(double)
/	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTper	double
)	O
;	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTStartPeriod	double
=	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTper	double
*	O
modf	(double,*(double))->(double)
(	O
dTmp	O
,	O
&	O
dDummy	O
)	O
;	O
}	O
}	O
}	O
}	O
void	O
UpdateNDoses	O
(	O
PIFN	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
,	O
PDOUBLE	*(double)
pdTnext	O
,	O
PDOUBLE	*(double)
pdTime	*(double)
)	O
{	O
int	O
j	O
;	O
j	O
=	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
iDoseCur	int
;	O
if	O
(	O
j	O
<	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
nDoses	int
)	O
{	O
*	O
pdTnext	O
=	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
rgT0s	*(double)
[	O
j	O
]	O
;	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
=	O
(	O
*	O
pdTime	*(double)
>=	O
*	O
pdTnext	O
)	O
;	O
if	O
(	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
)	O
{	O
*	O
pdTnext	O
=	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
rgT0s	*(double)
[	O
j	O
+	O
1	int
]	O
;	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
=	O
(	O
*	O
pdTime	*(double)
<	O
*	O
pdTnext	O
)	O
;	O
if	O
(	O
!	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
)	O
if	O
(	O
++	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
iDoseCur	int
<	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
nDoses	int
)	O
{	O
*	O
pdTnext	O
=	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
rgT0s	*(double)
[	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
iDoseCur	int
+	O
1	int
]	O
;	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
else	O
*	O
pdTnext	O
=	O
DBL_MAX	O
;	O
if	O
(	O
!	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
)	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dVal	double
=	O
0.0	int
;	O
}	O
BOOL	int
UpdateSpikes	O
(	O
PIFN	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
,	O
PDOUBLE	*(double)
pdTnext	O
,	O
PDOUBLE	*(double)
pdTime	*(double)
)	O
{	O
register	O
double	O
*	O
rgT0s	*(double)
=	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
rgT0s	*(double)
;	O
register	O
int	O
j	O
=	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
iDoseCur	int
;	O
*	O
pdTnext	O
=	O
DBL_MAX	O
;	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
=	O
FALSE	O
;	O
if	O
(	O
j	O
<	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
nDoses	int
)	O
{	O
if	O
(	O
*	O
pdTime	*(double)
<	O
rgT0s	*(double)
[	O
j	O
]	O
)	O
*	O
pdTnext	O
=	O
rgT0s	*(double)
[	O
j	O
]	O
;	O
else	O
if	O
(	O
*	O
pdTime	*(double)
==	O
rgT0s	*(double)
[	O
j	O
]	O
)	O
{	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
=	O
TRUE	O
;	O
if	O
(	O
j	O
+	O
1	int
<	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
nDoses	int
)	O
*	O
pdTnext	O
=	O
rgT0s	*(double)
[	O
j	O
+	O
1	int
]	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"\nUpdateSpikes: Discontinuity was passed over\n"	*(char)
)	O
;	O
}	O
return	O
(	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
)	O
;	O
}	O
void	O
UpdateDefaultInput	O
(	O
PIFN	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
,	O
PDOUBLE	*(double)
pdTnext	O
,	O
PDOUBLE	*(double)
pdTime	*(double)
)	O
{	O
*	O
pdTnext	O
=	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dTStartPeriod	double
+	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dT0	double
;	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
=	O
(	O
*	O
pdTime	*(double)
>=	O
*	O
pdTnext	O
)	O
;	O
if	O
(	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
)	O
{	O
*	O
pdTnext	O
+=	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dTexp	double
;	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
=	O
(	O
*	O
pdTime	*(double)
<	O
*	O
pdTnext	O
)	O
&&	O
(	O
(	O
*	O
pdTnext	O
-	O
*	O
pdTime	*(double)
)	O
>	O
DBL_EPSILON	O
*	O
2.0	int
*	O
(	O
*	O
pdTnext	O
)	O
)	O
;	O
if	O
(	O
!	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
)	O
{	O
if	O
(	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dTper	double
!=	O
0.0	int
)	O
*	O
pdTnext	O
=	O
(	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dTStartPeriod	double
+=	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dTper	double
)	O
;	O
else	O
*	O
pdTnext	O
=	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dTStartPeriod	double
=	O
DBL_MAX	O
-	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dTper	double
;	O
}	O
}	O
if	O
(	O
!	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
bOn	int
)	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dVal	double
=	O
0.0	int
;	O
else	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dVal	double
=	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dMag	double
;	O
}	O
void	O
UpdateInputs	(*(double),*(double))->(void)
(	O
PDOUBLE	*(double)
pdTime	*(double)
,	O
PDOUBLE	*(double)
pdNextTransTime	*(double)
)	O
{	O
double	O
dT	O
;	O
int	O
i	O
,	O
j	O
,	O
stateID	O
;	O
if	O
(	O
vbModelReinitd	O
)	O
{	O
ScaleModel	(*(double))->(void)
(	O
pdTime	*(double)
)	O
;	O
FixupDependentInputs	O
(	O
)	O
;	O
GetStartPeriods	O
(	O
pdTime	*(double)
)	O
;	O
}	O
dT	O
=	O
*	O
pdNextTransTime	*(double)
=	O
DBL_MAX	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
vnInputs	O
;	O
i	O
++	O
)	O
{	O
switch	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
)	O
{	O
case	O
IFN_CONSTANT	O
:	O
break	O
;	O
case	O
IFN_NDOSES	O
:	O
UpdateNDoses	O
(	O
&	O
vrgInputs	O
[	O
i	O
]	O
,	O
&	O
dT	O
,	O
pdTime	*(double)
)	O
;	O
break	O
;	O
case	O
IFN_EVENTS	O
:	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
bOn	int
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
++	O
;	O
UpdateSpikes	O
(	O
&	O
vrgInputs	O
[	O
i	O
]	O
,	O
&	O
dT	O
,	O
pdTime	*(double)
)	O
;	O
j	O
=	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
;	O
stateID	O
=	O
HINDEX	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
target_state	long
)	O
;	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
bOn	int
&&	O
(	O
j	O
<	O
vrgInputs	O
[	O
i	O
]	O
.	O
nDoses	int
)	O
)	O
vrgModelVars	O
[	O
stateID	O
]	O
=	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgOper	*(int)
[	O
j	O
]	O
==	O
KM_REPLACE	O
?	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgMags	*(double)
[	O
j	O
]	O
:	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgOper	*(int)
[	O
j	O
]	O
==	O
KM_ADD	O
?	O
vrgModelVars	O
[	O
stateID	O
]	O
+	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgMags	*(double)
[	O
j	O
]	O
:	O
vrgModelVars	O
[	O
stateID	O
]	O
*	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgMags	*(double)
[	O
j	O
]	O
)	O
;	O
break	O
;	O
case	O
IFN_SPIKES	O
:	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
bOn	int
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
++	O
;	O
UpdateSpikes	O
(	O
&	O
vrgInputs	O
[	O
i	O
]	O
,	O
&	O
dT	O
,	O
pdTime	*(double)
)	O
;	O
break	O
;	O
default	O
:	O
case	O
IFN_PERDOSE	O
:	O
case	O
IFN_PEREXP	O
:	O
case	O
IFN_PERTRANS	O
:	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
dMag	double
!=	O
0.0	int
)	O
UpdateDefaultInput	O
(	O
&	O
vrgInputs	O
[	O
i	O
]	O
,	O
&	O
dT	O
,	O
pdTime	*(double)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
dT	O
<	O
*	O
pdNextTransTime	*(double)
)	O
*	O
pdNextTransTime	*(double)
=	O
dT	O
;	O
}	O
if	O
(	O
vbModelReinitd	O
)	O
{	O
vbModelReinitd	O
=	O
FALSE	O
;	O
}	O
}	O
PVMMAPSTRCT	O
GetVarPtr	O
(	O
PVMMAPSTRCT	O
pvm	O
,	O
PSTR	*(char)
szName	*(char)
)	O
{	O
while	O
(	O
*	O
pvm	O
->	O
szName	*(char)
&&	O
MyStrcmp	O
(	O
szName	*(char)
,	O
pvm	O
->	O
szName	*(char)
)	O
)	O
pvm	O
++	O
;	O
return	O
(	O
*	O
pvm	O
->	O
szName	*(char)
?	O
pvm	O
:	O
NULL	O
)	O
;	O
}	O
HVAR	long
GetVarHandle	(*(char))->(long)
(	O
PSTR	*(char)
szName	*(char)
)	O
{	O
PVMMAPSTRCT	O
pvm	O
=	O
GetVarPtr	O
(	O
vrgvmGlo	O
,	O
szName	*(char)
)	O
;	O
return	O
(	O
pvm	O
?	O
pvm	O
->	O
hvar	long
:	O
ID_NULL	O
)	O
;	O
}	O
int	O
GetVarType	O
(	O
HVAR	long
hvar	long
)	O
{	O
BOOL	int
bOK	O
=	O
FALSE	O
;	O
switch	O
(	O
HTYPE	O
(	O
hvar	long
)	O
)	O
{	O
case	O
ID_INPUT	O
:	O
bOK	O
=	O
HINDEX	O
(	O
hvar	long
)	O
<	O
vnInputs	O
;	O
break	O
;	O
case	O
ID_STATE	O
:	O
bOK	O
=	O
HINDEX	O
(	O
hvar	long
)	O
<	O
vnStates	O
;	O
break	O
;	O
case	O
ID_OUTPUT	O
:	O
bOK	O
=	O
HINDEX	O
(	O
hvar	long
)	O
>=	O
vnStates	O
&&	O
HINDEX	O
(	O
hvar	long
)	O
<	O
vnModelVars	O
;	O
break	O
;	O
case	O
ID_PARM	O
:	O
{	O
int	O
nSOI	O
=	O
vnStates	O
+	O
vnOutputs	O
+	O
vnInputs	O
;	O
bOK	O
=	O
(	O
HINDEX	O
(	O
hvar	long
)	O
>=	O
nSOI	O
)	O
&&	O
(	O
HINDEX	O
(	O
hvar	long
)	O
<	O
nSOI	O
+	O
vnParms	O
)	O
;	O
break	O
;	O
}	O
default	O
:	O
break	O
;	O
}	O
return	O
(	O
bOK	O
?	O
HTYPE	O
(	O
hvar	long
)	O
:	O
ID_NULL	O
)	O
;	O
}	O
char	O
*	O
GetVarName	(long)->(*(char))
(	O
HVAR	long
hvar	long
)	O
{	O
static	O
char	O
szInvalid	O
[	O
]	O
=	O
"InvalidVariable?"	*(char)
;	O
PVMMAPSTRCT	O
pvm	O
=	O
vrgvmGlo	O
;	O
while	O
(	O
*	O
pvm	O
->	O
szName	*(char)
&&	O
hvar	long
!=	O
pvm	O
->	O
hvar	long
)	O
pvm	O
++	O
;	O
return	O
(	O
*	O
pvm	O
->	O
szName	*(char)
?	O
pvm	O
->	O
szName	*(char)
:	O
szInvalid	O
)	O
;	O
}	O
double	O
GetVarValue	(long)->(double)
(	O
HVAR	long
hvar	long
)	O
{	O
double	O
dReturn	O
=	O
0.0	int
;	O
switch	O
(	O
GetVarType	O
(	O
hvar	long
)	O
)	O
{	O
case	O
ID_INPUT	O
:	O
dReturn	O
=	O
vrgInputs	O
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
.	O
dVal	double
;	O
break	O
;	O
case	O
ID_OUTPUT	O
:	O
case	O
ID_STATE	O
:	O
dReturn	O
=	O
vrgModelVars	O
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
;	O
break	O
;	O
case	O
ID_PARM	O
:	O
{	O
PVMMAPSTRCT	O
pvm	O
;	O
pvm	O
=	O
&	O
vrgvmGlo	O
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
;	O
dReturn	O
=	O
*	O
(	O
PDOUBLE	*(double)
)	O
pvm	O
->	O
pVar	O
;	O
break	O
;	O
}	O
default	O
:	O
break	O
;	O
}	O
return	O
(	O
dReturn	O
)	O
;	O
}	O
BOOL	int
IsInput	(long)->(int)
(	O
HVAR	long
hvar	long
)	O
{	O
return	O
(	O
GetVarType	O
(	O
hvar	long
)	O
==	O
ID_INPUT	O
)	O
;	O
}	O
BOOL	int
IsState	(long)->(int)
(	O
HVAR	long
hvar	long
)	O
{	O
return	O
(	O
GetVarType	O
(	O
hvar	long
)	O
==	O
ID_STATE	O
)	O
;	O
}	O
BOOL	int
IsOutput	(long)->(int)
(	O
HVAR	long
hvar	long
)	O
{	O
return	O
(	O
GetVarType	O
(	O
hvar	long
)	O
==	O
ID_OUTPUT	O
)	O
;	O
}	O
BOOL	int
IsModelVar	(long)->(int)
(	O
HVAR	long
hvar	long
)	O
{	O
int	O
iType	int
=	O
GetVarType	O
(	O
hvar	long
)	O
;	O
return	O
(	O
iType	int
==	O
ID_STATE	O
||	O
iType	int
==	O
ID_OUTPUT	O
)	O
;	O
}	O
BOOL	int
IsParm	(long)->(int)
(	O
HVAR	long
hvar	long
)	O
{	O
return	O
(	O
GetVarType	O
(	O
hvar	long
)	O
==	O
ID_PARM	O
)	O
;	O
}	O
int	O
ModelIndex	(long)->(int)
(	O
HVAR	long
hvar	long
)	O
{	O
return	O
(	O
IsModelVar	(long)->(int)
(	O
hvar	long
)	O
?	O
HINDEX	O
(	O
hvar	long
)	O
:	O
0	int
)	O
;	O
}	O
BOOL	int
SetVar	(long,double)->(int)
(	O
HVAR	long
hvar	long
,	O
double	O
dVal	double
)	O
{	O
BOOL	int
bReturn	O
=	O
TRUE	O
;	O
switch	O
(	O
GetVarType	O
(	O
hvar	long
)	O
)	O
{	O
default	O
:	O
case	O
ID_INPUT	O
:	O
bReturn	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
ID_OUTPUT	O
:	O
case	O
ID_STATE	O
:	O
vrgModelVars	O
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
=	O
dVal	double
;	O
break	O
;	O
case	O
ID_PARM	O
:	O
{	O
PVMMAPSTRCT	O
pvm	O
=	O
&	O
vrgvmGlo	O
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
;	O
*	O
(	O
PDOUBLE	*(double)
)	O
pvm	O
->	O
pVar	O
=	O
dVal	double
;	O
break	O
;	O
}	O
}	O
return	O
(	O
bReturn	O
)	O
;	O
}	O
BOOL	int
SetInput	(long,*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))))->(int)
(	O
HVAR	long
hvar	long
,	O
PIFN	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
)	O
{	O
if	O
(	O
!	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
||	O
!	O
IsInput	(long)->(int)
(	O
hvar	long
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
vrgInputs	O
[	O
HINDEX	O
(	O
hvar	long
)	O
]	O
,	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
,	O
sizeof	O
(	O
IFN	struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int))
)	O
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
PDOUBLE	*(double)
GetModelVector	()->(*(double))
(	O
void	O
)	O
{	O
return	O
(	O
(	O
PDOUBLE	*(double)
)	O
vrgModelVars	O
)	O
;	O
}	O
int	O
GetNModelVars	()->(int)
(	O
void	O
)	O
{	O
return	O
(	O
vnModelVars	O
)	O
;	O
}	O
int	O
GetNStates	()->(int)
(	O
void	O
)	O
{	O
return	O
(	O
vnStates	O
)	O
;	O
}	O
void	O
CalcInputs	(*(double))->(void)
(	O
PDOUBLE	*(double)
pdTime	*(double)
)	O
{	O
int	O
i	O
;	O
double	O
dTmp	O
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
vnInputs	O
;	O
i	O
++	O
)	O
{	O
if	O
(	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
!=	O
IFN_CONSTANT	O
)	O
&&	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
bOn	int
||	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
!=	O
IFN_SPIKES	O
)	O
)	O
)	O
{	O
switch	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iType	int
)	O
{	O
case	O
IFN_CONSTANT	O
:	O
break	O
;	O
case	O
IFN_NDOSES	O
:	O
if	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
<	O
vrgInputs	O
[	O
i	O
]	O
.	O
nDoses	int
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dVal	double
=	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgMags	*(double)
[	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
]	O
*	O
vrgInputs	O
[	O
i	O
]	O
.	O
dMag	double
;	O
break	O
;	O
case	O
IFN_PERDOSE	O
:	O
break	O
;	O
case	O
IFN_PEREXP	O
:	O
vrgInputs	O
[	O
i	O
]	O
.	O
dVal	double
=	O
vrgInputs	O
[	O
i	O
]	O
.	O
dMag	double
*	O
(	O
(	O
int	O
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
bOn	int
)	O
*	O
exp	(double)->(double)
(	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTStartPeriod	double
+	O
vrgInputs	O
[	O
i	O
]	O
.	O
dT0	double
-	O
*	O
pdTime	*(double)
)	O
*	O
vrgInputs	O
[	O
i	O
]	O
.	O
dDecay	double
)	O
;	O
break	O
;	O
case	O
IFN_PERTRANS	O
:	O
dTmp	O
=	O
vrgInputs	O
[	O
i	O
]	O
.	O
dDecay	double
*	O
(	O
*	O
pdTime	*(double)
-	O
vrgInputs	O
[	O
i	O
]	O
.	O
dTStartPeriod	double
-	O
vrgInputs	O
[	O
i	O
]	O
.	O
dT0	double
)	O
;	O
vrgInputs	O
[	O
i	O
]	O
.	O
dVal	double
=	O
vrgInputs	O
[	O
i	O
]	O
.	O
dMag	double
*	O
(	O
(	O
int	O
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
bOn	int
)	O
*	O
pow	(double,double)->(double)
(	O
dTmp	O
,	O
vrgInputs	O
[	O
i	O
]	O
.	O
dNcpt	double
)	O
*	O
exp	(double)->(double)
(	O
-	O
dTmp	O
)	O
/	O
(	O
SQRT2PI	O
*	O
pow	(double,double)->(double)
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
dNcpt	double
,	O
vrgInputs	O
[	O
i	O
]	O
.	O
dNcpt	double
+	O
0.5	int
)	O
*	O
exp	(double)->(double)
(	O
-	O
vrgInputs	O
[	O
i	O
]	O
.	O
dNcpt	double
)	O
)	O
;	O
break	O
;	O
case	O
IFN_SPIKES	O
:	O
if	O
(	O
(	O
*	O
pdTime	*(double)
==	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgT0s	*(double)
[	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
]	O
)	O
&&	O
(	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
<	O
vrgInputs	O
[	O
i	O
]	O
.	O
nDoses	int
)	O
)	O
vrgInputs	O
[	O
i	O
]	O
.	O
dVal	double
=	O
vrgInputs	O
[	O
i	O
]	O
.	O
rgMags	*(double)
[	O
vrgInputs	O
[	O
i	O
]	O
.	O
iDoseCur	int
]	O
*	O
vrgInputs	O
[	O
i	O
]	O
.	O
dMag	double
;	O
else	O
vrgInputs	O
[	O
i	O
]	O
.	O
dVal	double
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
void	O
DumpSymbolTable	(*(char))->(void)
(	O
char	O
*	O
szFilename	*(char)
)	O
{	O
static	O
char	O
szStderr	O
[	O
]	O
=	O
"<stdout>"	*(char)
;	O
FILE	struct
*	O
pfile	O
;	O
PVMMAPSTRCT	O
pvm	O
=	O
&	O
vrgvmGlo	O
[	O
0	int
]	O
;	O
if	O
(	O
szFilename	*(char)
)	O
pfile	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
szFilename	*(char)
,	O
"a"	*(char)
)	O
;	O
else	O
{	O
pfile	O
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
szFilename	*(char)
=	O
szStderr	O
;	O
}	O
if	O
(	O
!	O
pfile	O
)	O
{	O
printf	(*(char))->(int)
(	O
"Cannot dump symbol table to %s\n"	*(char)
,	O
szFilename	*(char)
)	O
;	O
return	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfile	O
,	O
"\nSymbol Table:\n"	*(char)
)	O
;	O
if	O
(	O
!	O
pvm	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfile	O
,	O
"<null>\n"	*(char)
)	O
;	O
return	O
;	O
}	O
while	O
(	O
*	O
pvm	O
->	O
szName	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfile	O
,	O
"%s \t= "	*(char)
,	O
pvm	O
->	O
szName	*(char)
)	O
;	O
if	O
(	O
IsInput	(long)->(int)
(	O
pvm	O
->	O
hvar	long
)	O
)	O
{	O
PIFN	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
=	O
(	O
PIFN	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
)	O
pvm	O
->	O
pVar	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfile	O
,	O
"Mag=%g [Val=%g]\n"	*(char)
,	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dMag	double
,	O
pifn	*(struct(int,int,double,double,double,double,double,double,double,double,long,long,long,long,long,long,int,int,*(double),*(double),*(long),*(long),long,*(int)))
->	O
dVal	double
)	O
;	O
}	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
pfile	O
,	O
"%g\n"	*(char)
,	O
*	O
(	O
double	O
*	O
)	O
pvm	O
->	O
pVar	O
)	O
;	O
pvm	O
++	O
;	O
}	O
if	O
(	O
szFilename	*(char)
!=	O
szStderr	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
pfile	O
)	O
;	O
}	O
void	O
GetStateHandles	O
(	O
HVAR	long
*	O
phvar	*(long)
)	O
{	O
int	O
i	O
=	O
0	int
;	O
VMMAPSTRCT	O
*	O
pvm	O
=	O
vrgvmGlo	O
;	O
while	O
(	O
pvm	O
->	O
pVar	O
)	O
{	O
if	O
(	O
IsState	(long)->(int)
(	O
pvm	O
->	O
hvar	long
)	O
)	O
phvar	*(long)
[	O
i	O
++	O
]	O
=	O
pvm	O
->	O
hvar	long
;	O
++	O
pvm	O
;	O
}	O
;	O
}	O
