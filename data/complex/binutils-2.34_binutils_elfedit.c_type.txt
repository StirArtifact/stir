char	O
*	O
program_name	O
=	O
"elfedit"	*(char)
;	O
static	O
long	O
archive_file_offset	O
;	O
static	O
unsigned	O
long	O
archive_file_size	O
;	O
static	O
Elf_Internal_Ehdr	O
elf_header	O
;	O
static	O
Elf32_External_Ehdr	O
ehdr32	O
;	O
static	O
Elf64_External_Ehdr	O
ehdr64	O
;	O
static	O
int	O
input_elf_machine	O
=	O
-	O
1	int
;	O
static	O
int	O
output_elf_machine	O
=	O
-	O
1	int
;	O
static	O
int	O
input_elf_type	O
=	O
-	O
1	int
;	O
static	O
int	O
output_elf_type	O
=	O
-	O
1	int
;	O
static	O
int	O
input_elf_osabi	O
=	O
-	O
1	int
;	O
static	O
int	O
output_elf_osabi	O
=	O
-	O
1	int
;	O
enum	O
elfclass	O
{	O
ELF_CLASS_UNKNOWN	O
=	O
-	O
1	int
,	O
ELF_CLASS_NONE	O
=	O
ELFCLASSNONE	O
,	O
ELF_CLASS_32	O
=	O
ELFCLASS32	O
,	O
ELF_CLASS_64	O
=	O
ELFCLASS64	O
,	O
ELF_CLASS_BOTH	O
}	O
;	O
static	O
enum	O
elfclass	O
input_elf_class	O
=	O
ELF_CLASS_UNKNOWN	O
;	O
static	O
enum	O
elfclass	O
output_elf_class	O
=	O
ELF_CLASS_BOTH	O
;	O
static	O
unsigned	O
int	O
enable_x86_features	O
;	O
static	O
unsigned	O
int	O
disable_x86_features	O
;	O
static	O
int	O
update_gnu_property	O
(	O
const	O
char	O
*	O
file_name	O
,	O
FILE	struct
*	O
file	*(void)
)	O
{	O
char	O
*	O
map	O
;	O
Elf_Internal_Phdr	O
*	O
phdrs	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st_buf	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
int	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
if	O
(	O
!	O
enable_x86_features	O
&&	O
!	O
disable_x86_features	O
)	O
return	O
0	int
;	O
if	O
(	O
elf_header	O
.	O
e_machine	O
!=	O
EM_386	O
&&	O
elf_header	O
.	O
e_machine	O
!=	O
EM_X86_64	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Not an i386 nor x86-64 ELF file\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(void)
)	O
,	O
&	O
st_buf	O
)	O
<	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: stat () failed\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
return	O
1	int
;	O
}	O
map	O
=	O
mmap	O
(	O
NULL	O
,	O
st_buf	O
.	O
st_size	long
,	O
PROT_READ	O
|	O
PROT_WRITE	O
,	O
MAP_SHARED	O
,	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(void)
)	O
,	O
0	int
)	O
;	O
if	O
(	O
map	O
==	O
MAP_FAILED	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: mmap () failed\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
return	O
0	int
;	O
}	O
phdrs	O
=	O
xmalloc	O
(	O
elf_header	O
.	O
e_phnum	O
*	O
sizeof	O
(	O
*	O
phdrs	O
)	O
)	O
;	O
if	O
(	O
elf_header	O
.	O
e_ident	O
[	O
EI_CLASS	O
]	O
==	O
ELFCLASS32	O
)	O
{	O
Elf32_External_Phdr	O
*	O
phdrs32	O
=	O
(	O
Elf32_External_Phdr	O
*	O
)	O
(	O
map	O
+	O
elf_header	O
.	O
e_phoff	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
elf_header	O
.	O
e_phnum	O
;	O
i	*(struct)
++	O
)	O
{	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_type	O
=	O
BYTE_GET	O
(	O
phdrs32	O
[	O
i	*(struct)
]	O
.	O
p_type	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_offset	O
=	O
BYTE_GET	O
(	O
phdrs32	O
[	O
i	*(struct)
]	O
.	O
p_offset	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_vaddr	O
=	O
BYTE_GET	O
(	O
phdrs32	O
[	O
i	*(struct)
]	O
.	O
p_vaddr	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_paddr	O
=	O
BYTE_GET	O
(	O
phdrs32	O
[	O
i	*(struct)
]	O
.	O
p_paddr	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_filesz	O
=	O
BYTE_GET	O
(	O
phdrs32	O
[	O
i	*(struct)
]	O
.	O
p_filesz	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_memsz	O
=	O
BYTE_GET	O
(	O
phdrs32	O
[	O
i	*(struct)
]	O
.	O
p_memsz	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_flags	O
=	O
BYTE_GET	O
(	O
phdrs32	O
[	O
i	*(struct)
]	O
.	O
p_flags	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_align	O
=	O
BYTE_GET	O
(	O
phdrs32	O
[	O
i	*(struct)
]	O
.	O
p_align	O
)	O
;	O
}	O
}	O
else	O
{	O
Elf64_External_Phdr	O
*	O
phdrs64	O
=	O
(	O
Elf64_External_Phdr	O
*	O
)	O
(	O
map	O
+	O
elf_header	O
.	O
e_phoff	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
elf_header	O
.	O
e_phnum	O
;	O
i	*(struct)
++	O
)	O
{	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_type	O
=	O
BYTE_GET	O
(	O
phdrs64	O
[	O
i	*(struct)
]	O
.	O
p_type	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_offset	O
=	O
BYTE_GET	O
(	O
phdrs64	O
[	O
i	*(struct)
]	O
.	O
p_offset	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_vaddr	O
=	O
BYTE_GET	O
(	O
phdrs64	O
[	O
i	*(struct)
]	O
.	O
p_vaddr	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_paddr	O
=	O
BYTE_GET	O
(	O
phdrs64	O
[	O
i	*(struct)
]	O
.	O
p_paddr	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_filesz	O
=	O
BYTE_GET	O
(	O
phdrs64	O
[	O
i	*(struct)
]	O
.	O
p_filesz	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_memsz	O
=	O
BYTE_GET	O
(	O
phdrs64	O
[	O
i	*(struct)
]	O
.	O
p_memsz	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_flags	O
=	O
BYTE_GET	O
(	O
phdrs64	O
[	O
i	*(struct)
]	O
.	O
p_flags	O
)	O
;	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_align	O
=	O
BYTE_GET	O
(	O
phdrs64	O
[	O
i	*(struct)
]	O
.	O
p_align	O
)	O
;	O
}	O
}	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
0	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
elf_header	O
.	O
e_phnum	O
;	O
i	*(struct)
++	O
)	O
if	O
(	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_type	O
==	O
PT_NOTE	O
)	O
{	O
size_t	long
offset	long
=	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_offset	O
;	O
size_t	long
size	int
=	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_filesz	O
;	O
size_t	long
align	O
=	O
phdrs	O
[	O
i	*(struct)
]	O
.	O
p_align	O
;	O
char	O
*	O
buf	*(void)
=	O
map	O
+	O
offset	long
;	O
char	O
*	O
p	*(void)
=	O
buf	*(void)
;	O
while	O
(	O
p	*(void)
<	O
buf	*(void)
+	O
size	int
)	O
{	O
Elf_External_Note	O
*	O
xnp	O
=	O
(	O
Elf_External_Note	O
*	O
)	O
p	*(void)
;	O
Elf_Internal_Note	O
in	O
;	O
if	O
(	O
offsetof	O
(	O
Elf_External_Note	O
,	O
name	*(char)
)	O
>	O
buf	*(void)
-	O
p	*(void)
+	O
size	int
)	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
in	O
.	O
type	enum(int,int,int,int)
=	O
BYTE_GET	O
(	O
xnp	O
->	O
type	enum(int,int,int,int)
)	O
;	O
in	O
.	O
namesz	O
=	O
BYTE_GET	O
(	O
xnp	O
->	O
namesz	O
)	O
;	O
in	O
.	O
namedata	O
=	O
xnp	O
->	O
name	*(char)
;	O
if	O
(	O
in	O
.	O
namesz	O
>	O
buf	*(void)
-	O
in	O
.	O
namedata	O
+	O
size	int
)	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
in	O
.	O
descsz	O
=	O
BYTE_GET	O
(	O
xnp	O
->	O
descsz	O
)	O
;	O
in	O
.	O
descdata	O
=	O
p	*(void)
+	O
ELF_NOTE_DESC_OFFSET	O
(	O
in	O
.	O
namesz	O
,	O
align	O
)	O
;	O
in	O
.	O
descpos	O
=	O
offset	long
+	O
(	O
in	O
.	O
descdata	O
-	O
buf	*(void)
)	O
;	O
if	O
(	O
in	O
.	O
descsz	O
!=	O
0	int
&&	O
(	O
in	O
.	O
descdata	O
>=	O
buf	*(void)
+	O
size	int
||	O
in	O
.	O
descsz	O
>	O
buf	*(void)
-	O
in	O
.	O
descdata	O
+	O
size	int
)	O
)	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
in	O
.	O
namesz	O
==	O
sizeof	O
"GNU"	*(char)
&&	O
strcmp	(*(char),*(char))->(int)
(	O
in	O
.	O
namedata	O
,	O
"GNU"	*(char)
)	O
==	O
0	int
&&	O
in	O
.	O
type	enum(int,int,int,int)
==	O
NT_GNU_PROPERTY_TYPE_0	O
)	O
{	O
unsigned	O
char	O
*	O
ptr	*(*(char))
;	O
unsigned	O
char	O
*	O
ptr_end	O
;	O
if	O
(	O
in	O
.	O
descsz	O
<	O
8	int
||	O
(	O
in	O
.	O
descsz	O
%	O
align	O
)	O
!=	O
0	int
)	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
ptr	*(*(char))
=	O
(	O
unsigned	O
char	O
*	O
)	O
in	O
.	O
descdata	O
;	O
ptr_end	O
=	O
ptr	*(*(char))
+	O
in	O
.	O
descsz	O
;	O
do	O
{	O
unsigned	O
int	O
type	enum(int,int,int,int)
=	O
byte_get	O
(	O
ptr	*(*(char))
,	O
4	int
)	O
;	O
unsigned	O
int	O
datasz	O
=	O
byte_get	O
(	O
ptr	*(*(char))
+	O
4	int
,	O
4	int
)	O
;	O
unsigned	O
int	O
bitmask	O
,	O
old_bitmask	O
;	O
ptr	*(*(char))
+=	O
8	int
;	O
if	O
(	O
(	O
ptr	*(*(char))
+	O
datasz	O
)	O
>	O
ptr_end	O
)	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
if	O
(	O
type	enum(int,int,int,int)
==	O
GNU_PROPERTY_X86_FEATURE_1_AND	O
)	O
{	O
if	O
(	O
datasz	O
!=	O
4	int
)	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
old_bitmask	O
=	O
byte_get	O
(	O
ptr	*(*(char))
,	O
4	int
)	O
;	O
bitmask	O
=	O
old_bitmask	O
;	O
if	O
(	O
enable_x86_features	O
)	O
bitmask	O
|=	O
enable_x86_features	O
;	O
if	O
(	O
disable_x86_features	O
)	O
bitmask	O
&=	O
~	O
disable_x86_features	O
;	O
if	O
(	O
old_bitmask	O
!=	O
bitmask	O
)	O
byte_put	O
(	O
ptr	*(*(char))
,	O
bitmask	O
,	O
4	int
)	O
;	O
goto	O
out	O
;	O
}	O
ptr	*(*(char))
+=	O
ELF_ALIGN_UP	O
(	O
datasz	O
,	O
align	O
)	O
;	O
}	O
while	O
(	O
(	O
ptr_end	O
-	O
ptr	*(*(char))
)	O
>=	O
8	int
)	O
;	O
}	O
p	*(void)
+=	O
ELF_NOTE_NEXT_OFFSET	O
(	O
in	O
.	O
namesz	O
,	O
in	O
.	O
descsz	O
,	O
align	O
)	O
;	O
}	O
}	O
out	O
:	O
if	O
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
!=	O
0	int
)	O
error	O
(	O
_	O
(	O
"%s: Invalid PT_NOTE segment\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
free	(*(void))->(void)
(	O
phdrs	O
)	O
;	O
munmap	O
(	O
map	O
,	O
st_buf	O
.	O
st_size	long
)	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
static	O
int	O
elf_x86_feature	O
(	O
const	O
char	O
*	O
feature	O
,	O
int	O
enable	O
)	O
{	O
unsigned	O
int	O
x86_feature	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
feature	O
,	O
"ibt"	*(char)
)	O
==	O
0	int
)	O
x86_feature	O
=	O
GNU_PROPERTY_X86_FEATURE_1_IBT	O
;	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
feature	O
,	O
"shstk"	*(char)
)	O
==	O
0	int
)	O
x86_feature	O
=	O
GNU_PROPERTY_X86_FEATURE_1_SHSTK	O
;	O
else	O
{	O
error	O
(	O
_	O
(	O
"Unknown x86 feature: %s\n"	*(char)
)	O
,	O
feature	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
enable	O
)	O
{	O
enable_x86_features	O
|=	O
x86_feature	O
;	O
disable_x86_features	O
&=	O
~	O
x86_feature	O
;	O
}	O
else	O
{	O
disable_x86_features	O
|=	O
x86_feature	O
;	O
enable_x86_features	O
&=	O
~	O
x86_feature	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
enum	O
elfclass	O
elf_class	O
(	O
int	O
mach	long
)	O
{	O
switch	O
(	O
mach	long
)	O
{	O
case	O
EM_386	O
:	O
case	O
EM_IAMCU	O
:	O
return	O
ELF_CLASS_32	O
;	O
case	O
EM_L1OM	O
:	O
case	O
EM_K1OM	O
:	O
return	O
ELF_CLASS_64	O
;	O
case	O
EM_X86_64	O
:	O
case	O
EM_NONE	O
:	O
return	O
ELF_CLASS_BOTH	O
;	O
default	O
:	O
return	O
ELF_CLASS_BOTH	O
;	O
}	O
}	O
static	O
int	O
update_elf_header	O
(	O
const	O
char	O
*	O
file_name	O
,	O
FILE	struct
*	O
file	*(void)
)	O
{	O
int	O
class	O
,	O
machine	long
,	O
type	enum(int,int,int,int)
,	O
status	O
,	O
osabi	O
;	O
if	O
(	O
elf_header	O
.	O
e_ident	O
[	O
EI_VERSION	O
]	O
!=	O
EV_CURRENT	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Unsupported EI_VERSION: %d is not %d\n"	*(char)
)	O
,	O
file_name	O
,	O
elf_header	O
.	O
e_ident	O
[	O
EI_VERSION	O
]	O
,	O
EV_CURRENT	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
output_elf_machine	O
==	O
elf_header	O
.	O
e_machine	O
)	O
return	O
1	int
;	O
class	O
=	O
elf_header	O
.	O
e_ident	O
[	O
EI_CLASS	O
]	O
;	O
machine	long
=	O
elf_header	O
.	O
e_machine	O
;	O
if	O
(	O
input_elf_class	O
==	O
ELF_CLASS_UNKNOWN	O
)	O
input_elf_class	O
=	O
elf_class	O
(	O
machine	long
)	O
;	O
if	O
(	O
input_elf_class	O
!=	O
ELF_CLASS_BOTH	O
&&	O
(	O
int	O
)	O
input_elf_class	O
!=	O
class	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Unmatched input EI_CLASS: %d is not %d\n"	*(char)
)	O
,	O
file_name	O
,	O
class	O
,	O
input_elf_class	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
output_elf_class	O
!=	O
ELF_CLASS_BOTH	O
&&	O
(	O
int	O
)	O
output_elf_class	O
!=	O
class	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Unmatched output EI_CLASS: %d is not %d\n"	*(char)
)	O
,	O
file_name	O
,	O
class	O
,	O
output_elf_class	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
input_elf_machine	O
!=	O
-	O
1	int
&&	O
machine	long
!=	O
input_elf_machine	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Unmatched e_machine: %d is not %d\n"	*(char)
)	O
,	O
file_name	O
,	O
machine	long
,	O
input_elf_machine	O
)	O
;	O
return	O
0	int
;	O
}	O
type	enum(int,int,int,int)
=	O
elf_header	O
.	O
e_type	O
;	O
if	O
(	O
input_elf_type	O
!=	O
-	O
1	int
&&	O
type	enum(int,int,int,int)
!=	O
input_elf_type	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Unmatched e_type: %d is not %d\n"	*(char)
)	O
,	O
file_name	O
,	O
type	enum(int,int,int,int)
,	O
input_elf_type	O
)	O
;	O
return	O
0	int
;	O
}	O
osabi	O
=	O
elf_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
;	O
if	O
(	O
input_elf_osabi	O
!=	O
-	O
1	int
&&	O
osabi	O
!=	O
input_elf_osabi	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Unmatched EI_OSABI: %d is not %d\n"	*(char)
)	O
,	O
file_name	O
,	O
osabi	O
,	O
input_elf_osabi	O
)	O
;	O
return	O
0	int
;	O
}	O
switch	O
(	O
class	O
)	O
{	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
ELFCLASS32	O
:	O
if	O
(	O
output_elf_machine	O
!=	O
-	O
1	int
)	O
BYTE_PUT	O
(	O
ehdr32	O
.	O
e_machine	O
,	O
output_elf_machine	O
)	O
;	O
if	O
(	O
output_elf_type	O
!=	O
-	O
1	int
)	O
BYTE_PUT	O
(	O
ehdr32	O
.	O
e_type	O
,	O
output_elf_type	O
)	O
;	O
if	O
(	O
output_elf_osabi	O
!=	O
-	O
1	int
)	O
ehdr32	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
=	O
output_elf_osabi	O
;	O
status	O
=	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
ehdr32	O
,	O
sizeof	O
(	O
ehdr32	O
)	O
,	O
1	int
,	O
file	*(void)
)	O
==	O
1	int
;	O
break	O
;	O
case	O
ELFCLASS64	O
:	O
if	O
(	O
output_elf_machine	O
!=	O
-	O
1	int
)	O
BYTE_PUT	O
(	O
ehdr64	O
.	O
e_machine	O
,	O
output_elf_machine	O
)	O
;	O
if	O
(	O
output_elf_type	O
!=	O
-	O
1	int
)	O
BYTE_PUT	O
(	O
ehdr64	O
.	O
e_type	O
,	O
output_elf_type	O
)	O
;	O
if	O
(	O
output_elf_osabi	O
!=	O
-	O
1	int
)	O
ehdr64	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
=	O
output_elf_osabi	O
;	O
status	O
=	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
ehdr64	O
,	O
sizeof	O
(	O
ehdr64	O
)	O
,	O
1	int
,	O
file	*(void)
)	O
==	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
status	O
!=	O
1	int
)	O
error	O
(	O
_	O
(	O
"%s: Failed to update ELF header: %s\n"	*(char)
)	O
,	O
file_name	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
status	O
;	O
}	O
static	O
int	O
get_file_header	O
(	O
FILE	struct
*	O
file	*(void)
)	O
{	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
elf_header	O
.	O
e_ident	O
,	O
EI_NIDENT	O
,	O
1	int
,	O
file	*(void)
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
elf_header	O
.	O
e_ident	O
[	O
EI_MAG0	O
]	O
!=	O
ELFMAG0	O
||	O
elf_header	O
.	O
e_ident	O
[	O
EI_MAG1	O
]	O
!=	O
ELFMAG1	O
||	O
elf_header	O
.	O
e_ident	O
[	O
EI_MAG2	O
]	O
!=	O
ELFMAG2	O
||	O
elf_header	O
.	O
e_ident	O
[	O
EI_MAG3	O
]	O
!=	O
ELFMAG3	O
)	O
return	O
0	int
;	O
switch	O
(	O
elf_header	O
.	O
e_ident	O
[	O
EI_DATA	O
]	O
)	O
{	O
default	O
:	O
case	O
ELFDATANONE	O
:	O
case	O
ELFDATA2LSB	O
:	O
byte_get	O
=	O
byte_get_little_endian	O
;	O
byte_put	O
=	O
byte_put_little_endian	O
;	O
break	O
;	O
case	O
ELFDATA2MSB	O
:	O
byte_get	O
=	O
byte_get_big_endian	O
;	O
byte_put	O
=	O
byte_put_big_endian	O
;	O
break	O
;	O
}	O
switch	O
(	O
elf_header	O
.	O
e_ident	O
[	O
EI_CLASS	O
]	O
)	O
{	O
default	O
:	O
return	O
0	int
;	O
case	O
ELFCLASS32	O
:	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
ehdr32	O
.	O
e_type	O
,	O
sizeof	O
(	O
ehdr32	O
)	O
-	O
EI_NIDENT	O
,	O
1	int
,	O
file	*(void)
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
elf_header	O
.	O
e_type	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_type	O
)	O
;	O
elf_header	O
.	O
e_machine	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_machine	O
)	O
;	O
elf_header	O
.	O
e_version	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_version	O
)	O
;	O
elf_header	O
.	O
e_entry	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_entry	O
)	O
;	O
elf_header	O
.	O
e_phoff	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_phoff	O
)	O
;	O
elf_header	O
.	O
e_shoff	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_shoff	O
)	O
;	O
elf_header	O
.	O
e_flags	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_flags	O
)	O
;	O
elf_header	O
.	O
e_ehsize	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_ehsize	O
)	O
;	O
elf_header	O
.	O
e_phentsize	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_phentsize	O
)	O
;	O
elf_header	O
.	O
e_phnum	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_phnum	O
)	O
;	O
elf_header	O
.	O
e_shentsize	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_shentsize	O
)	O
;	O
elf_header	O
.	O
e_shnum	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_shnum	O
)	O
;	O
elf_header	O
.	O
e_shstrndx	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_shstrndx	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
ehdr32	O
,	O
&	O
elf_header	O
,	O
EI_NIDENT	O
)	O
;	O
break	O
;	O
case	O
ELFCLASS64	O
:	O
if	O
(	O
sizeof	O
(	O
bfd_vma	long
)	O
<	O
8	int
)	O
{	O
error	O
(	O
_	O
(	O
"This executable has been built without support for a\n64 bit data type and so it cannot process 64 bit ELF files.\n"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
ehdr64	O
.	O
e_type	O
,	O
sizeof	O
(	O
ehdr64	O
)	O
-	O
EI_NIDENT	O
,	O
1	int
,	O
file	*(void)
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
elf_header	O
.	O
e_type	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_type	O
)	O
;	O
elf_header	O
.	O
e_machine	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_machine	O
)	O
;	O
elf_header	O
.	O
e_version	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_version	O
)	O
;	O
elf_header	O
.	O
e_entry	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_entry	O
)	O
;	O
elf_header	O
.	O
e_phoff	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_phoff	O
)	O
;	O
elf_header	O
.	O
e_shoff	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_shoff	O
)	O
;	O
elf_header	O
.	O
e_flags	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_flags	O
)	O
;	O
elf_header	O
.	O
e_ehsize	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_ehsize	O
)	O
;	O
elf_header	O
.	O
e_phentsize	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_phentsize	O
)	O
;	O
elf_header	O
.	O
e_phnum	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_phnum	O
)	O
;	O
elf_header	O
.	O
e_shentsize	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_shentsize	O
)	O
;	O
elf_header	O
.	O
e_shnum	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_shnum	O
)	O
;	O
elf_header	O
.	O
e_shstrndx	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_shstrndx	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
ehdr64	O
,	O
&	O
elf_header	O
,	O
EI_NIDENT	O
)	O
;	O
break	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
process_object	O
(	O
const	O
char	O
*	O
file_name	O
,	O
FILE	struct
*	O
file	*(void)
)	O
{	O
long	O
offset	long
=	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
file	*(void)
)	O
;	O
if	O
(	O
!	O
get_file_header	O
(	O
file	*(void)
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Failed to read ELF header\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
file	*(void)
,	O
offset	long
,	O
SEEK_SET	O
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Failed to seek to ELF header\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
}	O
if	O
(	O
!	O
update_elf_header	O
(	O
file_name	O
,	O
file	*(void)
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
process_archive	O
(	O
const	O
char	O
*	O
file_name	O
,	O
FILE	struct
*	O
file	*(void)
,	O
bfd_boolean	int
is_thin_archive	int
)	O
{	O
struct	O
archive_info	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
struct	O
archive_info	O
nested_arch	O
;	O
size_t	long
got	O
;	O
int	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
file_name	O
=	O
NULL	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
file	*(void)
=	O
NULL	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
index_array	O
=	O
NULL	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_table	O
=	O
NULL	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
longnames	O
=	O
NULL	O
;	O
nested_arch	O
.	O
file_name	O
=	O
NULL	O
;	O
nested_arch	O
.	O
file	*(void)
=	O
NULL	O
;	O
nested_arch	O
.	O
index_array	O
=	O
NULL	O
;	O
nested_arch	O
.	O
sym_table	O
=	O
NULL	O
;	O
nested_arch	O
.	O
longnames	O
=	O
NULL	O
;	O
if	O
(	O
setup_archive	O
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
file_name	O
,	O
file	*(void)
,	O
is_thin_archive	int
,	O
FALSE	O
)	O
!=	O
0	int
)	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
goto	O
out	O
;	O
}	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
name	*(char)
;	O
size_t	long
namelen	O
;	O
char	O
*	O
qualified_name	O
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
file	*(void)
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
next_arhdr_offset	O
,	O
SEEK_SET	O
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to seek to next archive header\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
return	O
1	int
;	O
}	O
got	O
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
,	O
1	int
,	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
,	O
file	*(void)
)	O
;	O
if	O
(	O
got	O
!=	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
)	O
{	O
if	O
(	O
got	O
==	O
0	int
)	O
break	O
;	O
error	O
(	O
_	O
(	O
"%s: failed to read archive header\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
.	O
ar_fmag	O
,	O
ARFMAG	O
,	O
2	int
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: did not find a valid archive header\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
break	O
;	O
}	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
next_arhdr_offset	O
+=	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
;	O
archive_file_size	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
.	O
ar_size	O
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
archive_file_size	O
&	O
01	int
)	O
++	O
archive_file_size	O
;	O
name	*(char)
=	O
get_archive_member_name	O
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
nested_arch	O
)	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: bad archive file name\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
break	O
;	O
}	O
namelen	O
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
qualified_name	O
=	O
make_qualified_name	O
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
nested_arch	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
qualified_name	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: bad archive file name\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
is_thin_archive	int
&&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
nested_member_origin	O
==	O
0	int
)	O
{	O
FILE	struct
*	O
member_file	O
;	O
char	O
*	O
member_file_name	O
=	O
adjust_relative_path	O
(	O
file_name	O
,	O
name	*(char)
,	O
namelen	O
)	O
;	O
if	O
(	O
member_file_name	O
==	O
NULL	O
)	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
break	O
;	O
}	O
member_file	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
member_file_name	O
,	O
"r+b"	*(char)
)	O
;	O
if	O
(	O
member_file	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Input file '%s' is not readable\n"	*(char)
)	O
,	O
member_file_name	O
)	O
;	O
free	(*(void))->(void)
(	O
member_file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
break	O
;	O
}	O
archive_file_offset	O
=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
nested_member_origin	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
|=	O
process_object	O
(	O
qualified_name	O
,	O
member_file	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
member_file	O
)	O
;	O
free	(*(void))->(void)
(	O
member_file_name	O
)	O
;	O
}	O
else	O
if	O
(	O
is_thin_archive	int
)	O
{	O
archive_file_offset	O
=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
nested_member_origin	O
+	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
nested_arch	O
.	O
file	*(void)
,	O
archive_file_offset	O
,	O
SEEK_SET	O
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to seek to archive member\n"	*(char)
)	O
,	O
nested_arch	O
.	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
1	int
;	O
break	O
;	O
}	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
|=	O
process_object	O
(	O
qualified_name	O
,	O
nested_arch	O
.	O
file	*(void)
)	O
;	O
}	O
else	O
{	O
archive_file_offset	O
=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
next_arhdr_offset	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
next_arhdr_offset	O
+=	O
archive_file_size	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
|=	O
process_object	O
(	O
qualified_name	O
,	O
file	*(void)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
qualified_name	O
)	O
;	O
}	O
out	O
:	O
if	O
(	O
nested_arch	O
.	O
file	*(void)
!=	O
NULL	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
nested_arch	O
.	O
file	*(void)
)	O
;	O
release_archive	O
(	O
&	O
nested_arch	O
)	O
;	O
release_archive	O
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
static	O
int	O
check_file	O
(	O
const	O
char	O
*	O
file_name	O
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
statbuf_p	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	O
;	O
if	O
(	O
statbuf_p	O
==	O
NULL	O
)	O
statbuf_p	O
=	O
&	O
statbuf	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
file_name	O
,	O
statbuf_p	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	O
)	O
error	O
(	O
_	O
(	O
"'%s': No such file\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
else	O
error	O
(	O
_	O
(	O
"Could not locate '%s'.  System error message: %s\n"	*(char)
)	O
,	O
file_name	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
statbuf_p	O
->	O
st_mode	int
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"'%s' is not an ordinary file\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
process_file	O
(	O
const	O
char	O
*	O
file_name	O
)	O
{	O
FILE	struct
*	O
file	*(void)
;	O
char	O
armag	O
[	O
SARMAG	O
]	O
;	O
int	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
if	O
(	O
check_file	O
(	O
file_name	O
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
file	*(void)
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file_name	O
,	O
"r+b"	*(char)
)	O
;	O
if	O
(	O
file	*(void)
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Input file '%s' is not readable\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
armag	O
,	O
SARMAG	O
,	O
1	int
,	O
file	*(void)
)	O
!=	O
1	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Failed to read file's magic number\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
armag	O
,	O
ARMAG	O
,	O
SARMAG	O
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
process_archive	O
(	O
file_name	O
,	O
file	*(void)
,	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
armag	O
,	O
ARMAGT	O
,	O
SARMAG	O
)	O
==	O
0	int
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
process_archive	O
(	O
file_name	O
,	O
file	*(void)
,	O
TRUE	int
)	O
;	O
else	O
{	O
rewind	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
file	*(void)
)	O
;	O
archive_file_size	O
=	O
archive_file_offset	O
=	O
0	int
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
process_object	O
(	O
file_name	O
,	O
file	*(void)
)	O
;	O
if	O
(	O
!	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
&&	O
(	O
elf_header	O
.	O
e_type	O
==	O
ET_EXEC	O
||	O
elf_header	O
.	O
e_type	O
==	O
ET_DYN	O
)	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
update_gnu_property	O
(	O
file_name	O
,	O
file	*(void)
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(void)
)	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
static	O
const	O
struct	O
{	O
int	O
osabi	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
}	O
osabis	O
[	O
]	O
=	O
{	O
{	O
ELFOSABI_NONE	O
,	O
"none"	*(char)
}	O
,	O
{	O
ELFOSABI_HPUX	O
,	O
"HPUX"	*(char)
}	O
,	O
{	O
ELFOSABI_NETBSD	O
,	O
"NetBSD"	*(char)
}	O
,	O
{	O
ELFOSABI_GNU	O
,	O
"GNU"	*(char)
}	O
,	O
{	O
ELFOSABI_GNU	O
,	O
"Linux"	*(char)
}	O
,	O
{	O
ELFOSABI_SOLARIS	O
,	O
"Solaris"	*(char)
}	O
,	O
{	O
ELFOSABI_AIX	O
,	O
"AIX"	*(char)
}	O
,	O
{	O
ELFOSABI_IRIX	O
,	O
"Irix"	*(char)
}	O
,	O
{	O
ELFOSABI_FREEBSD	O
,	O
"FreeBSD"	*(char)
}	O
,	O
{	O
ELFOSABI_TRU64	O
,	O
"TRU64"	*(char)
}	O
,	O
{	O
ELFOSABI_MODESTO	O
,	O
"Modesto"	*(char)
}	O
,	O
{	O
ELFOSABI_OPENBSD	O
,	O
"OpenBSD"	*(char)
}	O
,	O
{	O
ELFOSABI_OPENVMS	O
,	O
"OpenVMS"	*(char)
}	O
,	O
{	O
ELFOSABI_NSK	O
,	O
"NSK"	*(char)
}	O
,	O
{	O
ELFOSABI_AROS	O
,	O
"AROS"	*(char)
}	O
,	O
{	O
ELFOSABI_FENIXOS	O
,	O
"FenixOS"	*(char)
}	O
}	O
;	O
static	O
int	O
elf_osabi	O
(	O
const	O
char	O
*	O
osabi	O
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
ARRAY_SIZE	O
(	O
osabis	O
)	O
;	O
i	*(struct)
++	O
)	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
osabi	O
,	O
osabis	O
[	O
i	*(struct)
]	O
.	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
osabis	O
[	O
i	*(struct)
]	O
.	O
osabi	O
;	O
error	O
(	O
_	O
(	O
"Unknown OSABI: %s\n"	*(char)
)	O
,	O
osabi	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
elf_machine	O
(	O
const	O
char	O
*	O
mach	long
)	O
{	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
mach	long
,	O
"i386"	*(char)
)	O
==	O
0	int
)	O
return	O
EM_386	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
mach	long
,	O
"iamcu"	*(char)
)	O
==	O
0	int
)	O
return	O
EM_IAMCU	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
mach	long
,	O
"l1om"	*(char)
)	O
==	O
0	int
)	O
return	O
EM_L1OM	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
mach	long
,	O
"k1om"	*(char)
)	O
==	O
0	int
)	O
return	O
EM_K1OM	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
mach	long
,	O
"x86_64"	*(char)
)	O
==	O
0	int
)	O
return	O
EM_X86_64	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
mach	long
,	O
"x86-64"	*(char)
)	O
==	O
0	int
)	O
return	O
EM_X86_64	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
mach	long
,	O
"none"	*(char)
)	O
==	O
0	int
)	O
return	O
EM_NONE	O
;	O
error	O
(	O
_	O
(	O
"Unknown machine type: %s\n"	*(char)
)	O
,	O
mach	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
elf_type	O
(	O
const	O
char	O
*	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
type	enum(int,int,int,int)
,	O
"rel"	*(char)
)	O
==	O
0	int
)	O
return	O
ET_REL	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
type	enum(int,int,int,int)
,	O
"exec"	*(char)
)	O
==	O
0	int
)	O
return	O
ET_EXEC	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
type	enum(int,int,int,int)
,	O
"dyn"	*(char)
)	O
==	O
0	int
)	O
return	O
ET_DYN	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
type	enum(int,int,int,int)
,	O
"none"	*(char)
)	O
==	O
0	int
)	O
return	O
ET_NONE	O
;	O
error	O
(	O
_	O
(	O
"Unknown type: %s\n"	*(char)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
enum	O
command_line_switch	O
{	O
OPTION_INPUT_MACH	O
=	O
150	int
,	O
OPTION_OUTPUT_MACH	O
,	O
OPTION_INPUT_TYPE	O
,	O
OPTION_OUTPUT_TYPE	O
,	O
OPTION_INPUT_OSABI	O
,	O
OPTION_OUTPUT_OSABI	O
,	O
OPTION_ENABLE_X86_FEATURE	O
,	O
OPTION_DISABLE_X86_FEATURE	O
,	O
}	O
;	O
static	O
struct	O
option	O
options	O
[	O
]	O
=	O
{	O
{	O
"input-mach"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_INPUT_MACH	O
}	O
,	O
{	O
"output-mach"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_OUTPUT_MACH	O
}	O
,	O
{	O
"input-type"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_INPUT_TYPE	O
}	O
,	O
{	O
"output-type"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_OUTPUT_TYPE	O
}	O
,	O
{	O
"input-osabi"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_INPUT_OSABI	O
}	O
,	O
{	O
"output-osabi"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_OUTPUT_OSABI	O
}	O
,	O
{	O
"enable-x86-feature"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_ENABLE_X86_FEATURE	O
}	O
,	O
{	O
"disable-x86-feature"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_DISABLE_X86_FEATURE	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
0	int
,	O
no_argument	O
,	O
0	int
,	O
0	int
}	O
}	O
;	O
ATTRIBUTE_NORETURN	O
static	O
void	O
usage	O
(	O
FILE	struct
*	O
stream	*(void)
,	O
int	O
exit_status	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
"Usage: %s <option(s)> elffile(s)\n"	*(char)
)	O
,	O
program_name	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
" Update the ELF header of ELF files\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
" The options are:\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
"  --input-mach <machine>      Set input machine type to <machine>\n  --output-mach <machine>     Set output machine type to <machine>\n  --input-type <type>         Set input file type to <type>\n  --output-type <type>        Set output file type to <type>\n  --input-osabi <osabi>       Set input OSABI to <osabi>\n  --output-osabi <osabi>      Set output OSABI to <osabi>\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
"  --enable-x86-feature <feature>\n                              Enable x86 feature <feature>\n  --disable-x86-feature <feature>\n                              Disable x86 feature <feature>\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
"  -h --help                   Display this information\n  -v --version                Display the version number of %s\n"	*(char)
)	O
,	O
program_name	O
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	O
[	O
0	int
]	O
&&	O
exit_status	O
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
"Report bugs to %s\n"	*(char)
)	O
,	O
REPORT_BUGS_TO	O
)	O
;	O
exit	(int)->(void)
(	O
exit_status	O
)	O
;	O
}	O
int	O
main	O
(	O
int	O
argc	O
,	O
char	O
*	O
*	O
argv	O
)	O
{	O
int	O
c	O
,	O
status	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_MESSAGES	O
,	O
""	*(char)
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_CTYPE	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	O
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	O
)	O
;	O
expandargv	O
(	O
&	O
argc	O
,	O
&	O
argv	O
)	O
;	O
while	O
(	O
(	O
c	O
=	O
getopt_long	O
(	O
argc	O
,	O
argv	O
,	O
"hv"	*(char)
,	O
options	O
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	O
)	O
{	O
case	O
OPTION_INPUT_MACH	O
:	O
input_elf_machine	O
=	O
elf_machine	O
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
input_elf_machine	O
<	O
0	int
)	O
return	O
1	int
;	O
input_elf_class	O
=	O
elf_class	O
(	O
input_elf_machine	O
)	O
;	O
if	O
(	O
input_elf_class	O
==	O
ELF_CLASS_UNKNOWN	O
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_OUTPUT_MACH	O
:	O
output_elf_machine	O
=	O
elf_machine	O
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
output_elf_machine	O
<	O
0	int
)	O
return	O
1	int
;	O
output_elf_class	O
=	O
elf_class	O
(	O
output_elf_machine	O
)	O
;	O
if	O
(	O
output_elf_class	O
==	O
ELF_CLASS_UNKNOWN	O
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_INPUT_TYPE	O
:	O
input_elf_type	O
=	O
elf_type	O
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
input_elf_type	O
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_OUTPUT_TYPE	O
:	O
output_elf_type	O
=	O
elf_type	O
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
output_elf_type	O
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_INPUT_OSABI	O
:	O
input_elf_osabi	O
=	O
elf_osabi	O
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
input_elf_osabi	O
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_OUTPUT_OSABI	O
:	O
output_elf_osabi	O
=	O
elf_osabi	O
(	O
optarg	*(char)
)	O
;	O
if	O
(	O
output_elf_osabi	O
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_ENABLE_X86_FEATURE	O
:	O
if	O
(	O
elf_x86_feature	O
(	O
optarg	*(char)
,	O
1	int
)	O
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
OPTION_DISABLE_X86_FEATURE	O
:	O
if	O
(	O
elf_x86_feature	O
(	O
optarg	*(char)
,	O
0	int
)	O
<	O
0	int
)	O
return	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	O
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
)	O
;	O
case	O
'v'	O
:	O
print_version	O
(	O
program_name	O
)	O
;	O
break	O
;	O
default	O
:	O
usage	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
optind	int
==	O
argc	O
||	O
(	O
output_elf_machine	O
==	O
-	O
1	int
&&	O
!	O
enable_x86_features	O
&&	O
!	O
disable_x86_features	O
&&	O
output_elf_type	O
==	O
-	O
1	int
&&	O
output_elf_osabi	O
==	O
-	O
1	int
)	O
)	O
usage	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
1	int
)	O
;	O
status	O
=	O
0	int
;	O
while	O
(	O
optind	int
<	O
argc	O
)	O
status	O
|=	O
process_file	O
(	O
argv	O
[	O
optind	int
++	O
]	O
)	O
;	O
return	O
status	O
;	O
}	O
