OBJID	long
EDMAPROC	O
_edma_newobj_basic_stage	(long,long,*(void))->(long)
(	O
CLASSID	long
IdC	long
,	O
CLASSID	long
isSIU	long
,	O
EPVoid	*(void)
ConstPar	*(void)
)	O
{	O
EUint32	long
i	long
;	O
OBJID	long
IdO	long
;	O
HMEM	long
h	long
;	O
if	O
(	O
ProcMapTable	*(char)
[	O
IdC	long
]	O
!=	O
CLASS_LOADED	int
)	O
if	O
(	O
(	O
edma_load_class_imp	(long)->(long)
(	O
IdC	long
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[new_obj_basic_stage] Can't load "	*(char)
"class '%s' implementation"	*(char)
,	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array(char)
)	O
;	O
pthread_mutex_lock	(*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))->(int)
(	O
&	O
obj_mutex	union(struct(int,int,int,int,int,union(struct(short,short),struct(*(struct`)))),array(char),long)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nMaxObj	long
;	O
i	long
++	O
)	O
if	O
(	O
gObj	O
[	O
(	O
nObj	long
+	O
i	long
)	O
%	O
nMaxObj	long
]	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
nMaxObj	long
)	O
{	O
if	O
(	O
(	O
hSObj	long
=	O
edma_prealloc	(long,long)->(long)
(	O
hSObj	long
,	O
sizeof	O
(	O
OBJ	struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*`,*`,*`)))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))
*	O
)	O
*	O
(	O
nMaxObj	long
+	O
OBJ_INC	int
)	O
)	O
)	O
==	O
(	O
HMEM	long
)	O
0	int
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))->(int)
(	O
&	O
obj_mutex	union(struct(int,int,int,int,int,union(struct(short,short),struct(*(struct`)))),array(char),long)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_new_obj_basic_stage] "	*(char)
"Can't create more objects"	*(char)
)	O
;	O
}	O
SObject	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
=	O
edma_pget	(long)->(*(void))
(	O
hSObj	long
)	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
(	O
SObject	*(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))
+	O
nMaxObj	long
)	O
,	O
0	int
,	O
OBJ_INC	int
*	O
sizeof	O
(	O
OBJ	struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*`,*`,*`)))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))
*	O
)	O
)	O
;	O
i	long
=	O
nMaxObj	long
;	O
nMaxObj	long
=	O
nMaxObj	long
+	O
OBJ_INC	int
;	O
edma_printf	(*(char))->(long)
(	O
"[INFO] Object table extended to %d Objects"	*(char)
,	O
nMaxObj	long
)	O
;	O
}	O
IdO	long
=	O
(	O
nObj	long
+	O
i	long
)	O
%	O
nMaxObj	long
;	O
if	O
(	O
(	O
gObj	O
[	O
IdO	long
]	O
=	O
(	O
OBJ	struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*`,*`,*`)))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))
*	O
)	O
malloc	(int)->(*(void))
(	O
sizeof	O
(	O
OBJ	struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*`,*`,*`)))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))->(int)
(	O
&	O
obj_mutex	union(struct(int,int,int,int,int,union(struct(short,short),struct(*(struct`)))),array(char),long)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_new_obj_basic_stage}"	*(char)
"Can't alloc memory for object struct"	*(char)
)	O
;	O
}	O
pthread_mutex_unlock	(*(union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long)))->(int)
(	O
&	O
obj_mutex	union(struct(int,int,int,int,int,union(struct(short,short),struct(*(struct`)))),array(char),long)
)	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
gObj	O
[	O
IdO	long
]	O
,	O
0	int
,	O
sizeof	O
(	O
OBJ	struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*`,*`,*`)))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))
)	O
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
Flag	char
=	O
OBJ_LOCKED	int
;	O
h	long
=	O
edma_palloc	(long)->(long)
(	O
gClass	O
[	O
IdC	long
]	O
->	O
TamDatos	long
)	O
;	O
if	O
(	O
h	long
==	O
(	O
HMEM	long
)	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
gObj	O
[	O
IdO	long
]	O
)	O
;	O
gObj	O
[	O
IdO	long
]	O
=	O
NULL	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_new_obj_basic_stage "	*(char)
"Can't create local storage for object"	*(char)
)	O
;	O
}	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hData	long
=	O
h	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
Data	*(void)
=	O
(	O
EPVoid	*(void)
)	O
edma_pget	(long)->(*(void))
(	O
h	long
)	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
gObj	O
[	O
IdO	long
]	O
->	O
Data	*(void)
,	O
0	int
,	O
gClass	O
[	O
IdC	long
]	O
->	O
TamDatos	long
)	O
;	O
edma_log	(*(char))->(long)
(	O
"Allocated %d bytes for object of class '%s':%d at %p"	*(char)
,	O
gClass	O
[	O
IdC	long
]	O
->	O
TamDatos	long
,	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array(char)
,	O
IdC	long
,	O
gObj	O
[	O
IdO	long
]	O
->	O
Data	*(void)
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
IdObj	long
=	O
IdO	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
=	O
IdC	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
IdApp	long
=	O
AppId	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
Father	long
=	O
-	O
1	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
PseudiFather	long
=	O
-	O
1	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
Flag	char
=	O
OBJ_EXIST	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
IdSIU	long
=	O
isSIU	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
Final	char
=	O
0	int
;	O
nObj	long
++	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
nUpTable	long
=	O
0	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
nDownTable	long
=	O
0	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
=	O
0	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hDownTable	long
=	O
0	int
;	O
return	O
IdO	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_newobj_vm_stage	(long)->(long)
(	O
OBJID	long
IdO	long
)	O
{	O
CLASSID	long
IdC	long
;	O
EUint32	long
i	long
,	O
j	long
;	O
IdC	long
=	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
gClass	O
[	O
IdC	long
]	O
->	O
nMetVir	long
)	O
{	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hvTable	long
=	O
edma_palloc	(long)->(long)
(	O
gClass	O
[	O
IdC	long
]	O
->	O
nMetVir	long
*	O
sizeof	O
(	O
PMetVir	struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*`,*`,*`)))))
)	O
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
=	O
(	O
PMetVir	struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*`,*`,*`)))))
*	O
)	O
edma_pget	(long)->(*(void))
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hvTable	long
)	O
;	O
if	O
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hvTable	long
==	O
0	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_new_obj_vm_stage] "	*(char)
"Can't allocate virtual table"	*(char)
)	O
;	O
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
{	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
Virtual	char
)	O
{	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
j	long
]	O
.	O
Ind	long
=	O
i	long
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
(	O
char	O
*	O
)	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
j	long
]	O
.	O
Id	*(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
IdMet	array(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
j	long
]	O
.	O
Func	*(()->(long))
=	O
(	O
PPROC	*(()->(long))
)	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
met_func	*(struct(*(*(()->(long)))))
[	O
i	long
]	O
.	O
Func	*(()->(long))
;	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
j	long
]	O
.	O
Obj	long
=	O
gObj	O
[	O
IdO	long
]	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
[	O
j	long
]	O
.	O
next	long
=	O
NULL	O
;	O
j	long
++	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_newobj_inh_stage	(long,long,*(void))->(long)
(	O
OBJID	long
IdO	long
,	O
OBJID	long
Father	long
,	O
EPVoid	*(void)
ConstPar	*(void)
)	O
{	O
EUint32	long
i	long
,	O
must_link	long
,	O
j	long
;	O
CLASSID	long
IdC	long
;	O
OBJID	long
id	long
;	O
EPChar	*(char)
ap_id	*(char)
;	O
ESint32	long
flag	long
=	O
0	int
;	O
IdC	long
=	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
)	O
{	O
gObj	O
[	O
IdO	long
]	O
->	O
nUpTable	long
=	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
=	O
edma_palloc	(long)->(long)
(	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
*	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
=	O
(	O
SC_ID	struct(long,array(char),long,long)
*	O
)	O
edma_pget	(long)->(*(void))
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
)	O
;	O
if	O
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
==	O
0	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_new_obj_inh_stage] "	*(char)
"Can't create superclass table"	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
i	long
++	O
)	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
=	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
i	long
++	O
)	O
{	O
id	long
=	O
-	O
1	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
=	O
-	O
1	int
;	O
edma_printf_dbg	(long,long,*(char))->(long)
(	O
4	int
,	O
-	O
1	int
,	O
"[_edma_newobj_inh_stage] Creating "	*(char)
"superobject of class %s"	*(char)
,	O
gClass	O
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
]	O
->	O
ClassName	array(char)
)	O
;	O
must_link	long
=	O
0	int
;	O
if	O
(	O
(	O
Father	long
!=	O
-	O
1	int
)	O
&&	O
(	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
==	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
)	O
)	O
{	O
id	long
=	O
Father	long
;	O
flag	long
=	O
1	int
;	O
must_link	long
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
id	long
=	O
edma_upcast_obj	(long,*(char))->(long)
(	O
IdO	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SubCIdList	*(array(char))
[	O
i	long
]	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
must_link	long
=	O
1	int
;	O
if	O
(	O
(	O
id	long
=	O
edma_upcast_obj	(long,*(char))->(long)
(	O
gObj	O
[	O
IdO	long
]	O
->	O
root_obj	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SubCIdList	*(array(char))
[	O
i	long
]	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
id	long
=	O
_edma_new_obj	(*(char),long,*(void))->(long)
(	O
gClass	O
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
]	O
->	O
ClassName	array(char)
,	O
IdO	long
,	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[%s] Can't create superobject of class %s"	*(char)
,	O
__FUNCTION__	O
,	O
gClass	O
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
]	O
->	O
ClassName	array(char)
)	O
;	O
}	O
must_link	long
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
id	long
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[%s] Can't link superclass %s to object %d"	*(char)
,	O
__FUNCTION__	O
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SubCIdList	*(array(char))
[	O
i	long
]	O
)	O
;	O
}	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
=	O
id	long
;	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SubCIdList	*(array(char))
[	O
i	long
]	O
[	O
0	int
]	O
)	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	*(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SubCIdList	*(array(char))
[	O
i	long
]	O
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
else	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	*(char)
,	O
gClass	O
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
]	O
->	O
ClassName	array(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
IdClass	long
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
;	O
if	O
(	O
must_link	long
)	O
{	O
ap_id	*(char)
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCIdList	*(array(char))
[	O
i	long
]	O
?	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCIdList	*(array(char))
[	O
i	long
]	O
:	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array(char)
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
;	O
j	long
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Id	*(char)
,	O
ap_id	*(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
j	long
==	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
)	O
edma_add_subobject	(long,long,*(char))->(long)
(	O
id	long
,	O
IdO	long
,	O
ap_id	*(char)
)	O
;	O
else	O
edma_add_subobject	(long,long,*(char))->(long)
(	O
id	long
,	O
IdO	long
,	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array(char)
)	O
;	O
}	O
}	O
}	O
return	O
IdO	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_newobj_final_stage	(long,*(char),*(void))->(long)
(	O
OBJID	long
IdO	long
,	O
EPChar	*(char)
ClassName	array(char)
,	O
EPVoid	*(void)
ConstPar	*(void)
)	O
{	O
EUint32	long
i	long
,	O
j	long
;	O
CLASSID	long
IdC	long
,	O
IdC1	long
;	O
ESint32	long
isSIU	long
;	O
IdC	long
=	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
;	O
isSIU	long
=	O
gObj	O
[	O
IdO	long
]	O
->	O
IdSIU	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
IdMet	array(char)
,	O
"born"	*(char)
,	O
4	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
!=	O
gClass	O
[	O
IdC	long
]	O
->	O
nMet	short
)	O
{	O
edma_met1	(long,long,char,*(void))->(long)
(	O
IdO	long
,	O
i	long
,	O
0	int
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
isSIU	long
!=	O
-	O
1	int
)	O
{	O
edma_met3	(long,*(char))->(long)
(	O
IdO	long
,	O
"NewObj"	*(char)
,	O
ClassName	array(char)
)	O
;	O
}	O
gClass	O
[	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
]	O
->	O
Used	char
=	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
Tipo	long
==	O
DT_EUSER	int
)	O
{	O
IdC1	long
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
UserInfo	long
;	O
j	long
=	O
(	O
OBJID	long
)	O
edma_new_obj	(*(char))->(long)
(	O
gClass	O
[	O
IdC1	long
]	O
->	O
ClassName	array(char)
,	O
NULL	O
)	O
;	O
*	O
(	O
(	O
OBJID	long
*	O
)	O
(	O
(	O
EPByte	*(char)
)	O
gObj	O
[	O
IdO	long
]	O
->	O
Data	*(void)
+	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
Off	short
)	O
)	O
=	O
j	long
;	O
}	O
return	O
IdO	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_new_obj	(*(char))->(long)
(	O
EPChar	*(char)
ClassNam1	*(char)
,	O
...	O
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
cid	long
,	O
siu_cid	*(long)
;	O
ESint32	long
off	long
;	O
va_list	*(char)
ConstPar	*(void)
;	O
if	O
(	O
(	O
off	long
=	O
_edma_parse_class_name	(*(char),*(long),*(long),long,long)->(long)
(	O
ClassNam1	*(char)
,	O
&	O
cid	long
,	O
&	O
siu_cid	*(long)
,	O
-	O
1	int
,	O
-	O
1	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_new_obj] Invalid Class Name '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
va_start	O
(	O
ConstPar	*(void)
,	O
ClassNam1	*(char)
)	O
;	O
id	long
=	O
_edma_new_obj_internal	(*(char),long,long,long,*(void))->(long)
(	O
ClassNam1	*(char)
+	O
off	long
,	O
cid	long
,	O
siu_cid	*(long)
,	O
-	O
1	int
,	O
ConstPar	*(void)
)	O
;	O
va_end	O
(	O
ConstPar	*(void)
)	O
;	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_new_obj_with_version	(*(char),long,long)->(long)
(	O
EPChar	*(char)
ClassNam1	*(char)
,	O
ESint32	long
vmajor	long
,	O
ESint32	long
vminor	long
,	O
...	O
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
cid	long
,	O
siu_cid	*(long)
;	O
ESint32	long
off	long
;	O
va_list	*(char)
ConstPar	*(void)
;	O
if	O
(	O
(	O
off	long
=	O
_edma_parse_class_name	(*(char),*(long),*(long),long,long)->(long)
(	O
ClassNam1	*(char)
,	O
&	O
cid	long
,	O
&	O
siu_cid	*(long)
,	O
vmajor	long
,	O
vminor	long
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_new_obj_with_version] Invalid Class Name '%s' "	*(char)
"version %ld.%ld"	*(char)
,	O
ClassNam1	*(char)
,	O
vmajor	long
,	O
vminor	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
va_start	O
(	O
ConstPar	*(void)
,	O
vminor	long
)	O
;	O
id	long
=	O
_edma_new_obj_internal	(*(char),long,long,long,*(void))->(long)
(	O
ClassNam1	*(char)
+	O
off	long
,	O
cid	long
,	O
siu_cid	*(long)
,	O
-	O
1	int
,	O
ConstPar	*(void)
)	O
;	O
va_end	O
(	O
ConstPar	*(void)
)	O
;	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_new_obj	(*(char),long,*(void))->(long)
(	O
EPChar	*(char)
ClassNam1	*(char)
,	O
OBJID	long
father	long
,	O
EPVoid	*(void)
ConstPar	*(void)
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
cid	long
,	O
siu_cid	*(long)
;	O
ESint32	long
off	long
;	O
if	O
(	O
(	O
off	long
=	O
_edma_parse_class_name	(*(char),*(long),*(long),long,long)->(long)
(	O
ClassNam1	*(char)
,	O
&	O
cid	long
,	O
&	O
siu_cid	*(long)
,	O
-	O
1	int
,	O
-	O
1	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_new_obj] Invalid Class Name '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
id	long
=	O
_edma_new_obj_internal	(*(char),long,long,long,*(void))->(long)
(	O
ClassNam1	*(char)
+	O
off	long
,	O
cid	long
,	O
siu_cid	*(long)
,	O
father	long
,	O
ConstPar	*(void)
)	O
;	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_new_obj_internal	(*(char),long,long,long,*(void))->(long)
(	O
EPChar	*(char)
ClassNam1	*(char)
,	O
CLASSID	long
cid	long
,	O
CLASSID	long
siu_cid	*(long)
,	O
OBJID	long
idFather	long
,	O
EPVoid	*(void)
ConstPar	*(void)
)	O
{	O
OBJID	long
id	long
;	O
if	O
(	O
(	O
id	long
=	O
_edma_newobj_basic_stage	(long,long,*(void))->(long)
(	O
cid	long
,	O
siu_cid	*(long)
,	O
ConstPar	*(void)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Basic Stage Failed."	*(char)
"Can't create object of class '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
gObj	O
[	O
id	long
]	O
->	O
root_obj	long
=	O
(	O
(	O
idFather	long
==	O
-	O
1	int
)	O
?	O
id	long
:	O
idFather	long
)	O
;	O
if	O
(	O
(	O
_edma_newobj_inh_stage	(long,long,*(void))->(long)
(	O
id	long
,	O
idFather	long
,	O
ConstPar	*(void)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Inheritance Stage Failed. "	*(char)
" Can't create object of class '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
if	O
(	O
(	O
_edma_newobj_vm_stage	(long)->(long)
(	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Virtual Method Stage Failed."	*(char)
" Can't create object of class '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
if	O
(	O
(	O
_edma_newobj_final_stage	(long,*(char),*(void))->(long)
(	O
id	long
,	O
ClassNam1	*(char)
,	O
ConstPar	*(void)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Final Stage Failed. "	*(char)
"can't create object of class '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_new_simple_obj	(*(char),*(void))->(long)
(	O
EPChar	*(char)
ClassNam1	*(char)
,	O
EPVoid	*(void)
ConstPar	*(void)
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
cid	long
,	O
siu_cid	*(long)
;	O
ESint32	long
off	long
;	O
if	O
(	O
ClassNam1	*(char)
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[_edma_new_simple_obj] Invalid Class Name (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
off	long
=	O
_edma_parse_class_name	(*(char),*(long),*(long),long,long)->(long)
(	O
ClassNam1	*(char)
,	O
&	O
cid	long
,	O
&	O
siu_cid	*(long)
,	O
-	O
1	int
,	O
-	O
1	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_new_simple_obj] Invalid Class Name '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
id	long
=	O
_edma_newobj_basic_stage	(long,long,*(void))->(long)
(	O
cid	long
,	O
siu_cid	*(long)
,	O
ConstPar	*(void)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Basic Stage Failed."	*(char)
"Can't create object of class '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
if	O
(	O
(	O
_edma_newobj_vm_stage	(long)->(long)
(	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Virtual Method Stage Failed."	*(char)
" Can't create object of class '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
gClass	O
[	O
gObj	O
[	O
id	long
]	O
->	O
IdClass	long
]	O
->	O
Used	char
=	O
1	int
;	O
return	O
id	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_free_superobjects	(long,long,long)->(long)
(	O
OBJID	long
IdObj	long
,	O
OBJID	long
old	long
,	O
ESint32	long
remove	(*(char))->(int)
)	O
{	O
int	O
i	long
,	O
n	int
;	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
n	int
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
0	int
]	O
.	O
IdClass	long
!=	O
-	O
1	int
)	O
{	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
0	int
]	O
.	O
Obj	long
]	O
;	O
edma_remove_superclass_ap	(long,*(char))->(long)
(	O
IdObj	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
0	int
]	O
.	O
Id	*(char)
)	O
;	O
if	O
(	O
(	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
==	O
0	int
)	O
)	O
_edma_internal_free_obj	(long,long,long)->(long)
(	O
(	O
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
->	O
IdObj	long
,	O
IdObj	long
,	O
remove	(*(char))->(int)
)	O
;	O
}	O
else	O
edma_met3	(long,*(char))->(long)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
0	int
]	O
.	O
Obj	long
,	O
"FreeObj"	*(char)
)	O
;	O
}	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
)	O
edma_pfree	(long,*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
=	O
0	int
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_free_obj	(long)->(long)
(	O
OBJID	long
IdObj	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_free_obj"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
else	O
return	O
_edma_internal_free_obj	(long,long,long)->(long)
(	O
IdObj	long
,	O
IdObj	long
,	O
0	int
)	O
;	O
}	O
EUint32	long
EDMAPROC	O
_edma_internal_free_obj	(long,long,long)->(long)
(	O
OBJID	long
IdObj	long
,	O
OBJID	long
old	long
,	O
ESint32	long
flag	long
)	O
{	O
EUint32	long
i	long
,	O
j	long
,	O
n	int
;	O
EUint32	long
IdClass	long
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"_edma_internal_free_obj"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Flag	char
==	O
OBJ_FREE	int
)	O
return	O
0	int
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
Flag	char
=	O
OBJ_FREE	int
;	O
IdClass	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSIU	long
!=	O
-	O
1	int
)	O
edma_met3	(long,*(char))->(long)
(	O
IdObj	long
,	O
"FreeObj"	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdClass	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdClass	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
IdMet	array(char)
,	O
"rip"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
!=	O
gClass	O
[	O
IdClass	long
]	O
->	O
nMet	short
)	O
edma_met1	(long,long,char,*(void))->(long)
(	O
IdObj	long
,	O
i	long
,	O
0	int
,	O
NULL	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdClass	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdClass	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
Tipo	long
==	O
DT_EUSER	int
)	O
{	O
j	long
=	O
*	O
(	O
(	O
OBJID	long
*	O
)	O
(	O
(	O
EPByte	*(char)
)	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	*(void)
+	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdClass	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
Off	short
)	O
)	O
;	O
edma_free_obj	(long)->(long)
(	O
j	long
)	O
;	O
}	O
nObj	long
--	O
;	O
if	O
(	O
nObj	long
<	O
0	int
)	O
edma_print	(*(char))->(long)
(	O
"**** Ooops!! **** ---> (SYSTEM ERROR) "	*(char)
"Negative number of objects in system..."	*(char)
)	O
;	O
n	int
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
IdClass	long
!=	O
-	O
1	int
)	O
_edma_internal_free_obj	(long,long,long)->(long)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
,	O
old	long
,	O
1	int
)	O
;	O
else	O
edma_met3	(long,*(char))->(long)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
,	O
"FreeObj"	*(char)
)	O
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
)	O
edma_pfree	(long,*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hDownTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
=	O
0	int
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
=	O
NULL	O
;	O
if	O
(	O
flag	long
)	O
_edma_free_superobjects	(long,long,long)->(long)
(	O
IdObj	long
,	O
old	long
,	O
1	int
)	O
;	O
else	O
_edma_free_superobjects	(long,long,long)->(long)
(	O
IdObj	long
,	O
old	long
,	O
0	int
)	O
;	O
edma_pfree	(long,*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hData	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	*(void)
)	O
;	O
edma_pfree	(long,*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hvTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSubSIU	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSubSIU	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
=	O
NULL	O
;	O
edma_printf_dbg	(long,long,*(char))->(long)
(	O
4	int
,	O
-	O
1	int
,	O
"(%s) Rips Object %u of Class %s"	*(char)
,	O
AppName	array(char)
,	O
IdObj	long
,	O
gClass	O
[	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_free_one_obj	(long)->(long)
(	O
OBJID	long
IdObj	long
)	O
{	O
EUint32	long
i	long
,	O
j	long
;	O
EUint32	long
IdClass	long
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_free_one_obj"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
IdClass	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSIU	long
!=	O
-	O
1	int
)	O
edma_met3	(long,*(char))->(long)
(	O
IdObj	long
,	O
"FreeObj"	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdClass	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdClass	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
IdMet	array(char)
,	O
"rip"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
!=	O
gClass	O
[	O
IdClass	long
]	O
->	O
nMet	short
)	O
edma_met1	(long,long,char,*(void))->(long)
(	O
IdObj	long
,	O
i	long
,	O
0	int
,	O
NULL	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdClass	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdClass	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
Tipo	long
==	O
DT_EUSER	int
)	O
{	O
j	long
=	O
*	O
(	O
(	O
OBJID	long
*	O
)	O
(	O
(	O
EPByte	*(char)
)	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	*(void)
+	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdClass	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
Off	short
)	O
)	O
;	O
edma_free_obj	(long)->(long)
(	O
j	long
)	O
;	O
}	O
nObj	long
--	O
;	O
if	O
(	O
nObj	long
<	O
0	int
)	O
edma_print	(*(char))->(long)
(	O
"(SYSTEM ERROR) Negative number of objects in system..."	*(char)
)	O
;	O
edma_pfree	(long,*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
)	O
;	O
edma_pfree	(long,*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hData	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	*(void)
)	O
;	O
edma_pfree	(long,*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hvTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	*(struct(char,long,array(char),*(()->(long)),*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
=	O
NULL	O
;	O
edma_printf_dbg	(long,long,*(char))->(long)
(	O
4	int
,	O
-	O
1	int
,	O
"(%s) Rips Object %u of Class %s"	*(char)
,	O
AppName	array(char)
,	O
IdObj	long
,	O
gClass	O
[	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
0	int
;	O
}	O
EDWord	long
EDMAPROC	O
edma_make_obj_virtual	(long)->(long)
(	O
OBJID	long
IdObj	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_make_obj_virtual"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
Flag	char
=	O
VIRTUAL_OBJECT	int
;	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_set_obj_final	(long,long)->(long)
(	O
OBJID	long
IdObj	long
,	O
EUint32	long
i	long
)	O
{	O
EUint32	long
old	long
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_set_obj_final"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
old	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
Final	char
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
Final	char
=	O
i	long
;	O
return	O
old	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_swap_obj	(long,long)->(long)
(	O
OBJID	long
id	long
,	O
OBJID	long
new_id	long
)	O
{	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
current	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
OBJID	long
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
ESint32	long
i	long
,	O
j	long
;	O
void	O
*	O
p	*(void)
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
id	long
,	O
"edma_swap_obj"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
new_id	long
,	O
"edma_swap_obj"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
id	long
]	O
->	O
nUpTable	long
;	O
i	long
++	O
)	O
{	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
nDownTable	long
;	O
j	long
++	O
)	O
if	O
(	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Obj	long
==	O
id	long
)	O
{	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Obj	long
=	O
new_id	long
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
;	O
i	long
++	O
)	O
{	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
nUpTable	long
;	O
j	long
++	O
)	O
if	O
(	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Obj	long
==	O
id	long
)	O
{	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Obj	long
=	O
new_id	long
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
new_id	long
]	O
->	O
nUpTable	long
;	O
i	long
++	O
)	O
{	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
new_id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
;	O
if	O
(	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
==	O
new_id	long
)	O
{	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
id	long
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
nDownTable	long
;	O
j	long
++	O
)	O
if	O
(	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Obj	long
==	O
new_id	long
)	O
{	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Obj	long
=	O
id	long
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
new_id	long
]	O
->	O
nDownTable	long
;	O
i	long
++	O
)	O
{	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
new_id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
;	O
if	O
(	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
==	O
new_id	long
)	O
{	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
id	long
;	O
continue	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
nUpTable	long
;	O
j	long
++	O
)	O
if	O
(	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Obj	long
==	O
new_id	long
)	O
{	O
gObj	O
[	O
aux	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Obj	long
=	O
id	long
;	O
}	O
}	O
current	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
id	long
]	O
;	O
gObj	O
[	O
id	long
]	O
=	O
gObj	O
[	O
new_id	long
]	O
;	O
gObj	O
[	O
new_id	long
]	O
=	O
current	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
gObj	O
[	O
id	long
]	O
->	O
IdObj	long
=	O
id	long
;	O
gObj	O
[	O
new_id	long
]	O
->	O
IdObj	long
=	O
new_id	long
;	O
return	O
0	int
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_newobj_inh_stage1	(long,long,*(void))->(long)
(	O
OBJID	long
IdO	long
,	O
OBJID	long
Father	long
,	O
EPVoid	*(void)
ConstPar	*(void)
)	O
{	O
EUint32	long
i	long
,	O
must_link	long
,	O
j	long
;	O
CLASSID	long
IdC	long
;	O
OBJID	long
id	long
;	O
EPChar	*(char)
ap_id	*(char)
;	O
ESint32	long
flag	long
=	O
0	int
;	O
IdC	long
=	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
)	O
{	O
gObj	O
[	O
IdO	long
]	O
->	O
nUpTable	long
=	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
=	O
edma_palloc	(long)->(long)
(	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
*	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
=	O
(	O
SC_ID	struct(long,array(char),long,long)
*	O
)	O
edma_pget	(long)->(*(void))
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
)	O
;	O
if	O
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
==	O
0	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_new_obj_inh_stage] "	*(char)
"Can't create superclass table"	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
i	long
++	O
)	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
=	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
i	long
++	O
)	O
{	O
id	long
=	O
-	O
1	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
=	O
-	O
1	int
;	O
edma_printf_dbg	(long,long,*(char))->(long)
(	O
4	int
,	O
-	O
1	int
,	O
"[_edma_newobj_inh_stage] Creating "	*(char)
"superobject of class %s"	*(char)
,	O
gClass	O
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
]	O
->	O
ClassName	array(char)
)	O
;	O
edma_printf_dbg	(long,long,*(char))->(long)
(	O
4	int
,	O
-	O
1	int
,	O
"SuperClass %d: '%s'(%d) Father: %d: '%s'%d "	*(char)
":: IdO: %d"	*(char)
,	O
i	long
,	O
gClass	O
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
]	O
->	O
ClassName	array(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
,	O
Father	long
,	O
gClass	O
[	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
,	O
IdO	long
)	O
;	O
must_link	long
=	O
0	int
;	O
if	O
(	O
(	O
Father	long
!=	O
-	O
1	int
)	O
&&	O
(	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
==	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
)	O
)	O
{	O
edma_printf_dbg	(long,long,*(char))->(long)
(	O
4	int
,	O
-	O
1	int
,	O
"**SuperClass %d: '%s'(%d) Father: %d: "	*(char)
"'%s'%d "	*(char)
,	O
i	long
,	O
gClass	O
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
]	O
->	O
ClassName	array(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
,	O
Father	long
,	O
gClass	O
[	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
)	O
;	O
id	long
=	O
Father	long
;	O
flag	long
=	O
1	int
;	O
must_link	long
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
id	long
=	O
edma_upcast_obj	(long,*(char))->(long)
(	O
IdO	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SubCIdList	*(array(char))
[	O
i	long
]	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
must_link	long
=	O
1	int
;	O
if	O
(	O
(	O
id	long
=	O
edma_upcast_obj	(long,*(char))->(long)
(	O
gObj	O
[	O
IdO	long
]	O
->	O
root_obj	long
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SubCIdList	*(array(char))
[	O
i	long
]	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
id	long
=	O
_edma_new_obj1	(*(char),long,*(void))->(long)
(	O
gClass	O
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
]	O
->	O
ClassName	array(char)
,	O
Father	long
,	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[%s] Can't create superobject of class %s"	*(char)
,	O
__FUNCTION__	O
,	O
gClass	O
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
]	O
->	O
ClassName	array(char)
)	O
;	O
}	O
must_link	long
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
id	long
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[%s] Can't link superclass %s "	*(char)
"to object %d"	*(char)
,	O
__FUNCTION__	O
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SubCIdList	*(array(char))
[	O
i	long
]	O
)	O
;	O
}	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
=	O
id	long
;	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SubCIdList	*(array(char))
[	O
i	long
]	O
[	O
0	int
]	O
)	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	*(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SubCIdList	*(array(char))
[	O
i	long
]	O
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
else	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	*(char)
,	O
gClass	O
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
]	O
->	O
ClassName	array(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
IdClass	long
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCList	*(long)
[	O
i	long
]	O
;	O
if	O
(	O
must_link	long
)	O
{	O
ap_id	*(char)
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCIdList	*(array(char))
[	O
i	long
]	O
?	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
IdC	long
]	O
->	O
SCIdList	*(array(char))
[	O
i	long
]	O
:	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array(char)
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
;	O
j	long
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
j	long
]	O
.	O
Id	*(char)
,	O
ap_id	*(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
j	long
==	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
)	O
edma_add_subobject	(long,long,*(char))->(long)
(	O
id	long
,	O
IdO	long
,	O
ap_id	*(char)
)	O
;	O
else	O
edma_add_subobject	(long,long,*(char))->(long)
(	O
id	long
,	O
IdO	long
,	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array(char)
)	O
;	O
}	O
}	O
}	O
return	O
IdO	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_new_obj1	(*(char),long,*(void))->(long)
(	O
EPChar	*(char)
ClassNam1	*(char)
,	O
OBJID	long
father	long
,	O
EPVoid	*(void)
ConstPar	*(void)
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
cid	long
,	O
siu_cid	*(long)
;	O
ESint32	long
off	long
;	O
if	O
(	O
(	O
off	long
=	O
_edma_parse_class_name	(*(char),*(long),*(long),long,long)->(long)
(	O
ClassNam1	*(char)
,	O
&	O
cid	long
,	O
&	O
siu_cid	*(long)
,	O
-	O
1	int
,	O
-	O
1	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_new_obj] Invalid Class Name '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
id	long
=	O
_edma_new_obj_internal1	(*(char),long,long,long,*(void))->(long)
(	O
ClassNam1	*(char)
+	O
off	long
,	O
cid	long
,	O
siu_cid	*(long)
,	O
father	long
,	O
ConstPar	*(void)
)	O
;	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_new_obj_internal1	(*(char),long,long,long,*(void))->(long)
(	O
EPChar	*(char)
ClassNam1	*(char)
,	O
CLASSID	long
cid	long
,	O
CLASSID	long
siu_cid	*(long)
,	O
OBJID	long
idFather	long
,	O
EPVoid	*(void)
ConstPar	*(void)
)	O
{	O
OBJID	long
id	long
;	O
if	O
(	O
(	O
id	long
=	O
_edma_newobj_basic_stage	(long,long,*(void))->(long)
(	O
cid	long
,	O
siu_cid	*(long)
,	O
ConstPar	*(void)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Basic Stage Failed."	*(char)
"Can't create object of class '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
gObj	O
[	O
id	long
]	O
->	O
root_obj	long
=	O
(	O
(	O
idFather	long
==	O
-	O
1	int
)	O
?	O
id	long
:	O
idFather	long
)	O
;	O
if	O
(	O
(	O
_edma_newobj_inh_stage1	(long,long,*(void))->(long)
(	O
id	long
,	O
idFather	long
,	O
ConstPar	*(void)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Inheritance Stage Failed. "	*(char)
" Can't create object of class '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
if	O
(	O
(	O
_edma_newobj_vm_stage	(long)->(long)
(	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Virtual Method Stage Failed."	*(char)
" Can't create object of class '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
if	O
(	O
(	O
_edma_newobj_final_stage	(long,*(char),*(void))->(long)
(	O
id	long
,	O
ClassNam1	*(char)
,	O
ConstPar	*(void)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_new_obj] Final Stage Failed. "	*(char)
"can't create object of class '%s'"	*(char)
,	O
ClassNam1	*(char)
)	O
;	O
return	O
id	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_obj_commit_suicide	(long)->(long)
(	O
OBJID	long
id	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
id	long
,	O
"edma_met3"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
gObj	O
[	O
id	long
]	O
->	O
Flag	char
=	O
OBJ_DIE	int
;	O
return	O
0	int
;	O
}	O
