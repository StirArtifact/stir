static	O
int	O
moderator_filter_message	(*(struct),*(struct),*(int))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
int	O
*	O
pdiscard	*(int)
)	O
{	O
int	O
rc	int
;	O
mu_sieve_machine_t	*(struct)
newmach	*(struct)
;	O
mu_attribute_t	*(struct)
attr	*(struct)
;	O
char	O
*	O
arg	*(char)
;	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"source"	*(char)
,	O
SVT_STRING	int
,	O
&	O
arg	*(char)
)	O
)	O
{	O
rc	int
=	O
mu_sieve_machine_clone	(*(struct),*(*(struct)))->(int)
(	O
mach	*(struct)
,	O
&	O
newmach	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot initialize sieve machine: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_sieve_compile	(*(struct),*(char))->(int)
(	O
newmach	*(struct)
,	O
arg	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot compile source `%s'"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"program"	*(char)
,	O
SVT_STRING	int
,	O
&	O
arg	*(char)
)	O
)	O
{	O
struct	O
mu_locus_range	struct(struct(*(char),int,int),struct(*(char),int,int))
locrange	struct(struct(*(char),int,int),struct(*(char),int,int))
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
rc	int
=	O
mu_sieve_machine_clone	(*(struct),*(*(struct)))->(int)
(	O
mach	*(struct)
,	O
&	O
newmach	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot initialize sieve machine: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mu_sieve_get_locus	(*(struct),*(struct(struct(*(char),int,int),struct(*(char),int,int))))->(int)
(	O
mach	*(struct)
,	O
&	O
locrange	struct(struct(*(char),int,int),struct(*(char),int,int))
)	O
;	O
rc	int
=	O
mu_sieve_compile_text	(*(struct),*(char),long,*(struct(*(char),int,int)))->(int)
(	O
newmach	*(struct)
,	O
arg	*(char)
,	O
strlen	(*(char))->(long)
(	O
arg	*(char)
)	O
,	O
&	O
locrange	struct(struct(*(char),int,int),struct(*(char),int,int))
.	O
beg	struct(*(char),int,int)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot compile subprogram"	*(char)
)	O
)	O
;	O
}	O
else	O
rc	int
=	O
mu_sieve_machine_dup	(*(struct),*(*(struct)))->(int)
(	O
mach	*(struct)
,	O
&	O
newmach	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_message_get_attribute	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
attr	*(struct)
)	O
;	O
mu_attribute_unset_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
;	O
rc	int
=	O
mu_sieve_message	(*(struct),*(struct))->(int)
(	O
newmach	*(struct)
,	O
msg	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
newmach	*(struct)
,	O
_	O
(	O
"failed to run inferior sieve machine"	*(char)
)	O
)	O
;	O
else	O
*	O
pdiscard	*(int)
=	O
mu_attribute_is_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
;	O
mu_sieve_machine_destroy	(*(*(struct)))->(void)
(	O
&	O
newmach	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
copy_header	(*(struct),*(struct),*(char),*(struct),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_header_t	*(struct)
to_hdr	*(struct)
,	O
char	O
*	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
mu_header_t	*(struct)
from_hdr	*(struct)
,	O
char	O
*	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
{	O
int	O
rc	int
;	O
const	O
char	O
*	O
value	*(void)
=	O
NULL	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_header_sget_value	O
(	O
from_hdr	*(struct)
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
&	O
value	*(void)
)	O
)	O
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot get `%s:' header: %s"	*(char)
)	O
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_header_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
to_hdr	*(struct)
,	O
to	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
,	O
value	*(void)
,	O
1	int
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
moderator_discard_message	(*(struct),*(struct),*(char))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_message_t	*(struct)
request	*(struct)
,	O
const	O
char	O
*	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
{	O
int	O
rc	int
;	O
mu_message_t	*(struct)
reply	*(struct)
;	O
mu_header_t	*(struct)
repl_hdr	*(struct)
,	O
req_hdr	*(struct)
;	O
mu_mailer_t	*(struct)
mailer	*(struct)
;	O
rc	int
=	O
mu_message_create	(*(*(struct)),*(void))->(int)
(	O
&	O
reply	*(struct)
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
reply	*(struct)
,	O
&	O
repl_hdr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_message_destroy	(*(*(struct)),*(void))->(void)
(	O
&	O
reply	*(struct)
,	O
NULL	O
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
request	*(struct)
,	O
&	O
req_hdr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_message_destroy	(*(*(struct)),*(void))->(void)
(	O
&	O
reply	*(struct)
,	O
NULL	O
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
copy_header	(*(struct),*(struct),*(char),*(struct),*(char))->(int)
(	O
mach	*(struct)
,	O
repl_hdr	*(struct)
,	O
MU_HEADER_TO	*(char)
,	O
req_hdr	*(struct)
,	O
MU_HEADER_FROM	*(char)
)	O
||	O
copy_header	(*(struct),*(struct),*(char),*(struct),*(char))->(int)
(	O
mach	*(struct)
,	O
repl_hdr	*(struct)
,	O
MU_HEADER_SUBJECT	*(char)
,	O
req_hdr	*(struct)
,	O
MU_HEADER_SUBJECT	*(char)
)	O
)	O
{	O
mu_message_destroy	(*(*(struct)),*(void))->(void)
(	O
&	O
reply	*(struct)
,	O
NULL	O
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
mu_header_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
repl_hdr	*(struct)
,	O
MU_HEADER_FROM	*(char)
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
,	O
1	int
)	O
;	O
mailer	*(struct)
=	O
mu_sieve_get_mailer	(*(struct))->(*(struct))
(	O
mach	*(struct)
)	O
;	O
rc	int
=	O
mu_mailer_open	(*(struct),int)->(int)
(	O
mailer	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot open mailer: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
else	O
{	O
rc	int
=	O
mu_mailer_send_message	(*(struct),*(struct),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))->(int)
(	O
mailer	*(struct)
,	O
reply	*(struct)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
mu_mailer_close	(*(struct))->(int)
(	O
mailer	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot send message: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
mu_message_destroy	(*(*(struct)),*(void))->(void)
(	O
&	O
reply	*(struct)
,	O
NULL	O
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
moderator_message_get_part	(*(struct),*(struct),long,*(*(struct)))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
size_t	long
index	(*(char),int)->(*(char))
,	O
mu_message_t	*(struct)
*	O
pmsg	*(*(struct))
)	O
{	O
int	O
rc	int
;	O
mu_message_t	*(struct)
tmp	*(struct)
;	O
mu_header_t	*(struct)
hdr	*(struct)
=	O
NULL	O
;	O
const	O
char	O
*	O
value	*(void)
;	O
if	O
(	O
(	O
rc	int
=	O
mu_message_get_part	(*(struct),long,*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
index	(*(char),int)->(*(char))
,	O
&	O
tmp	*(struct)
)	O
)	O
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot get message part #%lu: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
index	(*(char),int)->(*(char))
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
tmp	*(struct)
,	O
&	O
hdr	*(struct)
)	O
;	O
if	O
(	O
mu_header_sget_value	O
(	O
hdr	*(struct)
,	O
MU_HEADER_CONTENT_TYPE	*(char)
,	O
&	O
value	*(void)
)	O
==	O
0	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
value	*(void)
,	O
"message/rfc822"	*(char)
,	O
14	int
)	O
==	O
0	int
)	O
{	O
mu_stream_t	*(struct)
str	*(char)
;	O
mu_body_t	*(struct)
body	*(struct)
;	O
mu_message_get_body	(*(struct),*(*(struct)))->(int)
(	O
tmp	*(struct)
,	O
&	O
body	*(struct)
)	O
;	O
mu_body_get_streamref	(*(struct),*(*(struct)))->(int)
(	O
body	*(struct)
,	O
&	O
str	*(char)
)	O
;	O
rc	int
=	O
mu_stream_to_message	(*(struct),*(*(struct)))->(int)
(	O
str	*(char)
,	O
pmsg	*(*(struct))
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
str	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot convert MIME part stream to message: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
value	*(void)
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"expected message type message/rfc822, but found %s"	*(char)
)	O
,	O
value	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"no Content-Type header found"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
moderator_action	(*(struct))->(int)
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_message_t	*(struct)
msg	*(struct)
,	O
orig	*(struct)
;	O
int	O
rc	int
;	O
size_t	long
nparts	*(long)
=	O
0	int
;	O
int	O
discard	int
=	O
0	int
;	O
int	O
ismime	int
;	O
msg	*(struct)
=	O
mu_sieve_get_message	(*(struct))->(*(struct))
(	O
mach	*(struct)
)	O
;	O
mu_message_is_multipart	(*(struct),*(int))->(int)
(	O
msg	*(struct)
,	O
&	O
ismime	int
)	O
;	O
if	O
(	O
!	O
ismime	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"message is not multipart"	*(char)
)	O
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
rc	int
=	O
mu_message_get_num_parts	(*(struct),*(long))->(int)
(	O
msg	*(struct)
,	O
&	O
nparts	*(long)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
"mu_message_get_num_parts: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
if	O
(	O
nparts	*(long)
!=	O
3	int
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"expected 3 parts, but found %lu"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
nparts	*(long)
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
moderator_message_get_part	(*(struct),*(struct),long,*(*(struct)))->(int)
(	O
mach	*(struct)
,	O
msg	*(struct)
,	O
2	int
,	O
&	O
orig	*(struct)
)	O
)	O
)	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
rc	int
=	O
moderator_filter_message	(*(struct),*(struct),*(int))->(int)
(	O
mach	*(struct)
,	O
orig	*(struct)
,	O
&	O
discard	int
)	O
;	O
mu_message_unref	(*(struct))->(void)
(	O
orig	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
if	O
(	O
discard	int
&&	O
!	O
mu_sieve_is_dry_run	(*(struct))->(int)
(	O
mach	*(struct)
)	O
)	O
{	O
mu_message_t	*(struct)
request	*(struct)
;	O
char	O
*	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
=	O
NULL	O
;	O
if	O
(	O
(	O
rc	int
=	O
moderator_message_get_part	(*(struct),*(struct),long,*(*(struct)))->(int)
(	O
mach	*(struct)
,	O
msg	*(struct)
,	O
3	int
,	O
&	O
request	*(struct)
)	O
)	O
)	O
{	O
mu_sieve_error	(*(struct),*(char))->(void)
(	O
mach	*(struct)
,	O
_	O
(	O
"cannot get message part #3: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
mu_sieve_abort	(*(struct))->(void)
(	O
mach	*(struct)
)	O
;	O
}	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"address"	*(char)
,	O
SVT_STRING	int
,	O
&	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
;	O
if	O
(	O
moderator_discard_message	(*(struct),*(struct),*(char))->(int)
(	O
mach	*(struct)
,	O
request	*(struct)
,	O
from	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
)	O
)	O
discard	int
=	O
0	int
;	O
else	O
{	O
if	O
(	O
!	O
mu_sieve_get_tag	(*(struct),*(char),enum(int,int,int,int,int),*(void))->(int)
(	O
mach	*(struct)
,	O
"keep"	*(char)
,	O
SVT_VOID	int
,	O
NULL	O
)	O
)	O
{	O
mu_attribute_t	*(struct)
attr	*(struct)
=	O
0	int
;	O
if	O
(	O
mu_message_get_attribute	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
attr	*(struct)
)	O
==	O
0	int
)	O
mu_attribute_set_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
;	O
}	O
else	O
discard	int
=	O
0	int
;	O
}	O
mu_message_unref	(*(struct))->(void)
(	O
request	*(struct)
)	O
;	O
}	O
mu_sieve_log_action	(*(struct),*(char),*(char))->(void)
(	O
mach	*(struct)
,	O
"MODERATOR"	*(char)
,	O
discard	int
?	O
_	O
(	O
"discarding message"	*(char)
)	O
:	O
_	O
(	O
"keeping message"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
mu_sieve_data_type	enum(int,int,int,int,int)
moderator_req_args	array(enum(int,int,int,int,int))
[	O
]	O
=	O
{	O
SVT_VOID	int
}	O
;	O
static	O
mu_sieve_tag_def_t	struct(*(char),enum(int,int,int,int,int))
moderator_tags	array(struct(*(char),enum(int,int,int,int,int)))
[	O
]	O
=	O
{	O
{	O
"keep"	*(char)
,	O
SVT_VOID	int
}	O
,	O
{	O
"address"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"source"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
"program"	*(char)
,	O
SVT_STRING	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
mu_sieve_tag_group_t	struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct))->(int)))
moderator_tag_groups	array(struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct))->(int))))
[	O
]	O
=	O
{	O
{	O
moderator_tags	array(struct(*(char),enum(int,int,int,int,int)))
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
SIEVE_EXPORT	O
(	O
moderator	O
,	O
init	O
)	O
(	O
mu_sieve_machine_t	*(struct)
mach	*(struct)
)	O
{	O
mu_sieve_register_action	(*(struct),*(char),*((*(struct))->(int)),*(enum(int,int,int,int,int)),*(struct(*(struct(*`,enum(int,int,int,int,int))),*((*`)->(int)))),int)->(void)
(	O
mach	*(struct)
,	O
"moderator"	*(char)
,	O
moderator_action	(*(struct))->(int)
,	O
moderator_req_args	array(enum(int,int,int,int,int))
,	O
moderator_tag_groups	array(struct(*(struct(*(char),enum(int,int,int,int,int))),*((*(struct))->(int))))
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
