static	O
int	O
move_connects_strings	(int,int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
to_move	int
)	O
{	O
int	O
ss	array(int)
[	O
4	int
]	O
;	O
int	O
strings	array(int)
=	O
0	int
;	O
int	O
own_strings	int
=	O
0	int
;	O
int	O
k	int
,	O
l	int
;	O
int	O
fewlibs	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
ii	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
int	O
origin	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
ii	int
)	O
||	O
board	*(char)
[	O
ii	int
]	O
==	O
EMPTY	int
)	O
continue	O
;	O
origin	int
=	O
find_origin	(int)->(int)
(	O
ii	int
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
strings	array(int)
;	O
l	int
++	O
)	O
if	O
(	O
ss	array(int)
[	O
l	int
]	O
==	O
origin	int
)	O
break	O
;	O
if	O
(	O
l	int
==	O
strings	array(int)
)	O
{	O
ss	array(int)
[	O
strings	array(int)
]	O
=	O
origin	int
;	O
strings	array(int)
++	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
strings	array(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ss	array(int)
[	O
k	int
]	O
]	O
.	O
invincible	int
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
ss	array(int)
[	O
k	int
]	O
]	O
==	O
color	int
)	O
{	O
int	O
newlibs	int
=	O
approxlib	(int,int,int,*(int))->(int)
(	O
pos	int
,	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
;	O
own_strings	int
++	O
;	O
if	O
(	O
newlibs	int
>=	O
countlib	(int)->(int)
(	O
ss	array(int)
[	O
k	int
]	O
)	O
)	O
{	O
if	O
(	O
countlib	(int)->(int)
(	O
ss	array(int)
[	O
k	int
]	O
)	O
<=	O
4	int
)	O
fewlibs	int
++	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
ss	array(int)
[	O
k	int
]	O
)	O
<=	O
2	int
)	O
fewlibs	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
countlib	(int)->(int)
(	O
ss	array(int)
[	O
k	int
]	O
)	O
<=	O
2	int
)	O
fewlibs	int
++	O
;	O
if	O
(	O
countlib	(int)->(int)
(	O
ss	array(int)
[	O
k	int
]	O
)	O
<=	O
1	int
&&	O
to_move	int
)	O
{	O
int	O
dummy	array(int)
[	O
MAXCHAIN	int
]	O
;	O
fewlibs	int
++	O
;	O
fewlibs	int
+=	O
chainlinks2	(int,array(int),int)->(int)
(	O
ss	array(int)
[	O
k	int
]	O
,	O
dummy	array(int)
,	O
1	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
fewlibs	int
>	O
4	int
)	O
fewlibs	int
=	O
4	int
;	O
if	O
(	O
to_move	int
&&	O
is_ko	(int,int,*(int))->(int)
(	O
pos	int
,	O
color	int
,	O
NULL	O
)	O
&&	O
fewlibs	int
>	O
1	int
)	O
fewlibs	int
=	O
1	int
;	O
if	O
(	O
fewlibs	int
==	O
0	int
&&	O
own_strings	int
==	O
1	int
)	O
own_strings	int
=	O
0	int
;	O
return	O
own_strings	int
+	O
fewlibs	int
;	O
}	O
static	O
float	O
value_moves_get_blunder_size	(int,int)->(float)
(	O
int	O
move	*(int)
,	O
int	O
color	int
)	O
{	O
signed	O
char	O
saved_dragons	array(char)
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
saved_worms	array(char)
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
;	O
get_saved_dragons	(int,array(char))->(void)
(	O
move	*(int)
,	O
saved_dragons	array(char)
)	O
;	O
get_saved_worms	(int,array(char))->(void)
(	O
move	*(int)
,	O
saved_worms	array(char)
)	O
;	O
mark_safe_stones	(int,int,array(char),array(char),array(char))->(void)
(	O
color	int
,	O
move	*(int)
,	O
saved_dragons	array(char)
,	O
saved_worms	array(char)
,	O
safe_stones	array(char)
)	O
;	O
return	O
blunder_size	(int,int,*(int),array(char))->(float)
(	O
move	*(int)
,	O
color	int
,	O
NULL	O
,	O
safe_stones	array(char)
)	O
;	O
}	O
static	O
int	O
value_moves_confirm_safety	(int,int)->(int)
(	O
int	O
move	*(int)
,	O
int	O
color	int
)	O
{	O
return	O
(	O
value_moves_get_blunder_size	(int,int)->(float)
(	O
move	*(int)
,	O
color	int
)	O
==	O
0.0	int
)	O
;	O
}	O
static	O
void	O
find_more_attack_and_defense_moves	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
unstable_worms	array(int)
[	O
MAX_WORMS	O
]	O
;	O
int	O
N	int
=	O
0	int
;	O
int	O
ii	int
;	O
int	O
k	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
cursor_at_start_of_line	int
;	O
TRACE	O
(	O
"\nLooking for additional attack and defense moves. Trying moves ...\n"	*(char)
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
ii	int
]	O
)	O
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ii	int
]	O
.	O
origin	int
==	O
ii	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ii	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ii	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
unstable_worms	array(int)
[	O
N	int
]	O
=	O
ii	int
;	O
N	int
++	O
;	O
}	O
}	O
increase_depth_values	()->(void)
(	O
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
ii	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
send_two_return_one	(int,int)->(int)
(	O
ii	int
,	O
color	int
)	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
ii	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_BAD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_GOOD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_BAD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
CONNECT_MOVE	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
CUT_MOVE	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
MAX_REASONS	int
||	O
move	*(int)
[	O
ii	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
==	O
-	O
1	int
)	O
continue	O
;	O
cursor_at_start_of_line	int
=	O
0	int
;	O
TRACE	O
(	O
"%1m "	*(char)
,	O
ii	int
)	O
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
ii	int
,	O
color	int
,	O
"find_more_attack_and_defense_moves"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
N	int
;	O
k	int
++	O
)	O
{	O
int	O
aa	int
=	O
unstable_worms	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
aa	int
]	O
==	O
color	int
&&	O
!	O
defense_move_reason_known	(int,int)->(int)
(	O
ii	int
,	O
unstable_worms	array(int)
[	O
k	int
]	O
)	O
)	O
{	O
int	O
acode	int
=	O
attack	(int,*(int))->(int)
(	O
aa	int
,	O
NULL	O
)	O
;	O
if	O
(	O
acode	int
<	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
)	O
{	O
int	O
defense_works	int
=	O
1	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
attack_points	array(int)
[	O
0	int
]	O
,	O
other	int
,	O
"find_more_attack_and_defense_moves"	*(char)
,	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
board	*(char)
[	O
aa	int
]	O
)	O
defense_works	int
=	O
0	int
;	O
else	O
{	O
int	O
this_acode	int
=	O
REVERSE_RESULT	O
(	O
find_defense	(int,*(int))->(int)
(	O
aa	int
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
this_acode	int
>	O
acode	int
)	O
{	O
acode	int
=	O
this_acode	int
;	O
if	O
(	O
acode	int
>=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
)	O
defense_works	int
=	O
0	int
;	O
}	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
defense_works	int
)	O
{	O
if	O
(	O
!	O
cursor_at_start_of_line	int
)	O
TRACE	O
(	O
"\n"	*(char)
)	O
;	O
TRACE	O
(	O
"%ofound extra point of defense of %1m at %1m code %d\n"	*(char)
,	O
aa	int
,	O
ii	int
,	O
REVERSE_RESULT	O
(	O
acode	int
)	O
)	O
;	O
cursor_at_start_of_line	int
=	O
1	int
;	O
add_defense_move	(int,int,int)->(void)
(	O
ii	int
,	O
aa	int
,	O
REVERSE_RESULT	O
(	O
acode	int
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
board	*(char)
[	O
aa	int
]	O
==	O
other	int
&&	O
!	O
attack_move_reason_known	(int,int)->(int)
(	O
ii	int
,	O
unstable_worms	array(int)
[	O
k	int
]	O
)	O
)	O
{	O
int	O
dcode	int
=	O
find_defense	(int,*(int))->(int)
(	O
aa	int
,	O
NULL	O
)	O
;	O
if	O
(	O
dcode	int
<	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
)	O
{	O
int	O
attack_works	int
=	O
1	int
;	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
aa	int
,	O
NULL	O
)	O
>=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
defense_points	array(int)
[	O
0	int
]	O
,	O
other	int
,	O
"find_more_attack_and_defense_moves"	*(char)
,	O
0	int
)	O
)	O
{	O
int	O
this_dcode	int
=	O
REVERSE_RESULT	O
(	O
attack	(int,*(int))->(int)
(	O
aa	int
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
this_dcode	int
>	O
dcode	int
)	O
{	O
dcode	int
=	O
this_dcode	int
;	O
if	O
(	O
dcode	int
>=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
)	O
attack_works	int
=	O
0	int
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
else	O
attack_works	int
=	O
0	int
;	O
if	O
(	O
attack_works	int
)	O
{	O
if	O
(	O
!	O
cursor_at_start_of_line	int
)	O
TRACE	O
(	O
"\n"	*(char)
)	O
;	O
TRACE	O
(	O
"%ofound extra point of attack of %1m at %1m code %d\n"	*(char)
,	O
aa	int
,	O
ii	int
,	O
REVERSE_RESULT	O
(	O
dcode	int
)	O
)	O
;	O
cursor_at_start_of_line	int
=	O
1	int
;	O
add_attack_move	(int,int,int)->(void)
(	O
ii	int
,	O
aa	int
,	O
REVERSE_RESULT	O
(	O
dcode	int
)	O
)	O
;	O
}	O
}	O
}	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
TRACE	O
(	O
"\n"	*(char)
)	O
;	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
do_find_more_owl_attack_and_defense_moves	(int,int,int,int)->(void)
(	O
int	O
color	int
,	O
int	O
pos	int
,	O
int	O
move_reason_type	int
,	O
int	O
what	int
)	O
{	O
int	O
k	int
;	O
int	O
dd1	int
=	O
NO_MOVE	O
;	O
int	O
dd2	int
=	O
NO_MOVE	O
;	O
int	O
save_verbose	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
send_two_return_one	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
return	O
;	O
if	O
(	O
playing_into_snapback	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
return	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
if	O
(	O
move_reason_type	int
==	O
STRATEGIC_ATTACK_MOVE	int
||	O
move_reason_type	int
==	O
STRATEGIC_DEFEND_MOVE	int
)	O
dd1	int
=	O
what	int
;	O
else	O
if	O
(	O
move_reason_type	int
==	O
ATTACK_MOVE	int
||	O
move_reason_type	int
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
move_reason_type	int
==	O
ATTACK_MOVE_BAD_KO	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE_GOOD_KO	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE_BAD_KO	int
||	O
move_reason_type	int
==	O
VITAL_EYE_MOVE	int
)	O
dd1	int
=	O
what	int
;	O
else	O
if	O
(	O
move_reason_type	int
==	O
CONNECT_MOVE	int
)	O
{	O
int	O
worm1	int
=	O
conn_worm1	array(int)
[	O
what	int
]	O
;	O
int	O
worm2	int
=	O
conn_worm2	array(int)
[	O
what	int
]	O
;	O
dd1	int
=	O
dragon	int
[	O
worm1	int
]	O
.	O
origin	int
;	O
dd2	int
=	O
dragon	int
[	O
worm2	int
]	O
.	O
origin	int
;	O
if	O
(	O
dd1	int
==	O
dd2	int
)	O
dd2	int
=	O
NO_MOVE	O
;	O
}	O
else	O
{	O
verbose	int
=	O
save_verbose	int
;	O
return	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
int	O
dd	int
=	O
(	O
k	int
==	O
0	int
?	O
dd1	int
:	O
dd2	int
)	O
;	O
if	O
(	O
dd	int
==	O
NO_MOVE	O
)	O
continue	O
;	O
if	O
(	O
DRAGON2	O
(	O
dd	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
)	O
continue	O
;	O
if	O
(	O
DRAGON2	O
(	O
dd	int
)	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
CRITICAL	int
)	O
continue	O
;	O
if	O
(	O
(	O
move_reason_type	int
==	O
STRATEGIC_ATTACK_MOVE	int
||	O
move_reason_type	int
==	O
ATTACK_MOVE	int
||	O
move_reason_type	int
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
move_reason_type	int
==	O
ATTACK_MOVE_BAD_KO	int
||	O
(	O
move_reason_type	int
==	O
VITAL_EYE_MOVE	int
&&	O
board	*(char)
[	O
dd	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
&&	O
!	O
owl_attack_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
dd	int
)	O
)	O
{	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
acode	int
=	O
owl_does_attack	(int,int,*(int))->(int)
(	O
pos	int
,	O
dd	int
,	O
&	O
kworm	int
)	O
;	O
if	O
(	O
acode	int
>=	O
DRAGON2	O
(	O
dd	int
)	O
.	O
owl_attack_code	int
)	O
{	O
add_owl_attack_move	(int,int,int,int)->(void)
(	O
pos	int
,	O
dd	int
,	O
kworm	int
,	O
acode	int
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"Move at %1m upgraded to owl attack on %1m (%s).\n"	*(char)
,	O
pos	int
,	O
dd	int
,	O
result_to_string	(int)->(*(char))
(	O
acode	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
(	O
move_reason_type	int
==	O
STRATEGIC_DEFEND_MOVE	int
||	O
move_reason_type	int
==	O
CONNECT_MOVE	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE_GOOD_KO	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE_BAD_KO	int
||	O
(	O
move_reason_type	int
==	O
VITAL_EYE_MOVE	int
&&	O
board	*(char)
[	O
dd	int
]	O
==	O
color	int
)	O
)	O
&&	O
!	O
owl_defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
dd	int
)	O
)	O
{	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
dcode	int
=	O
owl_does_defend	(int,int,*(int))->(int)
(	O
pos	int
,	O
dd	int
,	O
&	O
kworm	int
)	O
;	O
if	O
(	O
dcode	int
>=	O
DRAGON2	O
(	O
dd	int
)	O
.	O
owl_defense_code	int
)	O
{	O
if	O
(	O
dcode	int
==	O
LOSS	int
)	O
add_loss_move	(int,int,int)->(void)
(	O
pos	int
,	O
dd	int
,	O
kworm	int
)	O
;	O
else	O
add_owl_defense_move	(int,int,int)->(void)
(	O
pos	int
,	O
dd	int
,	O
dcode	int
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"Move at %1m upgraded to owl defense for %1m (%s).\n"	*(char)
,	O
pos	int
,	O
dd	int
,	O
result_to_string	(int)->(*(char))
(	O
dcode	int
)	O
)	O
;	O
}	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
}	O
static	O
void	O
try_large_scale_owl_attack	(int,int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
target	int
,	O
int	O
dist	int
)	O
{	O
int	O
owl_nodes_before	int
;	O
int	O
owl_nodes_used	int
;	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
acode	int
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
int	O
save_owl_node_limit	int
=	O
owl_node_limit	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
target	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
!	O
owl_attack_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
target	int
)	O
,	O
pos	int
)	O
;	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
,	O
"Trying large scale move %1m on %1m\n"	*(char)
,	O
pos	int
,	O
target	int
)	O
;	O
increase_depth_values	()->(void)
(	O
)	O
;	O
if	O
(	O
dist	int
<=	O
1	int
)	O
owl_node_limit	int
*=	O
0.35	int
;	O
else	O
owl_node_limit	int
*=	O
0.15	int
;	O
if	O
(	O
DRAGON2	O
(	O
target	int
)	O
.	O
owl_attack_node_count	int
<	O
owl_node_limit	int
)	O
{	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
owl_nodes_before	int
=	O
get_owl_node_counter	()->(int)
(	O
)	O
;	O
acode	int
=	O
owl_does_attack	(int,int,*(int))->(int)
(	O
pos	int
,	O
target	int
,	O
&	O
kworm	int
)	O
;	O
owl_nodes_used	int
=	O
get_owl_node_counter	()->(int)
(	O
)	O
-	O
owl_nodes_before	int
;	O
if	O
(	O
acode	int
>=	O
DRAGON2	O
(	O
target	int
)	O
.	O
owl_attack_code	int
&&	O
acode	int
==	O
WIN	int
)	O
{	O
add_owl_attack_move	(int,int,int,int)->(void)
(	O
pos	int
,	O
target	int
,	O
kworm	int
,	O
acode	int
)	O
;	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
|	O
DEBUG_MOVE_REASONS	int
,	O
"Move at %1m owl-attacks %1m on a large scale(%s).\n"	*(char)
,	O
pos	int
,	O
target	int
,	O
result_to_string	(int)->(*(char))
(	O
acode	int
)	O
)	O
;	O
}	O
else	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
,	O
"Move at %1m isn't a clean large scale attack on %1m (%s).\n"	*(char)
,	O
pos	int
,	O
target	int
,	O
result_to_string	(int)->(*(char))
(	O
acode	int
)	O
)	O
;	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
,	O
"  owl nodes used = %d, dist = %d\n"	*(char)
,	O
owl_nodes_used	int
,	O
dist	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
}	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
owl_node_limit	int
=	O
save_owl_node_limit	int
;	O
}	O
static	O
void	O
find_large_scale_owl_attacks_on_dragon	(int,int)->(void)
(	O
int	O
color	int
,	O
int	O
target	int
)	O
{	O
int	O
x	int
,	O
y	int
;	O
int	O
x_min	int
=	O
board_size	int
;	O
int	O
x_max	int
=	O
0	int
;	O
int	O
y_min	int
=	O
board_size	int
;	O
int	O
y_max	int
=	O
0	int
;	O
int	O
dist	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
target	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
target	int
)	O
;	O
for	O
(	O
x	int
=	O
0	int
;	O
x	int
<	O
board_size	int
;	O
x	int
++	O
)	O
for	O
(	O
y	int
=	O
0	int
;	O
y	int
<	O
board_size	int
;	O
y	int
++	O
)	O
{	O
if	O
(	O
is_same_dragon	(int,int)->(int)
(	O
target	int
,	O
POS	O
(	O
x	int
,	O
y	int
)	O
)	O
)	O
{	O
if	O
(	O
x	int
<	O
x_min	int
)	O
x_min	int
=	O
x	int
;	O
if	O
(	O
x	int
>	O
x_max	int
)	O
x_max	int
=	O
x	int
;	O
if	O
(	O
y	int
<	O
y_min	int
)	O
y_min	int
=	O
y	int
;	O
if	O
(	O
y	int
>	O
y_max	int
)	O
y_max	int
=	O
y	int
;	O
}	O
}	O
ASSERT1	O
(	O
x_min	int
<=	O
x_max	int
&&	O
y_min	int
<=	O
y_max	int
,	O
target	int
)	O
;	O
for	O
(	O
dist	int
=	O
0	int
;	O
dist	int
<=	O
MAXIMUM_LARGE_SCALE_DIST	int
;	O
dist	int
++	O
)	O
for	O
(	O
x	int
=	O
gg_max	O
(	O
x_min	int
-	O
dist	int
,	O
0	int
)	O
;	O
x	int
<=	O
gg_min	O
(	O
x_max	int
+	O
dist	int
,	O
board_size	int
-	O
1	int
)	O
;	O
x	int
++	O
)	O
for	O
(	O
y	int
=	O
gg_max	O
(	O
y_min	int
-	O
dist	int
,	O
0	int
)	O
;	O
y	int
<=	O
gg_min	O
(	O
y_max	int
+	O
dist	int
,	O
board_size	int
-	O
1	int
)	O
;	O
y	int
++	O
)	O
{	O
int	O
pos	int
=	O
POS	O
(	O
x	int
,	O
y	int
)	O
;	O
ASSERT1	O
(	O
ON_BOARD2	O
(	O
x	int
,	O
y	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
a	char
,	O
b	char
,	O
dx	int
,	O
dy	int
;	O
a	char
=	O
abs	(int)->(int)
(	O
x	int
-	O
x_min	int
)	O
;	O
b	char
=	O
abs	(int)->(int)
(	O
x	int
-	O
x_max	int
)	O
;	O
dx	int
=	O
gg_min	O
(	O
a	char
,	O
b	char
)	O
;	O
a	char
=	O
abs	(int)->(int)
(	O
y	int
-	O
y_min	int
)	O
;	O
b	char
=	O
abs	(int)->(int)
(	O
y	int
-	O
y_max	int
)	O
;	O
dy	int
=	O
gg_min	O
(	O
a	char
,	O
b	char
)	O
;	O
if	O
(	O
gg_max	O
(	O
dx	int
,	O
dy	int
)	O
==	O
dist	int
&&	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
0	int
]	O
>=	O
0	int
&&	O
!	O
owl_attack_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
target	int
)	O
)	O
try_large_scale_owl_attack	(int,int,int,int)->(void)
(	O
pos	int
,	O
color	int
,	O
target	int
,	O
dist	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
find_large_scale_owl_attack_moves	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
d	int
;	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
,	O
"\nTrying to find large scale attack moves.\n"	*(char)
)	O
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
int	O
target	int
=	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
d	int
]	O
.	O
origin	int
;	O
if	O
(	O
dragon	int
[	O
target	int
]	O
.	O
color	int
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
dragon	int
[	O
target	int
]	O
.	O
size	int
<=	O
6	int
&&	O
dragon	int
[	O
target	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
&&	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
d	int
]	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
)	O
{	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
,	O
"Small critical dragon found at %1m\n"	*(char)
,	O
target	int
)	O
;	O
find_large_scale_owl_attacks_on_dragon	(int,int)->(void)
(	O
color	int
,	O
target	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
find_more_owl_attack_and_defense_moves	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
,	O
pos2	int
;	O
int	O
k	int
;	O
int	O
dd	int
=	O
NO_MOVE	O
;	O
int	O
worth_trying	int
;	O
int	O
save_verbose	int
;	O
struct	O
eye_data	struct(int,int,int,int,struct(char,char,char,char),char,char,char)
*	O
our_eyes	*(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
;	O
struct	O
eye_data	struct(int,int,int,int,struct(char,char,char,char),char,char,char)
*	O
your_eyes	*(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
;	O
struct	O
vital_eye_points	struct(array(int),array(int))
*	O
our_vital_points	*(struct(array(int),array(int)))
;	O
struct	O
vital_eye_points	struct(array(int),array(int))
*	O
your_vital_points	*(struct(array(int),array(int)))
;	O
if	O
(	O
verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"\nTrying to upgrade strategical attack and defense moves.\n"	*(char)
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
do_find_more_owl_attack_and_defense_moves	(int,int,int,int)->(void)
(	O
color	int
,	O
pos	int
,	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
,	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
)	O
;	O
}	O
}	O
if	O
(	O
verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"\nTrying vital eye moves as owl attacks.\n"	*(char)
)	O
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
{	O
our_eyes	*(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
white_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
;	O
your_eyes	*(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
black_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
;	O
our_vital_points	*(struct(array(int),array(int)))
=	O
white_vital_points	array(struct(array(int),array(int)))
;	O
your_vital_points	*(struct(array(int),array(int)))
=	O
black_vital_points	array(struct(array(int),array(int)))
;	O
}	O
else	O
{	O
our_eyes	*(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
black_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
;	O
your_eyes	*(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
white_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
;	O
our_vital_points	*(struct(array(int),array(int)))
=	O
black_vital_points	array(struct(array(int),array(int)))
;	O
your_vital_points	*(struct(array(int),array(int)))
=	O
white_vital_points	array(struct(array(int),array(int)))
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
our_eyes	*(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
&&	O
our_vital_points	*(struct(array(int),array(int)))
[	O
pos	int
]	O
.	O
defense_points	array(int)
[	O
0	int
]	O
!=	O
NO_MOVE	O
)	O
{	O
int	O
k	int
,	O
dr	int
;	O
find_eye_dragons	(int,array(struct(int,int,int,int,struct(char,char,char,char),char,char,char)),int,array(int),int)->(int)
(	O
pos	int
,	O
our_eyes	*(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
,	O
color	int
,	O
&	O
dr	int
,	O
1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_EYE_ATTACKS	int
;	O
k	int
++	O
)	O
{	O
int	O
move	*(int)
=	O
our_vital_points	*(struct(array(int),array(int)))
[	O
pos	int
]	O
.	O
defense_points	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
move	*(int)
==	O
NO_MOVE	O
)	O
break	O
;	O
do_find_more_owl_attack_and_defense_moves	(int,int,int,int)->(void)
(	O
color	int
,	O
move	*(int)
,	O
VITAL_EYE_MOVE	int
,	O
dr	int
)	O
;	O
}	O
}	O
if	O
(	O
your_eyes	*(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
&&	O
your_vital_points	*(struct(array(int),array(int)))
[	O
pos	int
]	O
.	O
attack_points	array(int)
[	O
0	int
]	O
!=	O
NO_MOVE	O
)	O
{	O
int	O
k	int
,	O
dr	int
;	O
find_eye_dragons	(int,array(struct(int,int,int,int,struct(char,char,char,char),char,char,char)),int,array(int),int)->(int)
(	O
pos	int
,	O
your_eyes	*(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
&	O
dr	int
,	O
1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_EYE_ATTACKS	int
;	O
k	int
++	O
)	O
{	O
int	O
move	*(int)
=	O
your_vital_points	*(struct(array(int),array(int)))
[	O
pos	int
]	O
.	O
attack_points	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
move	*(int)
==	O
NO_MOVE	O
)	O
break	O
;	O
do_find_more_owl_attack_and_defense_moves	(int,int,int,int)->(void)
(	O
color	int
,	O
move	*(int)
,	O
VITAL_EYE_MOVE	int
,	O
dr	int
)	O
;	O
}	O
}	O
}	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
)	O
{	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
worth_trying	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos2	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_GOOD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_BAD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_GOOD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_BAD_KO	int
)	O
{	O
dd	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
are_neighbor_dragons	(int,int)->(int)
(	O
dd	int
,	O
pos	int
)	O
)	O
{	O
worth_trying	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
worth_trying	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
!	O
owl_defense_move_reason_known	(int,int)->(int)
(	O
pos2	int
,	O
pos	int
)	O
)	O
{	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
dcode	int
=	O
owl_does_defend	(int,int,*(int))->(int)
(	O
pos2	int
,	O
pos	int
,	O
&	O
kworm	int
)	O
;	O
if	O
(	O
dcode	int
>=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
)	O
{	O
if	O
(	O
dcode	int
==	O
LOSS	int
)	O
add_loss_move	(int,int,int)->(void)
(	O
pos2	int
,	O
pos	int
,	O
kworm	int
)	O
;	O
else	O
add_owl_defense_move	(int,int,int)->(void)
(	O
pos2	int
,	O
pos	int
,	O
dcode	int
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"Move at %1m also owl defends %1m (%s).\n"	*(char)
,	O
pos2	int
,	O
pos	int
,	O
result_to_string	(int)->(*(char))
(	O
dcode	int
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
color	int
&&	O
!	O
owl_attack_move_reason_known	(int,int)->(int)
(	O
pos2	int
,	O
pos	int
)	O
)	O
{	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
acode	int
=	O
owl_does_attack	(int,int,*(int))->(int)
(	O
pos2	int
,	O
pos	int
,	O
&	O
kworm	int
)	O
;	O
if	O
(	O
acode	int
>=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_code	int
)	O
{	O
add_owl_attack_move	(int,int,int,int)->(void)
(	O
pos2	int
,	O
pos	int
,	O
kworm	int
,	O
acode	int
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	(*(char))->(int)
(	O
"Move at %1m also owl attacks %1m (%s).\n"	*(char)
,	O
pos2	int
,	O
pos	int
,	O
result_to_string	(int)->(*(char))
(	O
acode	int
)	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
}	O
static	O
void	O
try_potential_semeai_move	(int,int,*(struct(int,int,int)))->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
struct	O
move_reason	struct(int,int,int)
*	O
reason	array(int)
)	O
{	O
int	O
dr1	int
=	O
semeai_target1	array(int)
[	O
reason	array(int)
->	O
what	int
]	O
;	O
int	O
dr2	int
=	O
semeai_target2	array(int)
[	O
reason	array(int)
->	O
what	int
]	O
;	O
int	O
resulta	*(int)
,	O
resultb	*(int)
,	O
certain	*(int)
,	O
old_certain	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
dr1	int
]	O
)	O
,	O
pos	int
)	O
;	O
switch	O
(	O
reason	array(int)
->	O
type	char
)	O
{	O
case	O
POTENTIAL_SEMEAI_ATTACK	int
:	O
owl_analyze_semeai_after_move	(int,int,int,int,*(int),*(int),*(int),int,*(int),int)->(void)
(	O
pos	int
,	O
color	int
,	O
dr1	int
,	O
dr2	int
,	O
&	O
resulta	*(int)
,	O
&	O
resultb	*(int)
,	O
NULL	O
,	O
1	int
,	O
&	O
certain	*(int)
,	O
0	int
)	O
;	O
old_certain	int
=	O
DRAGON2	O
(	O
dr1	int
)	O
.	O
semeai_attack_certain	int
;	O
break	O
;	O
case	O
POTENTIAL_SEMEAI_DEFENSE	int
:	O
old_certain	int
=	O
DRAGON2	O
(	O
dr1	int
)	O
.	O
semeai_defense_certain	int
;	O
owl_analyze_semeai_after_move	(int,int,int,int,*(int),*(int),*(int),int,*(int),int)->(void)
(	O
pos	int
,	O
color	int
,	O
dr2	int
,	O
dr1	int
,	O
&	O
resulta	*(int)
,	O
&	O
resultb	*(int)
,	O
NULL	O
,	O
1	int
,	O
&	O
certain	*(int)
,	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
ASSERT1	O
(	O
0	int
,	O
pos	int
)	O
;	O
}	O
if	O
(	O
resulta	*(int)
==	O
0	int
&&	O
resultb	*(int)
==	O
0	int
&&	O
(	O
certain	*(int)
||	O
!	O
old_certain	int
)	O
)	O
{	O
add_semeai_move	(int,int)->(void)
(	O
pos	int
,	O
dr1	int
)	O
;	O
DEBUG	O
(	O
DEBUG_SEMEAI	int
,	O
"Potential semeai move at %1m for dragon at %1m is real\n"	*(char)
,	O
pos	int
,	O
dr1	int
)	O
;	O
}	O
else	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Potential semeai move at %1m for %1m discarded\n"	*(char)
,	O
pos	int
,	O
dr1	int
)	O
;	O
}	O
static	O
void	O
find_more_semeai_moves	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
k	int
,	O
r	int
;	O
int	O
potential_semeai_move_found	int
=	O
0	int
;	O
int	O
other_move_reason_found	int
=	O
0	int
;	O
if	O
(	O
!	O
ON_BOARD1	O
(	O
pos	int
)	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
POTENTIAL_SEMEAI_ATTACK	int
:	O
case	O
POTENTIAL_SEMEAI_DEFENSE	int
:	O
potential_semeai_move_found	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
other_move_reason_found	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
r	int
<	O
0	int
||	O
k	int
==	O
MAX_REASONS	int
)	O
&&	O
!	O
other_move_reason_found	int
)	O
continue	O
;	O
if	O
(	O
!	O
potential_semeai_move_found	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
POTENTIAL_SEMEAI_ATTACK	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
POTENTIAL_SEMEAI_DEFENSE	int
)	O
try_potential_semeai_move	(int,int,*(struct(int,int,int)))->(void)
(	O
pos	int
,	O
color	int
,	O
&	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
)	O
)	O
;	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
}	O
static	O
void	O
induce_secondary_move_reasons	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
aa	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE	int
)	O
{	O
int	O
attack_move	*(int)
;	O
int	O
color_to_move	int
;	O
int	O
num_adj	*(int)
,	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE	int
)	O
{	O
attack_move	*(int)
=	O
1	int
;	O
color_to_move	int
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
aa	int
]	O
)	O
;	O
}	O
else	O
{	O
attack_move	*(int)
=	O
0	int
;	O
color_to_move	int
=	O
board	*(char)
[	O
aa	int
]	O
;	O
}	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
)	O
continue	O
;	O
if	O
(	O
!	O
attack_move	*(int)
&&	O
!	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
)	O
continue	O
;	O
num_adj	*(int)
=	O
extended_chainlinks	(int,array(int),int)->(int)
(	O
aa	int
,	O
adjs	array(int)
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_adj	*(int)
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
num_adj	*(int)
;	O
j	int
++	O
)	O
{	O
int	O
adj1	int
=	O
adjs	array(int)
[	O
i	int
]	O
;	O
int	O
adj2	int
=	O
adjs	array(int)
[	O
j	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
adj1	int
]	O
!=	O
board	*(char)
[	O
adj2	int
]	O
)	O
continue	O
;	O
if	O
(	O
attack_move	*(int)
&&	O
board	*(char)
[	O
adj1	int
]	O
!=	O
board	*(char)
[	O
aa	int
]	O
&&	O
!	O
disconnect	(int,int,*(int))->(int)
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
attack_move	*(int)
&&	O
board	*(char)
[	O
adj1	int
]	O
!=	O
board	*(char)
[	O
aa	int
]	O
&&	O
!	O
string_connect	(int,int,*(int))->(int)
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
continue	O
;	O
if	O
(	O
attack_move	*(int)
&&	O
board	*(char)
[	O
adj1	int
]	O
==	O
board	*(char)
[	O
aa	int
]	O
)	O
continue	O
;	O
if	O
(	O
!	O
attack_move	*(int)
&&	O
board	*(char)
[	O
adj1	int
]	O
==	O
board	*(char)
[	O
aa	int
]	O
&&	O
!	O
disconnect	(int,int,*(int))->(int)
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
continue	O
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color_to_move	int
,	O
"induce_secondary_move_reasons"	*(char)
,	O
aa	int
)	O
)	O
{	O
if	O
(	O
attack_move	*(int)
&&	O
board	*(char)
[	O
adj1	int
]	O
!=	O
board	*(char)
[	O
aa	int
]	O
&&	O
!	O
disconnect	(int,int,*(int))->(int)
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Connection move at %1m induced for %1m/%1m due to attack of %1m\n"	*(char)
,	O
pos	int
,	O
adj1	int
,	O
adj2	int
,	O
aa	int
)	O
;	O
add_connection_move	(int,int,int)->(void)
(	O
pos	int
,	O
adj1	int
,	O
adj2	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	(int,int,int,int)->(void)
(	O
color	int
,	O
pos	int
,	O
CONNECT_MOVE	int
,	O
find_connection	(int,int)->(int)
(	O
adj1	int
,	O
adj2	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
attack_move	*(int)
&&	O
board	*(char)
[	O
adj1	int
]	O
!=	O
board	*(char)
[	O
aa	int
]	O
&&	O
!	O
string_connect	(int,int,*(int))->(int)
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Cut move at %1m induced for %1m/%1m due to defense of %1m\n"	*(char)
,	O
pos	int
,	O
adj1	int
,	O
adj2	int
,	O
aa	int
)	O
;	O
add_cut_move	(int,int,int)->(void)
(	O
pos	int
,	O
adj1	int
,	O
adj2	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
attack_move	*(int)
&&	O
board	*(char)
[	O
adj1	int
]	O
==	O
board	*(char)
[	O
aa	int
]	O
&&	O
!	O
disconnect	(int,int,*(int))->(int)
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Connection move at %1m induced for %1m/%1m due to defense of %1m\n"	*(char)
,	O
pos	int
,	O
adj1	int
,	O
adj2	int
,	O
aa	int
)	O
;	O
add_connection_move	(int,int,int)->(void)
(	O
pos	int
,	O
adj1	int
,	O
adj2	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	(int,int,int,int)->(void)
(	O
color	int
,	O
pos	int
,	O
CONNECT_MOVE	int
,	O
find_connection	(int,int)->(int)
(	O
adj1	int
,	O
adj2	int
)	O
)	O
;	O
}	O
else	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
attack_move	*(int)
)	O
{	O
int	O
strategically_valuable	int
=	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
size	int
>	O
3	int
)	O
;	O
signed	O
char	O
neighbor_dragons	array(char)
[	O
BOARDMAX	O
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
neighbor_dragons	array(char)
,	O
0	int
,	O
sizeof	O
(	O
neighbor_dragons	array(char)
)	O
)	O
;	O
if	O
(	O
!	O
strategically_valuable	int
)	O
{	O
int	O
num_dragons	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_adj	*(int)
;	O
i	int
++	O
)	O
{	O
int	O
origin	int
=	O
dragon	int
[	O
adjs	array(int)
[	O
i	int
]	O
]	O
.	O
origin	int
;	O
if	O
(	O
board	*(char)
[	O
origin	int
]	O
!=	O
color_to_move	int
&&	O
neighbor_dragons	array(char)
[	O
origin	int
]	O
!=	O
1	int
&&	O
dragon	int
[	O
origin	int
]	O
.	O
size	int
>	O
1	int
&&	O
dragon	int
[	O
origin	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
)	O
{	O
if	O
(	O
++	O
num_dragons	int
==	O
2	int
)	O
{	O
strategically_valuable	int
=	O
1	int
;	O
break	O
;	O
}	O
neighbor_dragons	array(char)
[	O
origin	int
]	O
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
strategically_valuable	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_adj	*(int)
;	O
i	int
++	O
)	O
{	O
int	O
origin	int
=	O
dragon	int
[	O
adjs	array(int)
[	O
i	int
]	O
]	O
.	O
origin	int
;	O
if	O
(	O
board	*(char)
[	O
origin	int
]	O
!=	O
color_to_move	int
&&	O
neighbor_dragons	array(char)
[	O
origin	int
]	O
!=	O
2	int
&&	O
dragon	int
[	O
origin	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
&&	O
dragon_weak	(int)->(int)
(	O
origin	int
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Strategical attack move at %1m induced for %1m due to defense of %1m\n"	*(char)
,	O
pos	int
,	O
origin	int
,	O
aa	int
)	O
;	O
add_strategical_attack_move	(int,int)->(void)
(	O
pos	int
,	O
origin	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	(int,int,int,int)->(void)
(	O
color	int
,	O
pos	int
,	O
STRATEGIC_ATTACK_MOVE	int
,	O
origin	int
)	O
;	O
neighbor_dragons	array(char)
[	O
origin	int
]	O
=	O
2	int
;	O
}	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE	int
)	O
{	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DRAGON2	O
(	O
aa	int
)	O
.	O
neighbors	int
;	O
i	int
++	O
)	O
{	O
int	O
bb	int
=	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array(int)
[	O
i	int
]	O
]	O
.	O
origin	int
;	O
if	O
(	O
dragon	int
[	O
bb	int
]	O
.	O
color	int
==	O
color	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
bb	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
==	O
0	int
&&	O
!	O
DRAGON2	O
(	O
bb	int
)	O
.	O
semeais	int
)	O
{	O
add_strategical_defense_move	(int,int)->(void)
(	O
pos	int
,	O
bb	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	(int,int,int,int)->(void)
(	O
color	int
,	O
pos	int
,	O
STRATEGIC_DEFEND_MOVE	int
,	O
bb	int
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Strategic defense at %1m induced for %1m due to owl attack on %1m\n"	*(char)
,	O
pos	int
,	O
bb	int
,	O
aa	int
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
CONNECT_MOVE	int
&&	O
cut_possible	(int,int)->(int)
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
{	O
int	O
worm1	int
=	O
conn_worm1	array(int)
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
;	O
int	O
worm2	int
=	O
conn_worm2	array(int)
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
;	O
int	O
pos2	int
;	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
board	*(char)
[	O
pos2	int
]	O
==	O
EMPTY	int
&&	O
cut_possible	(int,int)->(int)
(	O
pos2	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
&&	O
square_dist	(int,int)->(int)
(	O
pos	int
,	O
pos2	int
)	O
<=	O
5	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
8	int
;	O
j	int
++	O
)	O
{	O
int	O
pos3	int
=	O
pos2	int
+	O
delta	array(int)
[	O
j	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos3	int
)	O
&&	O
board	*(char)
[	O
pos3	int
]	O
==	O
color	int
&&	O
!	O
is_same_worm	(int,int)->(int)
(	O
pos3	int
,	O
worm1	int
)	O
&&	O
!	O
is_same_worm	(int,int)->(int)
(	O
pos3	int
,	O
worm2	int
)	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
"induce_secondary_move_reasons-B"	*(char)
,	O
worm1	int
)	O
)	O
{	O
int	O
break1	int
=	O
disconnect	(int,int,*(int))->(int)
(	O
pos3	int
,	O
worm1	int
,	O
NULL	O
)	O
;	O
int	O
break2	int
=	O
disconnect	(int,int,*(int))->(int)
(	O
pos3	int
,	O
worm2	int
,	O
NULL	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
break1	int
)	O
{	O
add_connection_move	(int,int,int)->(void)
(	O
pos	int
,	O
pos3	int
,	O
worm1	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	(int,int,int,int)->(void)
(	O
color	int
,	O
pos	int
,	O
CONNECT_MOVE	int
,	O
find_connection	(int,int)->(int)
(	O
pos3	int
,	O
worm1	int
)	O
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Connection at %1m induced for %1m/%1m due to connection at %1m/%1m\n"	*(char)
,	O
pos	int
,	O
worm1	int
,	O
worm2	int
,	O
pos3	int
,	O
worm1	int
)	O
;	O
}	O
if	O
(	O
!	O
break2	int
)	O
{	O
add_connection_move	(int,int,int)->(void)
(	O
pos	int
,	O
pos3	int
,	O
worm2	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	(int,int,int,int)->(void)
(	O
color	int
,	O
pos	int
,	O
CONNECT_MOVE	int
,	O
find_connection	(int,int)->(int)
(	O
pos3	int
,	O
worm2	int
)	O
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Connection at %1m induced for %1m/%1m due to connection at %1m/%1m\n"	*(char)
,	O
pos	int
,	O
worm1	int
,	O
worm2	int
,	O
pos3	int
,	O
worm2	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
examine_move_safety	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
start_timer	(int)->(void)
(	O
3	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
safety	int
=	O
0	int
;	O
int	O
tactical_safety	int
=	O
0	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
tactical_safety	int
=	O
is_known_safe_move	(int)->(int)
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
int	O
type	char
;	O
int	O
what	int
;	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
break	O
;	O
type	char
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
;	O
what	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
switch	O
(	O
type	char
)	O
{	O
case	O
CUT_MOVE	int
:	O
break	O
;	O
case	O
OWL_DEFEND_MOVE	int
:	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_LOSS	int
:	O
{	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
first_worm_in_dragon	(int)->(int)
(	O
what	int
)	O
;	O
ii	int
!=	O
NO_MOVE	O
;	O
ii	int
=	O
next_worm_in_dragon	(int)->(int)
(	O
ii	int
)	O
)	O
{	O
if	O
(	O
!	O
play_connect_n	(int,int,int)->(int)
(	O
color	int
,	O
0	int
,	O
1	int
,	O
pos	int
,	O
ii	int
,	O
pos	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
ii	int
!=	O
NO_MOVE	O
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
SEMEAI_MOVE	int
:	O
case	O
MY_ATARI_ATARI_MOVE	int
:	O
case	O
YOUR_ATARI_ATARI_MOVE	int
:	O
case	O
EITHER_MOVE	int
:	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
break	O
;	O
case	O
ALL_MOVE	int
:	O
break	O
;	O
case	O
EXPAND_TERRITORY_MOVE	int
:	O
case	O
EXPAND_MOYO_MOVE	int
:	O
case	O
INVASION_MOVE	int
:	O
safety	int
=	O
1	int
;	O
break	O
;	O
case	O
ATTACK_MOVE	int
:	O
case	O
ATTACK_MOVE_GOOD_KO	int
:	O
case	O
ATTACK_MOVE_BAD_KO	int
:	O
case	O
OWL_ATTACK_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_GAIN	int
:	O
{	O
int	O
aa	int
=	O
NO_MOVE	O
;	O
int	O
bb	int
=	O
NO_MOVE	O
;	O
int	O
size	int
;	O
int	O
m	int
;	O
int	O
our_color_neighbors	int
;	O
if	O
(	O
type	char
==	O
ATTACK_MOVE	int
||	O
type	char
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
type	char
==	O
ATTACK_MOVE_BAD_KO	int
)	O
{	O
aa	int
=	O
what	int
;	O
size	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
;	O
}	O
else	O
if	O
(	O
type	char
==	O
OWL_ATTACK_MOVE_GAIN	int
)	O
{	O
aa	int
=	O
either_data	array(struct(int,int,int,int))
[	O
what	int
]	O
.	O
what2	int
;	O
size	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
;	O
}	O
else	O
{	O
aa	int
=	O
what	int
;	O
size	int
=	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
;	O
}	O
if	O
(	O
size	int
>=	O
8	int
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
break	O
;	O
}	O
our_color_neighbors	int
=	O
0	int
;	O
if	O
(	O
type	char
==	O
ATTACK_MOVE	int
||	O
type	char
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
type	char
==	O
ATTACK_MOVE_BAD_KO	int
)	O
{	O
int	O
num_adj	*(int)
,	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
num_adj	*(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
aa	int
,	O
adjs	array(int)
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
num_adj	*(int)
;	O
m	int
++	O
)	O
{	O
int	O
adj	array(int)
=	O
adjs	array(int)
[	O
m	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
adj	array(int)
]	O
==	O
color	int
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
m	int
;	O
n	int
++	O
)	O
if	O
(	O
dragon	int
[	O
adjs	array(int)
[	O
n	int
]	O
]	O
.	O
id	int
==	O
dragon	int
[	O
adj	array(int)
]	O
.	O
id	int
)	O
break	O
;	O
if	O
(	O
n	int
==	O
m	int
)	O
{	O
our_color_neighbors	int
++	O
;	O
bb	int
=	O
adj	array(int)
;	O
}	O
}	O
}	O
}	O
else	O
{	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
DRAGON2	O
(	O
aa	int
)	O
.	O
neighbors	int
;	O
m	int
++	O
)	O
if	O
(	O
DRAGON	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array(int)
[	O
m	int
]	O
)	O
.	O
color	int
==	O
color	int
)	O
{	O
our_color_neighbors	int
++	O
;	O
bb	int
=	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array(int)
[	O
m	int
]	O
]	O
.	O
origin	int
;	O
if	O
(	O
dragon	int
[	O
bb	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
our_color_neighbors	int
>	O
1	int
)	O
break	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
4	int
;	O
m	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array(int)
[	O
m	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
d	int
]	O
==	O
color	int
)	O
{	O
bb	int
=	O
pos	int
+	O
d	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
bb	int
==	O
NO_MOVE	O
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
dragon	int
[	O
bb	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
owl_does_defend	(int,int,*(int))->(int)
(	O
pos	int
,	O
bb	int
,	O
NULL	O
)	O
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
DEFEND_MOVE	int
:	O
case	O
DEFEND_MOVE_GOOD_KO	int
:	O
case	O
DEFEND_MOVE_BAD_KO	int
:	O
{	O
int	O
aa	int
=	O
what	int
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
)	O
safety	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
play_connect_n	(int,int,int)->(int)
(	O
color	int
,	O
0	int
,	O
1	int
,	O
pos	int
,	O
aa	int
,	O
pos	int
)	O
&&	O
owl_does_defend	(int,int,*(int))->(int)
(	O
pos	int
,	O
aa	int
,	O
NULL	O
)	O
)	O
safety	int
=	O
1	int
;	O
break	O
;	O
}	O
case	O
ATTACK_THREAT	O
:	O
case	O
DEFEND_THREAT	O
:	O
break	O
;	O
case	O
CONNECT_MOVE	int
:	O
{	O
int	O
worm1	int
=	O
conn_worm1	array(int)
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
;	O
int	O
worm2	int
=	O
conn_worm2	array(int)
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
;	O
int	O
aa	int
=	O
dragon	int
[	O
worm1	int
]	O
.	O
origin	int
;	O
int	O
bb	int
=	O
dragon	int
[	O
worm2	int
]	O
.	O
origin	int
;	O
if	O
(	O
aa	int
==	O
bb	int
)	O
continue	O
;	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
||	O
DRAGON2	O
(	O
bb	int
)	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
UNCHECKED	int
&&	O
dragon	int
[	O
aa	int
]	O
.	O
crude_status	(int)->(enum)
==	O
ALIVE	int
)	O
||	O
(	O
DRAGON2	O
(	O
bb	int
)	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
UNCHECKED	int
&&	O
dragon	int
[	O
bb	int
]	O
.	O
crude_status	(int)->(enum)
==	O
ALIVE	int
)	O
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
owl_connection_defends	(int,int,int)->(int)
(	O
pos	int
,	O
aa	int
,	O
bb	int
)	O
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
safety	int
==	O
1	int
&&	O
(	O
tactical_safety	int
==	O
1	int
||	O
safe_move	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
safety	int
==	O
1	int
&&	O
(	O
tactical_safety	int
||	O
safe_move	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
)	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
=	O
1	int
;	O
else	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
=	O
0	int
;	O
time_report	(int,*(char),int,double)->(double)
(	O
3	int
,	O
"    examine_move_safety: "	*(char)
,	O
pos	int
,	O
1.0	int
)	O
;	O
}	O
}	O
float	O
dragon_weakness	(int,int)->(float)
(	O
int	O
dr	int
,	O
int	O
ignore_dead_dragons	int
)	O
{	O
int	O
dragon_safety	int
=	O
DRAGON2	O
(	O
dr	int
)	O
.	O
safety	int
;	O
if	O
(	O
ignore_dead_dragons	int
&&	O
(	O
dragon_safety	int
==	O
DEAD	int
||	O
dragon_safety	int
==	O
INESSENTIAL	int
||	O
dragon_safety	int
==	O
TACTICALLY_DEAD	int
)	O
)	O
return	O
0.0	int
;	O
if	O
(	O
doing_scoring	int
&&	O
dragon_safety	int
==	O
ALIVE	int
)	O
return	O
0.0	int
;	O
return	O
DRAGON2	O
(	O
dr	int
)	O
.	O
weakness	float
;	O
}	O
static	O
float	O
connection_value	(int,int,int,float)->(float)
(	O
int	O
dragona	int
,	O
int	O
dragonb	int
,	O
int	O
tt	int
,	O
float	O
margin	float
)	O
{	O
struct	O
dragon_data2	struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int)
*	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
=	O
&	O
DRAGON2	O
(	O
dragona	int
)	O
;	O
struct	O
dragon_data2	struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int)
*	O
db	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
=	O
&	O
DRAGON2	O
(	O
dragonb	int
)	O
;	O
float	O
sizea	float
=	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
strategic_size	float
;	O
float	O
sizeb	float
=	O
db	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
strategic_size	float
;	O
int	O
safetya	int
=	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
safety	int
;	O
int	O
safetyb	int
=	O
db	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
safety	int
;	O
float	O
crude_weakness_a	float
=	O
crude_dragon_weakness	(int,*(struct),int,float,float)->(float)
(	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
safety	int
,	O
&	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
genus	*(struct)
,	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
lunch	int
!=	O
NO_MOVE	O
,	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
moyo_territorial_value	float
,	O
(	O
float	O
)	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
escape_route	float
)	O
;	O
float	O
crude_weakness_sum	float
;	O
struct	O
eyevalue	struct(char,char,char,char)
genus_sum	struct(char,char,char,char)
;	O
float	O
terr_val	float
=	O
move	*(int)
[	O
tt	int
]	O
.	O
territorial_value	array(float)
;	O
float	O
return_value	float
;	O
if	O
(	O
margin	float
>	O
20.0	int
)	O
margin	float
=	O
20.0	int
;	O
if	O
(	O
doing_scoring	int
)	O
{	O
if	O
(	O
(	O
safetya	int
==	O
ALIVE	int
||	O
safetya	int
==	O
STRONGLY_ALIVE	int
||	O
safetya	int
==	O
INVINCIBLE	int
)	O
&&	O
(	O
safetyb	int
==	O
ALIVE	int
||	O
safetyb	int
==	O
STRONGLY_ALIVE	int
||	O
safetyb	int
==	O
INVINCIBLE	int
)	O
)	O
return	O
0.0	int
;	O
}	O
if	O
(	O
safetyb	int
==	O
INESSENTIAL	int
)	O
return	O
0.0	int
;	O
if	O
(	O
crude_weakness_a	float
==	O
0.0	int
||	O
dragon	int
[	O
dragona	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
return	O
0.0	int
;	O
if	O
(	O
terr_val	float
<	O
0.0	int
)	O
terr_val	float
=	O
0.0	int
;	O
add_eyevalues	(*(struct(char,char,char,char)),*(struct(char,char,char,char)),*(struct(char,char,char,char)))->(void)
(	O
&	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
genus	*(struct)
,	O
&	O
db	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
genus	*(struct)
,	O
&	O
genus_sum	struct(char,char,char,char)
)	O
;	O
crude_weakness_sum	float
=	O
crude_dragon_weakness	(int,*(struct),int,float,float)->(float)
(	O
safetyb	int
,	O
&	O
genus_sum	struct(char,char,char,char)
,	O
(	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
lunch	int
!=	O
NO_MOVE	O
||	O
db	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
lunch	int
!=	O
NO_MOVE	O
)	O
,	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
moyo_territorial_value	float
+	O
db	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
moyo_territorial_value	float
+	O
terr_val	float
,	O
(	O
float	O
)	O
da	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
->	O
escape_route	float
)	O
;	O
if	O
(	O
dragon	int
[	O
dragona	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
)	O
{	O
float	O
bonus	float
=	O
(	O
0.4	int
-	O
0.3	int
*	O
crude_weakness_sum	float
)	O
*	O
sizea	float
;	O
if	O
(	O
bonus	float
<	O
0.0	int
)	O
bonus	float
=	O
0.0	int
;	O
if	O
(	O
margin	float
>	O
0.0	int
&&	O
bonus	float
>	O
0.0	int
)	O
bonus	float
*=	O
1.0	int
+	O
0.05	int
*	O
margin	float
;	O
return_value	float
=	O
2.0	int
*	O
sizea	float
+	O
bonus	float
;	O
}	O
else	O
{	O
float	O
old_burden	float
=	O
2.0	int
*	O
crude_weakness_a	float
*	O
soft_cap	(float,float)->(float)
(	O
sizea	float
,	O
15.0	int
)	O
;	O
float	O
new_burden	float
=	O
2.0	int
*	O
crude_weakness_sum	float
*	O
soft_cap	(float,float)->(float)
(	O
sizea	float
+	O
sizeb	float
,	O
15.0	int
)	O
*	O
sizea	float
/	O
(	O
sizea	float
+	O
sizeb	float
)	O
;	O
return_value	float
=	O
1.05	int
*	O
(	O
old_burden	float
-	O
new_burden	float
)	O
;	O
if	O
(	O
margin	float
>	O
0.0	int
)	O
return_value	float
*=	O
1.0	int
+	O
0.02	int
*	O
margin	float
;	O
}	O
if	O
(	O
return_value	float
<	O
0.0	int
)	O
return_value	float
=	O
0.0	int
;	O
return	O
return_value	float
;	O
}	O
static	O
float	O
compute_shape_factor	(int)->(float)
(	O
int	O
pos	int
)	O
{	O
float	O
exponent	float
=	O
move	*(int)
[	O
pos	int
]	O
.	O
maxpos_shape	float
-	O
move	*(int)
[	O
pos	int
]	O
.	O
maxneg_shape	float
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
numpos_shape	int
>	O
1	int
)	O
exponent	float
+=	O
move	*(int)
[	O
pos	int
]	O
.	O
numpos_shape	int
-	O
1	int
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
numneg_shape	int
>	O
1	int
)	O
exponent	float
-=	O
move	*(int)
[	O
pos	int
]	O
.	O
numneg_shape	int
-	O
1	int
;	O
return	O
pow	(double,double)->(double)
(	O
1.05	int
,	O
exponent	float
)	O
;	O
}	O
static	O
float	O
adjusted_worm_attack_value	(int,int)->(float)
(	O
int	O
pos	int
,	O
int	O
ww	int
)	O
{	O
int	O
num_adj	*(int)
;	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
has_live_neighbor	int
=	O
0	int
;	O
float	O
adjusted_value	float
=	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ww	int
]	O
.	O
effective_size	float
;	O
float	O
adjustment_up	float
=	O
0.0	int
;	O
float	O
adjustment_down	float
=	O
0.0	int
;	O
int	O
s	int
;	O
num_adj	*(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
ww	int
,	O
adjs	array(int)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
num_adj	*(int)
;	O
s	int
++	O
)	O
{	O
int	O
adj	array(int)
=	O
adjs	array(int)
[	O
s	int
]	O
;	O
if	O
(	O
dragon	int
[	O
adj	array(int)
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
)	O
has_live_neighbor	int
=	O
1	int
;	O
if	O
(	O
dragon	int
[	O
adj	array(int)
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
&&	O
2	int
*	O
dragon	int
[	O
adj	array(int)
]	O
.	O
effective_size	float
>	O
adjustment_up	float
)	O
adjustment_up	float
=	O
2	int
*	O
dragon	int
[	O
adj	array(int)
]	O
.	O
effective_size	float
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
adj	array(int)
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
!	O
does_defend	(int,int)->(int)
(	O
pos	int
,	O
adj	array(int)
)	O
&&	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
adj	array(int)
]	O
.	O
effective_size	float
>	O
adjustment_down	float
)	O
adjustment_down	float
=	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
adj	array(int)
]	O
.	O
effective_size	float
;	O
}	O
if	O
(	O
has_live_neighbor	int
)	O
adjusted_value	float
+=	O
adjustment_up	float
;	O
adjusted_value	float
-=	O
adjustment_down	float
;	O
if	O
(	O
adjusted_value	float
>	O
0.0	int
)	O
return	O
adjusted_value	float
;	O
else	O
return	O
0.0	int
;	O
}	O
static	O
float	O
strategic_penalty	(int,int)->(float)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
float	O
ret_val	float
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
whose_area	(*(struct),int)->(int)
(	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
)	O
!=	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
return	O
0.0	int
;	O
if	O
(	O
whose_area	(*(struct),int)->(int)
(	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
pos	int
)	O
!=	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
return	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
EXPAND_MOYO_MOVE	int
:	O
case	O
STRATEGIC_ATTACK_MOVE	int
:	O
case	O
INVASION_MOVE	int
:	O
continue	O
;	O
case	O
DEFEND_MOVE	int
:	O
{	O
int	O
target	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
dragon	int
[	O
target	int
]	O
.	O
size	int
>	O
1	int
)	O
return	O
0.0	int
;	O
continue	O
;	O
}	O
case	O
OWL_DEFEND_MOVE	int
:	O
{	O
int	O
target	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
int	O
has_strong_neighbor	int
=	O
0	int
;	O
int	O
has_weak_neighbor	int
=	O
0	int
;	O
int	O
i	int
;	O
if	O
(	O
dragon	int
[	O
target	int
]	O
.	O
size	int
>	O
1	int
||	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
cutstone	int
>	O
0	int
||	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
cutstone2	int
>	O
0	int
)	O
return	O
0.0	int
;	O
if	O
(	O
edge_distance	(int)->(int)
(	O
pos	int
)	O
<	O
3	int
)	O
return	O
0.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
target	int
+	O
delta	array(int)
[	O
i	int
]	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
if	O
(	O
dragon	int
[	O
target	int
+	O
delta	array(int)
[	O
i	int
]	O
]	O
.	O
size	int
==	O
1	int
)	O
{	O
has_weak_neighbor	int
=	O
1	int
;	O
break	O
;	O
}	O
switch	O
(	O
DRAGON2	O
(	O
target	int
+	O
delta	array(int)
[	O
i	int
]	O
)	O
.	O
safety	int
)	O
{	O
case	O
INVINCIBLE	int
:	O
case	O
STRONGLY_ALIVE	int
:	O
has_strong_neighbor	int
=	O
1	int
;	O
break	O
;	O
case	O
ALIVE	int
:	O
if	O
(	O
DRAGON2	O
(	O
target	int
+	O
delta	array(int)
[	O
i	int
]	O
)	O
.	O
weakness	float
>	O
0.4	int
)	O
has_weak_neighbor	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
has_weak_neighbor	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
has_weak_neighbor	int
||	O
(	O
!	O
has_strong_neighbor	int
)	O
)	O
return	O
0.0	int
;	O
else	O
continue	O
;	O
}	O
default	O
:	O
return	O
0.0	int
;	O
}	O
}	O
ret_val	float
=	O
influence_territory	(*(struct),int,int)->(float)
(	O
INITIAL_INFLUENCE	O
(	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
,	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
;	O
ret_val	float
*=	O
12.0	int
;	O
ret_val	float
=	O
gg_max	O
(	O
0.0	int
,	O
ret_val	float
)	O
;	O
return	O
ret_val	float
;	O
}	O
int	O
adjacent_to_nondead_stone	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
stack	array(int)
[	O
MAXSTACK	O
]	O
;	O
int	O
move_color	array(int)
[	O
MAXSTACK	O
]	O
;	O
int	O
saved_stackp	int
=	O
stackp	int
;	O
int	O
result	int
=	O
0	int
;	O
while	O
(	O
stackp	int
>	O
0	int
)	O
{	O
get_move_from_stack	(int,*(int),*(int))->(void)
(	O
stackp	int
-	O
1	int
,	O
&	O
stack	array(int)
[	O
stackp	int
-	O
1	int
]	O
,	O
&	O
move_color	array(int)
[	O
stackp	int
-	O
1	int
]	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
NULL	O
,	O
EMPTY	int
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
12	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
;	O
if	O
(	O
k	int
<	O
8	int
)	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
else	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array(int)
[	O
k	int
-	O
8	int
]	O
)	O
)	O
pos2	int
=	O
pos	int
+	O
2	int
*	O
delta	array(int)
[	O
k	int
-	O
8	int
]	O
;	O
else	O
continue	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos2	int
]	O
.	O
color	int
==	O
color	int
&&	O
dragon	int
[	O
pos2	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
&&	O
!	O
disconnect	(int,int,*(int))->(int)
(	O
pos	int
,	O
pos2	int
,	O
NULL	O
)	O
)	O
{	O
result	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
while	O
(	O
stackp	int
<	O
saved_stackp	int
)	O
tryko	(int,int,*(char))->(int)
(	O
stack	array(int)
[	O
stackp	int
]	O
,	O
move_color	array(int)
[	O
stackp	int
]	O
,	O
NULL	O
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
max_lunch_eye_value	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
min	*(int)
;	O
int	O
probable	*(int)
;	O
int	O
max	*(int)
;	O
estimate_lunch_eye_value	(int,*(int),*(int),*(int),int)->(void)
(	O
pos	int
,	O
&	O
min	*(int)
,	O
&	O
probable	*(int)
,	O
&	O
max	*(int)
,	O
0	int
)	O
;	O
return	O
max	*(int)
;	O
}	O
static	O
void	O
estimate_territorial_value	(int,int,float,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
float	O
our_score	float
,	O
int	O
disable_delta_territory_cache	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
int	O
aa	int
=	O
NO_MOVE	O
;	O
int	O
bb	int
=	O
NO_MOVE	O
;	O
float	O
this_value	float
=	O
0.0	int
;	O
float	O
tot_value	float
=	O
0.0	int
;	O
float	O
secondary_value	float
=	O
0.0	int
;	O
int	O
does_block	int
=	O
0	int
;	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
;	O
float	O
strength	array(float)
[	O
BOARDMAX	O
]	O
;	O
set_strength_data	(int,array(char),array(float))->(void)
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
safe_stones	array(char)
,	O
strength	array(float)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
&	O
TERRITORY_REDUNDANT	int
)	O
continue	O
;	O
this_value	float
=	O
0.0	int
;	O
switch	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
ATTACK_MOVE	int
:	O
case	O
ATTACK_MOVE_GOOD_KO	int
:	O
case	O
ATTACK_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
aa	int
]	O
!=	O
color	int
,	O
aa	int
)	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f (secondary) - attack on %1m (defenseless)\n"	*(char)
,	O
pos	int
,	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
secondary_value	float
+=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
;	O
does_block	int
=	O
1	int
;	O
break	O
;	O
}	O
this_value	float
=	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f (secondary) - attack on %1m (dead)\n"	*(char)
,	O
pos	int
,	O
0.2	int
*	O
this_value	float
,	O
aa	int
)	O
;	O
secondary_value	float
+=	O
0.2	int
*	O
this_value	float
;	O
does_block	int
=	O
1	int
;	O
break	O
;	O
}	O
mark_changed_string	(int,array(char),array(float),char)->(void)
(	O
aa	int
,	O
safe_stones	array(char)
,	O
strength	array(float)
,	O
0	int
)	O
;	O
TRACE	O
(	O
"  %1m: attack on worm %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE	int
)	O
this_value	float
=	O
0.0	int
;	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_GOOD_KO	int
)	O
{	O
this_value	float
*=	O
0.3	int
;	O
TRACE	O
(	O
"  %1m: -%f - attack on worm %1m only with good ko\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_BAD_KO	int
)	O
{	O
this_value	float
*=	O
0.5	int
;	O
TRACE	O
(	O
"  %1m: -%f - attack on worm %1m only with bad ko\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
tot_value	float
-=	O
this_value	float
;	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
DEFEND_MOVE	int
:	O
case	O
DEFEND_MOVE_GOOD_KO	int
:	O
case	O
DEFEND_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
aa	int
]	O
==	O
color	int
,	O
aa	int
)	O
;	O
this_value	float
=	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f (secondary) - defense of %1m (dead)\n"	*(char)
,	O
pos	int
,	O
0.2	int
*	O
this_value	float
,	O
aa	int
)	O
;	O
secondary_value	float
+=	O
0.2	int
*	O
this_value	float
;	O
break	O
;	O
}	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
&&	O
(	O
owl_defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
<	O
defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
)	O
&&	O
!	O
semeai_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f (secondary) - ineffective defense of %1m (critical)\n"	*(char)
,	O
pos	int
,	O
0.2	int
*	O
this_value	float
,	O
aa	int
)	O
;	O
secondary_value	float
+=	O
0.2	int
*	O
this_value	float
;	O
break	O
;	O
}	O
mark_changed_string	(int,array(char),array(float),char)->(void)
(	O
aa	int
,	O
safe_stones	array(char)
,	O
strength	array(float)
,	O
INFLUENCE_SAVED_STONE	int
)	O
;	O
TRACE	O
(	O
"  %1m: defense of worm %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE	int
)	O
this_value	float
=	O
0.0	int
;	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_GOOD_KO	int
)	O
{	O
this_value	float
*=	O
0.3	int
;	O
TRACE	O
(	O
"  %1m: -%f - defense of worm %1m with good ko\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_BAD_KO	int
)	O
{	O
this_value	float
*=	O
0.5	int
;	O
TRACE	O
(	O
"  %1m: -%f - defense of worm %1m with bad ko\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
tot_value	float
-=	O
this_value	float
;	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
&&	O
(	O
owl_defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
<	O
defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
)	O
)	O
{	O
this_value	float
=	O
0.45	int
*	O
(	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
TRACE	O
(	O
"  %1m: -%f - suspected ineffective defense of worm %1m\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
tot_value	float
-=	O
this_value	float
;	O
}	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
ATTACK_THREAT	O
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
aa	int
]	O
==	O
other	int
,	O
aa	int
)	O
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"    %1m: 0.0 - threatens to capture %1m (dead)\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
"estimate_territorial_value-A"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
int	O
adjs	array(int)
[	O
MAXCHAIN	int
]	O
;	O
float	O
adjusted_value	float
=	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
;	O
float	O
adjustment_up	float
=	O
0.0	int
;	O
float	O
adjustment_down	float
=	O
0.0	int
;	O
int	O
s	int
;	O
int	O
num_adj	*(int)
;	O
int	O
defense_move	int
;	O
if	O
(	O
board	*(char)
[	O
aa	int
]	O
==	O
EMPTY	int
)	O
num_adj	*(int)
=	O
0	int
;	O
else	O
num_adj	*(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
aa	int
,	O
adjs	array(int)
)	O
;	O
if	O
(	O
!	O
is_known_good_attack_threat	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
&&	O
board	*(char)
[	O
aa	int
]	O
!=	O
EMPTY	int
&&	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
==	O
1	int
||	O
adjacent_to_nondead_stone	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
||	O
owl_defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
-	O
1	int
)	O
)	O
&&	O
find_defense	(int,*(int))->(int)
(	O
aa	int
,	O
&	O
defense_move	int
)	O
==	O
WIN	int
&&	O
defense_move	int
!=	O
NO_MOVE	O
)	O
{	O
int	O
bad_followup	int
;	O
int	O
attack_move	*(int)
;	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
&	O
attack_move	*(int)
)	O
!=	O
WIN	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
defense_move	int
,	O
other	int
,	O
"estimate_territorial_value-b"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_REASONS	int
;	O
i	int
++	O
)	O
{	O
int	O
reason	array(int)
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
i	int
]	O
;	O
int	O
attacked_string	int
;	O
if	O
(	O
reason	array(int)
<	O
0	int
)	O
break	O
;	O
attacked_string	int
=	O
move_reasons	array(struct(int,int,int))
[	O
reason	array(int)
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
reason	array(int)
]	O
.	O
type	char
==	O
ATTACK_MOVE	int
&&	O
board	*(char)
[	O
attacked_string	int
]	O
==	O
other	int
)	O
{	O
int	O
defense_code	int
=	O
find_defense	(int,*(int))->(int)
(	O
attacked_string	int
,	O
NULL	O
)	O
;	O
double	O
down_coefficient	double
=	O
0.0	int
;	O
switch	O
(	O
defense_code	int
)	O
{	O
case	O
WIN	int
:	O
down_coefficient	double
=	O
2.0	int
;	O
break	O
;	O
case	O
KO_A	int
:	O
down_coefficient	double
=	O
2.0	int
*	O
0.5	int
;	O
break	O
;	O
case	O
KO_B	int
:	O
down_coefficient	double
=	O
2.0	int
*	O
0.7	int
;	O
break	O
;	O
}	O
if	O
(	O
adjustment_down	float
<	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
attacked_string	int
]	O
.	O
effective_size	float
*	O
down_coefficient	double
)	O
)	O
{	O
adjustment_down	float
=	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
attacked_string	int
]	O
.	O
effective_size	float
*	O
down_coefficient	double
)	O
;	O
}	O
}	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
attack_move	*(int)
,	O
other	int
,	O
"estimate_territorial_value-c"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
aa	int
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
adjustment_down	float
=	O
2	int
*	O
countstones	(int)->(int)
(	O
pos	int
)	O
;	O
}	O
bad_followup	int
=	O
0	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
num_adj	*(int)
;	O
s	int
++	O
)	O
{	O
int	O
lib	int
;	O
if	O
(	O
countlib	(int)->(int)
(	O
adjs	array(int)
[	O
s	int
]	O
)	O
==	O
1	int
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
adjs	array(int)
[	O
s	int
]	O
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
lib	int
,	O
other	int
,	O
"estimate_territorial_value-d"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
!	O
attack	(int,*(int))->(int)
(	O
aa	int
,	O
NULL	O
)	O
&&	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
bad_followup	int
=	O
1	int
;	O
break	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
bad_followup	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
num_adj	*(int)
;	O
s	int
++	O
)	O
{	O
int	O
adj	array(int)
=	O
adjs	array(int)
[	O
s	int
]	O
;	O
if	O
(	O
same_string	(int,int)->(int)
(	O
pos	int
,	O
adj	array(int)
)	O
)	O
continue	O
;	O
if	O
(	O
dragon	int
[	O
adj	array(int)
]	O
.	O
color	int
==	O
color	int
&&	O
dragon	int
[	O
adj	array(int)
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
&&	O
2	int
*	O
dragon	int
[	O
adj	array(int)
]	O
.	O
effective_size	float
>	O
adjustment_up	float
)	O
adjustment_up	float
=	O
2	int
*	O
dragon	int
[	O
adj	array(int)
]	O
.	O
effective_size	float
;	O
if	O
(	O
dragon	int
[	O
adj	array(int)
]	O
.	O
color	int
==	O
color	int
&&	O
attack	(int,*(int))->(int)
(	O
adj	array(int)
,	O
NULL	O
)	O
&&	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
adj	array(int)
]	O
.	O
effective_size	float
>	O
adjustment_down	float
)	O
adjustment_down	float
=	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
adj	array(int)
]	O
.	O
effective_size	float
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
{	O
int	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
==	O
0	int
&&	O
!	O
owl_substantial	(int)->(int)
(	O
aa	int
)	O
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
break	O
;	O
}	O
verbose	int
=	O
save_verbose	int
;	O
}	O
adjusted_value	float
+=	O
adjustment_up	float
;	O
adjusted_value	float
-=	O
adjustment_down	float
;	O
if	O
(	O
adjusted_value	float
>	O
0.0	int
)	O
{	O
add_followup_value	(int,float)->(void)
(	O
pos	int
,	O
adjusted_value	float
)	O
;	O
TRACE	O
(	O
"  %1m:   %f (followup) - threatens to capture %1m\n"	*(char)
,	O
pos	int
,	O
adjusted_value	float
,	O
aa	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DEFEND_THREAT	O
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
aa	int
]	O
==	O
color	int
,	O
aa	int
)	O
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
"estimate_territorial_value-A"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
int	O
attack_move	*(int)
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
==	O
1	int
&&	O
attack	(int,*(int))->(int)
(	O
aa	int
,	O
&	O
attack_move	*(int)
)	O
==	O
WIN	int
&&	O
attack_move	*(int)
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
attack_move	*(int)
,	O
other	int
,	O
"estimate_territorial_value-b"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
add_followup_value	(int,float)->(void)
(	O
pos	int
,	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
TRACE	O
(	O
"  %1m:   %f (followup) - threatens to defend %1m\n"	*(char)
,	O
pos	int
,	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
UNCERTAIN_OWL_DEFENSE	int
:	O
break	O
;	O
case	O
CUT_MOVE	int
:	O
case	O
EXPAND_MOYO_MOVE	int
:	O
case	O
EXPAND_TERRITORY_MOVE	int
:	O
case	O
INVASION_MOVE	int
:	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
CONNECT_MOVE	int
:	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
)	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
STRATEGIC_ATTACK_MOVE	int
:	O
case	O
STRATEGIC_DEFEND_MOVE	int
:	O
if	O
(	O
!	O
doing_scoring	int
)	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
SEMEAI_THREAT	O
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
add_followup_value	(int,float)->(void)
(	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
TRACE	O
(	O
"  %1m: %f (followup) - threatens to win semeai for %1m\n"	*(char)
,	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
SEMEAI_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_GAIN	int
:	O
case	O
OWL_DEFEND_MOVE	int
:	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_LOSS	int
:	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_GAIN	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_LOSS	int
)	O
{	O
aa	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
bb	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
}	O
else	O
{	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
bb	int
=	O
NO_MOVE	O
;	O
}	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
size	int
==	O
1	int
&&	O
is_ko_point	(int)->(int)
(	O
aa	int
)	O
&&	O
liberty_of_string	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
)	O
{	O
TRACE	O
(	O
"  %1m: -0.5 - penalty for ko stone %1m (workaround)\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
tot_value	float
-=	O
0.5	int
;	O
}	O
mark_changed_dragon	(int,int,int,int,int,array(char),array(float),*(float))->(void)
(	O
pos	int
,	O
color	int
,	O
aa	int
,	O
bb	int
,	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
,	O
safe_stones	array(char)
,	O
strength	array(float)
,	O
&	O
this_value	float
)	O
;	O
this_value	float
*=	O
2.0	int
;	O
TRACE	O
(	O
"  %1m: owl attack/defend for %1m\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
SEMEAI_MOVE	int
)	O
this_value	float
=	O
0.0	int
;	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_GOOD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_GOOD_KO	int
)	O
{	O
this_value	float
*=	O
0.3	int
;	O
TRACE	O
(	O
"  %1m: -%f - owl attack/defense of %1m only with good ko\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_BAD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_BAD_KO	int
)	O
{	O
this_value	float
*=	O
0.5	int
;	O
TRACE	O
(	O
"  %1m: -%f - owl attack/defense of %1m only with bad ko\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_GAIN	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_LOSS	int
)	O
{	O
this_value	float
=	O
0.0	int
;	O
}	O
tot_value	float
-=	O
this_value	float
;	O
if	O
(	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_GOOD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_BAD_KO	int
)	O
&&	O
dragon	int
[	O
aa	int
]	O
.	O
size	int
==	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
size	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
==	O
WIN	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
attack_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
!=	O
WIN	int
)	O
{	O
if	O
(	O
large_scale	int
)	O
this_value	float
=	O
(	O
2.0	int
+	O
0.05	int
*	O
(	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
)	O
)	O
;	O
else	O
this_value	float
=	O
0.05	int
*	O
(	O
2	int
*	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
TRACE	O
(	O
"  %1m: -%f - suspected ineffective owl attack of worm %1m\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
tot_value	float
-=	O
this_value	float
;	O
}	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
OWL_ATTACK_THREAT	O
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"    %1m: 0.0 - threatens to owl attack %1m (dead)\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
}	O
{	O
float	O
value	*(char)
=	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
;	O
int	O
s	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
DRAGON2	O
(	O
aa	int
)	O
.	O
neighbors	int
;	O
s	int
++	O
)	O
{	O
int	O
d	int
=	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array(int)
[	O
s	int
]	O
;	O
int	O
adj	array(int)
=	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
d	int
]	O
.	O
origin	int
;	O
if	O
(	O
dragon	int
[	O
adj	array(int)
]	O
.	O
color	int
==	O
color	int
&&	O
dragon	int
[	O
adj	array(int)
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
&&	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
d	int
]	O
.	O
safety	int
!=	O
INESSENTIAL	int
&&	O
!	O
owl_defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
adj	array(int)
)	O
)	O
value	*(char)
=	O
0.0	int
;	O
}	O
if	O
(	O
value	*(char)
>	O
0.0	int
)	O
{	O
add_followup_value	(int,float)->(void)
(	O
pos	int
,	O
value	*(char)
)	O
;	O
TRACE	O
(	O
"  %1m: %f (followup) - threatens to owl attack %1m\n"	*(char)
,	O
pos	int
,	O
value	*(char)
,	O
aa	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
OWL_DEFEND_THREAT	O
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
add_followup_value	(int,float)->(void)
(	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
TRACE	O
(	O
"  %1m: %f (followup) - threatens to owl defend %1m\n"	*(char)
,	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_PREVENT_THREAT	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"    %1m: 0.0 - prevent defense threat (dragon is not dead)\n"	*(char)
,	O
pos	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
doing_scoring	int
&&	O
is_same_dragon	(int,int)->(int)
(	O
get_last_opponent_move	(int)->(int)
(	O
color	int
)	O
,	O
aa	int
)	O
)	O
{	O
this_value	float
=	O
1.5	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
;	O
TRACE	O
(	O
"  %1m: %f - attack last move played, although it seems dead\n"	*(char)
,	O
pos	int
,	O
this_value	float
)	O
;	O
tot_value	float
+=	O
this_value	float
*	O
attack_dragon_weight	float
;	O
}	O
else	O
if	O
(	O
!	O
doing_scoring	int
&&	O
our_score	float
>	O
0.0	int
)	O
{	O
this_value	float
=	O
gg_min	O
(	O
0.9	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
,	O
our_score	float
/	O
2.0	int
-	O
board_size	int
/	O
2.0	int
-	O
1.0	int
)	O
;	O
this_value	float
=	O
gg_max	O
(	O
this_value	float
,	O
0	int
)	O
;	O
TRACE	O
(	O
"  %1m: %f - attack %1m, although it seems dead, as we are ahead\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
tot_value	float
+=	O
this_value	float
*	O
attack_dragon_weight	float
;	O
}	O
else	O
{	O
add_reverse_followup_value	(int,float)->(void)
(	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
if	O
(	O
board	*(char)
[	O
aa	int
]	O
==	O
color	int
)	O
TRACE	O
(	O
"  %1m: %f (reverse followup) - prevent threat to attack %1m\n"	*(char)
,	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
else	O
TRACE	O
(	O
"  %1m: %f (reverse followup) - prevent threat to defend %1m\n"	*(char)
,	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
}	O
break	O
;	O
case	O
MY_ATARI_ATARI_MOVE	int
:	O
this_value	float
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
+	O
1.0	int
;	O
tot_value	float
+=	O
this_value	float
;	O
TRACE	O
(	O
"  %1m: %f - combination attack kills one of several worms\n"	*(char)
,	O
pos	int
,	O
this_value	float
)	O
;	O
break	O
;	O
case	O
YOUR_ATARI_ATARI_MOVE	int
:	O
does_block	int
=	O
1	int
;	O
this_value	float
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
tot_value	float
+=	O
this_value	float
;	O
TRACE	O
(	O
"  %1m: %f - defends against combination attack on several worms\n"	*(char)
,	O
pos	int
,	O
this_value	float
)	O
;	O
break	O
;	O
}	O
}	O
this_value	float
=	O
0.0	int
;	O
mark_inessential_stones	(int,array(char))->(void)
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
safe_stones	array(char)
)	O
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
==	O
1	int
&&	O
(	O
is_known_safe_move	(int)->(int)
(	O
pos	int
)	O
||	O
safe_move	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
!=	O
0	int
)	O
)	O
{	O
safe_stones	array(char)
[	O
pos	int
]	O
=	O
INFLUENCE_SAVED_STONE	int
;	O
strength	array(float)
[	O
pos	int
]	O
=	O
DEFAULT_STRENGTH	int
;	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"  %1m: is a safe move\n"	*(char)
,	O
pos	int
)	O
;	O
}	O
else	O
{	O
TRACE	O
(	O
"  %1m: not a safe move\n"	*(char)
,	O
pos	int
)	O
;	O
safe_stones	array(char)
[	O
pos	int
]	O
=	O
0	int
;	O
strength	array(float)
[	O
pos	int
]	O
=	O
0.0	int
;	O
}	O
if	O
(	O
does_block	int
&&	O
tryko	(int,int,*(char))->(int)
(	O
pos	int
,	O
color	int
,	O
"estimate_territorial_value"	*(char)
)	O
)	O
{	O
Hash_data	struct(array(long))
safety_hash	struct(array(long))
=	O
goal_to_hashvalue	(*(char))->(struct(array(long)))
(	O
safe_stones	array(char)
)	O
;	O
if	O
(	O
disable_delta_territory_cache	int
||	O
!	O
retrieve_delta_territory_cache	(int,int,*(float),*(float),*(struct),struct(array(long)))->(int)
(	O
pos	int
,	O
color	int
,	O
&	O
this_value	float
,	O
&	O
move	*(int)
[	O
pos	int
]	O
.	O
influence_followup_value	float
,	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
safety_hash	struct(array(long))
)	O
)	O
{	O
compute_influence	(int,array(char),array(float),*(struct),int,*(char))->(void)
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
safe_stones	array(char)
,	O
strength	array(float)
,	O
&	O
move_influence	struct
,	O
pos	int
,	O
"after move"	*(char)
)	O
;	O
increase_depth_values	()->(void)
(	O
)	O
;	O
break_territories	(int,*(struct),int,int)->(void)
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
&	O
move_influence	struct
,	O
0	int
,	O
pos	int
)	O
;	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
this_value	float
=	O
influence_delta_territory	(*(struct),*(struct),int,int)->(float)
(	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
&	O
move_influence	struct
,	O
color	int
,	O
pos	int
)	O
;	O
compute_followup_influence	(*(struct),*(struct),int,*(char))->(void)
(	O
&	O
move_influence	struct
,	O
&	O
followup_influence	struct
,	O
pos	int
,	O
"followup"	*(char)
)	O
;	O
if	O
(	O
this_value	float
!=	O
0.0	int
)	O
TRACE	O
(	O
"%1m: %f - change in territory\n"	*(char)
,	O
pos	int
,	O
this_value	float
)	O
;	O
else	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"%1m: 0.00 - change in territory\n"	*(char)
,	O
pos	int
)	O
;	O
move	*(int)
[	O
pos	int
]	O
.	O
influence_followup_value	float
=	O
influence_delta_territory	(*(struct),*(struct),int,int)->(float)
(	O
&	O
move_influence	struct
,	O
&	O
followup_influence	struct
,	O
color	int
,	O
pos	int
)	O
;	O
store_delta_territory_cache	(int,int,float,float,*(struct),struct(array(long)))->(void)
(	O
pos	int
,	O
color	int
,	O
this_value	float
,	O
move	*(int)
[	O
pos	int
]	O
.	O
influence_followup_value	float
,	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
safety_hash	struct(array(long))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
this_value	float
!=	O
0.0	int
)	O
TRACE	O
(	O
"%1m: %f - change in territory (cached)\n"	*(char)
,	O
pos	int
,	O
this_value	float
)	O
;	O
else	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"%1m: 0.00 - change in territory (cached)\n"	*(char)
,	O
pos	int
)	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
tot_value	float
+=	O
this_value	float
;	O
if	O
(	O
tot_value	float
<	O
move	*(int)
[	O
pos	int
]	O
.	O
min_territory	float
&&	O
move	*(int)
[	O
pos	int
]	O
.	O
min_territory	float
>	O
0	int
)	O
{	O
tot_value	float
=	O
move	*(int)
[	O
pos	int
]	O
.	O
min_territory	float
;	O
TRACE	O
(	O
"  %1m:   %f - revised to meet minimum territory value\n"	*(char)
,	O
pos	int
,	O
tot_value	float
)	O
;	O
}	O
if	O
(	O
tot_value	float
>	O
move	*(int)
[	O
pos	int
]	O
.	O
max_territory	float
)	O
{	O
tot_value	float
=	O
move	*(int)
[	O
pos	int
]	O
.	O
max_territory	float
;	O
TRACE	O
(	O
"  %1m:   %f - revised to meet maximum territory value\n"	*(char)
,	O
pos	int
,	O
tot_value	float
)	O
;	O
}	O
move	*(int)
[	O
pos	int
]	O
.	O
territorial_value	array(float)
=	O
tot_value	float
;	O
move	*(int)
[	O
pos	int
]	O
.	O
secondary_value	float
+=	O
secondary_value	float
;	O
}	O
static	O
void	O
estimate_strategical_value	(int,int,float,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
float	O
our_score	float
,	O
int	O
use_thrashing_dragon_heuristics	int
)	O
{	O
int	O
k	int
;	O
int	O
l	int
;	O
int	O
aa	int
=	O
NO_MOVE	O
;	O
int	O
bb	int
=	O
NO_MOVE	O
;	O
float	O
aa_value	float
=	O
0.0	int
;	O
float	O
bb_value	float
=	O
0.0	int
;	O
float	O
this_value	float
=	O
0.0	int
;	O
float	O
tot_value	float
=	O
0.0	int
;	O
float	O
dragon_value	array(float)
[	O
BOARDMAX	O
]	O
;	O
for	O
(	O
aa	int
=	O
BOARDMIN	O
;	O
aa	int
<	O
BOARDMAX	O
;	O
aa	int
++	O
)	O
dragon_value	array(float)
[	O
aa	int
]	O
=	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
&	O
STRATEGICALLY_REDUNDANT	int
)	O
continue	O
;	O
this_value	float
=	O
0.0	int
;	O
switch	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
ATTACK_MOVE	int
:	O
case	O
ATTACK_MOVE_GOOD_KO	int
:	O
case	O
ATTACK_MOVE_BAD_KO	int
:	O
case	O
DEFEND_MOVE	int
:	O
case	O
DEFEND_MOVE_GOOD_KO	int
:	O
case	O
DEFEND_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
defense_codes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
doing_scoring	int
&&	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
break	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
cutstone2	int
>	O
1	int
&&	O
!	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
inessential	int
)	O
{	O
double	O
ko_factor	double
=	O
1	int
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_GOOD_KO	int
)	O
{	O
ko_factor	double
=	O
0.6	int
;	O
}	O
else	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_BAD_KO	int
||	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_BAD_KO	int
)	O
{	O
ko_factor	double
=	O
0.4	int
;	O
}	O
this_value	float
=	O
10.0	int
*	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
cutstone2	int
-	O
1	int
)	O
*	O
ko_factor	double
;	O
TRACE	O
(	O
"  %1m: %f - %1m cutstone\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
tot_value	float
+=	O
this_value	float
;	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
||	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
inessential	int
)	O
break	O
;	O
if	O
(	O
max_lunch_eye_value	(int)->(int)
(	O
aa	int
)	O
==	O
0	int
)	O
break	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
next_lunch	int
;	O
l	int
++	O
)	O
if	O
(	O
lunch_worm	array(int)
[	O
l	int
]	O
==	O
aa	int
)	O
{	O
bb	int
=	O
lunch_dragon	array(int)
[	O
l	int
]	O
;	O
this_value	float
=	O
1.8	int
*	O
soft_cap	(float,float)->(float)
(	O
DRAGON2	O
(	O
bb	int
)	O
.	O
strategic_size	float
,	O
15.0	int
)	O
*	O
dragon_weakness	(int,int)->(float)
(	O
bb	int
,	O
0	int
)	O
;	O
if	O
(	O
dragon	int
[	O
bb	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
&&	O
dragon	int
[	O
bb	int
]	O
.	O
size	int
==	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
bb	int
]	O
.	O
size	int
&&	O
(	O
attack_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
bb	int
)	O
||	O
defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
bb	int
)	O
)	O
)	O
this_value	float
=	O
0.0	int
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
bb	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
(	O
(	O
color	int
==	O
board	*(char)
[	O
bb	int
]	O
&&	O
!	O
does_defend	(int,int)->(int)
(	O
pos	int
,	O
bb	int
)	O
)	O
||	O
(	O
color	int
==	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
bb	int
]	O
)	O
&&	O
!	O
does_attack	(int,int)->(int)
(	O
pos	int
,	O
bb	int
)	O
)	O
)	O
)	O
this_value	float
=	O
0.0	int
;	O
if	O
(	O
doing_scoring	int
&&	O
move	*(int)
[	O
pos	int
]	O
.	O
territorial_value	array(float)
<	O
0.0	int
&&	O
(	O
DRAGON2	O
(	O
bb	int
)	O
.	O
safety	int
==	O
ALIVE	int
||	O
DRAGON2	O
(	O
bb	int
)	O
.	O
safety	int
==	O
STRONGLY_ALIVE	int
||	O
DRAGON2	O
(	O
bb	int
)	O
.	O
safety	int
==	O
INVINCIBLE	int
)	O
)	O
this_value	float
=	O
0.0	int
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array(float)
[	O
bb	int
]	O
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - %1m attacked/defended\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
bb	int
)	O
;	O
dragon_value	array(float)
[	O
bb	int
]	O
=	O
this_value	float
;	O
}	O
}	O
break	O
;	O
case	O
ATTACK_THREAT	O
:	O
case	O
DEFEND_THREAT	O
:	O
break	O
;	O
case	O
EITHER_MOVE	int
:	O
aa	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
bb	int
=	O
either_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
&&	O
dragon	int
[	O
bb	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
break	O
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
MY_ATARI_ATARI_MOVE	int
,	O
-	O
1	int
)	O
)	O
break	O
;	O
aa_value	float
=	O
adjusted_worm_attack_value	(int,int)->(float)
(	O
pos	int
,	O
aa	int
)	O
;	O
bb_value	float
=	O
adjusted_worm_attack_value	(int,int)->(float)
(	O
pos	int
,	O
bb	int
)	O
;	O
this_value	float
=	O
gg_min	O
(	O
aa_value	float
,	O
bb_value	float
)	O
;	O
TRACE	O
(	O
"  %1m: %f - either attacks %1m (%f) or attacks %1m (%f)\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
,	O
aa_value	float
,	O
bb	int
,	O
bb_value	float
)	O
;	O
tot_value	float
+=	O
this_value	float
;	O
break	O
;	O
case	O
ALL_MOVE	int
:	O
aa	int
=	O
all_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
bb	int
=	O
all_data	array(struct(int,int,int,int))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
&&	O
dragon	int
[	O
bb	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
break	O
;	O
if	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
YOUR_ATARI_ATARI_MOVE	int
,	O
-	O
1	int
)	O
)	O
break	O
;	O
aa_value	float
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
;	O
bb_value	float
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
bb	int
]	O
.	O
effective_size	float
;	O
this_value	float
=	O
2	int
*	O
gg_min	O
(	O
aa_value	float
,	O
bb_value	float
)	O
;	O
TRACE	O
(	O
"  %1m: %f - both defends %1m (%f) and defends %1m (%f)\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
,	O
aa_value	float
,	O
bb	int
,	O
bb_value	float
)	O
;	O
tot_value	float
+=	O
this_value	float
;	O
break	O
;	O
case	O
CONNECT_MOVE	int
:	O
if	O
(	O
use_thrashing_dragon_heuristics	int
)	O
{	O
int	O
cc	int
;	O
aa	int
=	O
dragon	int
[	O
conn_worm1	array(int)
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
]	O
.	O
origin	int
;	O
bb	int
=	O
dragon	int
[	O
conn_worm2	array(int)
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
]	O
.	O
origin	int
;	O
cc	int
=	O
get_last_opponent_move	(int)->(int)
(	O
color	int
)	O
;	O
if	O
(	O
cc	int
!=	O
NO_MOVE	O
&&	O
thrashing_stone	array(char)
[	O
cc	int
]	O
&&	O
are_neighbor_dragons	(int,int)->(int)
(	O
aa	int
,	O
cc	int
)	O
&&	O
are_neighbor_dragons	(int,int)->(int)
(	O
bb	int
,	O
cc	int
)	O
)	O
{	O
if	O
(	O
aa	int
==	O
bb	int
)	O
this_value	float
=	O
1.6	int
*	O
DRAGON2	O
(	O
cc	int
)	O
.	O
strategic_size	float
;	O
else	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
||	O
DRAGON2	O
(	O
bb	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
)	O
{	O
if	O
(	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
&&	O
max_lunch_eye_value	(int)->(int)
(	O
aa	int
)	O
==	O
0	int
)	O
||	O
(	O
DRAGON2	O
(	O
bb	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
&&	O
max_lunch_eye_value	(int)->(int)
(	O
bb	int
)	O
==	O
0	int
)	O
)	O
this_value	float
=	O
0.0	int
;	O
else	O
this_value	float
=	O
0.8	int
*	O
DRAGON2	O
(	O
cc	int
)	O
.	O
strategic_size	float
;	O
}	O
else	O
this_value	float
=	O
1.7	int
*	O
DRAGON2	O
(	O
cc	int
)	O
.	O
strategic_size	float
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array(float)
[	O
dragon	int
[	O
cc	int
]	O
.	O
origin	int
]	O
)	O
{	O
dragon_value	array(float)
[	O
dragon	int
[	O
cc	int
]	O
.	O
origin	int
]	O
=	O
this_value	float
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - connect %1m and %1m to attack thrashing dragon %1m\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
,	O
bb	int
,	O
cc	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
)	O
break	O
;	O
case	O
CUT_MOVE	int
:	O
if	O
(	O
doing_scoring	int
&&	O
!	O
move	*(int)
[	O
pos	int
]	O
.	O
move_safety	int
)	O
break	O
;	O
aa	int
=	O
dragon	int
[	O
conn_worm1	array(int)
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
]	O
.	O
origin	int
;	O
bb	int
=	O
dragon	int
[	O
conn_worm2	array(int)
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
]	O
.	O
origin	int
;	O
if	O
(	O
aa	int
==	O
bb	int
)	O
continue	O
;	O
if	O
(	O
our_score	float
>	O
20.0	int
)	O
this_value	float
=	O
connection_value	(int,int,int,float)->(float)
(	O
aa	int
,	O
bb	int
,	O
pos	int
,	O
our_score	float
)	O
;	O
else	O
this_value	float
=	O
connection_value	(int,int,int,float)->(float)
(	O
aa	int
,	O
bb	int
,	O
pos	int
,	O
0	int
)	O
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array(float)
[	O
aa	int
]	O
)	O
{	O
dragon_value	array(float)
[	O
aa	int
]	O
=	O
this_value	float
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - %1m cut/connect strategic value\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
if	O
(	O
our_score	float
>	O
20.0	int
)	O
this_value	float
=	O
connection_value	(int,int,int,float)->(float)
(	O
bb	int
,	O
aa	int
,	O
pos	int
,	O
our_score	float
)	O
;	O
else	O
this_value	float
=	O
connection_value	(int,int,int,float)->(float)
(	O
bb	int
,	O
aa	int
,	O
pos	int
,	O
0	int
)	O
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array(float)
[	O
bb	int
]	O
)	O
{	O
dragon_value	array(float)
[	O
bb	int
]	O
=	O
this_value	float
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - %1m cut/connect strategic value\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
bb	int
)	O
;	O
}	O
break	O
;	O
case	O
SEMEAI_MOVE	int
:	O
break	O
;	O
case	O
STRATEGIC_ATTACK_MOVE	int
:	O
case	O
STRATEGIC_DEFEND_MOVE	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
use_thrashing_dragon_heuristics	int
&&	O
thrashing_stone	array(char)
[	O
aa	int
]	O
)	O
this_value	float
=	O
1.7	int
*	O
DRAGON2	O
(	O
aa	int
)	O
.	O
strategic_size	float
;	O
else	O
this_value	float
=	O
1.8	int
*	O
soft_cap	(float,float)->(float)
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
strategic_size	float
,	O
15.0	int
)	O
*	O
dragon_weakness	(int,int)->(float)
(	O
aa	int
,	O
1	int
)	O
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
==	O
STRATEGIC_ATTACK_MOVE	int
)	O
{	O
int	O
s	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
DRAGON2	O
(	O
aa	int
)	O
.	O
neighbors	int
;	O
s	int
++	O
)	O
{	O
int	O
d	int
=	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array(int)
[	O
s	int
]	O
;	O
int	O
adj	array(int)
=	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
d	int
]	O
.	O
origin	int
;	O
if	O
(	O
dragon	int
[	O
adj	array(int)
]	O
.	O
color	int
==	O
color	int
&&	O
dragon	int
[	O
adj	array(int)
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
&&	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
d	int
]	O
.	O
safety	int
!=	O
INESSENTIAL	int
&&	O
!	O
owl_defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
adj	array(int)
)	O
)	O
this_value	float
=	O
0.0	int
;	O
}	O
}	O
this_value	float
=	O
this_value	float
*	O
attack_dragon_weight	float
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array(float)
[	O
aa	int
]	O
)	O
{	O
dragon_value	array(float)
[	O
aa	int
]	O
=	O
this_value	float
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - %1m strategic attack/defend\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
break	O
;	O
case	O
UNCERTAIN_OWL_DEFENSE	int
:	O
aa	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
{	O
int	O
d	int
;	O
int	O
found_one	int
=	O
0	int
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
DRAGON2	O
(	O
aa	int
)	O
.	O
neighbors	int
;	O
d	int
++	O
)	O
if	O
(	O
DRAGON	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array(int)
[	O
d	int
]	O
)	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
)	O
found_one	int
=	O
1	int
;	O
if	O
(	O
found_one	int
)	O
break	O
;	O
}	O
if	O
(	O
our_score	float
<	O
0.0	int
)	O
this_value	float
=	O
0.0	int
;	O
else	O
this_value	float
=	O
gg_min	O
(	O
2	int
*	O
DRAGON2	O
(	O
aa	int
)	O
.	O
strategic_size	float
,	O
0.65	int
*	O
our_score	float
)	O
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array(float)
[	O
aa	int
]	O
)	O
{	O
dragon_value	array(float)
[	O
aa	int
]	O
=	O
this_value	float
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - %1m uncertain owl defense bonus\n"	*(char)
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
break	O
;	O
}	O
}	O
for	O
(	O
aa	int
=	O
BOARDMIN	O
;	O
aa	int
<	O
BOARDMAX	O
;	O
aa	int
++	O
)	O
{	O
if	O
(	O
dragon_value	array(float)
[	O
aa	int
]	O
==	O
0.0	int
)	O
continue	O
;	O
ASSERT1	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
origin	int
==	O
aa	int
,	O
aa	int
)	O
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
&&	O
!	O
owl_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m: 0.0 - disregarding strategic effect on %1m (critical dragon)\n"	*(char)
,	O
pos	int
,	O
aa	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
DEAD	int
&&	O
dragon	int
[	O
aa	int
]	O
.	O
size	int
==	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
size	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
effective_size	float
<	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
aa	int
]	O
.	O
size	int
+	O
2.0	int
&&	O
(	O
attack_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
||	O
defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
)	O
)	O
{	O
TRACE	O
(	O
"  %1m:   %f - %1m strategic value already counted - A.\n"	*(char)
,	O
pos	int
,	O
dragon_value	array(float)
[	O
aa	int
]	O
,	O
aa	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
attack_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
||	O
defense_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
||	O
(	O
owl_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
aa	int
)	O
&&	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
)	O
||	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
SEMEAI_MOVE	int
,	O
aa	int
)	O
)	O
{	O
float	O
excess_value	float
=	O
(	O
dragon_value	array(float)
[	O
aa	int
]	O
-	O
2	int
*	O
DRAGON2	O
(	O
aa	int
)	O
.	O
strategic_size	float
)	O
;	O
if	O
(	O
excess_value	float
>	O
0.0	int
)	O
{	O
TRACE	O
(	O
"  %1m: %f - strategic bonus for %1m\n"	*(char)
,	O
pos	int
,	O
excess_value	float
,	O
aa	int
)	O
;	O
tot_value	float
+=	O
excess_value	float
;	O
}	O
else	O
{	O
TRACE	O
(	O
"  %1m:   %f - %1m strategic value already counted - B.\n"	*(char)
,	O
pos	int
,	O
dragon_value	array(float)
[	O
aa	int
]	O
,	O
aa	int
)	O
;	O
}	O
continue	O
;	O
}	O
TRACE	O
(	O
"  %1m: %f - strategic effect on %1m\n"	*(char)
,	O
pos	int
,	O
dragon_value	array(float)
[	O
aa	int
]	O
,	O
aa	int
)	O
;	O
tot_value	float
+=	O
dragon_value	array(float)
[	O
aa	int
]	O
;	O
}	O
this_value	float
=	O
strategic_penalty	(int,int)->(float)
(	O
pos	int
,	O
color	int
)	O
;	O
this_value	float
=	O
this_value	float
*	O
invasion_malus_weight	float
;	O
if	O
(	O
this_value	float
>	O
0.0	int
)	O
{	O
TRACE	O
(	O
"  %1m: %f - strategic penalty, considered as invasion.\n"	*(char)
,	O
pos	int
,	O
-	O
this_value	float
)	O
;	O
tot_value	float
-=	O
this_value	float
;	O
}	O
move	*(int)
[	O
pos	int
]	O
.	O
strategical_value	float
=	O
tot_value	float
;	O
}	O
static	O
int	O
compare_move_reasons	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
p1	*(void)
,	O
const	O
void	O
*	O
p2	*(void)
)	O
{	O
const	O
int	O
mr1	int
=	O
*	O
(	O
const	O
int	O
*	O
)	O
p1	*(void)
;	O
const	O
int	O
mr2	int
=	O
*	O
(	O
const	O
int	O
*	O
)	O
p2	*(void)
;	O
if	O
(	O
move_reasons	array(struct(int,int,int))
[	O
mr1	int
]	O
.	O
type	char
!=	O
move_reasons	array(struct(int,int,int))
[	O
mr2	int
]	O
.	O
type	char
)	O
return	O
move_reasons	array(struct(int,int,int))
[	O
mr2	int
]	O
.	O
type	char
-	O
move_reasons	array(struct(int,int,int))
[	O
mr1	int
]	O
.	O
type	char
;	O
else	O
return	O
move_reasons	array(struct(int,int,int))
[	O
mr2	int
]	O
.	O
what	int
-	O
move_reasons	array(struct(int,int,int))
[	O
mr1	int
]	O
.	O
what	int
;	O
}	O
static	O
float	O
value_move_reasons	(int,int,float,float,int)->(float)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
float	O
pure_threat_value	float
,	O
float	O
our_score	float
,	O
int	O
use_thrashing_dragon_heuristics	int
)	O
{	O
float	O
tot_value	float
;	O
float	O
shape_factor	float
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
is_antisuji_move	(int)->(int)
(	O
pos	int
)	O
)	O
return	O
0.0	int
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
UNKNOWN	int
)	O
return	O
0.0	int
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
0	int
]	O
>=	O
0	int
||	O
move	*(int)
[	O
pos	int
]	O
.	O
min_territory	float
>	O
0.0	int
)	O
{	O
int	O
num_reasons	int
;	O
num_reasons	int
=	O
0	int
;	O
while	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
num_reasons	int
]	O
>=	O
0	int
&&	O
num_reasons	int
<	O
MAX_REASONS	int
)	O
num_reasons	int
++	O
;	O
gg_sort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
,	O
num_reasons	int
,	O
sizeof	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
0	int
]	O
)	O
,	O
compare_move_reasons	(*(void),*(void))->(int)
)	O
;	O
discard_redundant_move_reasons	(int)->(void)
(	O
pos	int
)	O
;	O
estimate_territorial_value	(int,int,float,int)->(void)
(	O
pos	int
,	O
color	int
,	O
our_score	float
,	O
0	int
)	O
;	O
estimate_strategical_value	(int,int,float,int)->(void)
(	O
pos	int
,	O
color	int
,	O
our_score	float
,	O
use_thrashing_dragon_heuristics	int
)	O
;	O
}	O
tot_value	float
=	O
territorial_weight	float
*	O
move	*(int)
[	O
pos	int
]	O
.	O
territorial_value	array(float)
+	O
strategical_weight	float
*	O
move	*(int)
[	O
pos	int
]	O
.	O
strategical_value	float
;	O
shape_factor	float
=	O
compute_shape_factor	(int)->(float)
(	O
pos	int
)	O
;	O
if	O
(	O
tot_value	float
>	O
0.0	int
)	O
{	O
int	O
c	char
;	O
float	O
followup_value	*(float)
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
influence_followup_value	float
<	O
0.0	int
)	O
move	*(int)
[	O
pos	int
]	O
.	O
influence_followup_value	float
=	O
0.0	int
;	O
followup_value	*(float)
=	O
move	*(int)
[	O
pos	int
]	O
.	O
followup_value	*(float)
+	O
move	*(int)
[	O
pos	int
]	O
.	O
influence_followup_value	float
;	O
TRACE	O
(	O
"  %1m:   %f - total followup value, added %f as territorial followup\n"	*(char)
,	O
pos	int
,	O
followup_value	*(float)
,	O
move	*(int)
[	O
pos	int
]	O
.	O
influence_followup_value	float
)	O
;	O
if	O
(	O
tot_value	float
>=	O
0.5	int
)	O
{	O
float	O
old_tot_value	float
=	O
tot_value	float
;	O
float	O
contribution	float
;	O
contribution	float
=	O
gg_min	O
(	O
gg_min	O
(	O
0.5	int
*	O
followup_value	*(float)
+	O
0.5	int
*	O
move	*(int)
[	O
pos	int
]	O
.	O
reverse_followup_value	float
,	O
1.0	int
*	O
tot_value	float
+	O
followup_value	*(float)
)	O
,	O
1.1	int
*	O
tot_value	float
+	O
move	*(int)
[	O
pos	int
]	O
.	O
reverse_followup_value	float
)	O
;	O
tot_value	float
+=	O
contribution	float
*	O
followup_weight	float
;	O
if	O
(	O
contribution	float
!=	O
0.0	int
)	O
{	O
TRACE	O
(	O
"  %1m: %f - added due to followup (%f) and reverse followup values (%f)\n"	*(char)
,	O
pos	int
,	O
contribution	float
,	O
followup_value	*(float)
,	O
move	*(int)
[	O
pos	int
]	O
.	O
reverse_followup_value	float
)	O
;	O
}	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
=	O
followup_value	*(float)
+	O
move	*(int)
[	O
pos	int
]	O
.	O
reverse_followup_value	float
-	O
(	O
tot_value	float
-	O
old_tot_value	float
)	O
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
<	O
0.0	int
)	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
=	O
0.0	int
;	O
}	O
else	O
{	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
=	O
shape_factor	float
*	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
followup_value	*(float)
+	O
move	*(int)
[	O
pos	int
]	O
.	O
reverse_followup_value	float
)	O
;	O
}	O
tot_value	float
+=	O
soft_cap	(float,float)->(float)
(	O
0.05	int
*	O
move	*(int)
[	O
pos	int
]	O
.	O
secondary_value	float
,	O
0.4	int
)	O
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
secondary_value	float
!=	O
0.0	int
)	O
TRACE	O
(	O
"  %1m: %f - secondary\n"	*(char)
,	O
pos	int
,	O
soft_cap	(float,float)->(float)
(	O
0.05	int
*	O
move	*(int)
[	O
pos	int
]	O
.	O
secondary_value	float
,	O
0.4	int
)	O
)	O
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
numpos_shape	int
+	O
move	*(int)
[	O
pos	int
]	O
.	O
numneg_shape	int
>	O
0	int
)	O
{	O
float	O
old_value	float
=	O
tot_value	float
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
territorial_value	array(float)
<	O
15	int
)	O
tot_value	float
*=	O
shape_factor	float
;	O
else	O
{	O
float	O
non_shape_val	float
=	O
move	*(int)
[	O
pos	int
]	O
.	O
territorial_value	array(float)
-	O
15	int
;	O
tot_value	float
=	O
(	O
tot_value	float
-	O
non_shape_val	float
)	O
*	O
shape_factor	float
+	O
non_shape_val	float
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"  %1m: %f - shape "	*(char)
,	O
pos	int
,	O
tot_value	float
-	O
old_value	float
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(shape values +%4.2f(%d) -%4.2f(%d), shape factor %5.3f)\n"	*(char)
,	O
move	*(int)
[	O
pos	int
]	O
.	O
maxpos_shape	float
,	O
move	*(int)
[	O
pos	int
]	O
.	O
numpos_shape	int
,	O
move	*(int)
[	O
pos	int
]	O
.	O
maxneg_shape	float
,	O
move	*(int)
[	O
pos	int
]	O
.	O
numneg_shape	int
,	O
shape_factor	float
)	O
;	O
}	O
}	O
c	char
=	O
(	O
move_connects_strings	(int,int,int)->(int)
(	O
pos	int
,	O
color	int
,	O
1	int
)	O
+	O
move_connects_strings	(int,int,int)->(int)
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
0	int
)	O
)	O
;	O
if	O
(	O
c	char
>	O
0	int
)	O
{	O
float	O
shape_factor2	float
=	O
pow	(double,double)->(double)
(	O
1.02	int
,	O
(	O
float	O
)	O
c	char
)	O
-	O
1	int
;	O
float	O
base_value	float
=	O
gg_max	O
(	O
gg_min	O
(	O
tot_value	float
,	O
5.0	int
)	O
,	O
1.0	int
)	O
;	O
if	O
(	O
verbose	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"  %1m: %f - connects strings "	*(char)
,	O
pos	int
,	O
base_value	float
*	O
shape_factor2	float
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(connect value %d, shape factor %5.3f)\n"	*(char)
,	O
c	char
,	O
shape_factor2	float
)	O
;	O
}	O
tot_value	float
+=	O
base_value	float
*	O
shape_factor2	float
;	O
}	O
if	O
(	O
tot_value	float
<	O
0.3	int
&&	O
(	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
CONNECT_MOVE	int
,	O
-	O
1	int
)	O
||	O
move_reason_known	(int,int,int)->(int)
(	O
pos	int
,	O
CUT_MOVE	int
,	O
-	O
1	int
)	O
)	O
)	O
{	O
float	O
old_tot_value	float
=	O
tot_value	float
;	O
tot_value	float
=	O
gg_min	O
(	O
0.3	int
,	O
tot_value	float
+	O
0.1	int
)	O
;	O
TRACE	O
(	O
"  %1m: %f - cut/connect dame bonus\n"	*(char)
,	O
pos	int
,	O
tot_value	float
-	O
old_tot_value	float
)	O
;	O
}	O
}	O
else	O
{	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
=	O
shape_factor	float
*	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
followup_value	*(float)
+	O
gg_min	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
followup_value	*(float)
,	O
move	*(int)
[	O
pos	int
]	O
.	O
reverse_followup_value	float
)	O
)	O
;	O
}	O
if	O
(	O
pure_threat_value	float
>	O
0.0	int
&&	O
move	*(int)
[	O
pos	int
]	O
.	O
worthwhile_threat	int
&&	O
tot_value	float
<=	O
pure_threat_value	float
&&	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
>	O
0.0	int
&&	O
is_legal	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
&&	O
value_moves_confirm_safety	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
{	O
float	O
new_tot_value	float
=	O
gg_min	O
(	O
pure_threat_value	float
,	O
tot_value	float
+	O
0.25	int
*	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
)	O
;	O
new_tot_value	float
*=	O
(	O
1.0	int
-	O
0.1	int
*	O
(	O
pure_threat_value	float
-	O
tot_value	float
)	O
/	O
pure_threat_value	float
)	O
;	O
if	O
(	O
new_tot_value	float
>	O
tot_value	float
)	O
{	O
TRACE	O
(	O
"  %1m: %f - carry out threat or defend against threat\n"	*(char)
,	O
pos	int
,	O
new_tot_value	float
-	O
tot_value	float
)	O
;	O
tot_value	float
=	O
new_tot_value	float
;	O
}	O
}	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
=	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
*	O
minimum_value_weight	float
;	O
move	*(int)
[	O
pos	int
]	O
.	O
max_value	float
=	O
move	*(int)
[	O
pos	int
]	O
.	O
max_value	float
*	O
maximum_value_weight	float
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
>	O
move	*(int)
[	O
pos	int
]	O
.	O
max_value	float
)	O
move	*(int)
[	O
pos	int
]	O
.	O
max_value	float
=	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
<	O
25	int
)	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
+=	O
tot_value	float
/	O
200	int
;	O
if	O
(	O
tot_value	float
<	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
&&	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
>	O
0	int
)	O
{	O
tot_value	float
=	O
move	*(int)
[	O
pos	int
]	O
.	O
min_value	float
;	O
TRACE	O
(	O
"  %1m:   %f - minimum accepted value\n"	*(char)
,	O
pos	int
,	O
tot_value	float
)	O
;	O
}	O
if	O
(	O
tot_value	float
>	O
move	*(int)
[	O
pos	int
]	O
.	O
max_value	float
)	O
{	O
tot_value	float
=	O
move	*(int)
[	O
pos	int
]	O
.	O
max_value	float
;	O
TRACE	O
(	O
"  %1m:   %f - maximum accepted value\n"	*(char)
,	O
pos	int
,	O
tot_value	float
)	O
;	O
}	O
if	O
(	O
tot_value	float
>	O
0	int
||	O
move	*(int)
[	O
pos	int
]	O
.	O
territorial_value	array(float)
>	O
0	int
||	O
move	*(int)
[	O
pos	int
]	O
.	O
strategical_value	float
>	O
0	int
)	O
{	O
TRACE	O
(	O
"Move generation values %1m to %f\n"	*(char)
,	O
pos	int
,	O
tot_value	float
)	O
;	O
move_considered	(int,float)->(void)
(	O
pos	int
,	O
tot_value	float
)	O
;	O
}	O
return	O
tot_value	float
;	O
}	O
static	O
void	O
value_moves	(int,float,float,int)->(void)
(	O
int	O
color	int
,	O
float	O
pure_threat_value	float
,	O
float	O
our_score	float
,	O
int	O
use_thrashing_dragon_heuristics	int
)	O
{	O
int	O
m	int
,	O
n	int
;	O
int	O
pos	int
;	O
TRACE	O
(	O
"\nMove valuation:\n"	*(char)
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
for	O
(	O
m	int
=	O
board_size	int
-	O
1	int
;	O
m	int
>=	O
0	int
;	O
m	int
--	O
)	O
{	O
pos	int
=	O
POS	O
(	O
m	int
,	O
n	int
)	O
;	O
move	*(int)
[	O
pos	int
]	O
.	O
value	*(char)
=	O
value_move_reasons	(int,int,float,float,int)->(float)
(	O
pos	int
,	O
color	int
,	O
pure_threat_value	float
,	O
our_score	float
,	O
use_thrashing_dragon_heuristics	int
)	O
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
value	*(char)
==	O
0.0	int
)	O
continue	O
;	O
if	O
(	O
is_legal	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
||	O
is_illegal_ko_capture	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
{	O
move	*(int)
[	O
pos	int
]	O
.	O
value	*(char)
+=	O
0.01	int
*	O
move	*(int)
[	O
pos	int
]	O
.	O
random_number	float
*	O
move	*(int)
[	O
pos	int
]	O
.	O
randomness_scaling	float
;	O
}	O
else	O
{	O
move	*(int)
[	O
pos	int
]	O
.	O
value	*(char)
=	O
0.0	int
;	O
TRACE	O
(	O
"Move at %1m wasn't legal.\n"	*(char)
,	O
pos	int
)	O
;	O
}	O
}	O
}	O
void	O
print_all_move_values	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
move	*(int)
[	O
pos	int
]	O
.	O
final_value	float
<=	O
0.0	int
)	O
continue	O
;	O
gfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
output	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%1M %f\n"	*(char)
,	O
pos	int
,	O
move	*(int)
[	O
pos	int
]	O
.	O
final_value	float
)	O
;	O
}	O
}	O
static	O
void	O
print_top_moves	()->(void)
(	O
void	O
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
float	O
tval	float
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
;	O
k	int
++	O
)	O
{	O
best_moves	array(int)
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
best_move_values	array(float)
[	O
k	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
move	*(int)
[	O
pos	int
]	O
.	O
final_value	float
<=	O
0.0	int
)	O
continue	O
;	O
tval	float
=	O
move	*(int)
[	O
pos	int
]	O
.	O
final_value	float
;	O
record_top_move	(int,float)->(void)
(	O
pos	int
,	O
tval	float
)	O
;	O
}	O
if	O
(	O
verbose	int
>	O
0	int
||	O
(	O
debug	int
&	O
DEBUG_TOP_MOVES	int
)	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
"\nTop moves:\n"	*(char)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
&&	O
best_move_values	array(float)
[	O
k	int
]	O
>	O
0.0	int
;	O
k	int
++	O
)	O
gprintf	(*(char))->(int)
(	O
"%d. %1M %f\n"	*(char)
,	O
k	int
+	O
1	int
,	O
best_moves	array(int)
[	O
k	int
]	O
,	O
best_move_values	array(float)
[	O
k	int
]	O
)	O
;	O
}	O
}	O
void	O
record_top_move	(int,float)->(void)
(	O
int	O
pos	int
,	O
float	O
val	long
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
9	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
if	O
(	O
val	long
>	O
best_move_values	array(float)
[	O
k	int
]	O
)	O
{	O
if	O
(	O
k	int
<	O
9	int
)	O
{	O
best_move_values	array(float)
[	O
k	int
+	O
1	int
]	O
=	O
best_move_values	array(float)
[	O
k	int
]	O
;	O
best_moves	array(int)
[	O
k	int
+	O
1	int
]	O
=	O
best_moves	array(int)
[	O
k	int
]	O
;	O
}	O
best_move_values	array(float)
[	O
k	int
]	O
=	O
val	long
;	O
best_moves	array(int)
[	O
k	int
]	O
=	O
pos	int
;	O
}	O
move	*(int)
[	O
pos	int
]	O
.	O
final_value	float
=	O
val	long
;	O
}	O
void	O
remove_top_move	(int)->(void)
(	O
int	O
move	*(int)
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
best_moves	array(int)
[	O
k	int
]	O
==	O
move	*(int)
)	O
{	O
int	O
l	int
;	O
for	O
(	O
l	int
=	O
k	int
;	O
l	int
<	O
9	int
;	O
l	int
++	O
)	O
{	O
best_moves	array(int)
[	O
l	int
]	O
=	O
best_moves	array(int)
[	O
l	int
+	O
1	int
]	O
;	O
best_move_values	array(float)
[	O
l	int
]	O
=	O
best_move_values	array(float)
[	O
l	int
+	O
1	int
]	O
;	O
}	O
best_moves	array(int)
[	O
9	int
]	O
=	O
NO_MOVE	O
;	O
best_move_values	array(float)
[	O
9	int
]	O
=	O
0.0	int
;	O
}	O
}	O
}	O
static	O
void	O
reevaluate_ko_threats	(int,int,float)->(void)
(	O
int	O
ko_move	int
,	O
int	O
color	int
,	O
float	O
ko_value	float
)	O
{	O
int	O
ko_stone	int
=	O
NO_MOVE	O
;	O
int	O
opp_ko_move	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
type	char
,	O
what	int
;	O
int	O
threat_does_work	int
=	O
0	int
;	O
int	O
ko_move_target	int
;	O
int	O
num_good_threats	int
=	O
0	int
;	O
int	O
good_threats	array(int)
[	O
BOARDMAX	O
]	O
;	O
int	O
best_threat_quality	int
=	O
-	O
1	int
;	O
float	O
threat_size	float
;	O
ko_move_target	int
=	O
get_biggest_owl_target	(int)->(int)
(	O
ko_move	int
)	O
;	O
if	O
(	O
is_illegal_ko_capture	(int,int)->(int)
(	O
ko_move	int
,	O
color	int
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
3	int
;	O
k	int
++	O
)	O
{	O
ko_stone	int
=	O
ko_move	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
ko_stone	int
)	O
&&	O
countlib	(int)->(int)
(	O
ko_stone	int
)	O
==	O
1	int
)	O
break	O
;	O
}	O
ASSERT_ON_BOARD1	O
(	O
ko_stone	int
)	O
;	O
}	O
TRACE	O
(	O
"Reevaluating ko threats.\n"	*(char)
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
threat_quality	int
=	O
0	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
pos	int
==	O
ko_move	int
)	O
continue	O
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
<=	O
0.0	int
)	O
continue	O
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
followup_value	*(float)
<	O
ko_value	float
)	O
threat_quality	int
=	O
-	O
1	int
;	O
threat_size	float
=	O
0.0	int
;	O
type	char
=	O
-	O
1	int
;	O
what	int
=	O
-	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	*(int)
[	O
pos	int
]	O
.	O
reason	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
&	O
THREAT_BIT	int
)	O
)	O
continue	O
;	O
switch	O
(	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
ATTACK_THREAT	O
:	O
case	O
DEFEND_THREAT	O
:	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
>	O
threat_size	float
)	O
{	O
threat_size	float
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
;	O
type	char
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
;	O
what	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
}	O
break	O
;	O
case	O
OWL_ATTACK_THREAT	O
:	O
case	O
OWL_DEFEND_THREAT	O
:	O
case	O
SEMEAI_THREAT	O
:	O
if	O
(	O
dragon	int
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
>	O
threat_size	float
)	O
{	O
threat_size	float
=	O
dragon	int
[	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
;	O
type	char
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
type	char
;	O
what	int
=	O
move_reasons	array(struct(int,int,int))
[	O
r	int
]	O
.	O
what	int
;	O
}	O
break	O
;	O
default	O
:	O
gg_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
type	char
==	O
-	O
1	int
||	O
ko_stone	int
==	O
NO_MOVE	O
)	O
threat_does_work	int
=	O
1	int
;	O
else	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
"reevaluate_ko_threats"	*(char)
,	O
ko_move	int
)	O
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
ko_stone	int
)	O
;	O
if	O
(	O
!	O
find_defense	(int,*(int))->(int)
(	O
ko_stone	int
,	O
&	O
opp_ko_move	int
)	O
)	O
threat_does_work	int
=	O
1	int
;	O
else	O
{	O
int	O
threat_wastes_point	int
=	O
0	int
;	O
if	O
(	O
whose_area	(*(struct),int)->(int)
(	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
pos	int
)	O
!=	O
EMPTY	int
)	O
threat_wastes_point	int
=	O
1	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
opp_ko_move	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
"reevaluate_ko_threats"	*(char)
,	O
ko_move	int
)	O
)	O
{	O
switch	O
(	O
type	char
)	O
{	O
case	O
ATTACK_THREAT	O
:	O
if	O
(	O
board	*(char)
[	O
what	int
]	O
!=	O
EMPTY	int
)	O
threat_does_work	int
=	O
attack	(int,*(int))->(int)
(	O
what	int
,	O
NULL	O
)	O
;	O
else	O
threat_does_work	int
=	O
find_defense	(int,*(int))->(int)
(	O
pos	int
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
DEFEND_THREAT	O
:	O
threat_does_work	int
=	O
(	O
board	*(char)
[	O
what	int
]	O
!=	O
EMPTY	int
&&	O
find_defense	(int,*(int))->(int)
(	O
what	int
,	O
NULL	O
)	O
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_THREAT	O
:	O
case	O
OWL_DEFEND_THREAT	O
:	O
threat_does_work	int
=	O
(	O
ko_move_target	int
!=	O
what	int
)	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
threat_does_work	int
&&	O
type	char
==	O
ATTACK_THREAT	O
)	O
{	O
int	O
apos	int
;	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
&	O
apos	int
)	O
&&	O
does_defend	(int,int)->(int)
(	O
apos	int
,	O
what	int
)	O
&&	O
(	O
forced_backfilling_moves	array(int)
[	O
apos	int
]	O
||	O
(	O
!	O
is_proper_eye_space	(int)->(int)
(	O
apos	int
)	O
&&	O
!	O
false_eye_territory	array(int)
[	O
apos	int
]	O
)	O
)	O
)	O
{	O
threat_does_work	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
ko_value	float
<	O
1.0	int
&&	O
threat_does_work	int
&&	O
threat_quality	int
>=	O
0	int
&&	O
(	O
type	char
==	O
ATTACK_THREAT	O
||	O
type	char
==	O
DEFEND_THREAT	O
)	O
)	O
{	O
int	O
averting_pos	int
;	O
if	O
(	O
type	char
==	O
ATTACK_THREAT	O
)	O
find_defense	(int,*(int))->(int)
(	O
what	int
,	O
&	O
averting_pos	int
)	O
;	O
else	O
attack	(int,*(int))->(int)
(	O
what	int
,	O
&	O
averting_pos	int
)	O
;	O
if	O
(	O
averting_pos	int
!=	O
NO_MOVE	O
)	O
{	O
int	O
averting_wastes_point	int
=	O
0	int
;	O
if	O
(	O
whose_territory	(*(struct),int)->(int)
(	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
averting_pos	int
)	O
!=	O
EMPTY	int
)	O
averting_wastes_point	int
=	O
1	int
;	O
threat_quality	int
=	O
averting_wastes_point	int
-	O
threat_wastes_point	int
;	O
if	O
(	O
threat_quality	int
<	O
0	int
)	O
threat_does_work	int
=	O
0	int
;	O
}	O
}	O
}	O
}	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
threat_does_work	int
)	O
{	O
if	O
(	O
threat_quality	int
==	O
best_threat_quality	int
)	O
good_threats	array(int)
[	O
num_good_threats	int
++	O
]	O
=	O
pos	int
;	O
else	O
if	O
(	O
threat_quality	int
>	O
best_threat_quality	int
)	O
{	O
best_threat_quality	int
=	O
threat_quality	int
;	O
num_good_threats	int
=	O
0	int
;	O
good_threats	array(int)
[	O
num_good_threats	int
++	O
]	O
=	O
pos	int
;	O
}	O
else	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"%1m: no additional ko value (threat does not work as ko threat)\n"	*(char)
,	O
pos	int
)	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_good_threats	int
;	O
k	int
++	O
)	O
{	O
pos	int
=	O
good_threats	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
value	*(char)
==	O
0.0	int
)	O
{	O
move	*(int)
[	O
pos	int
]	O
.	O
value	*(char)
+=	O
0.01	int
*	O
move	*(int)
[	O
pos	int
]	O
.	O
random_number	float
*	O
move	*(int)
[	O
pos	int
]	O
.	O
randomness_scaling	float
;	O
}	O
TRACE	O
(	O
"%1m: %f + %f = %f\n"	*(char)
,	O
pos	int
,	O
move	*(int)
[	O
pos	int
]	O
.	O
value	*(char)
,	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
,	O
move	*(int)
[	O
pos	int
]	O
.	O
value	*(char)
+	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
)	O
;	O
move	*(int)
[	O
pos	int
]	O
.	O
value	*(char)
+=	O
move	*(int)
[	O
pos	int
]	O
.	O
additional_ko_value	float
;	O
}	O
}	O
static	O
void	O
redistribute_points	()->(void)
(	O
void	O
)	O
{	O
int	O
source	int
;	O
int	O
target	int
;	O
for	O
(	O
target	int
=	O
BOARDMIN	O
;	O
target	int
<	O
BOARDMAX	O
;	O
target	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
target	int
)	O
)	O
move	*(int)
[	O
target	int
]	O
.	O
final_value	float
=	O
move	*(int)
[	O
target	int
]	O
.	O
value	*(char)
;	O
for	O
(	O
source	int
=	O
BOARDMIN	O
;	O
source	int
<	O
BOARDMAX	O
;	O
source	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
source	int
)	O
)	O
continue	O
;	O
target	int
=	O
replacement_map	array(int)
[	O
source	int
]	O
;	O
if	O
(	O
target	int
==	O
NO_MOVE	O
)	O
continue	O
;	O
TRACE	O
(	O
"Redistributing points from %1m to %1m.\n"	*(char)
,	O
source	int
,	O
target	int
)	O
;	O
if	O
(	O
move	*(int)
[	O
target	int
]	O
.	O
final_value	float
<	O
move	*(int)
[	O
source	int
]	O
.	O
final_value	float
)	O
{	O
TRACE	O
(	O
"%1m is now valued %f.\n"	*(char)
,	O
target	int
,	O
move	*(int)
[	O
source	int
]	O
.	O
final_value	float
)	O
;	O
move	*(int)
[	O
target	int
]	O
.	O
final_value	float
=	O
move	*(int)
[	O
source	int
]	O
.	O
final_value	float
;	O
}	O
TRACE	O
(	O
"%1m is now valued 0.\n"	*(char)
,	O
source	int
)	O
;	O
move	*(int)
[	O
source	int
]	O
.	O
final_value	float
=	O
0.0	int
;	O
}	O
}	O
static	O
int	O
find_best_move	(*(int),*(float),int,array(int))->(int)
(	O
int	O
*	O
the_move	*(int)
,	O
float	O
*	O
value	*(char)
,	O
int	O
color	int
,	O
int	O
allowed_moves	array(int)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
good_move_found	int
=	O
0	int
;	O
signed	O
char	O
blunder_tested	array(char)
[	O
BOARDMAX	O
]	O
;	O
float	O
best_value	float
=	O
0.0	int
;	O
int	O
best_move	int
=	O
NO_MOVE	O
;	O
int	O
pos	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
blunder_tested	array(char)
,	O
0	int
,	O
sizeof	O
(	O
blunder_tested	array(char)
)	O
)	O
;	O
while	O
(	O
!	O
good_move_found	int
)	O
{	O
best_value	float
=	O
0.0	int
;	O
best_move	int
=	O
NO_MOVE	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
float	O
this_value	float
=	O
move	*(int)
[	O
pos	int
]	O
.	O
final_value	float
;	O
if	O
(	O
allowed_moves	array(int)
&&	O
!	O
allowed_moves	array(int)
[	O
pos	int
]	O
)	O
continue	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
move	*(int)
[	O
pos	int
]	O
.	O
final_value	float
==	O
0.0	int
)	O
continue	O
;	O
if	O
(	O
this_value	float
>	O
best_value	float
)	O
{	O
if	O
(	O
is_legal	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
||	O
is_illegal_ko_capture	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
{	O
best_value	float
=	O
this_value	float
;	O
best_move	int
=	O
pos	int
;	O
}	O
else	O
{	O
TRACE	O
(	O
"Move at %1m would be suicide.\n"	*(char)
,	O
pos	int
)	O
;	O
remove_top_move	(int)->(void)
(	O
pos	int
)	O
;	O
move	*(int)
[	O
pos	int
]	O
.	O
value	*(char)
=	O
0.0	int
;	O
move	*(int)
[	O
pos	int
]	O
.	O
final_value	float
=	O
0.0	int
;	O
}	O
}	O
}	O
if	O
(	O
best_value	float
>	O
0.0	int
&&	O
(	O
is_illegal_ko_capture	(int,int)->(int)
(	O
best_move	int
,	O
color	int
)	O
||	O
!	O
is_allowed_move	(int,int)->(int)
(	O
best_move	int
,	O
color	int
)	O
)	O
)	O
{	O
TRACE	O
(	O
"Move at %1m would be an illegal ko capture.\n"	*(char)
,	O
best_move	int
)	O
;	O
reevaluate_ko_threats	(int,int,float)->(void)
(	O
best_move	int
,	O
color	int
,	O
best_value	float
)	O
;	O
redistribute_points	()->(void)
(	O
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
2	int
,	O
"  reevaluate_ko_threats"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
remove_top_move	(int)->(void)
(	O
best_move	int
)	O
;	O
move	*(int)
[	O
best_move	int
]	O
.	O
value	*(char)
=	O
0.0	int
;	O
move	*(int)
[	O
best_move	int
]	O
.	O
final_value	float
=	O
0.0	int
;	O
print_top_moves	()->(void)
(	O
)	O
;	O
good_move_found	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
best_value	float
>	O
0.0	int
)	O
{	O
if	O
(	O
!	O
blunder_tested	array(char)
[	O
best_move	int
]	O
)	O
{	O
float	O
blunder_size	(int,int,*(int),array(char))->(float)
=	O
value_moves_get_blunder_size	(int,int)->(float)
(	O
best_move	int
,	O
color	int
)	O
;	O
if	O
(	O
blunder_size	(int,int,*(int),array(char))->(float)
>	O
0.0	int
)	O
{	O
TRACE	O
(	O
"Move at %1m is a blunder, subtracting %f.\n"	*(char)
,	O
best_move	int
,	O
blunder_size	(int,int,*(int),array(char))->(float)
)	O
;	O
remove_top_move	(int)->(void)
(	O
best_move	int
)	O
;	O
move	*(int)
[	O
best_move	int
]	O
.	O
value	*(char)
-=	O
blunder_size	(int,int,*(int),array(char))->(float)
;	O
move	*(int)
[	O
best_move	int
]	O
.	O
final_value	float
-=	O
blunder_size	(int,int,*(int),array(char))->(float)
;	O
TRACE	O
(	O
"Move at %1m is now valued %f.\n"	*(char)
,	O
best_move	int
,	O
move	*(int)
[	O
best_move	int
]	O
.	O
final_value	float
)	O
;	O
record_top_move	(int,float)->(void)
(	O
best_move	int
,	O
move	*(int)
[	O
best_move	int
]	O
.	O
final_value	float
)	O
;	O
good_move_found	int
=	O
0	int
;	O
blunder_tested	array(char)
[	O
best_move	int
]	O
=	O
1	int
;	O
}	O
else	O
good_move_found	int
=	O
1	int
;	O
}	O
else	O
good_move_found	int
=	O
1	int
;	O
}	O
else	O
good_move_found	int
=	O
1	int
;	O
}	O
if	O
(	O
best_value	float
>	O
0.0	int
&&	O
best_move	int
!=	O
NO_MOVE	O
)	O
{	O
*	O
the_move	*(int)
=	O
best_move	int
;	O
*	O
value	*(char)
=	O
best_value	float
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
review_move_reasons	(*(int),*(float),int,float,float,array(int),int)->(int)
(	O
int	O
*	O
the_move	*(int)
,	O
float	O
*	O
value	*(char)
,	O
int	O
color	int
,	O
float	O
pure_threat_value	float
,	O
float	O
our_score	float
,	O
int	O
allowed_moves	array(int)
[	O
BOARDMAX	O
]	O
,	O
int	O
use_thrashing_dragon_heuristics	int
)	O
{	O
int	O
save_verbose	int
;	O
current_color	int
=	O
color	int
;	O
start_timer	(int)->(void)
(	O
2	int
)	O
;	O
find_more_attack_and_defense_moves	(int)->(void)
(	O
color	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
2	int
,	O
"  find_more_attack_and_defense_moves"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
if	O
(	O
get_level	()->(int)
(	O
)	O
>=	O
6	int
)	O
{	O
find_more_owl_attack_and_defense_moves	(int)->(void)
(	O
color	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
2	int
,	O
"  find_more_owl_attack_and_defense_moves"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
if	O
(	O
large_scale	int
&&	O
get_level	()->(int)
(	O
)	O
>=	O
6	int
)	O
{	O
find_large_scale_owl_attack_moves	(int)->(void)
(	O
color	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
2	int
,	O
"  find_large_scale_owl_attack_moves"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
find_more_semeai_moves	(int)->(void)
(	O
color	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
2	int
,	O
"  find_more_semeai_moves"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
examine_move_safety	(int)->(void)
(	O
color	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
2	int
,	O
"  examine_move_safety"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
induce_secondary_move_reasons	(int)->(void)
(	O
color	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
2	int
,	O
"  induce_secondary_move_reasons"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
if	O
(	O
printworms	int
||	O
verbose	int
)	O
list_move_reasons	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
NO_MOVE	O
)	O
;	O
value_moves	(int,float,float,int)->(void)
(	O
color	int
,	O
pure_threat_value	float
,	O
our_score	float
,	O
use_thrashing_dragon_heuristics	int
)	O
;	O
time_report	(int,*(char),int,double)->(double)
(	O
2	int
,	O
"  value_moves"	*(char)
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
redistribute_points	()->(void)
(	O
)	O
;	O
print_top_moves	()->(void)
(	O
)	O
;	O
return	O
find_best_move	(*(int),*(float),int,array(int))->(int)
(	O
the_move	*(int)
,	O
value	*(char)
,	O
color	int
,	O
allowed_moves	array(int)
)	O
;	O
}	O
void	O
choose_strategy	(int,float,float)->(void)
(	O
int	O
color	int
,	O
float	O
our_score	float
,	O
float	O
game_status	(int)->(float)
)	O
{	O
minimum_value_weight	float
=	O
1.0	int
;	O
maximum_value_weight	float
=	O
1.0	int
;	O
territorial_weight	float
=	O
1.0	int
;	O
strategical_weight	float
=	O
1.0	int
;	O
attack_dragon_weight	float
=	O
1.0	int
;	O
invasion_malus_weight	float
=	O
1.0	int
;	O
followup_weight	float
=	O
1.0	int
;	O
TRACE	O
(	O
"  Game status = %f (0.0 = start, 1.0 = game over)\n"	*(char)
,	O
game_status	(int)->(float)
)	O
;	O
if	O
(	O
cosmic_gnugo	int
)	O
{	O
if	O
(	O
game_status	(int)->(float)
>	O
0.65	int
&&	O
our_score	float
>	O
15.0	int
)	O
{	O
minimum_value_weight	float
=	O
0.66	int
;	O
maximum_value_weight	float
=	O
2.0	int
;	O
territorial_weight	float
=	O
0.95	int
;	O
strategical_weight	float
=	O
1.0	int
;	O
attack_dragon_weight	float
=	O
1.1	int
;	O
invasion_malus_weight	float
=	O
1.3	int
;	O
followup_weight	float
=	O
1.1	int
;	O
TRACE	O
(	O
"  %s is leading, using conservative settings.\n"	*(char)
,	O
color	int
==	O
WHITE	int
?	O
"White"	*(char)
:	O
"Black"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
game_status	(int)->(float)
>	O
0.16	int
)	O
{	O
minimum_value_weight	float
=	O
0.66	int
;	O
maximum_value_weight	float
=	O
2.0	int
;	O
territorial_weight	float
=	O
1.4	int
;	O
strategical_weight	float
=	O
0.5	int
;	O
attack_dragon_weight	float
=	O
0.62	int
;	O
invasion_malus_weight	float
=	O
2.0	int
;	O
followup_weight	float
=	O
0.62	int
;	O
if	O
(	O
game_status	(int)->(float)
>	O
0.75	int
&&	O
our_score	float
<	O
-	O
25.0	int
)	O
invasion_malus_weight	float
=	O
0.2	int
;	O
TRACE	O
(	O
"  %s is not winning enough, using aggressive settings.\n"	*(char)
,	O
color	int
==	O
WHITE	int
?	O
"White"	*(char)
:	O
"Black"	*(char)
)	O
;	O
}	O
}	O
}	O
void	O
prepare_move_influence_debugging	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
float	O
our_score	float
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
our_score	float
=	O
black_score	float
;	O
else	O
our_score	float
=	O
-	O
white_score	float
;	O
estimate_territorial_value	(int,int,float,int)->(void)
(	O
pos	int
,	O
color	int
,	O
our_score	float
,	O
1	int
)	O
;	O
}	O
void	O
compute_move_probabilities	(array(float))->(void)
(	O
float	O
probabilities	array(float)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
num_moves	int
=	O
0	int
;	O
int	O
moves	array(int)
[	O
BOARDMAX	O
]	O
;	O
double	O
lower_values	array(double)
[	O
BOARDMAX	O
]	O
;	O
double	O
upper_values	array(double)
[	O
BOARDMAX	O
]	O
;	O
double	O
densities	array(double)
[	O
BOARDMAX	O
]	O
;	O
double	O
common_lower_limit	double
=	O
0.0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
probabilities	array(float)
[	O
pos	int
]	O
=	O
0.0	int
;	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
move	*(int)
[	O
pos	int
]	O
.	O
final_value	float
>	O
0.0	int
)	O
{	O
double	O
scale	double
=	O
0.01	int
*	O
(	O
double	O
)	O
move	*(int)
[	O
pos	int
]	O
.	O
randomness_scaling	float
;	O
moves	array(int)
[	O
num_moves	int
]	O
=	O
pos	int
;	O
lower_values	array(double)
[	O
num_moves	int
]	O
=	O
(	O
(	O
double	O
)	O
move	*(int)
[	O
pos	int
]	O
.	O
final_value	float
-	O
(	O
scale	double
*	O
move	*(int)
[	O
pos	int
]	O
.	O
random_number	float
)	O
)	O
;	O
upper_values	array(double)
[	O
num_moves	int
]	O
=	O
lower_values	array(double)
[	O
num_moves	int
]	O
+	O
scale	double
;	O
densities	array(double)
[	O
num_moves	int
]	O
=	O
1.0	int
/	O
scale	double
;	O
if	O
(	O
lower_values	array(double)
[	O
num_moves	int
]	O
>	O
common_lower_limit	double
)	O
common_lower_limit	double
=	O
lower_values	array(double)
[	O
num_moves	int
]	O
;	O
num_moves	int
++	O
;	O
}	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
i	int
;	O
double	O
lower_limit	double
=	O
common_lower_limit	double
;	O
while	O
(	O
lower_limit	double
<	O
upper_values	array(double)
[	O
k	int
]	O
)	O
{	O
int	O
j	int
;	O
double	O
upper_limit	double
=	O
upper_values	array(double)
[	O
k	int
]	O
;	O
double	O
span_power	double
;	O
double	O
polynomial	array(double)
[	O
BOARDMAX	O
]	O
;	O
int	O
degree	int
;	O
degree	int
=	O
0	int
;	O
polynomial	array(double)
[	O
0	int
]	O
=	O
1.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
upper_values	array(double)
[	O
i	int
]	O
>	O
lower_limit	double
&&	O
upper_values	array(double)
[	O
i	int
]	O
<	O
upper_limit	double
)	O
upper_limit	double
=	O
upper_values	array(double)
[	O
i	int
]	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
!=	O
k	int
&&	O
upper_values	array(double)
[	O
i	int
]	O
>=	O
upper_limit	double
)	O
{	O
polynomial	array(double)
[	O
++	O
degree	int
]	O
=	O
0.0	int
;	O
for	O
(	O
j	int
=	O
degree	int
;	O
j	int
>	O
0	int
;	O
j	int
--	O
)	O
{	O
polynomial	array(double)
[	O
j	int
]	O
=	O
(	O
densities	array(double)
[	O
i	int
]	O
*	O
(	O
polynomial	array(double)
[	O
j	int
-	O
1	int
]	O
+	O
(	O
(	O
lower_limit	double
-	O
lower_values	array(double)
[	O
i	int
]	O
)	O
*	O
polynomial	array(double)
[	O
j	int
]	O
)	O
)	O
)	O
;	O
}	O
polynomial	array(double)
[	O
0	int
]	O
*=	O
densities	array(double)
[	O
i	int
]	O
*	O
(	O
lower_limit	double
-	O
lower_values	array(double)
[	O
i	int
]	O
)	O
;	O
}	O
}	O
span_power	double
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
degree	int
;	O
j	int
++	O
)	O
{	O
span_power	double
*=	O
upper_limit	double
-	O
lower_limit	double
;	O
probabilities	array(float)
[	O
moves	array(int)
[	O
k	int
]	O
]	O
+=	O
(	O
polynomial	array(double)
[	O
j	int
]	O
*	O
span_power	double
)	O
/	O
(	O
j	int
+	O
1	int
)	O
;	O
}	O
lower_limit	double
=	O
upper_limit	double
;	O
}	O
probabilities	array(float)
[	O
moves	array(int)
[	O
k	int
]	O
]	O
*=	O
densities	array(double)
[	O
k	int
]	O
;	O
}	O
}	O
