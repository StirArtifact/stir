char	O
*	O
input_line_pointer	O
;	O
bfd_boolean	int
input_from_string	O
=	O
FALSE	O
;	O
char	O
lex_type	O
[	O
256	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
LEX_HASH	O
,	O
LEX_DOLLAR	O
,	O
LEX_PCT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
LEX_QM	O
,	O
LEX_AT	O
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
LEX_BR	O
,	O
0	int
,	O
LEX_BR	O
,	O
0	int
,	O
3	int
,	O
0	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
LEX_BR	O
,	O
0	int
,	O
LEX_BR	O
,	O
LEX_TILDE	O
,	O
0	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
}	O
;	O
char	O
is_end_of_line	O
[	O
256	int
]	O
=	O
{	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
char	O
original_case_string	O
[	O
128	int
]	O
;	O
static	O
char	O
*	O
buffer	O
;	O
static	O
char	O
*	O
buffer_limit	O
;	O
int	O
target_big_endian	O
=	O
TARGET_BYTES_BIG_ENDIAN	O
;	O
const	O
char	O
*	O
*	O
include_dirs	O
;	O
int	O
include_dir_count	O
;	O
int	O
include_dir_maxlen	O
=	O
1	int
;	O
addressT	O
abs_section_offset	O
;	O
symbolS	O
*	O
line_label	O
;	O
symbolS	O
*	O
mri_common_symbol	O
;	O
static	O
int	O
mri_pending_align	O
;	O
static	O
int	O
dwarf_file_string	O
;	O
static	O
unsigned	O
int	O
bundle_align_p2	O
;	O
static	O
fragS	O
*	O
bundle_lock_frag	O
;	O
static	O
frchainS	O
*	O
bundle_lock_frchain	O
;	O
static	O
unsigned	O
int	O
bundle_lock_depth	O
;	O
static	O
void	O
do_s_func	O
(	O
int	O
end_p	O
,	O
const	O
char	O
*	O
default_prefix	O
)	O
;	O
static	O
void	O
s_align	O
(	O
int	O
,	O
int	O
)	O
;	O
static	O
void	O
s_altmacro	O
(	O
int	O
)	O
;	O
static	O
void	O
s_bad_end	O
(	O
int	O
)	O
;	O
static	O
void	O
s_reloc	O
(	O
int	O
)	O
;	O
static	O
int	O
hex_float	O
(	O
int	O
,	O
char	O
*	O
)	O
;	O
static	O
segT	O
get_known_segmented_expression	O
(	O
expressionS	O
*	O
expP	O
)	O
;	O
static	O
void	O
pobegin	O
(	O
void	O
)	O
;	O
static	O
size_t	long
get_non_macro_line_sb	O
(	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
)	O
;	O
static	O
void	O
generate_file_debug	O
(	O
void	O
)	O
;	O
static	O
char	O
*	O
_find_end_of_line	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
;	O
void	O
read_begin	O
(	O
void	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
pobegin	O
(	O
)	O
;	O
obj_read_begin_hook	O
(	O
)	O
;	O
obstack_begin	O
(	O
&	O
notes	O
,	O
chunksize	O
)	O
;	O
obstack_begin	O
(	O
&	O
cond_obstack	O
,	O
chunksize	O
)	O
;	O
for	O
(	O
p	*(void)
=	O
tc_line_separator_chars	O
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(void)
]	O
=	O
2	int
;	O
if	O
(	O
flag_mri	O
)	O
lex_type	O
[	O
'?'	O
]	O
=	O
3	int
;	O
}	O
static	O
struct	O
hash_control	O
*	O
po_hash	O
;	O
static	O
const	O
pseudo_typeS	O
potable	O
[	O
]	O
=	O
{	O
{	O
"abort"	*(char)
,	O
s_abort	O
,	O
0	int
}	O
,	O
{	O
"align"	*(char)
,	O
s_align_ptwo	O
,	O
0	int
}	O
,	O
{	O
"altmacro"	*(char)
,	O
s_altmacro	O
,	O
1	int
}	O
,	O
{	O
"ascii"	*(char)
,	O
stringer	O
,	O
8	int
+	O
0	int
}	O
,	O
{	O
"asciz"	*(char)
,	O
stringer	O
,	O
8	int
+	O
1	int
}	O
,	O
{	O
"balign"	*(char)
,	O
s_align_bytes	O
,	O
0	int
}	O
,	O
{	O
"balignw"	*(char)
,	O
s_align_bytes	O
,	O
-	O
2	int
}	O
,	O
{	O
"balignl"	*(char)
,	O
s_align_bytes	O
,	O
-	O
4	int
}	O
,	O
{	O
"bundle_align_mode"	*(char)
,	O
s_bundle_align_mode	O
,	O
0	int
}	O
,	O
{	O
"bundle_lock"	*(char)
,	O
s_bundle_lock	O
,	O
0	int
}	O
,	O
{	O
"bundle_unlock"	*(char)
,	O
s_bundle_unlock	O
,	O
0	int
}	O
,	O
{	O
"byte"	*(char)
,	O
cons	O
,	O
1	int
}	O
,	O
{	O
"comm"	*(char)
,	O
s_comm	O
,	O
0	int
}	O
,	O
{	O
"common"	*(char)
,	O
s_mri_common	O
,	O
0	int
}	O
,	O
{	O
"common.s"	*(char)
,	O
s_mri_common	O
,	O
1	int
}	O
,	O
{	O
"data"	*(char)
,	O
s_data	O
,	O
0	int
}	O
,	O
{	O
"dc"	*(char)
,	O
cons	O
,	O
2	int
}	O
,	O
{	O
"dc.a"	*(char)
,	O
cons	O
,	O
0	int
}	O
,	O
{	O
"dc.b"	*(char)
,	O
cons	O
,	O
1	int
}	O
,	O
{	O
"dc.d"	*(char)
,	O
float_cons	O
,	O
'd'	O
}	O
,	O
{	O
"dc.l"	*(char)
,	O
cons	O
,	O
4	int
}	O
,	O
{	O
"dc.s"	*(char)
,	O
float_cons	O
,	O
'f'	O
}	O
,	O
{	O
"dc.w"	*(char)
,	O
cons	O
,	O
2	int
}	O
,	O
{	O
"dc.x"	*(char)
,	O
float_cons	O
,	O
'x'	O
}	O
,	O
{	O
"dcb"	*(char)
,	O
s_space	O
,	O
2	int
}	O
,	O
{	O
"dcb.b"	*(char)
,	O
s_space	O
,	O
1	int
}	O
,	O
{	O
"dcb.d"	*(char)
,	O
s_float_space	O
,	O
'd'	O
}	O
,	O
{	O
"dcb.l"	*(char)
,	O
s_space	O
,	O
4	int
}	O
,	O
{	O
"dcb.s"	*(char)
,	O
s_float_space	O
,	O
'f'	O
}	O
,	O
{	O
"dcb.w"	*(char)
,	O
s_space	O
,	O
2	int
}	O
,	O
{	O
"dcb.x"	*(char)
,	O
s_float_space	O
,	O
'x'	O
}	O
,	O
{	O
"ds"	*(char)
,	O
s_space	O
,	O
2	int
}	O
,	O
{	O
"ds.b"	*(char)
,	O
s_space	O
,	O
1	int
}	O
,	O
{	O
"ds.d"	*(char)
,	O
s_space	O
,	O
8	int
}	O
,	O
{	O
"ds.l"	*(char)
,	O
s_space	O
,	O
4	int
}	O
,	O
{	O
"ds.p"	*(char)
,	O
s_space	O
,	O
12	int
}	O
,	O
{	O
"ds.s"	*(char)
,	O
s_space	O
,	O
4	int
}	O
,	O
{	O
"ds.w"	*(char)
,	O
s_space	O
,	O
2	int
}	O
,	O
{	O
"ds.x"	*(char)
,	O
s_space	O
,	O
12	int
}	O
,	O
{	O
"debug"	*(char)
,	O
s_ignore	O
,	O
0	int
}	O
,	O
{	O
"double"	*(char)
,	O
float_cons	O
,	O
'd'	O
}	O
,	O
{	O
"eject"	*(char)
,	O
listing_eject	O
,	O
0	int
}	O
,	O
{	O
"else"	*(char)
,	O
s_else	O
,	O
0	int
}	O
,	O
{	O
"elsec"	*(char)
,	O
s_else	O
,	O
0	int
}	O
,	O
{	O
"elseif"	*(char)
,	O
s_elseif	O
,	O
(	O
int	O
)	O
O_ne	O
}	O
,	O
{	O
"end"	*(char)
,	O
s_end	O
,	O
0	int
}	O
,	O
{	O
"endc"	*(char)
,	O
s_endif	O
,	O
0	int
}	O
,	O
{	O
"endfunc"	*(char)
,	O
s_func	O
,	O
1	int
}	O
,	O
{	O
"endif"	*(char)
,	O
s_endif	O
,	O
0	int
}	O
,	O
{	O
"endm"	*(char)
,	O
s_bad_end	O
,	O
0	int
}	O
,	O
{	O
"endr"	*(char)
,	O
s_bad_end	O
,	O
1	int
}	O
,	O
{	O
"equ"	*(char)
,	O
s_set	O
,	O
0	int
}	O
,	O
{	O
"equiv"	*(char)
,	O
s_set	O
,	O
1	int
}	O
,	O
{	O
"eqv"	*(char)
,	O
s_set	O
,	O
-	O
1	int
}	O
,	O
{	O
"err"	*(char)
,	O
s_err	O
,	O
0	int
}	O
,	O
{	O
"error"	*(char)
,	O
s_errwarn	O
,	O
1	int
}	O
,	O
{	O
"exitm"	*(char)
,	O
s_mexit	O
,	O
0	int
}	O
,	O
{	O
"extern"	*(char)
,	O
s_ignore	O
,	O
0	int
}	O
,	O
{	O
"appfile"	*(char)
,	O
s_app_file	O
,	O
1	int
}	O
,	O
{	O
"appline"	*(char)
,	O
s_app_line	O
,	O
1	int
}	O
,	O
{	O
"fail"	*(char)
,	O
s_fail	O
,	O
0	int
}	O
,	O
{	O
"file"	*(char)
,	O
s_app_file	O
,	O
0	int
}	O
,	O
{	O
"fill"	*(char)
,	O
s_fill	O
,	O
0	int
}	O
,	O
{	O
"float"	*(char)
,	O
float_cons	O
,	O
'f'	O
}	O
,	O
{	O
"format"	*(char)
,	O
s_ignore	O
,	O
0	int
}	O
,	O
{	O
"func"	*(char)
,	O
s_func	O
,	O
0	int
}	O
,	O
{	O
"global"	*(char)
,	O
s_globl	O
,	O
0	int
}	O
,	O
{	O
"globl"	*(char)
,	O
s_globl	O
,	O
0	int
}	O
,	O
{	O
"hword"	*(char)
,	O
cons	O
,	O
2	int
}	O
,	O
{	O
"if"	*(char)
,	O
s_if	O
,	O
(	O
int	O
)	O
O_ne	O
}	O
,	O
{	O
"ifb"	*(char)
,	O
s_ifb	O
,	O
1	int
}	O
,	O
{	O
"ifc"	*(char)
,	O
s_ifc	O
,	O
0	int
}	O
,	O
{	O
"ifdef"	*(char)
,	O
s_ifdef	O
,	O
0	int
}	O
,	O
{	O
"ifeq"	*(char)
,	O
s_if	O
,	O
(	O
int	O
)	O
O_eq	O
}	O
,	O
{	O
"ifeqs"	*(char)
,	O
s_ifeqs	O
,	O
0	int
}	O
,	O
{	O
"ifge"	*(char)
,	O
s_if	O
,	O
(	O
int	O
)	O
O_ge	O
}	O
,	O
{	O
"ifgt"	*(char)
,	O
s_if	O
,	O
(	O
int	O
)	O
O_gt	O
}	O
,	O
{	O
"ifle"	*(char)
,	O
s_if	O
,	O
(	O
int	O
)	O
O_le	O
}	O
,	O
{	O
"iflt"	*(char)
,	O
s_if	O
,	O
(	O
int	O
)	O
O_lt	O
}	O
,	O
{	O
"ifnb"	*(char)
,	O
s_ifb	O
,	O
0	int
}	O
,	O
{	O
"ifnc"	*(char)
,	O
s_ifc	O
,	O
1	int
}	O
,	O
{	O
"ifndef"	*(char)
,	O
s_ifdef	O
,	O
1	int
}	O
,	O
{	O
"ifne"	*(char)
,	O
s_if	O
,	O
(	O
int	O
)	O
O_ne	O
}	O
,	O
{	O
"ifnes"	*(char)
,	O
s_ifeqs	O
,	O
1	int
}	O
,	O
{	O
"ifnotdef"	*(char)
,	O
s_ifdef	O
,	O
1	int
}	O
,	O
{	O
"incbin"	*(char)
,	O
s_incbin	O
,	O
0	int
}	O
,	O
{	O
"include"	*(char)
,	O
s_include	O
,	O
0	int
}	O
,	O
{	O
"int"	*(char)
,	O
cons	O
,	O
4	int
}	O
,	O
{	O
"irp"	*(char)
,	O
s_irp	O
,	O
0	int
}	O
,	O
{	O
"irep"	*(char)
,	O
s_irp	O
,	O
0	int
}	O
,	O
{	O
"irpc"	*(char)
,	O
s_irp	O
,	O
1	int
}	O
,	O
{	O
"irepc"	*(char)
,	O
s_irp	O
,	O
1	int
}	O
,	O
{	O
"lcomm"	*(char)
,	O
s_lcomm	O
,	O
0	int
}	O
,	O
{	O
"lflags"	*(char)
,	O
s_ignore	O
,	O
0	int
}	O
,	O
{	O
"linefile"	*(char)
,	O
s_app_line	O
,	O
0	int
}	O
,	O
{	O
"linkonce"	*(char)
,	O
s_linkonce	O
,	O
0	int
}	O
,	O
{	O
"list"	*(char)
,	O
listing_list	O
,	O
1	int
}	O
,	O
{	O
"llen"	*(char)
,	O
listing_psize	O
,	O
1	int
}	O
,	O
{	O
"long"	*(char)
,	O
cons	O
,	O
4	int
}	O
,	O
{	O
"lsym"	*(char)
,	O
s_lsym	O
,	O
0	int
}	O
,	O
{	O
"macro"	*(char)
,	O
s_macro	O
,	O
0	int
}	O
,	O
{	O
"mexit"	*(char)
,	O
s_mexit	O
,	O
0	int
}	O
,	O
{	O
"mri"	*(char)
,	O
s_mri	O
,	O
0	int
}	O
,	O
{	O
".mri"	*(char)
,	O
s_mri	O
,	O
0	int
}	O
,	O
{	O
"name"	*(char)
,	O
s_ignore	O
,	O
0	int
}	O
,	O
{	O
"noaltmacro"	*(char)
,	O
s_altmacro	O
,	O
0	int
}	O
,	O
{	O
"noformat"	*(char)
,	O
s_ignore	O
,	O
0	int
}	O
,	O
{	O
"nolist"	*(char)
,	O
listing_list	O
,	O
0	int
}	O
,	O
{	O
"nopage"	*(char)
,	O
listing_nopage	O
,	O
0	int
}	O
,	O
{	O
"nops"	*(char)
,	O
s_nops	O
,	O
0	int
}	O
,	O
{	O
"octa"	*(char)
,	O
cons	O
,	O
16	int
}	O
,	O
{	O
"offset"	*(char)
,	O
s_struct	O
,	O
0	int
}	O
,	O
{	O
"org"	*(char)
,	O
s_org	O
,	O
0	int
}	O
,	O
{	O
"p2align"	*(char)
,	O
s_align_ptwo	O
,	O
0	int
}	O
,	O
{	O
"p2alignw"	*(char)
,	O
s_align_ptwo	O
,	O
-	O
2	int
}	O
,	O
{	O
"p2alignl"	*(char)
,	O
s_align_ptwo	O
,	O
-	O
4	int
}	O
,	O
{	O
"page"	*(char)
,	O
listing_eject	O
,	O
0	int
}	O
,	O
{	O
"plen"	*(char)
,	O
listing_psize	O
,	O
0	int
}	O
,	O
{	O
"print"	*(char)
,	O
s_print	O
,	O
0	int
}	O
,	O
{	O
"psize"	*(char)
,	O
listing_psize	O
,	O
0	int
}	O
,	O
{	O
"purgem"	*(char)
,	O
s_purgem	O
,	O
0	int
}	O
,	O
{	O
"quad"	*(char)
,	O
cons	O
,	O
8	int
}	O
,	O
{	O
"reloc"	*(char)
,	O
s_reloc	O
,	O
0	int
}	O
,	O
{	O
"rep"	*(char)
,	O
s_rept	O
,	O
0	int
}	O
,	O
{	O
"rept"	*(char)
,	O
s_rept	O
,	O
0	int
}	O
,	O
{	O
"rva"	*(char)
,	O
s_rva	O
,	O
4	int
}	O
,	O
{	O
"sbttl"	*(char)
,	O
listing_title	O
,	O
1	int
}	O
,	O
{	O
"set"	*(char)
,	O
s_set	O
,	O
0	int
}	O
,	O
{	O
"short"	*(char)
,	O
cons	O
,	O
2	int
}	O
,	O
{	O
"single"	*(char)
,	O
float_cons	O
,	O
'f'	O
}	O
,	O
{	O
"space"	*(char)
,	O
s_space	O
,	O
0	int
}	O
,	O
{	O
"skip"	*(char)
,	O
s_space	O
,	O
0	int
}	O
,	O
{	O
"sleb128"	*(char)
,	O
s_leb128	O
,	O
1	int
}	O
,	O
{	O
"spc"	*(char)
,	O
s_ignore	O
,	O
0	int
}	O
,	O
{	O
"stabd"	*(char)
,	O
s_stab	O
,	O
'd'	O
}	O
,	O
{	O
"stabn"	*(char)
,	O
s_stab	O
,	O
'n'	O
}	O
,	O
{	O
"stabs"	*(char)
,	O
s_stab	O
,	O
's'	O
}	O
,	O
{	O
"string"	*(char)
,	O
stringer	O
,	O
8	int
+	O
1	int
}	O
,	O
{	O
"string8"	*(char)
,	O
stringer	O
,	O
8	int
+	O
1	int
}	O
,	O
{	O
"string16"	*(char)
,	O
stringer	O
,	O
16	int
+	O
1	int
}	O
,	O
{	O
"string32"	*(char)
,	O
stringer	O
,	O
32	int
+	O
1	int
}	O
,	O
{	O
"string64"	*(char)
,	O
stringer	O
,	O
64	int
+	O
1	int
}	O
,	O
{	O
"struct"	*(char)
,	O
s_struct	O
,	O
0	int
}	O
,	O
{	O
"text"	*(char)
,	O
s_text	O
,	O
0	int
}	O
,	O
{	O
"this_GCC_requires_the_GNU_assembler"	*(char)
,	O
s_ignore	O
,	O
0	int
}	O
,	O
{	O
"this_gcc_requires_the_gnu_assembler"	*(char)
,	O
s_ignore	O
,	O
0	int
}	O
,	O
{	O
"title"	*(char)
,	O
listing_title	O
,	O
0	int
}	O
,	O
{	O
"ttl"	*(char)
,	O
listing_title	O
,	O
0	int
}	O
,	O
{	O
"uleb128"	*(char)
,	O
s_leb128	O
,	O
0	int
}	O
,	O
{	O
"xcom"	*(char)
,	O
s_comm	O
,	O
0	int
}	O
,	O
{	O
"xdef"	*(char)
,	O
s_globl	O
,	O
0	int
}	O
,	O
{	O
"xref"	*(char)
,	O
s_ignore	O
,	O
0	int
}	O
,	O
{	O
"xstabs"	*(char)
,	O
s_xstab	O
,	O
's'	O
}	O
,	O
{	O
"warning"	*(char)
,	O
s_errwarn	O
,	O
0	int
}	O
,	O
{	O
"weakref"	*(char)
,	O
s_weakref	O
,	O
0	int
}	O
,	O
{	O
"word"	*(char)
,	O
cons	O
,	O
2	int
}	O
,	O
{	O
"zero"	*(char)
,	O
s_space	O
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
offsetT	O
get_absolute_expr	O
(	O
expressionS	O
*	O
exp	O
)	O
{	O
expression_and_evaluate	O
(	O
exp	O
)	O
;	O
if	O
(	O
exp	O
->	O
X_op	O
!=	O
O_constant	O
)	O
{	O
if	O
(	O
exp	O
->	O
X_op	O
!=	O
O_absent	O
)	O
as_bad	O
(	O
_	O
(	O
"bad or irreducible absolute expression"	*(char)
)	O
)	O
;	O
exp	O
->	O
X_add_number	O
=	O
0	int
;	O
}	O
return	O
exp	O
->	O
X_add_number	O
;	O
}	O
offsetT	O
get_absolute_expression	O
(	O
void	O
)	O
{	O
expressionS	O
exp	O
;	O
return	O
get_absolute_expr	O
(	O
&	O
exp	O
)	O
;	O
}	O
static	O
int	O
pop_override_ok	O
=	O
0	int
;	O
static	O
const	O
char	O
*	O
pop_table_name	O
;	O
void	O
pop_insert	O
(	O
const	O
pseudo_typeS	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
{	O
const	O
char	O
*	O
errtxt	O
;	O
const	O
pseudo_typeS	O
*	O
pop	O
;	O
for	O
(	O
pop	O
=	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
pop	O
->	O
poc_name	O
;	O
pop	O
++	O
)	O
{	O
errtxt	O
=	O
hash_insert	O
(	O
po_hash	O
,	O
pop	O
->	O
poc_name	O
,	O
(	O
char	O
*	O
)	O
pop	O
)	O
;	O
if	O
(	O
errtxt	O
&&	O
(	O
!	O
pop_override_ok	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
errtxt	O
,	O
"exists"	*(char)
)	O
)	O
)	O
as_fatal	O
(	O
_	O
(	O
"error constructing %s pseudo-op table: %s"	*(char)
)	O
,	O
pop_table_name	O
,	O
errtxt	O
)	O
;	O
}	O
}	O
static	O
void	O
pobegin	O
(	O
void	O
)	O
{	O
po_hash	O
=	O
hash_new	O
(	O
)	O
;	O
pop_table_name	O
=	O
"md"	*(char)
;	O
md_pop_insert	O
(	O
)	O
;	O
pop_table_name	O
=	O
"obj"	*(char)
;	O
pop_override_ok	O
=	O
1	int
;	O
obj_pop_insert	O
(	O
)	O
;	O
pop_table_name	O
=	O
"standard"	*(char)
;	O
pop_insert	O
(	O
potable	O
)	O
;	O
pop_table_name	O
=	O
"cfi"	*(char)
;	O
pop_override_ok	O
=	O
1	int
;	O
cfi_pop_insert	O
(	O
)	O
;	O
}	O
static	O
char	O
*	O
scrub_string	O
;	O
static	O
char	O
*	O
scrub_string_end	O
;	O
static	O
size_t	long
scrub_from_string	O
(	O
char	O
*	O
buf	*(void)
,	O
size_t	long
buflen	O
)	O
{	O
size_t	long
copy	int
;	O
copy	int
=	O
scrub_string_end	O
-	O
scrub_string	O
;	O
if	O
(	O
copy	int
>	O
buflen	O
)	O
copy	int
=	O
buflen	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	*(void)
,	O
scrub_string	O
,	O
copy	int
)	O
;	O
scrub_string	O
+=	O
copy	int
;	O
return	O
copy	int
;	O
}	O
static	O
int	O
try_macro	O
(	O
char	O
term	O
,	O
const	O
char	O
*	O
line	O
)	O
{	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
out	O
;	O
const	O
char	O
*	O
err	O
;	O
macro_entry	O
*	O
macro	O
;	O
if	O
(	O
check_macro	O
(	O
line	O
,	O
&	O
out	O
,	O
&	O
err	O
,	O
&	O
macro	O
)	O
)	O
{	O
if	O
(	O
err	O
!=	O
NULL	O
)	O
as_bad	O
(	O
"%s"	*(char)
,	O
err	O
)	O
;	O
*	O
input_line_pointer	O
++	O
=	O
term	O
;	O
input_scrub_include_sb	O
(	O
&	O
out	O
,	O
input_line_pointer	O
,	O
1	int
)	O
;	O
sb_kill	O
(	O
&	O
out	O
)	O
;	O
buffer_limit	O
=	O
input_scrub_next_buffer	O
(	O
&	O
input_line_pointer	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
fragS	O
*	O
start_bundle	O
(	O
void	O
)	O
{	O
fragS	O
*	O
frag	O
=	O
frag_now	O
;	O
frag_align_code	O
(	O
0	int
,	O
0	int
)	O
;	O
while	O
(	O
frag	O
->	O
fr_type	O
!=	O
rs_align_code	O
)	O
frag	O
=	O
frag	O
->	O
fr_next	O
;	O
gas_assert	O
(	O
frag	O
!=	O
frag_now	O
)	O
;	O
return	O
frag	O
;	O
}	O
static	O
unsigned	O
int	O
pending_bundle_size	O
(	O
fragS	O
*	O
frag	O
)	O
{	O
unsigned	O
int	O
offset	long
=	O
frag	O
->	O
fr_fix	O
;	O
unsigned	O
int	O
size	int
=	O
0	int
;	O
gas_assert	O
(	O
frag	O
!=	O
frag_now	O
)	O
;	O
gas_assert	O
(	O
frag	O
->	O
fr_type	O
==	O
rs_align_code	O
)	O
;	O
while	O
(	O
frag	O
!=	O
frag_now	O
)	O
{	O
if	O
(	O
frag	O
==	O
NULL	O
)	O
return	O
0	int
;	O
size	int
+=	O
frag	O
->	O
fr_fix	O
;	O
if	O
(	O
frag	O
->	O
fr_type	O
==	O
rs_machine_dependent	O
)	O
size	int
+=	O
md_frag_max_var	O
(	O
frag	O
)	O
;	O
frag	O
=	O
frag	O
->	O
fr_next	O
;	O
}	O
gas_assert	O
(	O
frag	O
==	O
frag_now	O
)	O
;	O
size	int
+=	O
frag_now_fix	O
(	O
)	O
;	O
if	O
(	O
frag	O
->	O
fr_type	O
==	O
rs_machine_dependent	O
)	O
size	int
+=	O
md_frag_max_var	O
(	O
frag	O
)	O
;	O
gas_assert	O
(	O
size	int
>=	O
offset	long
)	O
;	O
return	O
size	int
-	O
offset	long
;	O
}	O
static	O
void	O
finish_bundle	O
(	O
fragS	O
*	O
frag	O
,	O
unsigned	O
int	O
size	int
)	O
{	O
gas_assert	O
(	O
bundle_align_p2	O
>	O
0	int
)	O
;	O
gas_assert	O
(	O
frag	O
->	O
fr_type	O
==	O
rs_align_code	O
)	O
;	O
if	O
(	O
size	int
>	O
1	int
)	O
{	O
frag	O
->	O
fr_offset	O
=	O
bundle_align_p2	O
;	O
frag	O
->	O
fr_subtype	O
=	O
size	int
-	O
1	int
;	O
}	O
if	O
(	O
bundle_align_p2	O
>	O
OCTETS_PER_BYTE_POWER	int
)	O
record_alignment	O
(	O
now_seg	O
,	O
bundle_align_p2	O
-	O
OCTETS_PER_BYTE_POWER	int
)	O
;	O
}	O
static	O
void	O
assemble_one	O
(	O
char	O
*	O
line	O
)	O
{	O
fragS	O
*	O
insn_start_frag	O
=	O
NULL	O
;	O
if	O
(	O
bundle_lock_frchain	O
!=	O
NULL	O
&&	O
bundle_lock_frchain	O
!=	O
frchain_now	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"cannot change section or subsection inside .bundle_lock"	*(char)
)	O
)	O
;	O
bundle_lock_frchain	O
=	O
NULL	O
;	O
}	O
if	O
(	O
bundle_lock_frchain	O
==	O
NULL	O
&&	O
bundle_align_p2	O
>	O
0	int
)	O
insn_start_frag	O
=	O
start_bundle	O
(	O
)	O
;	O
md_assemble	O
(	O
line	O
)	O
;	O
if	O
(	O
bundle_lock_frchain	O
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
bundle_size	O
=	O
pending_bundle_size	O
(	O
bundle_lock_frag	O
)	O
;	O
if	O
(	O
bundle_size	O
>	O
1U	int
<<	O
bundle_align_p2	O
)	O
as_bad	O
(	O
_	O
(	O
".bundle_lock sequence at %u bytes, "	*(char)
"but .bundle_align_mode limit is %u bytes"	*(char)
)	O
,	O
bundle_size	O
,	O
1U	int
<<	O
bundle_align_p2	O
)	O
;	O
}	O
else	O
if	O
(	O
bundle_align_p2	O
>	O
0	int
)	O
{	O
unsigned	O
int	O
insn_size	O
=	O
pending_bundle_size	O
(	O
insn_start_frag	O
)	O
;	O
if	O
(	O
insn_size	O
>	O
1U	int
<<	O
bundle_align_p2	O
)	O
as_bad	O
(	O
_	O
(	O
"single instruction is %u bytes long, "	*(char)
"but .bundle_align_mode limit is %u bytes"	*(char)
)	O
,	O
insn_size	O
,	O
1U	int
<<	O
bundle_align_p2	O
)	O
;	O
finish_bundle	O
(	O
insn_start_frag	O
,	O
insn_size	O
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
in_bss	O
(	O
void	O
)	O
{	O
flagword	int
flags	int
=	O
bfd_section_flags	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))->(int)
(	O
now_seg	O
)	O
;	O
return	O
(	O
flags	int
&	O
SEC_ALLOC	O
)	O
&&	O
!	O
(	O
flags	int
&	O
(	O
SEC_LOAD	O
|	O
SEC_HAS_CONTENTS	O
)	O
)	O
;	O
}	O
void	O
do_align	O
(	O
unsigned	O
int	O
n	O
,	O
char	O
*	O
fill	*((long,int,int)->(*(void)))
,	O
unsigned	O
int	O
len	long
,	O
unsigned	O
int	O
max	O
)	O
{	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
||	O
in_bss	O
(	O
)	O
)	O
{	O
if	O
(	O
fill	*((long,int,int)->(*(void)))
!=	O
NULL	O
)	O
while	O
(	O
len	long
--	O
>	O
0	int
)	O
if	O
(	O
*	O
fill	*((long,int,int)->(*(void)))
++	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
)	O
as_warn	O
(	O
_	O
(	O
"ignoring fill value in absolute section"	*(char)
)	O
)	O
;	O
else	O
as_warn	O
(	O
_	O
(	O
"ignoring fill value in section `%s'"	*(char)
)	O
,	O
segment_name	O
(	O
now_seg	O
)	O
)	O
;	O
break	O
;	O
}	O
fill	*((long,int,int)->(*(void)))
=	O
NULL	O
;	O
len	long
=	O
0	int
;	O
}	O
md_do_align	O
(	O
n	O
,	O
fill	*((long,int,int)->(*(void)))
,	O
len	long
,	O
max	O
,	O
just_record_alignment	O
)	O
;	O
if	O
(	O
(	O
n	O
>	O
OCTETS_PER_BYTE_POWER	int
)	O
&&	O
!	O
need_pass_2	O
)	O
{	O
if	O
(	O
fill	*((long,int,int)->(*(void)))
==	O
NULL	O
)	O
{	O
if	O
(	O
subseg_text_p	O
(	O
now_seg	O
)	O
)	O
frag_align_code	O
(	O
n	O
,	O
max	O
)	O
;	O
else	O
frag_align	O
(	O
n	O
,	O
0	int
,	O
max	O
)	O
;	O
}	O
else	O
if	O
(	O
len	long
<=	O
1	int
)	O
frag_align	O
(	O
n	O
,	O
*	O
fill	*((long,int,int)->(*(void)))
,	O
max	O
)	O
;	O
else	O
frag_align_pattern	O
(	O
n	O
,	O
fill	*((long,int,int)->(*(void)))
,	O
len	long
,	O
max	O
)	O
;	O
}	O
just_record_alignment	O
:	O
ATTRIBUTE_UNUSED_LABEL	O
if	O
(	O
n	O
>	O
OCTETS_PER_BYTE_POWER	int
)	O
record_alignment	O
(	O
now_seg	O
,	O
n	O
-	O
OCTETS_PER_BYTE_POWER	int
)	O
;	O
}	O
void	O
read_a_source_file	O
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
char	O
nul_char	O
;	O
char	O
next_char	O
;	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
int	O
temp	O
;	O
pseudo_typeS	O
*	O
pop	O
;	O
buffer	O
=	O
input_scrub_new_file	O
(	O
name	*(char)
)	O
;	O
listing_file	O
(	O
name	*(char)
)	O
;	O
listing_newline	O
(	O
NULL	O
)	O
;	O
register_dependency	O
(	O
name	*(char)
)	O
;	O
generate_file_debug	O
(	O
)	O
;	O
while	O
(	O
(	O
buffer_limit	O
=	O
input_scrub_next_buffer	O
(	O
&	O
input_line_pointer	O
)	O
)	O
!=	O
0	int
)	O
{	O
static	O
char	O
*	O
last_eol	O
;	O
last_eol	O
=	O
NULL	O
;	O
while	O
(	O
input_line_pointer	O
<	O
buffer_limit	O
)	O
{	O
bfd_boolean	int
was_new_line	O
;	O
was_new_line	O
=	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
input_line_pointer	O
[	O
-	O
1	int
]	O
]	O
;	O
if	O
(	O
was_new_line	O
)	O
{	O
symbol_set_value_now	O
(	O
&	O
dot_symbol	O
)	O
;	O
if	O
(	O
input_line_pointer	O
[	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
bump_line_counters	O
(	O
)	O
;	O
}	O
if	O
(	O
listing	O
)	O
{	O
if	O
(	O
(	O
listing	O
&	O
LISTING_MACEXP	O
)	O
&&	O
macro_nest	O
>	O
0	int
)	O
{	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
find_end_of_line	O
(	O
input_line_pointer	O
,	O
flag_m68k_mri	O
)	O
;	O
if	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
!=	O
last_eol	O
)	O
{	O
char	O
*	O
copy	int
;	O
int	O
len	long
;	O
last_eol	O
=	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
len	long
=	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
-	O
input_line_pointer	O
;	O
copy	int
=	O
XNEWVEC	O
(	O
char	O
,	O
len	long
+	O
macro_nest	O
+	O
2	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
copy	int
,	O
'>'	O
,	O
macro_nest	O
)	O
;	O
copy	int
[	O
macro_nest	O
]	O
=	O
' '	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
copy	int
+	O
macro_nest	O
+	O
1	int
,	O
input_line_pointer	O
,	O
len	long
)	O
;	O
copy	int
[	O
macro_nest	O
+	O
1	int
+	O
len	long
]	O
=	O
'\0'	O
;	O
listing_newline	O
(	O
copy	int
)	O
;	O
}	O
}	O
else	O
listing_newline	O
(	O
NULL	O
)	O
;	O
}	O
if	O
(	O
was_new_line	O
)	O
{	O
line_label	O
=	O
NULL	O
;	O
if	O
(	O
LABELS_WITHOUT_COLONS	O
||	O
flag_m68k_mri	O
)	O
{	O
next_char	O
=	O
*	O
input_line_pointer	O
;	O
if	O
(	O
is_name_beginner	O
(	O
next_char	O
)	O
||	O
next_char	O
==	O
'"'	O
)	O
{	O
char	O
*	O
line_start	O
;	O
int	O
mri_line_macro	O
;	O
HANDLE_CONDITIONAL_ASSEMBLY	O
(	O
0	int
)	O
;	O
nul_char	O
=	O
get_symbol_name	O
(	O
&	O
line_start	O
)	O
;	O
next_char	O
=	O
(	O
nul_char	O
==	O
'"'	O
?	O
input_line_pointer	O
[	O
1	int
]	O
:	O
nul_char	O
)	O
;	O
mri_line_macro	O
=	O
0	int
;	O
if	O
(	O
flag_m68k_mri	O
)	O
{	O
char	O
*	O
rest	O
=	O
input_line_pointer	O
+	O
1	int
;	O
if	O
(	O
*	O
rest	O
==	O
':'	O
)	O
++	O
rest	O
;	O
if	O
(	O
*	O
rest	O
==	O
' '	O
||	O
*	O
rest	O
==	O
'\t'	O
)	O
++	O
rest	O
;	O
if	O
(	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
rest	O
,	O
"EQU"	*(char)
,	O
3	int
)	O
==	O
0	int
||	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
rest	O
,	O
"SET"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
&&	O
(	O
rest	O
[	O
3	int
]	O
==	O
' '	O
||	O
rest	O
[	O
3	int
]	O
==	O
'\t'	O
)	O
)	O
{	O
input_line_pointer	O
=	O
rest	O
+	O
3	int
;	O
equals	O
(	O
line_start	O
,	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
rest	O
,	O
"SET"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
rest	O
,	O
"MACRO"	*(char)
,	O
5	int
)	O
==	O
0	int
&&	O
(	O
rest	O
[	O
5	int
]	O
==	O
' '	O
||	O
rest	O
[	O
5	int
]	O
==	O
'\t'	O
||	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
rest	O
[	O
5	int
]	O
]	O
)	O
)	O
mri_line_macro	O
=	O
1	int
;	O
}	O
if	O
(	O
!	O
mri_line_macro	O
)	O
line_label	O
=	O
colon	O
(	O
line_start	O
)	O
;	O
else	O
line_label	O
=	O
symbol_create	O
(	O
line_start	O
,	O
absolute_section	O
,	O
(	O
valueT	O
)	O
0	int
,	O
&	O
zero_address_frag	O
)	O
;	O
next_char	O
=	O
restore_line_pointer	O
(	O
nul_char	O
)	O
;	O
if	O
(	O
next_char	O
==	O
':'	O
)	O
input_line_pointer	O
++	O
;	O
}	O
}	O
}	O
do	O
nul_char	O
=	O
next_char	O
=	O
*	O
input_line_pointer	O
++	O
;	O
while	O
(	O
next_char	O
==	O
'\t'	O
||	O
next_char	O
==	O
' '	O
||	O
next_char	O
==	O
'\f'	O
)	O
;	O
if	O
(	O
is_name_beginner	O
(	O
next_char	O
)	O
||	O
next_char	O
==	O
'"'	O
)	O
{	O
char	O
*	O
rest	O
;	O
HANDLE_CONDITIONAL_ASSEMBLY	O
(	O
1	int
)	O
;	O
--	O
input_line_pointer	O
;	O
nul_char	O
=	O
get_symbol_name	O
(	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
next_char	O
=	O
(	O
nul_char	O
==	O
'"'	O
?	O
input_line_pointer	O
[	O
1	int
]	O
:	O
nul_char	O
)	O
;	O
rest	O
=	O
input_line_pointer	O
+	O
(	O
nul_char	O
==	O
'"'	O
?	O
2	int
:	O
1	int
)	O
;	O
if	O
(	O
TC_START_LABEL	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
nul_char	O
,	O
next_char	O
)	O
)	O
{	O
if	O
(	O
flag_m68k_mri	O
)	O
{	O
if	O
(	O
*	O
rest	O
==	O
':'	O
)	O
++	O
rest	O
;	O
if	O
(	O
*	O
rest	O
==	O
' '	O
||	O
*	O
rest	O
==	O
'\t'	O
)	O
++	O
rest	O
;	O
if	O
(	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
rest	O
,	O
"EQU"	*(char)
,	O
3	int
)	O
==	O
0	int
||	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
rest	O
,	O
"SET"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
&&	O
(	O
rest	O
[	O
3	int
]	O
==	O
' '	O
||	O
rest	O
[	O
3	int
]	O
==	O
'\t'	O
)	O
)	O
{	O
input_line_pointer	O
=	O
rest	O
+	O
3	int
;	O
equals	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
1	int
)	O
;	O
continue	O
;	O
}	O
}	O
line_label	O
=	O
colon	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
restore_line_pointer	O
(	O
nul_char	O
)	O
;	O
++	O
input_line_pointer	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
next_char	O
==	O
'='	O
&&	O
*	O
rest	O
==	O
'='	O
)	O
||	O
(	O
(	O
next_char	O
==	O
' '	O
||	O
next_char	O
==	O
'\t'	O
)	O
&&	O
rest	O
[	O
0	int
]	O
==	O
'='	O
&&	O
rest	O
[	O
1	int
]	O
==	O
'='	O
)	O
)	O
{	O
equals	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
-	O
1	int
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
next_char	O
==	O
'='	O
||	O
(	O
(	O
next_char	O
==	O
' '	O
||	O
next_char	O
==	O
'\t'	O
)	O
&&	O
*	O
rest	O
==	O
'='	O
)	O
)	O
)	O
{	O
equals	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
1	int
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
else	O
{	O
pop	O
=	O
NULL	O
;	O
{	O
char	O
*	O
s2	O
=	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
original_case_string	O
,	O
s2	O
,	O
sizeof	O
(	O
original_case_string	O
)	O
)	O
;	O
original_case_string	O
[	O
sizeof	O
(	O
original_case_string	O
)	O
-	O
1	int
]	O
=	O
0	int
;	O
while	O
(	O
*	O
s2	O
)	O
{	O
*	O
s2	O
=	O
TOLOWER	O
(	O
*	O
s2	O
)	O
;	O
s2	O
++	O
;	O
}	O
}	O
if	O
(	O
NO_PSEUDO_DOT	O
||	O
flag_m68k_mri	O
)	O
{	O
pop	O
=	O
(	O
pseudo_typeS	O
*	O
)	O
hash_find	O
(	O
po_hash	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
if	O
(	O
pop	O
!=	O
NULL	O
&&	O
pop	O
->	O
poc_handler	O
==	O
NULL	O
)	O
pop	O
=	O
NULL	O
;	O
}	O
if	O
(	O
pop	O
!=	O
NULL	O
||	O
(	O
!	O
flag_m68k_mri	O
&&	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
'.'	O
)	O
)	O
{	O
if	O
(	O
pop	O
==	O
NULL	O
)	O
pop	O
=	O
(	O
pseudo_typeS	O
*	O
)	O
hash_find	O
(	O
po_hash	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
+	O
1	int
)	O
;	O
if	O
(	O
pop	O
&&	O
!	O
pop	O
->	O
poc_handler	O
)	O
pop	O
=	O
NULL	O
;	O
if	O
(	O
mri_pending_align	O
&&	O
(	O
pop	O
==	O
NULL	O
||	O
!	O
(	O
(	O
pop	O
->	O
poc_handler	O
==	O
cons	O
&&	O
pop	O
->	O
poc_val	O
==	O
1	int
)	O
||	O
(	O
pop	O
->	O
poc_handler	O
==	O
s_space	O
&&	O
pop	O
->	O
poc_val	O
==	O
1	int
)	O
||	O
pop	O
->	O
poc_handler	O
==	O
s_if	O
||	O
pop	O
->	O
poc_handler	O
==	O
s_ifdef	O
||	O
pop	O
->	O
poc_handler	O
==	O
s_ifc	O
||	O
pop	O
->	O
poc_handler	O
==	O
s_ifeqs	O
||	O
pop	O
->	O
poc_handler	O
==	O
s_else	O
||	O
pop	O
->	O
poc_handler	O
==	O
s_endif	O
||	O
pop	O
->	O
poc_handler	O
==	O
s_globl	O
||	O
pop	O
->	O
poc_handler	O
==	O
s_ignore	O
)	O
)	O
)	O
{	O
do_align	O
(	O
1	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
mri_pending_align	O
=	O
0	int
;	O
if	O
(	O
line_label	O
!=	O
NULL	O
)	O
{	O
symbol_set_frag	O
(	O
line_label	O
,	O
frag_now	O
)	O
;	O
S_SET_VALUE	O
(	O
line_label	O
,	O
frag_now_fix	O
(	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
pop	O
==	O
NULL	O
)	O
{	O
char	O
*	O
end	*(*(char))
=	O
input_line_pointer	O
;	O
(	O
void	O
)	O
restore_line_pointer	O
(	O
nul_char	O
)	O
;	O
s_ignore	O
(	O
0	int
)	O
;	O
nul_char	O
=	O
next_char	O
=	O
*	O
--	O
input_line_pointer	O
;	O
*	O
input_line_pointer	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
macro_defined	O
||	O
!	O
try_macro	O
(	O
next_char	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
{	O
*	O
end	*(*(char))
=	O
'\0'	O
;	O
as_bad	O
(	O
_	O
(	O
"unknown pseudo-op: `%s'"	*(char)
)	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
*	O
input_line_pointer	O
++	O
=	O
nul_char	O
;	O
}	O
continue	O
;	O
}	O
next_char	O
=	O
restore_line_pointer	O
(	O
nul_char	O
)	O
;	O
if	O
(	O
next_char	O
==	O
' '	O
||	O
next_char	O
==	O
'\t'	O
)	O
input_line_pointer	O
++	O
;	O
(	O
*	O
pop	O
->	O
poc_handler	O
)	O
(	O
pop	O
->	O
poc_val	O
)	O
;	O
if	O
(	O
pop	O
->	O
poc_handler	O
==	O
s_end	O
)	O
goto	O
quit	O
;	O
}	O
else	O
{	O
(	O
void	O
)	O
restore_line_pointer	O
(	O
nul_char	O
)	O
;	O
input_line_pointer	O
=	O
_find_end_of_line	O
(	O
input_line_pointer	O
,	O
flag_m68k_mri	O
,	O
1	int
,	O
0	int
)	O
;	O
next_char	O
=	O
nul_char	O
=	O
*	O
input_line_pointer	O
;	O
*	O
input_line_pointer	O
=	O
'\0'	O
;	O
generate_lineno_debug	O
(	O
)	O
;	O
if	O
(	O
macro_defined	O
&&	O
try_macro	O
(	O
next_char	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
continue	O
;	O
if	O
(	O
mri_pending_align	O
)	O
{	O
do_align	O
(	O
1	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
mri_pending_align	O
=	O
0	int
;	O
if	O
(	O
line_label	O
!=	O
NULL	O
)	O
{	O
symbol_set_frag	O
(	O
line_label	O
,	O
frag_now	O
)	O
;	O
S_SET_VALUE	O
(	O
line_label	O
,	O
frag_now_fix	O
(	O
)	O
)	O
;	O
}	O
}	O
assemble_one	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
if	O
(	O
input_line_pointer	O
==	O
NULL	O
)	O
as_fatal	O
(	O
_	O
(	O
"unable to continue with assembly."	*(char)
)	O
)	O
;	O
*	O
input_line_pointer	O
++	O
=	O
nul_char	O
;	O
}	O
}	O
continue	O
;	O
}	O
if	O
(	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
next_char	O
]	O
)	O
continue	O
;	O
if	O
(	O
(	O
LOCAL_LABELS_DOLLAR	O
||	O
LOCAL_LABELS_FB	O
)	O
&&	O
ISDIGIT	O
(	O
next_char	O
)	O
)	O
{	O
char	O
*	O
backup	O
=	O
input_line_pointer	O
;	O
HANDLE_CONDITIONAL_ASSEMBLY	O
(	O
1	int
)	O
;	O
temp	O
=	O
next_char	O
-	O
'0'	O
;	O
if	O
(	O
nul_char	O
==	O
'"'	O
)	O
++	O
input_line_pointer	O
;	O
while	O
(	O
ISDIGIT	O
(	O
*	O
input_line_pointer	O
)	O
)	O
{	O
temp	O
=	O
(	O
temp	O
*	O
10	int
)	O
+	O
*	O
input_line_pointer	O
-	O
'0'	O
;	O
++	O
input_line_pointer	O
;	O
}	O
if	O
(	O
LOCAL_LABELS_DOLLAR	O
&&	O
*	O
input_line_pointer	O
==	O
'$'	O
&&	O
*	O
(	O
input_line_pointer	O
+	O
1	int
)	O
==	O
':'	O
)	O
{	O
input_line_pointer	O
+=	O
2	int
;	O
if	O
(	O
dollar_label_defined	O
(	O
temp	O
)	O
)	O
{	O
as_fatal	O
(	O
_	O
(	O
"label \"%d$\" redefined"	*(char)
)	O
,	O
temp	O
)	O
;	O
}	O
define_dollar_label	O
(	O
temp	O
)	O
;	O
colon	O
(	O
dollar_label_name	O
(	O
temp	O
,	O
0	int
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
LOCAL_LABELS_FB	O
&&	O
*	O
input_line_pointer	O
++	O
==	O
':'	O
)	O
{	O
fb_label_instance_inc	O
(	O
temp	O
)	O
;	O
colon	O
(	O
fb_label_name	O
(	O
temp	O
,	O
0	int
)	O
)	O
;	O
continue	O
;	O
}	O
input_line_pointer	O
=	O
backup	O
;	O
}	O
if	O
(	O
next_char	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
line_comment_chars	O
,	O
next_char	O
)	O
)	O
{	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
sbuf	O
;	O
char	O
*	O
ends	O
;	O
char	O
*	O
new_buf	O
;	O
char	O
*	O
new_tmp	O
;	O
unsigned	O
int	O
new_length	O
;	O
char	O
*	O
tmp_buf	O
=	O
0	int
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
input_line_pointer	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"APP\n"	*(char)
,	O
4	int
)	O
)	O
{	O
ignore_rest_of_line	O
(	O
)	O
;	O
continue	O
;	O
}	O
bump_line_counters	O
(	O
)	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
+=	O
4	int
;	O
ends	O
=	O
strstr	(*(char),*(char))->(*(char))
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"#NO_APP\n"	*(char)
)	O
;	O
if	O
(	O
!	O
ends	O
)	O
{	O
unsigned	O
int	O
tmp_len	O
;	O
unsigned	O
int	O
num	O
;	O
tmp_len	O
=	O
buffer_limit	O
-	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
tmp_buf	O
=	O
XNEWVEC	O
(	O
char	O
,	O
tmp_len	O
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tmp_buf	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
tmp_len	O
)	O
;	O
do	O
{	O
new_tmp	O
=	O
input_scrub_next_buffer	O
(	O
&	O
buffer	O
)	O
;	O
if	O
(	O
!	O
new_tmp	O
)	O
break	O
;	O
else	O
buffer_limit	O
=	O
new_tmp	O
;	O
input_line_pointer	O
=	O
buffer	O
;	O
ends	O
=	O
strstr	(*(char),*(char))->(*(char))
(	O
buffer	O
,	O
"#NO_APP\n"	*(char)
)	O
;	O
if	O
(	O
ends	O
)	O
num	O
=	O
ends	O
-	O
buffer	O
;	O
else	O
num	O
=	O
buffer_limit	O
-	O
buffer	O
;	O
tmp_buf	O
=	O
XRESIZEVEC	O
(	O
char	O
,	O
tmp_buf	O
,	O
tmp_len	O
+	O
num	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
tmp_buf	O
+	O
tmp_len	O
,	O
buffer	O
,	O
num	O
)	O
;	O
tmp_len	O
+=	O
num	O
;	O
}	O
while	O
(	O
!	O
ends	O
)	O
;	O
input_line_pointer	O
=	O
ends	O
?	O
ends	O
+	O
8	int
:	O
NULL	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
tmp_buf	O
;	O
ends	O
=	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
+	O
tmp_len	O
;	O
}	O
else	O
{	O
input_line_pointer	O
=	O
ends	O
+	O
8	int
;	O
}	O
scrub_string	O
=	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
scrub_string_end	O
=	O
ends	O
;	O
new_length	O
=	O
ends	O
-	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
new_buf	O
=	O
XNEWVEC	O
(	O
char	O
,	O
new_length	O
)	O
;	O
new_tmp	O
=	O
new_buf	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
space	O
;	O
size_t	long
size	int
;	O
space	O
=	O
(	O
new_buf	O
+	O
new_length	O
)	O
-	O
new_tmp	O
;	O
size	int
=	O
do_scrub_chars	O
(	O
scrub_from_string	O
,	O
new_tmp	O
,	O
space	O
)	O
;	O
if	O
(	O
size	int
<	O
space	O
)	O
{	O
new_tmp	O
[	O
size	int
]	O
=	O
0	int
;	O
break	O
;	O
}	O
new_buf	O
=	O
XRESIZEVEC	O
(	O
char	O
,	O
new_buf	O
,	O
new_length	O
+	O
100	int
)	O
;	O
new_tmp	O
=	O
new_buf	O
+	O
new_length	O
;	O
new_length	O
+=	O
100	int
;	O
}	O
if	O
(	O
tmp_buf	O
)	O
free	(*(void))->(void)
(	O
tmp_buf	O
)	O
;	O
new_length	O
=	O
strlen	(*(char))->(long)
(	O
new_buf	O
)	O
;	O
sb_build	O
(	O
&	O
sbuf	O
,	O
new_length	O
)	O
;	O
sb_add_buffer	O
(	O
&	O
sbuf	O
,	O
new_buf	O
,	O
new_length	O
)	O
;	O
input_scrub_include_sb	O
(	O
&	O
sbuf	O
,	O
input_line_pointer	O
,	O
0	int
)	O
;	O
sb_kill	O
(	O
&	O
sbuf	O
)	O
;	O
buffer_limit	O
=	O
input_scrub_next_buffer	O
(	O
&	O
input_line_pointer	O
)	O
;	O
free	(*(void))->(void)
(	O
new_buf	O
)	O
;	O
continue	O
;	O
}	O
HANDLE_CONDITIONAL_ASSEMBLY	O
(	O
1	int
)	O
;	O
input_line_pointer	O
--	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
}	O
quit	O
:	O
symbol_set_value_now	O
(	O
&	O
dot_symbol	O
)	O
;	O
if	O
(	O
bundle_lock_frag	O
!=	O
NULL	O
)	O
{	O
as_bad_where	O
(	O
bundle_lock_frag	O
->	O
fr_file	O
,	O
bundle_lock_frag	O
->	O
fr_line	O
,	O
_	O
(	O
".bundle_lock with no matching .bundle_unlock"	*(char)
)	O
)	O
;	O
bundle_lock_frag	O
=	O
NULL	O
;	O
bundle_lock_frchain	O
=	O
NULL	O
;	O
bundle_lock_depth	O
=	O
0	int
;	O
}	O
md_cleanup	O
(	O
)	O
;	O
input_scrub_close	O
(	O
)	O
;	O
}	O
static	O
void	O
convert_to_bignum	O
(	O
expressionS	O
*	O
exp	O
,	O
int	O
sign	O
)	O
{	O
valueT	O
value	long
;	O
unsigned	O
int	O
i	*(struct)
;	O
value	long
=	O
exp	O
->	O
X_add_number	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
sizeof	O
(	O
exp	O
->	O
X_add_number	O
)	O
/	O
CHARS_PER_LITTLENUM	O
;	O
i	*(struct)
++	O
)	O
{	O
generic_bignum	O
[	O
i	*(struct)
]	O
=	O
value	long
&	O
LITTLENUM_MASK	O
;	O
value	long
>>=	O
LITTLENUM_NUMBER_OF_BITS	O
;	O
}	O
if	O
(	O
(	O
exp	O
->	O
X_add_number	O
<	O
0	int
)	O
==	O
!	O
sign	O
)	O
generic_bignum	O
[	O
i	*(struct)
++	O
]	O
=	O
sign	O
?	O
LITTLENUM_MASK	O
:	O
0	int
;	O
exp	O
->	O
X_op	O
=	O
O_big	O
;	O
exp	O
->	O
X_add_number	O
=	O
i	*(struct)
;	O
}	O
char	O
*	O
mri_comment_field	O
(	O
char	O
*	O
stopcp	O
)	O
{	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
for	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
input_line_pointer	O
;	O
!	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
]	O
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
++	O
)	O
;	O
*	O
stopcp	O
=	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
'\0'	O
;	O
return	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
}	O
void	O
mri_comment_end	O
(	O
char	O
*	O
stop	O
,	O
int	O
stopc	O
)	O
{	O
know	O
(	O
flag_mri	O
)	O
;	O
input_line_pointer	O
=	O
stop	O
;	O
*	O
stop	O
=	O
stopc	O
;	O
while	O
(	O
!	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
)	O
++	O
input_line_pointer	O
;	O
}	O
void	O
s_abort	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
as_fatal	O
(	O
_	O
(	O
".abort detected.  Abandoning ship."	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
s_align	O
(	O
signed	O
int	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
,	O
int	O
bytes_p	O
)	O
{	O
unsigned	O
int	O
align_limit	O
=	O
TC_ALIGN_LIMIT	O
;	O
unsigned	O
int	O
align	O
;	O
char	O
*	O
stop	O
=	O
NULL	O
;	O
char	O
stopc	O
=	O
0	int
;	O
offsetT	O
fill	*((long,int,int)->(*(void)))
=	O
0	int
;	O
unsigned	O
int	O
max	O
;	O
int	O
fill_p	O
;	O
if	O
(	O
flag_mri	O
)	O
stop	O
=	O
mri_comment_field	O
(	O
&	O
stopc	O
)	O
;	O
if	O
(	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
)	O
{	O
if	O
(	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
<	O
0	int
)	O
align	O
=	O
0	int
;	O
else	O
align	O
=	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
;	O
}	O
else	O
{	O
align	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
if	O
(	O
bytes_p	O
)	O
{	O
if	O
(	O
align	O
!=	O
0	int
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
(	O
align	O
&	O
1	int
)	O
==	O
0	int
;	O
align	O
>>=	O
1	int
,	O
++	O
i	*(struct)
)	O
;	O
if	O
(	O
align	O
!=	O
1	int
)	O
as_bad	O
(	O
_	O
(	O
"alignment not a power of 2"	*(char)
)	O
)	O
;	O
align	O
=	O
i	*(struct)
;	O
}	O
}	O
if	O
(	O
align	O
>	O
align_limit	O
)	O
{	O
align	O
=	O
align_limit	O
;	O
as_warn	O
(	O
_	O
(	O
"alignment too large: %u assumed"	*(char)
)	O
,	O
align	O
)	O
;	O
}	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
{	O
fill_p	O
=	O
0	int
;	O
max	O
=	O
0	int
;	O
}	O
else	O
{	O
++	O
input_line_pointer	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
fill_p	O
=	O
0	int
;	O
else	O
{	O
fill	*((long,int,int)->(*(void)))
=	O
get_absolute_expression	O
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
fill_p	O
=	O
1	int
;	O
}	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
max	O
=	O
0	int
;	O
else	O
{	O
++	O
input_line_pointer	O
;	O
max	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
fill_p	O
)	O
{	O
if	O
(	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
<	O
0	int
)	O
as_warn	O
(	O
_	O
(	O
"expected fill pattern missing"	*(char)
)	O
)	O
;	O
do_align	O
(	O
align	O
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
0	int
,	O
max	O
)	O
;	O
}	O
else	O
{	O
unsigned	O
int	O
fill_len	O
;	O
if	O
(	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
>=	O
0	int
)	O
fill_len	O
=	O
1	int
;	O
else	O
fill_len	O
=	O
-	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
;	O
if	O
(	O
fill_len	O
<=	O
1	int
)	O
{	O
char	O
fill_char	O
=	O
0	int
;	O
fill_char	O
=	O
fill	*((long,int,int)->(*(void)))
;	O
do_align	O
(	O
align	O
,	O
&	O
fill_char	O
,	O
fill_len	O
,	O
max	O
)	O
;	O
}	O
else	O
{	O
char	O
ab	O
[	O
16	int
]	O
;	O
if	O
(	O
(	O
size_t	long
)	O
fill_len	O
>	O
sizeof	O
ab	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"fill pattern too long, truncating to %u"	*(char)
)	O
,	O
(	O
unsigned	O
)	O
sizeof	O
ab	O
)	O
;	O
fill_len	O
=	O
sizeof	O
ab	O
;	O
}	O
md_number_to_chars	O
(	O
ab	O
,	O
fill	*((long,int,int)->(*(void)))
,	O
fill_len	O
)	O
;	O
do_align	O
(	O
align	O
,	O
ab	O
,	O
fill_len	O
,	O
max	O
)	O
;	O
}	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
}	O
void	O
s_align_bytes	O
(	O
int	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
)	O
{	O
s_align	O
(	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
,	O
1	int
)	O
;	O
}	O
void	O
s_align_ptwo	O
(	O
int	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
)	O
{	O
s_align	O
(	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
,	O
0	int
)	O
;	O
}	O
static	O
void	O
s_altmacro	O
(	O
int	O
on	O
)	O
{	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
macro_set_alternate	O
(	O
on	O
)	O
;	O
}	O
char	O
*	O
read_symbol_name	O
(	O
void	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
start	O
;	O
char	O
c	O
;	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
if	O
(	O
c	O
==	O
'"'	O
)	O
{	O
ptrdiff_t	O
len	long
=	O
SYM_NAME_CHUNK_LEN	O
;	O
char	O
*	O
name_end	O
;	O
unsigned	O
int	O
C	O
;	O
start	O
=	O
name	*(char)
=	O
XNEWVEC	O
(	O
char	O
,	O
len	long
+	O
1	int
)	O
;	O
name_end	O
=	O
name	*(char)
+	O
SYM_NAME_CHUNK_LEN	O
;	O
while	O
(	O
is_a_char	O
(	O
C	O
=	O
next_char_of_string	O
(	O
)	O
)	O
)	O
{	O
if	O
(	O
name	*(char)
>=	O
name_end	O
)	O
{	O
ptrdiff_t	O
sofar	O
;	O
sofar	O
=	O
name	*(char)
-	O
start	O
;	O
len	long
+=	O
SYM_NAME_CHUNK_LEN	O
;	O
start	O
=	O
XRESIZEVEC	O
(	O
char	O
,	O
start	O
,	O
len	long
+	O
1	int
)	O
;	O
name_end	O
=	O
start	O
+	O
len	long
;	O
name	*(char)
=	O
start	O
+	O
sofar	O
;	O
}	O
*	O
name	*(char)
++	O
=	O
(	O
char	O
)	O
C	O
;	O
}	O
*	O
name	*(char)
=	O
0	int
;	O
if	O
(	O
mbstowcs	(*(int),*(char),long)->(long)
(	O
NULL	O
,	O
name	*(char)
,	O
len	long
)	O
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
as_warn	O
(	O
_	O
(	O
"symbol name not recognised in the current locale"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
is_name_beginner	O
(	O
c	O
)	O
||	O
(	O
input_from_string	O
&&	O
c	O
==	O
FAKE_LABEL_CHAR	O
)	O
)	O
{	O
ptrdiff_t	O
len	long
;	O
name	*(char)
=	O
input_line_pointer	O
-	O
1	int
;	O
while	O
(	O
is_part_of_name	O
(	O
c	O
=	O
*	O
input_line_pointer	O
++	O
)	O
||	O
(	O
input_from_string	O
&&	O
c	O
==	O
FAKE_LABEL_CHAR	O
)	O
)	O
;	O
len	long
=	O
(	O
input_line_pointer	O
-	O
name	*(char)
)	O
-	O
1	int
;	O
start	O
=	O
XNEWVEC	O
(	O
char	O
,	O
len	long
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
start	O
,	O
name	*(char)
,	O
len	long
)	O
;	O
start	O
[	O
len	long
]	O
=	O
0	int
;	O
if	O
(	O
!	O
is_name_ender	O
(	O
c	O
)	O
)	O
--	O
input_line_pointer	O
;	O
}	O
else	O
name	*(char)
=	O
start	O
=	O
NULL	O
;	O
if	O
(	O
name	*(char)
==	O
start	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"expected symbol name"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
return	O
start	O
;	O
}	O
symbolS	O
*	O
s_comm_internal	O
(	O
int	O
param	O
,	O
symbolS	O
*	O
(	O
*	O
comm_parse_extra	O
)	O
(	O
int	O
,	O
symbolS	O
*	O
,	O
addressT	O
)	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
offsetT	O
temp	O
,	O
size	int
;	O
symbolS	O
*	O
symbolP	O
=	O
NULL	O
;	O
char	O
*	O
stop	O
=	O
NULL	O
;	O
char	O
stopc	O
=	O
0	int
;	O
expressionS	O
exp	O
;	O
if	O
(	O
flag_mri	O
)	O
stop	O
=	O
mri_comment_field	O
(	O
&	O
stopc	O
)	O
;	O
if	O
(	O
(	O
name	*(char)
=	O
read_symbol_name	O
(	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
out	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
input_line_pointer	O
++	O
;	O
temp	O
=	O
get_absolute_expr	O
(	O
&	O
exp	O
)	O
;	O
size	int
=	O
temp	O
;	O
size	int
&=	O
(	O
(	O
addressT	O
)	O
2	int
<<	O
(	O
stdoutput	O
->	O
arch_info	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
->	O
bits_per_address	int
-	O
1	int
)	O
)	O
-	O
1	int
;	O
if	O
(	O
exp	O
.	O
X_op	O
==	O
O_absent	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"missing size expression"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
goto	O
out	O
;	O
}	O
else	O
if	O
(	O
temp	O
!=	O
size	int
||	O
!	O
exp	O
.	O
X_unsigned	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"size (%ld) out of range, ignored"	*(char)
)	O
,	O
(	O
long	O
)	O
temp	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
goto	O
out	O
;	O
}	O
symbolP	O
=	O
symbol_find_or_make	O
(	O
name	*(char)
)	O
;	O
if	O
(	O
(	O
S_IS_DEFINED	O
(	O
symbolP	O
)	O
||	O
symbol_equated_p	O
(	O
symbolP	O
)	O
)	O
&&	O
!	O
S_IS_COMMON	O
(	O
symbolP	O
)	O
)	O
{	O
if	O
(	O
!	O
S_IS_VOLATILE	O
(	O
symbolP	O
)	O
)	O
{	O
symbolP	O
=	O
NULL	O
;	O
as_bad	O
(	O
_	O
(	O
"symbol `%s' is already defined"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
goto	O
out	O
;	O
}	O
symbolP	O
=	O
symbol_clone	O
(	O
symbolP	O
,	O
1	int
)	O
;	O
S_SET_SEGMENT	O
(	O
symbolP	O
,	O
undefined_section	O
)	O
;	O
S_SET_VALUE	O
(	O
symbolP	O
,	O
0	int
)	O
;	O
symbol_set_frag	O
(	O
symbolP	O
,	O
&	O
zero_address_frag	O
)	O
;	O
S_CLEAR_VOLATILE	O
(	O
symbolP	O
)	O
;	O
}	O
size	int
=	O
S_GET_VALUE	O
(	O
symbolP	O
)	O
;	O
if	O
(	O
size	int
==	O
0	int
)	O
size	int
=	O
temp	O
;	O
else	O
if	O
(	O
size	int
!=	O
temp	O
)	O
as_warn	O
(	O
_	O
(	O
"size of \"%s\" is already %ld; not changing to %ld"	*(char)
)	O
,	O
name	*(char)
,	O
(	O
long	O
)	O
size	int
,	O
(	O
long	O
)	O
temp	O
)	O
;	O
if	O
(	O
comm_parse_extra	O
!=	O
NULL	O
)	O
symbolP	O
=	O
(	O
*	O
comm_parse_extra	O
)	O
(	O
param	O
,	O
symbolP	O
,	O
size	int
)	O
;	O
else	O
{	O
S_SET_VALUE	O
(	O
symbolP	O
,	O
(	O
valueT	O
)	O
size	int
)	O
;	O
S_SET_EXTERNAL	O
(	O
symbolP	O
)	O
;	O
S_SET_SEGMENT	O
(	O
symbolP	O
,	O
bfd_com_section_ptr	O
)	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
out	O
:	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
symbolP	O
;	O
}	O
void	O
s_comm	O
(	O
int	O
ignore	O
)	O
{	O
s_comm_internal	O
(	O
ignore	O
,	O
NULL	O
)	O
;	O
}	O
void	O
s_mri_common	O
(	O
int	O
small	O
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
char	O
c	O
;	O
char	O
*	O
alc	O
=	O
NULL	O
;	O
symbolS	O
*	O
sym	*(struct)
;	O
offsetT	O
align	O
;	O
char	O
*	O
stop	O
=	O
NULL	O
;	O
char	O
stopc	O
=	O
0	int
;	O
if	O
(	O
!	O
flag_mri	O
)	O
{	O
s_comm	O
(	O
0	int
)	O
;	O
return	O
;	O
}	O
stop	O
=	O
mri_comment_field	O
(	O
&	O
stopc	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
name	*(char)
=	O
input_line_pointer	O
;	O
if	O
(	O
!	O
ISDIGIT	O
(	O
*	O
name	*(char)
)	O
)	O
c	O
=	O
get_symbol_name	O
(	O
&	O
name	*(char)
)	O
;	O
else	O
{	O
do	O
{	O
++	O
input_line_pointer	O
;	O
}	O
while	O
(	O
ISDIGIT	O
(	O
*	O
input_line_pointer	O
)	O
)	O
;	O
c	O
=	O
*	O
input_line_pointer	O
;	O
*	O
input_line_pointer	O
=	O
'\0'	O
;	O
if	O
(	O
line_label	O
!=	O
NULL	O
)	O
{	O
alc	O
=	O
XNEWVEC	O
(	O
char	O
,	O
strlen	(*(char))->(long)
(	O
S_GET_NAME	O
(	O
line_label	O
)	O
)	O
+	O
(	O
input_line_pointer	O
-	O
name	*(char)
)	O
+	O
1	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
alc	O
,	O
"%s%s"	*(char)
,	O
name	*(char)
,	O
S_GET_NAME	O
(	O
line_label	O
)	O
)	O
;	O
name	*(char)
=	O
alc	O
;	O
}	O
}	O
sym	*(struct)
=	O
symbol_find_or_make	O
(	O
name	*(char)
)	O
;	O
c	O
=	O
restore_line_pointer	O
(	O
c	O
)	O
;	O
if	O
(	O
alc	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
alc	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
align	O
=	O
0	int
;	O
else	O
{	O
++	O
input_line_pointer	O
;	O
align	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
}	O
if	O
(	O
S_IS_DEFINED	O
(	O
sym	*(struct)
)	O
&&	O
!	O
S_IS_COMMON	O
(	O
sym	*(struct)
)	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"symbol `%s' is already defined"	*(char)
)	O
,	O
S_GET_NAME	O
(	O
sym	*(struct)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
return	O
;	O
}	O
S_SET_EXTERNAL	O
(	O
sym	*(struct)
)	O
;	O
S_SET_SEGMENT	O
(	O
sym	*(struct)
,	O
bfd_com_section_ptr	O
)	O
;	O
mri_common_symbol	O
=	O
sym	*(struct)
;	O
if	O
(	O
align	O
!=	O
0	int
)	O
S_SET_ALIGN	O
(	O
sym	*(struct)
,	O
align	O
)	O
;	O
if	O
(	O
line_label	O
!=	O
NULL	O
)	O
{	O
expressionS	O
exp	O
;	O
exp	O
.	O
X_op	O
=	O
O_symbol	O
;	O
exp	O
.	O
X_add_symbol	O
=	O
sym	*(struct)
;	O
exp	O
.	O
X_add_number	O
=	O
0	int
;	O
symbol_set_value_expression	O
(	O
line_label	O
,	O
&	O
exp	O
)	O
;	O
symbol_set_frag	O
(	O
line_label	O
,	O
&	O
zero_address_frag	O
)	O
;	O
S_SET_SEGMENT	O
(	O
line_label	O
,	O
expr_section	O
)	O
;	O
}	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
input_line_pointer	O
+=	O
2	int
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
input_line_pointer	O
+=	O
2	int
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
}	O
void	O
s_data	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
segT	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
int	O
temp	O
;	O
temp	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
if	O
(	O
flag_readonly_data_in_text	O
)	O
{	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
text_section	O
;	O
temp	O
+=	O
1000	int
;	O
}	O
else	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
data_section	O
;	O
subseg_set	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
(	O
subsegT	O
)	O
temp	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_app_file_string	O
(	O
char	O
*	O
file	*(void)
,	O
int	O
appfile	O
ATTRIBUTE_UNUSED	O
)	O
{	O
register_dependency	O
(	O
file	*(void)
)	O
;	O
obj_app_file	O
(	O
file	*(void)
,	O
appfile	O
)	O
;	O
}	O
void	O
s_app_file	O
(	O
int	O
appfile	O
)	O
{	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
int	O
length	O
;	O
if	O
(	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
demand_copy_string	O
(	O
&	O
length	O
)	O
)	O
!=	O
0	int
)	O
{	O
int	O
may_omit	O
=	O
(	O
!	O
new_logical_line_flags	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
-	O
1	int
,	O
1	int
)	O
&&	O
appfile	O
)	O
;	O
if	O
(	O
flag_m68k_mri	O
&&	O
*	O
input_line_pointer	O
==	O
'\''	O
&&	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
input_line_pointer	O
[	O
1	int
]	O
]	O
)	O
++	O
input_line_pointer	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
!	O
may_omit	O
)	O
s_app_file_string	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
appfile	O
)	O
;	O
}	O
}	O
static	O
int	O
get_linefile_number	O
(	O
int	O
*	O
flag	*(int)
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
<	O
'0'	O
||	O
*	O
input_line_pointer	O
>	O
'9'	O
)	O
return	O
0	int
;	O
*	O
flag	*(int)
=	O
get_absolute_expression	O
(	O
)	O
;	O
return	O
1	int
;	O
}	O
void	O
s_app_line	O
(	O
int	O
appline	O
)	O
{	O
char	O
*	O
file	*(void)
=	O
NULL	O
;	O
int	O
l	O
;	O
if	O
(	O
appline	O
)	O
l	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
else	O
if	O
(	O
!	O
get_linefile_number	O
(	O
&	O
l	O
)	O
)	O
{	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
l	O
--	O
;	O
if	O
(	O
l	O
<	O
-	O
1	int
)	O
as_warn	O
(	O
_	O
(	O
"line numbers must be positive; line number %d rejected"	*(char)
)	O
,	O
l	O
+	O
1	int
)	O
;	O
else	O
{	O
int	O
flags	int
=	O
0	int
;	O
int	O
length	O
=	O
0	int
;	O
if	O
(	O
!	O
appline	O
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
'"'	O
)	O
file	*(void)
=	O
demand_copy_string	O
(	O
&	O
length	O
)	O
;	O
if	O
(	O
file	*(void)
)	O
{	O
int	O
this_flag	O
;	O
while	O
(	O
get_linefile_number	O
(	O
&	O
this_flag	O
)	O
)	O
switch	O
(	O
this_flag	O
)	O
{	O
case	O
1	int
:	O
case	O
2	int
:	O
if	O
(	O
flags	int
&&	O
flags	int
!=	O
(	O
1	int
<<	O
this_flag	O
)	O
)	O
as_warn	O
(	O
_	O
(	O
"incompatible flag %i in line directive"	*(char)
)	O
,	O
this_flag	O
)	O
;	O
else	O
flags	int
|=	O
1	int
<<	O
this_flag	O
;	O
break	O
;	O
case	O
3	int
:	O
case	O
4	int
:	O
break	O
;	O
default	O
:	O
as_warn	O
(	O
_	O
(	O
"unsupported flag %i in line directive"	*(char)
)	O
,	O
this_flag	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
)	O
file	*(void)
=	O
0	int
;	O
}	O
}	O
if	O
(	O
appline	O
||	O
file	*(void)
)	O
{	O
new_logical_line_flags	O
(	O
file	*(void)
,	O
l	O
,	O
flags	int
)	O
;	O
}	O
}	O
if	O
(	O
appline	O
||	O
file	*(void)
)	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
else	O
ignore_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_end	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
flag_mri	O
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
!	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
&&	O
*	O
input_line_pointer	O
!=	O
'*'	O
&&	O
*	O
input_line_pointer	O
!=	O
'!'	O
)	O
as_warn	O
(	O
_	O
(	O
"start address not supported"	*(char)
)	O
)	O
;	O
}	O
}	O
void	O
s_err	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
".err encountered"	*(char)
)	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_errwarn	O
(	O
int	O
err	O
)	O
{	O
int	O
len	long
;	O
const	O
char	O
*	O
msg	O
=	O
(	O
err	O
?	O
_	O
(	O
".error directive invoked in source file"	*(char)
)	O
:	O
_	O
(	O
".warning directive invoked in source file"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
is_it_end_of_statement	O
(	O
)	O
)	O
{	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
'\"'	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"%s argument must be a string"	*(char)
)	O
,	O
err	O
?	O
".error"	*(char)
:	O
".warning"	*(char)
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
msg	O
=	O
demand_copy_C_string	O
(	O
&	O
len	long
)	O
;	O
if	O
(	O
msg	O
==	O
NULL	O
)	O
return	O
;	O
}	O
if	O
(	O
err	O
)	O
as_bad	O
(	O
"%s"	*(char)
,	O
msg	O
)	O
;	O
else	O
as_warn	O
(	O
"%s"	*(char)
,	O
msg	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_fail	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
offsetT	O
temp	O
;	O
char	O
*	O
stop	O
=	O
NULL	O
;	O
char	O
stopc	O
=	O
0	int
;	O
if	O
(	O
flag_mri	O
)	O
stop	O
=	O
mri_comment_field	O
(	O
&	O
stopc	O
)	O
;	O
temp	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
if	O
(	O
temp	O
>=	O
500	int
)	O
as_warn	O
(	O
_	O
(	O
".fail %ld encountered"	*(char)
)	O
,	O
(	O
long	O
)	O
temp	O
)	O
;	O
else	O
as_bad	O
(	O
_	O
(	O
".fail %ld encountered"	*(char)
)	O
,	O
(	O
long	O
)	O
temp	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
}	O
void	O
s_fill	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
expressionS	O
rep_exp	O
;	O
long	O
size	int
=	O
1	int
;	O
long	O
fill	*((long,int,int)->(*(void)))
=	O
0	int
;	O
char	O
*	O
p	*(void)
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
expression	O
(	O
&	O
rep_exp	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
{	O
input_line_pointer	O
++	O
;	O
size	int
=	O
get_absolute_expression	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
{	O
input_line_pointer	O
++	O
;	O
fill	*((long,int,int)->(*(void)))
=	O
get_absolute_expression	O
(	O
)	O
;	O
}	O
}	O
if	O
(	O
size	int
>	O
BSD_FILL_SIZE_CROCK_8	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
".fill size clamped to %d"	*(char)
)	O
,	O
BSD_FILL_SIZE_CROCK_8	O
)	O
;	O
size	int
=	O
BSD_FILL_SIZE_CROCK_8	O
;	O
}	O
if	O
(	O
size	int
<	O
0	int
)	O
{	O
as_warn	O
(	O
_	O
(	O
"size negative; .fill ignored"	*(char)
)	O
)	O
;	O
size	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
rep_exp	O
.	O
X_op	O
==	O
O_constant	O
&&	O
rep_exp	O
.	O
X_add_number	O
<=	O
0	int
)	O
{	O
if	O
(	O
rep_exp	O
.	O
X_add_number	O
<	O
0	int
)	O
as_warn	O
(	O
_	O
(	O
"repeat < 0; .fill ignored"	*(char)
)	O
)	O
;	O
size	int
=	O
0	int
;	O
}	O
if	O
(	O
size	int
&&	O
!	O
need_pass_2	O
)	O
{	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
)	O
{	O
if	O
(	O
rep_exp	O
.	O
X_op	O
!=	O
O_constant	O
)	O
as_bad	O
(	O
_	O
(	O
"non-constant fill count for absolute section"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
fill	*((long,int,int)->(*(void)))
&&	O
rep_exp	O
.	O
X_add_number	O
!=	O
0	int
)	O
as_bad	O
(	O
_	O
(	O
"attempt to fill absolute section with non-zero value"	*(char)
)	O
)	O
;	O
abs_section_offset	O
+=	O
rep_exp	O
.	O
X_add_number	O
*	O
size	int
;	O
}	O
else	O
if	O
(	O
fill	*((long,int,int)->(*(void)))
&&	O
(	O
rep_exp	O
.	O
X_op	O
!=	O
O_constant	O
||	O
rep_exp	O
.	O
X_add_number	O
!=	O
0	int
)	O
&&	O
in_bss	O
(	O
)	O
)	O
as_bad	O
(	O
_	O
(	O
"attempt to fill section `%s' with non-zero value"	*(char)
)	O
,	O
segment_name	O
(	O
now_seg	O
)	O
)	O
;	O
if	O
(	O
rep_exp	O
.	O
X_op	O
==	O
O_constant	O
)	O
{	O
p	*(void)
=	O
frag_var	O
(	O
rs_fill	O
,	O
(	O
int	O
)	O
size	int
,	O
(	O
int	O
)	O
size	int
,	O
(	O
relax_substateT	O
)	O
0	int
,	O
(	O
symbolS	O
*	O
)	O
0	int
,	O
(	O
offsetT	O
)	O
rep_exp	O
.	O
X_add_number	O
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
else	O
{	O
symbolS	O
*	O
rep_sym	O
;	O
rep_sym	O
=	O
make_expr_symbol	O
(	O
&	O
rep_exp	O
)	O
;	O
if	O
(	O
size	int
!=	O
1	int
)	O
{	O
expressionS	O
size_exp	O
;	O
size_exp	O
.	O
X_op	O
=	O
O_constant	O
;	O
size_exp	O
.	O
X_add_number	O
=	O
size	int
;	O
rep_exp	O
.	O
X_op	O
=	O
O_multiply	O
;	O
rep_exp	O
.	O
X_add_symbol	O
=	O
rep_sym	O
;	O
rep_exp	O
.	O
X_op_symbol	O
=	O
make_expr_symbol	O
(	O
&	O
size_exp	O
)	O
;	O
rep_exp	O
.	O
X_add_number	O
=	O
0	int
;	O
rep_sym	O
=	O
make_expr_symbol	O
(	O
&	O
rep_exp	O
)	O
;	O
}	O
p	*(void)
=	O
frag_var	O
(	O
rs_space	O
,	O
(	O
int	O
)	O
size	int
,	O
(	O
int	O
)	O
size	int
,	O
(	O
relax_substateT	O
)	O
0	int
,	O
rep_sym	O
,	O
(	O
offsetT	O
)	O
0	int
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
p	*(void)
,	O
0	int
,	O
(	O
unsigned	O
int	O
)	O
size	int
)	O
;	O
md_number_to_chars	O
(	O
p	*(void)
,	O
(	O
valueT	O
)	O
fill	*((long,int,int)->(*(void)))
,	O
(	O
size	int
>	O
BSD_FILL_SIZE_CROCK_4	O
?	O
BSD_FILL_SIZE_CROCK_4	O
:	O
(	O
int	O
)	O
size	int
)	O
)	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_globl	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
c	O
;	O
symbolS	O
*	O
symbolP	O
;	O
char	O
*	O
stop	O
=	O
NULL	O
;	O
char	O
stopc	O
=	O
0	int
;	O
if	O
(	O
flag_mri	O
)	O
stop	O
=	O
mri_comment_field	O
(	O
&	O
stopc	O
)	O
;	O
do	O
{	O
if	O
(	O
(	O
name	*(char)
=	O
read_symbol_name	O
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
symbolP	O
=	O
symbol_find_or_make	O
(	O
name	*(char)
)	O
;	O
S_SET_EXTERNAL	O
(	O
symbolP	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	O
=	O
*	O
input_line_pointer	O
;	O
if	O
(	O
c	O
==	O
','	O
)	O
{	O
input_line_pointer	O
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
)	O
c	O
=	O
'\n'	O
;	O
}	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
while	O
(	O
c	O
==	O
','	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
}	O
void	O
s_irp	O
(	O
int	O
irpc	O
)	O
{	O
char	O
*	O
eol	O
;	O
const	O
char	O
*	O
file	*(void)
;	O
unsigned	O
int	O
line	O
;	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
const	O
char	O
*	O
err	O
;	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
out	O
;	O
file	*(void)
=	O
as_where	O
(	O
&	O
line	O
)	O
;	O
eol	O
=	O
find_end_of_line	O
(	O
input_line_pointer	O
,	O
0	int
)	O
;	O
sb_build	O
(	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
eol	O
-	O
input_line_pointer	O
)	O
;	O
sb_add_buffer	O
(	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
input_line_pointer	O
,	O
eol	O
-	O
input_line_pointer	O
)	O
;	O
input_line_pointer	O
=	O
eol	O
;	O
sb_new	O
(	O
&	O
out	O
)	O
;	O
err	O
=	O
expand_irp	O
(	O
irpc	O
,	O
0	int
,	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
&	O
out	O
,	O
get_non_macro_line_sb	O
)	O
;	O
if	O
(	O
err	O
!=	O
NULL	O
)	O
as_bad_where	O
(	O
file	*(void)
,	O
line	O
,	O
"%s"	*(char)
,	O
err	O
)	O
;	O
sb_kill	O
(	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
input_scrub_include_sb	O
(	O
&	O
out	O
,	O
input_line_pointer	O
,	O
1	int
)	O
;	O
sb_kill	O
(	O
&	O
out	O
)	O
;	O
buffer_limit	O
=	O
input_scrub_next_buffer	O
(	O
&	O
input_line_pointer	O
)	O
;	O
}	O
void	O
s_linkonce	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
enum	O
linkonce_type	O
type	char
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
type	char
=	O
LINKONCE_DISCARD	O
;	O
if	O
(	O
!	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
)	O
{	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
char	O
c	O
;	O
c	O
=	O
get_symbol_name	O
(	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"discard"	*(char)
)	O
==	O
0	int
)	O
type	char
=	O
LINKONCE_DISCARD	O
;	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"one_only"	*(char)
)	O
==	O
0	int
)	O
type	char
=	O
LINKONCE_ONE_ONLY	O
;	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"same_size"	*(char)
)	O
==	O
0	int
)	O
type	char
=	O
LINKONCE_SAME_SIZE	O
;	O
else	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
"same_contents"	*(char)
)	O
==	O
0	int
)	O
type	char
=	O
LINKONCE_SAME_CONTENTS	O
;	O
else	O
as_warn	O
(	O
_	O
(	O
"unrecognized .linkonce type `%s'"	*(char)
)	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
(	O
void	O
)	O
restore_line_pointer	O
(	O
c	O
)	O
;	O
}	O
{	O
flagword	int
flags	int
;	O
if	O
(	O
(	O
bfd_applicable_section_flags	O
(	O
stdoutput	O
)	O
&	O
SEC_LINK_ONCE	O
)	O
==	O
0	int
)	O
as_warn	O
(	O
_	O
(	O
".linkonce is not supported for this object file format"	*(char)
)	O
)	O
;	O
flags	int
=	O
bfd_section_flags	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))))->(int)
(	O
now_seg	O
)	O
;	O
flags	int
|=	O
SEC_LINK_ONCE	O
;	O
switch	O
(	O
type	char
)	O
{	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
LINKONCE_DISCARD	O
:	O
flags	int
|=	O
SEC_LINK_DUPLICATES_DISCARD	O
;	O
break	O
;	O
case	O
LINKONCE_ONE_ONLY	O
:	O
flags	int
|=	O
SEC_LINK_DUPLICATES_ONE_ONLY	O
;	O
break	O
;	O
case	O
LINKONCE_SAME_SIZE	O
:	O
flags	int
|=	O
SEC_LINK_DUPLICATES_SAME_SIZE	O
;	O
break	O
;	O
case	O
LINKONCE_SAME_CONTENTS	O
:	O
flags	int
|=	O
SEC_LINK_DUPLICATES_SAME_CONTENTS	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
bfd_set_section_flags	(*(struct(*(char),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),int,*(struct),*(*(struct`)),int,long,long,long,*(void),*(char),*(struct(int,union`)),int,int,*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct`)),union(*(struct`),*(struct`)),union(*(struct`),*(struct`)))),int)->(int)
(	O
now_seg	O
,	O
flags	int
)	O
)	O
as_bad	O
(	O
_	O
(	O
"bfd_set_section_flags: %s"	*(char)
)	O
,	O
bfd_errmsg	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(char))
(	O
bfd_get_error	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
)	O
)	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
bss_alloc	O
(	O
symbolS	O
*	O
symbolP	O
,	O
addressT	O
size	int
,	O
unsigned	O
int	O
align	O
)	O
{	O
char	O
*	O
pfrag	O
;	O
segT	O
current_seg	O
=	O
now_seg	O
;	O
subsegT	O
current_subseg	O
=	O
now_subseg	O
;	O
segT	O
bss_seg	O
=	O
bss_section	O
;	O
subseg_set	O
(	O
bss_seg	O
,	O
1	int
)	O
;	O
if	O
(	O
align	O
>	O
OCTETS_PER_BYTE_POWER	int
)	O
{	O
record_alignment	O
(	O
bss_seg	O
,	O
align	O
)	O
;	O
frag_align	O
(	O
align	O
,	O
0	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
S_GET_SEGMENT	O
(	O
symbolP	O
)	O
==	O
bss_seg	O
)	O
symbol_get_frag	O
(	O
symbolP	O
)	O
->	O
fr_symbol	O
=	O
NULL	O
;	O
symbol_set_frag	O
(	O
symbolP	O
,	O
frag_now	O
)	O
;	O
pfrag	O
=	O
frag_var	O
(	O
rs_org	O
,	O
1	int
,	O
1	int
,	O
0	int
,	O
symbolP	O
,	O
size	int
,	O
NULL	O
)	O
;	O
*	O
pfrag	O
=	O
0	int
;	O
S_SET_SIZE	O
(	O
symbolP	O
,	O
size	int
)	O
;	O
S_SET_SEGMENT	O
(	O
symbolP	O
,	O
bss_seg	O
)	O
;	O
subseg_set	O
(	O
current_seg	O
,	O
current_subseg	O
)	O
;	O
}	O
offsetT	O
parse_align	O
(	O
int	O
align_bytes	O
)	O
{	O
expressionS	O
exp	O
;	O
addressT	O
align	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
{	O
no_align	O
:	O
as_bad	O
(	O
_	O
(	O
"expected alignment after size"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
input_line_pointer	O
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
align	O
=	O
get_absolute_expr	O
(	O
&	O
exp	O
)	O
;	O
if	O
(	O
exp	O
.	O
X_op	O
==	O
O_absent	O
)	O
goto	O
no_align	O
;	O
if	O
(	O
!	O
exp	O
.	O
X_unsigned	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"alignment negative; 0 assumed"	*(char)
)	O
)	O
;	O
align	O
=	O
0	int
;	O
}	O
if	O
(	O
align_bytes	O
&&	O
align	O
!=	O
0	int
)	O
{	O
unsigned	O
int	O
alignp2	O
=	O
0	int
;	O
while	O
(	O
(	O
align	O
&	O
1	int
)	O
==	O
0	int
)	O
align	O
>>=	O
1	int
,	O
++	O
alignp2	O
;	O
if	O
(	O
align	O
!=	O
1	int
)	O
{	O
as_bad	O
(	O
_	O
(	O
"alignment not a power of 2"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
align	O
=	O
alignp2	O
;	O
}	O
return	O
align	O
;	O
}	O
symbolS	O
*	O
s_lcomm_internal	O
(	O
int	O
needs_align	O
,	O
symbolS	O
*	O
symbolP	O
,	O
addressT	O
size	int
)	O
{	O
addressT	O
align	O
=	O
0	int
;	O
if	O
(	O
needs_align	O
)	O
{	O
align	O
=	O
parse_align	O
(	O
needs_align	O
-	O
1	int
)	O
;	O
if	O
(	O
align	O
==	O
(	O
addressT	O
)	O
-	O
1	int
)	O
return	O
NULL	O
;	O
}	O
else	O
TC_IMPLICIT_LCOMM_ALIGNMENT	O
(	O
size	int
,	O
align	O
)	O
;	O
bss_alloc	O
(	O
symbolP	O
,	O
size	int
,	O
align	O
)	O
;	O
return	O
symbolP	O
;	O
}	O
void	O
s_lcomm	O
(	O
int	O
needs_align	O
)	O
{	O
s_comm_internal	O
(	O
needs_align	O
,	O
s_lcomm_internal	O
)	O
;	O
}	O
void	O
s_lcomm_bytes	O
(	O
int	O
needs_align	O
)	O
{	O
s_comm_internal	O
(	O
needs_align	O
*	O
2	int
,	O
s_lcomm_internal	O
)	O
;	O
}	O
void	O
s_lsym	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
expressionS	O
exp	O
;	O
symbolS	O
*	O
symbolP	O
;	O
if	O
(	O
(	O
name	*(char)
=	O
read_symbol_name	O
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"expected comma after \"%s\""	*(char)
)	O
,	O
name	*(char)
)	O
;	O
goto	O
err_out	O
;	O
}	O
input_line_pointer	O
++	O
;	O
expression_and_evaluate	O
(	O
&	O
exp	O
)	O
;	O
if	O
(	O
exp	O
.	O
X_op	O
!=	O
O_constant	O
&&	O
exp	O
.	O
X_op	O
!=	O
O_register	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"bad expression"	*(char)
)	O
)	O
;	O
goto	O
err_out	O
;	O
}	O
symbolP	O
=	O
symbol_find_or_make	O
(	O
name	*(char)
)	O
;	O
if	O
(	O
S_GET_SEGMENT	O
(	O
symbolP	O
)	O
==	O
undefined_section	O
)	O
{	O
S_SET_SEGMENT	O
(	O
symbolP	O
,	O
(	O
exp	O
.	O
X_op	O
==	O
O_constant	O
?	O
absolute_section	O
:	O
reg_section	O
)	O
)	O
;	O
S_SET_VALUE	O
(	O
symbolP	O
,	O
(	O
valueT	O
)	O
exp	O
.	O
X_add_number	O
)	O
;	O
}	O
else	O
{	O
as_bad	O
(	O
_	O
(	O
"symbol `%s' is already defined"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
;	O
err_out	O
:	O
ignore_rest_of_line	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
static	O
int	O
get_line_sb	O
(	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
line	O
,	O
int	O
in_macro	O
)	O
{	O
char	O
*	O
eol	O
;	O
if	O
(	O
input_line_pointer	O
[	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
bump_line_counters	O
(	O
)	O
;	O
if	O
(	O
input_line_pointer	O
>=	O
buffer_limit	O
)	O
{	O
buffer_limit	O
=	O
input_scrub_next_buffer	O
(	O
&	O
input_line_pointer	O
)	O
;	O
if	O
(	O
buffer_limit	O
==	O
0	int
)	O
return	O
0	int
;	O
}	O
eol	O
=	O
_find_end_of_line	O
(	O
input_line_pointer	O
,	O
flag_m68k_mri	O
,	O
0	int
,	O
in_macro	O
)	O
;	O
sb_add_buffer	O
(	O
line	O
,	O
input_line_pointer	O
,	O
eol	O
-	O
input_line_pointer	O
)	O
;	O
input_line_pointer	O
=	O
eol	O
;	O
return	O
*	O
input_line_pointer	O
++	O
;	O
}	O
static	O
size_t	long
get_non_macro_line_sb	O
(	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
line	O
)	O
{	O
return	O
get_line_sb	O
(	O
line	O
,	O
0	int
)	O
;	O
}	O
static	O
size_t	long
get_macro_line_sb	O
(	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
line	O
)	O
{	O
return	O
get_line_sb	O
(	O
line	O
,	O
1	int
)	O
;	O
}	O
void	O
s_macro	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
eol	O
;	O
const	O
char	O
*	O
file	*(void)
;	O
unsigned	O
int	O
line	O
;	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
const	O
char	O
*	O
err	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
file	*(void)
=	O
as_where	O
(	O
&	O
line	O
)	O
;	O
eol	O
=	O
find_end_of_line	O
(	O
input_line_pointer	O
,	O
0	int
)	O
;	O
sb_build	O
(	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
eol	O
-	O
input_line_pointer	O
)	O
;	O
sb_add_buffer	O
(	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
input_line_pointer	O
,	O
eol	O
-	O
input_line_pointer	O
)	O
;	O
input_line_pointer	O
=	O
eol	O
;	O
if	O
(	O
line_label	O
!=	O
NULL	O
)	O
{	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
label	O
;	O
size_t	long
len	long
;	O
name	*(char)
=	O
S_GET_NAME	O
(	O
line_label	O
)	O
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
sb_build	O
(	O
&	O
label	O
,	O
len	long
)	O
;	O
sb_add_buffer	O
(	O
&	O
label	O
,	O
name	*(char)
,	O
len	long
)	O
;	O
err	O
=	O
define_macro	O
(	O
0	int
,	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
&	O
label	O
,	O
get_macro_line_sb	O
,	O
file	*(void)
,	O
line	O
,	O
&	O
name	*(char)
)	O
;	O
sb_kill	O
(	O
&	O
label	O
)	O
;	O
}	O
else	O
err	O
=	O
define_macro	O
(	O
0	int
,	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
NULL	O
,	O
get_macro_line_sb	O
,	O
file	*(void)
,	O
line	O
,	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
err	O
!=	O
NULL	O
)	O
as_bad_where	O
(	O
file	*(void)
,	O
line	O
,	O
err	O
,	O
name	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
line_label	O
!=	O
NULL	O
)	O
{	O
S_SET_SEGMENT	O
(	O
line_label	O
,	O
absolute_section	O
)	O
;	O
S_SET_VALUE	O
(	O
line_label	O
,	O
0	int
)	O
;	O
symbol_set_frag	O
(	O
line_label	O
,	O
&	O
zero_address_frag	O
)	O
;	O
}	O
if	O
(	O
(	O
(	O
NO_PSEUDO_DOT	O
||	O
flag_m68k_mri	O
)	O
&&	O
hash_find	O
(	O
po_hash	O
,	O
name	*(char)
)	O
!=	O
NULL	O
)	O
||	O
(	O
!	O
flag_m68k_mri	O
&&	O
*	O
name	*(char)
==	O
'.'	O
&&	O
hash_find	O
(	O
po_hash	O
,	O
name	*(char)
+	O
1	int
)	O
!=	O
NULL	O
)	O
)	O
as_warn_where	O
(	O
file	*(void)
,	O
line	O
,	O
_	O
(	O
"attempt to redefine pseudo-op `%s' ignored"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
}	O
sb_kill	O
(	O
&	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
}	O
void	O
s_mexit	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
macro_nest	O
)	O
{	O
cond_exit_macro	O
(	O
macro_nest	O
)	O
;	O
buffer_limit	O
=	O
input_scrub_next_buffer	O
(	O
&	O
input_line_pointer	O
)	O
;	O
}	O
else	O
as_warn	O
(	O
_	O
(	O
"ignoring macro exit outside a macro definition."	*(char)
)	O
)	O
;	O
}	O
void	O
s_mri	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
int	O
on	O
;	O
on	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
if	O
(	O
on	O
!=	O
0	int
)	O
{	O
flag_mri	O
=	O
1	int
;	O
macro_mri_mode	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
flag_mri	O
=	O
0	int
;	O
macro_mri_mode	O
(	O
0	int
)	O
;	O
}	O
expr_set_precedence	O
(	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
do_org	O
(	O
segT	O
segment	O
,	O
expressionS	O
*	O
exp	O
,	O
int	O
fill	*((long,int,int)->(*(void)))
)	O
{	O
if	O
(	O
segment	O
!=	O
now_seg	O
&&	O
segment	O
!=	O
absolute_section	O
&&	O
segment	O
!=	O
expr_section	O
)	O
as_bad	O
(	O
_	O
(	O
"invalid segment \"%s\""	*(char)
)	O
,	O
segment_name	O
(	O
segment	O
)	O
)	O
;	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
)	O
{	O
if	O
(	O
fill	*((long,int,int)->(*(void)))
!=	O
0	int
)	O
as_warn	O
(	O
_	O
(	O
"ignoring fill value in absolute section"	*(char)
)	O
)	O
;	O
if	O
(	O
exp	O
->	O
X_op	O
!=	O
O_constant	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"only constant offsets supported in absolute section"	*(char)
)	O
)	O
;	O
exp	O
->	O
X_add_number	O
=	O
0	int
;	O
}	O
abs_section_offset	O
=	O
exp	O
->	O
X_add_number	O
;	O
}	O
else	O
{	O
char	O
*	O
p	*(void)
;	O
symbolS	O
*	O
sym	*(struct)
=	O
exp	O
->	O
X_add_symbol	O
;	O
offsetT	O
off	O
=	O
exp	O
->	O
X_add_number	O
*	O
OCTETS_PER_BYTE	O
;	O
if	O
(	O
fill	*((long,int,int)->(*(void)))
&&	O
in_bss	O
(	O
)	O
)	O
as_warn	O
(	O
_	O
(	O
"ignoring fill value in section `%s'"	*(char)
)	O
,	O
segment_name	O
(	O
now_seg	O
)	O
)	O
;	O
if	O
(	O
exp	O
->	O
X_op	O
!=	O
O_constant	O
&&	O
exp	O
->	O
X_op	O
!=	O
O_symbol	O
)	O
{	O
sym	*(struct)
=	O
make_expr_symbol	O
(	O
exp	O
)	O
;	O
off	O
=	O
0	int
;	O
}	O
p	*(void)
=	O
frag_var	O
(	O
rs_org	O
,	O
1	int
,	O
1	int
,	O
(	O
relax_substateT	O
)	O
0	int
,	O
sym	*(struct)
,	O
off	O
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
*	O
p	*(void)
=	O
fill	*((long,int,int)->(*(void)))
;	O
}	O
}	O
void	O
s_org	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
segT	O
segment	O
;	O
expressionS	O
exp	O
;	O
long	O
temp_fill	O
;	O
if	O
(	O
flag_m68k_mri	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"MRI style ORG pseudo-op not supported"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
segment	O
=	O
get_known_segmented_expression	O
(	O
&	O
exp	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
{	O
input_line_pointer	O
++	O
;	O
temp_fill	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
}	O
else	O
temp_fill	O
=	O
0	int
;	O
if	O
(	O
!	O
need_pass_2	O
)	O
do_org	O
(	O
segment	O
,	O
&	O
exp	O
,	O
temp_fill	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_mri_sect	O
(	O
char	O
*	O
type	char
ATTRIBUTE_UNUSED	O
)	O
{	O
as_bad	O
(	O
"MRI mode not supported for this target"	*(char)
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_print	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
int	O
len	long
;	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
demand_copy_C_string	O
(	O
&	O
len	long
)	O
;	O
if	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
!=	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_purgem	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
is_it_end_of_statement	O
(	O
)	O
)	O
{	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
do	O
{	O
char	O
*	O
name	*(char)
;	O
char	O
c	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	O
=	O
get_symbol_name	O
(	O
&	O
name	*(char)
)	O
;	O
delete_macro	O
(	O
name	*(char)
)	O
;	O
*	O
input_line_pointer	O
=	O
c	O
;	O
SKIP_WHITESPACE_AFTER_NAME	O
(	O
)	O
;	O
}	O
while	O
(	O
*	O
input_line_pointer	O
++	O
==	O
','	O
)	O
;	O
--	O
input_line_pointer	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
s_bad_end	O
(	O
int	O
endr	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
".end%c encountered without preceding %s"	*(char)
)	O
,	O
endr	O
?	O
'r'	O
:	O
'm'	O
,	O
endr	O
?	O
".rept, .irp, or .irpc"	*(char)
:	O
".macro"	*(char)
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_rept	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
size_t	long
count	int
;	O
count	int
=	O
(	O
size_t	long
)	O
get_absolute_expression	O
(	O
)	O
;	O
do_repeat	O
(	O
count	int
,	O
"REPT"	*(char)
,	O
"ENDR"	*(char)
)	O
;	O
}	O
void	O
do_repeat	O
(	O
size_t	long
count	int
,	O
const	O
char	O
*	O
start	O
,	O
const	O
char	O
*	O
end	*(*(char))
)	O
{	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
one	O
;	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
many	O
;	O
if	O
(	O
(	O
(	O
ssize_t	long
)	O
count	int
)	O
<	O
0	int
)	O
{	O
as_bad	O
(	O
_	O
(	O
"negative count for %s - ignored"	*(char)
)	O
,	O
start	O
)	O
;	O
count	int
=	O
0	int
;	O
}	O
sb_new	O
(	O
&	O
one	O
)	O
;	O
if	O
(	O
!	O
buffer_and_nest	O
(	O
start	O
,	O
end	*(*(char))
,	O
&	O
one	O
,	O
get_non_macro_line_sb	O
)	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"%s without %s"	*(char)
)	O
,	O
start	O
,	O
end	*(*(char))
)	O
;	O
return	O
;	O
}	O
sb_build	O
(	O
&	O
many	O
,	O
count	int
*	O
one	O
.	O
len	long
)	O
;	O
while	O
(	O
count	int
--	O
>	O
0	int
)	O
sb_add_sb	O
(	O
&	O
many	O
,	O
&	O
one	O
)	O
;	O
sb_kill	O
(	O
&	O
one	O
)	O
;	O
input_scrub_include_sb	O
(	O
&	O
many	O
,	O
input_line_pointer	O
,	O
1	int
)	O
;	O
sb_kill	O
(	O
&	O
many	O
)	O
;	O
buffer_limit	O
=	O
input_scrub_next_buffer	O
(	O
&	O
input_line_pointer	O
)	O
;	O
}	O
void	O
do_repeat_with_expander	O
(	O
size_t	long
count	int
,	O
const	O
char	O
*	O
start	O
,	O
const	O
char	O
*	O
end	*(*(char))
,	O
const	O
char	O
*	O
expander	O
)	O
{	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
one	O
;	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
many	O
;	O
if	O
(	O
(	O
(	O
ssize_t	long
)	O
count	int
)	O
<	O
0	int
)	O
{	O
as_bad	O
(	O
_	O
(	O
"negative count for %s - ignored"	*(char)
)	O
,	O
start	O
)	O
;	O
count	int
=	O
0	int
;	O
}	O
sb_new	O
(	O
&	O
one	O
)	O
;	O
if	O
(	O
!	O
buffer_and_nest	O
(	O
start	O
,	O
end	*(*(char))
,	O
&	O
one	O
,	O
get_non_macro_line_sb	O
)	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"%s without %s"	*(char)
)	O
,	O
start	O
,	O
end	*(*(char))
)	O
;	O
return	O
;	O
}	O
sb_new	O
(	O
&	O
many	O
)	O
;	O
if	O
(	O
expander	O
!=	O
NULL	O
&&	O
strstr	(*(char),*(char))->(*(char))
(	O
one	O
.	O
ptr	*(*(char))
,	O
expander	O
)	O
!=	O
NULL	O
)	O
{	O
while	O
(	O
count	int
--	O
>	O
0	int
)	O
{	O
int	O
len	long
;	O
char	O
*	O
sub	O
;	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
processed	O
;	O
sb_build	O
(	O
&	O
processed	O
,	O
one	O
.	O
len	long
)	O
;	O
sb_add_sb	O
(	O
&	O
processed	O
,	O
&	O
one	O
)	O
;	O
sub	O
=	O
strstr	(*(char),*(char))->(*(char))
(	O
processed	O
.	O
ptr	*(*(char))
,	O
expander	O
)	O
;	O
len	long
=	O
sprintf	(*(char),*(char))->(int)
(	O
sub	O
,	O
"%lu"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
count	int
)	O
;	O
gas_assert	O
(	O
len	long
<	O
8	int
)	O
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
sub	O
+	O
len	long
,	O
sub	O
+	O
8	int
,	O
processed	O
.	O
ptr	*(*(char))
+	O
processed	O
.	O
len	long
-	O
(	O
sub	O
+	O
8	int
)	O
)	O
;	O
processed	O
.	O
len	long
-=	O
(	O
8	int
-	O
len	long
)	O
;	O
sb_add_sb	O
(	O
&	O
many	O
,	O
&	O
processed	O
)	O
;	O
sb_kill	O
(	O
&	O
processed	O
)	O
;	O
}	O
}	O
else	O
while	O
(	O
count	int
--	O
>	O
0	int
)	O
sb_add_sb	O
(	O
&	O
many	O
,	O
&	O
one	O
)	O
;	O
sb_kill	O
(	O
&	O
one	O
)	O
;	O
input_scrub_include_sb	O
(	O
&	O
many	O
,	O
input_line_pointer	O
,	O
1	int
)	O
;	O
sb_kill	O
(	O
&	O
many	O
)	O
;	O
buffer_limit	O
=	O
input_scrub_next_buffer	O
(	O
&	O
input_line_pointer	O
)	O
;	O
}	O
void	O
end_repeat	O
(	O
int	O
extra	O
)	O
{	O
cond_exit_macro	O
(	O
macro_nest	O
)	O
;	O
while	O
(	O
extra	O
--	O
>=	O
0	int
)	O
buffer_limit	O
=	O
input_scrub_next_buffer	O
(	O
&	O
input_line_pointer	O
)	O
;	O
}	O
static	O
void	O
assign_symbol	O
(	O
char	O
*	O
name	*(char)
,	O
int	O
mode	*(char)
)	O
{	O
symbolS	O
*	O
symbolP	O
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
name	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
segT	O
segment	O
;	O
expressionS	O
exp	O
;	O
segment	O
=	O
get_known_segmented_expression	O
(	O
&	O
exp	O
)	O
;	O
if	O
(	O
!	O
need_pass_2	O
)	O
do_org	O
(	O
segment	O
,	O
&	O
exp	O
,	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
symbolP	O
=	O
symbol_find	O
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
&&	O
(	O
symbolP	O
=	O
md_undefined_symbol	O
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
symbolP	O
=	O
symbol_find_or_make	O
(	O
name	*(char)
)	O
;	O
if	O
(	O
listing	O
&	O
LISTING_SYMBOLS	O
)	O
{	O
extern	O
struct	O
list_info_struct	O
*	O
listing_tail	O
;	O
fragS	O
*	O
dummy_frag	O
=	O
XCNEW	O
(	O
fragS	O
)	O
;	O
dummy_frag	O
->	O
line	O
=	O
listing_tail	O
;	O
dummy_frag	O
->	O
fr_symbol	O
=	O
symbolP	O
;	O
symbol_set_frag	O
(	O
symbolP	O
,	O
dummy_frag	O
)	O
;	O
}	O
}	O
if	O
(	O
S_IS_DEFINED	O
(	O
symbolP	O
)	O
||	O
symbol_equated_p	O
(	O
symbolP	O
)	O
)	O
{	O
if	O
(	O
(	O
mode	*(char)
!=	O
0	int
||	O
!	O
S_IS_VOLATILE	O
(	O
symbolP	O
)	O
)	O
&&	O
!	O
S_CAN_BE_REDEFINED	O
(	O
symbolP	O
)	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"symbol `%s' is already defined"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
input_line_pointer	O
--	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
S_IS_VOLATILE	O
(	O
symbolP	O
)	O
)	O
symbolP	O
=	O
symbol_clone	O
(	O
symbolP	O
,	O
1	int
)	O
;	O
}	O
if	O
(	O
mode	*(char)
==	O
0	int
)	O
S_SET_VOLATILE	O
(	O
symbolP	O
)	O
;	O
else	O
if	O
(	O
mode	*(char)
<	O
0	int
)	O
S_SET_FORWARD_REF	O
(	O
symbolP	O
)	O
;	O
pseudo_set	O
(	O
symbolP	O
)	O
;	O
}	O
void	O
s_set	O
(	O
int	O
equiv	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
(	O
name	*(char)
=	O
read_symbol_name	O
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"expected comma after \"%s\""	*(char)
)	O
,	O
name	*(char)
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
input_line_pointer	O
++	O
;	O
assign_symbol	O
(	O
name	*(char)
,	O
equiv	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
void	O
s_space	O
(	O
int	O
mult	O
)	O
{	O
expressionS	O
exp	O
;	O
expressionS	O
val	int
;	O
char	O
*	O
p	*(void)
=	O
0	int
;	O
char	O
*	O
stop	O
=	O
NULL	O
;	O
char	O
stopc	O
=	O
0	int
;	O
int	O
bytes	O
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
if	O
(	O
flag_mri	O
)	O
stop	O
=	O
mri_comment_field	O
(	O
&	O
stopc	O
)	O
;	O
if	O
(	O
flag_m68k_mri	O
&&	O
mult	O
>	O
1	int
)	O
{	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
)	O
{	O
abs_section_offset	O
+=	O
abs_section_offset	O
&	O
1	int
;	O
if	O
(	O
line_label	O
!=	O
NULL	O
)	O
S_SET_VALUE	O
(	O
line_label	O
,	O
abs_section_offset	O
)	O
;	O
}	O
else	O
if	O
(	O
mri_common_symbol	O
!=	O
NULL	O
)	O
{	O
valueT	O
mri_val	O
;	O
mri_val	O
=	O
S_GET_VALUE	O
(	O
mri_common_symbol	O
)	O
;	O
if	O
(	O
(	O
mri_val	O
&	O
1	int
)	O
!=	O
0	int
)	O
{	O
S_SET_VALUE	O
(	O
mri_common_symbol	O
,	O
mri_val	O
+	O
1	int
)	O
;	O
if	O
(	O
line_label	O
!=	O
NULL	O
)	O
{	O
expressionS	O
*	O
symexp	O
;	O
symexp	O
=	O
symbol_get_value_expression	O
(	O
line_label	O
)	O
;	O
know	O
(	O
symexp	O
->	O
X_op	O
==	O
O_symbol	O
)	O
;	O
know	O
(	O
symexp	O
->	O
X_add_symbol	O
==	O
mri_common_symbol	O
)	O
;	O
symexp	O
->	O
X_add_number	O
+=	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
do_align	O
(	O
1	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
line_label	O
!=	O
NULL	O
)	O
{	O
symbol_set_frag	O
(	O
line_label	O
,	O
frag_now	O
)	O
;	O
S_SET_VALUE	O
(	O
line_label	O
,	O
frag_now_fix	O
(	O
)	O
)	O
;	O
}	O
}	O
}	O
bytes	O
=	O
mult	O
;	O
expression	O
(	O
&	O
exp	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
{	O
++	O
input_line_pointer	O
;	O
expression	O
(	O
&	O
val	int
)	O
;	O
}	O
else	O
{	O
val	int
.	O
X_op	O
=	O
O_constant	O
;	O
val	int
.	O
X_add_number	O
=	O
0	int
;	O
}	O
if	O
(	O
(	O
val	int
.	O
X_op	O
!=	O
O_constant	O
||	O
val	int
.	O
X_add_number	O
<	O
-	O
0x80	int
||	O
val	int
.	O
X_add_number	O
>	O
0xff	int
||	O
(	O
mult	O
!=	O
0	int
&&	O
mult	O
!=	O
1	int
&&	O
val	int
.	O
X_add_number	O
!=	O
0	int
)	O
)	O
&&	O
(	O
now_seg	O
!=	O
absolute_section	O
&&	O
!	O
in_bss	O
(	O
)	O
)	O
)	O
{	O
resolve_expression	O
(	O
&	O
exp	O
)	O
;	O
if	O
(	O
exp	O
.	O
X_op	O
!=	O
O_constant	O
)	O
as_bad	O
(	O
_	O
(	O
"unsupported variable size or fill value"	*(char)
)	O
)	O
;	O
else	O
{	O
offsetT	O
i	*(struct)
;	O
if	O
(	O
exp	O
.	O
X_add_number	O
<	O
0	int
||	O
exp	O
.	O
X_add_number	O
>	O
(	O
1	int
<<	O
10	int
)	O
)	O
as_bad	O
(	O
_	O
(	O
"size value for space directive too large: %lx"	*(char)
)	O
,	O
(	O
long	O
)	O
exp	O
.	O
X_add_number	O
)	O
;	O
else	O
{	O
if	O
(	O
mult	O
==	O
0	int
)	O
mult	O
=	O
1	int
;	O
bytes	O
=	O
mult	O
*	O
exp	O
.	O
X_add_number	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
exp	O
.	O
X_add_number	O
;	O
i	*(struct)
++	O
)	O
emit_expr	O
(	O
&	O
val	int
,	O
mult	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
||	O
mri_common_symbol	O
!=	O
NULL	O
)	O
resolve_expression	O
(	O
&	O
exp	O
)	O
;	O
if	O
(	O
exp	O
.	O
X_op	O
==	O
O_constant	O
)	O
{	O
offsetT	O
repeat	O
;	O
repeat	O
=	O
exp	O
.	O
X_add_number	O
;	O
if	O
(	O
mult	O
)	O
repeat	O
*=	O
mult	O
;	O
bytes	O
=	O
repeat	O
;	O
if	O
(	O
repeat	O
<=	O
0	int
)	O
{	O
if	O
(	O
!	O
flag_mri	O
)	O
as_warn	O
(	O
_	O
(	O
".space repeat count is zero, ignored"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
repeat	O
<	O
0	int
)	O
as_warn	O
(	O
_	O
(	O
".space repeat count is negative, ignored"	*(char)
)	O
)	O
;	O
goto	O
getout	O
;	O
}	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
)	O
{	O
if	O
(	O
val	int
.	O
X_op	O
!=	O
O_constant	O
||	O
val	int
.	O
X_add_number	O
!=	O
0	int
)	O
as_warn	O
(	O
_	O
(	O
"ignoring fill value in absolute section"	*(char)
)	O
)	O
;	O
abs_section_offset	O
+=	O
repeat	O
;	O
goto	O
getout	O
;	O
}	O
if	O
(	O
mri_common_symbol	O
!=	O
NULL	O
)	O
{	O
S_SET_VALUE	O
(	O
mri_common_symbol	O
,	O
S_GET_VALUE	O
(	O
mri_common_symbol	O
)	O
+	O
repeat	O
)	O
;	O
goto	O
getout	O
;	O
}	O
if	O
(	O
!	O
need_pass_2	O
)	O
p	*(void)
=	O
frag_var	O
(	O
rs_fill	O
,	O
1	int
,	O
1	int
,	O
(	O
relax_substateT	O
)	O
0	int
,	O
(	O
symbolS	O
*	O
)	O
0	int
,	O
(	O
offsetT	O
)	O
repeat	O
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"space allocation too complex in absolute section"	*(char)
)	O
)	O
;	O
subseg_set	O
(	O
text_section	O
,	O
0	int
)	O
;	O
}	O
if	O
(	O
mri_common_symbol	O
!=	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"space allocation too complex in common section"	*(char)
)	O
)	O
;	O
mri_common_symbol	O
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
need_pass_2	O
)	O
p	*(void)
=	O
frag_var	O
(	O
rs_space	O
,	O
1	int
,	O
1	int
,	O
(	O
relax_substateT	O
)	O
0	int
,	O
make_expr_symbol	O
(	O
&	O
exp	O
)	O
,	O
(	O
offsetT	O
)	O
0	int
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
val	int
.	O
X_op	O
!=	O
O_constant	O
||	O
val	int
.	O
X_add_number	O
!=	O
0	int
)	O
&&	O
in_bss	O
(	O
)	O
)	O
as_warn	O
(	O
_	O
(	O
"ignoring fill value in section `%s'"	*(char)
)	O
,	O
segment_name	O
(	O
now_seg	O
)	O
)	O
;	O
else	O
if	O
(	O
p	*(void)
)	O
*	O
p	*(void)
=	O
val	int
.	O
X_add_number	O
;	O
}	O
getout	O
:	O
if	O
(	O
flag_mri	O
&&	O
(	O
bytes	O
&	O
1	int
)	O
!=	O
0	int
)	O
mri_pending_align	O
=	O
1	int
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
}	O
void	O
s_nops	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
expressionS	O
exp	O
;	O
expressionS	O
val	int
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
expression	O
(	O
&	O
exp	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
{	O
++	O
input_line_pointer	O
;	O
expression	O
(	O
&	O
val	int
)	O
;	O
}	O
else	O
{	O
val	int
.	O
X_op	O
=	O
O_constant	O
;	O
val	int
.	O
X_add_number	O
=	O
0	int
;	O
}	O
if	O
(	O
val	int
.	O
X_op	O
==	O
O_constant	O
)	O
{	O
if	O
(	O
val	int
.	O
X_add_number	O
<	O
0	int
)	O
{	O
as_warn	O
(	O
_	O
(	O
"negative nop control byte, ignored"	*(char)
)	O
)	O
;	O
val	int
.	O
X_add_number	O
=	O
0	int
;	O
}	O
if	O
(	O
!	O
need_pass_2	O
)	O
{	O
char	O
*	O
p	*(void)
;	O
symbolS	O
*	O
sym	*(struct)
=	O
make_expr_symbol	O
(	O
&	O
exp	O
)	O
;	O
p	*(void)
=	O
frag_var	O
(	O
rs_space_nop	O
,	O
1	int
,	O
1	int
,	O
(	O
relax_substateT	O
)	O
0	int
,	O
sym	*(struct)
,	O
(	O
offsetT	O
)	O
0	int
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
*	O
p	*(void)
=	O
val	int
.	O
X_add_number	O
;	O
}	O
}	O
else	O
as_bad	O
(	O
_	O
(	O
"unsupported variable nop control in .nops directive"	*(char)
)	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_float_space	O
(	O
int	O
float_type	O
)	O
{	O
offsetT	O
count	int
;	O
int	O
flen	O
;	O
char	O
temp	O
[	O
MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT	O
]	O
;	O
char	O
*	O
stop	O
=	O
NULL	O
;	O
char	O
stopc	O
=	O
0	int
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
if	O
(	O
flag_mri	O
)	O
stop	O
=	O
mri_comment_field	O
(	O
&	O
stopc	O
)	O
;	O
count	int
=	O
get_absolute_expression	O
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"missing value"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
return	O
;	O
}	O
++	O
input_line_pointer	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
input_line_pointer	O
[	O
0	int
]	O
==	O
'0'	O
&&	O
ISALPHA	O
(	O
input_line_pointer	O
[	O
1	int
]	O
)	O
)	O
input_line_pointer	O
+=	O
2	int
;	O
if	O
(	O
input_line_pointer	O
[	O
0	int
]	O
==	O
':'	O
)	O
{	O
flen	O
=	O
hex_float	O
(	O
float_type	O
,	O
temp	O
)	O
;	O
if	O
(	O
flen	O
<	O
0	int
)	O
{	O
ignore_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
const	O
char	O
*	O
err	O
;	O
err	O
=	O
md_atof	O
(	O
float_type	O
,	O
temp	O
,	O
&	O
flen	O
)	O
;	O
know	O
(	O
flen	O
<=	O
MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT	O
)	O
;	O
know	O
(	O
err	O
!=	O
NULL	O
||	O
flen	O
>	O
0	int
)	O
;	O
if	O
(	O
err	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"bad floating literal: %s"	*(char)
)	O
,	O
err	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
return	O
;	O
}	O
}	O
while	O
(	O
--	O
count	int
>=	O
0	int
)	O
{	O
char	O
*	O
p	*(void)
;	O
p	*(void)
=	O
frag_more	O
(	O
flen	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
temp	O
,	O
(	O
unsigned	O
int	O
)	O
flen	O
)	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
}	O
void	O
s_struct	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
stop	O
=	O
NULL	O
;	O
char	O
stopc	O
=	O
0	int
;	O
if	O
(	O
flag_mri	O
)	O
stop	O
=	O
mri_comment_field	O
(	O
&	O
stopc	O
)	O
;	O
abs_section_offset	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
if	O
(	O
IS_ELF	O
)	O
obj_elf_section_change_hook	O
(	O
)	O
;	O
subseg_set	O
(	O
absolute_section	O
,	O
0	int
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
}	O
void	O
s_text	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
int	O
temp	O
;	O
temp	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
subseg_set	O
(	O
text_section	O
,	O
(	O
subsegT	O
)	O
temp	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_weakref	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
symbolS	O
*	O
symbolP	O
;	O
symbolS	O
*	O
symbolP2	O
;	O
expressionS	O
exp	O
;	O
if	O
(	O
(	O
name	*(char)
=	O
read_symbol_name	O
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
symbolP	O
=	O
symbol_find_or_make	O
(	O
name	*(char)
)	O
;	O
if	O
(	O
S_IS_DEFINED	O
(	O
symbolP	O
)	O
||	O
symbol_equated_p	O
(	O
symbolP	O
)	O
)	O
{	O
if	O
(	O
!	O
S_IS_VOLATILE	O
(	O
symbolP	O
)	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"symbol `%s' is already defined"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
goto	O
err_out	O
;	O
}	O
symbolP	O
=	O
symbol_clone	O
(	O
symbolP	O
,	O
1	int
)	O
;	O
S_CLEAR_VOLATILE	O
(	O
symbolP	O
)	O
;	O
}	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"expected comma after \"%s\""	*(char)
)	O
,	O
name	*(char)
)	O
;	O
goto	O
err_out	O
;	O
}	O
input_line_pointer	O
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
if	O
(	O
(	O
name	*(char)
=	O
read_symbol_name	O
(	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
(	O
symbolP2	O
=	O
symbol_find_noref	O
(	O
name	*(char)
,	O
1	int
)	O
)	O
==	O
NULL	O
&&	O
(	O
symbolP2	O
=	O
md_undefined_symbol	O
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
symbolP2	O
=	O
symbol_find_or_make	O
(	O
name	*(char)
)	O
;	O
S_SET_WEAKREFD	O
(	O
symbolP2	O
)	O
;	O
}	O
else	O
{	O
symbolS	O
*	O
symp	O
=	O
symbolP2	O
;	O
while	O
(	O
S_IS_WEAKREFR	O
(	O
symp	O
)	O
&&	O
symp	O
!=	O
symbolP	O
)	O
{	O
expressionS	O
*	O
expP	O
=	O
symbol_get_value_expression	O
(	O
symp	O
)	O
;	O
gas_assert	O
(	O
expP	O
->	O
X_op	O
==	O
O_symbol	O
&&	O
expP	O
->	O
X_add_number	O
==	O
0	int
)	O
;	O
symp	O
=	O
expP	O
->	O
X_add_symbol	O
;	O
}	O
if	O
(	O
symp	O
==	O
symbolP	O
)	O
{	O
char	O
*	O
loop	O
;	O
loop	O
=	O
concat	O
(	O
S_GET_NAME	O
(	O
symbolP	O
)	O
,	O
" => "	*(char)
,	O
S_GET_NAME	O
(	O
symbolP2	O
)	O
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
symp	O
=	O
symbolP2	O
;	O
while	O
(	O
symp	O
!=	O
symbolP	O
)	O
{	O
char	O
*	O
old_loop	O
=	O
loop	O
;	O
symp	O
=	O
symbol_get_value_expression	O
(	O
symp	O
)	O
->	O
X_add_symbol	O
;	O
loop	O
=	O
concat	O
(	O
loop	O
,	O
" => "	*(char)
,	O
S_GET_NAME	O
(	O
symp	O
)	O
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
old_loop	O
)	O
;	O
}	O
as_bad	O
(	O
_	O
(	O
"%s: would close weakref loop: %s"	*(char)
)	O
,	O
S_GET_NAME	O
(	O
symbolP	O
)	O
,	O
loop	O
)	O
;	O
free	(*(void))->(void)
(	O
loop	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
exp	O
,	O
0	int
,	O
sizeof	O
(	O
exp	O
)	O
)	O
;	O
exp	O
.	O
X_op	O
=	O
O_symbol	O
;	O
exp	O
.	O
X_add_symbol	O
=	O
symbolP2	O
;	O
S_SET_SEGMENT	O
(	O
symbolP	O
,	O
undefined_section	O
)	O
;	O
symbol_set_value_expression	O
(	O
symbolP	O
,	O
&	O
exp	O
)	O
;	O
symbol_set_frag	O
(	O
symbolP	O
,	O
&	O
zero_address_frag	O
)	O
;	O
S_SET_WEAKREFR	O
(	O
symbolP	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
;	O
err_out	O
:	O
ignore_rest_of_line	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
void	O
demand_empty_rest_of_line	O
(	O
void	O
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
)	O
input_line_pointer	O
++	O
;	O
else	O
{	O
if	O
(	O
ISPRINT	O
(	O
*	O
input_line_pointer	O
)	O
)	O
as_bad	O
(	O
_	O
(	O
"junk at end of line, first unrecognized character is `%c'"	*(char)
)	O
,	O
*	O
input_line_pointer	O
)	O
;	O
else	O
as_bad	O
(	O
_	O
(	O
"junk at end of line, first unrecognized character valued 0x%x"	*(char)
)	O
,	O
*	O
input_line_pointer	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
}	O
know	O
(	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
input_line_pointer	O
[	O
-	O
1	int
]	O
]	O
)	O
;	O
}	O
void	O
ignore_rest_of_line	O
(	O
void	O
)	O
{	O
while	O
(	O
input_line_pointer	O
<	O
buffer_limit	O
&&	O
!	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
)	O
input_line_pointer	O
++	O
;	O
input_line_pointer	O
++	O
;	O
if	O
(	O
input_line_pointer	O
<=	O
buffer_limit	O
)	O
know	O
(	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
input_line_pointer	O
[	O
-	O
1	int
]	O
]	O
)	O
;	O
}	O
static	O
void	O
set_zero_frag	O
(	O
symbolS	O
*	O
symbolP	O
)	O
{	O
if	O
(	O
symbol_get_frag	O
(	O
symbolP	O
)	O
->	O
fr_type	O
!=	O
rs_dummy	O
)	O
symbol_set_frag	O
(	O
symbolP	O
,	O
&	O
zero_address_frag	O
)	O
;	O
}	O
void	O
pseudo_set	O
(	O
symbolS	O
*	O
symbolP	O
)	O
{	O
expressionS	O
exp	O
;	O
segT	O
seg	O
;	O
know	O
(	O
symbolP	O
)	O
;	O
if	O
(	O
!	O
S_IS_FORWARD_REF	O
(	O
symbolP	O
)	O
)	O
(	O
void	O
)	O
expression	O
(	O
&	O
exp	O
)	O
;	O
else	O
(	O
void	O
)	O
deferred_expression	O
(	O
&	O
exp	O
)	O
;	O
if	O
(	O
exp	O
.	O
X_op	O
==	O
O_illegal	O
)	O
as_bad	O
(	O
_	O
(	O
"illegal expression"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
exp	O
.	O
X_op	O
==	O
O_absent	O
)	O
as_bad	O
(	O
_	O
(	O
"missing expression"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
exp	O
.	O
X_op	O
==	O
O_big	O
)	O
{	O
if	O
(	O
exp	O
.	O
X_add_number	O
>	O
0	int
)	O
as_bad	O
(	O
_	O
(	O
"bignum invalid"	*(char)
)	O
)	O
;	O
else	O
as_bad	O
(	O
_	O
(	O
"floating point number invalid"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
exp	O
.	O
X_op	O
==	O
O_subtract	O
&&	O
!	O
S_IS_FORWARD_REF	O
(	O
symbolP	O
)	O
&&	O
SEG_NORMAL	O
(	O
S_GET_SEGMENT	O
(	O
exp	O
.	O
X_add_symbol	O
)	O
)	O
&&	O
(	O
symbol_get_frag	O
(	O
exp	O
.	O
X_add_symbol	O
)	O
==	O
symbol_get_frag	O
(	O
exp	O
.	O
X_op_symbol	O
)	O
)	O
)	O
{	O
exp	O
.	O
X_op	O
=	O
O_constant	O
;	O
exp	O
.	O
X_add_number	O
=	O
(	O
S_GET_VALUE	O
(	O
exp	O
.	O
X_add_symbol	O
)	O
-	O
S_GET_VALUE	O
(	O
exp	O
.	O
X_op_symbol	O
)	O
)	O
;	O
}	O
if	O
(	O
symbol_section_p	O
(	O
symbolP	O
)	O
)	O
{	O
as_bad	O
(	O
"attempt to set value of section symbol"	*(char)
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
exp	O
.	O
X_op	O
)	O
{	O
case	O
O_illegal	O
:	O
case	O
O_absent	O
:	O
case	O
O_big	O
:	O
exp	O
.	O
X_add_number	O
=	O
0	int
;	O
case	O
O_constant	O
:	O
S_SET_SEGMENT	O
(	O
symbolP	O
,	O
absolute_section	O
)	O
;	O
S_SET_VALUE	O
(	O
symbolP	O
,	O
(	O
valueT	O
)	O
exp	O
.	O
X_add_number	O
)	O
;	O
set_zero_frag	O
(	O
symbolP	O
)	O
;	O
break	O
;	O
case	O
O_register	O
:	O
if	O
(	O
S_IS_EXTERNAL	O
(	O
symbolP	O
)	O
)	O
{	O
as_bad	O
(	O
"can't equate global symbol `%s' with register name"	*(char)
,	O
S_GET_NAME	O
(	O
symbolP	O
)	O
)	O
;	O
return	O
;	O
}	O
S_SET_SEGMENT	O
(	O
symbolP	O
,	O
reg_section	O
)	O
;	O
S_SET_VALUE	O
(	O
symbolP	O
,	O
(	O
valueT	O
)	O
exp	O
.	O
X_add_number	O
)	O
;	O
set_zero_frag	O
(	O
symbolP	O
)	O
;	O
symbol_get_value_expression	O
(	O
symbolP	O
)	O
->	O
X_op	O
=	O
O_register	O
;	O
break	O
;	O
case	O
O_symbol	O
:	O
seg	O
=	O
S_GET_SEGMENT	O
(	O
exp	O
.	O
X_add_symbol	O
)	O
;	O
if	O
(	O
symbolP	O
==	O
exp	O
.	O
X_add_symbol	O
&&	O
(	O
seg	O
!=	O
undefined_section	O
||	O
!	O
symbol_constant_p	O
(	O
symbolP	O
)	O
)	O
)	O
{	O
*	O
symbol_X_add_number	O
(	O
symbolP	O
)	O
+=	O
exp	O
.	O
X_add_number	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
S_IS_FORWARD_REF	O
(	O
symbolP	O
)	O
&&	O
seg	O
!=	O
undefined_section	O
)	O
{	O
symbolS	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
exp	O
.	O
X_add_symbol	O
;	O
if	O
(	O
S_IS_COMMON	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
as_bad	O
(	O
_	O
(	O
"`%s' can't be equated to common symbol `%s'"	*(char)
)	O
,	O
S_GET_NAME	O
(	O
symbolP	O
)	O
,	O
S_GET_NAME	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
;	O
S_SET_SEGMENT	O
(	O
symbolP	O
,	O
seg	O
)	O
;	O
S_SET_VALUE	O
(	O
symbolP	O
,	O
exp	O
.	O
X_add_number	O
+	O
S_GET_VALUE	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
;	O
symbol_set_frag	O
(	O
symbolP	O
,	O
symbol_get_frag	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
;	O
copy_symbol_attributes	O
(	O
symbolP	O
,	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
;	O
break	O
;	O
}	O
S_SET_SEGMENT	O
(	O
symbolP	O
,	O
undefined_section	O
)	O
;	O
symbol_set_value_expression	O
(	O
symbolP	O
,	O
&	O
exp	O
)	O
;	O
copy_symbol_attributes	O
(	O
symbolP	O
,	O
exp	O
.	O
X_add_symbol	O
)	O
;	O
set_zero_frag	O
(	O
symbolP	O
)	O
;	O
break	O
;	O
default	O
:	O
S_SET_SEGMENT	O
(	O
symbolP	O
,	O
expr_section	O
)	O
;	O
symbol_set_value_expression	O
(	O
symbolP	O
,	O
&	O
exp	O
)	O
;	O
set_zero_frag	O
(	O
symbolP	O
)	O
;	O
break	O
;	O
}	O
}	O
void	O
do_parse_cons_expression	O
(	O
expressionS	O
*	O
exp	O
,	O
int	O
nbytes	long
ATTRIBUTE_UNUSED	O
)	O
{	O
(	O
void	O
)	O
TC_PARSE_CONS_EXPRESSION	O
(	O
exp	O
,	O
nbytes	long
)	O
;	O
}	O
static	O
void	O
cons_worker	O
(	O
int	O
nbytes	long
,	O
int	O
rva	O
)	O
{	O
int	O
c	O
;	O
expressionS	O
exp	O
;	O
char	O
*	O
stop	O
=	O
NULL	O
;	O
char	O
stopc	O
=	O
0	int
;	O
if	O
(	O
flag_mri	O
)	O
stop	O
=	O
mri_comment_field	O
(	O
&	O
stopc	O
)	O
;	O
if	O
(	O
is_it_end_of_statement	O
(	O
)	O
)	O
{	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
nbytes	long
==	O
0	int
)	O
nbytes	long
=	O
TC_ADDRESS_BYTES	O
(	O
)	O
;	O
md_cons_align	O
(	O
nbytes	long
)	O
;	O
c	O
=	O
0	int
;	O
do	O
{	O
TC_PARSE_CONS_RETURN_TYPE	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
TC_PARSE_CONS_RETURN_NONE	O
;	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
TC_PARSE_CONS_EXPRESSION	O
(	O
&	O
exp	O
,	O
(	O
unsigned	O
int	O
)	O
nbytes	long
)	O
;	O
}	O
if	O
(	O
rva	O
)	O
{	O
if	O
(	O
exp	O
.	O
X_op	O
==	O
O_symbol	O
)	O
exp	O
.	O
X_op	O
=	O
O_symbol_rva	O
;	O
else	O
as_fatal	O
(	O
_	O
(	O
"rva without symbol"	*(char)
)	O
)	O
;	O
}	O
emit_expr_with_reloc	O
(	O
&	O
exp	O
,	O
(	O
unsigned	O
int	O
)	O
nbytes	long
,	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
)	O
;	O
++	O
c	O
;	O
}	O
while	O
(	O
*	O
input_line_pointer	O
++	O
==	O
','	O
)	O
;	O
if	O
(	O
flag_mri	O
&&	O
nbytes	long
==	O
1	int
&&	O
(	O
c	O
&	O
1	int
)	O
!=	O
0	int
)	O
mri_pending_align	O
=	O
1	int
;	O
input_line_pointer	O
--	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
}	O
void	O
cons	O
(	O
int	O
size	int
)	O
{	O
cons_worker	O
(	O
size	int
,	O
0	int
)	O
;	O
}	O
void	O
s_rva	O
(	O
int	O
size	int
)	O
{	O
cons_worker	O
(	O
size	int
,	O
1	int
)	O
;	O
}	O
static	O
void	O
s_reloc	O
(	O
int	O
ignore	O
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
stop	O
=	O
NULL	O
;	O
char	O
stopc	O
=	O
0	int
;	O
expressionS	O
exp	O
;	O
char	O
*	O
r_name	O
;	O
int	O
c	O
;	O
struct	O
reloc_list	O
*	O
reloc	O
;	O
struct	O
_bfd_rel	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
bfd_reloc_code_real_type	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
code	int
;	O
}	O
;	O
static	O
struct	O
_bfd_rel	O
bfd_relocs	O
[	O
]	O
=	O
{	O
{	O
"NONE"	*(char)
,	O
BFD_RELOC_NONE	int
}	O
,	O
{	O
"8"	*(char)
,	O
BFD_RELOC_8	int
}	O
,	O
{	O
"16"	*(char)
,	O
BFD_RELOC_16	int
}	O
,	O
{	O
"32"	*(char)
,	O
BFD_RELOC_32	int
}	O
,	O
{	O
"64"	*(char)
,	O
BFD_RELOC_64	int
}	O
}	O
;	O
reloc	O
=	O
XNEW	O
(	O
struct	O
reloc_list	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
stop	O
=	O
mri_comment_field	O
(	O
&	O
stopc	O
)	O
;	O
expression	O
(	O
&	O
exp	O
)	O
;	O
switch	O
(	O
exp	O
.	O
X_op	O
)	O
{	O
case	O
O_illegal	O
:	O
case	O
O_absent	O
:	O
case	O
O_big	O
:	O
case	O
O_register	O
:	O
as_bad	O
(	O
_	O
(	O
"missing or bad offset expression"	*(char)
)	O
)	O
;	O
goto	O
err_out	O
;	O
case	O
O_constant	O
:	O
exp	O
.	O
X_add_symbol	O
=	O
section_symbol	O
(	O
now_seg	O
)	O
;	O
exp	O
.	O
X_op	O
=	O
O_symbol	O
;	O
case	O
O_symbol	O
:	O
if	O
(	O
exp	O
.	O
X_add_number	O
==	O
0	int
)	O
{	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
offset_sym	O
=	O
exp	O
.	O
X_add_symbol	O
;	O
break	O
;	O
}	O
default	O
:	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
offset_sym	O
=	O
make_expr_symbol	O
(	O
&	O
exp	O
)	O
;	O
break	O
;	O
}	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"missing reloc type"	*(char)
)	O
)	O
;	O
goto	O
err_out	O
;	O
}	O
++	O
input_line_pointer	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	O
=	O
get_symbol_name	O
(	O
&	O
r_name	O
)	O
;	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
r_name	O
,	O
"BFD_RELOC_"	*(char)
,	O
10	int
)	O
==	O
0	int
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
for	O
(	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
howto	*(struct)
=	O
NULL	O
,	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
ARRAY_SIZE	O
(	O
bfd_relocs	O
)	O
;	O
i	*(struct)
++	O
)	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
r_name	O
+	O
10	int
,	O
bfd_relocs	O
[	O
i	*(struct)
]	O
.	O
name	*(char)
)	O
==	O
0	int
)	O
{	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
howto	*(struct)
=	O
bfd_reloc_type_lookup	(*(struct),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(*(struct(int,int,int,int,int,enum(int,int,int,int),int,int,int,int,long,long,*((*`,*`,*`,*`,*`,*`,*`)->(enum(int,int,int,int,int,int,int,int))),*(char))))
(	O
stdoutput	O
,	O
bfd_relocs	O
[	O
i	*(struct)
]	O
.	O
code	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
howto	*(struct)
=	O
bfd_reloc_name_lookup	(*(struct),*(char))->(*(struct(int,int,int,int,int,enum(int,int,int,int),int,int,int,int,long,long,*((*`,*`,*`,*`,*`,*`,*`)->(enum(int,int,int,int,int,int,int,int))),*(char))))
(	O
stdoutput	O
,	O
r_name	O
)	O
;	O
*	O
input_line_pointer	O
=	O
c	O
;	O
if	O
(	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
howto	*(struct)
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"unrecognized reloc type"	*(char)
)	O
)	O
;	O
goto	O
err_out	O
;	O
}	O
exp	O
.	O
X_op	O
=	O
O_absent	O
;	O
SKIP_WHITESPACE_AFTER_NAME	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
{	O
++	O
input_line_pointer	O
;	O
expression	O
(	O
&	O
exp	O
)	O
;	O
}	O
switch	O
(	O
exp	O
.	O
X_op	O
)	O
{	O
case	O
O_illegal	O
:	O
case	O
O_big	O
:	O
case	O
O_register	O
:	O
as_bad	O
(	O
_	O
(	O
"bad reloc expression"	*(char)
)	O
)	O
;	O
err_out	O
:	O
ignore_rest_of_line	O
(	O
)	O
;	O
free	(*(void))->(void)
(	O
reloc	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
return	O
;	O
case	O
O_absent	O
:	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sym	*(struct)
=	O
NULL	O
;	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
addend	long
=	O
0	int
;	O
break	O
;	O
case	O
O_constant	O
:	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sym	*(struct)
=	O
NULL	O
;	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
addend	long
=	O
exp	O
.	O
X_add_number	O
;	O
break	O
;	O
case	O
O_symbol	O
:	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sym	*(struct)
=	O
exp	O
.	O
X_add_symbol	O
;	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
addend	long
=	O
exp	O
.	O
X_add_number	O
;	O
break	O
;	O
default	O
:	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sym	*(struct)
=	O
make_expr_symbol	O
(	O
&	O
exp	O
)	O
;	O
reloc	O
->	O
u	union(long,*(struct))
.	O
a	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct(*(*`),long,long,*(struct`))),*(*(struct(*`,long,long,*`))),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct(struct(*`,long,long,*`),*(struct`))),*(struct(*(char),*(struct`),*(void),*(struct`),*(struct`),*(struct`),long,long,int,enum(int,int,int,int,int),enum(int,int,int,int),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int),int,int,*(struct`),long,long,struct(*`,*`,*`,int,int,int,int),*(struct`),*(struct`),int,int,long,*(*`),int,int,*(struct`),*(void),*(struct`),*(struct`),*(struct`),*(struct`),union(*`,*`),union(*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`),*(void),*(void),*(struct`))),*(struct(*(struct`),*(char),long,int,*(struct`),union(*`,long))),*(*(struct(*`,*`,long,int,*`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
addend	long
=	O
0	int
;	O
break	O
;	O
}	O
reloc	O
->	O
file	*(void)
=	O
as_where	O
(	O
&	O
reloc	O
->	O
line	O
)	O
;	O
reloc	O
->	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
reloc_list	O
;	O
reloc_list	O
=	O
reloc	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
}	O
void	O
emit_expr	O
(	O
expressionS	O
*	O
exp	O
,	O
unsigned	O
int	O
nbytes	long
)	O
{	O
emit_expr_with_reloc	O
(	O
exp	O
,	O
nbytes	long
,	O
TC_PARSE_CONS_RETURN_NONE	O
)	O
;	O
}	O
void	O
emit_expr_with_reloc	O
(	O
expressionS	O
*	O
exp	O
,	O
unsigned	O
int	O
nbytes	long
,	O
TC_PARSE_CONS_RETURN_TYPE	O
reloc	O
)	O
{	O
operatorT	O
op	O
;	O
char	O
*	O
p	*(void)
;	O
valueT	O
extra_digit	O
=	O
0	int
;	O
if	O
(	O
need_pass_2	O
)	O
return	O
;	O
frag_grow	O
(	O
nbytes	long
)	O
;	O
dot_value	O
=	O
frag_now_fix	O
(	O
)	O
;	O
dot_frag	O
=	O
frag_now	O
;	O
{	O
static	O
int	O
dwarf_line	O
=	O
-	O
1	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
segment_name	O
(	O
now_seg	O
)	O
,	O
".line"	*(char)
)	O
!=	O
0	int
)	O
dwarf_line	O
=	O
-	O
1	int
;	O
else	O
if	O
(	O
dwarf_line	O
>=	O
0	int
&&	O
nbytes	long
==	O
2	int
&&	O
exp	O
->	O
X_op	O
==	O
O_constant	O
&&	O
(	O
exp	O
->	O
X_add_number	O
==	O
-	O
1	int
||	O
exp	O
->	O
X_add_number	O
==	O
0xffff	int
)	O
)	O
listing_source_line	O
(	O
(	O
unsigned	O
int	O
)	O
dwarf_line	O
)	O
;	O
else	O
if	O
(	O
nbytes	long
==	O
4	int
&&	O
exp	O
->	O
X_op	O
==	O
O_constant	O
&&	O
exp	O
->	O
X_add_number	O
>=	O
0	int
)	O
dwarf_line	O
=	O
exp	O
->	O
X_add_number	O
;	O
else	O
dwarf_line	O
=	O
-	O
1	int
;	O
}	O
{	O
static	O
int	O
dwarf_file	O
=	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
segment_name	O
(	O
now_seg	O
)	O
,	O
".debug"	*(char)
)	O
!=	O
0	int
)	O
dwarf_file	O
=	O
0	int
;	O
else	O
if	O
(	O
dwarf_file	O
==	O
0	int
&&	O
nbytes	long
==	O
2	int
&&	O
exp	O
->	O
X_op	O
==	O
O_constant	O
&&	O
exp	O
->	O
X_add_number	O
==	O
0x11	int
)	O
dwarf_file	O
=	O
1	int
;	O
else	O
if	O
(	O
dwarf_file	O
==	O
1	int
&&	O
nbytes	long
==	O
2	int
&&	O
exp	O
->	O
X_op	O
==	O
O_constant	O
&&	O
exp	O
->	O
X_add_number	O
==	O
0x12	int
)	O
dwarf_file	O
=	O
2	int
;	O
else	O
if	O
(	O
dwarf_file	O
==	O
2	int
&&	O
nbytes	long
==	O
4	int
)	O
dwarf_file	O
=	O
3	int
;	O
else	O
if	O
(	O
dwarf_file	O
==	O
3	int
&&	O
nbytes	long
==	O
2	int
&&	O
exp	O
->	O
X_op	O
==	O
O_constant	O
&&	O
exp	O
->	O
X_add_number	O
==	O
0x38	int
)	O
dwarf_file	O
=	O
4	int
;	O
else	O
dwarf_file	O
=	O
0	int
;	O
if	O
(	O
dwarf_file	O
==	O
4	int
)	O
dwarf_file_string	O
=	O
1	int
;	O
else	O
dwarf_file_string	O
=	O
0	int
;	O
}	O
if	O
(	O
check_eh_frame	O
(	O
exp	O
,	O
&	O
nbytes	long
)	O
)	O
return	O
;	O
op	O
=	O
exp	O
->	O
X_op	O
;	O
if	O
(	O
op	O
==	O
O_uminus	O
&&	O
exp	O
->	O
X_add_number	O
==	O
0	int
&&	O
symbol_get_value_expression	O
(	O
exp	O
->	O
X_add_symbol	O
)	O
->	O
X_op	O
==	O
O_big	O
&&	O
symbol_get_value_expression	O
(	O
exp	O
->	O
X_add_symbol	O
)	O
->	O
X_add_number	O
>	O
0	int
)	O
{	O
int	O
i	*(struct)
;	O
unsigned	O
long	O
carry	O
;	O
exp	O
=	O
symbol_get_value_expression	O
(	O
exp	O
->	O
X_add_symbol	O
)	O
;	O
carry	O
=	O
1	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
exp	O
->	O
X_add_number	O
;	O
i	*(struct)
++	O
)	O
{	O
unsigned	O
long	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
;	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
=	O
(	O
(	O
(	O
~	O
(	O
generic_bignum	O
[	O
i	*(struct)
]	O
&	O
LITTLENUM_MASK	O
)	O
)	O
&	O
LITTLENUM_MASK	O
)	O
+	O
carry	O
)	O
;	O
generic_bignum	O
[	O
i	*(struct)
]	O
=	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
&	O
LITTLENUM_MASK	O
;	O
carry	O
=	O
next	*(struct(*(struct(*(struct`),*(char),long)),*(char),long))
>>	O
LITTLENUM_NUMBER_OF_BITS	O
;	O
}	O
extra_digit	O
=	O
(	O
valueT	O
)	O
-	O
1	int
;	O
op	O
=	O
O_big	O
;	O
}	O
if	O
(	O
op	O
==	O
O_absent	O
||	O
op	O
==	O
O_illegal	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"zero assumed for missing expression"	*(char)
)	O
)	O
;	O
exp	O
->	O
X_add_number	O
=	O
0	int
;	O
op	O
=	O
O_constant	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
O_big	O
&&	O
exp	O
->	O
X_add_number	O
<=	O
0	int
)	O
{	O
as_bad	O
(	O
_	O
(	O
"floating point number invalid"	*(char)
)	O
)	O
;	O
exp	O
->	O
X_add_number	O
=	O
0	int
;	O
op	O
=	O
O_constant	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
O_register	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"register value used as expression"	*(char)
)	O
)	O
;	O
op	O
=	O
O_constant	O
;	O
}	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
)	O
{	O
if	O
(	O
op	O
!=	O
O_constant	O
||	O
exp	O
->	O
X_add_number	O
!=	O
0	int
)	O
as_bad	O
(	O
_	O
(	O
"attempt to store value in absolute section"	*(char)
)	O
)	O
;	O
abs_section_offset	O
+=	O
nbytes	long
;	O
return	O
;	O
}	O
if	O
(	O
(	O
op	O
!=	O
O_constant	O
||	O
exp	O
->	O
X_add_number	O
!=	O
0	int
)	O
&&	O
in_bss	O
(	O
)	O
)	O
as_bad	O
(	O
_	O
(	O
"attempt to store non-zero value in section `%s'"	*(char)
)	O
,	O
segment_name	O
(	O
now_seg	O
)	O
)	O
;	O
p	*(void)
=	O
frag_more	O
(	O
(	O
int	O
)	O
nbytes	long
)	O
;	O
if	O
(	O
reloc	O
!=	O
TC_PARSE_CONS_RETURN_NONE	O
)	O
{	O
emit_expr_fix	O
(	O
exp	O
,	O
nbytes	long
,	O
frag_now	O
,	O
p	*(void)
,	O
reloc	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
op	O
==	O
O_constant	O
&&	O
nbytes	long
>	O
sizeof	O
(	O
valueT	O
)	O
)	O
{	O
extra_digit	O
=	O
exp	O
->	O
X_unsigned	O
?	O
0	int
:	O
-	O
1	int
;	O
convert_to_bignum	O
(	O
exp	O
,	O
!	O
exp	O
->	O
X_unsigned	O
)	O
;	O
op	O
=	O
O_big	O
;	O
}	O
if	O
(	O
op	O
==	O
O_constant	O
)	O
{	O
valueT	O
get	O
;	O
valueT	O
use	O
;	O
valueT	O
mask	O
;	O
valueT	O
hibit	O
;	O
valueT	O
unmask	O
;	O
if	O
(	O
nbytes	long
>=	O
sizeof	O
(	O
valueT	O
)	O
)	O
{	O
mask	O
=	O
0	int
;	O
if	O
(	O
nbytes	long
>	O
sizeof	O
(	O
valueT	O
)	O
)	O
hibit	O
=	O
0	int
;	O
else	O
hibit	O
=	O
(	O
valueT	O
)	O
1	int
<<	O
(	O
nbytes	long
*	O
BITS_PER_CHAR	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
mask	O
=	O
~	O
(	O
valueT	O
)	O
0	int
<<	O
(	O
BITS_PER_CHAR	O
*	O
nbytes	long
)	O
;	O
hibit	O
=	O
(	O
valueT	O
)	O
1	int
<<	O
(	O
nbytes	long
*	O
BITS_PER_CHAR	O
-	O
1	int
)	O
;	O
}	O
unmask	O
=	O
~	O
mask	O
;	O
get	O
=	O
exp	O
->	O
X_add_number	O
;	O
use	O
=	O
get	O
&	O
unmask	O
;	O
if	O
(	O
(	O
get	O
&	O
mask	O
)	O
!=	O
0	int
&&	O
(	O
(	O
get	O
&	O
mask	O
)	O
!=	O
mask	O
||	O
(	O
get	O
&	O
hibit	O
)	O
==	O
0	int
)	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"value 0x%lx truncated to 0x%lx"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
get	O
,	O
(	O
unsigned	O
long	O
)	O
use	O
)	O
;	O
}	O
md_number_to_chars	O
(	O
p	*(void)
,	O
use	O
,	O
(	O
int	O
)	O
nbytes	long
)	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
O_big	O
)	O
{	O
unsigned	O
int	O
size	int
;	O
LITTLENUM_TYPE	O
*	O
nums	O
;	O
size	int
=	O
exp	O
->	O
X_add_number	O
*	O
CHARS_PER_LITTLENUM	O
;	O
if	O
(	O
nbytes	long
<	O
size	int
)	O
{	O
int	O
i	*(struct)
=	O
nbytes	long
/	O
CHARS_PER_LITTLENUM	O
;	O
if	O
(	O
i	*(struct)
!=	O
0	int
)	O
{	O
LITTLENUM_TYPE	O
sign	O
=	O
0	int
;	O
if	O
(	O
(	O
generic_bignum	O
[	O
--	O
i	*(struct)
]	O
&	O
(	O
1	int
<<	O
(	O
LITTLENUM_NUMBER_OF_BITS	O
-	O
1	int
)	O
)	O
)	O
!=	O
0	int
)	O
sign	O
=	O
~	O
(	O
LITTLENUM_TYPE	O
)	O
0	int
;	O
while	O
(	O
++	O
i	*(struct)
<	O
exp	O
->	O
X_add_number	O
)	O
if	O
(	O
generic_bignum	O
[	O
i	*(struct)
]	O
!=	O
sign	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
nbytes	long
==	O
1	int
)	O
{	O
LITTLENUM_TYPE	O
sign	O
=	O
(	O
generic_bignum	O
[	O
0	int
]	O
&	O
(	O
1	int
<<	O
7	int
)	O
)	O
?	O
-	O
1	int
:	O
0	int
;	O
LITTLENUM_TYPE	O
himask	O
=	O
LITTLENUM_MASK	O
&	O
~	O
0xFF	int
;	O
if	O
(	O
(	O
generic_bignum	O
[	O
0	int
]	O
&	O
himask	O
)	O
==	O
(	O
sign	O
&	O
himask	O
)	O
)	O
{	O
while	O
(	O
++	O
i	*(struct)
<	O
exp	O
->	O
X_add_number	O
)	O
if	O
(	O
generic_bignum	O
[	O
i	*(struct)
]	O
!=	O
sign	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
i	*(struct)
<	O
exp	O
->	O
X_add_number	O
)	O
as_warn	O
(	O
ngettext	O
(	O
"bignum truncated to %d byte"	*(char)
,	O
"bignum truncated to %d bytes"	*(char)
,	O
nbytes	long
)	O
,	O
nbytes	long
)	O
;	O
size	int
=	O
nbytes	long
;	O
}	O
if	O
(	O
nbytes	long
==	O
1	int
)	O
{	O
md_number_to_chars	O
(	O
p	*(void)
,	O
(	O
valueT	O
)	O
generic_bignum	O
[	O
0	int
]	O
,	O
1	int
)	O
;	O
return	O
;	O
}	O
know	O
(	O
nbytes	long
%	O
CHARS_PER_LITTLENUM	O
==	O
0	int
)	O
;	O
if	O
(	O
target_big_endian	O
)	O
{	O
while	O
(	O
nbytes	long
>	O
size	int
)	O
{	O
md_number_to_chars	O
(	O
p	*(void)
,	O
extra_digit	O
,	O
CHARS_PER_LITTLENUM	O
)	O
;	O
nbytes	long
-=	O
CHARS_PER_LITTLENUM	O
;	O
p	*(void)
+=	O
CHARS_PER_LITTLENUM	O
;	O
}	O
nums	O
=	O
generic_bignum	O
+	O
size	int
/	O
CHARS_PER_LITTLENUM	O
;	O
while	O
(	O
size	int
>=	O
CHARS_PER_LITTLENUM	O
)	O
{	O
--	O
nums	O
;	O
md_number_to_chars	O
(	O
p	*(void)
,	O
(	O
valueT	O
)	O
*	O
nums	O
,	O
CHARS_PER_LITTLENUM	O
)	O
;	O
size	int
-=	O
CHARS_PER_LITTLENUM	O
;	O
p	*(void)
+=	O
CHARS_PER_LITTLENUM	O
;	O
}	O
}	O
else	O
{	O
nums	O
=	O
generic_bignum	O
;	O
while	O
(	O
size	int
>=	O
CHARS_PER_LITTLENUM	O
)	O
{	O
md_number_to_chars	O
(	O
p	*(void)
,	O
(	O
valueT	O
)	O
*	O
nums	O
,	O
CHARS_PER_LITTLENUM	O
)	O
;	O
++	O
nums	O
;	O
size	int
-=	O
CHARS_PER_LITTLENUM	O
;	O
p	*(void)
+=	O
CHARS_PER_LITTLENUM	O
;	O
nbytes	long
-=	O
CHARS_PER_LITTLENUM	O
;	O
}	O
while	O
(	O
nbytes	long
>=	O
CHARS_PER_LITTLENUM	O
)	O
{	O
md_number_to_chars	O
(	O
p	*(void)
,	O
extra_digit	O
,	O
CHARS_PER_LITTLENUM	O
)	O
;	O
nbytes	long
-=	O
CHARS_PER_LITTLENUM	O
;	O
p	*(void)
+=	O
CHARS_PER_LITTLENUM	O
;	O
}	O
}	O
}	O
else	O
emit_expr_fix	O
(	O
exp	O
,	O
nbytes	long
,	O
frag_now	O
,	O
p	*(void)
,	O
TC_PARSE_CONS_RETURN_NONE	O
)	O
;	O
}	O
void	O
emit_expr_fix	O
(	O
expressionS	O
*	O
exp	O
,	O
unsigned	O
int	O
nbytes	long
,	O
fragS	O
*	O
frag	O
,	O
char	O
*	O
p	*(void)
,	O
TC_PARSE_CONS_RETURN_TYPE	O
r	O
ATTRIBUTE_UNUSED	O
)	O
{	O
int	O
offset	long
=	O
0	int
;	O
unsigned	O
int	O
size	int
=	O
nbytes	long
;	O
memset	(*(void),int,long)->(*(void))
(	O
p	*(void)
,	O
0	int
,	O
size	int
)	O
;	O
TC_CONS_FIX_NEW	O
(	O
frag	O
,	O
p	*(void)
-	O
frag	O
->	O
fr_literal	O
+	O
offset	long
,	O
size	int
,	O
exp	O
,	O
r	O
)	O
;	O
}	O
static	O
int	O
hex_float	O
(	O
int	O
float_type	O
,	O
char	O
*	O
bytes	O
)	O
{	O
int	O
length	O
;	O
int	O
i	*(struct)
;	O
switch	O
(	O
float_type	O
)	O
{	O
case	O
'f'	O
:	O
case	O
'F'	O
:	O
case	O
's'	O
:	O
case	O
'S'	O
:	O
length	O
=	O
4	int
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'D'	O
:	O
case	O
'r'	O
:	O
case	O
'R'	O
:	O
length	O
=	O
8	int
;	O
break	O
;	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
length	O
=	O
12	int
;	O
break	O
;	O
case	O
'p'	O
:	O
case	O
'P'	O
:	O
length	O
=	O
12	int
;	O
break	O
;	O
default	O
:	O
as_bad	O
(	O
_	O
(	O
"unknown floating type type '%c'"	*(char)
)	O
,	O
float_type	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
i	*(struct)
=	O
0	int
;	O
while	O
(	O
hex_p	O
(	O
*	O
input_line_pointer	O
)	O
||	O
*	O
input_line_pointer	O
==	O
'_'	O
)	O
{	O
int	O
d	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
'_'	O
)	O
{	O
++	O
input_line_pointer	O
;	O
continue	O
;	O
}	O
if	O
(	O
i	*(struct)
>=	O
length	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"floating point constant too large"	*(char)
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
d	O
=	O
hex_value	O
(	O
*	O
input_line_pointer	O
)	O
<<	O
4	int
;	O
++	O
input_line_pointer	O
;	O
while	O
(	O
*	O
input_line_pointer	O
==	O
'_'	O
)	O
++	O
input_line_pointer	O
;	O
if	O
(	O
hex_p	O
(	O
*	O
input_line_pointer	O
)	O
)	O
{	O
d	O
+=	O
hex_value	O
(	O
*	O
input_line_pointer	O
)	O
;	O
++	O
input_line_pointer	O
;	O
}	O
if	O
(	O
target_big_endian	O
)	O
bytes	O
[	O
i	*(struct)
]	O
=	O
d	O
;	O
else	O
bytes	O
[	O
length	O
-	O
i	*(struct)
-	O
1	int
]	O
=	O
d	O
;	O
++	O
i	*(struct)
;	O
}	O
if	O
(	O
i	*(struct)
<	O
length	O
)	O
{	O
if	O
(	O
target_big_endian	O
)	O
memset	(*(void),int,long)->(*(void))
(	O
bytes	O
+	O
i	*(struct)
,	O
0	int
,	O
length	O
-	O
i	*(struct)
)	O
;	O
else	O
memset	(*(void),int,long)->(*(void))
(	O
bytes	O
,	O
0	int
,	O
length	O
-	O
i	*(struct)
)	O
;	O
}	O
return	O
length	O
;	O
}	O
void	O
float_cons	O
(	O
int	O
float_type	O
)	O
{	O
char	O
*	O
p	*(void)
;	O
int	O
length	O
;	O
const	O
char	O
*	O
err	O
;	O
char	O
temp	O
[	O
MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT	O
]	O
;	O
if	O
(	O
is_it_end_of_statement	O
(	O
)	O
)	O
{	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"attempt to store float in absolute section"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
in_bss	O
(	O
)	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"attempt to store float in section `%s'"	*(char)
)	O
,	O
segment_name	O
(	O
now_seg	O
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
md_cons_align	O
(	O
1	int
)	O
;	O
do	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
input_line_pointer	O
[	O
0	int
]	O
==	O
'0'	O
&&	O
ISALPHA	O
(	O
input_line_pointer	O
[	O
1	int
]	O
)	O
)	O
input_line_pointer	O
+=	O
2	int
;	O
if	O
(	O
input_line_pointer	O
[	O
0	int
]	O
==	O
':'	O
)	O
{	O
++	O
input_line_pointer	O
;	O
length	O
=	O
hex_float	O
(	O
float_type	O
,	O
temp	O
)	O
;	O
if	O
(	O
length	O
<	O
0	int
)	O
{	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
err	O
=	O
md_atof	O
(	O
float_type	O
,	O
temp	O
,	O
&	O
length	O
)	O
;	O
know	O
(	O
length	O
<=	O
MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT	O
)	O
;	O
know	O
(	O
err	O
!=	O
NULL	O
||	O
length	O
>	O
0	int
)	O
;	O
if	O
(	O
err	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"bad floating literal: %s"	*(char)
)	O
,	O
err	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
!	O
need_pass_2	O
)	O
{	O
int	O
count	int
;	O
count	int
=	O
1	int
;	O
while	O
(	O
--	O
count	int
>=	O
0	int
)	O
{	O
p	*(void)
=	O
frag_more	O
(	O
length	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
p	*(void)
,	O
temp	O
,	O
(	O
unsigned	O
int	O
)	O
length	O
)	O
;	O
}	O
}	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
while	O
(	O
*	O
input_line_pointer	O
++	O
==	O
','	O
)	O
;	O
--	O
input_line_pointer	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
inline	O
unsigned	O
int	O
sizeof_sleb128	O
(	O
offsetT	O
value	long
)	O
{	O
int	O
size	int
=	O
0	int
;	O
unsigned	O
byte	O
;	O
do	O
{	O
byte	O
=	O
(	O
value	long
&	O
0x7f	int
)	O
;	O
value	long
=	O
(	O
value	long
>>	O
7	int
)	O
|	O
~	O
(	O
-	O
(	O
offsetT	O
)	O
1	int
>>	O
7	int
)	O
;	O
size	int
+=	O
1	int
;	O
}	O
while	O
(	O
!	O
(	O
(	O
(	O
value	long
==	O
0	int
)	O
&&	O
(	O
(	O
byte	O
&	O
0x40	int
)	O
==	O
0	int
)	O
)	O
||	O
(	O
(	O
value	long
==	O
-	O
1	int
)	O
&&	O
(	O
(	O
byte	O
&	O
0x40	int
)	O
!=	O
0	int
)	O
)	O
)	O
)	O
;	O
return	O
size	int
;	O
}	O
static	O
inline	O
unsigned	O
int	O
sizeof_uleb128	O
(	O
valueT	O
value	long
)	O
{	O
int	O
size	int
=	O
0	int
;	O
do	O
{	O
value	long
>>=	O
7	int
;	O
size	int
+=	O
1	int
;	O
}	O
while	O
(	O
value	long
!=	O
0	int
)	O
;	O
return	O
size	int
;	O
}	O
unsigned	O
int	O
sizeof_leb128	O
(	O
valueT	O
value	long
,	O
int	O
sign	O
)	O
{	O
if	O
(	O
sign	O
)	O
return	O
sizeof_sleb128	O
(	O
(	O
offsetT	O
)	O
value	long
)	O
;	O
else	O
return	O
sizeof_uleb128	O
(	O
value	long
)	O
;	O
}	O
static	O
inline	O
unsigned	O
int	O
output_sleb128	O
(	O
char	O
*	O
p	*(void)
,	O
offsetT	O
value	long
)	O
{	O
char	O
*	O
orig	O
=	O
p	*(void)
;	O
int	O
more	O
;	O
do	O
{	O
unsigned	O
byte	O
=	O
(	O
value	long
&	O
0x7f	int
)	O
;	O
value	long
=	O
(	O
value	long
>>	O
7	int
)	O
|	O
~	O
(	O
-	O
(	O
offsetT	O
)	O
1	int
>>	O
7	int
)	O
;	O
more	O
=	O
!	O
(	O
(	O
(	O
(	O
value	long
==	O
0	int
)	O
&&	O
(	O
(	O
byte	O
&	O
0x40	int
)	O
==	O
0	int
)	O
)	O
||	O
(	O
(	O
value	long
==	O
-	O
1	int
)	O
&&	O
(	O
(	O
byte	O
&	O
0x40	int
)	O
!=	O
0	int
)	O
)	O
)	O
)	O
;	O
if	O
(	O
more	O
)	O
byte	O
|=	O
0x80	int
;	O
*	O
p	*(void)
++	O
=	O
byte	O
;	O
}	O
while	O
(	O
more	O
)	O
;	O
return	O
p	*(void)
-	O
orig	O
;	O
}	O
static	O
inline	O
unsigned	O
int	O
output_uleb128	O
(	O
char	O
*	O
p	*(void)
,	O
valueT	O
value	long
)	O
{	O
char	O
*	O
orig	O
=	O
p	*(void)
;	O
do	O
{	O
unsigned	O
byte	O
=	O
(	O
value	long
&	O
0x7f	int
)	O
;	O
value	long
>>=	O
7	int
;	O
if	O
(	O
value	long
!=	O
0	int
)	O
byte	O
|=	O
0x80	int
;	O
*	O
p	*(void)
++	O
=	O
byte	O
;	O
}	O
while	O
(	O
value	long
!=	O
0	int
)	O
;	O
return	O
p	*(void)
-	O
orig	O
;	O
}	O
unsigned	O
int	O
output_leb128	O
(	O
char	O
*	O
p	*(void)
,	O
valueT	O
value	long
,	O
int	O
sign	O
)	O
{	O
if	O
(	O
sign	O
)	O
return	O
output_sleb128	O
(	O
p	*(void)
,	O
(	O
offsetT	O
)	O
value	long
)	O
;	O
else	O
return	O
output_uleb128	O
(	O
p	*(void)
,	O
value	long
)	O
;	O
}	O
static	O
inline	O
unsigned	O
int	O
output_big_sleb128	O
(	O
char	O
*	O
p	*(void)
,	O
LITTLENUM_TYPE	O
*	O
bignum	O
,	O
unsigned	O
int	O
size	int
)	O
{	O
char	O
*	O
orig	O
=	O
p	*(void)
;	O
valueT	O
val	int
=	O
0	int
;	O
int	O
loaded	O
=	O
0	int
;	O
unsigned	O
byte	O
;	O
while	O
(	O
size	int
>	O
1	int
&&	O
bignum	O
[	O
size	int
-	O
1	int
]	O
==	O
LITTLENUM_MASK	O
&&	O
bignum	O
[	O
size	int
-	O
2	int
]	O
>	O
LITTLENUM_MASK	O
/	O
2	int
)	O
size	int
--	O
;	O
do	O
{	O
val	int
|=	O
(	O
*	O
bignum	O
<<	O
loaded	O
)	O
;	O
loaded	O
+=	O
LITTLENUM_NUMBER_OF_BITS	O
;	O
size	int
--	O
;	O
bignum	O
++	O
;	O
do	O
{	O
byte	O
=	O
val	int
&	O
0x7f	int
;	O
loaded	O
-=	O
7	int
;	O
val	int
>>=	O
7	int
;	O
if	O
(	O
size	int
>	O
0	int
||	O
val	int
!=	O
(	O
(	O
byte	O
&	O
0x40	int
)	O
==	O
0	int
?	O
0	int
:	O
(	O
(	O
valueT	O
)	O
1	int
<<	O
loaded	O
)	O
-	O
1	int
)	O
)	O
byte	O
|=	O
0x80	int
;	O
if	O
(	O
orig	O
)	O
*	O
p	*(void)
=	O
byte	O
;	O
p	*(void)
++	O
;	O
}	O
while	O
(	O
(	O
byte	O
&	O
0x80	int
)	O
!=	O
0	int
&&	O
loaded	O
>=	O
7	int
)	O
;	O
}	O
while	O
(	O
size	int
>	O
0	int
)	O
;	O
if	O
(	O
(	O
byte	O
&	O
0x80	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
val	int
&	O
(	O
1	int
<<	O
(	O
loaded	O
-	O
1	int
)	O
)	O
)	O
val	int
|=	O
~	O
0U	int
<<	O
loaded	O
;	O
if	O
(	O
orig	O
)	O
*	O
p	*(void)
=	O
val	int
&	O
0x7f	int
;	O
p	*(void)
++	O
;	O
}	O
return	O
p	*(void)
-	O
orig	O
;	O
}	O
static	O
inline	O
unsigned	O
int	O
output_big_uleb128	O
(	O
char	O
*	O
p	*(void)
,	O
LITTLENUM_TYPE	O
*	O
bignum	O
,	O
unsigned	O
int	O
size	int
)	O
{	O
char	O
*	O
orig	O
=	O
p	*(void)
;	O
valueT	O
val	int
=	O
0	int
;	O
int	O
loaded	O
=	O
0	int
;	O
unsigned	O
byte	O
;	O
while	O
(	O
size	int
>	O
0	int
&&	O
bignum	O
[	O
size	int
-	O
1	int
]	O
==	O
0	int
)	O
size	int
--	O
;	O
do	O
{	O
if	O
(	O
loaded	O
<	O
7	int
&&	O
size	int
>	O
0	int
)	O
{	O
val	int
|=	O
(	O
*	O
bignum	O
<<	O
loaded	O
)	O
;	O
loaded	O
+=	O
8	int
*	O
CHARS_PER_LITTLENUM	O
;	O
size	int
--	O
;	O
bignum	O
++	O
;	O
}	O
byte	O
=	O
val	int
&	O
0x7f	int
;	O
loaded	O
-=	O
7	int
;	O
val	int
>>=	O
7	int
;	O
if	O
(	O
size	int
>	O
0	int
||	O
val	int
)	O
byte	O
|=	O
0x80	int
;	O
if	O
(	O
orig	O
)	O
*	O
p	*(void)
=	O
byte	O
;	O
p	*(void)
++	O
;	O
}	O
while	O
(	O
byte	O
&	O
0x80	int
)	O
;	O
return	O
p	*(void)
-	O
orig	O
;	O
}	O
static	O
unsigned	O
int	O
output_big_leb128	O
(	O
char	O
*	O
p	*(void)
,	O
LITTLENUM_TYPE	O
*	O
bignum	O
,	O
unsigned	O
int	O
size	int
,	O
int	O
sign	O
)	O
{	O
if	O
(	O
sign	O
)	O
return	O
output_big_sleb128	O
(	O
p	*(void)
,	O
bignum	O
,	O
size	int
)	O
;	O
else	O
return	O
output_big_uleb128	O
(	O
p	*(void)
,	O
bignum	O
,	O
size	int
)	O
;	O
}	O
static	O
void	O
emit_leb128_expr	O
(	O
expressionS	O
*	O
exp	O
,	O
int	O
sign	O
)	O
{	O
operatorT	O
op	O
=	O
exp	O
->	O
X_op	O
;	O
unsigned	O
int	O
nbytes	long
;	O
if	O
(	O
op	O
==	O
O_absent	O
||	O
op	O
==	O
O_illegal	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"zero assumed for missing expression"	*(char)
)	O
)	O
;	O
exp	O
->	O
X_add_number	O
=	O
0	int
;	O
op	O
=	O
O_constant	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
O_big	O
&&	O
exp	O
->	O
X_add_number	O
<=	O
0	int
)	O
{	O
as_bad	O
(	O
_	O
(	O
"floating point number invalid"	*(char)
)	O
)	O
;	O
exp	O
->	O
X_add_number	O
=	O
0	int
;	O
op	O
=	O
O_constant	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
O_register	O
)	O
{	O
as_warn	O
(	O
_	O
(	O
"register value used as expression"	*(char)
)	O
)	O
;	O
op	O
=	O
O_constant	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
O_constant	O
&&	O
sign	O
&&	O
(	O
exp	O
->	O
X_add_number	O
<	O
0	int
)	O
==	O
!	O
exp	O
->	O
X_extrabit	O
)	O
{	O
convert_to_bignum	O
(	O
exp	O
,	O
exp	O
->	O
X_extrabit	O
)	O
;	O
op	O
=	O
O_big	O
;	O
}	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
)	O
{	O
if	O
(	O
op	O
!=	O
O_constant	O
||	O
exp	O
->	O
X_add_number	O
!=	O
0	int
)	O
as_bad	O
(	O
_	O
(	O
"attempt to store value in absolute section"	*(char)
)	O
)	O
;	O
abs_section_offset	O
++	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
op	O
!=	O
O_constant	O
||	O
exp	O
->	O
X_add_number	O
!=	O
0	int
)	O
&&	O
in_bss	O
(	O
)	O
)	O
as_bad	O
(	O
_	O
(	O
"attempt to store non-zero value in section `%s'"	*(char)
)	O
,	O
segment_name	O
(	O
now_seg	O
)	O
)	O
;	O
nbytes	long
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
if	O
(	O
check_eh_frame	O
(	O
exp	O
,	O
&	O
nbytes	long
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
if	O
(	O
op	O
==	O
O_constant	O
)	O
{	O
valueT	O
value	long
=	O
exp	O
->	O
X_add_number	O
;	O
unsigned	O
int	O
size	int
;	O
char	O
*	O
p	*(void)
;	O
size	int
=	O
sizeof_leb128	O
(	O
value	long
,	O
sign	O
)	O
;	O
p	*(void)
=	O
frag_more	O
(	O
size	int
)	O
;	O
if	O
(	O
output_leb128	O
(	O
p	*(void)
,	O
value	long
,	O
sign	O
)	O
>	O
size	int
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
O_big	O
)	O
{	O
int	O
nbr_digits	O
=	O
exp	O
->	O
X_add_number	O
;	O
unsigned	O
int	O
size	int
;	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
exp	O
->	O
X_unsigned	O
&&	O
nbr_digits	O
<	O
SIZE_OF_LARGE_NUMBER	O
&&	O
generic_bignum	O
[	O
nbr_digits	O
-	O
1	int
]	O
==	O
LITTLENUM_MASK	O
)	O
generic_bignum	O
[	O
nbr_digits	O
++	O
]	O
=	O
0	int
;	O
size	int
=	O
output_big_leb128	O
(	O
NULL	O
,	O
generic_bignum	O
,	O
nbr_digits	O
,	O
sign	O
)	O
;	O
p	*(void)
=	O
frag_more	O
(	O
size	int
)	O
;	O
if	O
(	O
output_big_leb128	O
(	O
p	*(void)
,	O
generic_bignum	O
,	O
nbr_digits	O
,	O
sign	O
)	O
>	O
size	int
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
frag_var	O
(	O
rs_leb128	O
,	O
sizeof_uleb128	O
(	O
~	O
(	O
valueT	O
)	O
0	int
)	O
,	O
0	int
,	O
sign	O
,	O
make_expr_symbol	O
(	O
exp	O
)	O
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
}	O
void	O
s_leb128	O
(	O
int	O
sign	O
)	O
{	O
expressionS	O
exp	O
;	O
do	O
{	O
expression	O
(	O
&	O
exp	O
)	O
;	O
emit_leb128_expr	O
(	O
&	O
exp	O
,	O
sign	O
)	O
;	O
}	O
while	O
(	O
*	O
input_line_pointer	O
++	O
==	O
','	O
)	O
;	O
input_line_pointer	O
--	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
static	O
void	O
stringer_append_char	O
(	O
int	O
c	O
,	O
int	O
bitsize	int
)	O
{	O
if	O
(	O
c	O
&&	O
in_bss	O
(	O
)	O
)	O
as_bad	O
(	O
_	O
(	O
"attempt to store non-empty string in section `%s'"	*(char)
)	O
,	O
segment_name	O
(	O
now_seg	O
)	O
)	O
;	O
if	O
(	O
!	O
target_big_endian	O
)	O
FRAG_APPEND_1_CHAR	O
(	O
c	O
)	O
;	O
switch	O
(	O
bitsize	int
)	O
{	O
case	O
64	int
:	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
case	O
32	int
:	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
case	O
16	int
:	O
FRAG_APPEND_1_CHAR	O
(	O
0	int
)	O
;	O
case	O
8	int
:	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
target_big_endian	O
)	O
FRAG_APPEND_1_CHAR	O
(	O
c	O
)	O
;	O
}	O
void	O
stringer	O
(	O
int	O
bits_appendzero	O
)	O
{	O
const	O
int	O
bitsize	int
=	O
bits_appendzero	O
&	O
~	O
7	int
;	O
const	O
int	O
append_zero	O
=	O
bits_appendzero	O
&	O
1	int
;	O
unsigned	O
int	O
c	O
;	O
char	O
*	O
start	O
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
if	O
(	O
now_seg	O
==	O
absolute_section	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"strings must be placed into a section"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
is_it_end_of_statement	O
(	O
)	O
)	O
{	O
c	O
=	O
0	int
;	O
++	O
input_line_pointer	O
;	O
}	O
else	O
{	O
c	O
=	O
','	O
;	O
}	O
while	O
(	O
c	O
==	O
','	O
||	O
c	O
==	O
'<'	O
||	O
c	O
==	O
'"'	O
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
switch	O
(	O
*	O
input_line_pointer	O
)	O
{	O
case	O
'\"'	O
:	O
++	O
input_line_pointer	O
;	O
start	O
=	O
input_line_pointer	O
;	O
while	O
(	O
is_a_char	O
(	O
c	O
=	O
next_char_of_string	O
(	O
)	O
)	O
)	O
stringer_append_char	O
(	O
c	O
,	O
bitsize	int
)	O
;	O
if	O
(	O
append_zero	O
)	O
stringer_append_char	O
(	O
0	int
,	O
bitsize	int
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
segment_name	O
(	O
now_seg	O
)	O
,	O
".debug"	*(char)
)	O
!=	O
0	int
)	O
dwarf_file_string	O
=	O
0	int
;	O
else	O
if	O
(	O
dwarf_file_string	O
)	O
{	O
c	O
=	O
input_line_pointer	O
[	O
-	O
1	int
]	O
;	O
input_line_pointer	O
[	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
listing_source_file	O
(	O
start	O
)	O
;	O
input_line_pointer	O
[	O
-	O
1	int
]	O
=	O
c	O
;	O
}	O
break	O
;	O
case	O
'<'	O
:	O
input_line_pointer	O
++	O
;	O
c	O
=	O
get_single_number	O
(	O
)	O
;	O
stringer_append_char	O
(	O
c	O
,	O
bitsize	int
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
'>'	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"expected <nn>"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
input_line_pointer	O
++	O
;	O
break	O
;	O
case	O
','	O
:	O
input_line_pointer	O
++	O
;	O
break	O
;	O
}	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	O
=	O
*	O
input_line_pointer	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
unsigned	O
int	O
next_char_of_string	O
(	O
void	O
)	O
{	O
unsigned	O
int	O
c	O
;	O
c	O
=	O
*	O
input_line_pointer	O
++	O
&	O
CHAR_MASK	O
;	O
switch	O
(	O
c	O
)	O
{	O
case	O
0	int
:	O
--	O
input_line_pointer	O
;	O
c	O
=	O
NOT_A_CHAR	O
;	O
break	O
;	O
case	O
'\"'	O
:	O
c	O
=	O
NOT_A_CHAR	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
as_warn	O
(	O
_	O
(	O
"unterminated string; newline inserted"	*(char)
)	O
)	O
;	O
bump_line_counters	O
(	O
)	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
!	O
TC_STRING_ESCAPES	O
)	O
break	O
;	O
switch	O
(	O
c	O
=	O
*	O
input_line_pointer	O
++	O
&	O
CHAR_MASK	O
)	O
{	O
case	O
'b'	O
:	O
c	O
=	O
'\b'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
c	O
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
c	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
c	O
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
c	O
=	O
'\t'	O
;	O
break	O
;	O
case	O
'v'	O
:	O
c	O
=	O
'\013'	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
case	O
'"'	O
:	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
{	O
long	O
number	O
;	O
int	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
number	O
=	O
0	int
;	O
ISDIGIT	O
(	O
c	O
)	O
&&	O
i	*(struct)
<	O
3	int
;	O
c	O
=	O
*	O
input_line_pointer	O
++	O
,	O
i	*(struct)
++	O
)	O
{	O
number	O
=	O
number	O
*	O
8	int
+	O
c	O
-	O
'0'	O
;	O
}	O
c	O
=	O
number	O
&	O
CHAR_MASK	O
;	O
}	O
--	O
input_line_pointer	O
;	O
break	O
;	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
{	O
long	O
number	O
;	O
number	O
=	O
0	int
;	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
while	O
(	O
ISXDIGIT	O
(	O
c	O
)	O
)	O
{	O
if	O
(	O
ISDIGIT	O
(	O
c	O
)	O
)	O
number	O
=	O
number	O
*	O
16	int
+	O
c	O
-	O
'0'	O
;	O
else	O
if	O
(	O
ISUPPER	O
(	O
c	O
)	O
)	O
number	O
=	O
number	O
*	O
16	int
+	O
c	O
-	O
'A'	O
+	O
10	int
;	O
else	O
number	O
=	O
number	O
*	O
16	int
+	O
c	O
-	O
'a'	O
+	O
10	int
;	O
c	O
=	O
*	O
input_line_pointer	O
++	O
;	O
}	O
c	O
=	O
number	O
&	O
CHAR_MASK	O
;	O
--	O
input_line_pointer	O
;	O
}	O
break	O
;	O
case	O
'\n'	O
:	O
as_warn	O
(	O
_	O
(	O
"unterminated string; newline inserted"	*(char)
)	O
)	O
;	O
c	O
=	O
'\n'	O
;	O
bump_line_counters	O
(	O
)	O
;	O
break	O
;	O
case	O
0	int
:	O
--	O
input_line_pointer	O
;	O
c	O
=	O
NOT_A_CHAR	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
(	O
c	O
)	O
;	O
}	O
static	O
segT	O
get_segmented_expression	O
(	O
expressionS	O
*	O
expP	O
)	O
{	O
segT	O
retval	O
;	O
retval	O
=	O
expression	O
(	O
expP	O
)	O
;	O
if	O
(	O
expP	O
->	O
X_op	O
==	O
O_illegal	O
||	O
expP	O
->	O
X_op	O
==	O
O_absent	O
||	O
expP	O
->	O
X_op	O
==	O
O_big	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"expected address expression"	*(char)
)	O
)	O
;	O
expP	O
->	O
X_op	O
=	O
O_constant	O
;	O
expP	O
->	O
X_add_number	O
=	O
0	int
;	O
retval	O
=	O
absolute_section	O
;	O
}	O
return	O
retval	O
;	O
}	O
static	O
segT	O
get_known_segmented_expression	O
(	O
expressionS	O
*	O
expP	O
)	O
{	O
segT	O
retval	O
=	O
get_segmented_expression	O
(	O
expP	O
)	O
;	O
if	O
(	O
retval	O
==	O
undefined_section	O
)	O
{	O
if	O
(	O
expP	O
->	O
X_add_symbol	O
!=	O
NULL	O
&&	O
S_GET_SEGMENT	O
(	O
expP	O
->	O
X_add_symbol	O
)	O
!=	O
expr_section	O
)	O
as_warn	O
(	O
_	O
(	O
"symbol \"%s\" undefined; zero assumed"	*(char)
)	O
,	O
S_GET_NAME	O
(	O
expP	O
->	O
X_add_symbol	O
)	O
)	O
;	O
else	O
as_warn	O
(	O
_	O
(	O
"some symbol undefined; zero assumed"	*(char)
)	O
)	O
;	O
retval	O
=	O
absolute_section	O
;	O
expP	O
->	O
X_op	O
=	O
O_constant	O
;	O
expP	O
->	O
X_add_number	O
=	O
0	int
;	O
}	O
return	O
retval	O
;	O
}	O
char	O
get_absolute_expression_and_terminator	O
(	O
long	O
*	O
val_pointer	O
)	O
{	O
*	O
val_pointer	O
=	O
(	O
long	O
)	O
get_absolute_expression	O
(	O
)	O
;	O
return	O
(	O
*	O
input_line_pointer	O
++	O
)	O
;	O
}	O
char	O
*	O
demand_copy_C_string	O
(	O
int	O
*	O
len_pointer	O
)	O
{	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
if	O
(	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
demand_copy_string	O
(	O
len_pointer	O
)	O
)	O
!=	O
0	int
)	O
{	O
int	O
len	long
;	O
for	O
(	O
len	long
=	O
*	O
len_pointer	O
;	O
len	long
>	O
0	int
;	O
len	long
--	O
)	O
{	O
if	O
(	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
0	int
)	O
{	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
=	O
0	int
;	O
len	long
=	O
1	int
;	O
*	O
len_pointer	O
=	O
0	int
;	O
as_bad	O
(	O
_	O
(	O
"this string may not contain \'\\0\'"	*(char)
)	O
)	O
;	O
}	O
}	O
}	O
return	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
}	O
char	O
*	O
demand_copy_string	O
(	O
int	O
*	O
lenP	O
)	O
{	O
unsigned	O
int	O
c	O
;	O
int	O
len	long
;	O
char	O
*	O
retval	O
;	O
len	long
=	O
0	int
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
'\"'	O
)	O
{	O
input_line_pointer	O
++	O
;	O
while	O
(	O
is_a_char	O
(	O
c	O
=	O
next_char_of_string	O
(	O
)	O
)	O
)	O
{	O
obstack_1grow	O
(	O
&	O
notes	O
,	O
c	O
)	O
;	O
len	long
++	O
;	O
}	O
obstack_1grow	O
(	O
&	O
notes	O
,	O
'\0'	O
)	O
;	O
retval	O
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
&	O
notes	O
)	O
;	O
}	O
else	O
{	O
as_bad	O
(	O
_	O
(	O
"missing string"	*(char)
)	O
)	O
;	O
retval	O
=	O
NULL	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
}	O
*	O
lenP	O
=	O
len	long
;	O
return	O
(	O
retval	O
)	O
;	O
}	O
int	O
is_it_end_of_statement	O
(	O
void	O
)	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
return	O
(	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
)	O
;	O
}	O
void	O
equals	O
(	O
char	O
*	O
sym_name	O
,	O
int	O
reassign	O
)	O
{	O
char	O
*	O
stop	O
=	O
NULL	O
;	O
char	O
stopc	O
=	O
0	int
;	O
input_line_pointer	O
++	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
'='	O
)	O
input_line_pointer	O
++	O
;	O
if	O
(	O
reassign	O
<	O
0	int
&&	O
*	O
input_line_pointer	O
==	O
'='	O
)	O
input_line_pointer	O
++	O
;	O
while	O
(	O
*	O
input_line_pointer	O
==	O
' '	O
||	O
*	O
input_line_pointer	O
==	O
'\t'	O
)	O
input_line_pointer	O
++	O
;	O
if	O
(	O
flag_mri	O
)	O
stop	O
=	O
mri_comment_field	O
(	O
&	O
stopc	O
)	O
;	O
assign_symbol	O
(	O
sym_name	O
,	O
reassign	O
>=	O
0	int
?	O
!	O
reassign	O
:	O
reassign	O
)	O
;	O
if	O
(	O
flag_mri	O
)	O
{	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
mri_comment_end	O
(	O
stop	O
,	O
stopc	O
)	O
;	O
}	O
}	O
void	O
s_incbin	O
(	O
int	O
x	O
ATTRIBUTE_UNUSED	O
)	O
{	O
FILE	struct
*	O
binfile	O
;	O
char	O
*	O
path	O
;	O
char	O
*	O
filename	*(char)
;	O
char	O
*	O
binfrag	O
;	O
long	O
skip	O
=	O
0	int
;	O
long	O
count	int
=	O
0	int
;	O
long	O
bytes	O
;	O
int	O
len	long
;	O
md_cons_align	O
(	O
1	int
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
filename	*(char)
=	O
demand_copy_string	O
(	O
&	O
len	long
)	O
;	O
if	O
(	O
filename	*(char)
==	O
NULL	O
)	O
return	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
{	O
++	O
input_line_pointer	O
;	O
skip	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
==	O
','	O
)	O
{	O
++	O
input_line_pointer	O
;	O
count	int
=	O
get_absolute_expression	O
(	O
)	O
;	O
if	O
(	O
count	int
==	O
0	int
)	O
as_warn	O
(	O
_	O
(	O
".incbin count zero, ignoring `%s'"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
binfile	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
FOPEN_RB	O
)	O
;	O
if	O
(	O
binfile	O
==	O
NULL	O
)	O
{	O
int	O
i	*(struct)
;	O
path	O
=	O
XNEWVEC	O
(	O
char	O
,	O
(	O
unsigned	O
long	O
)	O
len	long
+	O
include_dir_maxlen	O
+	O
5	int
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
include_dir_count	O
;	O
i	*(struct)
++	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
path	O
,	O
"%s/%s"	*(char)
,	O
include_dirs	O
[	O
i	*(struct)
]	O
,	O
filename	*(char)
)	O
;	O
binfile	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
path	O
,	O
FOPEN_RB	O
)	O
;	O
if	O
(	O
binfile	O
!=	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
binfile	O
==	O
NULL	O
)	O
as_bad	O
(	O
_	O
(	O
"file not found: %s"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
}	O
else	O
path	O
=	O
xstrdup	O
(	O
filename	*(char)
)	O
;	O
if	O
(	O
binfile	O
)	O
{	O
long	O
file_len	O
;	O
register_dependency	O
(	O
path	O
)	O
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
binfile	O
,	O
0	int
,	O
SEEK_END	O
)	O
!=	O
0	int
)	O
{	O
as_bad	O
(	O
_	O
(	O
"seek to end of .incbin file failed `%s'"	*(char)
)	O
,	O
path	O
)	O
;	O
goto	O
done	O
;	O
}	O
file_len	O
=	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
binfile	O
)	O
;	O
if	O
(	O
count	int
==	O
0	int
)	O
count	int
=	O
file_len	O
-	O
skip	O
;	O
if	O
(	O
skip	O
<	O
0	int
||	O
count	int
<	O
0	int
||	O
file_len	O
<	O
0	int
||	O
skip	O
+	O
count	int
>	O
file_len	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"skip (%ld) or count (%ld) invalid for file size (%ld)"	*(char)
)	O
,	O
skip	O
,	O
count	int
,	O
file_len	O
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
binfile	O
,	O
skip	O
,	O
SEEK_SET	O
)	O
!=	O
0	int
)	O
{	O
as_bad	O
(	O
_	O
(	O
"could not skip to %ld in file `%s'"	*(char)
)	O
,	O
skip	O
,	O
path	O
)	O
;	O
goto	O
done	O
;	O
}	O
binfrag	O
=	O
frag_more	O
(	O
count	int
)	O
;	O
bytes	O
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
binfrag	O
,	O
1	int
,	O
count	int
,	O
binfile	O
)	O
;	O
if	O
(	O
bytes	O
<	O
count	int
)	O
as_warn	O
(	O
_	O
(	O
"truncated file `%s', %ld of %ld bytes read"	*(char)
)	O
,	O
path	O
,	O
bytes	O
,	O
count	int
)	O
;	O
}	O
done	O
:	O
if	O
(	O
binfile	O
!=	O
NULL	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
binfile	O
)	O
;	O
if	O
(	O
path	O
)	O
free	(*(void))->(void)
(	O
path	O
)	O
;	O
}	O
void	O
s_include	O
(	O
int	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
filename	*(char)
;	O
int	O
i	*(struct)
;	O
FILE	struct
*	O
try_file	O
;	O
char	O
*	O
path	O
;	O
if	O
(	O
!	O
flag_m68k_mri	O
)	O
{	O
filename	*(char)
=	O
demand_copy_string	O
(	O
&	O
i	*(struct)
)	O
;	O
if	O
(	O
filename	*(char)
==	O
NULL	O
)	O
{	O
return	O
;	O
}	O
}	O
else	O
{	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
i	*(struct)
=	O
0	int
;	O
while	O
(	O
!	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
&&	O
*	O
input_line_pointer	O
!=	O
' '	O
&&	O
*	O
input_line_pointer	O
!=	O
'\t'	O
)	O
{	O
obstack_1grow	O
(	O
&	O
notes	O
,	O
*	O
input_line_pointer	O
)	O
;	O
++	O
input_line_pointer	O
;	O
++	O
i	*(struct)
;	O
}	O
obstack_1grow	O
(	O
&	O
notes	O
,	O
'\0'	O
)	O
;	O
filename	*(char)
=	O
(	O
char	O
*	O
)	O
obstack_finish	O
(	O
&	O
notes	O
)	O
;	O
while	O
(	O
!	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	O
]	O
)	O
++	O
input_line_pointer	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
path	O
=	O
XNEWVEC	O
(	O
char	O
,	O
(	O
unsigned	O
long	O
)	O
i	*(struct)
+	O
include_dir_maxlen	O
+	O
5	int
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
include_dir_count	O
;	O
i	*(struct)
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
path	O
,	O
include_dirs	O
[	O
i	*(struct)
]	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
path	O
,	O
"/"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
path	O
,	O
filename	*(char)
)	O
;	O
if	O
(	O
0	int
!=	O
(	O
try_file	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
path	O
,	O
FOPEN_RT	O
)	O
)	O
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
try_file	O
)	O
;	O
goto	O
gotit	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
path	O
)	O
;	O
path	O
=	O
filename	*(char)
;	O
gotit	O
:	O
register_dependency	O
(	O
path	O
)	O
;	O
input_scrub_insert_file	O
(	O
path	O
)	O
;	O
}	O
void	O
add_include_dir	O
(	O
char	O
*	O
path	O
)	O
{	O
int	O
i	*(struct)
;	O
if	O
(	O
include_dir_count	O
==	O
0	int
)	O
{	O
include_dirs	O
=	O
XNEWVEC	O
(	O
const	O
char	O
*	O
,	O
2	int
)	O
;	O
include_dirs	O
[	O
0	int
]	O
=	O
"."	*(char)
;	O
include_dir_count	O
=	O
2	int
;	O
}	O
else	O
{	O
include_dir_count	O
++	O
;	O
include_dirs	O
=	O
XRESIZEVEC	O
(	O
const	O
char	O
*	O
,	O
include_dirs	O
,	O
include_dir_count	O
)	O
;	O
}	O
include_dirs	O
[	O
include_dir_count	O
-	O
1	int
]	O
=	O
path	O
;	O
i	*(struct)
=	O
strlen	(*(char))->(long)
(	O
path	O
)	O
;	O
if	O
(	O
i	*(struct)
>	O
include_dir_maxlen	O
)	O
include_dir_maxlen	O
=	O
i	*(struct)
;	O
}	O
static	O
void	O
generate_file_debug	O
(	O
void	O
)	O
{	O
if	O
(	O
debug_type	O
==	O
DEBUG_STABS	O
)	O
stabs_generate_asm_file	O
(	O
)	O
;	O
}	O
void	O
generate_lineno_debug	O
(	O
void	O
)	O
{	O
switch	O
(	O
debug_type	O
)	O
{	O
case	O
DEBUG_UNSPECIFIED	O
:	O
case	O
DEBUG_NONE	O
:	O
case	O
DEBUG_DWARF	O
:	O
break	O
;	O
case	O
DEBUG_STABS	O
:	O
stabs_generate_asm_lineno	O
(	O
)	O
;	O
break	O
;	O
case	O
DEBUG_ECOFF	O
:	O
ecoff_generate_asm_lineno	O
(	O
)	O
;	O
break	O
;	O
case	O
DEBUG_DWARF2	O
:	O
break	O
;	O
}	O
}	O
void	O
s_func	O
(	O
int	O
end_p	O
)	O
{	O
do_s_func	O
(	O
end_p	O
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
do_s_func	O
(	O
int	O
end_p	O
,	O
const	O
char	O
*	O
default_prefix	O
)	O
{	O
static	O
char	O
*	O
current_name	O
;	O
static	O
char	O
*	O
current_label	O
;	O
if	O
(	O
end_p	O
)	O
{	O
if	O
(	O
current_name	O
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"missing .func"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
debug_type	O
==	O
DEBUG_STABS	O
)	O
stabs_generate_asm_endfunc	O
(	O
current_name	O
,	O
current_label	O
)	O
;	O
current_name	O
=	O
current_label	O
=	O
NULL	O
;	O
}	O
else	O
{	O
char	O
*	O
name	*(char)
,	O
*	O
label	O
;	O
char	O
delim1	O
,	O
delim2	O
;	O
if	O
(	O
current_name	O
!=	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
".endfunc missing for previous .func"	*(char)
)	O
)	O
;	O
ignore_rest_of_line	O
(	O
)	O
;	O
return	O
;	O
}	O
delim1	O
=	O
get_symbol_name	O
(	O
&	O
name	*(char)
)	O
;	O
name	*(char)
=	O
xstrdup	O
(	O
name	*(char)
)	O
;	O
*	O
input_line_pointer	O
=	O
delim1	O
;	O
SKIP_WHITESPACE_AFTER_NAME	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	O
!=	O
','	O
)	O
{	O
if	O
(	O
default_prefix	O
)	O
{	O
if	O
(	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
label	O
,	O
"%s%s"	*(char)
,	O
default_prefix	O
,	O
name	*(char)
)	O
==	O
-	O
1	int
)	O
as_fatal	O
(	O
"%s"	*(char)
,	O
xstrerror	O
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
char	O
leading_char	O
=	O
bfd_get_symbol_leading_char	O
(	O
stdoutput	O
)	O
;	O
if	O
(	O
leading_char	O
)	O
{	O
if	O
(	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
label	O
,	O
"%c%s"	*(char)
,	O
leading_char	O
,	O
name	*(char)
)	O
==	O
-	O
1	int
)	O
as_fatal	O
(	O
"%s"	*(char)
,	O
xstrerror	O
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
label	O
=	O
name	*(char)
;	O
}	O
}	O
else	O
{	O
++	O
input_line_pointer	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
delim2	O
=	O
get_symbol_name	O
(	O
&	O
label	O
)	O
;	O
label	O
=	O
xstrdup	O
(	O
label	O
)	O
;	O
restore_line_pointer	O
(	O
delim2	O
)	O
;	O
}	O
if	O
(	O
debug_type	O
==	O
DEBUG_STABS	O
)	O
stabs_generate_asm_func	O
(	O
name	*(char)
,	O
label	O
)	O
;	O
current_name	O
=	O
name	*(char)
;	O
current_label	O
=	O
label	O
;	O
}	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
s_bundle_align_mode	O
(	O
int	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
int	O
align	O
=	O
get_absolute_expression	O
(	O
)	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
align	O
>	O
(	O
unsigned	O
int	O
)	O
TC_ALIGN_LIMIT	O
)	O
as_fatal	O
(	O
_	O
(	O
".bundle_align_mode alignment too large (maximum %u)"	*(char)
)	O
,	O
(	O
unsigned	O
int	O
)	O
TC_ALIGN_LIMIT	O
)	O
;	O
if	O
(	O
bundle_lock_frag	O
!=	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
"cannot change .bundle_align_mode inside .bundle_lock"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
bundle_align_p2	O
=	O
align	O
;	O
}	O
void	O
s_bundle_lock	O
(	O
int	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
ATTRIBUTE_UNUSED	O
)	O
{	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
bundle_align_p2	O
==	O
0	int
)	O
{	O
as_bad	O
(	O
_	O
(	O
".bundle_lock is meaningless without .bundle_align_mode"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
bundle_lock_depth	O
==	O
0	int
)	O
{	O
bundle_lock_frchain	O
=	O
frchain_now	O
;	O
bundle_lock_frag	O
=	O
start_bundle	O
(	O
)	O
;	O
}	O
++	O
bundle_lock_depth	O
;	O
}	O
void	O
s_bundle_unlock	O
(	O
int	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
int	O
size	int
;	O
demand_empty_rest_of_line	O
(	O
)	O
;	O
if	O
(	O
bundle_lock_frag	O
==	O
NULL	O
)	O
{	O
as_bad	O
(	O
_	O
(	O
".bundle_unlock without preceding .bundle_lock"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
gas_assert	O
(	O
bundle_align_p2	O
>	O
0	int
)	O
;	O
gas_assert	O
(	O
bundle_lock_depth	O
>	O
0	int
)	O
;	O
if	O
(	O
--	O
bundle_lock_depth	O
>	O
0	int
)	O
return	O
;	O
size	int
=	O
pending_bundle_size	O
(	O
bundle_lock_frag	O
)	O
;	O
if	O
(	O
size	int
>	O
1U	int
<<	O
bundle_align_p2	O
)	O
as_bad	O
(	O
_	O
(	O
".bundle_lock sequence is %u bytes, "	*(char)
"but bundle size is only %u bytes"	*(char)
)	O
,	O
size	int
,	O
1u	int
<<	O
bundle_align_p2	O
)	O
;	O
else	O
finish_bundle	O
(	O
bundle_lock_frag	O
,	O
size	int
)	O
;	O
bundle_lock_frag	O
=	O
NULL	O
;	O
bundle_lock_frchain	O
=	O
NULL	O
;	O
}	O
void	O
s_ignore	O
(	O
int	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
ATTRIBUTE_UNUSED	O
)	O
{	O
ignore_rest_of_line	O
(	O
)	O
;	O
}	O
void	O
read_print_statistics	O
(	O
FILE	struct
*	O
file	*(void)
)	O
{	O
hash_print_statistics	O
(	O
file	*(void)
,	O
"pseudo-op table"	*(char)
,	O
po_hash	O
)	O
;	O
}	O
void	O
input_scrub_insert_line	O
(	O
const	O
char	O
*	O
line	O
)	O
{	O
sb	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
newline	O
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
line	O
)	O
;	O
sb_build	O
(	O
&	O
newline	O
,	O
len	long
)	O
;	O
sb_add_buffer	O
(	O
&	O
newline	O
,	O
line	O
,	O
len	long
)	O
;	O
input_scrub_include_sb	O
(	O
&	O
newline	O
,	O
input_line_pointer	O
,	O
0	int
)	O
;	O
sb_kill	O
(	O
&	O
newline	O
)	O
;	O
buffer_limit	O
=	O
input_scrub_next_buffer	O
(	O
&	O
input_line_pointer	O
)	O
;	O
}	O
void	O
input_scrub_insert_file	O
(	O
char	O
*	O
path	O
)	O
{	O
input_scrub_include_file	O
(	O
path	O
,	O
input_line_pointer	O
)	O
;	O
buffer_limit	O
=	O
input_scrub_next_buffer	O
(	O
&	O
input_line_pointer	O
)	O
;	O
}	O
static	O
char	O
*	O
_find_end_of_line	O
(	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
int	O
mri_string	O
,	O
int	O
insn	O
ATTRIBUTE_UNUSED	O
,	O
int	O
in_macro	O
)	O
{	O
char	O
inquote	O
=	O
'\0'	O
;	O
int	O
inescape	O
=	O
0	int
;	O
while	O
(	O
!	O
is_end_of_line	O
[	O
(	O
unsigned	O
char	O
)	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
]	O
||	O
(	O
inquote	O
&&	O
!	O
ISCNTRL	O
(	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
)	O
)	O
||	O
(	O
inquote	O
==	O
'\''	O
&&	O
flag_mri	O
)	O
||	O
(	O
in_macro	O
&&	O
inescape	O
&&	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
'@'	O
)	O
)	O
{	O
if	O
(	O
mri_string	O
&&	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
'\''	O
)	O
inquote	O
^=	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
else	O
if	O
(	O
inescape	O
)	O
inescape	O
=	O
0	int
;	O
else	O
if	O
(	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
'\\'	O
)	O
inescape	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
inquote	O
?	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
'"'	O
:	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
==	O
inquote	O
)	O
inquote	O
^=	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
++	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
}	O
if	O
(	O
inquote	O
)	O
as_warn	O
(	O
_	O
(	O
"missing closing `%c'"	*(char)
)	O
,	O
inquote	O
)	O
;	O
if	O
(	O
inescape	O
&&	O
!	O
ignore_input	O
(	O
)	O
)	O
as_warn	O
(	O
_	O
(	O
"stray `\\'"	*(char)
)	O
)	O
;	O
return	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
;	O
}	O
char	O
*	O
find_end_of_line	O
(	O
char	O
*	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
int	O
mri_string	O
)	O
{	O
return	O
_find_end_of_line	O
(	O
s	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct))))
,	O
mri_string	O
,	O
0	int
,	O
0	int
)	O
;	O
}	O
static	O
char	O
*	O
saved_ilp	O
=	O
NULL	O
;	O
static	O
char	O
*	O
saved_limit	O
;	O
void	O
temp_ilp	O
(	O
char	O
*	O
buf	*(void)
)	O
{	O
gas_assert	O
(	O
saved_ilp	O
==	O
NULL	O
)	O
;	O
gas_assert	O
(	O
buf	*(void)
!=	O
NULL	O
)	O
;	O
saved_ilp	O
=	O
input_line_pointer	O
;	O
saved_limit	O
=	O
buffer_limit	O
;	O
if	O
(	O
saved_ilp	O
==	O
NULL	O
)	O
saved_limit	O
=	O
saved_ilp	O
=	O
(	O
char	O
*	O
)	O
""	*(char)
;	O
input_line_pointer	O
=	O
buf	*(void)
;	O
buffer_limit	O
=	O
buf	*(void)
+	O
strlen	(*(char))->(long)
(	O
buf	*(void)
)	O
;	O
input_from_string	O
=	O
TRUE	int
;	O
}	O
void	O
restore_ilp	O
(	O
void	O
)	O
{	O
gas_assert	O
(	O
saved_ilp	O
!=	O
NULL	O
)	O
;	O
input_line_pointer	O
=	O
saved_ilp	O
;	O
buffer_limit	O
=	O
saved_limit	O
;	O
input_from_string	O
=	O
FALSE	O
;	O
saved_ilp	O
=	O
NULL	O
;	O
}	O
