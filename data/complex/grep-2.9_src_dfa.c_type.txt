typedef	O
int	O
charclass	array(int)
[	O
CHARCLASS_INTS	O
]	O
;	O
typedef	O
enum	O
{	O
END	int
=	O
-	O
1	int
,	O
EMPTY	int
=	O
NOTCHAR	O
,	O
BACKREF	int
,	O
BEGLINE	int
,	O
ENDLINE	int
,	O
BEGWORD	int
,	O
ENDWORD	int
,	O
LIMWORD	int
,	O
NOTLIMWORD	int
,	O
QMARK	int
,	O
STAR	int
,	O
PLUS	int
,	O
REPMN	int
,	O
CAT	int
,	O
OR	int
,	O
LPAREN	int
,	O
RPAREN	int
,	O
ANYCHAR	int
,	O
MBCSET	int
,	O
WCHAR	int
,	O
CSET	int
}	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
typedef	O
struct	O
{	O
unsigned	O
int	O
index	(*(char),int)->(*(char))
;	O
unsigned	O
int	O
constraint	int
;	O
}	O
position	struct(int,int)
;	O
typedef	O
struct	O
{	O
position	struct(int,int)
*	O
elems	*(struct(int,int))
;	O
int	O
nelem	int
;	O
}	O
position_set	struct(*(struct(int,int)),int)
;	O
typedef	O
struct	O
{	O
int	O
hash	int
;	O
position_set	struct(*(struct(int,int)),int)
elems	*(struct(int,int))
;	O
char	O
newline	int
;	O
char	O
letter	char
;	O
char	O
backref	*(int)
;	O
unsigned	O
char	O
constraint	int
;	O
int	O
first_end	int
;	O
position_set	struct(*(struct(int,int)),int)
mbps	struct(*(struct(int,int)),int)
;	O
}	O
dfa_state	struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))
;	O
struct	O
mb_char_classes	struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)
{	O
int	O
cset	int
;	O
int	O
invert	int
;	O
wchar_t	int
*	O
chars	*(int)
;	O
int	O
nchars	int
;	O
wctype_t	long
*	O
ch_classes	*(long)
;	O
int	O
nch_classes	int
;	O
wchar_t	int
*	O
range_sts	*(int)
;	O
wchar_t	int
*	O
range_ends	*(int)
;	O
int	O
nranges	int
;	O
char	O
*	O
*	O
equivs	*(*(char))
;	O
int	O
nequivs	int
;	O
char	O
*	O
*	O
coll_elems	*(*(char))
;	O
int	O
ncoll_elems	int
;	O
}	O
;	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
{	O
charclass	array(int)
*	O
charclasses	*(array(int))
;	O
int	O
cindex	int
;	O
int	O
calloc	(long,long)->(*(void))
;	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
*	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
;	O
int	O
tindex	int
;	O
int	O
talloc	int
;	O
int	O
depth	int
;	O
int	O
nleaves	int
;	O
int	O
nregexps	int
;	O
unsigned	O
int	O
mb_cur_max	int
;	O
int	O
utf8_anychar_classes	array(int)
[	O
5	int
]	O
;	O
int	O
nmultibyte_prop	int
;	O
int	O
*	O
multibyte_prop	*(int)
;	O
struct	O
mb_char_classes	struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)
*	O
mbcsets	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
;	O
int	O
nmbcsets	int
;	O
int	O
mbcsets_alloc	int
;	O
dfa_state	struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))
*	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
;	O
int	O
sindex	int
;	O
int	O
salloc	int
;	O
position_set	struct(*(struct(int,int)),int)
*	O
follows	*(struct(*(struct(int,int)),int))
;	O
int	O
searchflag	int
;	O
int	O
tralloc	int
;	O
int	O
trcount	int
;	O
int	O
*	O
*	O
trans	*(*(int))
;	O
int	O
*	O
*	O
realtrans	*(*(int))
;	O
int	O
*	O
*	O
fails	*(*(int))
;	O
int	O
*	O
success	*(int)
;	O
int	O
*	O
newlines	*(int)
;	O
struct	O
dfamust	struct(int,*(char),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
}	O
;	O
static	O
void	O
dfamust	struct(int,*(char),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
)	O
;	O
static	O
void	O
regexp	()->(void)
(	O
void	O
)	O
;	O
static	O
int	O
tstbit	(int,array(int))->(int)
(	O
unsigned	O
int	O
b	int
,	O
charclass	array(int)
const	O
c	array(int)
)	O
{	O
return	O
c	array(int)
[	O
b	int
/	O
INTBITS	O
]	O
&	O
1	int
<<	O
b	int
%	O
INTBITS	O
;	O
}	O
static	O
void	O
setbit	(int,array(int))->(void)
(	O
unsigned	O
int	O
b	int
,	O
charclass	array(int)
c	array(int)
)	O
{	O
c	array(int)
[	O
b	int
/	O
INTBITS	O
]	O
|=	O
1	int
<<	O
b	int
%	O
INTBITS	O
;	O
}	O
static	O
void	O
clrbit	(int,array(int))->(void)
(	O
unsigned	O
int	O
b	int
,	O
charclass	array(int)
c	array(int)
)	O
{	O
c	array(int)
[	O
b	int
/	O
INTBITS	O
]	O
&=	O
~	O
(	O
1	int
<<	O
b	int
%	O
INTBITS	O
)	O
;	O
}	O
static	O
void	O
copyset	(array(int),array(int))->(void)
(	O
charclass	array(int)
const	O
src	array(int)
,	O
charclass	array(int)
dst	array(int)
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dst	array(int)
,	O
src	array(int)
,	O
sizeof	O
(	O
charclass	array(int)
)	O
)	O
;	O
}	O
static	O
void	O
zeroset	(array(int))->(void)
(	O
charclass	array(int)
s	long
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
s	long
,	O
0	int
,	O
sizeof	O
(	O
charclass	array(int)
)	O
)	O
;	O
}	O
static	O
void	O
notset	(array(int))->(void)
(	O
charclass	array(int)
s	long
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CHARCLASS_INTS	O
;	O
++	O
i	int
)	O
s	long
[	O
i	int
]	O
=	O
~	O
s	long
[	O
i	int
]	O
;	O
}	O
static	O
int	O
equal	(array(int),array(int))->(int)
(	O
charclass	array(int)
const	O
s1	*(char)
,	O
charclass	array(int)
const	O
s2	*(char)
)	O
{	O
return	O
memcmp	(*(void),*(void),long)->(int)
(	O
s1	*(char)
,	O
s2	*(char)
,	O
sizeof	O
(	O
charclass	array(int)
)	O
)	O
==	O
0	int
;	O
}	O
static	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
;	O
static	O
int	O
charclass_index	(array(int))->(int)
(	O
charclass	array(int)
const	O
s	long
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
cindex	int
;	O
++	O
i	int
)	O
if	O
(	O
equal	(array(int),array(int))->(int)
(	O
s	long
,	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
charclasses	*(array(int))
[	O
i	int
]	O
)	O
)	O
return	O
i	int
;	O
REALLOC_IF_NECESSARY	O
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
charclasses	*(array(int))
,	O
charclass	array(int)
,	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
calloc	(long,long)->(*(void))
,	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
cindex	int
)	O
;	O
++	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
cindex	int
;	O
copyset	(array(int),array(int))->(void)
(	O
s	long
,	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
charclasses	*(array(int))
[	O
i	int
]	O
)	O
;	O
return	O
i	int
;	O
}	O
static	O
reg_syntax_t	long
syntax_bits	long
,	O
syntax_bits_set	long
;	O
static	O
int	O
case_fold	int
;	O
static	O
unsigned	O
char	O
eolbyte	char
;	O
void	O
dfasyntax	(long,int,char)->(void)
(	O
reg_syntax_t	long
bits	long
,	O
int	O
fold	int
,	O
unsigned	O
char	O
eol	char
)	O
{	O
syntax_bits_set	long
=	O
1	int
;	O
syntax_bits	long
=	O
bits	long
;	O
case_fold	int
=	O
fold	int
;	O
eolbyte	char
=	O
eol	char
;	O
}	O
static	O
bool	bool
setbit_wc	(int,array(int))->(bool)
(	O
wint_t	int
wc	int
,	O
charclass	array(int)
c	array(int)
)	O
{	O
int	O
b	int
=	O
wctob	(int)->(int)
(	O
wc	int
)	O
;	O
if	O
(	O
b	int
==	O
EOF	O
)	O
return	O
false	int
;	O
setbit	(int,array(int))->(void)
(	O
b	int
,	O
c	array(int)
)	O
;	O
return	O
true	int
;	O
}	O
static	O
void	O
setbit_c	(int,array(int))->(void)
(	O
int	O
b	int
,	O
charclass	array(int)
c	array(int)
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
btowc	(int)->(int)
(	O
b	int
)	O
==	O
WEOF	O
)	O
return	O
;	O
setbit	(int,array(int))->(void)
(	O
b	int
,	O
c	array(int)
)	O
;	O
}	O
static	O
void	O
setbit_case_fold_c	(int,array(int))->(void)
(	O
int	O
b	int
,	O
charclass	array(int)
c	array(int)
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
wint_t	int
wc	int
=	O
btowc	(int)->(int)
(	O
b	int
)	O
;	O
if	O
(	O
wc	int
==	O
WEOF	O
)	O
return	O
;	O
setbit	(int,array(int))->(void)
(	O
b	int
,	O
c	array(int)
)	O
;	O
if	O
(	O
case_fold	int
&&	O
iswalpha	(int)->(int)
(	O
wc	int
)	O
)	O
setbit_wc	(int,array(int))->(bool)
(	O
iswupper	(int)->(int)
(	O
wc	int
)	O
?	O
towlower	(int)->(int)
(	O
wc	int
)	O
:	O
towupper	(int)->(int)
(	O
wc	int
)	O
,	O
c	array(int)
)	O
;	O
}	O
else	O
{	O
setbit	(int,array(int))->(void)
(	O
b	int
,	O
c	array(int)
)	O
;	O
if	O
(	O
case_fold	int
&&	O
isalpha	(int)->(int)
(	O
b	int
)	O
)	O
setbit_c	(int,array(int))->(void)
(	O
isupper	(int)->(int)
(	O
b	int
)	O
?	O
tolower	(int)->(int)
(	O
b	int
)	O
:	O
toupper	(int)->(int)
(	O
b	int
)	O
,	O
c	array(int)
)	O
;	O
}	O
}	O
static	O
inline	O
int	O
using_utf8	()->(int)
(	O
void	O
)	O
{	O
static	O
int	O
utf8	int
=	O
-	O
1	int
;	O
if	O
(	O
utf8	int
==	O
-	O
1	int
)	O
{	O
utf8	int
=	O
(	O
STREQ	O
(	O
nl_langinfo	(int)->(*(char))
(	O
CODESET	int
)	O
,	O
"UTF-8"	*(char)
)	O
)	O
;	O
}	O
return	O
utf8	int
;	O
}	O
static	O
char	O
const	O
*	O
lexptr	*(char)
;	O
static	O
int	O
lexleft	int
;	O
static	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
static	O
int	O
laststart	int
;	O
static	O
int	O
parens	int
;	O
static	O
int	O
minrep	int
,	O
maxrep	int
;	O
static	O
int	O
hard_LC_COLLATE	int
;	O
static	O
int	O
cur_mb_len	int
=	O
1	int
;	O
static	O
mbstate_t	struct(int,union(int,array(char)))
mbs	struct(int,union(int,array(char)))
;	O
static	O
wchar_t	int
wctok	int
;	O
static	O
unsigned	O
char	O
*	O
mblen_buf	*(char)
;	O
static	O
wchar_t	int
*	O
inputwcs	*(int)
;	O
static	O
unsigned	O
char	O
const	O
*	O
buf_begin	*(char)
;	O
static	O
unsigned	O
char	O
const	O
*	O
buf_end	*(char)
;	O
typedef	O
int	O
predicate	(int)->(int)
(	O
int	O
)	O
;	O
struct	O
dfa_ctype	struct(*(char),*((int)->(int)),bool)
{	O
const	O
char	O
*	O
name	*(char)
;	O
predicate	(int)->(int)
*	O
func	*((int)->(int))
;	O
bool	bool
single_byte_only	bool
;	O
}	O
;	O
static	O
const	O
struct	O
dfa_ctype	struct(*(char),*((int)->(int)),bool)
prednames	array(struct(*(char),*((int)->(int)),bool))
[	O
]	O
=	O
{	O
{	O
"alpha"	*(char)
,	O
isalpha	(int)->(int)
,	O
false	int
}	O
,	O
{	O
"upper"	*(char)
,	O
isupper	(int)->(int)
,	O
false	int
}	O
,	O
{	O
"lower"	*(char)
,	O
islower	(int)->(int)
,	O
false	int
}	O
,	O
{	O
"digit"	*(char)
,	O
isdigit	(int)->(int)
,	O
true	int
}	O
,	O
{	O
"xdigit"	*(char)
,	O
isxdigit	(int)->(int)
,	O
true	int
}	O
,	O
{	O
"space"	*(char)
,	O
isspace	(int)->(int)
,	O
false	int
}	O
,	O
{	O
"punct"	*(char)
,	O
ispunct	(int)->(int)
,	O
false	int
}	O
,	O
{	O
"alnum"	*(char)
,	O
isalnum	(int)->(int)
,	O
false	int
}	O
,	O
{	O
"print"	*(char)
,	O
isprint	(int)->(int)
,	O
false	int
}	O
,	O
{	O
"graph"	*(char)
,	O
isgraph	(int)->(int)
,	O
false	int
}	O
,	O
{	O
"cntrl"	*(char)
,	O
iscntrl	(int)->(int)
,	O
false	int
}	O
,	O
{	O
"blank"	*(char)
,	O
isblank	(int)->(int)
,	O
false	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
false	int
}	O
}	O
;	O
static	O
const	O
struct	O
dfa_ctype	struct(*(char),*((int)->(int)),bool)
*	O
find_pred	(*(char))->(*(struct(*(char),*((int)->(int)),bool)))
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
prednames	array(struct(*(char),*((int)->(int)),bool))
[	O
i	int
]	O
.	O
name	*(char)
;	O
++	O
i	int
)	O
if	O
(	O
STREQ	O
(	O
str	*(char)
,	O
prednames	array(struct(*(char),*((int)->(int)),bool))
[	O
i	int
]	O
.	O
name	*(char)
)	O
)	O
break	O
;	O
return	O
&	O
prednames	array(struct(*(char),*((int)->(int)),bool))
[	O
i	int
]	O
;	O
}	O
static	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
parse_bracket_exp	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
void	O
)	O
{	O
int	O
invert	int
;	O
int	O
c	array(int)
,	O
c1	int
,	O
c2	int
;	O
charclass	array(int)
ccl	array(int)
;	O
int	O
colon_warning_state	int
;	O
wint_t	int
wc	int
,	O
wc1	int
,	O
wc2	int
;	O
struct	O
mb_char_classes	struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)
*	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
;	O
int	O
chars_al	int
,	O
range_sts_al	int
,	O
range_ends_al	int
,	O
ch_classes_al	int
,	O
equivs_al	int
,	O
coll_elems_al	int
;	O
chars_al	int
=	O
1	int
;	O
range_sts_al	int
=	O
range_ends_al	int
=	O
0	int
;	O
ch_classes_al	int
=	O
equivs_al	int
=	O
coll_elems_al	int
=	O
0	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
REALLOC_IF_NECESSARY	O
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
mbcsets	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
,	O
struct	O
mb_char_classes	struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)
,	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
mbcsets_alloc	int
,	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
nmbcsets	int
+	O
1	int
)	O
;	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
=	O
&	O
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
mbcsets	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
[	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
nmbcsets	int
++	O
]	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
,	O
0	int
,	O
sizeof	O
*	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
)	O
;	O
}	O
else	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
=	O
NULL	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
ccl	array(int)
,	O
0	int
,	O
sizeof	O
ccl	array(int)
)	O
;	O
FETCH_WC	O
(	O
c	array(int)
,	O
wc	int
,	O
_	O
(	O
"unbalanced ["	*(char)
)	O
)	O
;	O
if	O
(	O
c	array(int)
==	O
'^'	O
)	O
{	O
FETCH_WC	O
(	O
c	array(int)
,	O
wc	int
,	O
_	O
(	O
"unbalanced ["	*(char)
)	O
)	O
;	O
invert	int
=	O
1	int
;	O
}	O
else	O
invert	int
=	O
0	int
;	O
colon_warning_state	int
=	O
(	O
c	array(int)
==	O
':'	O
)	O
;	O
do	O
{	O
c1	int
=	O
EOF	O
;	O
colon_warning_state	int
&=	O
~	O
2	int
;	O
if	O
(	O
c	array(int)
==	O
'['	O
&&	O
(	O
syntax_bits	long
&	O
RE_CHAR_CLASSES	O
)	O
)	O
{	O
char	O
str	*(char)
[	O
BRACKET_BUFFER_SIZE	int
]	O
;	O
FETCH_WC	O
(	O
c1	int
,	O
wc1	int
,	O
_	O
(	O
"unbalanced ["	*(char)
)	O
)	O
;	O
if	O
(	O
c1	int
==	O
':'	O
||	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
(	O
c1	int
==	O
'.'	O
||	O
c1	int
==	O
'='	O
)	O
)	O
)	O
{	O
size_t	long
len	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
FETCH_WC	O
(	O
c	array(int)
,	O
wc	int
,	O
_	O
(	O
"unbalanced ["	*(char)
)	O
)	O
;	O
if	O
(	O
(	O
c	array(int)
==	O
c1	int
&&	O
*	O
lexptr	*(char)
==	O
']'	O
)	O
||	O
lexleft	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
len	long
<	O
BRACKET_BUFFER_SIZE	int
)	O
str	*(char)
[	O
len	long
++	O
]	O
=	O
c	array(int)
;	O
else	O
str	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
str	*(char)
[	O
len	long
]	O
=	O
'\0'	O
;	O
FETCH_WC	O
(	O
c	array(int)
,	O
wc	int
,	O
_	O
(	O
"unbalanced ["	*(char)
)	O
)	O
;	O
if	O
(	O
c1	int
==	O
':'	O
)	O
{	O
char	O
const	O
*	O
class	*(char)
=	O
(	O
case_fold	int
&&	O
(	O
STREQ	O
(	O
str	*(char)
,	O
"upper"	*(char)
)	O
||	O
STREQ	O
(	O
str	*(char)
,	O
"lower"	*(char)
)	O
)	O
?	O
"alpha"	*(char)
:	O
str	*(char)
)	O
;	O
const	O
struct	O
dfa_ctype	struct(*(char),*((int)->(int)),bool)
*	O
pred	*(struct(*(char),*((int)->(int)),bool))
=	O
find_pred	(*(char))->(*(struct(*(char),*((int)->(int)),bool)))
(	O
class	*(char)
)	O
;	O
if	O
(	O
!	O
pred	*(struct(*(char),*((int)->(int)),bool))
)	O
dfaerror	(*(char))->(void)
(	O
_	O
(	O
"invalid character class"	*(char)
)	O
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
!	O
pred	*(struct(*(char),*((int)->(int)),bool))
->	O
single_byte_only	bool
)	O
{	O
wctype_t	long
wt	long
=	O
wctype	(*(char))->(long)
(	O
class	*(char)
)	O
;	O
if	O
(	O
ch_classes_al	int
==	O
0	int
)	O
MALLOC	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
ch_classes	*(long)
,	O
wctype_t	long
,	O
++	O
ch_classes_al	int
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
ch_classes	*(long)
,	O
wctype_t	long
,	O
ch_classes_al	int
,	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nch_classes	int
+	O
1	int
)	O
;	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
ch_classes	*(long)
[	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nch_classes	int
++	O
]	O
=	O
wt	long
;	O
}	O
for	O
(	O
c2	int
=	O
0	int
;	O
c2	int
<	O
NOTCHAR	O
;	O
++	O
c2	int
)	O
if	O
(	O
pred	*(struct(*(char),*((int)->(int)),bool))
->	O
func	*((int)->(int))
(	O
c2	int
)	O
)	O
setbit_case_fold_c	(int,array(int))->(void)
(	O
c2	int
,	O
ccl	array(int)
)	O
;	O
}	O
else	O
if	O
(	O
c1	int
==	O
'='	O
||	O
c1	int
==	O
'.'	O
)	O
{	O
char	O
*	O
elem	*(char)
;	O
MALLOC	O
(	O
elem	*(char)
,	O
char	O
,	O
len	long
+	O
1	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
elem	*(char)
,	O
str	*(char)
,	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
c1	int
==	O
'='	O
)	O
{	O
if	O
(	O
equivs_al	int
==	O
0	int
)	O
MALLOC	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
equivs	*(*(char))
,	O
char	O
*	O
,	O
++	O
equivs_al	int
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
equivs	*(*(char))
,	O
char	O
*	O
,	O
equivs_al	int
,	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nequivs	int
+	O
1	int
)	O
;	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
equivs	*(*(char))
[	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nequivs	int
++	O
]	O
=	O
elem	*(char)
;	O
}	O
if	O
(	O
c1	int
==	O
'.'	O
)	O
{	O
if	O
(	O
coll_elems_al	int
==	O
0	int
)	O
MALLOC	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
coll_elems	*(*(char))
,	O
char	O
*	O
,	O
++	O
coll_elems_al	int
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
coll_elems	*(*(char))
,	O
char	O
*	O
,	O
coll_elems_al	int
,	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
ncoll_elems	int
+	O
1	int
)	O
;	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
coll_elems	*(*(char))
[	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
ncoll_elems	int
++	O
]	O
=	O
elem	*(char)
;	O
}	O
}	O
colon_warning_state	int
|=	O
8	int
;	O
FETCH_WC	O
(	O
c1	int
,	O
wc1	int
,	O
_	O
(	O
"unbalanced ["	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
c	array(int)
==	O
'\\'	O
&&	O
(	O
syntax_bits	long
&	O
RE_BACKSLASH_ESCAPE_IN_LISTS	O
)	O
)	O
FETCH_WC	O
(	O
c	array(int)
,	O
wc	int
,	O
_	O
(	O
"unbalanced ["	*(char)
)	O
)	O
;	O
if	O
(	O
c1	int
==	O
EOF	O
)	O
FETCH_WC	O
(	O
c1	int
,	O
wc1	int
,	O
_	O
(	O
"unbalanced ["	*(char)
)	O
)	O
;	O
if	O
(	O
c1	int
==	O
'-'	O
)	O
{	O
FETCH_WC	O
(	O
c2	int
,	O
wc2	int
,	O
_	O
(	O
"unbalanced ["	*(char)
)	O
)	O
;	O
if	O
(	O
c2	int
==	O
']'	O
)	O
{	O
lexptr	*(char)
-=	O
cur_mb_len	int
;	O
lexleft	int
+=	O
cur_mb_len	int
;	O
}	O
}	O
if	O
(	O
c1	int
==	O
'-'	O
&&	O
c2	int
!=	O
']'	O
)	O
{	O
if	O
(	O
c2	int
==	O
'\\'	O
&&	O
(	O
syntax_bits	long
&	O
RE_BACKSLASH_ESCAPE_IN_LISTS	O
)	O
)	O
FETCH_WC	O
(	O
c2	int
,	O
wc2	int
,	O
_	O
(	O
"unbalanced ["	*(char)
)	O
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
if	O
(	O
range_sts_al	int
==	O
0	int
)	O
{	O
MALLOC	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
range_sts	*(int)
,	O
wchar_t	int
,	O
++	O
range_sts_al	int
)	O
;	O
MALLOC	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
range_ends	*(int)
,	O
wchar_t	int
,	O
++	O
range_ends_al	int
)	O
;	O
}	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
range_sts	*(int)
,	O
wchar_t	int
,	O
range_sts_al	int
,	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nranges	int
+	O
1	int
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
range_ends	*(int)
,	O
wchar_t	int
,	O
range_ends_al	int
,	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nranges	int
+	O
1	int
)	O
;	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
range_sts	*(int)
[	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nranges	int
]	O
=	O
case_fold	int
?	O
towlower	(int)->(int)
(	O
wc	int
)	O
:	O
(	O
wchar_t	int
)	O
wc	int
;	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
range_ends	*(int)
[	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nranges	int
++	O
]	O
=	O
case_fold	int
?	O
towlower	(int)->(int)
(	O
wc2	int
)	O
:	O
(	O
wchar_t	int
)	O
wc2	int
;	O
}	O
else	O
{	O
c1	int
=	O
c	array(int)
;	O
if	O
(	O
case_fold	int
)	O
{	O
c1	int
=	O
tolower	(int)->(int)
(	O
c1	int
)	O
;	O
c2	int
=	O
tolower	(int)->(int)
(	O
c2	int
)	O
;	O
}	O
if	O
(	O
!	O
hard_LC_COLLATE	int
)	O
for	O
(	O
c	array(int)
=	O
c1	int
;	O
c	array(int)
<=	O
c2	int
;	O
c	array(int)
++	O
)	O
setbit_case_fold_c	(int,array(int))->(void)
(	O
c	array(int)
,	O
ccl	array(int)
)	O
;	O
else	O
{	O
regex_t	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
re	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
char	O
pattern	array(char)
[	O
6	int
]	O
=	O
{	O
'['	O
,	O
c1	int
,	O
'-'	O
,	O
c2	int
,	O
']'	O
,	O
0	int
}	O
;	O
char	O
subject	array(char)
[	O
2	int
]	O
=	O
{	O
0	int
,	O
0	int
}	O
;	O
regcomp	(*(struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int)->(int)
(	O
&	O
re	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
pattern	array(char)
,	O
REG_NOSUB	O
)	O
;	O
for	O
(	O
c	array(int)
=	O
0	int
;	O
c	array(int)
<	O
NOTCHAR	O
;	O
++	O
c	array(int)
)	O
{	O
subject	array(char)
[	O
0	int
]	O
=	O
c	array(int)
;	O
if	O
(	O
!	O
(	O
case_fold	int
&&	O
isupper	(int)->(int)
(	O
c	array(int)
)	O
)	O
&&	O
regexec	(*(struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),long,array(struct(int,int)),int)->(int)
(	O
&	O
re	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
subject	array(char)
,	O
0	int
,	O
NULL	O
,	O
0	int
)	O
!=	O
REG_NOMATCH	O
)	O
setbit_case_fold_c	(int,array(int))->(void)
(	O
c	array(int)
,	O
ccl	array(int)
)	O
;	O
}	O
regfree	(*(struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(void)
(	O
&	O
re	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
;	O
}	O
}	O
colon_warning_state	int
|=	O
8	int
;	O
FETCH_WC	O
(	O
c1	int
,	O
wc1	int
,	O
_	O
(	O
"unbalanced ["	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
colon_warning_state	int
|=	O
(	O
c	array(int)
==	O
':'	O
)	O
?	O
2	int
:	O
4	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
if	O
(	O
case_fold	int
&&	O
iswalpha	(int)->(int)
(	O
wc	int
)	O
)	O
{	O
wc	int
=	O
towlower	(int)->(int)
(	O
wc	int
)	O
;	O
if	O
(	O
!	O
setbit_wc	(int,array(int))->(bool)
(	O
wc	int
,	O
ccl	array(int)
)	O
)	O
{	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
chars	*(int)
,	O
wchar_t	int
,	O
chars_al	int
,	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nchars	int
+	O
1	int
)	O
;	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
chars	*(int)
[	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nchars	int
++	O
]	O
=	O
wc	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
!	O
setbit_wc	(int,array(int))->(bool)
(	O
wc	int
,	O
ccl	array(int)
)	O
)	O
{	O
REALLOC_IF_NECESSARY	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
chars	*(int)
,	O
wchar_t	int
,	O
chars_al	int
,	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nchars	int
+	O
1	int
)	O
;	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
chars	*(int)
[	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nchars	int
++	O
]	O
=	O
wc	int
;	O
}	O
}	O
else	O
setbit_case_fold_c	(int,array(int))->(void)
(	O
c	array(int)
,	O
ccl	array(int)
)	O
;	O
}	O
while	O
(	O
(	O
wc	int
=	O
wc1	int
,	O
(	O
c	array(int)
=	O
c1	int
)	O
!=	O
']'	O
)	O
)	O
;	O
if	O
(	O
colon_warning_state	int
==	O
7	int
)	O
dfawarn	(*(char))->(void)
(	O
_	O
(	O
"character class syntax is [[:space:]], not [:space:]"	*(char)
)	O
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
static	O
charclass	array(int)
zeroclass	array(int)
;	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
invert	int
=	O
invert	int
;	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
cset	int
=	O
equal	(array(int),array(int))->(int)
(	O
ccl	array(int)
,	O
zeroclass	array(int)
)	O
?	O
-	O
1	int
:	O
charclass_index	(array(int))->(int)
(	O
ccl	array(int)
)	O
;	O
return	O
MBCSET	int
;	O
}	O
if	O
(	O
invert	int
)	O
{	O
assert	O
(	O
MB_CUR_MAX	O
==	O
1	int
)	O
;	O
notset	(array(int))->(void)
(	O
ccl	array(int)
)	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_HAT_LISTS_NOT_NEWLINE	O
)	O
clrbit	(int,array(int))->(void)
(	O
eolbyte	char
,	O
ccl	array(int)
)	O
;	O
}	O
return	O
CSET	int
+	O
charclass_index	(array(int))->(int)
(	O
ccl	array(int)
)	O
;	O
}	O
static	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
lex	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
void	O
)	O
{	O
unsigned	O
int	O
c	array(int)
,	O
c2	int
;	O
int	O
backslash	int
=	O
0	int
;	O
charclass	array(int)
ccl	array(int)
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
FETCH_WC	O
(	O
c	array(int)
,	O
wctok	int
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
int	O
)	O
c	array(int)
==	O
EOF	O
)	O
goto	O
normal_char	O
;	O
}	O
else	O
FETCH	O
(	O
c	array(int)
,	O
NULL	O
)	O
;	O
switch	O
(	O
c	array(int)
)	O
{	O
case	O
'\\'	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
lexleft	int
==	O
0	int
)	O
dfaerror	(*(char))->(void)
(	O
_	O
(	O
"unfinished \\ escape"	*(char)
)	O
)	O
;	O
backslash	int
=	O
1	int
;	O
break	O
;	O
case	O
'^'	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_ANCHORS	O
||	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
END	int
||	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
LPAREN	int
||	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
OR	int
)	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
BEGLINE	int
;	O
goto	O
normal_char	O
;	O
case	O
'$'	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_ANCHORS	O
||	O
lexleft	int
==	O
0	int
||	O
(	O
syntax_bits	long
&	O
RE_NO_BK_PARENS	O
?	O
lexleft	int
>	O
0	int
&&	O
*	O
lexptr	*(char)
==	O
')'	O
:	O
lexleft	int
>	O
1	int
&&	O
lexptr	*(char)
[	O
0	int
]	O
==	O
'\\'	O
&&	O
lexptr	*(char)
[	O
1	int
]	O
==	O
')'	O
)	O
||	O
(	O
syntax_bits	long
&	O
RE_NO_BK_VBAR	O
?	O
lexleft	int
>	O
0	int
&&	O
*	O
lexptr	*(char)
==	O
'|'	O
:	O
lexleft	int
>	O
1	int
&&	O
lexptr	*(char)
[	O
0	int
]	O
==	O
'\\'	O
&&	O
lexptr	*(char)
[	O
1	int
]	O
==	O
'|'	O
)	O
||	O
(	O
(	O
syntax_bits	long
&	O
RE_NEWLINE_ALT	O
)	O
&&	O
lexleft	int
>	O
0	int
&&	O
*	O
lexptr	*(char)
==	O
'\n'	O
)	O
)	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
ENDLINE	int
;	O
goto	O
normal_char	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_BK_REFS	O
)	O
)	O
{	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
BACKREF	int
;	O
}	O
goto	O
normal_char	O
;	O
case	O
'`'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
BEGLINE	int
;	O
goto	O
normal_char	O
;	O
case	O
'\''	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
ENDLINE	int
;	O
goto	O
normal_char	O
;	O
case	O
'<'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
BEGWORD	int
;	O
goto	O
normal_char	O
;	O
case	O
'>'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
ENDWORD	int
;	O
goto	O
normal_char	O
;	O
case	O
'b'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
LIMWORD	int
;	O
goto	O
normal_char	O
;	O
case	O
'B'	O
:	O
if	O
(	O
backslash	int
&&	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
NOTLIMWORD	int
;	O
goto	O
normal_char	O
;	O
case	O
'?'	O
:	O
if	O
(	O
syntax_bits	long
&	O
RE_LIMITED_OPS	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_BK_PLUS_QM	O
)	O
!=	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_OPS	O
)	O
&&	O
laststart	int
)	O
goto	O
normal_char	O
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
QMARK	int
;	O
case	O
'*'	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_OPS	O
)	O
&&	O
laststart	int
)	O
goto	O
normal_char	O
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
STAR	int
;	O
case	O
'+'	O
:	O
if	O
(	O
syntax_bits	long
&	O
RE_LIMITED_OPS	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_BK_PLUS_QM	O
)	O
!=	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_OPS	O
)	O
&&	O
laststart	int
)	O
goto	O
normal_char	O
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
PLUS	int
;	O
case	O
'{'	O
:	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_INTERVALS	O
)	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_NO_BK_BRACES	O
)	O
==	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_CONTEXT_INDEP_OPS	O
)	O
&&	O
laststart	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_NO_BK_BRACES	O
)	O
{	O
int	O
lo	int
=	O
-	O
1	int
,	O
hi	int
=	O
-	O
1	int
;	O
char	O
const	O
*	O
p	*(void)
=	O
lexptr	*(char)
;	O
char	O
const	O
*	O
lim	*(char)
=	O
p	*(void)
+	O
lexleft	int
;	O
for	O
(	O
;	O
p	*(void)
!=	O
lim	*(char)
&&	O
ISASCIIDIGIT	O
(	O
*	O
p	*(void)
)	O
;	O
p	*(void)
++	O
)	O
lo	int
=	O
(	O
lo	int
<	O
0	int
?	O
0	int
:	O
lo	int
*	O
10	int
)	O
+	O
*	O
p	*(void)
-	O
'0'	O
;	O
if	O
(	O
p	*(void)
!=	O
lim	*(char)
&&	O
*	O
p	*(void)
==	O
','	O
)	O
while	O
(	O
++	O
p	*(void)
!=	O
lim	*(char)
&&	O
ISASCIIDIGIT	O
(	O
*	O
p	*(void)
)	O
)	O
hi	int
=	O
(	O
hi	int
<	O
0	int
?	O
0	int
:	O
hi	int
*	O
10	int
)	O
+	O
*	O
p	*(void)
-	O
'0'	O
;	O
else	O
hi	int
=	O
lo	int
;	O
if	O
(	O
p	*(void)
==	O
lim	*(char)
||	O
*	O
p	*(void)
!=	O
'}'	O
||	O
lo	int
<	O
0	int
||	O
RE_DUP_MAX	O
<	O
hi	int
||	O
(	O
0	int
<=	O
hi	int
&&	O
hi	int
<	O
lo	int
)	O
)	O
goto	O
normal_char	O
;	O
}	O
minrep	int
=	O
0	int
;	O
FETCH	O
(	O
c	array(int)
,	O
_	O
(	O
"unfinished repeat count"	*(char)
)	O
)	O
;	O
if	O
(	O
ISASCIIDIGIT	O
(	O
c	array(int)
)	O
)	O
{	O
minrep	int
=	O
c	array(int)
-	O
'0'	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
FETCH	O
(	O
c	array(int)
,	O
_	O
(	O
"unfinished repeat count"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
ISASCIIDIGIT	O
(	O
c	array(int)
)	O
)	O
break	O
;	O
minrep	int
=	O
10	int
*	O
minrep	int
+	O
c	array(int)
-	O
'0'	O
;	O
}	O
}	O
else	O
dfaerror	(*(char))->(void)
(	O
_	O
(	O
"malformed repeat count"	*(char)
)	O
)	O
;	O
if	O
(	O
c	array(int)
==	O
','	O
)	O
{	O
FETCH	O
(	O
c	array(int)
,	O
_	O
(	O
"unfinished repeat count"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
ISASCIIDIGIT	O
(	O
c	array(int)
)	O
)	O
maxrep	int
=	O
-	O
1	int
;	O
else	O
{	O
maxrep	int
=	O
c	array(int)
-	O
'0'	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
FETCH	O
(	O
c	array(int)
,	O
_	O
(	O
"unfinished repeat count"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
ISASCIIDIGIT	O
(	O
c	array(int)
)	O
)	O
break	O
;	O
maxrep	int
=	O
10	int
*	O
maxrep	int
+	O
c	array(int)
-	O
'0'	O
;	O
}	O
if	O
(	O
0	int
<=	O
maxrep	int
&&	O
maxrep	int
<	O
minrep	int
)	O
dfaerror	(*(char))->(void)
(	O
_	O
(	O
"malformed repeat count"	*(char)
)	O
)	O
;	O
}	O
}	O
else	O
maxrep	int
=	O
minrep	int
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_NO_BK_BRACES	O
)	O
)	O
{	O
if	O
(	O
c	array(int)
!=	O
'\\'	O
)	O
dfaerror	(*(char))->(void)
(	O
_	O
(	O
"malformed repeat count"	*(char)
)	O
)	O
;	O
FETCH	O
(	O
c	array(int)
,	O
_	O
(	O
"unfinished repeat count"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
c	array(int)
!=	O
'}'	O
)	O
dfaerror	(*(char))->(void)
(	O
_	O
(	O
"malformed repeat count"	*(char)
)	O
)	O
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
REPMN	int
;	O
case	O
'|'	O
:	O
if	O
(	O
syntax_bits	long
&	O
RE_LIMITED_OPS	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_NO_BK_VBAR	O
)	O
==	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
laststart	int
=	O
1	int
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
OR	int
;	O
case	O
'\n'	O
:	O
if	O
(	O
syntax_bits	long
&	O
RE_LIMITED_OPS	O
||	O
backslash	int
||	O
!	O
(	O
syntax_bits	long
&	O
RE_NEWLINE_ALT	O
)	O
)	O
goto	O
normal_char	O
;	O
laststart	int
=	O
1	int
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
OR	int
;	O
case	O
'('	O
:	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_NO_BK_PARENS	O
)	O
==	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
++	O
parens	int
;	O
laststart	int
=	O
1	int
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
LPAREN	int
;	O
case	O
')'	O
:	O
if	O
(	O
backslash	int
!=	O
(	O
(	O
syntax_bits	long
&	O
RE_NO_BK_PARENS	O
)	O
==	O
0	int
)	O
)	O
goto	O
normal_char	O
;	O
if	O
(	O
parens	int
==	O
0	int
&&	O
syntax_bits	long
&	O
RE_UNMATCHED_RIGHT_PAREN_ORD	O
)	O
goto	O
normal_char	O
;	O
--	O
parens	int
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
RPAREN	int
;	O
case	O
'.'	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
ANYCHAR	int
;	O
}	O
zeroset	(array(int))->(void)
(	O
ccl	array(int)
)	O
;	O
notset	(array(int))->(void)
(	O
ccl	array(int)
)	O
;	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_DOT_NEWLINE	O
)	O
)	O
clrbit	(int,array(int))->(void)
(	O
eolbyte	char
,	O
ccl	array(int)
)	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_DOT_NOT_NULL	O
)	O
clrbit	(int,array(int))->(void)
(	O
'\0'	O
,	O
ccl	array(int)
)	O
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
CSET	int
+	O
charclass_index	(array(int))->(int)
(	O
ccl	array(int)
)	O
;	O
case	O
's'	O
:	O
case	O
'S'	O
:	O
if	O
(	O
!	O
backslash	int
||	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
goto	O
normal_char	O
;	O
zeroset	(array(int))->(void)
(	O
ccl	array(int)
)	O
;	O
for	O
(	O
c2	int
=	O
0	int
;	O
c2	int
<	O
NOTCHAR	O
;	O
++	O
c2	int
)	O
if	O
(	O
isspace	(int)->(int)
(	O
c2	int
)	O
)	O
setbit	(int,array(int))->(void)
(	O
c2	int
,	O
ccl	array(int)
)	O
;	O
if	O
(	O
c	array(int)
==	O
'S'	O
)	O
notset	(array(int))->(void)
(	O
ccl	array(int)
)	O
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
CSET	int
+	O
charclass_index	(array(int))->(int)
(	O
ccl	array(int)
)	O
;	O
case	O
'w'	O
:	O
case	O
'W'	O
:	O
if	O
(	O
!	O
backslash	int
||	O
(	O
syntax_bits	long
&	O
RE_NO_GNU_OPS	O
)	O
)	O
goto	O
normal_char	O
;	O
zeroset	(array(int))->(void)
(	O
ccl	array(int)
)	O
;	O
for	O
(	O
c2	int
=	O
0	int
;	O
c2	int
<	O
NOTCHAR	O
;	O
++	O
c2	int
)	O
if	O
(	O
IS_WORD_CONSTITUENT	O
(	O
c2	int
)	O
)	O
setbit	(int,array(int))->(void)
(	O
c2	int
,	O
ccl	array(int)
)	O
;	O
if	O
(	O
c	array(int)
==	O
'W'	O
)	O
notset	(array(int))->(void)
(	O
ccl	array(int)
)	O
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
CSET	int
+	O
charclass_index	(array(int))->(int)
(	O
ccl	array(int)
)	O
;	O
case	O
'['	O
:	O
if	O
(	O
backslash	int
)	O
goto	O
normal_char	O
;	O
laststart	int
=	O
0	int
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
parse_bracket_exp	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
;	O
default	O
:	O
normal_char	O
:	O
laststart	int
=	O
0	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
WCHAR	int
;	O
if	O
(	O
case_fold	int
&&	O
isalpha	(int)->(int)
(	O
c	array(int)
)	O
)	O
{	O
zeroset	(array(int))->(void)
(	O
ccl	array(int)
)	O
;	O
setbit_case_fold_c	(int,array(int))->(void)
(	O
c	array(int)
,	O
ccl	array(int)
)	O
;	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
CSET	int
+	O
charclass_index	(array(int))->(int)
(	O
ccl	array(int)
)	O
;	O
}	O
return	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
c	array(int)
;	O
}	O
}	O
abort	()->(void)
(	O
)	O
;	O
return	O
END	int
;	O
}	O
static	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
static	O
int	O
depth	int
;	O
static	O
void	O
addtok_mb	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(void)
(	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
int	O
mbprop	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
REALLOC_IF_NECESSARY	O
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
multibyte_prop	*(int)
,	O
int	O
,	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
nmultibyte_prop	int
,	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tindex	int
)	O
;	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
multibyte_prop	*(int)
[	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tindex	int
]	O
=	O
mbprop	int
;	O
}	O
REALLOC_IF_NECESSARY	O
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
,	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
talloc	int
,	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tindex	int
)	O
;	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tindex	int
++	O
]	O
=	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
switch	O
(	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
QMARK	int
:	O
case	O
STAR	int
:	O
case	O
PLUS	int
:	O
break	O
;	O
case	O
CAT	int
:	O
case	O
OR	int
:	O
--	O
depth	int
;	O
break	O
;	O
default	O
:	O
++	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
nleaves	int
;	O
case	O
EMPTY	int
:	O
++	O
depth	int
;	O
break	O
;	O
}	O
if	O
(	O
depth	int
>	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
depth	int
)	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
depth	int
=	O
depth	int
;	O
}	O
static	O
void	O
addtok_wc	(int)->(void)
(	O
wint_t	int
wc	int
)	O
;	O
static	O
void	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
MBCSET	int
)	O
{	O
bool	bool
need_or	bool
=	O
false	int
;	O
struct	O
mb_char_classes	struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)
*	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
=	O
&	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
mbcsets	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
[	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
nmbcsets	int
-	O
1	int
]	O
;	O
if	O
(	O
!	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
invert	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nchars	int
;	O
i	int
++	O
)	O
{	O
addtok_wc	(int)->(void)
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
chars	*(int)
[	O
i	int
]	O
)	O
;	O
if	O
(	O
need_or	bool
)	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
OR	int
)	O
;	O
need_or	bool
=	O
true	int
;	O
}	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nchars	int
=	O
0	int
;	O
}	O
if	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
invert	int
||	O
(	O
!	O
using_utf8	()->(int)
(	O
)	O
&&	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
cset	int
!=	O
-	O
1	int
)	O
||	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nchars	int
!=	O
0	int
||	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nch_classes	int
!=	O
0	int
||	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nranges	int
!=	O
0	int
||	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nequivs	int
!=	O
0	int
||	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
ncoll_elems	int
!=	O
0	int
)	O
{	O
addtok_mb	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(void)
(	O
MBCSET	int
,	O
(	O
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
nmbcsets	int
-	O
1	int
)	O
<<	O
2	int
)	O
+	O
3	int
)	O
;	O
if	O
(	O
need_or	bool
)	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
OR	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
cset	int
!=	O
-	O
1	int
)	O
{	O
assert	O
(	O
using_utf8	()->(int)
(	O
)	O
)	O
;	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
CSET	int
+	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
cset	int
)	O
;	O
if	O
(	O
need_or	bool
)	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
OR	int
)	O
;	O
}	O
}	O
}	O
else	O
addtok_mb	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(void)
(	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
3	int
)	O
;	O
}	O
static	O
void	O
addtok_wc	(int)->(void)
(	O
wint_t	int
wc	int
)	O
{	O
unsigned	O
char	O
buf	array(char)
[	O
MB_LEN_MAX	int
]	O
;	O
mbstate_t	struct(int,union(int,array(char)))
s	long
;	O
int	O
i	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
s	long
,	O
0	int
,	O
sizeof	O
s	long
)	O
;	O
cur_mb_len	int
=	O
wcrtomb	(*(char),int,*(struct(int,union(int,array(char)))))->(long)
(	O
(	O
char	O
*	O
)	O
buf	array(char)
,	O
wc	int
,	O
&	O
s	long
)	O
;	O
if	O
(	O
cur_mb_len	int
<=	O
0	int
)	O
buf	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
addtok_mb	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(void)
(	O
buf	array(char)
[	O
0	int
]	O
,	O
cur_mb_len	int
==	O
1	int
?	O
3	int
:	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
cur_mb_len	int
;	O
i	int
++	O
)	O
{	O
addtok_mb	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(void)
(	O
buf	array(char)
[	O
i	int
]	O
,	O
i	int
==	O
cur_mb_len	int
-	O
1	int
?	O
2	int
:	O
0	int
)	O
;	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
CAT	int
)	O
;	O
}	O
}	O
static	O
void	O
add_utf8_anychar	()->(void)
(	O
void	O
)	O
{	O
static	O
const	O
charclass	array(int)
utf8_classes	array(array(int))
[	O
5	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
~	O
0	int
,	O
~	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
~	O
0	int
,	O
~	O
0	int
,	O
~	O
0	int
,	O
~	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xfffffffcU	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xffff	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xff0000	int
}	O
}	O
;	O
const	O
unsigned	O
int	O
n	long
=	O
sizeof	O
(	O
utf8_classes	array(array(int))
)	O
/	O
sizeof	O
(	O
utf8_classes	array(array(int))
[	O
0	int
]	O
)	O
;	O
unsigned	O
int	O
i	int
;	O
if	O
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
utf8_anychar_classes	array(int)
[	O
0	int
]	O
==	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	long
;	O
i	int
++	O
)	O
{	O
charclass	array(int)
c	array(int)
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
c	array(int)
,	O
utf8_classes	array(array(int))
[	O
i	int
]	O
,	O
sizeof	O
c	array(int)
)	O
;	O
if	O
(	O
i	int
==	O
1	int
)	O
{	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_DOT_NEWLINE	O
)	O
)	O
clrbit	(int,array(int))->(void)
(	O
eolbyte	char
,	O
c	array(int)
)	O
;	O
if	O
(	O
syntax_bits	long
&	O
RE_DOT_NOT_NULL	O
)	O
clrbit	(int,array(int))->(void)
(	O
'\0'	O
,	O
c	array(int)
)	O
;	O
}	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
utf8_anychar_classes	array(int)
[	O
i	int
]	O
=	O
CSET	int
+	O
charclass_index	(array(int))->(int)
(	O
c	array(int)
)	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
n	long
;	O
i	int
++	O
)	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
utf8_anychar_classes	array(int)
[	O
i	int
]	O
)	O
;	O
while	O
(	O
--	O
i	int
>	O
1	int
)	O
{	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
utf8_anychar_classes	array(int)
[	O
0	int
]	O
)	O
;	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
CAT	int
)	O
;	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
OR	int
)	O
;	O
}	O
}	O
static	O
void	O
atom	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
WCHAR	int
)	O
{	O
addtok_wc	(int)->(void)
(	O
case_fold	int
?	O
towlower	(int)->(int)
(	O
wctok	int
)	O
:	O
wctok	int
)	O
;	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
lex	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ANYCHAR	int
&&	O
using_utf8	()->(int)
(	O
)	O
)	O
{	O
add_utf8_anychar	()->(void)
(	O
)	O
;	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
lex	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
>=	O
0	int
&&	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
<	O
NOTCHAR	O
)	O
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
>=	O
CSET	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
BACKREF	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
BEGLINE	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ENDLINE	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
BEGWORD	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ANYCHAR	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
MBCSET	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ENDWORD	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
LIMWORD	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
NOTLIMWORD	int
)	O
{	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
lex	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
LPAREN	int
)	O
{	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
lex	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
;	O
regexp	()->(void)
(	O
)	O
;	O
if	O
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
RPAREN	int
)	O
dfaerror	(*(char))->(void)
(	O
_	O
(	O
"unbalanced ("	*(char)
)	O
)	O
;	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
lex	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
;	O
}	O
else	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
EMPTY	int
)	O
;	O
}	O
static	O
int	O
nsubtoks	(int)->(int)
(	O
int	O
tindex	int
)	O
{	O
int	O
ntoks1	int
;	O
switch	O
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
tindex	int
-	O
1	int
]	O
)	O
{	O
default	O
:	O
return	O
1	int
;	O
case	O
QMARK	int
:	O
case	O
STAR	int
:	O
case	O
PLUS	int
:	O
return	O
1	int
+	O
nsubtoks	(int)->(int)
(	O
tindex	int
-	O
1	int
)	O
;	O
case	O
CAT	int
:	O
case	O
OR	int
:	O
ntoks1	int
=	O
nsubtoks	(int)->(int)
(	O
tindex	int
-	O
1	int
)	O
;	O
return	O
1	int
+	O
ntoks1	int
+	O
nsubtoks	(int)->(int)
(	O
tindex	int
-	O
1	int
-	O
ntoks1	int
)	O
;	O
}	O
}	O
static	O
void	O
copytoks	(int,int)->(void)
(	O
int	O
tindex	int
,	O
int	O
ntokens	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ntokens	int
;	O
++	O
i	int
)	O
{	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
tindex	int
+	O
i	int
]	O
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
tindex	int
+	O
i	int
]	O
==	O
MBCSET	int
)	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
multibyte_prop	*(int)
[	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tindex	int
-	O
1	int
]	O
=	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
multibyte_prop	*(int)
[	O
tindex	int
+	O
i	int
]	O
;	O
}	O
}	O
static	O
void	O
closure	()->(void)
(	O
void	O
)	O
{	O
int	O
tindex	int
,	O
ntokens	int
,	O
i	int
;	O
atom	()->(void)
(	O
)	O
;	O
while	O
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
QMARK	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
STAR	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
PLUS	int
||	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
REPMN	int
)	O
if	O
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
REPMN	int
&&	O
(	O
minrep	int
||	O
maxrep	int
)	O
)	O
{	O
ntokens	int
=	O
nsubtoks	(int)->(int)
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tindex	int
)	O
;	O
tindex	int
=	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tindex	int
-	O
ntokens	int
;	O
if	O
(	O
maxrep	int
<	O
0	int
)	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
PLUS	int
)	O
;	O
if	O
(	O
minrep	int
==	O
0	int
)	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
QMARK	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
minrep	int
;	O
++	O
i	int
)	O
{	O
copytoks	(int,int)->(void)
(	O
tindex	int
,	O
ntokens	int
)	O
;	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
CAT	int
)	O
;	O
}	O
for	O
(	O
;	O
i	int
<	O
maxrep	int
;	O
++	O
i	int
)	O
{	O
copytoks	(int,int)->(void)
(	O
tindex	int
,	O
ntokens	int
)	O
;	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
QMARK	int
)	O
;	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
CAT	int
)	O
;	O
}	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
lex	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
REPMN	int
)	O
{	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tindex	int
-=	O
nsubtoks	(int)->(int)
(	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
->	O
tindex	int
)	O
;	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
lex	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
;	O
closure	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
lex	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
;	O
}	O
}	O
static	O
void	O
branch	()->(void)
(	O
void	O
)	O
{	O
closure	()->(void)
(	O
)	O
;	O
while	O
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
RPAREN	int
&&	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
OR	int
&&	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
>=	O
0	int
)	O
{	O
closure	()->(void)
(	O
)	O
;	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
CAT	int
)	O
;	O
}	O
}	O
static	O
void	O
regexp	()->(void)
(	O
void	O
)	O
{	O
branch	()->(void)
(	O
)	O
;	O
while	O
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
OR	int
)	O
{	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
lex	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
;	O
branch	()->(void)
(	O
)	O
;	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
OR	int
)	O
;	O
}	O
}	O
void	O
dfaparse	(*(char),long,*(struct))->(void)
(	O
char	O
const	O
*	O
s	long
,	O
size_t	long
len	long
,	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
)	O
{	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
=	O
d	*(struct)
;	O
lexptr	*(char)
=	O
s	long
;	O
lexleft	int
=	O
len	long
;	O
lasttok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
END	int
;	O
laststart	int
=	O
1	int
;	O
parens	int
=	O
0	int
;	O
hard_LC_COLLATE	int
=	O
hard_locale	(int)->(bool)
(	O
LC_COLLATE	O
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
cur_mb_len	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
mbs	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
mbs	struct(int,union(int,array(char)))
)	O
;	O
}	O
if	O
(	O
!	O
syntax_bits_set	long
)	O
dfaerror	(*(char))->(void)
(	O
_	O
(	O
"no syntax specified"	*(char)
)	O
)	O
;	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
lex	()->(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
(	O
)	O
;	O
depth	int
=	O
d	*(struct)
->	O
depth	int
;	O
regexp	()->(void)
(	O
)	O
;	O
if	O
(	O
tok	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
!=	O
END	int
)	O
dfaerror	(*(char))->(void)
(	O
_	O
(	O
"unbalanced )"	*(char)
)	O
)	O
;	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
END	int
-	O
d	*(struct)
->	O
nregexps	int
)	O
;	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
CAT	int
)	O
;	O
if	O
(	O
d	*(struct)
->	O
nregexps	int
)	O
addtok	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))->(void)
(	O
OR	int
)	O
;	O
++	O
d	*(struct)
->	O
nregexps	int
;	O
}	O
static	O
void	O
copy	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
position_set	struct(*(struct(int,int)),int)
const	O
*	O
src	array(int)
,	O
position_set	struct(*(struct(int,int)),int)
*	O
dst	array(int)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
src	array(int)
->	O
nelem	int
;	O
++	O
i	int
)	O
dst	array(int)
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
=	O
src	array(int)
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
;	O
dst	array(int)
->	O
nelem	int
=	O
src	array(int)
->	O
nelem	int
;	O
}	O
static	O
void	O
insert	(struct(int,int),*(struct(*(struct(int,int)),int)))->(void)
(	O
position	struct(int,int)
p	*(void)
,	O
position_set	struct(*(struct(int,int)),int)
*	O
s	long
)	O
{	O
int	O
count	*(int)
=	O
s	long
->	O
nelem	int
;	O
int	O
lo	int
=	O
0	int
,	O
hi	int
=	O
count	*(int)
;	O
while	O
(	O
lo	int
<	O
hi	int
)	O
{	O
int	O
mid	int
=	O
(	O
(	O
unsigned	O
)	O
lo	int
+	O
(	O
unsigned	O
)	O
hi	int
)	O
>>	O
1	int
;	O
if	O
(	O
s	long
->	O
elems	*(struct(int,int))
[	O
mid	int
]	O
.	O
index	(*(char),int)->(*(char))
<	O
p	*(void)
.	O
index	(*(char),int)->(*(char))
)	O
lo	int
=	O
mid	int
+	O
1	int
;	O
else	O
hi	int
=	O
mid	int
;	O
}	O
if	O
(	O
lo	int
<	O
count	*(int)
&&	O
p	*(void)
.	O
index	(*(char),int)->(*(char))
==	O
s	long
->	O
elems	*(struct(int,int))
[	O
lo	int
]	O
.	O
index	(*(char),int)->(*(char))
)	O
s	long
->	O
elems	*(struct(int,int))
[	O
lo	int
]	O
.	O
constraint	int
|=	O
p	*(void)
.	O
constraint	int
;	O
else	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
count	*(int)
;	O
i	int
>	O
lo	int
;	O
i	int
--	O
)	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
=	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
-	O
1	int
]	O
;	O
s	long
->	O
elems	*(struct(int,int))
[	O
lo	int
]	O
=	O
p	*(void)
;	O
++	O
s	long
->	O
nelem	int
;	O
}	O
}	O
static	O
void	O
merge	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
position_set	struct(*(struct(int,int)),int)
const	O
*	O
s1	*(char)
,	O
position_set	struct(*(struct(int,int)),int)
const	O
*	O
s2	*(char)
,	O
position_set	struct(*(struct(int,int)),int)
*	O
m	*(struct(*(struct(int,int)),int))
)	O
{	O
int	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
;	O
m	*(struct(*(struct(int,int)),int))
->	O
nelem	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
s1	*(char)
->	O
nelem	int
&&	O
j	int
<	O
s2	*(char)
->	O
nelem	int
)	O
if	O
(	O
s1	*(char)
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
>	O
s2	*(char)
->	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
)	O
m	*(struct(*(struct(int,int)),int))
->	O
elems	*(struct(int,int))
[	O
m	*(struct(*(struct(int,int)),int))
->	O
nelem	int
++	O
]	O
=	O
s1	*(char)
->	O
elems	*(struct(int,int))
[	O
i	int
++	O
]	O
;	O
else	O
if	O
(	O
s1	*(char)
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
<	O
s2	*(char)
->	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
)	O
m	*(struct(*(struct(int,int)),int))
->	O
elems	*(struct(int,int))
[	O
m	*(struct(*(struct(int,int)),int))
->	O
nelem	int
++	O
]	O
=	O
s2	*(char)
->	O
elems	*(struct(int,int))
[	O
j	int
++	O
]	O
;	O
else	O
{	O
m	*(struct(*(struct(int,int)),int))
->	O
elems	*(struct(int,int))
[	O
m	*(struct(*(struct(int,int)),int))
->	O
nelem	int
]	O
=	O
s1	*(char)
->	O
elems	*(struct(int,int))
[	O
i	int
++	O
]	O
;	O
m	*(struct(*(struct(int,int)),int))
->	O
elems	*(struct(int,int))
[	O
m	*(struct(*(struct(int,int)),int))
->	O
nelem	int
++	O
]	O
.	O
constraint	int
|=	O
s2	*(char)
->	O
elems	*(struct(int,int))
[	O
j	int
++	O
]	O
.	O
constraint	int
;	O
}	O
while	O
(	O
i	int
<	O
s1	*(char)
->	O
nelem	int
)	O
m	*(struct(*(struct(int,int)),int))
->	O
elems	*(struct(int,int))
[	O
m	*(struct(*(struct(int,int)),int))
->	O
nelem	int
++	O
]	O
=	O
s1	*(char)
->	O
elems	*(struct(int,int))
[	O
i	int
++	O
]	O
;	O
while	O
(	O
j	int
<	O
s2	*(char)
->	O
nelem	int
)	O
m	*(struct(*(struct(int,int)),int))
->	O
elems	*(struct(int,int))
[	O
m	*(struct(*(struct(int,int)),int))
->	O
nelem	int
++	O
]	O
=	O
s2	*(char)
->	O
elems	*(struct(int,int))
[	O
j	int
++	O
]	O
;	O
}	O
static	O
void	O
delete	(struct(int,int),*(struct(*(struct(int,int)),int)))->(void)
(	O
position	struct(int,int)
p	*(void)
,	O
position_set	struct(*(struct(int,int)),int)
*	O
s	long
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
s	long
->	O
nelem	int
;	O
++	O
i	int
)	O
if	O
(	O
p	*(void)
.	O
index	(*(char),int)->(*(char))
==	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
)	O
break	O
;	O
if	O
(	O
i	int
<	O
s	long
->	O
nelem	int
)	O
for	O
(	O
--	O
s	long
->	O
nelem	int
;	O
i	int
<	O
s	long
->	O
nelem	int
;	O
++	O
i	int
)	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
=	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
+	O
1	int
]	O
;	O
}	O
static	O
int	O
state_index	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),*(struct(*(struct(int,int)),int)),int,int)->(int)
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
position_set	struct(*(struct(int,int)),int)
const	O
*	O
s	long
,	O
int	O
newline	int
,	O
int	O
letter	char
)	O
{	O
int	O
hash	int
=	O
0	int
;	O
int	O
constraint	int
;	O
int	O
i	int
,	O
j	int
;	O
newline	int
=	O
newline	int
?	O
1	int
:	O
0	int
;	O
letter	char
=	O
letter	char
?	O
1	int
:	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
s	long
->	O
nelem	int
;	O
++	O
i	int
)	O
hash	int
^=	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
+	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
constraint	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
sindex	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
hash	int
!=	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
hash	int
||	O
s	long
->	O
nelem	int
!=	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
.	O
nelem	int
||	O
newline	int
!=	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
newline	int
||	O
letter	char
!=	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
letter	char
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
s	long
->	O
nelem	int
;	O
++	O
j	int
)	O
if	O
(	O
s	long
->	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
constraint	int
!=	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
.	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
constraint	int
||	O
s	long
->	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
!=	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
.	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
)	O
break	O
;	O
if	O
(	O
j	int
==	O
s	long
->	O
nelem	int
)	O
return	O
i	int
;	O
}	O
REALLOC_IF_NECESSARY	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
,	O
dfa_state	struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))
,	O
d	*(struct)
->	O
salloc	int
,	O
d	*(struct)
->	O
sindex	int
)	O
;	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
hash	int
=	O
hash	int
;	O
MALLOC	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
s	long
->	O
nelem	int
)	O
;	O
copy	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
s	long
,	O
&	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
)	O
;	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
newline	int
=	O
newline	int
;	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
letter	char
=	O
letter	char
;	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
backref	*(int)
=	O
0	int
;	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
constraint	int
=	O
0	int
;	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
first_end	int
=	O
0	int
;	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
nelem	int
=	O
0	int
;	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
=	O
NULL	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
s	long
->	O
nelem	int
;	O
++	O
j	int
)	O
if	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
s	long
->	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
<	O
0	int
)	O
{	O
constraint	int
=	O
s	long
->	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
constraint	int
;	O
if	O
(	O
SUCCEEDS_IN_CONTEXT	O
(	O
constraint	int
,	O
newline	int
,	O
0	int
,	O
letter	char
,	O
0	int
)	O
||	O
SUCCEEDS_IN_CONTEXT	O
(	O
constraint	int
,	O
newline	int
,	O
0	int
,	O
letter	char
,	O
1	int
)	O
||	O
SUCCEEDS_IN_CONTEXT	O
(	O
constraint	int
,	O
newline	int
,	O
1	int
,	O
letter	char
,	O
0	int
)	O
||	O
SUCCEEDS_IN_CONTEXT	O
(	O
constraint	int
,	O
newline	int
,	O
1	int
,	O
letter	char
,	O
1	int
)	O
)	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
constraint	int
|=	O
constraint	int
;	O
if	O
(	O
!	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
first_end	int
)	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
first_end	int
=	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
s	long
->	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
;	O
}	O
else	O
if	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
s	long
->	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
==	O
BACKREF	int
)	O
{	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
constraint	int
=	O
NO_CONSTRAINT	int
;	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
backref	*(int)
=	O
1	int
;	O
}	O
++	O
d	*(struct)
->	O
sindex	int
;	O
return	O
i	int
;	O
}	O
static	O
void	O
epsclosure	(*(struct(*(struct(int,int)),int)),*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
position_set	struct(*(struct(int,int)),int)
*	O
s	long
,	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
const	O
*	O
d	*(struct)
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
*	O
visited	*(char)
;	O
position	struct(int,int)
p	*(void)
,	O
old	struct(int,int)
;	O
CALLOC	O
(	O
visited	*(char)
,	O
char	O
,	O
d	*(struct)
->	O
tindex	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
s	long
->	O
nelem	int
;	O
++	O
i	int
)	O
if	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
>=	O
NOTCHAR	O
&&	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
!=	O
BACKREF	int
&&	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
!=	O
ANYCHAR	int
&&	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
!=	O
MBCSET	int
&&	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
<	O
CSET	int
)	O
{	O
old	struct(int,int)
=	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
;	O
p	*(void)
.	O
constraint	int
=	O
old	struct(int,int)
.	O
constraint	int
;	O
delete	(struct(int,int),*(struct(*(struct(int,int)),int)))->(void)
(	O
s	long
->	O
elems	*(struct(int,int))
[	O
i	int
]	O
,	O
s	long
)	O
;	O
if	O
(	O
visited	*(char)
[	O
old	struct(int,int)
.	O
index	(*(char),int)->(*(char))
]	O
)	O
{	O
--	O
i	int
;	O
continue	O
;	O
}	O
visited	*(char)
[	O
old	struct(int,int)
.	O
index	(*(char),int)->(*(char))
]	O
=	O
1	int
;	O
switch	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
old	struct(int,int)
.	O
index	(*(char),int)->(*(char))
]	O
)	O
{	O
case	O
BEGLINE	int
:	O
p	*(void)
.	O
constraint	int
&=	O
BEGLINE_CONSTRAINT	int
;	O
break	O
;	O
case	O
ENDLINE	int
:	O
p	*(void)
.	O
constraint	int
&=	O
ENDLINE_CONSTRAINT	int
;	O
break	O
;	O
case	O
BEGWORD	int
:	O
p	*(void)
.	O
constraint	int
&=	O
BEGWORD_CONSTRAINT	int
;	O
break	O
;	O
case	O
ENDWORD	int
:	O
p	*(void)
.	O
constraint	int
&=	O
ENDWORD_CONSTRAINT	int
;	O
break	O
;	O
case	O
LIMWORD	int
:	O
p	*(void)
.	O
constraint	int
&=	O
LIMWORD_CONSTRAINT	int
;	O
break	O
;	O
case	O
NOTLIMWORD	int
:	O
p	*(void)
.	O
constraint	int
&=	O
NOTLIMWORD_CONSTRAINT	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
old	struct(int,int)
.	O
index	(*(char),int)->(*(char))
]	O
.	O
nelem	int
;	O
++	O
j	int
)	O
{	O
p	*(void)
.	O
index	(*(char),int)->(*(char))
=	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
old	struct(int,int)
.	O
index	(*(char),int)->(*(char))
]	O
.	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
;	O
insert	(struct(int,int),*(struct(*(struct(int,int)),int)))->(void)
(	O
p	*(void)
,	O
s	long
)	O
;	O
}	O
i	int
=	O
-	O
1	int
;	O
}	O
free	(*(void))->(void)
(	O
visited	*(char)
)	O
;	O
}	O
void	O
dfaanalyze	(*(struct),int)->(void)
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
int	O
searchflag	int
)	O
{	O
int	O
*	O
nullable	*(int)
;	O
int	O
*	O
nfirstpos	*(int)
;	O
position	struct(int,int)
*	O
firstpos	*(struct(int,int))
;	O
int	O
*	O
nlastpos	*(int)
;	O
position	struct(int,int)
*	O
lastpos	*(struct(int,int))
;	O
int	O
*	O
nalloc	*(int)
;	O
position_set	struct(*(struct(int,int)),int)
tmp	struct(*(struct(int,int)),int)
;	O
position_set	struct(*(struct(int,int)),int)
merged	struct(*(struct(int,int)),int)
;	O
int	O
wants_newline	int
;	O
int	O
*	O
o_nullable	*(int)
;	O
int	O
*	O
o_nfirst	*(int)
,	O
*	O
o_nlast	*(int)
;	O
position	struct(int,int)
*	O
o_firstpos	*(struct(int,int))
,	O
*	O
o_lastpos	*(struct(int,int))
;	O
int	O
i	int
,	O
j	int
;	O
position	struct(int,int)
*	O
pos	*(struct(int,int))
;	O
d	*(struct)
->	O
searchflag	int
=	O
searchflag	int
;	O
MALLOC	O
(	O
nullable	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
depth	int
)	O
;	O
o_nullable	*(int)
=	O
nullable	*(int)
;	O
MALLOC	O
(	O
nfirstpos	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
depth	int
)	O
;	O
o_nfirst	*(int)
=	O
nfirstpos	*(int)
;	O
MALLOC	O
(	O
firstpos	*(struct(int,int))
,	O
position	struct(int,int)
,	O
d	*(struct)
->	O
nleaves	int
)	O
;	O
o_firstpos	*(struct(int,int))
=	O
firstpos	*(struct(int,int))
,	O
firstpos	*(struct(int,int))
+=	O
d	*(struct)
->	O
nleaves	int
;	O
MALLOC	O
(	O
nlastpos	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
depth	int
)	O
;	O
o_nlast	*(int)
=	O
nlastpos	*(int)
;	O
MALLOC	O
(	O
lastpos	*(struct(int,int))
,	O
position	struct(int,int)
,	O
d	*(struct)
->	O
nleaves	int
)	O
;	O
o_lastpos	*(struct(int,int))
=	O
lastpos	*(struct(int,int))
,	O
lastpos	*(struct(int,int))
+=	O
d	*(struct)
->	O
nleaves	int
;	O
CALLOC	O
(	O
nalloc	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
tindex	int
)	O
;	O
MALLOC	O
(	O
merged	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
2	int
*	O
d	*(struct)
->	O
nleaves	int
)	O
;	O
CALLOC	O
(	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
,	O
position_set	struct(*(struct(int,int)),int)
,	O
d	*(struct)
->	O
tindex	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
tindex	int
;	O
++	O
i	int
)	O
switch	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
)	O
{	O
case	O
EMPTY	int
:	O
*	O
nullable	*(int)
++	O
=	O
1	int
;	O
*	O
nfirstpos	*(int)
++	O
=	O
*	O
nlastpos	*(int)
++	O
=	O
0	int
;	O
break	O
;	O
case	O
STAR	int
:	O
case	O
PLUS	int
:	O
tmp	struct(*(struct(int,int)),int)
.	O
nelem	int
=	O
nfirstpos	*(int)
[	O
-	O
1	int
]	O
;	O
tmp	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
=	O
firstpos	*(struct(int,int))
;	O
pos	*(struct(int,int))
=	O
lastpos	*(struct(int,int))
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nlastpos	*(int)
[	O
-	O
1	int
]	O
;	O
++	O
j	int
)	O
{	O
merge	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
&	O
tmp	struct(*(struct(int,int)),int)
,	O
&	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
pos	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
,	O
&	O
merged	struct(*(struct(int,int)),int)
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
pos	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
nalloc	*(int)
[	O
pos	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
,	O
merged	struct(*(struct(int,int)),int)
.	O
nelem	int
-	O
1	int
)	O
;	O
copy	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
&	O
merged	struct(*(struct(int,int)),int)
,	O
&	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
pos	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
)	O
;	O
}	O
case	O
QMARK	int
:	O
if	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
!=	O
PLUS	int
)	O
nullable	*(int)
[	O
-	O
1	int
]	O
=	O
1	int
;	O
break	O
;	O
case	O
CAT	int
:	O
tmp	struct(*(struct(int,int)),int)
.	O
nelem	int
=	O
nfirstpos	*(int)
[	O
-	O
1	int
]	O
;	O
tmp	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
=	O
firstpos	*(struct(int,int))
;	O
pos	*(struct(int,int))
=	O
lastpos	*(struct(int,int))
+	O
nlastpos	*(int)
[	O
-	O
1	int
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
nlastpos	*(int)
[	O
-	O
2	int
]	O
;	O
++	O
j	int
)	O
{	O
merge	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
&	O
tmp	struct(*(struct(int,int)),int)
,	O
&	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
pos	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
,	O
&	O
merged	struct(*(struct(int,int)),int)
)	O
;	O
REALLOC_IF_NECESSARY	O
(	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
pos	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
nalloc	*(int)
[	O
pos	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
,	O
merged	struct(*(struct(int,int)),int)
.	O
nelem	int
-	O
1	int
)	O
;	O
copy	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
&	O
merged	struct(*(struct(int,int)),int)
,	O
&	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
pos	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
)	O
;	O
}	O
if	O
(	O
nullable	*(int)
[	O
-	O
2	int
]	O
)	O
nfirstpos	*(int)
[	O
-	O
2	int
]	O
+=	O
nfirstpos	*(int)
[	O
-	O
1	int
]	O
;	O
else	O
firstpos	*(struct(int,int))
+=	O
nfirstpos	*(int)
[	O
-	O
1	int
]	O
;	O
--	O
nfirstpos	*(int)
;	O
if	O
(	O
nullable	*(int)
[	O
-	O
1	int
]	O
)	O
nlastpos	*(int)
[	O
-	O
2	int
]	O
+=	O
nlastpos	*(int)
[	O
-	O
1	int
]	O
;	O
else	O
{	O
pos	*(struct(int,int))
=	O
lastpos	*(struct(int,int))
+	O
nlastpos	*(int)
[	O
-	O
2	int
]	O
;	O
for	O
(	O
j	int
=	O
nlastpos	*(int)
[	O
-	O
1	int
]	O
-	O
1	int
;	O
j	int
>=	O
0	int
;	O
--	O
j	int
)	O
pos	*(struct(int,int))
[	O
j	int
]	O
=	O
lastpos	*(struct(int,int))
[	O
j	int
]	O
;	O
lastpos	*(struct(int,int))
+=	O
nlastpos	*(int)
[	O
-	O
2	int
]	O
;	O
nlastpos	*(int)
[	O
-	O
2	int
]	O
=	O
nlastpos	*(int)
[	O
-	O
1	int
]	O
;	O
}	O
--	O
nlastpos	*(int)
;	O
nullable	*(int)
[	O
-	O
2	int
]	O
=	O
nullable	*(int)
[	O
-	O
1	int
]	O
&&	O
nullable	*(int)
[	O
-	O
2	int
]	O
;	O
--	O
nullable	*(int)
;	O
break	O
;	O
case	O
OR	int
:	O
nfirstpos	*(int)
[	O
-	O
2	int
]	O
+=	O
nfirstpos	*(int)
[	O
-	O
1	int
]	O
;	O
--	O
nfirstpos	*(int)
;	O
nlastpos	*(int)
[	O
-	O
2	int
]	O
+=	O
nlastpos	*(int)
[	O
-	O
1	int
]	O
;	O
--	O
nlastpos	*(int)
;	O
nullable	*(int)
[	O
-	O
2	int
]	O
=	O
nullable	*(int)
[	O
-	O
1	int
]	O
||	O
nullable	*(int)
[	O
-	O
2	int
]	O
;	O
--	O
nullable	*(int)
;	O
break	O
;	O
default	O
:	O
*	O
nullable	*(int)
++	O
=	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
==	O
BACKREF	int
;	O
*	O
nfirstpos	*(int)
++	O
=	O
*	O
nlastpos	*(int)
++	O
=	O
1	int
;	O
--	O
firstpos	*(struct(int,int))
,	O
--	O
lastpos	*(struct(int,int))
;	O
firstpos	*(struct(int,int))
->	O
index	(*(char),int)->(*(char))
=	O
lastpos	*(struct(int,int))
->	O
index	(*(char),int)->(*(char))
=	O
i	int
;	O
firstpos	*(struct(int,int))
->	O
constraint	int
=	O
lastpos	*(struct(int,int))
->	O
constraint	int
=	O
NO_CONSTRAINT	int
;	O
nalloc	*(int)
[	O
i	int
]	O
=	O
1	int
;	O
MALLOC	O
(	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
nalloc	*(int)
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
tindex	int
;	O
++	O
i	int
)	O
if	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
<	O
NOTCHAR	O
||	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
==	O
BACKREF	int
||	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
==	O
ANYCHAR	int
||	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
==	O
MBCSET	int
||	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
>=	O
CSET	int
)	O
{	O
copy	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
&	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
i	int
]	O
,	O
&	O
merged	struct(*(struct(int,int)),int)
)	O
;	O
epsclosure	(*(struct(*(struct(int,int)),int)),*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
&	O
merged	struct(*(struct(int,int)),int)
,	O
d	*(struct)
)	O
;	O
if	O
(	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
i	int
]	O
.	O
nelem	int
<	O
merged	struct(*(struct(int,int)),int)
.	O
nelem	int
)	O
REALLOC	O
(	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
merged	struct(*(struct(int,int)),int)
.	O
nelem	int
)	O
;	O
copy	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
&	O
merged	struct(*(struct(int,int)),int)
,	O
&	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
i	int
]	O
)	O
;	O
}	O
merged	struct(*(struct(int,int)),int)
.	O
nelem	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nfirstpos	*(int)
[	O
-	O
1	int
]	O
;	O
++	O
i	int
)	O
insert	(struct(int,int),*(struct(*(struct(int,int)),int)))->(void)
(	O
firstpos	*(struct(int,int))
[	O
i	int
]	O
,	O
&	O
merged	struct(*(struct(int,int)),int)
)	O
;	O
epsclosure	(*(struct(*(struct(int,int)),int)),*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
&	O
merged	struct(*(struct(int,int)),int)
,	O
d	*(struct)
)	O
;	O
wants_newline	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
merged	struct(*(struct(int,int)),int)
.	O
nelem	int
;	O
++	O
i	int
)	O
if	O
(	O
PREV_NEWLINE_DEPENDENT	O
(	O
merged	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
constraint	int
)	O
)	O
wants_newline	int
=	O
1	int
;	O
d	*(struct)
->	O
salloc	int
=	O
1	int
;	O
d	*(struct)
->	O
sindex	int
=	O
0	int
;	O
MALLOC	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
,	O
dfa_state	struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))
,	O
d	*(struct)
->	O
salloc	int
)	O
;	O
state_index	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),*(struct(*(struct(int,int)),int)),int,int)->(int)
(	O
d	*(struct)
,	O
&	O
merged	struct(*(struct(int,int)),int)
,	O
wants_newline	int
,	O
0	int
)	O
;	O
free	(*(void))->(void)
(	O
o_nullable	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
o_nfirst	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
o_firstpos	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
o_nlast	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
o_lastpos	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
nalloc	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
merged	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
)	O
;	O
}	O
void	O
dfastate	(int,*(struct),array(int))->(void)
(	O
int	O
s	long
,	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
int	O
trans	*(*(int))
[	O
]	O
)	O
{	O
position_set	struct(*(struct(int,int)),int)
*	O
grps	*(struct(*(struct(int,int)),int))
;	O
charclass	array(int)
*	O
labels	*(array(int))
;	O
int	O
ngrps	int
=	O
0	int
;	O
position	struct(int,int)
pos	*(struct(int,int))
;	O
charclass	array(int)
matches	array(int)
;	O
int	O
matchesf	int
;	O
charclass	array(int)
intersect	array(int)
;	O
int	O
intersectf	int
;	O
charclass	array(int)
leftovers	array(int)
;	O
int	O
leftoversf	int
;	O
static	O
charclass	array(int)
letters	array(int)
;	O
static	O
charclass	array(int)
newline	int
;	O
position_set	struct(*(struct(int,int)),int)
follows	*(struct(*(struct(int,int)),int))
;	O
position_set	struct(*(struct(int,int)),int)
tmp	struct(*(struct(int,int)),int)
;	O
int	O
state	*(int)
;	O
int	O
wants_newline	int
;	O
int	O
state_newline	int
;	O
int	O
wants_letter	int
;	O
int	O
state_letter	int
;	O
static	O
int	O
initialized	int
;	O
int	O
next_isnt_1st_byte	int
=	O
0	int
;	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
grps	*(struct(*(struct(int,int)),int))
=	O
xnmalloc	(long,long)->(*(void))
(	O
NOTCHAR	O
,	O
sizeof	O
*	O
grps	*(struct(*(struct(int,int)),int))
)	O
;	O
labels	*(array(int))
=	O
xnmalloc	(long,long)->(*(void))
(	O
NOTCHAR	O
,	O
sizeof	O
*	O
labels	*(array(int))
)	O
;	O
if	O
(	O
!	O
initialized	int
)	O
{	O
initialized	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NOTCHAR	O
;	O
++	O
i	int
)	O
if	O
(	O
IS_WORD_CONSTITUENT	O
(	O
i	int
)	O
)	O
setbit	(int,array(int))->(void)
(	O
i	int
,	O
letters	array(int)
)	O
;	O
setbit	(int,array(int))->(void)
(	O
eolbyte	char
,	O
newline	int
)	O
;	O
}	O
zeroset	(array(int))->(void)
(	O
matches	array(int)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
elems	*(struct(int,int))
.	O
nelem	int
;	O
++	O
i	int
)	O
{	O
pos	*(struct(int,int))
=	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
elems	*(struct(int,int))
.	O
elems	*(struct(int,int))
[	O
i	int
]	O
;	O
if	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
>=	O
0	int
&&	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
<	O
NOTCHAR	O
)	O
setbit	(int,array(int))->(void)
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
,	O
matches	array(int)
)	O
;	O
else	O
if	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
>=	O
CSET	int
)	O
copyset	(array(int),array(int))->(void)
(	O
d	*(struct)
->	O
charclasses	*(array(int))
[	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
-	O
CSET	int
]	O
,	O
matches	array(int)
)	O
;	O
else	O
if	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
==	O
ANYCHAR	int
||	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
==	O
MBCSET	int
)	O
{	O
if	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
nelem	int
==	O
0	int
)	O
{	O
MALLOC	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
elems	*(struct(int,int))
.	O
nelem	int
)	O
;	O
}	O
insert	(struct(int,int),*(struct(*(struct(int,int)),int)))->(void)
(	O
pos	*(struct(int,int))
,	O
&	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
)	O
)	O
;	O
continue	O
;	O
}	O
else	O
continue	O
;	O
if	O
(	O
pos	*(struct(int,int))
.	O
constraint	int
!=	O
0xFF	int
)	O
{	O
if	O
(	O
!	O
MATCHES_NEWLINE_CONTEXT	O
(	O
pos	*(struct(int,int))
.	O
constraint	int
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
newline	int
,	O
1	int
)	O
)	O
clrbit	(int,array(int))->(void)
(	O
eolbyte	char
,	O
matches	array(int)
)	O
;	O
if	O
(	O
!	O
MATCHES_NEWLINE_CONTEXT	O
(	O
pos	*(struct(int,int))
.	O
constraint	int
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
newline	int
,	O
0	int
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
;	O
++	O
j	int
)	O
matches	array(int)
[	O
j	int
]	O
&=	O
newline	int
[	O
j	int
]	O
;	O
if	O
(	O
!	O
MATCHES_LETTER_CONTEXT	O
(	O
pos	*(struct(int,int))
.	O
constraint	int
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
letter	char
,	O
1	int
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
;	O
++	O
j	int
)	O
matches	array(int)
[	O
j	int
]	O
&=	O
~	O
letters	array(int)
[	O
j	int
]	O
;	O
if	O
(	O
!	O
MATCHES_LETTER_CONTEXT	O
(	O
pos	*(struct(int,int))
.	O
constraint	int
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
letter	char
,	O
0	int
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
;	O
++	O
j	int
)	O
matches	array(int)
[	O
j	int
]	O
&=	O
letters	array(int)
[	O
j	int
]	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
&&	O
!	O
matches	array(int)
[	O
j	int
]	O
;	O
++	O
j	int
)	O
continue	O
;	O
if	O
(	O
j	int
==	O
CHARCLASS_INTS	O
)	O
continue	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
ngrps	int
;	O
++	O
j	int
)	O
{	O
if	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
>=	O
0	int
&&	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
<	O
NOTCHAR	O
&&	O
!	O
tstbit	(int,array(int))->(int)
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
,	O
labels	*(array(int))
[	O
j	int
]	O
)	O
)	O
continue	O
;	O
intersectf	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
CHARCLASS_INTS	O
;	O
++	O
k	int
)	O
(	O
intersect	array(int)
[	O
k	int
]	O
=	O
matches	array(int)
[	O
k	int
]	O
&	O
labels	*(array(int))
[	O
j	int
]	O
[	O
k	int
]	O
)	O
?	O
(	O
intersectf	int
=	O
1	int
)	O
:	O
0	int
;	O
if	O
(	O
!	O
intersectf	int
)	O
continue	O
;	O
leftoversf	int
=	O
matchesf	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
CHARCLASS_INTS	O
;	O
++	O
k	int
)	O
{	O
int	O
match	int
=	O
matches	array(int)
[	O
k	int
]	O
,	O
label	int
=	O
labels	*(array(int))
[	O
j	int
]	O
[	O
k	int
]	O
;	O
(	O
leftovers	array(int)
[	O
k	int
]	O
=	O
~	O
match	int
&	O
label	int
)	O
?	O
(	O
leftoversf	int
=	O
1	int
)	O
:	O
0	int
;	O
(	O
matches	array(int)
[	O
k	int
]	O
=	O
match	int
&	O
~	O
label	int
)	O
?	O
(	O
matchesf	int
=	O
1	int
)	O
:	O
0	int
;	O
}	O
if	O
(	O
leftoversf	int
)	O
{	O
copyset	(array(int),array(int))->(void)
(	O
leftovers	array(int)
,	O
labels	*(array(int))
[	O
ngrps	int
]	O
)	O
;	O
copyset	(array(int),array(int))->(void)
(	O
intersect	array(int)
,	O
labels	*(array(int))
[	O
j	int
]	O
)	O
;	O
MALLOC	O
(	O
grps	*(struct(*(struct(int,int)),int))
[	O
ngrps	int
]	O
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
d	*(struct)
->	O
nleaves	int
)	O
;	O
copy	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
&	O
grps	*(struct(*(struct(int,int)),int))
[	O
j	int
]	O
,	O
&	O
grps	*(struct(*(struct(int,int)),int))
[	O
ngrps	int
]	O
)	O
;	O
++	O
ngrps	int
;	O
}	O
grps	*(struct(*(struct(int,int)),int))
[	O
j	int
]	O
.	O
elems	*(struct(int,int))
[	O
grps	*(struct(*(struct(int,int)),int))
[	O
j	int
]	O
.	O
nelem	int
++	O
]	O
=	O
pos	*(struct(int,int))
;	O
if	O
(	O
!	O
matchesf	int
)	O
break	O
;	O
}	O
if	O
(	O
j	int
==	O
ngrps	int
)	O
{	O
copyset	(array(int),array(int))->(void)
(	O
matches	array(int)
,	O
labels	*(array(int))
[	O
ngrps	int
]	O
)	O
;	O
zeroset	(array(int))->(void)
(	O
matches	array(int)
)	O
;	O
MALLOC	O
(	O
grps	*(struct(*(struct(int,int)),int))
[	O
ngrps	int
]	O
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
d	*(struct)
->	O
nleaves	int
)	O
;	O
grps	*(struct(*(struct(int,int)),int))
[	O
ngrps	int
]	O
.	O
nelem	int
=	O
1	int
;	O
grps	*(struct(*(struct(int,int)),int))
[	O
ngrps	int
]	O
.	O
elems	*(struct(int,int))
[	O
0	int
]	O
=	O
pos	*(struct(int,int))
;	O
++	O
ngrps	int
;	O
}	O
}	O
MALLOC	O
(	O
follows	*(struct(*(struct(int,int)),int))
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
d	*(struct)
->	O
nleaves	int
)	O
;	O
MALLOC	O
(	O
tmp	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
d	*(struct)
->	O
nleaves	int
)	O
;	O
if	O
(	O
d	*(struct)
->	O
searchflag	int
)	O
{	O
wants_newline	int
=	O
0	int
;	O
wants_letter	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
0	int
]	O
.	O
elems	*(struct(int,int))
.	O
nelem	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
PREV_NEWLINE_DEPENDENT	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
0	int
]	O
.	O
elems	*(struct(int,int))
.	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
constraint	int
)	O
)	O
wants_newline	int
=	O
1	int
;	O
if	O
(	O
PREV_LETTER_DEPENDENT	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
0	int
]	O
.	O
elems	*(struct(int,int))
.	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
constraint	int
)	O
)	O
wants_letter	int
=	O
1	int
;	O
}	O
copy	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
&	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
0	int
]	O
.	O
elems	*(struct(int,int))
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
)	O
;	O
state	*(int)
=	O
state_index	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),*(struct(*(struct(int,int)),int)),int,int)->(int)
(	O
d	*(struct)
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
wants_newline	int
)	O
state_newline	int
=	O
state_index	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),*(struct(*(struct(int,int)),int)),int,int)->(int)
(	O
d	*(struct)
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
,	O
1	int
,	O
0	int
)	O
;	O
else	O
state_newline	int
=	O
state	*(int)
;	O
if	O
(	O
wants_letter	int
)	O
state_letter	int
=	O
state_index	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),*(struct(*(struct(int,int)),int)),int,int)->(int)
(	O
d	*(struct)
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
,	O
0	int
,	O
1	int
)	O
;	O
else	O
state_letter	int
=	O
state	*(int)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NOTCHAR	O
;	O
++	O
i	int
)	O
trans	*(*(int))
[	O
i	int
]	O
=	O
(	O
IS_WORD_CONSTITUENT	O
(	O
i	int
)	O
)	O
?	O
state_letter	int
:	O
state	*(int)
;	O
trans	*(*(int))
[	O
eolbyte	char
]	O
=	O
state_newline	int
;	O
}	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NOTCHAR	O
;	O
++	O
i	int
)	O
trans	*(*(int))
[	O
i	int
]	O
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ngrps	int
;	O
++	O
i	int
)	O
{	O
follows	*(struct(*(struct(int,int)),int))
.	O
nelem	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
grps	*(struct(*(struct(int,int)),int))
[	O
i	int
]	O
.	O
nelem	int
;	O
++	O
j	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
grps	*(struct(*(struct(int,int)),int))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
.	O
nelem	int
;	O
++	O
k	int
)	O
insert	(struct(int,int),*(struct(*(struct(int,int)),int)))->(void)
(	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
grps	*(struct(*(struct(int,int)),int))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
.	O
elems	*(struct(int,int))
[	O
k	int
]	O
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
)	O
;	O
if	O
(	O
d	*(struct)
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
next_isnt_1st_byte	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
follows	*(struct(*(struct(int,int)),int))
.	O
nelem	int
;	O
++	O
j	int
)	O
{	O
if	O
(	O
!	O
(	O
d	*(struct)
->	O
multibyte_prop	*(int)
[	O
follows	*(struct(*(struct(int,int)),int))
.	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
&	O
1	int
)	O
)	O
{	O
next_isnt_1st_byte	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
d	*(struct)
->	O
searchflag	int
&&	O
(	O
d	*(struct)
->	O
mb_cur_max	int
==	O
1	int
||	O
!	O
next_isnt_1st_byte	int
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
0	int
]	O
.	O
elems	*(struct(int,int))
.	O
nelem	int
;	O
++	O
j	int
)	O
insert	(struct(int,int),*(struct(*(struct(int,int)),int)))->(void)
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
0	int
]	O
.	O
elems	*(struct(int,int))
.	O
elems	*(struct(int,int))
[	O
j	int
]	O
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
)	O
;	O
wants_newline	int
=	O
0	int
;	O
if	O
(	O
tstbit	(int,array(int))->(int)
(	O
eolbyte	char
,	O
labels	*(array(int))
[	O
i	int
]	O
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
follows	*(struct(*(struct(int,int)),int))
.	O
nelem	int
;	O
++	O
j	int
)	O
if	O
(	O
PREV_NEWLINE_DEPENDENT	O
(	O
follows	*(struct(*(struct(int,int)),int))
.	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
constraint	int
)	O
)	O
wants_newline	int
=	O
1	int
;	O
wants_letter	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
;	O
++	O
j	int
)	O
if	O
(	O
labels	*(array(int))
[	O
i	int
]	O
[	O
j	int
]	O
&	O
letters	array(int)
[	O
j	int
]	O
)	O
break	O
;	O
if	O
(	O
j	int
<	O
CHARCLASS_INTS	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
follows	*(struct(*(struct(int,int)),int))
.	O
nelem	int
;	O
++	O
j	int
)	O
if	O
(	O
PREV_LETTER_DEPENDENT	O
(	O
follows	*(struct(*(struct(int,int)),int))
.	O
elems	*(struct(int,int))
[	O
j	int
]	O
.	O
constraint	int
)	O
)	O
wants_letter	int
=	O
1	int
;	O
state	*(int)
=	O
state_index	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),*(struct(*(struct(int,int)),int)),int,int)->(int)
(	O
d	*(struct)
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
wants_newline	int
)	O
state_newline	int
=	O
state_index	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),*(struct(*(struct(int,int)),int)),int,int)->(int)
(	O
d	*(struct)
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
,	O
1	int
,	O
0	int
)	O
;	O
else	O
state_newline	int
=	O
state	*(int)
;	O
if	O
(	O
wants_letter	int
)	O
state_letter	int
=	O
state_index	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),*(struct(*(struct(int,int)),int)),int,int)->(int)
(	O
d	*(struct)
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
,	O
0	int
,	O
1	int
)	O
;	O
else	O
state_letter	int
=	O
state	*(int)
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARCLASS_INTS	O
;	O
++	O
j	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
INTBITS	O
;	O
++	O
k	int
)	O
if	O
(	O
labels	*(array(int))
[	O
i	int
]	O
[	O
j	int
]	O
&	O
1	int
<<	O
k	int
)	O
{	O
int	O
c	array(int)
=	O
j	int
*	O
INTBITS	O
+	O
k	int
;	O
if	O
(	O
c	array(int)
==	O
eolbyte	char
)	O
trans	*(*(int))
[	O
c	array(int)
]	O
=	O
state_newline	int
;	O
else	O
if	O
(	O
IS_WORD_CONSTITUENT	O
(	O
c	array(int)
)	O
)	O
trans	*(*(int))
[	O
c	array(int)
]	O
=	O
state_letter	int
;	O
else	O
if	O
(	O
c	array(int)
<	O
NOTCHAR	O
)	O
trans	*(*(int))
[	O
c	array(int)
]	O
=	O
state	*(int)
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ngrps	int
;	O
++	O
i	int
)	O
free	(*(void))->(void)
(	O
grps	*(struct(*(struct(int,int)),int))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
follows	*(struct(*(struct(int,int)),int))
.	O
elems	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
tmp	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
grps	*(struct(*(struct(int,int)),int))
)	O
;	O
free	(*(void))->(void)
(	O
labels	*(array(int))
)	O
;	O
}	O
static	O
void	O
build_state	(int,*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
int	O
s	long
,	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
)	O
{	O
int	O
*	O
trans	*(*(int))
;	O
int	O
i	int
;	O
if	O
(	O
d	*(struct)
->	O
trcount	int
>=	O
1024	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
tralloc	int
;	O
++	O
i	int
)	O
{	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
trans	*(*(int))
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
fails	*(*(int))
[	O
i	int
]	O
)	O
;	O
d	*(struct)
->	O
trans	*(*(int))
[	O
i	int
]	O
=	O
d	*(struct)
->	O
fails	*(*(int))
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
d	*(struct)
->	O
trcount	int
=	O
0	int
;	O
}	O
++	O
d	*(struct)
->	O
trcount	int
;	O
d	*(struct)
->	O
success	*(int)
[	O
s	long
]	O
=	O
0	int
;	O
if	O
(	O
ACCEPTS_IN_CONTEXT	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
newline	int
,	O
1	int
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
letter	char
,	O
0	int
,	O
s	long
,	O
*	O
d	*(struct)
)	O
)	O
d	*(struct)
->	O
success	*(int)
[	O
s	long
]	O
|=	O
4	int
;	O
if	O
(	O
ACCEPTS_IN_CONTEXT	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
newline	int
,	O
0	int
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
letter	char
,	O
1	int
,	O
s	long
,	O
*	O
d	*(struct)
)	O
)	O
d	*(struct)
->	O
success	*(int)
[	O
s	long
]	O
|=	O
2	int
;	O
if	O
(	O
ACCEPTS_IN_CONTEXT	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
newline	int
,	O
0	int
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
letter	char
,	O
0	int
,	O
s	long
,	O
*	O
d	*(struct)
)	O
)	O
d	*(struct)
->	O
success	*(int)
[	O
s	long
]	O
|=	O
1	int
;	O
MALLOC	O
(	O
trans	*(*(int))
,	O
int	O
,	O
NOTCHAR	O
)	O
;	O
dfastate	(int,*(struct),array(int))->(void)
(	O
s	long
,	O
d	*(struct)
,	O
trans	*(*(int))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NOTCHAR	O
;	O
++	O
i	int
)	O
if	O
(	O
trans	*(*(int))
[	O
i	int
]	O
>=	O
d	*(struct)
->	O
tralloc	int
)	O
{	O
int	O
oldalloc	int
=	O
d	*(struct)
->	O
tralloc	int
;	O
while	O
(	O
trans	*(*(int))
[	O
i	int
]	O
>=	O
d	*(struct)
->	O
tralloc	int
)	O
d	*(struct)
->	O
tralloc	int
*=	O
2	int
;	O
REALLOC	O
(	O
d	*(struct)
->	O
realtrans	*(*(int))
,	O
int	O
*	O
,	O
d	*(struct)
->	O
tralloc	int
+	O
1	int
)	O
;	O
d	*(struct)
->	O
trans	*(*(int))
=	O
d	*(struct)
->	O
realtrans	*(*(int))
+	O
1	int
;	O
REALLOC	O
(	O
d	*(struct)
->	O
fails	*(*(int))
,	O
int	O
*	O
,	O
d	*(struct)
->	O
tralloc	int
)	O
;	O
REALLOC	O
(	O
d	*(struct)
->	O
success	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
tralloc	int
)	O
;	O
REALLOC	O
(	O
d	*(struct)
->	O
newlines	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
tralloc	int
)	O
;	O
while	O
(	O
oldalloc	int
<	O
d	*(struct)
->	O
tralloc	int
)	O
{	O
d	*(struct)
->	O
trans	*(*(int))
[	O
oldalloc	int
]	O
=	O
NULL	O
;	O
d	*(struct)
->	O
fails	*(*(int))
[	O
oldalloc	int
++	O
]	O
=	O
NULL	O
;	O
}	O
}	O
d	*(struct)
->	O
newlines	*(int)
[	O
s	long
]	O
=	O
trans	*(*(int))
[	O
eolbyte	char
]	O
;	O
trans	*(*(int))
[	O
eolbyte	char
]	O
=	O
-	O
1	int
;	O
if	O
(	O
ACCEPTING	O
(	O
s	long
,	O
*	O
d	*(struct)
)	O
)	O
d	*(struct)
->	O
fails	*(*(int))
[	O
s	long
]	O
=	O
trans	*(*(int))
;	O
else	O
d	*(struct)
->	O
trans	*(*(int))
[	O
s	long
]	O
=	O
trans	*(*(int))
;	O
}	O
static	O
void	O
build_state_zero	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
)	O
{	O
d	*(struct)
->	O
tralloc	int
=	O
1	int
;	O
d	*(struct)
->	O
trcount	int
=	O
0	int
;	O
CALLOC	O
(	O
d	*(struct)
->	O
realtrans	*(*(int))
,	O
int	O
*	O
,	O
d	*(struct)
->	O
tralloc	int
+	O
1	int
)	O
;	O
d	*(struct)
->	O
trans	*(*(int))
=	O
d	*(struct)
->	O
realtrans	*(*(int))
+	O
1	int
;	O
CALLOC	O
(	O
d	*(struct)
->	O
fails	*(*(int))
,	O
int	O
*	O
,	O
d	*(struct)
->	O
tralloc	int
)	O
;	O
MALLOC	O
(	O
d	*(struct)
->	O
success	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
tralloc	int
)	O
;	O
MALLOC	O
(	O
d	*(struct)
->	O
newlines	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
tralloc	int
)	O
;	O
build_state	(int,*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
0	int
,	O
d	*(struct)
)	O
;	O
}	O
static	O
void	O
realloc_trans_if_necessary	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int)->(void)
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
int	O
new_state	int
)	O
{	O
if	O
(	O
new_state	int
>=	O
d	*(struct)
->	O
tralloc	int
)	O
{	O
int	O
oldalloc	int
=	O
d	*(struct)
->	O
tralloc	int
;	O
while	O
(	O
new_state	int
>=	O
d	*(struct)
->	O
tralloc	int
)	O
d	*(struct)
->	O
tralloc	int
*=	O
2	int
;	O
REALLOC	O
(	O
d	*(struct)
->	O
realtrans	*(*(int))
,	O
int	O
*	O
,	O
d	*(struct)
->	O
tralloc	int
+	O
1	int
)	O
;	O
d	*(struct)
->	O
trans	*(*(int))
=	O
d	*(struct)
->	O
realtrans	*(*(int))
+	O
1	int
;	O
REALLOC	O
(	O
d	*(struct)
->	O
fails	*(*(int))
,	O
int	O
*	O
,	O
d	*(struct)
->	O
tralloc	int
)	O
;	O
REALLOC	O
(	O
d	*(struct)
->	O
success	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
tralloc	int
)	O
;	O
REALLOC	O
(	O
d	*(struct)
->	O
newlines	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
tralloc	int
)	O
;	O
while	O
(	O
oldalloc	int
<	O
d	*(struct)
->	O
tralloc	int
)	O
{	O
d	*(struct)
->	O
trans	*(*(int))
[	O
oldalloc	int
]	O
=	O
NULL	O
;	O
d	*(struct)
->	O
fails	*(*(int))
[	O
oldalloc	int
++	O
]	O
=	O
NULL	O
;	O
}	O
}	O
}	O
typedef	O
enum	O
{	O
TRANSIT_STATE_IN_PROGRESS	int
,	O
TRANSIT_STATE_DONE	int
,	O
TRANSIT_STATE_END_BUFFER	int
}	O
status_transit_state	enum(int,int,int)
;	O
static	O
status_transit_state	enum(int,int,int)
transit_state_singlebyte	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,*(char),*(int))->(enum(int,int,int))
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
int	O
s	long
,	O
unsigned	O
char	O
const	O
*	O
p	*(void)
,	O
int	O
*	O
next_state	*(int)
)	O
{	O
int	O
*	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
int	O
works	int
=	O
s	long
;	O
status_transit_state	enum(int,int,int)
rval	enum(int,int,int)
=	O
TRANSIT_STATE_IN_PROGRESS	int
;	O
while	O
(	O
rval	enum(int,int,int)
==	O
TRANSIT_STATE_IN_PROGRESS	int
)	O
{	O
if	O
(	O
(	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
d	*(struct)
->	O
trans	*(*(int))
[	O
works	int
]	O
)	O
!=	O
NULL	O
)	O
{	O
works	int
=	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
[	O
*	O
p	*(void)
]	O
;	O
rval	enum(int,int,int)
=	O
TRANSIT_STATE_DONE	int
;	O
if	O
(	O
works	int
<	O
0	int
)	O
works	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
works	int
<	O
0	int
)	O
{	O
if	O
(	O
p	*(void)
==	O
buf_end	*(char)
)	O
{	O
abort	()->(void)
(	O
)	O
;	O
}	O
works	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
d	*(struct)
->	O
fails	*(*(int))
[	O
works	int
]	O
)	O
{	O
works	int
=	O
d	*(struct)
->	O
fails	*(*(int))
[	O
works	int
]	O
[	O
*	O
p	*(void)
]	O
;	O
rval	enum(int,int,int)
=	O
TRANSIT_STATE_DONE	int
;	O
}	O
else	O
{	O
build_state	(int,*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
works	int
,	O
d	*(struct)
)	O
;	O
}	O
}	O
*	O
next_state	*(int)
=	O
works	int
;	O
return	O
rval	enum(int,int,int)
;	O
}	O
static	O
int	O
match_anychar	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,struct(int,int),int)->(int)
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
int	O
s	long
,	O
position	struct(int,int)
pos	*(struct(int,int))
,	O
int	O
idx	int
)	O
{	O
int	O
newline	int
=	O
0	int
;	O
int	O
letter	char
=	O
0	int
;	O
wchar_t	int
wc	int
;	O
int	O
mbclen	int
;	O
wc	int
=	O
inputwcs	*(int)
[	O
idx	int
]	O
;	O
mbclen	int
=	O
(	O
mblen_buf	*(char)
[	O
idx	int
]	O
==	O
0	int
)	O
?	O
1	int
:	O
mblen_buf	*(char)
[	O
idx	int
]	O
;	O
if	O
(	O
wc	int
==	O
(	O
wchar_t	int
)	O
eolbyte	char
)	O
{	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_DOT_NEWLINE	O
)	O
)	O
return	O
0	int
;	O
newline	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
wc	int
==	O
(	O
wchar_t	int
)	O
'\0'	O
)	O
{	O
if	O
(	O
syntax_bits	long
&	O
RE_DOT_NOT_NULL	O
)	O
return	O
0	int
;	O
newline	int
=	O
1	int
;	O
}	O
if	O
(	O
iswalnum	(int)->(int)
(	O
wc	int
)	O
||	O
wc	int
==	O
L'_'	O
)	O
letter	char
=	O
1	int
;	O
if	O
(	O
!	O
SUCCEEDS_IN_CONTEXT	O
(	O
pos	*(struct(int,int))
.	O
constraint	int
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
newline	int
,	O
newline	int
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
letter	char
,	O
letter	char
)	O
)	O
return	O
0	int
;	O
return	O
mbclen	int
;	O
}	O
static	O
int	O
match_mb_charset	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,struct(int,int),int)->(int)
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
int	O
s	long
,	O
position	struct(int,int)
pos	*(struct(int,int))
,	O
int	O
idx	int
)	O
{	O
int	O
i	int
;	O
int	O
match	int
;	O
int	O
match_len	int
;	O
int	O
op_len	int
;	O
char	O
buffer	*(char)
[	O
128	int
]	O
;	O
wchar_t	int
wcbuf	array(int)
[	O
6	int
]	O
;	O
struct	O
mb_char_classes	struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)
*	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
;	O
int	O
newline	int
=	O
0	int
;	O
int	O
letter	char
=	O
0	int
;	O
wchar_t	int
wc	int
;	O
wc	int
=	O
inputwcs	*(int)
[	O
idx	int
]	O
;	O
if	O
(	O
wc	int
==	O
(	O
wchar_t	int
)	O
eolbyte	char
)	O
{	O
if	O
(	O
!	O
(	O
syntax_bits	long
&	O
RE_DOT_NEWLINE	O
)	O
)	O
return	O
0	int
;	O
newline	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
wc	int
==	O
(	O
wchar_t	int
)	O
'\0'	O
)	O
{	O
if	O
(	O
syntax_bits	long
&	O
RE_DOT_NOT_NULL	O
)	O
return	O
0	int
;	O
newline	int
=	O
1	int
;	O
}	O
if	O
(	O
iswalnum	(int)->(int)
(	O
wc	int
)	O
||	O
wc	int
==	O
L'_'	O
)	O
letter	char
=	O
1	int
;	O
if	O
(	O
!	O
SUCCEEDS_IN_CONTEXT	O
(	O
pos	*(struct(int,int))
.	O
constraint	int
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
newline	int
,	O
newline	int
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
letter	char
,	O
letter	char
)	O
)	O
return	O
0	int
;	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
=	O
&	O
(	O
d	*(struct)
->	O
mbcsets	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
[	O
(	O
d	*(struct)
->	O
multibyte_prop	*(int)
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
)	O
>>	O
2	int
]	O
)	O
;	O
match	int
=	O
!	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
invert	int
;	O
match_len	int
=	O
(	O
mblen_buf	*(char)
[	O
idx	int
]	O
==	O
0	int
)	O
?	O
1	int
:	O
mblen_buf	*(char)
[	O
idx	int
]	O
;	O
if	O
(	O
wc	int
<	O
NOTCHAR	O
&&	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
cset	int
!=	O
-	O
1	int
&&	O
tstbit	(int,array(int))->(int)
(	O
(	O
unsigned	O
char	O
)	O
wc	int
,	O
d	*(struct)
->	O
charclasses	*(array(int))
[	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
cset	int
]	O
)	O
)	O
goto	O
charset_matched	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nch_classes	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
iswctype	(int,long)->(int)
(	O
(	O
wint_t	int
)	O
wc	int
,	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
ch_classes	*(long)
[	O
i	int
]	O
)	O
)	O
goto	O
charset_matched	O
;	O
}	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
buffer	*(char)
,	O
(	O
char	O
const	O
*	O
)	O
buf_begin	*(char)
+	O
idx	int
,	O
match_len	int
)	O
;	O
buffer	*(char)
[	O
match_len	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nequivs	int
;	O
i	int
++	O
)	O
{	O
op_len	int
=	O
strlen	(*(char))->(long)
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
equivs	*(*(char))
[	O
i	int
]	O
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
buffer	*(char)
,	O
(	O
char	O
const	O
*	O
)	O
buf_begin	*(char)
+	O
idx	int
,	O
op_len	int
)	O
;	O
buffer	*(char)
[	O
op_len	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strcoll	(*(char),*(char))->(int)
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
equivs	*(*(char))
[	O
i	int
]	O
,	O
buffer	*(char)
)	O
==	O
0	int
)	O
{	O
match_len	int
=	O
op_len	int
;	O
goto	O
charset_matched	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
ncoll_elems	int
;	O
i	int
++	O
)	O
{	O
op_len	int
=	O
strlen	(*(char))->(long)
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
coll_elems	*(*(char))
[	O
i	int
]	O
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
buffer	*(char)
,	O
(	O
char	O
const	O
*	O
)	O
buf_begin	*(char)
+	O
idx	int
,	O
op_len	int
)	O
;	O
buffer	*(char)
[	O
op_len	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strcoll	(*(char),*(char))->(int)
(	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
coll_elems	*(*(char))
[	O
i	int
]	O
,	O
buffer	*(char)
)	O
==	O
0	int
)	O
{	O
match_len	int
=	O
op_len	int
;	O
goto	O
charset_matched	O
;	O
}	O
}	O
wcbuf	array(int)
[	O
0	int
]	O
=	O
wc	int
;	O
wcbuf	array(int)
[	O
1	int
]	O
=	O
wcbuf	array(int)
[	O
3	int
]	O
=	O
wcbuf	array(int)
[	O
5	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nranges	int
;	O
i	int
++	O
)	O
{	O
wcbuf	array(int)
[	O
2	int
]	O
=	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
range_sts	*(int)
[	O
i	int
]	O
;	O
wcbuf	array(int)
[	O
4	int
]	O
=	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
range_ends	*(int)
[	O
i	int
]	O
;	O
if	O
(	O
wcscoll	(*(int),*(int))->(int)
(	O
wcbuf	array(int)
,	O
wcbuf	array(int)
+	O
2	int
)	O
>=	O
0	int
&&	O
wcscoll	(*(int),*(int))->(int)
(	O
wcbuf	array(int)
+	O
4	int
,	O
wcbuf	array(int)
)	O
>=	O
0	int
)	O
goto	O
charset_matched	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
nchars	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
wc	int
==	O
work_mbc	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
->	O
chars	*(int)
[	O
i	int
]	O
)	O
goto	O
charset_matched	O
;	O
}	O
match	int
=	O
!	O
match	int
;	O
charset_matched	O
:	O
return	O
match	int
?	O
match_len	int
:	O
0	int
;	O
}	O
static	O
int	O
*	O
check_matching_with_multibyte_ops	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,int)->(*(int))
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
int	O
s	long
,	O
int	O
idx	int
)	O
{	O
int	O
i	int
;	O
int	O
*	O
rarray	*(int)
;	O
MALLOC	O
(	O
rarray	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
nelem	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
nelem	int
;	O
++	O
i	int
)	O
{	O
position	struct(int,int)
pos	*(struct(int,int))
=	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
[	O
i	int
]	O
;	O
switch	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
pos	*(struct(int,int))
.	O
index	(*(char),int)->(*(char))
]	O
)	O
{	O
case	O
ANYCHAR	int
:	O
rarray	*(int)
[	O
i	int
]	O
=	O
match_anychar	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,struct(int,int),int)->(int)
(	O
d	*(struct)
,	O
s	long
,	O
pos	*(struct(int,int))
,	O
idx	int
)	O
;	O
break	O
;	O
case	O
MBCSET	int
:	O
rarray	*(int)
[	O
i	int
]	O
=	O
match_mb_charset	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,struct(int,int),int)->(int)
(	O
d	*(struct)
,	O
s	long
,	O
pos	*(struct(int,int))
,	O
idx	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
return	O
rarray	*(int)
;	O
}	O
static	O
status_transit_state	enum(int,int,int)
transit_state_consume_1char	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,*(*(char)),*(int),*(int),*(struct(*(struct(int,int)),int)))->(enum(int,int,int))
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
int	O
s	long
,	O
unsigned	O
char	O
const	O
*	O
*	O
pp	*(*(char))
,	O
int	O
*	O
match_lens	*(int)
,	O
int	O
*	O
mbclen	int
,	O
position_set	struct(*(struct(int,int)),int)
*	O
pps	*(struct(*(struct(int,int)),int))
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
s1	*(char)
,	O
s2	*(char)
;	O
int	O
*	O
work_mbls	*(int)
;	O
status_transit_state	enum(int,int,int)
rs	enum(int,int,int)
=	O
TRANSIT_STATE_DONE	int
;	O
*	O
mbclen	int
=	O
(	O
mblen_buf	*(char)
[	O
*	O
pp	*(*(char))
-	O
buf_begin	*(char)
]	O
==	O
0	int
)	O
?	O
1	int
:	O
mblen_buf	*(char)
[	O
*	O
pp	*(*(char))
-	O
buf_begin	*(char)
]	O
;	O
s1	*(char)
=	O
s	long
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
*	O
mbclen	int
;	O
i	int
++	O
)	O
{	O
s2	*(char)
=	O
s1	*(char)
;	O
rs	enum(int,int,int)
=	O
transit_state_singlebyte	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,*(char),*(int))->(enum(int,int,int))
(	O
d	*(struct)
,	O
s2	*(char)
,	O
(	O
*	O
pp	*(*(char))
)	O
++	O
,	O
&	O
s1	*(char)
)	O
;	O
}	O
copy	(*(struct(*(struct(int,int)),int)),*(struct(*(struct(int,int)),int)))->(void)
(	O
&	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s1	*(char)
]	O
.	O
elems	*(struct(int,int))
)	O
,	O
pps	*(struct(*(struct(int,int)),int))
)	O
;	O
if	O
(	O
match_lens	*(int)
==	O
NULL	O
&&	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
nelem	int
!=	O
0	int
)	O
work_mbls	*(int)
=	O
check_matching_with_multibyte_ops	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,int)->(*(int))
(	O
d	*(struct)
,	O
s	long
,	O
*	O
pp	*(*(char))
-	O
buf_begin	*(char)
)	O
;	O
else	O
work_mbls	*(int)
=	O
match_lens	*(int)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
nelem	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
work_mbls	*(int)
[	O
i	int
]	O
==	O
*	O
mbclen	int
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
.	O
nelem	int
;	O
j	int
++	O
)	O
insert	(struct(int,int),*(struct(*(struct(int,int)),int)))->(void)
(	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
.	O
elems	*(struct(int,int))
[	O
j	int
]	O
,	O
pps	*(struct(*(struct(int,int)),int))
)	O
;	O
}	O
if	O
(	O
match_lens	*(int)
==	O
NULL	O
&&	O
work_mbls	*(int)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
work_mbls	*(int)
)	O
;	O
return	O
rs	enum(int,int,int)
;	O
}	O
static	O
int	O
transit_state	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,*(*(char)))->(int)
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
int	O
s	long
,	O
unsigned	O
char	O
const	O
*	O
*	O
pp	*(*(char))
)	O
{	O
int	O
s1	*(char)
;	O
int	O
mbclen	int
;	O
int	O
maxlen	int
=	O
0	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
*	O
match_lens	*(int)
=	O
NULL	O
;	O
int	O
nelem	int
=	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
nelem	int
;	O
position_set	struct(*(struct(int,int)),int)
follows	*(struct(*(struct(int,int)),int))
;	O
unsigned	O
char	O
const	O
*	O
p1	*(char)
=	O
*	O
pp	*(*(char))
;	O
wchar_t	int
wc	int
;	O
if	O
(	O
nelem	int
>	O
0	int
)	O
{	O
match_lens	*(int)
=	O
check_matching_with_multibyte_ops	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,int)->(*(int))
(	O
d	*(struct)
,	O
s	long
,	O
*	O
pp	*(*(char))
-	O
buf_begin	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nelem	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_lens	*(int)
[	O
i	int
]	O
>	O
maxlen	int
)	O
maxlen	int
=	O
match_lens	*(int)
[	O
i	int
]	O
;	O
}	O
}	O
if	O
(	O
nelem	int
==	O
0	int
||	O
maxlen	int
==	O
0	int
)	O
{	O
status_transit_state	enum(int,int,int)
rs	enum(int,int,int)
;	O
rs	enum(int,int,int)
=	O
transit_state_singlebyte	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,*(char),*(int))->(enum(int,int,int))
(	O
d	*(struct)
,	O
s	long
,	O
*	O
pp	*(*(char))
,	O
&	O
s1	*(char)
)	O
;	O
if	O
(	O
rs	enum(int,int,int)
==	O
TRANSIT_STATE_DONE	int
)	O
++	O
*	O
pp	*(*(char))
;	O
free	(*(void))->(void)
(	O
match_lens	*(int)
)	O
;	O
return	O
s1	*(char)
;	O
}	O
follows	*(struct(*(struct(int,int)),int))
.	O
nelem	int
=	O
0	int
;	O
MALLOC	O
(	O
follows	*(struct(*(struct(int,int)),int))
.	O
elems	*(struct(int,int))
,	O
position	struct(int,int)
,	O
d	*(struct)
->	O
nleaves	int
)	O
;	O
transit_state_consume_1char	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,*(*(char)),*(int),*(int),*(struct(*(struct(int,int)),int)))->(enum(int,int,int))
(	O
d	*(struct)
,	O
s	long
,	O
pp	*(*(char))
,	O
match_lens	*(int)
,	O
&	O
mbclen	int
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
)	O
;	O
wc	int
=	O
inputwcs	*(int)
[	O
*	O
pp	*(*(char))
-	O
mbclen	int
-	O
buf_begin	*(char)
]	O
;	O
s1	*(char)
=	O
state_index	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),*(struct(*(struct(int,int)),int)),int,int)->(int)
(	O
d	*(struct)
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
,	O
wc	int
==	O
L'\n'	O
,	O
iswalnum	(int)->(int)
(	O
wc	int
)	O
)	O
;	O
realloc_trans_if_necessary	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int)->(void)
(	O
d	*(struct)
,	O
s1	*(char)
)	O
;	O
while	O
(	O
*	O
pp	*(*(char))
-	O
p1	*(char)
<	O
maxlen	int
)	O
{	O
follows	*(struct(*(struct(int,int)),int))
.	O
nelem	int
=	O
0	int
;	O
transit_state_consume_1char	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,*(*(char)),*(int),*(int),*(struct(*(struct(int,int)),int)))->(enum(int,int,int))
(	O
d	*(struct)
,	O
s1	*(char)
,	O
pp	*(*(char))
,	O
NULL	O
,	O
&	O
mbclen	int
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nelem	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_lens	*(int)
[	O
i	int
]	O
==	O
*	O
pp	*(*(char))
-	O
p1	*(char)
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s1	*(char)
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
.	O
nelem	int
;	O
j	int
++	O
)	O
insert	(struct(int,int),*(struct(*(struct(int,int)),int)))->(void)
(	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s1	*(char)
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
[	O
i	int
]	O
.	O
index	(*(char),int)->(*(char))
]	O
.	O
elems	*(struct(int,int))
[	O
j	int
]	O
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
)	O
;	O
}	O
wc	int
=	O
inputwcs	*(int)
[	O
*	O
pp	*(*(char))
-	O
mbclen	int
-	O
buf_begin	*(char)
]	O
;	O
s1	*(char)
=	O
state_index	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),*(struct(*(struct(int,int)),int)),int,int)->(int)
(	O
d	*(struct)
,	O
&	O
follows	*(struct(*(struct(int,int)),int))
,	O
wc	int
==	O
L'\n'	O
,	O
iswalnum	(int)->(int)
(	O
wc	int
)	O
)	O
;	O
realloc_trans_if_necessary	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int)->(void)
(	O
d	*(struct)
,	O
s1	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
match_lens	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
follows	*(struct(*(struct(int,int)),int))
.	O
elems	*(struct(int,int))
)	O
;	O
return	O
s1	*(char)
;	O
}	O
static	O
void	O
prepare_wc_buf	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
begin	*(char)
,	O
const	O
char	O
*	O
end	*(int)
)	O
{	O
unsigned	O
char	O
eol	char
=	O
eolbyte	char
;	O
size_t	long
remain_bytes	long
,	O
i	int
;	O
buf_begin	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
begin	*(char)
;	O
remain_bytes	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
end	*(int)
-	O
begin	*(char)
+	O
1	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
remain_bytes	long
==	O
0	int
)	O
{	O
remain_bytes	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
inputwcs	*(int)
+	O
i	int
,	O
begin	*(char)
+	O
i	int
,	O
end	*(int)
-	O
begin	*(char)
-	O
i	int
+	O
1	int
,	O
&	O
mbs	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
remain_bytes	long
<	O
1	int
||	O
remain_bytes	long
==	O
(	O
size_t	long
)	O
-	O
1	int
||	O
remain_bytes	long
==	O
(	O
size_t	long
)	O
-	O
2	int
||	O
(	O
remain_bytes	long
==	O
1	int
&&	O
inputwcs	*(int)
[	O
i	int
]	O
==	O
(	O
wchar_t	int
)	O
begin	*(char)
[	O
i	int
]	O
)	O
)	O
{	O
remain_bytes	long
=	O
0	int
;	O
inputwcs	*(int)
[	O
i	int
]	O
=	O
(	O
wchar_t	int
)	O
begin	*(char)
[	O
i	int
]	O
;	O
mblen_buf	*(char)
[	O
i	int
]	O
=	O
0	int
;	O
if	O
(	O
begin	*(char)
[	O
i	int
]	O
==	O
eol	char
)	O
break	O
;	O
}	O
else	O
{	O
mblen_buf	*(char)
[	O
i	int
]	O
=	O
remain_bytes	long
;	O
remain_bytes	long
--	O
;	O
}	O
}	O
else	O
{	O
mblen_buf	*(char)
[	O
i	int
]	O
=	O
remain_bytes	long
;	O
inputwcs	*(int)
[	O
i	int
]	O
=	O
0	int
;	O
remain_bytes	long
--	O
;	O
}	O
}	O
buf_end	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
begin	*(char)
+	O
i	int
)	O
;	O
mblen_buf	*(char)
[	O
i	int
]	O
=	O
0	int
;	O
inputwcs	*(int)
[	O
i	int
]	O
=	O
0	int
;	O
}	O
char	O
*	O
dfaexec	(*(struct),*(char),*(char),int,*(int),*(int))->(*(char))
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
char	O
const	O
*	O
begin	*(char)
,	O
char	O
*	O
end	*(int)
,	O
int	O
newline	int
,	O
int	O
*	O
count	*(int)
,	O
int	O
*	O
backref	*(int)
)	O
{	O
int	O
s	long
,	O
s1	*(char)
,	O
tmp	struct(*(struct(int,int)),int)
;	O
unsigned	O
char	O
const	O
*	O
p	*(void)
;	O
int	O
*	O
*	O
trans	*(*(int))
,	O
*	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
unsigned	O
char	O
eol	char
=	O
eolbyte	char
;	O
unsigned	O
char	O
saved_end	char
;	O
static	O
int	O
sbit	array(int)
[	O
NOTCHAR	O
]	O
;	O
static	O
int	O
sbit_init	int
;	O
if	O
(	O
!	O
sbit_init	int
)	O
{	O
unsigned	O
int	O
i	int
;	O
sbit_init	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NOTCHAR	O
;	O
++	O
i	int
)	O
sbit	array(int)
[	O
i	int
]	O
=	O
(	O
IS_WORD_CONSTITUENT	O
(	O
i	int
)	O
)	O
?	O
2	int
:	O
1	int
;	O
sbit	array(int)
[	O
eol	char
]	O
=	O
4	int
;	O
}	O
if	O
(	O
!	O
d	*(struct)
->	O
tralloc	int
)	O
build_state_zero	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
d	*(struct)
)	O
;	O
s	long
=	O
s1	*(char)
=	O
0	int
;	O
p	*(void)
=	O
(	O
unsigned	O
char	O
const	O
*	O
)	O
begin	*(char)
;	O
trans	*(*(int))
=	O
d	*(struct)
->	O
trans	*(*(int))
;	O
saved_end	char
=	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
end	*(int)
;	O
*	O
end	*(int)
=	O
eol	char
;	O
if	O
(	O
d	*(struct)
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
MALLOC	O
(	O
mblen_buf	*(char)
,	O
unsigned	O
char	O
,	O
end	*(int)
-	O
begin	*(char)
+	O
2	int
)	O
;	O
MALLOC	O
(	O
inputwcs	*(int)
,	O
wchar_t	int
,	O
end	*(int)
-	O
begin	*(char)
+	O
2	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
mbs	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
prepare_wc_buf	(*(char),*(char))->(void)
(	O
(	O
const	O
char	O
*	O
)	O
p	*(void)
,	O
end	*(int)
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
d	*(struct)
->	O
mb_cur_max	int
>	O
1	int
)	O
while	O
(	O
(	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
trans	*(*(int))
[	O
s	long
]	O
)	O
)	O
{	O
if	O
(	O
p	*(void)
>	O
buf_end	*(char)
)	O
break	O
;	O
s1	*(char)
=	O
s	long
;	O
SKIP_REMAINS_MB_IF_INITIAL_STATE	O
(	O
s	long
,	O
p	*(void)
)	O
;	O
if	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
nelem	int
==	O
0	int
)	O
{	O
s	long
=	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
[	O
*	O
p	*(void)
++	O
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
backref	*(int)
)	O
{	O
*	O
backref	*(int)
=	O
1	int
;	O
free	(*(void))->(void)
(	O
mblen_buf	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
inputwcs	*(int)
)	O
;	O
*	O
end	*(int)
=	O
saved_end	char
;	O
return	O
(	O
char	O
*	O
)	O
p	*(void)
;	O
}	O
s	long
=	O
transit_state	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,*(*(char)))->(int)
(	O
d	*(struct)
,	O
s	long
,	O
&	O
p	*(void)
)	O
;	O
trans	*(*(int))
=	O
d	*(struct)
->	O
trans	*(*(int))
;	O
}	O
else	O
while	O
(	O
(	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
trans	*(*(int))
[	O
s	long
]	O
)	O
!=	O
0	int
)	O
{	O
s1	*(char)
=	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
[	O
*	O
p	*(void)
++	O
]	O
;	O
if	O
(	O
(	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
trans	*(*(int))
[	O
s1	*(char)
]	O
)	O
==	O
0	int
)	O
{	O
tmp	struct(*(struct(int,int)),int)
=	O
s	long
;	O
s	long
=	O
s1	*(char)
;	O
s1	*(char)
=	O
tmp	struct(*(struct(int,int)),int)
;	O
break	O
;	O
}	O
s	long
=	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
[	O
*	O
p	*(void)
++	O
]	O
;	O
}	O
if	O
(	O
s	long
>=	O
0	int
&&	O
(	O
char	O
*	O
)	O
p	*(void)
<=	O
end	*(int)
&&	O
d	*(struct)
->	O
fails	*(*(int))
[	O
s	long
]	O
)	O
{	O
if	O
(	O
d	*(struct)
->	O
success	*(int)
[	O
s	long
]	O
&	O
sbit	array(int)
[	O
*	O
p	*(void)
]	O
)	O
{	O
if	O
(	O
backref	*(int)
)	O
*	O
backref	*(int)
=	O
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
s	long
]	O
.	O
backref	*(int)
!=	O
0	int
)	O
;	O
if	O
(	O
d	*(struct)
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
free	(*(void))->(void)
(	O
mblen_buf	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
inputwcs	*(int)
)	O
;	O
}	O
*	O
end	*(int)
=	O
saved_end	char
;	O
return	O
(	O
char	O
*	O
)	O
p	*(void)
;	O
}	O
s1	*(char)
=	O
s	long
;	O
if	O
(	O
d	*(struct)
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
s	long
=	O
transit_state	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))),int,*(*(char)))->(int)
(	O
d	*(struct)
,	O
s	long
,	O
&	O
p	*(void)
)	O
;	O
trans	*(*(int))
=	O
d	*(struct)
->	O
trans	*(*(int))
;	O
}	O
else	O
s	long
=	O
d	*(struct)
->	O
fails	*(*(int))
[	O
s	long
]	O
[	O
*	O
p	*(void)
++	O
]	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
char	O
*	O
)	O
p	*(void)
<=	O
end	*(int)
&&	O
p	*(void)
[	O
-	O
1	int
]	O
==	O
eol	char
)	O
{	O
if	O
(	O
count	*(int)
)	O
++	O
*	O
count	*(int)
;	O
if	O
(	O
d	*(struct)
->	O
mb_cur_max	int
>	O
1	int
)	O
prepare_wc_buf	(*(char),*(char))->(void)
(	O
(	O
const	O
char	O
*	O
)	O
p	*(void)
,	O
end	*(int)
)	O
;	O
}	O
if	O
(	O
(	O
char	O
*	O
)	O
p	*(void)
>	O
end	*(int)
)	O
{	O
if	O
(	O
d	*(struct)
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
free	(*(void))->(void)
(	O
mblen_buf	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
inputwcs	*(int)
)	O
;	O
}	O
*	O
end	*(int)
=	O
saved_end	char
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
s	long
>=	O
0	int
)	O
{	O
build_state	(int,*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
s	long
,	O
d	*(struct)
)	O
;	O
trans	*(*(int))
=	O
d	*(struct)
->	O
trans	*(*(int))
;	O
continue	O
;	O
}	O
if	O
(	O
p	*(void)
[	O
-	O
1	int
]	O
==	O
eol	char
&&	O
newline	int
)	O
{	O
s	long
=	O
d	*(struct)
->	O
newlines	*(int)
[	O
s1	*(char)
]	O
;	O
continue	O
;	O
}	O
s	long
=	O
0	int
;	O
}	O
}	O
static	O
void	O
free_mbdata	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
)	O
{	O
unsigned	O
int	O
i	int
;	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
multibyte_prop	*(int)
)	O
;	O
d	*(struct)
->	O
multibyte_prop	*(int)
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
nmbcsets	int
;	O
++	O
i	int
)	O
{	O
unsigned	O
int	O
j	int
;	O
struct	O
mb_char_classes	struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)
*	O
p	*(void)
=	O
&	O
(	O
d	*(struct)
->	O
mbcsets	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
p	*(void)
->	O
chars	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(void)
->	O
ch_classes	*(long)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(void)
->	O
range_sts	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(void)
->	O
range_ends	*(int)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
p	*(void)
->	O
nequivs	int
;	O
++	O
j	int
)	O
free	(*(void))->(void)
(	O
p	*(void)
->	O
equivs	*(*(char))
[	O
j	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
p	*(void)
->	O
equivs	*(*(char))
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
p	*(void)
->	O
ncoll_elems	int
;	O
++	O
j	int
)	O
free	(*(void))->(void)
(	O
p	*(void)
->	O
coll_elems	*(*(char))
[	O
j	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
p	*(void)
->	O
coll_elems	*(*(char))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
mbcsets	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
)	O
;	O
d	*(struct)
->	O
mbcsets	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
=	O
NULL	O
;	O
d	*(struct)
->	O
nmbcsets	int
=	O
0	int
;	O
}	O
void	O
dfainit	(*(struct))->(void)
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
d	*(struct)
,	O
0	int
,	O
sizeof	O
*	O
d	*(struct)
)	O
;	O
d	*(struct)
->	O
calloc	(long,long)->(*(void))
=	O
1	int
;	O
MALLOC	O
(	O
d	*(struct)
->	O
charclasses	*(array(int))
,	O
charclass	array(int)
,	O
d	*(struct)
->	O
calloc	(long,long)->(*(void))
)	O
;	O
d	*(struct)
->	O
talloc	int
=	O
1	int
;	O
MALLOC	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
,	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
d	*(struct)
->	O
talloc	int
)	O
;	O
d	*(struct)
->	O
mb_cur_max	int
=	O
MB_CUR_MAX	O
;	O
if	O
(	O
d	*(struct)
->	O
mb_cur_max	int
>	O
1	int
)	O
{	O
d	*(struct)
->	O
nmultibyte_prop	int
=	O
1	int
;	O
MALLOC	O
(	O
d	*(struct)
->	O
multibyte_prop	*(int)
,	O
int	O
,	O
d	*(struct)
->	O
nmultibyte_prop	int
)	O
;	O
d	*(struct)
->	O
mbcsets_alloc	int
=	O
1	int
;	O
MALLOC	O
(	O
d	*(struct)
->	O
mbcsets	*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int))
,	O
struct	O
mb_char_classes	struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)
,	O
d	*(struct)
->	O
mbcsets_alloc	int
)	O
;	O
}	O
}	O
static	O
void	O
dfaoptimize	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
)	O
{	O
unsigned	O
int	O
i	int
;	O
if	O
(	O
!	O
using_utf8	()->(int)
(	O
)	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
tindex	int
;	O
++	O
i	int
)	O
{	O
switch	O
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
i	int
]	O
)	O
{	O
case	O
ANYCHAR	int
:	O
abort	()->(void)
(	O
)	O
;	O
case	O
MBCSET	int
:	O
return	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
free_mbdata	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
d	*(struct)
)	O
;	O
d	*(struct)
->	O
mb_cur_max	int
=	O
1	int
;	O
}	O
void	O
dfacomp	(*(char),long,*(struct),int)->(void)
(	O
char	O
const	O
*	O
s	long
,	O
size_t	long
len	long
,	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
,	O
int	O
searchflag	int
)	O
{	O
dfainit	(*(struct))->(void)
(	O
d	*(struct)
)	O
;	O
dfaparse	(*(char),long,*(struct))->(void)
(	O
s	long
,	O
len	long
,	O
d	*(struct)
)	O
;	O
dfamust	struct(int,*(char),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
(	O
d	*(struct)
)	O
;	O
dfaoptimize	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
d	*(struct)
)	O
;	O
dfaanalyze	(*(struct),int)->(void)
(	O
d	*(struct)
,	O
searchflag	int
)	O
;	O
}	O
void	O
dfafree	(*(struct))->(void)
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
)	O
{	O
int	O
i	int
;	O
struct	O
dfamust	struct(int,*(char),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
,	O
*	O
ndm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
charclasses	*(array(int))
)	O
;	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
)	O
;	O
if	O
(	O
d	*(struct)
->	O
mb_cur_max	int
>	O
1	int
)	O
free_mbdata	(*(struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*`,int,*`,int,*`,*`,int,*`,int,*`,int)),int,int,*(struct(int,struct`,char,char,char,char,int,struct`)),int,int,*(struct(*`,int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*`,*`)))))->(void)
(	O
d	*(struct)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
sindex	int
;	O
++	O
i	int
)	O
{	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
.	O
elems	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
[	O
i	int
]	O
.	O
mbps	struct(*(struct(int,int)),int)
.	O
elems	*(struct(int,int))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
states	*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int)))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
tindex	int
;	O
++	O
i	int
)	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
[	O
i	int
]	O
.	O
elems	*(struct(int,int))
)	O
;	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
follows	*(struct(*(struct(int,int)),int))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
d	*(struct)
->	O
tralloc	int
;	O
++	O
i	int
)	O
{	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
trans	*(*(int))
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
fails	*(*(int))
[	O
i	int
]	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
realtrans	*(*(int))
)	O
;	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
fails	*(*(int))
)	O
;	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
newlines	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
d	*(struct)
->	O
success	*(int)
)	O
;	O
for	O
(	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
=	O
d	*(struct)
->	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
=	O
ndm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
)	O
{	O
ndm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
=	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
->	O
next	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
free	(*(void))->(void)
(	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
->	O
must	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
)	O
;	O
}	O
}	O
static	O
char	O
*	O
icatalloc	(*(char),*(char))->(*(char))
(	O
char	O
*	O
old	struct(int,int)
,	O
char	O
const	O
*	O
new	*(char)
)	O
{	O
char	O
*	O
result	*(char)
;	O
size_t	long
oldsize	long
,	O
newsize	long
;	O
newsize	long
=	O
(	O
new	*(char)
==	O
NULL	O
)	O
?	O
0	int
:	O
strlen	(*(char))->(long)
(	O
new	*(char)
)	O
;	O
if	O
(	O
old	struct(int,int)
==	O
NULL	O
)	O
oldsize	long
=	O
0	int
;	O
else	O
if	O
(	O
newsize	long
==	O
0	int
)	O
return	O
old	struct(int,int)
;	O
else	O
oldsize	long
=	O
strlen	(*(char))->(long)
(	O
old	struct(int,int)
)	O
;	O
if	O
(	O
old	struct(int,int)
==	O
NULL	O
)	O
result	*(char)
=	O
malloc	(long)->(*(void))
(	O
newsize	long
+	O
1	int
)	O
;	O
else	O
result	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
old	struct(int,int)
,	O
oldsize	long
+	O
newsize	long
+	O
1	int
)	O
;	O
if	O
(	O
result	*(char)
!=	O
NULL	O
&&	O
new	*(char)
!=	O
NULL	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
result	*(char)
+	O
oldsize	long
,	O
new	*(char)
)	O
;	O
return	O
result	*(char)
;	O
}	O
static	O
char	O
*	O
icpyalloc	(*(char))->(*(char))
(	O
char	O
const	O
*	O
string	*(char)
)	O
{	O
return	O
icatalloc	(*(char),*(char))->(*(char))
(	O
NULL	O
,	O
string	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
istrstr	(*(char),*(char))->(*(char))
(	O
char	O
const	O
*	O
lookin	*(char)
,	O
char	O
const	O
*	O
lookfor	*(char)
)	O
{	O
char	O
const	O
*	O
cp	*(char)
;	O
size_t	long
len	long
;	O
len	long
=	O
strlen	(*(char))->(long)
(	O
lookfor	*(char)
)	O
;	O
for	O
(	O
cp	*(char)
=	O
lookin	*(char)
;	O
*	O
cp	*(char)
!=	O
'\0'	O
;	O
++	O
cp	*(char)
)	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
cp	*(char)
,	O
lookfor	*(char)
,	O
len	long
)	O
==	O
0	int
)	O
return	O
(	O
char	O
*	O
)	O
cp	*(char)
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
freelist	(*(*(char)))->(void)
(	O
char	O
*	O
*	O
cpp	*(*(char))
)	O
{	O
int	O
i	int
;	O
if	O
(	O
cpp	*(*(char))
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
cpp	*(*(char))
[	O
i	int
]	O
!=	O
NULL	O
;	O
++	O
i	int
)	O
{	O
free	(*(void))->(void)
(	O
cpp	*(*(char))
[	O
i	int
]	O
)	O
;	O
cpp	*(*(char))
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
}	O
static	O
char	O
*	O
*	O
enlist	(*(*(char)),*(char),long)->(*(*(char)))
(	O
char	O
*	O
*	O
cpp	*(*(char))
,	O
char	O
*	O
new	*(char)
,	O
size_t	long
len	long
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
cpp	*(*(char))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
new	*(char)
=	O
icpyalloc	(*(char))->(*(char))
(	O
new	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
freelist	(*(*(char)))->(void)
(	O
cpp	*(*(char))
)	O
;	O
return	O
NULL	O
;	O
}	O
new	*(char)
[	O
len	long
]	O
=	O
'\0'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
cpp	*(*(char))
[	O
i	int
]	O
!=	O
NULL	O
;	O
++	O
i	int
)	O
if	O
(	O
istrstr	(*(char),*(char))->(*(char))
(	O
cpp	*(*(char))
[	O
i	int
]	O
,	O
new	*(char)
)	O
!=	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
new	*(char)
)	O
;	O
return	O
cpp	*(*(char))
;	O
}	O
j	int
=	O
0	int
;	O
while	O
(	O
cpp	*(*(char))
[	O
j	int
]	O
!=	O
NULL	O
)	O
if	O
(	O
istrstr	(*(char),*(char))->(*(char))
(	O
new	*(char)
,	O
cpp	*(*(char))
[	O
j	int
]	O
)	O
==	O
NULL	O
)	O
++	O
j	int
;	O
else	O
{	O
free	(*(void))->(void)
(	O
cpp	*(*(char))
[	O
j	int
]	O
)	O
;	O
if	O
(	O
--	O
i	int
==	O
j	int
)	O
break	O
;	O
cpp	*(*(char))
[	O
j	int
]	O
=	O
cpp	*(*(char))
[	O
i	int
]	O
;	O
cpp	*(*(char))
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
cpp	*(*(char))
=	O
xnrealloc	(*(void),long,long)->(*(void))
(	O
cpp	*(*(char))
,	O
i	int
+	O
2	int
,	O
sizeof	O
*	O
cpp	*(*(char))
)	O
;	O
cpp	*(*(char))
[	O
i	int
]	O
=	O
new	*(char)
;	O
cpp	*(*(char))
[	O
i	int
+	O
1	int
]	O
=	O
NULL	O
;	O
return	O
cpp	*(*(char))
;	O
}	O
static	O
char	O
*	O
*	O
comsubs	(*(char),*(char))->(*(*(char)))
(	O
char	O
*	O
left	*(char)
,	O
char	O
const	O
*	O
right	*(char)
)	O
{	O
char	O
*	O
*	O
cpp	*(*(char))
;	O
char	O
*	O
lcp	*(char)
;	O
char	O
*	O
rcp	*(char)
;	O
size_t	long
i	int
,	O
len	long
;	O
if	O
(	O
left	*(char)
==	O
NULL	O
||	O
right	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
cpp	*(*(char))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
*	O
cpp	*(*(char))
)	O
;	O
if	O
(	O
cpp	*(*(char))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
cpp	*(*(char))
[	O
0	int
]	O
=	O
NULL	O
;	O
for	O
(	O
lcp	*(char)
=	O
left	*(char)
;	O
*	O
lcp	*(char)
!=	O
'\0'	O
;	O
++	O
lcp	*(char)
)	O
{	O
len	long
=	O
0	int
;	O
rcp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
right	*(char)
,	O
*	O
lcp	*(char)
)	O
;	O
while	O
(	O
rcp	*(char)
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
lcp	*(char)
[	O
i	int
]	O
!=	O
'\0'	O
&&	O
lcp	*(char)
[	O
i	int
]	O
==	O
rcp	*(char)
[	O
i	int
]	O
;	O
++	O
i	int
)	O
continue	O
;	O
if	O
(	O
i	int
>	O
len	long
)	O
len	long
=	O
i	int
;	O
rcp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
rcp	*(char)
+	O
1	int
,	O
*	O
lcp	*(char)
)	O
;	O
}	O
if	O
(	O
len	long
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
cpp	*(*(char))
=	O
enlist	(*(*(char)),*(char),long)->(*(*(char)))
(	O
cpp	*(*(char))
,	O
lcp	*(char)
,	O
len	long
)	O
)	O
==	O
NULL	O
)	O
break	O
;	O
}	O
return	O
cpp	*(*(char))
;	O
}	O
static	O
char	O
*	O
*	O
addlists	(*(*(char)),*(*(char)))->(*(*(char)))
(	O
char	O
*	O
*	O
old	struct(int,int)
,	O
char	O
*	O
*	O
new	*(char)
)	O
{	O
int	O
i	int
;	O
if	O
(	O
old	struct(int,int)
==	O
NULL	O
||	O
new	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
new	*(char)
[	O
i	int
]	O
!=	O
NULL	O
;	O
++	O
i	int
)	O
{	O
old	struct(int,int)
=	O
enlist	(*(*(char)),*(char),long)->(*(*(char)))
(	O
old	struct(int,int)
,	O
new	*(char)
[	O
i	int
]	O
,	O
strlen	(*(char))->(long)
(	O
new	*(char)
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
old	struct(int,int)
==	O
NULL	O
)	O
break	O
;	O
}	O
return	O
old	struct(int,int)
;	O
}	O
static	O
char	O
*	O
*	O
inboth	(*(*(char)),*(*(char)))->(*(*(char)))
(	O
char	O
*	O
*	O
left	*(char)
,	O
char	O
*	O
*	O
right	*(char)
)	O
{	O
char	O
*	O
*	O
both	*(*(char))
;	O
char	O
*	O
*	O
temp	*(*(char))
;	O
int	O
lnum	int
,	O
rnum	int
;	O
if	O
(	O
left	*(char)
==	O
NULL	O
||	O
right	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
both	*(*(char))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
*	O
both	*(*(char))
)	O
;	O
if	O
(	O
both	*(*(char))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
both	*(*(char))
[	O
0	int
]	O
=	O
NULL	O
;	O
for	O
(	O
lnum	int
=	O
0	int
;	O
left	*(char)
[	O
lnum	int
]	O
!=	O
NULL	O
;	O
++	O
lnum	int
)	O
{	O
for	O
(	O
rnum	int
=	O
0	int
;	O
right	*(char)
[	O
rnum	int
]	O
!=	O
NULL	O
;	O
++	O
rnum	int
)	O
{	O
temp	*(*(char))
=	O
comsubs	(*(char),*(char))->(*(*(char)))
(	O
left	*(char)
[	O
lnum	int
]	O
,	O
right	*(char)
[	O
rnum	int
]	O
)	O
;	O
if	O
(	O
temp	*(*(char))
==	O
NULL	O
)	O
{	O
freelist	(*(*(char)))->(void)
(	O
both	*(*(char))
)	O
;	O
return	O
NULL	O
;	O
}	O
both	*(*(char))
=	O
addlists	(*(*(char)),*(*(char)))->(*(*(char)))
(	O
both	*(*(char))
,	O
temp	*(*(char))
)	O
;	O
freelist	(*(*(char)))->(void)
(	O
temp	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
temp	*(*(char))
)	O
;	O
if	O
(	O
both	*(*(char))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
}	O
}	O
return	O
both	*(*(char))
;	O
}	O
typedef	O
struct	O
{	O
char	O
*	O
*	O
in	*(*(char))
;	O
char	O
*	O
left	*(char)
;	O
char	O
*	O
right	*(char)
;	O
char	O
*	O
is	*(char)
;	O
}	O
must	*(char)
;	O
static	O
void	O
resetmust	(*(struct(*(*(char)),*(char),*(char),*(char))))->(void)
(	O
must	*(char)
*	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
)	O
{	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
[	O
0	int
]	O
=	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
[	O
0	int
]	O
=	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
freelist	(*(*(char)))->(void)
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
)	O
;	O
}	O
static	O
void	O
dfamust	struct(int,*(char),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
d	*(struct)
)	O
{	O
must	*(char)
*	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
must	*(char)
*	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
char	O
*	O
result	*(char)
;	O
int	O
ri	int
;	O
int	O
i	int
;	O
int	O
exact	int
;	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
static	O
must	*(char)
must0	struct(*(*(char)),*(char),*(char),*(char))
;	O
struct	O
dfamust	struct(int,*(char),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
static	O
char	O
empty_string	array(char)
[	O
]	O
=	O
""	*(char)
;	O
result	*(char)
=	O
empty_string	array(char)
;	O
exact	int
=	O
0	int
;	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
=	O
xnmalloc	(long,long)->(*(void))
(	O
d	*(struct)
->	O
tindex	int
+	O
1	int
,	O
sizeof	O
*	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
)	O
;	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
=	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
d	*(struct)
->	O
tindex	int
;	O
++	O
i	int
)	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
=	O
must0	struct(*(*(char)),*(char),*(char),*(char))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
d	*(struct)
->	O
tindex	int
;	O
++	O
i	int
)	O
{	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
in	*(*(char))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
*	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
in	*(*(char))
)	O
;	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
left	*(char)
=	O
malloc	(long)->(*(void))
(	O
2	int
)	O
;	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
right	*(char)
=	O
malloc	(long)->(*(void))
(	O
2	int
)	O
;	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
is	*(char)
=	O
malloc	(long)->(*(void))
(	O
2	int
)	O
;	O
if	O
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
in	*(*(char))
==	O
NULL	O
||	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
left	*(char)
==	O
NULL	O
||	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
right	*(char)
==	O
NULL	O
||	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
is	*(char)
==	O
NULL	O
)	O
goto	O
done	O
;	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
left	*(char)
[	O
0	int
]	O
=	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
right	*(char)
[	O
0	int
]	O
=	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
is	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
in	*(*(char))
[	O
0	int
]	O
=	O
NULL	O
;	O
}	O
for	O
(	O
ri	int
=	O
0	int
;	O
ri	int
<	O
d	*(struct)
->	O
tindex	int
;	O
++	O
ri	int
)	O
{	O
switch	O
(	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
d	*(struct)
->	O
tokens	*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int))
[	O
ri	int
]	O
)	O
{	O
case	O
LPAREN	int
:	O
case	O
RPAREN	int
:	O
assert	O
(	O
!	O
"neither LPAREN nor RPAREN may appear here"	*(char)
)	O
;	O
case	O
EMPTY	int
:	O
case	O
BEGLINE	int
:	O
case	O
ENDLINE	int
:	O
case	O
BEGWORD	int
:	O
case	O
ENDWORD	int
:	O
case	O
LIMWORD	int
:	O
case	O
NOTLIMWORD	int
:	O
case	O
BACKREF	int
:	O
resetmust	(*(struct(*(*(char)),*(char),*(char),*(char))))->(void)
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
)	O
;	O
break	O
;	O
case	O
STAR	int
:	O
case	O
QMARK	int
:	O
assert	O
(	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
<	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
)	O
;	O
--	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
resetmust	(*(struct(*(*(char)),*(char),*(char),*(char))))->(void)
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
)	O
;	O
break	O
;	O
case	O
OR	int
:	O
assert	O
(	O
&	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
[	O
2	int
]	O
<=	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
)	O
;	O
{	O
char	O
*	O
*	O
new	*(char)
;	O
must	*(char)
*	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
must	*(char)
*	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
int	O
j	int
,	O
ln	int
,	O
rn	int
,	O
n	long
;	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
=	O
--	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
=	O
--	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
if	O
(	O
!	O
STREQ	O
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
,	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
)	O
)	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
[	O
i	int
]	O
!=	O
'\0'	O
&&	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
[	O
i	int
]	O
==	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
[	O
i	int
]	O
)	O
++	O
i	int
;	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
ln	int
=	O
strlen	(*(char))->(long)
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
)	O
;	O
rn	int
=	O
strlen	(*(char))->(long)
(	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
)	O
;	O
n	long
=	O
ln	int
;	O
if	O
(	O
n	long
>	O
rn	int
)	O
n	long
=	O
rn	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	long
;	O
++	O
i	int
)	O
if	O
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
[	O
ln	int
-	O
i	int
-	O
1	int
]	O
!=	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
[	O
rn	int
-	O
i	int
-	O
1	int
]	O
)	O
break	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
i	int
;	O
++	O
j	int
)	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
[	O
j	int
]	O
=	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
[	O
(	O
ln	int
-	O
i	int
)	O
+	O
j	int
]	O
;	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
[	O
j	int
]	O
=	O
'\0'	O
;	O
new	*(char)
=	O
inboth	(*(*(char)),*(*(char)))->(*(*(char)))
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
,	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
)	O
;	O
if	O
(	O
new	*(char)
==	O
NULL	O
)	O
goto	O
done	O
;	O
freelist	(*(*(char)))->(void)
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
)	O
;	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
=	O
new	*(char)
;	O
}	O
break	O
;	O
case	O
PLUS	int
:	O
assert	O
(	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
<	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
)	O
;	O
--	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
END	int
:	O
assert	O
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
==	O
&	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
[	O
1	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
[	O
0	int
]	O
.	O
in	*(*(char))
[	O
i	int
]	O
!=	O
NULL	O
;	O
++	O
i	int
)	O
if	O
(	O
strlen	(*(char))->(long)
(	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
[	O
0	int
]	O
.	O
in	*(*(char))
[	O
i	int
]	O
)	O
>	O
strlen	(*(char))->(long)
(	O
result	*(char)
)	O
)	O
result	*(char)
=	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
[	O
0	int
]	O
.	O
in	*(*(char))
[	O
i	int
]	O
;	O
if	O
(	O
STREQ	O
(	O
result	*(char)
,	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
[	O
0	int
]	O
.	O
is	*(char)
)	O
)	O
exact	int
=	O
1	int
;	O
goto	O
done	O
;	O
case	O
CAT	int
:	O
assert	O
(	O
&	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
[	O
2	int
]	O
<=	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
)	O
;	O
{	O
must	*(char)
*	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
must	*(char)
*	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
=	O
--	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
=	O
--	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
=	O
addlists	(*(*(char)),*(*(char)))->(*(*(char)))
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
,	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
)	O
;	O
if	O
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
==	O
NULL	O
)	O
goto	O
done	O
;	O
if	O
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
char	O
*	O
tp	*(char)
;	O
tp	*(char)
=	O
icpyalloc	(*(char))->(*(char))
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
)	O
;	O
if	O
(	O
tp	*(char)
==	O
NULL	O
)	O
goto	O
done	O
;	O
tp	*(char)
=	O
icatalloc	(*(char),*(char))->(*(char))
(	O
tp	*(char)
,	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
)	O
;	O
if	O
(	O
tp	*(char)
==	O
NULL	O
)	O
goto	O
done	O
;	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
=	O
enlist	(*(*(char)),*(char),long)->(*(*(char)))
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
,	O
tp	*(char)
,	O
strlen	(*(char))->(long)
(	O
tp	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
tp	*(char)
)	O
;	O
if	O
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
==	O
NULL	O
)	O
goto	O
done	O
;	O
}	O
if	O
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
=	O
icatalloc	(*(char),*(char))->(*(char))
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
,	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
)	O
;	O
if	O
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
==	O
NULL	O
)	O
goto	O
done	O
;	O
}	O
if	O
(	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
=	O
icatalloc	(*(char),*(char))->(*(char))
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
,	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
)	O
;	O
if	O
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
==	O
NULL	O
)	O
goto	O
done	O
;	O
if	O
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
=	O
icatalloc	(*(char),*(char))->(*(char))
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
,	O
rmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
)	O
;	O
if	O
(	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
==	O
NULL	O
)	O
goto	O
done	O
;	O
}	O
else	O
lmp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
<	O
END	int
)	O
{	O
assert	O
(	O
!	O
"oops! t >= END"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
'\0'	O
)	O
{	O
goto	O
done	O
;	O
}	O
else	O
if	O
(	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
>=	O
CSET	int
||	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ANYCHAR	int
||	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
MBCSET	int
)	O
{	O
resetmust	(*(struct(*(*(char)),*(char),*(char),*(char))))->(void)
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
)	O
;	O
}	O
else	O
{	O
resetmust	(*(struct(*(*(char)),*(char),*(char),*(char))))->(void)
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
)	O
;	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
[	O
0	int
]	O
=	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
[	O
0	int
]	O
=	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
[	O
0	int
]	O
=	O
t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
[	O
1	int
]	O
=	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
left	*(char)
[	O
1	int
]	O
=	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
right	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
=	O
enlist	(*(*(char)),*(char),long)->(*(*(char)))
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
,	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
is	*(char)
,	O
(	O
size_t	long
)	O
1	int
)	O
;	O
if	O
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
->	O
in	*(*(char))
==	O
NULL	O
)	O
goto	O
done	O
;	O
}	O
break	O
;	O
}	O
++	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
;	O
}	O
done	O
:	O
if	O
(	O
strlen	(*(char))->(long)
(	O
result	*(char)
)	O
)	O
{	O
MALLOC	O
(	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
,	O
struct	O
dfamust	struct(int,*(char),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
,	O
1	int
)	O
;	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
->	O
exact	int
=	O
exact	int
;	O
MALLOC	O
(	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
->	O
must	*(char)
,	O
char	O
,	O
strlen	(*(char))->(long)
(	O
result	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
->	O
must	*(char)
,	O
result	*(char)
)	O
;	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
->	O
next	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
=	O
d	*(struct)
->	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
d	*(struct)
->	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
=	O
dm	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
}	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
=	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
d	*(struct)
->	O
tindex	int
;	O
++	O
i	int
)	O
{	O
freelist	(*(*(char)))->(void)
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
in	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
in	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
left	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
right	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
[	O
i	int
]	O
.	O
is	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
mp	*(struct(*(*(char)),*(char),*(char),*(char)))
)	O
;	O
}	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
dfaalloc	()->(*(struct))
(	O
void	O
)	O
{	O
return	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
)	O
)	O
;	O
}	O
struct	O
dfamust	struct(int,*(char),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
*	O
dfamusts	(*(struct))->(*(struct(int,*(char),*(struct(int,*`,*`)))))
(	O
struct	O
dfa	struct(*(array(int)),int,int,*(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)),int,int,int,int,int,int,array(int),int,*(int),*(struct(int,int,*(int),int,*(long),int,*(int),*(int),int,*(*(char)),int,*(*(char)),int)),int,int,*(struct(int,struct(*(struct(int,int)),int),char,char,char,char,int,struct(*(struct(int,int)),int))),int,int,*(struct(*(struct(int,int)),int)),int,int,int,*(*(int)),*(*(int)),*(*(int)),*(int),*(int),*(struct(int,*(char),*(struct(int,*(char),*(struct`))))))
const	O
*	O
d	*(struct)
)	O
{	O
return	O
d	*(struct)
->	O
musts	*(struct(int,*(char),*(struct(int,*(char),*(struct`)))))
;	O
}	O
