z_const	O
char	O
*	O
const	O
z_errmsg	array(*(char))
[	O
10	int
]	O
=	O
{	O
(	O
z_const	O
char	O
*	O
)	O
"need dictionary"	*(char)
,	O
(	O
z_const	O
char	O
*	O
)	O
"stream end"	*(char)
,	O
(	O
z_const	O
char	O
*	O
)	O
""	*(char)
,	O
(	O
z_const	O
char	O
*	O
)	O
"file error"	*(char)
,	O
(	O
z_const	O
char	O
*	O
)	O
"stream error"	*(char)
,	O
(	O
z_const	O
char	O
*	O
)	O
"data error"	*(char)
,	O
(	O
z_const	O
char	O
*	O
)	O
"insufficient memory"	*(char)
,	O
(	O
z_const	O
char	O
*	O
)	O
"buffer error"	*(char)
,	O
(	O
z_const	O
char	O
*	O
)	O
"incompatible version"	*(char)
,	O
(	O
z_const	O
char	O
*	O
)	O
""	*(char)
}	O
;	O
const	O
char	O
*	O
ZEXPORT	O
zlibVersion	()->(*(char))
(	O
)	O
{	O
return	O
ZLIB_VERSION	*(char)
;	O
}	O
uLong	long
ZEXPORT	O
zlibCompileFlags	()->(long)
(	O
)	O
{	O
uLong	long
flags	long
;	O
flags	long
=	O
0	int
;	O
switch	O
(	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
uInt	int
)	O
)	O
)	O
{	O
case	O
2	int
:	O
break	O
;	O
case	O
4	int
:	O
flags	long
+=	O
1	int
;	O
break	O
;	O
case	O
8	int
:	O
flags	long
+=	O
2	int
;	O
break	O
;	O
default	O
:	O
flags	long
+=	O
3	int
;	O
}	O
switch	O
(	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
uLong	long
)	O
)	O
)	O
{	O
case	O
2	int
:	O
break	O
;	O
case	O
4	int
:	O
flags	long
+=	O
1	int
<<	O
2	int
;	O
break	O
;	O
case	O
8	int
:	O
flags	long
+=	O
2	int
<<	O
2	int
;	O
break	O
;	O
default	O
:	O
flags	long
+=	O
3	int
<<	O
2	int
;	O
}	O
switch	O
(	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
voidpf	*(void)
)	O
)	O
)	O
{	O
case	O
2	int
:	O
break	O
;	O
case	O
4	int
:	O
flags	long
+=	O
1	int
<<	O
4	int
;	O
break	O
;	O
case	O
8	int
:	O
flags	long
+=	O
2	int
<<	O
4	int
;	O
break	O
;	O
default	O
:	O
flags	long
+=	O
3	int
<<	O
4	int
;	O
}	O
switch	O
(	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
z_off_t	O
)	O
)	O
)	O
{	O
case	O
2	int
:	O
break	O
;	O
case	O
4	int
:	O
flags	long
+=	O
1	int
<<	O
6	int
;	O
break	O
;	O
case	O
8	int
:	O
flags	long
+=	O
2	int
<<	O
6	int
;	O
break	O
;	O
default	O
:	O
flags	long
+=	O
3	int
<<	O
6	int
;	O
}	O
return	O
flags	long
;	O
}	O
const	O
char	O
*	O
ZEXPORT	O
zError	(int)->(*(char))
(	O
err	int
)	O
int	O
err	int
;	O
{	O
return	O
ERR_MSG	O
(	O
err	int
)	O
;	O
}	O
voidpf	*(void)
ZLIB_INTERNAL	O
zcalloc	(*(void),int,int)->(*(void))
(	O
opaque	*(void)
,	O
items	int
,	O
size	int
)	O
voidpf	*(void)
opaque	*(void)
;	O
unsigned	O
items	int
;	O
unsigned	O
size	int
;	O
{	O
(	O
void	O
)	O
opaque	*(void)
;	O
return	O
sizeof	O
(	O
uInt	int
)	O
>	O
2	int
?	O
(	O
voidpf	*(void)
)	O
malloc	(long)->(*(void))
(	O
items	int
*	O
size	int
)	O
:	O
(	O
voidpf	*(void)
)	O
calloc	(long,long)->(*(void))
(	O
items	int
,	O
size	int
)	O
;	O
}	O
void	O
ZLIB_INTERNAL	O
zcfree	(*(void),*(void))->(void)
(	O
opaque	*(void)
,	O
ptr	*(void)
)	O
voidpf	*(void)
opaque	*(void)
;	O
voidpf	*(void)
ptr	*(void)
;	O
{	O
(	O
void	O
)	O
opaque	*(void)
;	O
free	(*(void))->(void)
(	O
ptr	*(void)
)	O
;	O
}	O
