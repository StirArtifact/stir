extern	O
dataobs	struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int)
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
]	O
;	O
extern	O
int	O
dap_ono	int
;	O
extern	O
FILE	struct
*	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
extern	O
FILE	struct
*	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
extern	O
char	O
*	O
dap_dapname	*(char)
;	O
static	O
double	O
*	O
allparam	*(double)
;	O
static	O
char	O
*	O
sel	*(char)
;	O
static	O
char	O
*	O
selred	*(char)
;	O
static	O
double	O
(	O
*	O
ex	*(()->(double))
)	O
(	O
)	O
;	O
static	O
double	O
*	O
*	O
tab	*(*(double))
;	O
static	O
int	O
nc	int
;	O
static	O
double	O
loglike	(*(double))->(double)
(	O
double	O
*	O
selparam	*(double)
)	O
{	O
int	O
s	int
;	O
int	O
p	double
;	O
double	O
expected	double
;	O
double	O
ll	double
;	O
int	O
c	int
;	O
for	O
(	O
s	int
=	O
0	int
,	O
p	double
=	O
0	int
;	O
sel	*(char)
[	O
s	int
]	O
;	O
s	int
++	O
)	O
{	O
if	O
(	O
sel	*(char)
[	O
s	int
]	O
!=	O
'!'	O
)	O
allparam	*(double)
[	O
s	int
]	O
=	O
selparam	*(double)
[	O
p	double
++	O
]	O
;	O
else	O
allparam	*(double)
[	O
s	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
ll	double
=	O
0.0	int
,	O
c	int
=	O
0	int
;	O
c	int
<	O
nc	int
;	O
c	int
++	O
)	O
{	O
expected	double
=	O
ex	*(()->(double))
(	O
allparam	*(double)
,	O
tab	*(*(double))
[	O
c	int
]	O
+	O
1	int
)	O
;	O
ll	double
+=	O
tab	*(*(double))
[	O
c	int
]	O
[	O
0	int
]	O
*	O
log	(double)->(double)
(	O
expected	double
)	O
-	O
expected	double
;	O
}	O
return	O
ll	double
;	O
}	O
static	O
int	O
selparse	(*(char),*(char))->(int)
(	O
char	O
*	O
names	*(char)
,	O
char	O
*	O
codes	*(char)
)	O
{	O
int	O
n	int
;	O
int	O
c	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
names	*(char)
[	O
n	int
]	O
==	O
' '	O
;	O
n	int
++	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
names	*(char)
[	O
n	int
]	O
;	O
c	int
++	O
)	O
{	O
if	O
(	O
names	*(char)
[	O
n	int
]	O
==	O
'!'	O
||	O
names	*(char)
[	O
n	int
]	O
==	O
'?'	O
)	O
{	O
codes	*(char)
[	O
c	int
]	O
=	O
names	*(char)
[	O
n	int
]	O
;	O
for	O
(	O
++	O
n	int
;	O
names	*(char)
[	O
n	int
]	O
==	O
' '	O
;	O
n	int
++	O
)	O
;	O
}	O
else	O
codes	*(char)
[	O
c	int
]	O
=	O
'1'	O
;	O
while	O
(	O
names	*(char)
[	O
n	int
]	O
&&	O
names	*(char)
[	O
n	int
]	O
!=	O
' '	O
)	O
n	int
++	O
;	O
while	O
(	O
names	*(char)
[	O
n	int
]	O
==	O
' '	O
)	O
n	int
++	O
;	O
}	O
codes	*(char)
[	O
c	int
]	O
=	O
'\0'	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
categ1	(*(*(double)),int,*(int),int,*(()->(double)),*(double),*(char),*(char),int,int,int,array(int),array(int),int,*(char))->(void)
(	O
double	O
*	O
*	O
tab	*(*(double))
,	O
int	O
ncell	int
,	O
int	O
*	O
varv	array(int)
,	O
int	O
nvar	int
,	O
double	O
(	O
*	O
expect	*(()->(double))
)	O
(	O
)	O
,	O
double	O
*	O
param	*(double)
,	O
char	O
*	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
,	O
char	O
*	O
selcodes	*(char)
,	O
int	O
param1n	int
,	O
int	O
param2n	int
,	O
int	O
covn	int
,	O
int	O
partv	array(int)
[	O
]	O
,	O
int	O
partv2	array(int)
[	O
]	O
,	O
int	O
npart	int
,	O
char	O
*	O
trace	*(char)
)	O
{	O
int	O
typen	int
;	O
int	O
sparam	int
;	O
int	O
sparamr	int
;	O
int	O
nparam	int
;	O
int	O
c	int
,	O
c1	int
,	O
c0	int
;	O
double	O
*	O
x	array(double)
;	O
double	O
*	O
xch	*(double)
;	O
int	O
p	double
;	O
double	O
step	()->(int)
,	O
tol	double
;	O
double	O
tmp	double
;	O
int	O
v	int
;	O
double	O
likerat	double
;	O
double	O
likered	double
;	O
double	O
pearson	double
;	O
double	O
*	O
infomem	*(double)
;	O
double	O
*	O
*	O
info	*(*(double))
;	O
int	O
p1	int
,	O
p2	int
;	O
double	O
lpp	double
,	O
lpm	double
,	O
lmp	double
,	O
lmm	double
;	O
double	O
h	double
,	O
halfh	double
;	O
int	O
s	int
,	O
s1	int
;	O
int	O
nonsing	int
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(categ1) missing _type_ variable\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
sparamr	int
=	O
0	int
;	O
likered	double
=	O
0.0	int
;	O
nc	int
=	O
ncell	int
;	O
ex	*(()->(double))
=	O
expect	*(()->(double))
;	O
x	array(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
strlen	(*(char))->(long)
(	O
sel	*(char)
)	O
,	O
""	*(char)
)	O
;	O
xch	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
strlen	(*(char))->(long)
(	O
sel	*(char)
)	O
,	O
""	*(char)
)	O
;	O
if	O
(	O
selred	*(char)
)	O
{	O
sel	*(char)
=	O
selred	*(char)
;	O
for	O
(	O
nparam	int
=	O
0	int
,	O
sparamr	int
=	O
0	int
;	O
sel	*(char)
[	O
nparam	int
]	O
;	O
nparam	int
++	O
)	O
{	O
if	O
(	O
sel	*(char)
[	O
nparam	int
]	O
!=	O
'!'	O
)	O
{	O
allparam	*(double)
[	O
nparam	int
]	O
=	O
param	*(double)
[	O
nparam	int
]	O
;	O
sparamr	int
++	O
;	O
}	O
else	O
allparam	*(double)
[	O
nparam	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
p	double
=	O
0	int
,	O
nparam	int
=	O
0	int
;	O
sel	*(char)
[	O
nparam	int
]	O
;	O
nparam	int
++	O
)	O
{	O
if	O
(	O
sel	*(char)
[	O
nparam	int
]	O
!=	O
'!'	O
)	O
x	array(double)
[	O
p	double
++	O
]	O
=	O
param	*(double)
[	O
nparam	int
]	O
;	O
}	O
for	O
(	O
step	()->(int)
=	O
0.0	int
,	O
p	double
=	O
0	int
;	O
p	double
<	O
sparamr	int
;	O
p	double
++	O
)	O
{	O
tmp	double
=	O
x	array(double)
[	O
p	double
]	O
;	O
step	()->(int)
+=	O
tmp	double
*	O
tmp	double
;	O
}	O
if	O
(	O
step	()->(int)
>	O
0.0	int
)	O
step	()->(int)
=	O
0.1	int
*	O
sqrt	(double)->(double)
(	O
step	()->(int)
)	O
;	O
else	O
step	()->(int)
=	O
0.01	int
;	O
tol	double
=	O
dap_cattol	double
*	O
step	()->(int)
;	O
dap_maximize	(*((array(double))->(double)),int,array(double),double,double,*(char))->(double)
(	O
&	O
loglike	(*(double))->(double)
,	O
sparamr	int
,	O
x	array(double)
,	O
step	()->(int)
,	O
tol	double
,	O
trace	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
0	int
,	O
likerat	double
=	O
0.0	int
;	O
c	int
<	O
ncell	int
;	O
c	int
++	O
)	O
likered	double
+=	O
(	O
tab	*(*(double))
[	O
c	int
]	O
[	O
0	int
]	O
+	O
dap_addtozero	double
)	O
*	O
log	(double)->(double)
(	O
(	O
tab	*(*(double))
[	O
c	int
]	O
[	O
0	int
]	O
+	O
dap_addtozero	double
)	O
/	O
expect	*(()->(double))
(	O
allparam	*(double)
,	O
tab	*(*(double))
[	O
c	int
]	O
+	O
1	int
)	O
)	O
;	O
likered	double
*=	O
2.0	int
;	O
}	O
sel	*(char)
=	O
selcodes	*(char)
;	O
for	O
(	O
nparam	int
=	O
0	int
,	O
sparam	int
=	O
0	int
;	O
sel	*(char)
[	O
nparam	int
]	O
;	O
nparam	int
++	O
)	O
{	O
if	O
(	O
sel	*(char)
[	O
nparam	int
]	O
!=	O
'!'	O
)	O
{	O
allparam	*(double)
[	O
nparam	int
]	O
=	O
param	*(double)
[	O
nparam	int
]	O
;	O
sparam	int
++	O
;	O
}	O
else	O
allparam	*(double)
[	O
nparam	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
p	double
=	O
0	int
,	O
nparam	int
=	O
0	int
;	O
sel	*(char)
[	O
nparam	int
]	O
;	O
nparam	int
++	O
)	O
{	O
if	O
(	O
sel	*(char)
[	O
nparam	int
]	O
!=	O
'!'	O
)	O
x	array(double)
[	O
p	double
++	O
]	O
=	O
param	*(double)
[	O
nparam	int
]	O
;	O
}	O
for	O
(	O
step	()->(int)
=	O
0.0	int
,	O
p	double
=	O
0	int
;	O
p	double
<	O
sparam	int
;	O
p	double
++	O
)	O
{	O
tmp	double
=	O
x	array(double)
[	O
p	double
]	O
;	O
step	()->(int)
+=	O
tmp	double
*	O
tmp	double
;	O
}	O
if	O
(	O
step	()->(int)
>	O
0.0	int
)	O
step	()->(int)
=	O
0.1	int
*	O
sqrt	(double)->(double)
(	O
step	()->(int)
)	O
;	O
else	O
step	()->(int)
=	O
0.01	int
;	O
tol	double
=	O
dap_cattol	double
*	O
step	()->(int)
;	O
dap_maximize	(*((array(double))->(double)),int,array(double),double,double,*(char))->(double)
(	O
&	O
loglike	(*(double))->(double)
,	O
sparam	int
,	O
x	array(double)
,	O
step	()->(int)
,	O
tol	double
,	O
trace	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
0	int
,	O
likerat	double
=	O
0.0	int
,	O
pearson	double
=	O
0.0	int
;	O
c	int
<	O
ncell	int
;	O
c	int
++	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
=	O
tab	*(*(double))
[	O
c	int
]	O
[	O
v	int
]	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"OBS"	*(char)
)	O
;	O
output	()->(void)
(	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"FIT"	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
0	int
]	O
]	O
=	O
expect	*(()->(double))
(	O
allparam	*(double)
,	O
tab	*(*(double))
[	O
c	int
]	O
+	O
1	int
)	O
;	O
likerat	double
+=	O
(	O
tab	*(*(double))
[	O
c	int
]	O
[	O
0	int
]	O
+	O
dap_addtozero	double
)	O
*	O
log	(double)->(double)
(	O
(	O
tab	*(*(double))
[	O
c	int
]	O
[	O
0	int
]	O
+	O
dap_addtozero	double
)	O
/	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
0	int
]	O
]	O
)	O
;	O
tmp	double
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
0	int
]	O
]	O
-	O
tab	*(*(double))
[	O
c	int
]	O
[	O
0	int
]	O
;	O
pearson	double
+=	O
tmp	double
*	O
tmp	double
/	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
0	int
]	O
]	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
likerat	double
*=	O
2.0	int
;	O
infomem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
sparam	int
*	O
sparam	int
,	O
""	*(char)
)	O
;	O
info	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
sparam	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
sparam	int
;	O
p	double
++	O
)	O
info	*(*(double))
[	O
p	double
]	O
=	O
infomem	*(double)
+	O
p	double
*	O
sparam	int
;	O
h	double
=	O
0.0001	int
;	O
halfh	double
=	O
h	double
/	O
2.0	int
;	O
for	O
(	O
p1	int
=	O
0	int
;	O
p1	int
<	O
sparam	int
;	O
p1	int
++	O
)	O
{	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
sparam	int
;	O
p	double
++	O
)	O
xch	*(double)
[	O
p	double
]	O
=	O
x	array(double)
[	O
p	double
]	O
;	O
lpm	double
=	O
loglike	(*(double))->(double)
(	O
xch	*(double)
)	O
;	O
xch	*(double)
[	O
p1	int
]	O
+=	O
h	double
;	O
lpp	double
=	O
loglike	(*(double))->(double)
(	O
xch	*(double)
)	O
;	O
xch	*(double)
[	O
p1	int
]	O
=	O
x	array(double)
[	O
p1	int
]	O
-	O
h	double
;	O
lmm	double
=	O
loglike	(*(double))->(double)
(	O
xch	*(double)
)	O
;	O
info	*(*(double))
[	O
p1	int
]	O
[	O
p1	int
]	O
=	O
-	O
(	O
lpp	double
-	O
2.0	int
*	O
lpm	double
+	O
lmm	double
)	O
/	O
(	O
h	double
*	O
h	double
)	O
;	O
}	O
for	O
(	O
p1	int
=	O
0	int
;	O
p1	int
<	O
sparam	int
;	O
p1	int
++	O
)	O
for	O
(	O
p2	int
=	O
0	int
;	O
p2	int
<	O
p1	int
;	O
p2	int
++	O
)	O
{	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
sparam	int
;	O
p	double
++	O
)	O
xch	*(double)
[	O
p	double
]	O
=	O
x	array(double)
[	O
p	double
]	O
;	O
xch	*(double)
[	O
p1	int
]	O
+=	O
halfh	double
;	O
xch	*(double)
[	O
p2	int
]	O
+=	O
halfh	double
;	O
lpp	double
=	O
loglike	(*(double))->(double)
(	O
xch	*(double)
)	O
;	O
xch	*(double)
[	O
p1	int
]	O
=	O
x	array(double)
[	O
p1	int
]	O
-	O
halfh	double
;	O
lmp	double
=	O
loglike	(*(double))->(double)
(	O
xch	*(double)
)	O
;	O
xch	*(double)
[	O
p2	int
]	O
=	O
x	array(double)
[	O
p2	int
]	O
-	O
halfh	double
;	O
lmm	double
=	O
loglike	(*(double))->(double)
(	O
xch	*(double)
)	O
;	O
xch	*(double)
[	O
p1	int
]	O
=	O
x	array(double)
[	O
p1	int
]	O
+	O
halfh	double
;	O
lpm	double
=	O
loglike	(*(double))->(double)
(	O
xch	*(double)
)	O
;	O
info	*(*(double))
[	O
p1	int
]	O
[	O
p2	int
]	O
=	O
-	O
(	O
lpp	double
-	O
lpm	double
-	O
lmp	double
+	O
lmm	double
)	O
/	O
(	O
h	double
*	O
h	double
)	O
;	O
info	*(*(double))
[	O
p2	int
]	O
[	O
p1	int
]	O
=	O
info	*(*(double))
[	O
p1	int
]	O
[	O
p2	int
]	O
;	O
}	O
if	O
(	O
!	O
(	O
nonsing	int
=	O
dap_invert	(*(*(double)),int)->(int)
(	O
info	*(*(double))
,	O
sparam	int
)	O
)	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(categ1) covariance matrix is singular\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
dap_ono	int
=	O
1	int
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(categ1) output dataset has no _type_ variable\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
npart	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
partv	array(int)
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
partv2	array(int)
[	O
v	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
partv	array(int)
[	O
v	int
]	O
]	O
;	O
else	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
partv	array(int)
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_int	*(int)
[	O
partv2	array(int)
[	O
v	int
]	O
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_int	*(int)
[	O
partv	array(int)
[	O
v	int
]	O
]	O
;	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
partv2	array(int)
[	O
v	int
]	O
]	O
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
partv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Maximum likelihood estimation\n\n"	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cell count: %s\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
0	int
]	O
]	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Class and aux variables:"	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
v	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" %s"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\nStatistic              df      Prob\n"	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"G2[Model]   = %6.2f  %3d    %.4f\n"	*(char)
,	O
likerat	double
,	O
ncell	int
-	O
sparam	int
,	O
(	O
(	O
ncell	int
>	O
sparam	int
)	O
?	O
(	O
ceil	(double)->(double)
(	O
10000.0	int
*	O
probchisq	(double,int)->(double)
(	O
likerat	double
,	O
ncell	int
-	O
sparam	int
)	O
)	O
/	O
10000.0	int
)	O
:	O
1.0	int
)	O
)	O
;	O
if	O
(	O
selred	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"G2[Reduced] = %6.2f  %3d    %.4f\n"	*(char)
,	O
likered	double
,	O
ncell	int
-	O
sparamr	int
,	O
ceil	(double)->(double)
(	O
10000.0	int
*	O
probchisq	(double,int)->(double)
(	O
likered	double
,	O
ncell	int
-	O
sparamr	int
)	O
)	O
/	O
10000.0	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"G2[Diff]    = %6.2f  %3d    %.4f\n"	*(char)
,	O
likered	double
-	O
likerat	double
,	O
sparam	int
-	O
sparamr	int
,	O
ceil	(double)->(double)
(	O
10000.0	int
*	O
probchisq	(double,int)->(double)
(	O
likered	double
-	O
likerat	double
,	O
sparam	int
-	O
sparamr	int
)	O
)	O
/	O
10000.0	int
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"X2[Model]   = %6.2f  %3d    %.4f\n"	*(char)
,	O
pearson	double
,	O
ncell	int
-	O
sparam	int
,	O
(	O
(	O
ncell	int
>	O
sparam	int
)	O
?	O
(	O
ceil	(double)->(double)
(	O
10000.0	int
*	O
probchisq	(double,int)->(double)
(	O
pearson	double
,	O
ncell	int
-	O
sparam	int
)	O
)	O
/	O
10000.0	int
)	O
:	O
1.0	int
)	O
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"    Estimate          ASE  Model  Parameter\n"	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
==	O
' '	O
;	O
c	int
++	O
)	O
;	O
for	O
(	O
p	double
=	O
0	int
,	O
s	int
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%12g "	*(char)
,	O
allparam	*(double)
[	O
p	double
]	O
)	O
;	O
if	O
(	O
sel	*(char)
[	O
p	double
]	O
==	O
'!'	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"              "	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
{	O
if	O
(	O
nonsing	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%12g  "	*(char)
,	O
sqrt	(double)->(double)
(	O
info	*(*(double))
[	O
s	int
]	O
[	O
s	int
]	O
)	O
)	O
;	O
else	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"           ?  "	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
switch	O
(	O
selcodes	*(char)
[	O
p	double
]	O
)	O
{	O
case	O
'1'	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  *    "	*(char)
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"  ?    "	*(char)
)	O
;	O
for	O
(	O
++	O
c	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
==	O
' '	O
;	O
c	int
++	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"       "	*(char)
)	O
;	O
for	O
(	O
++	O
c	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
==	O
' '	O
;	O
c	int
++	O
)	O
;	O
break	O
;	O
}	O
for	O
(	O
p2	int
=	O
0	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
&&	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
!=	O
' '	O
;	O
c	int
++	O
,	O
p2	int
++	O
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
param2n	int
]	O
[	O
p2	int
]	O
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
;	O
}	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
param2n	int
]	O
[	O
p2	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
==	O
' '	O
)	O
c	int
++	O
;	O
if	O
(	O
sel	*(char)
[	O
p	double
]	O
!=	O
'!'	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"ESTIMATE"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
param1n	int
]	O
,	O
""	*(char)
)	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
covn	int
]	O
=	O
allparam	*(double)
[	O
p	double
]	O
;	O
output	()->(void)
(	O
)	O
;	O
s	int
++	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"COVAR"	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
==	O
' '	O
;	O
c	int
++	O
)	O
;	O
for	O
(	O
p	double
=	O
0	int
,	O
s	int
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
{	O
if	O
(	O
selcodes	*(char)
[	O
p	double
]	O
!=	O
'1'	O
)	O
{	O
for	O
(	O
++	O
c	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
==	O
' '	O
;	O
c	int
++	O
)	O
;	O
}	O
while	O
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
==	O
' '	O
)	O
c	int
++	O
;	O
for	O
(	O
c1	int
=	O
0	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c1	int
]	O
==	O
' '	O
;	O
c1	int
++	O
)	O
;	O
for	O
(	O
p1	int
=	O
0	int
,	O
s1	int
=	O
0	int
;	O
p1	int
<	O
nparam	int
;	O
p1	int
++	O
)	O
{	O
if	O
(	O
sel	*(char)
[	O
p	double
]	O
!=	O
'!'	O
&&	O
sel	*(char)
[	O
p1	int
]	O
!=	O
'!'	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
covn	int
]	O
=	O
info	*(*(double))
[	O
s	int
]	O
[	O
s1	int
]	O
;	O
if	O
(	O
sel	*(char)
[	O
p1	int
]	O
!=	O
'!'	O
)	O
s1	int
++	O
;	O
if	O
(	O
selcodes	*(char)
[	O
p1	int
]	O
!=	O
'1'	O
)	O
{	O
for	O
(	O
++	O
c1	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c1	int
]	O
==	O
' '	O
;	O
c1	int
++	O
)	O
;	O
}	O
if	O
(	O
sel	*(char)
[	O
p	double
]	O
!=	O
'!'	O
&&	O
sel	*(char)
[	O
p1	int
]	O
!=	O
'!'	O
)	O
{	O
for	O
(	O
p2	int
=	O
0	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c1	int
]	O
&&	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c1	int
]	O
!=	O
' '	O
;	O
c1	int
++	O
,	O
p2	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
param2n	int
]	O
[	O
p2	int
]	O
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c1	int
]	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
param2n	int
]	O
[	O
p2	int
]	O
=	O
'\0'	O
;	O
c0	int
=	O
c	int
;	O
if	O
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c0	int
]	O
==	O
'?'	O
)	O
{	O
for	O
(	O
c0	int
++	O
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c0	int
]	O
==	O
' '	O
;	O
c0	int
++	O
)	O
;	O
}	O
for	O
(	O
p2	int
=	O
0	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c0	int
]	O
&&	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c0	int
]	O
!=	O
' '	O
;	O
c0	int
++	O
,	O
p2	int
++	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
param1n	int
]	O
[	O
p2	int
]	O
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c0	int
]	O
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
param1n	int
]	O
[	O
p2	int
]	O
=	O
'\0'	O
;	O
output	()->(void)
(	O
)	O
;	O
}	O
while	O
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c1	int
]	O
==	O
' '	O
)	O
c1	int
++	O
;	O
}	O
while	O
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
&&	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
c	int
]	O
!=	O
' '	O
)	O
c	int
++	O
;	O
if	O
(	O
sel	*(char)
[	O
p	double
]	O
!=	O
'!'	O
)	O
s	int
++	O
;	O
}	O
dap_ono	int
=	O
0	int
;	O
dap_free	(*(void),*(char))->(void)
(	O
x	array(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
xch	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
infomem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
info	*(*(double))
,	O
""	*(char)
)	O
;	O
}	O
void	O
categ	(*(char),*(char),*(char),*(()->(double)),*(double),*(char),*(char),*(char))->(void)
(	O
char	O
*	O
dname	array(char)
,	O
char	O
*	O
varlist	array(char)
,	O
char	O
*	O
auxvarlist	*(char)
,	O
double	O
(	O
*	O
expect	*(()->(double))
)	O
(	O
)	O
,	O
double	O
*	O
param	*(double)
,	O
char	O
*	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
,	O
char	O
*	O
part	*(char)
,	O
char	O
*	O
trace	*(char)
)	O
{	O
int	O
p	double
;	O
char	O
*	O
filset	*(char)
;	O
char	O
*	O
filarg	*(char)
;	O
char	O
*	O
catset	*(char)
;	O
char	O
*	O
covset	*(char)
;	O
int	O
param1n	int
,	O
param2n	int
,	O
covn	int
;	O
int	O
paramlen1	int
,	O
paramlen	int
;	O
char	O
paramstr	array(char)
[	O
12	int
]	O
;	O
char	O
*	O
partstr	*(char)
;	O
int	O
*	O
varv	array(int)
;	O
int	O
*	O
partv	array(int)
,	O
*	O
partv2	array(int)
;	O
int	O
ncvar	int
;	O
int	O
navar	int
;	O
int	O
nvar	int
;	O
int	O
npart	int
;	O
int	O
more	int
;	O
int	O
nparam	int
;	O
char	O
*	O
selcodes	*(char)
;	O
double	O
*	O
tabmem	*(double)
;	O
int	O
v	int
;	O
int	O
ncell	int
;	O
int	O
s	int
;	O
varv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	*(char)
)	O
;	O
partv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	*(char)
)	O
;	O
partv2	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	*(char)
)	O
;	O
filarg	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
part	*(char)
)	O
+	O
8	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
filarg	*(char)
,	O
"FILL "	*(char)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
varlist	array(char)
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
v	int
=	O
5	int
;	O
varlist	array(char)
[	O
s	int
]	O
&&	O
varlist	array(char)
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
filarg	*(char)
[	O
v	int
++	O
]	O
=	O
varlist	array(char)
[	O
s	int
++	O
]	O
;	O
filarg	*(char)
[	O
v	int
++	O
]	O
=	O
':'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
filarg	*(char)
+	O
v	int
,	O
part	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
filarg	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
filarg	*(char)
,	O
varlist	array(char)
+	O
s	int
)	O
;	O
filset	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
dname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
filset	*(char)
,	O
dname	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
filset	*(char)
,	O
".fil"	*(char)
)	O
;	O
dataset	(array(char),array(char),*(char))->(void)
(	O
dname	array(char)
,	O
filset	*(char)
,	O
filarg	*(char)
)	O
;	O
catset	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
dname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
catset	*(char)
,	O
dname	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
catset	*(char)
,	O
".cat"	*(char)
)	O
;	O
covset	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
dname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
covset	*(char)
,	O
dname	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
covset	*(char)
,	O
".cov"	*(char)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
,	O
paramlen	int
=	O
0	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
s	int
]	O
;	O
)	O
{	O
while	O
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
s	int
]	O
==	O
' '	O
||	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
s	int
]	O
==	O
'?'	O
||	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
s	int
]	O
==	O
'!'	O
)	O
s	int
++	O
;	O
for	O
(	O
paramlen1	int
=	O
0	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
s	int
]	O
&&	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
[	O
s	int
]	O
!=	O
' '	O
;	O
s	int
++	O
)	O
paramlen1	int
++	O
;	O
if	O
(	O
paramlen1	int
>	O
paramlen	int
)	O
paramlen	int
=	O
paramlen1	int
;	O
}	O
dap_ono	int
=	O
0	int
;	O
inset	(array(char))->(void)
(	O
filset	*(char)
)	O
;	O
ncvar	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
varlist	array(char)
,	O
varv	array(int)
,	O
dap_maxvar	int
)	O
;	O
navar	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
auxvarlist	*(char)
,	O
varv	array(int)
+	O
ncvar	int
,	O
dap_maxvar	int
-	O
ncvar	int
)	O
;	O
nvar	int
=	O
ncvar	int
+	O
navar	int
;	O
for	O
(	O
v	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
!=	O
DBL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(categ) classification or auxiliary variable not of type double: %s\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
varv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
npart	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
part	*(char)
,	O
partv	array(int)
,	O
dap_maxvar	int
)	O
;	O
dap_ono	int
=	O
1	int
;	O
dap_clearobs	(*(char))->(int)
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
paramstr	array(char)
,	O
"_param1_ %d"	*(char)
,	O
paramlen	int
)	O
;	O
param1n	int
=	O
dap_vd	(array(char),int)->(int)
(	O
paramstr	array(char)
,	O
0	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
paramstr	array(char)
,	O
"_param2_ %d"	*(char)
,	O
paramlen	int
)	O
;	O
param2n	int
=	O
dap_vd	(array(char),int)->(int)
(	O
paramstr	array(char)
,	O
0	int
)	O
;	O
covn	int
=	O
dap_vd	(array(char),int)->(int)
(	O
"_cov_ -1"	*(char)
,	O
0	int
)	O
;	O
partstr	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
part	*(char)
)	O
+	O
1	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
npart	int
;	O
v	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
partstr	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
partv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
partstr	*(char)
+	O
strlen	(*(char))->(long)
(	O
partstr	*(char)
)	O
,	O
" %d"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
partv	array(int)
[	O
v	int
]	O
]	O
)	O
;	O
partv2	array(int)
[	O
v	int
]	O
=	O
dap_vd	(array(char),int)->(int)
(	O
partstr	*(char)
,	O
1	int
)	O
;	O
}	O
outset	(array(char),array(char))->(void)
(	O
covset	*(char)
,	O
""	*(char)
)	O
;	O
dap_ono	int
=	O
0	int
;	O
outset	(array(char),array(char))->(void)
(	O
catset	*(char)
,	O
""	*(char)
)	O
;	O
tabmem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
dap_maxcell	int
,	O
""	*(char)
)	O
;	O
tab	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxcell	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
ncell	int
=	O
0	int
;	O
ncell	int
<	O
dap_maxcell	int
;	O
ncell	int
++	O
)	O
tab	*(*(double))
[	O
ncell	int
]	O
=	O
tabmem	*(double)
+	O
ncell	int
*	O
nvar	int
;	O
selcodes	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
)	O
+	O
1	int
,	O
""	*(char)
)	O
;	O
nparam	int
=	O
selparse	(*(char),*(char))->(int)
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
,	O
selcodes	*(char)
)	O
;	O
allparam	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nparam	int
,	O
""	*(char)
)	O
;	O
sel	*(char)
=	O
selcodes	*(char)
;	O
if	O
(	O
index	(*(char),int)->(*(char))
(	O
selcodes	*(char)
,	O
'?'	O
)	O
)	O
{	O
selred	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
nparam	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
selcodes	*(char)
[	O
s	int
]	O
;	O
s	int
++	O
)	O
{	O
if	O
(	O
selcodes	*(char)
[	O
s	int
]	O
==	O
'?'	O
)	O
selred	*(char)
[	O
s	int
]	O
=	O
'!'	O
;	O
else	O
selred	*(char)
[	O
s	int
]	O
=	O
selcodes	*(char)
[	O
s	int
]	O
;	O
}	O
selred	*(char)
[	O
s	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
selred	*(char)
=	O
NULL	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
allparam	*(double)
[	O
p	double
]	O
=	O
param	*(double)
[	O
p	double
]	O
;	O
for	O
(	O
ncell	int
=	O
0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	()->(int)
(	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
partv	array(int)
,	O
npart	int
)	O
)	O
{	O
dap_swap	()->(void)
(	O
)	O
;	O
dap_head	(array(int),int)->(void)
(	O
partv	array(int)
,	O
npart	int
)	O
;	O
categ1	(*(*(double)),int,*(int),int,*(()->(double)),*(double),*(char),*(char),int,int,int,array(int),array(int),int,*(char))->(void)
(	O
tab	*(*(double))
,	O
ncell	int
,	O
varv	array(int)
,	O
nvar	int
,	O
expect	*(()->(double))
,	O
param	*(double)
,	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
,	O
selcodes	*(char)
,	O
param1n	int
,	O
param2n	int
,	O
covn	int
,	O
partv	array(int)
,	O
partv2	array(int)
,	O
npart	int
,	O
trace	*(char)
)	O
;	O
dap_swap	()->(void)
(	O
)	O
;	O
ncell	int
=	O
0	int
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
allparam	*(double)
[	O
p	double
]	O
=	O
param	*(double)
[	O
p	double
]	O
;	O
}	O
if	O
(	O
more	int
)	O
{	O
if	O
(	O
ncell	int
<	O
dap_maxcell	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
tab	*(*(double))
[	O
ncell	int
]	O
[	O
v	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
varv	array(int)
[	O
v	int
]	O
]	O
;	O
ncell	int
++	O
;	O
}	O
else	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(categ) too many cells\n"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
selred	*(char)
)	O
{	O
dap_free	(*(void),*(char))->(void)
(	O
selred	*(char)
,	O
""	*(char)
)	O
;	O
selred	*(char)
=	O
NULL	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
filarg	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
partv	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
partv2	array(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
filset	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
catset	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
covset	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
partstr	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
tabmem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
tab	*(*(double))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
allparam	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
selcodes	*(char)
,	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
*	O
*	O
paramlist	*(*(int))
;	O
static	O
double	O
*	O
maxval	*(double)
;	O
static	O
int	O
numparam	int
;	O
static	O
int	O
nclass	int
;	O
static	O
double	O
llexpect	(*(double),*(double))->(double)
(	O
double	O
*	O
param	*(double)
,	O
double	O
*	O
class	*(double)
)	O
{	O
int	O
p	double
;	O
int	O
c	int
;	O
int	O
neg	array(int)
[	O
MAXCLASS	int
]	O
;	O
double	O
sign	double
;	O
int	O
match	int
;	O
double	O
logc	double
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
neg	array(int)
[	O
c	int
]	O
=	O
(	O
class	*(double)
[	O
c	int
]	O
==	O
maxval	*(double)
[	O
c	int
]	O
)	O
;	O
for	O
(	O
logc	double
=	O
param	*(double)
[	O
0	int
]	O
,	O
p	double
=	O
1	int
;	O
p	double
<	O
numparam	int
;	O
p	double
++	O
)	O
{	O
for	O
(	O
sign	double
=	O
1.0	int
,	O
match	int
=	O
1	int
,	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
paramlist	*(*(int))
[	O
p	double
]	O
[	O
c	int
]	O
>=	O
0	int
)	O
{	O
if	O
(	O
neg	array(int)
[	O
c	int
]	O
)	O
sign	double
*=	O
-	O
1.0	int
;	O
else	O
match	int
&=	O
(	O
paramlist	*(*(int))
[	O
p	double
]	O
[	O
c	int
]	O
==	O
(	O
int	O
)	O
class	*(double)
[	O
c	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
match	int
)	O
logc	double
+=	O
sign	double
*	O
param	*(double)
[	O
p	double
]	O
;	O
}	O
return	O
exp	(double)->(double)
(	O
logc	double
)	O
;	O
}	O
static	O
int	O
findclass	(*(char),*(*(char)))->(int)
(	O
char	O
*	O
cname	*(char)
,	O
char	O
*	O
*	O
class	*(double)
)	O
{	O
int	O
c	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
cname	*(char)
,	O
class	*(double)
[	O
c	int
]	O
)	O
)	O
return	O
c	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
llparse	(*(*(char)),int,*(int),*(char),*(char),*(int))->(int)
(	O
char	O
*	O
*	O
class	*(double)
,	O
int	O
nterm	int
,	O
unsigned	O
int	O
*	O
pattern	*(int)
,	O
char	O
*	O
model0	*(char)
,	O
char	O
*	O
model1	*(char)
,	O
int	O
*	O
term	*(int)
)	O
{	O
int	O
classlen1	int
;	O
int	O
classlen	int
;	O
int	O
nt	int
;	O
int	O
c	int
;	O
int	O
l	int
;	O
int	O
cm	int
;	O
char	O
*	O
oneclass	*(char)
;	O
int	O
oneterm	int
;	O
int	O
m	int
;	O
int	O
t	int
,	O
t1	double
;	O
int	O
firstclass	int
;	O
for	O
(	O
c	int
=	O
0	int
,	O
classlen	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
(	O
classlen1	int
=	O
strlen	(*(char))->(long)
(	O
class	*(double)
[	O
c	int
]	O
)	O
)	O
>	O
classlen	int
)	O
classlen	int
=	O
classlen1	int
;	O
}	O
oneclass	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
classlen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
nterm	int
;	O
t	int
++	O
)	O
term	*(int)
[	O
t	int
]	O
=	O
0	int
;	O
nterm	int
=	O
0	int
;	O
for	O
(	O
m	int
=	O
0	int
;	O
model1	*(char)
[	O
m	int
]	O
==	O
' '	O
;	O
m	int
++	O
)	O
;	O
for	O
(	O
oneterm	int
=	O
0	int
;	O
model1	*(char)
[	O
m	int
]	O
;	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
model1	*(char)
[	O
m	int
]	O
&&	O
model1	*(char)
[	O
m	int
]	O
!=	O
'*'	O
&&	O
model1	*(char)
[	O
m	int
]	O
!=	O
' '	O
;	O
m	int
++	O
)	O
oneclass	*(char)
[	O
c	int
++	O
]	O
=	O
model1	*(char)
[	O
m	int
]	O
;	O
oneclass	*(char)
[	O
c	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
model1	*(char)
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
c	int
=	O
findclass	(*(char),*(*(char)))->(int)
(	O
oneclass	*(char)
,	O
class	*(double)
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(llparse) Unknown class variable %s in model %s\n"	*(char)
,	O
oneclass	*(char)
,	O
model1	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
oneterm	int
|=	O
pattern	*(int)
[	O
c	int
]	O
;	O
if	O
(	O
model1	*(char)
[	O
m	int
]	O
!=	O
'*'	O
)	O
{	O
term	*(int)
[	O
oneterm	int
]	O
=	O
1	int
;	O
if	O
(	O
oneterm	int
>	O
nterm	int
)	O
nterm	int
=	O
oneterm	int
;	O
oneterm	int
=	O
0	int
;	O
}	O
else	O
m	int
++	O
;	O
while	O
(	O
model1	*(char)
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
}	O
for	O
(	O
t1	double
=	O
0	int
;	O
t1	double
<=	O
nterm	int
;	O
t1	double
++	O
)	O
{	O
if	O
(	O
term	*(int)
[	O
t1	double
]	O
)	O
{	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
nterm	int
;	O
t	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
t	int
&	O
~	O
t1	double
)	O
)	O
term	*(int)
[	O
t	int
]	O
=	O
1	int
;	O
}	O
}	O
}	O
for	O
(	O
m	int
=	O
0	int
;	O
model0	*(char)
[	O
m	int
]	O
==	O
' '	O
;	O
m	int
++	O
)	O
;	O
for	O
(	O
oneterm	int
=	O
0	int
;	O
model0	*(char)
[	O
m	int
]	O
;	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
model0	*(char)
[	O
m	int
]	O
&&	O
model0	*(char)
[	O
m	int
]	O
!=	O
'*'	O
&&	O
model0	*(char)
[	O
m	int
]	O
!=	O
' '	O
;	O
m	int
++	O
)	O
oneclass	*(char)
[	O
c	int
++	O
]	O
=	O
model0	*(char)
[	O
m	int
]	O
;	O
oneclass	*(char)
[	O
c	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
model0	*(char)
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
c	int
=	O
findclass	(*(char),*(*(char)))->(int)
(	O
oneclass	*(char)
,	O
class	*(double)
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(llparse) Unknown class variable %s in model %s\n"	*(char)
,	O
oneclass	*(char)
,	O
model0	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
oneterm	int
|=	O
pattern	*(int)
[	O
c	int
]	O
;	O
if	O
(	O
model0	*(char)
[	O
m	int
]	O
!=	O
'*'	O
)	O
{	O
if	O
(	O
!	O
term	*(int)
[	O
oneterm	int
]	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"(llparse) Term in model0 ("	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
c	int
=	O
0	int
,	O
firstclass	int
=	O
1	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
pattern	*(int)
[	O
c	int
]	O
&	O
~	O
oneterm	int
)	O
)	O
{	O
if	O
(	O
firstclass	int
)	O
firstclass	int
=	O
0	int
;	O
else	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"*"	*(char)
,	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
class	*(double)
[	O
c	int
]	O
)	O
;	O
}	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
") not in in model1 (%s)\n"	*(char)
,	O
model1	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
term	*(int)
[	O
oneterm	int
]	O
=	O
2	int
;	O
oneterm	int
=	O
0	int
;	O
}	O
else	O
m	int
++	O
;	O
while	O
(	O
model0	*(char)
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
}	O
for	O
(	O
t1	double
=	O
0	int
;	O
t1	double
<=	O
nterm	int
;	O
t1	double
++	O
)	O
{	O
if	O
(	O
term	*(int)
[	O
t1	double
]	O
==	O
2	int
)	O
{	O
for	O
(	O
t	int
=	O
0	int
;	O
t	int
<	O
nterm	int
;	O
t	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
t	int
&	O
~	O
t1	double
)	O
)	O
term	*(int)
[	O
t	int
]	O
=	O
2	int
;	O
}	O
}	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
oneclass	*(char)
,	O
""	*(char)
)	O
;	O
return	O
nterm	int
;	O
}	O
typedef	O
struct	O
node	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
{	O
char	O
*	O
value	*(char)
;	O
struct	O
node	struct(*(char),*(struct(*(char),*(struct(*(char),*(struct`))))))
*	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
;	O
void	O
loglin	(*(char),*(char),*(char),*(char),*(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
varlist	array(char)
,	O
char	O
*	O
model0	*(char)
,	O
char	O
*	O
model1	*(char)
,	O
char	O
*	O
part	*(char)
)	O
{	O
char	O
*	O
fnamefil	*(char)
;	O
char	O
*	O
filarg	*(char)
;	O
char	O
*	O
fname1	*(char)
;	O
char	O
*	O
catname	*(char)
;	O
char	O
*	O
varlist1	*(char)
;	O
char	O
*	O
outlist	*(char)
;	O
char	O
*	O
vardef	*(char)
;	O
int	O
nvar	int
;	O
int	O
l	int
,	O
l1	int
;	O
int	O
vd	int
;	O
int	O
*	O
classv	*(int)
;	O
int	O
npart	int
;	O
int	O
c	int
,	O
cc	int
;	O
int	O
nv	int
;	O
int	O
coff	int
;	O
double	O
*	O
maxval1	*(double)
;	O
int	O
maxmaxval	int
;	O
int	O
nvl	int
;	O
int	O
firstpart	int
;	O
int	O
more	int
;	O
double	O
oneval	double
;	O
int	O
*	O
term	*(int)
;	O
int	O
nterm	int
;	O
double	O
*	O
param	*(double)
;	O
int	O
termparam	int
;	O
int	O
nparam0	int
;	O
char	O
*	O
classmem	*(char)
;	O
char	O
*	O
*	O
class	*(double)
;	O
int	O
cm	int
;	O
char	O
*	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
;	O
int	O
sellen	int
;	O
int	O
termlen	int
;	O
char	O
*	O
selterm	*(char)
;	O
int	O
s	int
;	O
int	O
*	O
sub	*(int)
;	O
unsigned	O
int	O
*	O
pattern	*(int)
;	O
int	O
t	int
;	O
int	O
*	O
paramlistmem	*(int)
;	O
int	O
p	double
;	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
*	O
*	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
;	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
*	O
*	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
;	O
int	O
*	O
maxlen	*(int)
;	O
int	O
onelen	int
;	O
char	O
formstr	array(char)
[	O
8	int
]	O
;	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
*	O
nodeptr	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
fnamefil	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
fnamefil	*(char)
,	O
fname	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
fnamefil	*(char)
,	O
".fil"	*(char)
)	O
;	O
filarg	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
part	*(char)
)	O
+	O
8	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
filarg	*(char)
,	O
"FILL "	*(char)
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
varlist	array(char)
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
l	int
=	O
5	int
;	O
varlist	array(char)
[	O
s	int
]	O
&&	O
varlist	array(char)
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
filarg	*(char)
[	O
l	int
++	O
]	O
=	O
varlist	array(char)
[	O
s	int
++	O
]	O
;	O
filarg	*(char)
[	O
l	int
++	O
]	O
=	O
':'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
filarg	*(char)
+	O
l	int
,	O
part	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
filarg	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
filarg	*(char)
,	O
varlist	array(char)
+	O
s	int
)	O
;	O
dataset	(array(char),array(char),*(char))->(void)
(	O
fname	array(char)
,	O
fnamefil	*(char)
,	O
filarg	*(char)
)	O
;	O
fname1	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname	array(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
fname1	*(char)
,	O
fname	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
fname1	*(char)
,	O
".llm"	*(char)
)	O
;	O
catname	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
fname1	*(char)
)	O
+	O
5	int
,	O
""	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
catname	*(char)
,	O
fname1	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
catname	*(char)
,	O
".cat"	*(char)
)	O
;	O
for	O
(	O
l	int
=	O
0	int
,	O
nvar	int
=	O
0	int
;	O
varlist	array(char)
[	O
l	int
]	O
;	O
)	O
{	O
while	O
(	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
if	O
(	O
varlist	array(char)
[	O
l	int
]	O
)	O
{	O
nvar	int
++	O
;	O
while	O
(	O
varlist	array(char)
[	O
l	int
]	O
&&	O
varlist	array(char)
[	O
l	int
]	O
!=	O
' '	O
)	O
l	int
++	O
;	O
}	O
}	O
nclass	int
=	O
nvar	int
-	O
1	int
;	O
varlist1	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
nvar	int
+	O
2	int
,	O
""	*(char)
)	O
;	O
outlist	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
nvar	int
+	O
strlen	(*(char))->(long)
(	O
part	*(char)
)	O
+	O
2	int
,	O
""	*(char)
)	O
;	O
vardef	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
)	O
+	O
4	int
,	O
""	*(char)
)	O
;	O
classv	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	*(char)
)	O
;	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
=	O
(	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
*	O
)	O
*	O
nclass	int
,	O
""	*(char)
)	O
;	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
=	O
(	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
*	O
)	O
*	O
nclass	int
,	O
""	*(char)
)	O
;	O
maxlen	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
""	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
fnamefil	*(char)
)	O
;	O
npart	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
part	*(char)
,	O
classv	*(int)
,	O
dap_maxvar	int
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
varlist	array(char)
[	O
l	int
]	O
&&	O
varlist	array(char)
[	O
l	int
]	O
!=	O
' '	O
;	O
)	O
{	O
varlist1	*(char)
[	O
l1	int
]	O
=	O
varlist	array(char)
[	O
l	int
]	O
;	O
outlist	*(char)
[	O
l1	int
++	O
]	O
=	O
varlist	array(char)
[	O
l	int
++	O
]	O
;	O
}	O
coff	int
=	O
l	int
;	O
dap_list	(array(char),array(int),int)->(int)
(	O
varlist	array(char)
+	O
coff	int
,	O
classv	*(int)
+	O
npart	int
,	O
dap_maxvar	int
-	O
npart	int
)	O
;	O
if	O
(	O
nclass	int
>	O
MAXCLASS	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(loglin) Number of classification variables (%d) exceeds %d.\n"	*(char)
,	O
nclass	int
,	O
MAXCLASS	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
varlist1	*(char)
[	O
l1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
c	int
=	O
dap_varnum	(array(char))->(int)
(	O
varlist1	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(loglin) Count variable %s unknown.\n"	*(char)
,	O
varlist1	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
c	int
]	O
>=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(loglin) Count variable %s not of type double.\n"	*(char)
,	O
varlist1	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_len	*(int)
[	O
classv	*(int)
[	O
npart	int
+	O
c	int
]	O
]	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(loglin) Classification variable %s not a string.\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
classv	*(int)
[	O
npart	int
+	O
c	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
classmem	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
varlist	array(char)
+	O
coff	int
)	O
+	O
1	int
,	O
""	*(char)
)	O
;	O
class	*(double)
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
nclass	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
0	int
,	O
cm	int
=	O
0	int
;	O
varlist	array(char)
[	O
l	int
]	O
;	O
)	O
{	O
while	O
(	O
varlist	array(char)
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
if	O
(	O
varlist	array(char)
[	O
l	int
]	O
)	O
{	O
varlist1	*(char)
[	O
l1	int
]	O
=	O
' '	O
;	O
outlist	*(char)
[	O
l1	int
++	O
]	O
=	O
' '	O
;	O
varlist1	*(char)
[	O
l1	int
]	O
=	O
'_'	O
;	O
outlist	*(char)
[	O
l1	int
++	O
]	O
=	O
'_'	O
;	O
vardef	*(char)
[	O
0	int
]	O
=	O
'_'	O
;	O
class	*(double)
[	O
c	int
]	O
=	O
classmem	*(char)
+	O
cm	int
;	O
for	O
(	O
vd	int
=	O
1	int
;	O
varlist	array(char)
[	O
l	int
]	O
&&	O
varlist	array(char)
[	O
l	int
]	O
!=	O
' '	O
;	O
l	int
++	O
)	O
{	O
classmem	*(char)
[	O
cm	int
++	O
]	O
=	O
varlist	array(char)
[	O
l	int
]	O
;	O
vardef	*(char)
[	O
vd	int
++	O
]	O
=	O
varlist	array(char)
[	O
l	int
]	O
;	O
varlist1	*(char)
[	O
l1	int
]	O
=	O
varlist	array(char)
[	O
l	int
]	O
;	O
outlist	*(char)
[	O
l1	int
++	O
]	O
=	O
varlist	array(char)
[	O
l	int
]	O
;	O
}	O
vardef	*(char)
[	O
vd	int
]	O
=	O
'\0'	O
;	O
classmem	*(char)
[	O
cm	int
++	O
]	O
=	O
'\0'	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
vardef	*(char)
,	O
" -1"	*(char)
)	O
;	O
classv	*(int)
[	O
npart	int
+	O
nclass	int
+	O
c	int
++	O
]	O
=	O
dap_vd	(array(char),int)->(int)
(	O
vardef	*(char)
,	O
0	int
)	O
;	O
}	O
}	O
varlist1	*(char)
[	O
l1	int
]	O
=	O
'\0'	O
;	O
outlist	*(char)
[	O
l1	int
]	O
=	O
'\0'	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
" "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
outlist	*(char)
,	O
part	*(char)
)	O
;	O
outset	(array(char),array(char))->(void)
(	O
fname1	*(char)
,	O
outlist	*(char)
)	O
;	O
maxval	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nclass	int
,	O
""	*(char)
)	O
;	O
maxval1	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nclass	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
nclass	int
;	O
nvl	int
++	O
)	O
maxval1	*(double)
[	O
nvl	int
]	O
=	O
0.0	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
classv	*(int)
[	O
npart	int
+	O
nclass	int
+	O
c	int
]	O
]	O
=	O
0.0	int
;	O
maxlen	*(int)
[	O
c	int
]	O
=	O
0	int
;	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
=	O
NULL	O
;	O
}	O
for	O
(	O
firstpart	int
=	O
1	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	()->(int)
(	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
classv	*(int)
,	O
npart	int
)	O
)	O
{	O
if	O
(	O
firstpart	int
)	O
{	O
for	O
(	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
nclass	int
;	O
nvl	int
++	O
)	O
maxval	*(double)
[	O
nvl	int
]	O
=	O
maxval1	*(double)
[	O
nvl	int
]	O
;	O
firstpart	int
=	O
0	int
;	O
}	O
else	O
{	O
for	O
(	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
nclass	int
;	O
nvl	int
++	O
)	O
{	O
if	O
(	O
maxval	*(double)
[	O
nvl	int
]	O
!=	O
maxval1	*(double)
[	O
nvl	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(loglin) Variable %s has different numbers of levels in different parts of dataset %s\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
classv	*(int)
[	O
npart	int
+	O
nvl	int
]	O
]	O
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
nclass	int
;	O
nvl	int
++	O
)	O
{	O
maxval1	*(double)
[	O
nvl	int
]	O
=	O
0.0	int
;	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
classv	*(int)
[	O
npart	int
+	O
nclass	int
+	O
nvl	int
]	O
]	O
=	O
0.0	int
;	O
}	O
}	O
if	O
(	O
more	int
)	O
{	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
classv	*(int)
,	O
npart	int
)	O
)	O
nv	int
=	O
nclass	int
+	O
1	int
;	O
else	O
{	O
for	O
(	O
nv	int
=	O
1	int
;	O
nv	int
<=	O
nclass	int
;	O
nv	int
++	O
)	O
{	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
classv	*(int)
,	O
npart	int
+	O
nv	int
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
nv	int
<=	O
nclass	int
)	O
{	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
classv	*(int)
[	O
npart	int
+	O
nclass	int
+	O
nv	int
-	O
1	int
]	O
]	O
+=	O
1.0	int
;	O
oneval	double
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
classv	*(int)
[	O
npart	int
+	O
nclass	int
+	O
nv	int
-	O
1	int
]	O
]	O
;	O
if	O
(	O
oneval	double
>	O
99.0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(loglin) Number of levels (%g) for %s exceeds maximum (100)\n"	*(char)
,	O
oneval	double
+	O
1.0	int
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
classv	*(int)
[	O
npart	int
+	O
nclass	int
+	O
nv	int
-	O
1	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
oneval	double
>	O
maxval1	*(double)
[	O
nv	int
-	O
1	int
]	O
)	O
{	O
maxval1	*(double)
[	O
nv	int
-	O
1	int
]	O
=	O
oneval	double
;	O
onelen	int
=	O
strlen	(*(char))->(long)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
classv	*(int)
[	O
npart	int
+	O
nv	int
-	O
1	int
]	O
]	O
)	O
;	O
if	O
(	O
onelen	int
>	O
maxlen	*(int)
[	O
nv	int
-	O
1	int
]	O
)	O
maxlen	*(int)
[	O
nv	int
-	O
1	int
]	O
=	O
onelen	int
;	O
if	O
(	O
firstpart	int
)	O
{	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nv	int
-	O
1	int
]	O
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
(	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
)	O
,	O
""	*(char)
)	O
;	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nv	int
-	O
1	int
]	O
=	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nv	int
-	O
1	int
]	O
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nv	int
-	O
1	int
]	O
->	O
value	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
onelen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nv	int
-	O
1	int
]	O
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nv	int
-	O
1	int
]	O
->	O
value	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
classv	*(int)
[	O
npart	int
+	O
nv	int
-	O
1	int
]	O
]	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
firstpart	int
)	O
{	O
for	O
(	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
nclass	int
;	O
nvl	int
++	O
)	O
{	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nvl	int
]	O
=	O
(	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
valnode	struct(*(char),*(struct(*(char),*(struct(*`,*`)))))
)	O
,	O
""	*(char)
)	O
;	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nvl	int
]	O
=	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nvl	int
]	O
;	O
onelen	int
=	O
strlen	(*(char))->(long)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
classv	*(int)
[	O
npart	int
+	O
nvl	int
]	O
]	O
)	O
;	O
if	O
(	O
onelen	int
>	O
maxlen	*(int)
[	O
nvl	int
]	O
)	O
maxlen	*(int)
[	O
nvl	int
]	O
=	O
onelen	int
;	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nvl	int
]	O
->	O
value	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
onelen	int
+	O
1	int
,	O
""	*(char)
)	O
;	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nvl	int
]	O
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
NULL	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
nvl	int
]	O
->	O
value	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
classv	*(int)
[	O
npart	int
+	O
nvl	int
]	O
]	O
)	O
;	O
}	O
}	O
for	O
(	O
c	int
=	O
nv	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
classv	*(int)
[	O
npart	int
+	O
nclass	int
+	O
c	int
]	O
]	O
!=	O
maxval1	*(double)
[	O
c	int
]	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(loglin) Variable %s has different numbers of levels\n"	*(char)
,	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_nam	*(*(char))
[	O
classv	*(int)
[	O
npart	int
+	O
c	int
]	O
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
classv	*(int)
[	O
npart	int
+	O
nclass	int
+	O
c	int
]	O
]	O
=	O
0.0	int
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
}	O
dap_head	(array(int),int)->(void)
(	O
NULL	O
,	O
0	int
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Loglinear model:\nnumerical indexes of classification variables\n\n"	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Number"	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
maxmaxval	int
=	O
0	int
,	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
onelen	int
=	O
strlen	(*(char))->(long)
(	O
class	*(double)
[	O
c	int
]	O
)	O
;	O
if	O
(	O
maxlen	*(int)
[	O
c	int
]	O
<	O
onelen	int
)	O
maxlen	*(int)
[	O
c	int
]	O
=	O
onelen	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
formstr	array(char)
,	O
"  %%-%ds"	*(char)
,	O
maxlen	*(int)
[	O
c	int
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
formstr	array(char)
,	O
class	*(double)
[	O
c	int
]	O
)	O
;	O
if	O
(	O
(	O
(	O
int	O
)	O
maxval	*(double)
[	O
c	int
]	O
)	O
>	O
maxmaxval	int
)	O
maxmaxval	int
=	O
(	O
(	O
int	O
)	O
maxval	*(double)
[	O
c	int
]	O
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"------"	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
maxlen	*(int)
[	O
c	int
]	O
;	O
cc	int
++	O
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'-'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
=	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<=	O
maxmaxval	int
;	O
cc	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%6d"	*(char)
,	O
cc	int
+	O
1	int
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
formstr	array(char)
,	O
"  %%-%ds"	*(char)
,	O
maxlen	*(int)
[	O
c	int
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
formstr	array(char)
,	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
->	O
value	*(char)
)	O
;	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
=	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
}	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
formstr	array(char)
,	O
"  %%%ds"	*(char)
,	O
maxlen	*(int)
[	O
c	int
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
formstr	array(char)
,	O
""	*(char)
)	O
;	O
}	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
nterm	int
=	O
1	int
,	O
nv	int
=	O
0	int
;	O
nv	int
<	O
nclass	int
;	O
nv	int
++	O
)	O
nterm	int
*=	O
2	int
;	O
term	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nterm	int
,	O
""	*(char)
)	O
;	O
pattern	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
1	int
,	O
pattern	*(int)
[	O
0	int
]	O
=	O
1	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
pattern	*(int)
[	O
c	int
]	O
=	O
2	int
*	O
pattern	*(int)
[	O
c	int
-	O
1	int
]	O
;	O
nterm	int
=	O
llparse	(*(*(char)),int,*(int),*(char),*(char),*(int))->(int)
(	O
class	*(double)
,	O
nterm	int
,	O
pattern	*(int)
,	O
model0	*(char)
,	O
model1	*(char)
,	O
term	*(int)
)	O
;	O
for	O
(	O
nparam0	int
=	O
1	int
,	O
sellen	int
=	O
5	int
,	O
t	int
=	O
1	int
;	O
t	int
<=	O
nterm	int
;	O
t	int
++	O
)	O
{	O
if	O
(	O
term	*(int)
[	O
t	int
]	O
)	O
{	O
for	O
(	O
termparam	int
=	O
1	int
,	O
c	int
=	O
0	int
,	O
termlen	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
pattern	*(int)
[	O
c	int
]	O
&	O
~	O
t	int
)	O
)	O
{	O
termparam	int
*=	O
(	O
int	O
)	O
maxval	*(double)
[	O
c	int
]	O
;	O
termlen	int
+=	O
strlen	(*(char))->(long)
(	O
class	*(double)
[	O
c	int
]	O
)	O
+	O
4	int
;	O
}	O
}	O
nparam0	int
+=	O
termparam	int
;	O
sellen	int
+=	O
termparam	int
*	O
(	O
termlen	int
+	O
2	int
)	O
;	O
}	O
}	O
param	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nparam0	int
,	O
""	*(char)
)	O
;	O
paramlistmem	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nparam0	int
*	O
nclass	int
,	O
""	*(char)
)	O
;	O
paramlist	*(*(int))
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
nparam0	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam0	int
;	O
p	double
++	O
)	O
paramlist	*(*(int))
[	O
p	double
]	O
=	O
paramlistmem	*(int)
+	O
p	double
*	O
nclass	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
sellen	int
,	O
""	*(char)
)	O
;	O
selterm	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
sellen	int
,	O
""	*(char)
)	O
;	O
sub	*(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
nclass	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
t	int
=	O
1	int
,	O
strcpy	(*(char),*(char))->(*(char))
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
,	O
"_mu"	*(char)
)	O
,	O
numparam	int
=	O
0	int
;	O
t	int
<=	O
nterm	int
;	O
t	int
++	O
)	O
{	O
selterm	*(char)
[	O
0	int
]	O
=	O
' '	O
;	O
selterm	*(char)
[	O
1	int
]	O
=	O
' '	O
;	O
if	O
(	O
term	*(int)
[	O
t	int
]	O
)	O
{	O
if	O
(	O
term	*(int)
[	O
t	int
]	O
==	O
2	int
||	O
!	O
model0	*(char)
[	O
0	int
]	O
)	O
selterm	*(char)
[	O
1	int
]	O
=	O
' '	O
;	O
else	O
selterm	*(char)
[	O
1	int
]	O
=	O
'?'	O
;	O
selterm	*(char)
[	O
2	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
pattern	*(int)
[	O
c	int
]	O
&	O
~	O
t	int
)	O
)	O
{	O
if	O
(	O
!	O
selterm	*(char)
[	O
2	int
]	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
selterm	*(char)
,	O
class	*(double)
[	O
c	int
]	O
)	O
;	O
else	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
selterm	*(char)
,	O
"*"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
selterm	*(char)
,	O
class	*(double)
[	O
c	int
]	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
sub	*(int)
[	O
c	int
]	O
=	O
1	int
;	O
do	O
{	O
numparam	int
++	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
,	O
selterm	*(char)
)	O
;	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
nclass	int
;	O
cc	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
pattern	*(int)
[	O
cc	int
]	O
&	O
~	O
t	int
)	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
,	O
":"	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
+	O
strlen	(*(char))->(long)
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
)	O
,	O
"%d"	*(char)
,	O
sub	*(int)
[	O
cc	int
]	O
)	O
;	O
paramlist	*(*(int))
[	O
numparam	int
]	O
[	O
cc	int
]	O
=	O
sub	*(int)
[	O
cc	int
]	O
-	O
1	int
;	O
}	O
else	O
paramlist	*(*(int))
[	O
numparam	int
]	O
[	O
cc	int
]	O
=	O
-	O
1	int
;	O
}	O
for	O
(	O
c	int
=	O
nclass	int
-	O
1	int
;	O
c	int
>=	O
0	int
;	O
c	int
--	O
)	O
{	O
if	O
(	O
!	O
(	O
pattern	*(int)
[	O
c	int
]	O
&	O
~	O
t	int
)	O
&&	O
sub	*(int)
[	O
c	int
]	O
<	O
(	O
int	O
)	O
maxval	*(double)
[	O
c	int
]	O
)	O
{	O
sub	*(int)
[	O
c	int
]	O
++	O
;	O
for	O
(	O
cc	int
=	O
c	int
+	O
1	int
;	O
cc	int
<	O
nclass	int
;	O
cc	int
++	O
)	O
sub	*(int)
[	O
cc	int
]	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
while	O
(	O
c	int
>=	O
0	int
)	O
;	O
}	O
}	O
numparam	int
++	O
;	O
param	*(double)
[	O
0	int
]	O
=	O
1.0	int
;	O
for	O
(	O
p	double
=	O
1	int
;	O
p	double
<	O
numparam	int
;	O
p	double
++	O
)	O
param	*(double)
[	O
p	double
]	O
=	O
0.0	int
;	O
categ	(*(char),*(char),*(char),*(()->(double)),*(double),*(char),*(char),*(char))->(void)
(	O
fname1	*(char)
,	O
varlist1	*(char)
,	O
""	*(char)
,	O
&	O
llexpect	(*(double),*(double))->(double)
,	O
param	*(double)
,	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
,	O
part	*(char)
,	O
""	*(char)
)	O
;	O
inset	(array(char))->(void)
(	O
catname	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
vardef	*(char)
,	O
class	*(double)
[	O
c	int
]	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
vardef	*(char)
+	O
strlen	(*(char))->(long)
(	O
vardef	*(char)
)	O
,	O
" %d"	*(char)
,	O
maxlen	*(int)
[	O
c	int
]	O
)	O
;	O
classv	*(int)
[	O
c	int
]	O
=	O
dap_vd	(array(char),int)->(int)
(	O
vardef	*(char)
,	O
0	int
)	O
;	O
}	O
outset	(array(char),array(char))->(void)
(	O
fname1	*(char)
,	O
""	*(char)
)	O
;	O
dap_list	(array(char),array(int),int)->(int)
(	O
varlist1	*(char)
,	O
classv	*(int)
+	O
nclass	int
,	O
nclass	int
+	O
1	int
)	O
;	O
while	O
(	O
step	()->(int)
(	O
)	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
for	O
(	O
nodeptr	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
,	O
nvl	int
=	O
0	int
;	O
nvl	int
<	O
(	O
int	O
)	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_dbl	*(double)
[	O
classv	*(int)
[	O
nclass	int
+	O
1	int
+	O
c	int
]	O
]	O
;	O
nvl	int
++	O
)	O
nodeptr	*(struct(*(char),*(struct(*(char),*(struct`)))))
=	O
nodeptr	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
0	int
]	O
.	O
do_str	*(*(char))
[	O
classv	*(int)
[	O
c	int
]	O
]	O
,	O
nodeptr	*(struct(*(char),*(struct(*(char),*(struct`)))))
->	O
value	*(char)
)	O
;	O
}	O
output	()->(void)
(	O
)	O
;	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
fnamefil	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
filarg	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
fname1	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
catname	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
varlist1	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
outlist	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
vardef	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
classv	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
maxval	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
maxval1	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
term	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
param	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
selterm	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
sub	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
classmem	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
class	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
pattern	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
paramlistmem	*(int)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
paramlist	*(*(int))
,	O
""	*(char)
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nclass	int
;	O
c	int
++	O
)	O
{	O
while	O
(	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
)	O
{	O
dap_free	(*(void),*(char))->(void)
(	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
->	O
value	*(char)
,	O
""	*(char)
)	O
;	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
=	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
->	O
next	*(struct(*(char),*(struct(*(char),*(struct`)))))
;	O
dap_free	(*(void),*(char))->(void)
(	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
,	O
""	*(char)
)	O
;	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
=	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
[	O
c	int
]	O
;	O
}	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
classval	*(*(struct(*(char),*(struct(*`,*`)))))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
endcv	*(*(struct(*(char),*(struct(*`,*`)))))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
maxlen	*(int)
,	O
""	*(char)
)	O
;	O
}	O
static	O
int	O
findparam	(*(char),array(*(char)),int)->(int)
(	O
char	O
*	O
pname	*(char)
,	O
char	O
*	O
param	*(double)
[	O
]	O
,	O
int	O
nparam	int
)	O
{	O
int	O
p	double
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
pname	*(char)
,	O
param	*(double)
[	O
p	double
]	O
)	O
)	O
return	O
p	double
;	O
}	O
return	O
-	O
1	int
;	O
}	O
void	O
estimate	(*(char),*(char),*(char),*(char))->(void)
(	O
char	O
*	O
fname	array(char)
,	O
char	O
*	O
parameters	*(char)
,	O
char	O
*	O
definitions	*(char)
,	O
char	O
*	O
part	*(char)
)	O
{	O
char	O
*	O
parammem	*(char)
;	O
char	O
*	O
*	O
param	*(double)
;	O
int	O
start	int
,	O
end	int
;	O
int	O
nparam	int
;	O
int	O
p	double
,	O
p1	int
;	O
int	O
defstate	int
;	O
double	O
*	O
defmem	*(double)
;	O
double	O
*	O
*	O
def	*(*(double))
;	O
double	O
coeff	double
;	O
double	O
sign	double
;	O
double	O
place	double
;	O
int	O
pnum1	int
,	O
pnum2	int
,	O
pnum3	int
;	O
int	O
defnum	int
;	O
int	O
ninput	int
;	O
double	O
*	O
estimate	(*(char),*(char),*(char),*(char))->(void)
;	O
double	O
*	O
covmem	*(double)
;	O
double	O
*	O
*	O
cov	*(*(double))
;	O
int	O
typen	int
,	O
param1n	int
,	O
param2n	int
,	O
covn	int
;	O
int	O
more	int
;	O
int	O
*	O
partv	array(int)
;	O
int	O
npart	int
;	O
parammem	*(char)
=	O
dap_malloc	(int,*(char))->(*(char))
(	O
strlen	(*(char))->(long)
(	O
parameters	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
definitions	*(char)
)	O
+	O
1	int
,	O
""	*(char)
)	O
;	O
nparam	int
=	O
(	O
strlen	(*(char))->(long)
(	O
parameters	*(char)
)	O
+	O
strlen	(*(char))->(long)
(	O
definitions	*(char)
)	O
)	O
/	O
2	int
;	O
param	*(double)
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
nparam	int
,	O
""	*(char)
)	O
;	O
defmem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nparam	int
*	O
nparam	int
,	O
""	*(char)
)	O
;	O
def	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nparam	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
{	O
def	*(*(double))
[	O
p	double
]	O
=	O
defmem	*(double)
+	O
p	double
*	O
nparam	int
;	O
for	O
(	O
p1	int
=	O
0	int
;	O
p1	int
<	O
nparam	int
;	O
p1	int
++	O
)	O
def	*(*(double))
[	O
p	double
]	O
[	O
p1	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
start	int
=	O
0	int
;	O
parameters	*(char)
[	O
start	int
]	O
==	O
' '	O
;	O
start	int
++	O
)	O
;	O
for	O
(	O
nparam	int
=	O
0	int
,	O
p	double
=	O
0	int
;	O
parameters	*(char)
[	O
start	int
]	O
;	O
start	int
=	O
end	int
)	O
{	O
param	*(double)
[	O
nparam	int
++	O
]	O
=	O
parammem	*(char)
+	O
p	double
;	O
for	O
(	O
end	int
=	O
start	int
;	O
parameters	*(char)
[	O
end	int
]	O
&&	O
parameters	*(char)
[	O
end	int
]	O
!=	O
' '	O
;	O
)	O
parammem	*(char)
[	O
p	double
++	O
]	O
=	O
parameters	*(char)
[	O
end	int
++	O
]	O
;	O
parammem	*(char)
[	O
p	double
++	O
]	O
=	O
'\0'	O
;	O
while	O
(	O
parameters	*(char)
[	O
end	int
]	O
==	O
' '	O
)	O
end	int
++	O
;	O
}	O
ninput	int
=	O
nparam	int
;	O
for	O
(	O
start	int
=	O
0	int
;	O
definitions	*(char)
[	O
start	int
]	O
==	O
' '	O
;	O
start	int
++	O
)	O
;	O
for	O
(	O
defstate	int
=	O
0	int
;	O
definitions	*(char)
[	O
start	int
]	O
;	O
start	int
=	O
end	int
)	O
{	O
param	*(double)
[	O
nparam	int
]	O
=	O
parammem	*(char)
+	O
p	double
;	O
if	O
(	O
definitions	*(char)
[	O
start	int
]	O
==	O
'+'	O
||	O
definitions	*(char)
[	O
start	int
]	O
==	O
'-'	O
)	O
{	O
sign	double
=	O
2.0	int
*	O
(	O
(	O
double	O
)	O
(	O
definitions	*(char)
[	O
start	int
]	O
==	O
'+'	O
)	O
)	O
-	O
1.0	int
;	O
for	O
(	O
start	int
++	O
;	O
definitions	*(char)
[	O
start	int
]	O
==	O
' '	O
;	O
start	int
++	O
)	O
;	O
}	O
if	O
(	O
definitions	*(char)
[	O
start	int
]	O
==	O
'.'	O
||	O
(	O
'0'	O
<=	O
definitions	*(char)
[	O
start	int
]	O
&&	O
definitions	*(char)
[	O
start	int
]	O
<=	O
'9'	O
)	O
)	O
{	O
for	O
(	O
coeff	double
=	O
0.0	int
,	O
place	double
=	O
0.0	int
;	O
definitions	*(char)
[	O
start	int
]	O
==	O
'.'	O
||	O
(	O
'0'	O
<=	O
definitions	*(char)
[	O
start	int
]	O
&&	O
definitions	*(char)
[	O
start	int
]	O
<=	O
'9'	O
)	O
;	O
start	int
++	O
)	O
{	O
if	O
(	O
definitions	*(char)
[	O
start	int
]	O
==	O
'.'	O
)	O
{	O
if	O
(	O
place	double
>	O
0.0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(estimate) bad coefficient in definition: %s\n"	*(char)
,	O
definitions	*(char)
+	O
start	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
else	O
place	double
=	O
1.0	int
;	O
}	O
else	O
{	O
coeff	double
=	O
10.0	int
*	O
coeff	double
+	O
(	O
double	O
)	O
(	O
definitions	*(char)
[	O
start	int
]	O
-	O
'0'	O
)	O
;	O
if	O
(	O
place	double
>	O
0.0	int
)	O
place	double
*=	O
10.0	int
;	O
}	O
}	O
coeff	double
*=	O
sign	double
;	O
if	O
(	O
place	double
>	O
0.0	int
)	O
coeff	double
/=	O
place	double
;	O
while	O
(	O
definitions	*(char)
[	O
start	int
]	O
==	O
' '	O
)	O
start	int
++	O
;	O
}	O
else	O
coeff	double
=	O
sign	double
;	O
for	O
(	O
end	int
=	O
start	int
;	O
definitions	*(char)
[	O
end	int
]	O
&&	O
definitions	*(char)
[	O
end	int
]	O
!=	O
' '	O
&&	O
definitions	*(char)
[	O
end	int
]	O
!=	O
'='	O
&&	O
definitions	*(char)
[	O
end	int
]	O
!=	O
'+'	O
&&	O
definitions	*(char)
[	O
end	int
]	O
!=	O
'-'	O
;	O
)	O
parammem	*(char)
[	O
p	double
++	O
]	O
=	O
definitions	*(char)
[	O
end	int
++	O
]	O
;	O
parammem	*(char)
[	O
p	double
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
pnum1	int
=	O
findparam	(*(char),array(*(char)),int)->(int)
(	O
param	*(double)
[	O
nparam	int
]	O
,	O
param	*(double)
,	O
nparam	int
)	O
)	O
<	O
0	int
)	O
nparam	int
++	O
;	O
else	O
p	double
=	O
param	*(double)
[	O
nparam	int
]	O
-	O
parammem	*(char)
;	O
while	O
(	O
definitions	*(char)
[	O
end	int
]	O
==	O
' '	O
)	O
end	int
++	O
;	O
switch	O
(	O
defstate	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
definitions	*(char)
[	O
end	int
]	O
==	O
'='	O
)	O
{	O
defstate	int
=	O
1	int
;	O
for	O
(	O
end	int
++	O
;	O
definitions	*(char)
[	O
end	int
]	O
==	O
' '	O
;	O
end	int
++	O
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(estimate) definition starting at %s missing an =\n"	*(char)
,	O
definitions	*(char)
+	O
start	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
defnum	int
=	O
nparam	int
-	O
1	int
;	O
sign	double
=	O
1.0	int
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
pnum1	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(estimate) undefined parameter %s in definition\n"	*(char)
,	O
param	*(double)
[	O
nparam	int
-	O
1	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
sign	double
==	O
0.0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(estimate) missing sign or coefficient for parameter %s in definition\n"	*(char)
,	O
param	*(double)
[	O
nparam	int
-	O
1	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
def	*(*(double))
[	O
defnum	int
]	O
[	O
pnum1	int
]	O
=	O
coeff	double
;	O
if	O
(	O
definitions	*(char)
[	O
end	int
]	O
!=	O
'+'	O
&&	O
definitions	*(char)
[	O
end	int
]	O
!=	O
'-'	O
)	O
defstate	int
=	O
0	int
;	O
sign	double
=	O
0.0	int
;	O
break	O
;	O
}	O
}	O
estimate	(*(char),*(char),*(char),*(char))->(void)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nparam	int
,	O
""	*(char)
)	O
;	O
covmem	*(double)
=	O
(	O
double	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
)	O
*	O
nparam	int
*	O
nparam	int
,	O
""	*(char)
)	O
;	O
cov	*(*(double))
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nparam	int
,	O
""	*(char)
)	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
nparam	int
;	O
p	double
++	O
)	O
cov	*(*(double))
[	O
p	double
]	O
=	O
covmem	*(double)
+	O
nparam	int
*	O
p	double
;	O
inset	(array(char))->(void)
(	O
fname	array(char)
)	O
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_type_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(estimate) missing _type_ variable in dataset %s\n"	*(char)
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
param1n	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_param1_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(estimate) missing _param1_ variable in dataset %s\n"	*(char)
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
param2n	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_param2_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(estimate) missing _param2_ variable in dataset %s\n"	*(char)
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
covn	int
=	O
dap_varnum	(array(char))->(int)
(	O
"_cov_"	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(estimate) missing _cov_ variable in dataset %s\n"	*(char)
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
partv	array(int)
=	O
(	O
int	O
*	O
)	O
dap_malloc	(int,*(char))->(*(char))
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	*(char)
)	O
;	O
npart	int
=	O
dap_list	(array(char),array(int),int)->(int)
(	O
part	*(char)
,	O
partv	array(int)
,	O
dap_maxvar	int
)	O
;	O
for	O
(	O
pnum1	int
=	O
0	int
;	O
pnum1	int
<	O
nparam	int
;	O
pnum1	int
++	O
)	O
{	O
estimate	(*(char),*(char),*(char),*(char))->(void)
[	O
pnum1	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
nparam	int
;	O
pnum2	int
++	O
)	O
cov	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
for	O
(	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	()->(int)
(	O
)	O
;	O
if	O
(	O
dap_newpart	(array(int),int)->(int)
(	O
partv	array(int)
,	O
npart	int
)	O
)	O
{	O
dap_swap	()->(void)
(	O
)	O
;	O
dap_head	(array(int),int)->(void)
(	O
partv	array(int)
,	O
npart	int
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"    Estimate           SE  Parameter\n"	*(char)
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
pnum1	int
=	O
ninput	int
;	O
pnum1	int
<	O
nparam	int
;	O
pnum1	int
++	O
)	O
{	O
estimate	(*(char),*(char),*(char),*(char))->(void)
[	O
pnum1	int
]	O
=	O
0.0	int
;	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
pnum1	int
;	O
pnum2	int
++	O
)	O
{	O
if	O
(	O
def	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
&&	O
!	O
finite	(double)->(int)
(	O
estimate	(*(char),*(char),*(char),*(char))->(void)
[	O
pnum2	int
]	O
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_err	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"(estimate) estimate for parameter %s not in dataset %s\n"	*(char)
,	O
param	*(double)
[	O
pnum2	int
]	O
,	O
fname	array(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
estimate	(*(char),*(char),*(char),*(char))->(void)
[	O
pnum1	int
]	O
+=	O
def	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
*	O
estimate	(*(char),*(char),*(char),*(char))->(void)
[	O
pnum2	int
]	O
;	O
}	O
cov	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum1	int
]	O
=	O
0.0	int
;	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
pnum1	int
;	O
pnum2	int
++	O
)	O
{	O
for	O
(	O
pnum3	int
=	O
0	int
;	O
pnum3	int
<	O
pnum1	int
;	O
pnum3	int
++	O
)	O
{	O
coeff	double
=	O
def	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
*	O
def	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum3	int
]	O
;	O
cov	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum1	int
]	O
+=	O
coeff	double
*	O
cov	*(*(double))
[	O
pnum2	int
]	O
[	O
pnum3	int
]	O
;	O
}	O
}	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
pnum1	int
;	O
pnum2	int
++	O
)	O
{	O
cov	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
=	O
0.0	int
;	O
for	O
(	O
pnum3	int
=	O
0	int
;	O
pnum3	int
<	O
pnum1	int
;	O
pnum3	int
++	O
)	O
{	O
coeff	double
=	O
def	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
;	O
cov	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
+=	O
coeff	double
*	O
cov	*(*(double))
[	O
pnum2	int
]	O
[	O
pnum3	int
]	O
;	O
}	O
cov	*(*(double))
[	O
pnum2	int
]	O
[	O
pnum1	int
]	O
=	O
cov	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
;	O
}	O
}	O
for	O
(	O
pnum1	int
=	O
ninput	int
;	O
pnum1	int
<	O
nparam	int
;	O
pnum1	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%12g %12g  %s ="	*(char)
,	O
estimate	(*(char),*(char),*(char),*(char))->(void)
[	O
pnum1	int
]	O
,	O
sqrt	(double)->(double)
(	O
cov	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum1	int
]	O
)	O
,	O
param	*(double)
[	O
pnum1	int
]	O
)	O
;	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
nparam	int
;	O
pnum2	int
++	O
)	O
{	O
if	O
(	O
def	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
!=	O
0.0	int
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
def	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
>	O
0.0	int
)	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'+'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
def	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
==	O
1.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
param	*(double)
[	O
pnum2	int
]	O
)	O
;	O
else	O
if	O
(	O
def	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
==	O
-	O
1.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" -%s"	*(char)
,	O
param	*(double)
[	O
pnum2	int
]	O
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%g%s"	*(char)
,	O
def	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
,	O
param	*(double)
[	O
pnum2	int
]	O
)	O
;	O
}	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
dap_lst	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
dap_swap	()->(void)
(	O
)	O
;	O
for	O
(	O
pnum1	int
=	O
0	int
;	O
pnum1	int
<	O
nparam	int
;	O
pnum1	int
++	O
)	O
{	O
estimate	(*(char),*(char),*(char),*(char))->(void)
[	O
pnum1	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
for	O
(	O
pnum2	int
=	O
0	int
;	O
pnum2	int
<	O
nparam	int
;	O
pnum2	int
++	O
)	O
cov	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
}	O
if	O
(	O
more	int
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"ESTIMATE"	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
pnum2	int
=	O
findparam	(*(char),array(*(char)),int)->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
param2n	int
]	O
,	O
param	*(double)
,	O
ninput	int
)	O
)	O
>=	O
0	int
)	O
estimate	(*(char),*(char),*(char),*(char))->(void)
[	O
pnum2	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
covn	int
]	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
typen	int
]	O
,	O
"COVAR"	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
pnum1	int
=	O
findparam	(*(char),array(*(char)),int)->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
param1n	int
]	O
,	O
param	*(double)
,	O
ninput	int
)	O
)	O
>=	O
0	int
&&	O
(	O
pnum2	int
=	O
findparam	(*(char),array(*(char)),int)->(int)
(	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_str	*(*(char))
[	O
param2n	int
]	O
,	O
param	*(double)
,	O
ninput	int
)	O
)	O
>=	O
0	int
)	O
cov	*(*(double))
[	O
pnum1	int
]	O
[	O
pnum2	int
]	O
=	O
dap_obs	array(struct(*(int),*(*(int)),*(double),*(*(double)),*(*(char)),*(int),*(*(char)),*(int),*(int),*(int),int,int,int,int))
[	O
dap_ono	int
]	O
.	O
do_dbl	*(double)
[	O
covn	int
]	O
;	O
}	O
}	O
}	O
dap_free	(*(void),*(char))->(void)
(	O
parammem	*(char)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
param	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
defmem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
def	*(*(double))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
estimate	(*(char),*(char),*(char),*(char))->(void)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
covmem	*(double)
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
cov	*(*(double))
,	O
""	*(char)
)	O
;	O
dap_free	(*(void),*(char))->(void)
(	O
partv	array(int)
,	O
""	*(char)
)	O
;	O
}	O
