int	O
walker_verbose_flag	int
=	O
0	int
;	O
off_t	long
largest_member_file	long
=	O
0	int
;	O
int	O
walk_dir	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
get_member_file	(*(struct(union(*(struct`),long),char,array(char))))->(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
*	O
get_lang_args	(*(struct(union(*(struct`),long),char,array(char))))->(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
void	O
print_member_file	(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))->(void)
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
)	O
;	O
int	O
walk_sub_dirs	(*(struct(*(*(void)),int,int)))->(int)
(	O
struct	O
dynvec	struct(*(*(void)),int,int)
*	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
)	O
;	O
void	O
reparent_children	(*(struct(union(*(struct`),long),char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(void)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
dlink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
slink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
int	O
classify_link	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
get_link_from_dirent	(*(struct(long,long,short,char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dirent	struct(long,long,short,char,array(char))
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
make_link_from_dirent	(*(struct(long,long,short,char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dirent	struct(long,long,short,char,array(char))
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
get_link_from_string	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
make_link_from_string	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
int	O
lang_wanted	(*(char))->(int)
(	O
char	O
const	O
*	O
lang_name	*(char)
)	O
;	O
char	O
*	O
*	O
append_strings_to_vector	(*(*(char)),*(char),*(char))->(*(*(char)))
(	O
char	O
*	O
*	O
vector_0	*(*(void))
,	O
char	O
*	O
string	*(char)
,	O
char	O
const	O
*	O
delimiter_class	*(char)
)	O
;	O
int	O
vector_length	(*(*(char)))->(int)
(	O
char	O
*	O
*	O
vector	*(*(char))
)	O
;	O
int	O
string_in_vector	(*(char),*(*(char)))->(int)
(	O
char	O
const	O
*	O
string	*(char)
,	O
char	O
*	O
*	O
vector	*(*(char))
)	O
;	O
static	O
int	O
same_as_dot	(*(char))->(int)
(	O
char	O
const	O
*	O
cwd	*(char)
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
fill_link_vector	(*(*(struct(union(*`,long),char,array(char)))),*(struct(union(*(struct`),long),char,array(char))))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
fill_link_vector_1	(*(*(struct(union(*`,long),char,array(char)))),*(struct(union(*(struct`),long),char,array(char))))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
char	O
*	O
fill_dot_dots	(*(char),int)->(*(char))
(	O
char	O
*	O
buf	*(char)
,	O
int	O
levels	int
)	O
;	O
static	O
char	O
*	O
absolute_file_name_1	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
char	O
*	O
buffer	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
unsigned	O
long	O
member_file_hash_1	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
;	O
unsigned	O
long	O
member_file_hash_2	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
;	O
int	O
member_file_hash_compare	(*(void),*(void))->(int)
(	O
void	O
const	O
*	O
x	*(void)
,	O
void	O
const	O
*	O
y	*(void)
)	O
;	O
unsigned	O
long	O
file_link_hash_1	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
;	O
unsigned	O
long	O
file_link_hash_2	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
;	O
int	O
file_link_hash_compare	(*(void),*(void))->(int)
(	O
void	O
const	O
*	O
x	*(void)
,	O
void	O
const	O
*	O
y	*(void)
)	O
;	O
unsigned	O
long	O
dev_ino_hash_1	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
;	O
unsigned	O
long	O
dev_ino_hash_2	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
;	O
int	O
dev_ino_hash_compare	(*(void),*(void))->(int)
(	O
void	O
const	O
*	O
x	*(void)
,	O
void	O
const	O
*	O
y	*(void)
)	O
;	O
int	O
symlink_ancestry	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
find_alias_link	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
maybe_get_member_file	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
static	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
0	int
;	O
static	O
char	O
const	O
white_space	array(char)
[	O
]	O
=	O
" \t\r\n\v\f"	*(char)
;	O
char	O
*	O
xgetcwd	()->(*(char))
(	O
void	O
)	O
;	O
int	O
walk_dir	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
int	O
scannable_files	int
;	O
struct	O
dynvec	struct(*(*(void)),int,int)
*	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
;	O
DIR	struct
*	O
dirp	*(struct)
;	O
if	O
(	O
!	O
chdir_to_link	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
)	O
return	O
0	int
;	O
dirp	*(struct)
=	O
opendir	(*(char))->(*(struct))
(	O
"."	*(char)
)	O
;	O
if	O
(	O
dirp	*(struct)
==	O
0	int
)	O
{	O
char	O
*	O
file_name	*(char)
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
file_name	*(char)
,	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't read directory `%s' (`.' from `%s')"	*(char)
)	O
,	O
file_name	*(char)
,	O
xgetcwd	()->(*(char))
(	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
=	O
make_dynvec	(int)->(*(struct(*(*(void)),int,int)))
(	O
32	int
)	O
;	O
scannable_files	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dirent	struct(long,long,short,char,array(char))
=	O
readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dirp	*(struct)
)	O
;	O
if	O
(	O
dirent	struct(long,long,short,char,array(char))
==	O
0	int
)	O
break	O
;	O
if	O
(	O
IS_DOT_or_DOT_DOT	O
(	O
dirent	struct(long,long,short,char,array(char))
->	O
d_name	array(char)
)	O
)	O
continue	O
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
get_link_from_dirent	(*(struct(long,long,short,char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
dirent	struct(long,long,short,char,array(char))
,	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
!	O
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
&	O
FL_PRUNE	O
)	O
)	O
walk_flink	(*(struct(union(*(struct`),long),char,array(char))),*(struct(*(*(void)),int,int)))->(void)
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
)	O
;	O
}	O
closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
;	O
scannable_files	int
+=	O
walk_sub_dirs	(*(struct(*(*(void)),int,int)))->(int)
(	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
)	O
;	O
dynvec_free	(*(struct(*(*(void)),int,int)))->(void)
(	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
)	O
;	O
return	O
scannable_files	int
;	O
}	O
int	O
walk_sub_dirs	(*(struct(*(*(void)),int,int)))->(int)
(	O
struct	O
dynvec	struct(*(*(void)),int,int)
*	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
sub_dirs	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
sub_dirs_end	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
int	O
total_scannable_files	int
=	O
0	int
;	O
dynvec_freeze	(*(struct(*(*(void)),int,int)))->(void)
(	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
)	O
;	O
sub_dirs_end	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
)	O
&	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
->	O
dv_vec	*(*(void))
[	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
->	O
dv_fill	int
]	O
;	O
sub_dirs	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
)	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
->	O
dv_vec	*(*(void))
;	O
for	O
(	O
;	O
sub_dirs	*(*(struct(union(*(struct`),long),char,array(char))))
<	O
sub_dirs_end	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
sub_dirs	*(*(struct(union(*(struct`),long),char,array(char))))
++	O
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
sub_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
*	O
sub_dirs	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
int	O
scannable_files	int
=	O
walk_dir	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
sub_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
scannable_files	int
)	O
total_scannable_files	int
+=	O
scannable_files	int
;	O
}	O
return	O
total_scannable_files	int
;	O
}	O
void	O
walk_flink	(*(struct(union(*(struct`),long),char,array(char))),*(struct(*(*(void)),int,int)))->(void)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
struct	O
dynvec	struct(*(*(void)),int,int)
*	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
unsigned	O
int	O
old_flags	int
;	O
unsigned	O
int	O
new_flags	int
;	O
new_flags	int
=	O
classify_link	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
new_flags	int
==	O
0	int
)	O
return	O
;	O
old_flags	int
=	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
;	O
if	O
(	O
(	O
old_flags	int
&	O
FL_TYPE_MASK	O
)	O
&&	O
(	O
old_flags	int
&	O
FL_TYPE_MASK	O
)	O
!=	O
(	O
new_flags	int
&	O
FL_TYPE_MASK	O
)	O
)	O
{	O
char	O
*	O
file_name	*(char)
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
file_name	*(char)
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"notice: `%s' was a %s, but is now a %s!"	*(char)
)	O
,	O
file_name	*(char)
,	O
(	O
FL_IS_FILE	O
(	O
old_flags	int
)	O
?	O
_	O
(	O
"file"	*(char)
)	O
:	O
_	O
(	O
"directory"	*(char)
)	O
)	O
,	O
(	O
FL_IS_FILE	O
(	O
new_flags	int
)	O
?	O
_	O
(	O
"file"	*(char)
)	O
:	O
_	O
(	O
"directory"	*(char)
)	O
)	O
)	O
;	O
}	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
=	O
(	O
old_flags	int
&	O
~	O
(	O
FL_TYPE_MASK	O
|	O
FL_SYM_LINK	O
)	O
)	O
|	O
new_flags	int
;	O
if	O
(	O
FL_IS_DIR	O
(	O
new_flags	int
)	O
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
alias_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
alias_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
find_alias_link	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
alias_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
if	O
(	O
!	O
(	O
new_flags	int
&	O
FL_SYM_LINK	O
)	O
)	O
reparent_children	(*(struct(union(*(struct`),long),char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(void)
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
alias_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
}	O
else	O
if	O
(	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
==	O
0	int
)	O
walk_dir	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
else	O
dynvec_append	(*(struct(*(*(void)),int,int)),*(void))->(void)
(	O
sub_dirs_vec	*(struct(*(*(void)),int,int))
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
}	O
else	O
{	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
;	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
=	O
maybe_get_member_file	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
)	O
{	O
if	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
>	O
largest_member_file	long
)	O
largest_member_file	long
=	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
;	O
if	O
(	O
walker_verbose_flag	int
)	O
print_member_file	(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))->(void)
(	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
)	O
;	O
}	O
}	O
}	O
void	O
reparent_children	(*(struct(union(*(struct`),long),char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(void)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
dlink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
slink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
void	O
*	O
*	O
slot	*(void)
=	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
.	O
ht_vec	*(*(void))
;	O
void	O
*	O
*	O
end	*(*(void))
=	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
.	O
ht_vec	*(*(void))
[	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
.	O
ht_size	long
]	O
;	O
for	O
(	O
;	O
slot	*(void)
<	O
end	*(*(void))
;	O
slot	*(void)
++	O
)	O
{	O
if	O
(	O
!	O
HASH_VACANT	O
(	O
*	O
slot	*(void)
)	O
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
child	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
)	O
*	O
slot	*(void)
;	O
if	O
(	O
child	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
==	O
slink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
void	O
*	O
*	O
new_slot	*(*(void))
;	O
*	O
slot	*(void)
=	O
hash_deleted_item	*(void)
;	O
child	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
=	O
dlink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
new_slot	*(*(void))
=	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
child	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
*	O
new_slot	*(*(void))
=	O
child	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
}	O
}	O
}	O
}	O
void	O
mark_member_file_links	(*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))))->(void)
(	O
struct	O
idhead	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
*	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
{	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
*	O
members_0	*(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
=	O
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
*	O
)	O
hash_dump	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(*(void)),*((*(void),*(void))->(int)))->(*(*(void)))
(	O
&	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
idh_member_file_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
0	int
,	O
member_file_qsort_compare	(*(void),*(void))->(int)
)	O
;	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
*	O
end	*(*(void))
=	O
&	O
members_0	*(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
[	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
idh_member_file_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
.	O
ht_fill	long
]	O
;	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
*	O
members	*(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
;	O
long	O
new_index	long
=	O
0	int
;	O
for	O
(	O
members	*(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
=	O
members_0	*(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
;	O
members	*(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
<	O
end	*(*(void))
;	O
members	*(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
++	O
)	O
{	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
=	O
*	O
members	*(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_index	long
=	O
new_index	long
++	O
;	O
for	O
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
!	O
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
&	O
FL_USED	O
)	O
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
)	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
|=	O
FL_USED	O
;	O
}	O
free	(*(void))->(void)
(	O
members_0	*(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
)	O
;	O
}	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
maybe_get_member_file	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
alias_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
;	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
alias_member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
=	O
0	int
;	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
=	O
get_member_file	(*(struct(union(*(struct`),long),char,array(char))))->(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
alias_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
find_alias_link	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
if	O
(	O
alias_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
alias_member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
=	O
find_member_file	(*(struct(union(*(struct`),long),char,array(char))))->(*(struct(*(struct(union`,char,array(char))),*(struct),long)))
(	O
alias_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
&&	O
alias_member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
)	O
{	O
int	O
ancestry	int
=	O
symlink_ancestry	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
int	O
alias_ancestry	int
=	O
symlink_ancestry	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
alias_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_lang_args	*(struct)
!=	O
alias_member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_lang_args	*(struct)
)	O
{	O
char	O
*	O
file_name	*(char)
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
char	O
*	O
alias_file_name	*(char)
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
file_name	*(char)
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
alias_file_name	*(char)
,	O
alias_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: `%s' and `%s' are the same file, but yield different scans!"	*(char)
)	O
,	O
file_name	*(char)
,	O
alias_file_name	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
alias_ancestry	int
>	O
ancestry	int
)	O
{	O
hash_delete	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(void))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_member_file_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
)	O
;	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
&=	O
~	O
FL_MEMBER	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
hash_delete	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(void))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_member_file_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
alias_member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
)	O
;	O
alias_member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
&=	O
~	O
FL_MEMBER	O
;	O
}	O
}	O
return	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
find_alias_link	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
*	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
;	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
*	O
*	O
slot	*(void)
;	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
=	O
(	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
*	O
)	O
obstack_alloc	O
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_dev_ino_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
sizeof	O
(	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
)	O
)	O
;	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
->	O
di_dev	long
=	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_dev	long
;	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
->	O
di_ino	long
=	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_ino	long
;	O
slot	*(void)
=	O
(	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
*	O
*	O
)	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_dev_ino_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
)	O
;	O
if	O
(	O
HASH_VACANT	O
(	O
*	O
slot	*(void)
)	O
)	O
{	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
->	O
di_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
hash_insert_at	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void),*(void))->(*(void))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_dev_ino_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
,	O
slot	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_dev_ino_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
)	O
;	O
return	O
(	O
*	O
slot	*(void)
)	O
->	O
di_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
}	O
}	O
int	O
symlink_ancestry	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
int	O
ancestry	int
=	O
0	int
;	O
while	O
(	O
!	O
IS_ROOT_FILE_LINK	O
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
)	O
{	O
if	O
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
&	O
FL_SYM_LINK	O
)	O
return	O
ancestry	int
;	O
ancestry	int
++	O
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
;	O
}	O
return	O
PATH_MAX	int
;	O
}	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
get_member_file	(*(struct(union(*(struct`),long),char,array(char))))->(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
;	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
*	O
slot	*(void)
;	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
const	O
*	O
args	*(void)
;	O
args	*(void)
=	O
get_lang_args	(*(struct(union(*(struct`),long),char,array(char))))->(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
args	*(void)
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
lang_wanted	(*(char))->(int)
(	O
args	*(void)
->	O
la_language	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_name	*(char)
)	O
)	O
return	O
0	int
;	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
=	O
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
)	O
obstack_alloc	O
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_member_file_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
sizeof	O
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
)	O
)	O
;	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
slot	*(void)
=	O
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
*	O
)	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_member_file_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
)	O
;	O
if	O
(	O
HASH_VACANT	O
(	O
*	O
slot	*(void)
)	O
)	O
{	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_index	long
=	O
-	O
1	int
;	O
hash_insert_at	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void),*(void))->(*(void))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_member_file_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
,	O
slot	*(void)
)	O
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
|=	O
FL_MEMBER	O
;	O
}	O
else	O
{	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_member_file_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
)	O
;	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
=	O
*	O
slot	*(void)
;	O
}	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_lang_args	*(struct)
=	O
args	*(void)
;	O
return	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
;	O
}	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
find_member_file	(*(struct(union(*(struct`),long),char,array(char))))->(*(struct(*(struct(union`,char,array(char))),*(struct),long)))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
key	*(void)
;	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
*	O
slot	*(void)
;	O
key	*(void)
.	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
)	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
slot	*(void)
=	O
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
*	O
)	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_member_file_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
&	O
key	*(void)
)	O
;	O
if	O
(	O
HASH_VACANT	O
(	O
*	O
slot	*(void)
)	O
)	O
return	O
0	int
;	O
return	O
*	O
slot	*(void)
;	O
}	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
*	O
get_lang_args	(*(struct(union(*(struct`),long),char,array(char))))->(*(struct(*(struct(*`,*`,*`,*`,int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*`,*`,*`,*`,int,*`)))))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
struct	O
lang_args	struct(*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))))))
*	O
args	*(void)
=	O
lang_args_list	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
;	O
char	O
*	O
file_name	*(char)
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
while	O
(	O
args	*(void)
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
args	*(void)
->	O
la_pattern	*(char)
,	O
SLASH_CHAR	char
)	O
)	O
{	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
file_name	*(char)
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
fnmatch	(*(char),*(char),int)->(int)
(	O
args	*(void)
->	O
la_pattern	*(char)
,	O
file_name	*(char)
,	O
MAYBE_FNM_CASEFOLD	int
|	O
FNM_FILE_NAME	O
)	O
==	O
0	int
)	O
return	O
(	O
args	*(void)
->	O
la_language	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
?	O
args	*(void)
:	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
fnmatch	(*(char),*(char),int)->(int)
(	O
args	*(void)
->	O
la_pattern	*(char)
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
,	O
MAYBE_FNM_CASEFOLD	int
)	O
==	O
0	int
)	O
return	O
(	O
args	*(void)
->	O
la_language	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
?	O
args	*(void)
:	O
0	int
)	O
;	O
}	O
args	*(void)
=	O
args	*(void)
->	O
la_next	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
;	O
}	O
return	O
(	O
(	O
lang_args_default	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
&&	O
lang_args_default	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
->	O
la_language	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
)	O
?	O
lang_args_default	*(struct(*(struct(*(char),*((*`,int)->(*`)),*((*`,*`,*`)->(*`)),*(()->(void)),int,array(*(char)))),*(char),*(char),*(void),int,*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`)))))
:	O
0	int
)	O
;	O
}	O
void	O
print_member_file	(*(struct(*(struct(union`,char,array(char))),*(struct(*`,*`,*`,*`,int,*`)),long)))->(void)
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
*	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
)	O
{	O
char	O
*	O
file_name	*(char)
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
file_name	*(char)
,	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
printf	(*(char))->(int)
(	O
"%ld: %s: %s\n"	*(char)
,	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_member_file_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
.	O
ht_fill	long
-	O
1	int
,	O
member	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_lang_args	*(struct)
->	O
la_language	*(struct(*(char),*((*(*`),int)->(*(void))),*((*(struct`),*(void),*(int))->(*(struct`))),*(()->(void)),int,array(*(char))))
->	O
lg_name	*(char)
,	O
file_name	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
*	O
langs_included	*(*(char))
;	O
static	O
char	O
*	O
*	O
langs_excluded	*(*(char))
;	O
int	O
lang_wanted	(*(char))->(int)
(	O
char	O
const	O
*	O
lang_name	*(char)
)	O
{	O
if	O
(	O
langs_excluded	*(*(char))
)	O
return	O
!	O
string_in_vector	(*(char),*(*(char)))->(int)
(	O
lang_name	*(char)
,	O
langs_excluded	*(*(char))
)	O
;	O
else	O
if	O
(	O
langs_included	*(*(char))
)	O
return	O
string_in_vector	(*(char),*(*(char)))->(int)
(	O
lang_name	*(char)
,	O
langs_included	*(*(char))
)	O
;	O
else	O
return	O
1	int
;	O
}	O
void	O
include_languages	(*(char))->(void)
(	O
char	O
*	O
lang_names	*(char)
)	O
{	O
if	O
(	O
langs_excluded	*(*(char))
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
0	int
,	O
"can't mix --include and --exclude options"	*(char)
)	O
;	O
langs_included	*(*(char))
=	O
append_strings_to_vector	(*(*(char)),*(char),*(char))->(*(*(char)))
(	O
langs_included	*(*(char))
,	O
lang_names	*(char)
,	O
white_space	array(char)
)	O
;	O
}	O
void	O
exclude_languages	(*(char))->(void)
(	O
char	O
*	O
lang_names	*(char)
)	O
{	O
if	O
(	O
langs_excluded	*(*(char))
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
0	int
,	O
"can't mix --include and --exclude options"	*(char)
)	O
;	O
langs_excluded	*(*(char))
=	O
append_strings_to_vector	(*(*(char)),*(char),*(char))->(*(*(char)))
(	O
langs_excluded	*(*(char))
,	O
lang_names	*(char)
,	O
white_space	array(char)
)	O
;	O
}	O
char	O
*	O
*	O
append_strings_to_vector	(*(*(char)),*(char),*(char))->(*(*(char)))
(	O
char	O
*	O
*	O
vector_0	*(*(void))
,	O
char	O
*	O
string	*(char)
,	O
char	O
const	O
*	O
delimiter_class	*(char)
)	O
{	O
char	O
*	O
*	O
vector	*(*(char))
;	O
if	O
(	O
vector_0	*(*(void))
)	O
{	O
int	O
length	int
=	O
vector_length	(*(*(char)))->(int)
(	O
vector_0	*(*(void))
)	O
;	O
vector_0	*(*(void))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
vector_0	*(*(void))
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
length	int
+	O
2	int
+	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
/	O
2	int
)	O
)	O
;	O
vector	*(*(char))
=	O
&	O
vector_0	*(*(void))
[	O
length	int
]	O
;	O
}	O
else	O
vector	*(*(char))
=	O
vector_0	*(*(void))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
2	int
+	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
/	O
2	int
)	O
)	O
;	O
do	O
*	O
vector	*(*(char))
=	O
strsep	(*(*(char)),*(char))->(*(char))
(	O
&	O
string	*(char)
,	O
delimiter_class	*(char)
)	O
;	O
while	O
(	O
*	O
vector	*(*(char))
++	O
)	O
;	O
return	O
xrealloc	(*(void),long)->(*(void))
(	O
vector_0	*(*(void))
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
vector	*(*(char))
-	O
vector_0	*(*(void))
)	O
)	O
;	O
}	O
int	O
vector_length	(*(*(char)))->(int)
(	O
char	O
*	O
*	O
vector	*(*(char))
)	O
{	O
int	O
length	int
=	O
0	int
;	O
while	O
(	O
*	O
vector	*(*(char))
++	O
)	O
length	int
++	O
;	O
return	O
length	int
;	O
}	O
int	O
string_in_vector	(*(char),*(*(char)))->(int)
(	O
char	O
const	O
*	O
string	*(char)
,	O
char	O
*	O
*	O
vector	*(*(char))
)	O
{	O
while	O
(	O
*	O
vector	*(*(char))
)	O
if	O
(	O
strequ	O
(	O
string	*(char)
,	O
*	O
vector	*(*(char))
++	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
parse_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
char	O
*	O
file_name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
relative_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
char	O
*	O
*	O
links_0	*(*(char))
;	O
char	O
*	O
*	O
links	*(*(char))
;	O
if	O
(	O
IS_ABSOLUTE	O
(	O
file_name	*(char)
)	O
)	O
{	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
get_link_from_string	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
SLASH_STRING	*(char)
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
relative_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
relative_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
else	O
if	O
(	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
else	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
get_current_dir_link	()->(*(struct(union(*(struct`),long),char,array(char))))
(	O
)	O
;	O
links	*(*(char))
=	O
links_0	*(*(char))
=	O
vectorize_string	(*(char),*(char))->(*(*(char)))
(	O
file_name	*(char)
,	O
SLASH_STRING	*(char)
)	O
;	O
while	O
(	O
*	O
links	*(*(char))
)	O
{	O
char	O
const	O
*	O
link_name	*(char)
=	O
*	O
links	*(*(char))
++	O
;	O
if	O
(	O
*	O
link_name	*(char)
==	O
'\0'	O
||	O
IS_DOT	O
(	O
link_name	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
IS_DOT_DOT	O
(	O
link_name	*(char)
)	O
)	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
;	O
else	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
get_link_from_string	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
link_name	*(char)
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
!	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
)	O
{	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
=	O
classify_link	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
if	O
(	O
!	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
)	O
return	O
0	int
;	O
}	O
}	O
}	O
free	(*(void))->(void)
(	O
links_0	*(*(char))
)	O
;	O
return	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
get_current_dir_link	()->(*(struct(union(*(struct`),long),char,array(char))))
(	O
void	O
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
char	O
*	O
cwd_0	*(char)
;	O
char	O
*	O
cwd	*(char)
;	O
char	O
*	O
xcwd	*(char)
=	O
0	int
;	O
char	O
*	O
*	O
links_0	*(*(char))
;	O
char	O
*	O
*	O
links	*(*(char))
;	O
if	O
(	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
return	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
cwd_0	*(char)
=	O
"."	*(char)
;	O
if	O
(	O
cwd_0	*(char)
)	O
cwd_0	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
cwd_0	*(char)
)	O
;	O
if	O
(	O
!	O
same_as_dot	(*(char))->(int)
(	O
cwd_0	*(char)
)	O
)	O
cwd_0	*(char)
=	O
xcwd	*(char)
=	O
xgetcwd	()->(*(char))
(	O
)	O
;	O
if	O
(	O
cwd_0	*(char)
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't get working directory"	*(char)
)	O
)	O
;	O
cwd	*(char)
=	O
cwd_0	*(char)
;	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
get_link_from_string	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
SLASH_STRING	*(char)
,	O
0	int
)	O
;	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
=	O
(	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
&	O
~	O
FL_TYPE_MASK	O
)	O
|	O
FL_TYPE_DIR	O
;	O
links	*(*(char))
=	O
links_0	*(*(char))
=	O
vectorize_string	(*(char),*(char))->(*(*(char)))
(	O
cwd	*(char)
,	O
SLASH_STRING	*(char)
)	O
;	O
while	O
(	O
*	O
links	*(*(char))
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
char	O
const	O
*	O
link_name	*(char)
=	O
*	O
links	*(*(char))
++	O
;	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
get_link_from_string	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
link_name	*(char)
,	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
!	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
)	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
=	O
classify_link	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
;	O
}	O
chdir_to_link	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
links_0	*(*(char))
)	O
;	O
if	O
(	O
xcwd	*(char)
)	O
free	(*(void))->(void)
(	O
xcwd	*(char)
)	O
;	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
return	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
}	O
static	O
int	O
same_as_dot	(*(char))->(int)
(	O
char	O
const	O
*	O
cwd	*(char)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
cwd_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
dot_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
cwd	*(char)
==	O
0	int
||	O
*	O
cwd	*(char)
!=	O
'/'	O
||	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
cwd	*(char)
,	O
&	O
cwd_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
||	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
"."	*(char)
,	O
&	O
dot_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
return	O
0	int
;	O
return	O
(	O
(	O
cwd_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
==	O
dot_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
)	O
&&	O
(	O
cwd_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
==	O
dot_st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
)	O
)	O
;	O
}	O
int	O
chdir_to_link	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
char	O
*	O
to_dir_name	*(char)
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
if	O
(	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
==	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
return	O
1	int
;	O
if	O
(	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
maybe_relative_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
to_dir_name	*(char)
,	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
else	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
to_dir_name	*(char)
,	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
chdir	(*(char))->(int)
(	O
to_dir_name	*(char)
)	O
<	O
0	int
)	O
{	O
if	O
(	O
IS_ABSOLUTE	O
(	O
to_dir_name	*(char)
)	O
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't chdir to `%s'"	*(char)
)	O
,	O
to_dir_name	*(char)
)	O
;	O
else	O
{	O
char	O
*	O
from_dir_name	*(char)
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
from_dir_name	*(char)
,	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't chdir to `%s' from `%s'"	*(char)
)	O
,	O
to_dir_name	*(char)
,	O
from_dir_name	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
else	O
{	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
return	O
1	int
;	O
}	O
}	O
char	O
*	O
*	O
vectorize_string	(*(char),*(char))->(*(*(char)))
(	O
char	O
*	O
string	*(char)
,	O
char	O
const	O
*	O
delimiter_class	*(char)
)	O
{	O
char	O
*	O
*	O
vector_0	*(*(void))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
2	int
+	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
/	O
2	int
)	O
)	O
;	O
char	O
*	O
*	O
vector	*(*(char))
=	O
vector_0	*(*(void))
;	O
*	O
vector	*(*(char))
++	O
=	O
strsep	(*(*(char)),*(char))->(*(char))
(	O
&	O
string	*(char)
,	O
delimiter_class	*(char)
)	O
;	O
if	O
(	O
vector	*(*(char))
[	O
-	O
1	int
]	O
)	O
{	O
if	O
(	O
vector	*(*(char))
[	O
-	O
1	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
)	O
vector	*(*(char))
--	O
;	O
do	O
*	O
vector	*(*(char))
=	O
strsep	(*(*(char)),*(char))->(*(char))
(	O
&	O
string	*(char)
,	O
delimiter_class	*(char)
)	O
;	O
while	O
(	O
*	O
vector	*(*(char))
++	O
)	O
;	O
}	O
return	O
xrealloc	(*(void),long)->(*(void))
(	O
vector_0	*(*(void))
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
vector	*(*(char))
-	O
vector_0	*(*(void))
)	O
)	O
;	O
}	O
void	O
prune_file_names	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(void)
(	O
char	O
*	O
str	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
from_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
char	O
*	O
*	O
file_names_0	*(*(char))
=	O
vectorize_string	(*(char),*(char))->(*(*(char)))
(	O
str	*(char)
,	O
white_space	array(char)
)	O
;	O
char	O
*	O
*	O
file_names	*(*(char))
=	O
file_names_0	*(*(char))
;	O
while	O
(	O
*	O
file_names	*(*(char))
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
parse_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
*	O
file_names	*(*(char))
++	O
,	O
from_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
|=	O
FL_PRUNE	O
;	O
}	O
free	(*(void))->(void)
(	O
file_names_0	*(*(char))
)	O
;	O
}	O
int	O
classify_link	(*(struct(union(*(struct`),long),char,array(char))),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
*	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
unsigned	O
int	O
flags	*(int)
=	O
0	int
;	O
if	O
(	O
!	O
chdir_to_link	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
,	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
<	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't lstat `%s' from `%s'"	*(char)
)	O
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
,	O
xgetcwd	()->(*(char))
(	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
S_ISLNK	O
(	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
,	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
<	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't stat `%s' from `%s'"	*(char)
)	O
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
,	O
xgetcwd	()->(*(char))
(	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
flags	*(int)
|=	O
FL_SYM_LINK	O
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
flags	*(int)
|=	O
FL_TYPE_DIR	O
;	O
else	O
if	O
(	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_size	long
==	O
0	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
S_ISREG	O
(	O
stp	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
st_mode	int
)	O
)	O
flags	*(int)
|=	O
FL_TYPE_FILE	O
;	O
else	O
return	O
0	int
;	O
return	O
flags	*(int)
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
get_link_from_dirent	(*(struct(long,long,short,char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dirent	struct(long,long,short,char,array(char))
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
slot	*(void)
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
new_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
new_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
make_link_from_dirent	(*(struct(long,long,short,char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
dirent	struct(long,long,short,char,array(char))
,	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
slot	*(void)
=	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
)	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
new_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
HASH_VACANT	O
(	O
*	O
slot	*(void)
)	O
)	O
slot	*(void)
=	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
)	O
hash_insert_at	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void),*(void))->(*(void))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
new_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
slot	*(void)
)	O
;	O
else	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
new_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
return	O
*	O
slot	*(void)
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
get_link_from_string	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
slot	*(void)
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
new_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
new_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
make_link_from_string	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
name	*(char)
,	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
slot	*(void)
=	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
)	O
hash_find_slot	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void))->(*(*(void)))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
new_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
HASH_VACANT	O
(	O
*	O
slot	*(void)
)	O
)	O
slot	*(void)
=	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
)	O
hash_insert_at	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),*(void),*(void))->(*(void))
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
new_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
slot	*(void)
)	O
;	O
else	O
obstack_free	(*(struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int)),*(void))->(void)
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
new_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
return	O
*	O
slot	*(void)
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
make_link_from_dirent	(*(struct(long,long,short,char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dirent	struct(long,long,short,char,array(char))
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
)	O
obstack_alloc	O
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
sizeof	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
)	O
+	O
strlen	(*(char))->(long)
(	O
dirent	struct(long,long,short,char,array(char))
->	O
d_name	array(char)
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
,	O
dirent	struct(long,long,short,char,array(char))
->	O
d_name	array(char)
)	O
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
=	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
?	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
:	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
=	O
0	int
;	O
return	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
make_link_from_string	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
)	O
obstack_alloc	O
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_link_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
,	O
sizeof	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
)	O
+	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
,	O
name	*(char)
)	O
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
=	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
?	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
:	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
=	O
0	int
;	O
return	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
fill_link_vector	(*(*(struct(union(*`,long),char,array(char)))),*(struct(union(*(struct`),long),char,array(char))))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
fill_link_vector_1	(*(*(struct(union(*`,long),char,array(char)))),*(struct(union(*(struct`),long),char,array(char))))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
*	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
0	int
;	O
return	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
fill_link_vector_1	(*(*(struct(union(*`,long),char,array(char)))),*(struct(union(*(struct`),long),char,array(char))))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
if	O
(	O
!	O
IS_ROOT_FILE_LINK	O
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
)	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
fill_link_vector_1	(*(*(struct(union(*`,long),char,array(char)))),*(struct(union(*(struct`),long),char,array(char))))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
)	O
;	O
*	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
++	O
=	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
return	O
vec_buf	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
}	O
char	O
*	O
maybe_relative_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
char	O
*	O
buf_0	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
to_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
from_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
to_link_vec_0	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
alloca	O
(	O
sizeof	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
*	O
(	O
PATH_MAX	int
/	O
2	int
)	O
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
from_link_vec_0	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
alloca	O
(	O
sizeof	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
*	O
(	O
PATH_MAX	int
/	O
2	int
)	O
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
to_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
to_link_vec_0	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
from_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
from_link_vec_0	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
from_link_end	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
*	O
from_links	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
int	O
alloc_me	int
=	O
(	O
buf_0	*(char)
==	O
0	int
)	O
;	O
char	O
*	O
buf	*(char)
;	O
int	O
levels	int
;	O
if	O
(	O
from_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
==	O
0	int
)	O
from_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
current_dir_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
if	O
(	O
alloc_me	int
)	O
buf_0	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
PATH_MAX	int
)	O
;	O
if	O
(	O
to_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
==	O
from_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf_0	*(char)
,	O
"."	*(char)
)	O
;	O
else	O
if	O
(	O
to_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
==	O
from_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf_0	*(char)
,	O
to_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
)	O
;	O
else	O
if	O
(	O
from_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_flags	char
&	O
FL_SYM_LINK	O
)	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
buf_0	*(char)
,	O
to_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
else	O
if	O
(	O
to_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
==	O
from_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf_0	*(char)
,	O
".."	*(char)
)	O
;	O
else	O
if	O
(	O
to_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
==	O
from_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf_0	*(char)
,	O
DOT_DOT_SLASH	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
&	O
buf_0	*(char)
[	O
3	int
]	O
,	O
to_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
)	O
;	O
}	O
else	O
{	O
from_link_end	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
fill_link_vector	(*(*(struct(union(*`,long),char,array(char)))),*(struct(union(*(struct`),long),char,array(char))))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
from_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
,	O
from_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
fill_link_vector	(*(*(struct(union(*`,long),char,array(char)))),*(struct(union(*(struct`),long),char,array(char))))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
to_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
,	O
to_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
while	O
(	O
*	O
to_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
==	O
*	O
from_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
{	O
if	O
(	O
*	O
to_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
==	O
0	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf_0	*(char)
,	O
"."	*(char)
)	O
;	O
goto	O
out	O
;	O
}	O
to_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
++	O
;	O
from_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
++	O
;	O
}	O
levels	int
=	O
from_link_end	*(*(struct(union(*(struct`),long),char,array(char))))
-	O
from_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
if	O
(	O
levels	int
>=	O
(	O
from_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
-	O
from_link_vec_0	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
)	O
{	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
buf_0	*(char)
,	O
to_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
goto	O
out	O
;	O
}	O
for	O
(	O
from_links	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
from_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
*	O
from_links	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
from_links	*(*(struct(union(*(struct`),long),char,array(char))))
++	O
)	O
if	O
(	O
(	O
*	O
from_links	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
->	O
fl_flags	char
&	O
FL_SYM_LINK	O
)	O
{	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
buf_0	*(char)
,	O
to_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
goto	O
out	O
;	O
}	O
buf	*(char)
=	O
fill_dot_dots	(*(char),int)->(*(char))
(	O
buf_0	*(char)
,	O
levels	int
)	O
;	O
if	O
(	O
*	O
to_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
==	O
0	int
)	O
*	O
--	O
buf	*(char)
=	O
'\0'	O
;	O
else	O
{	O
do	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
(	O
*	O
to_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
->	O
fl_name	array(char)
)	O
;	O
buf	*(char)
+=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
(	O
*	O
to_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
->	O
fl_name	array(char)
[	O
0	int
]	O
!=	O
SLASH_CHAR	char
&&	O
*	O
++	O
to_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
*	O
buf	*(char)
++	O
=	O
SLASH_CHAR	char
;	O
}	O
while	O
(	O
*	O
to_link_vec	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
;	O
}	O
}	O
out	O
:	O
if	O
(	O
alloc_me	int
)	O
buf_0	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
buf_0	*(char)
,	O
(	O
1	int
+	O
strlen	(*(char))->(long)
(	O
buf_0	*(char)
)	O
)	O
)	O
;	O
return	O
buf_0	*(char)
;	O
}	O
char	O
*	O
fill_dot_dots	(*(char),int)->(*(char))
(	O
char	O
*	O
buf	*(char)
,	O
int	O
levels	int
)	O
{	O
while	O
(	O
levels	int
--	O
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
DOT_DOT_SLASH	*(char)
)	O
;	O
buf	*(char)
+=	O
3	int
;	O
}	O
return	O
buf	*(char)
;	O
}	O
char	O
*	O
absolute_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
char	O
*	O
buf_0	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
char	O
*	O
end	*(*(void))
;	O
int	O
alloc_me	int
=	O
(	O
buf_0	*(char)
==	O
0	int
)	O
;	O
if	O
(	O
alloc_me	int
)	O
buf_0	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
PATH_MAX	int
)	O
;	O
end	*(*(void))
=	O
absolute_file_name_1	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
buf_0	*(char)
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
end	*(*(void))
>	O
&	O
buf_0	*(char)
[	O
1	int
]	O
)	O
end	*(*(void))
--	O
;	O
*	O
end	*(*(void))
++	O
=	O
'\0'	O
;	O
if	O
(	O
alloc_me	int
)	O
buf_0	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
buf_0	*(char)
,	O
(	O
size_t	long
)	O
(	O
end	*(*(void))
-	O
buf_0	*(char)
)	O
)	O
;	O
return	O
buf_0	*(char)
;	O
}	O
static	O
char	O
*	O
absolute_file_name_1	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
char	O
*	O
buf	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
char	O
*	O
end	*(*(void))
;	O
if	O
(	O
IS_ROOT_FILE_LINK	O
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
)	O
end	*(*(void))
=	O
buf	*(char)
;	O
else	O
end	*(*(void))
=	O
absolute_file_name_1	(*(char),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
buf	*(char)
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
end	*(*(void))
,	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
)	O
;	O
if	O
(	O
*	O
end	*(*(void))
==	O
SLASH_CHAR	char
)	O
end	*(*(void))
++	O
;	O
else	O
{	O
end	*(*(void))
+=	O
strlen	(*(char))->(long)
(	O
end	*(*(void))
)	O
;	O
*	O
end	*(*(void))
++	O
=	O
SLASH_CHAR	char
;	O
}	O
return	O
end	*(*(void))
;	O
}	O
unsigned	O
long	O
member_file_hash_1	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
{	O
return_ADDRESS_HASH_1	O
(	O
(	O
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
const	O
*	O
)	O
key	*(void)
)	O
->	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
}	O
unsigned	O
long	O
member_file_hash_2	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
{	O
return_ADDRESS_HASH_2	O
(	O
(	O
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
const	O
*	O
)	O
key	*(void)
)	O
->	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
}	O
int	O
member_file_hash_compare	(*(void),*(void))->(int)
(	O
void	O
const	O
*	O
x	*(void)
,	O
void	O
const	O
*	O
y	*(void)
)	O
{	O
return_ADDRESS_COMPARE	O
(	O
(	O
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
const	O
*	O
)	O
x	*(void)
)	O
->	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
(	O
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
const	O
*	O
)	O
y	*(void)
)	O
->	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
}	O
int	O
member_file_qsort_compare	(*(void),*(void))->(int)
(	O
void	O
const	O
*	O
x	*(void)
,	O
void	O
const	O
*	O
y	*(void)
)	O
{	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
const	O
*	O
mfx	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
=	O
*	O
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
const	O
*	O
const	O
*	O
)	O
x	*(void)
;	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
const	O
*	O
mfy	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
=	O
*	O
(	O
struct	O
member_file	struct(*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))),*(struct),long)
const	O
*	O
const	O
*	O
)	O
y	*(void)
;	O
int	O
result	long
;	O
INTEGER_COMPARE	O
(	O
mfx	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_lang_args	*(struct)
->	O
la_index	int
,	O
mfy	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_lang_args	*(struct)
->	O
la_index	int
,	O
result	long
)	O
;	O
if	O
(	O
result	long
)	O
return	O
result	long
;	O
else	O
{	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flx	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
mfx	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
fly	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
mfy	*(struct(*(struct(union(*`,long),char,array(char))),*(struct(*(struct`),*(char),*(char),*(void),int,*(struct`))),long))
->	O
mf_link	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
if	O
(	O
flx	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
==	O
fly	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
)	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
flx	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
,	O
fly	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
)	O
;	O
result	long
=	O
(	O
links_depth	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
flx	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
-	O
links_depth	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
fly	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
)	O
;	O
if	O
(	O
result	long
)	O
return	O
result	long
;	O
while	O
(	O
flx	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
!=	O
fly	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
)	O
{	O
flx	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
flx	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
;	O
fly	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
fly	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
;	O
}	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
flx	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
,	O
fly	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_name	array(char)
)	O
;	O
}	O
}	O
unsigned	O
long	O
file_link_hash_1	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
{	O
unsigned	O
long	O
result	long
=	O
0	int
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
(	O
IS_ROOT_FILE_LINK	O
(	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
key	*(void)
)	O
)	O
?	O
0	int
:	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
key	*(void)
)	O
->	O
fl_parent	O
)	O
;	O
STRING_HASH_1	O
(	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
key	*(void)
)	O
->	O
fl_name	array(char)
,	O
result	long
)	O
;	O
ADDRESS_HASH_1	O
(	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
unsigned	O
long	O
file_link_hash_2	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
{	O
unsigned	O
long	O
result	long
=	O
0	int
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
(	O
IS_ROOT_FILE_LINK	O
(	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
key	*(void)
)	O
)	O
?	O
0	int
:	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
key	*(void)
)	O
->	O
fl_parent	O
)	O
;	O
STRING_HASH_2	O
(	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
key	*(void)
)	O
->	O
fl_name	array(char)
,	O
result	long
)	O
;	O
ADDRESS_HASH_2	O
(	O
parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
int	O
file_link_hash_compare	(*(void),*(void))->(int)
(	O
void	O
const	O
*	O
x	*(void)
,	O
void	O
const	O
*	O
y	*(void)
)	O
{	O
int	O
result	long
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
x_parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
(	O
IS_ROOT_FILE_LINK	O
(	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
x	*(void)
)	O
)	O
?	O
0	int
:	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
x	*(void)
)	O
->	O
fl_parent	O
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
y_parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
(	O
IS_ROOT_FILE_LINK	O
(	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
y	*(void)
)	O
)	O
?	O
0	int
:	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
y	*(void)
)	O
->	O
fl_parent	O
)	O
;	O
ADDRESS_COMPARE	O
(	O
x_parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
y_parent	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
,	O
result	long
)	O
;	O
if	O
(	O
result	long
)	O
return	O
result	long
;	O
STRING_COMPARE	O
(	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
x	*(void)
)	O
->	O
fl_name	array(char)
,	O
(	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
)	O
y	*(void)
)	O
->	O
fl_name	array(char)
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
int	O
links_depth	(*(struct(union(*(struct`),long),char,array(char))))->(int)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
const	O
*	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
{	O
int	O
depth	int
=	O
0	int
;	O
while	O
(	O
!	O
IS_ROOT_FILE_LINK	O
(	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
)	O
{	O
depth	int
++	O
;	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
flink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
->	O
fl_parent	O
;	O
}	O
return	O
depth	int
;	O
}	O
unsigned	O
long	O
dev_ino_hash_1	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
{	O
unsigned	O
long	O
result	long
=	O
0	int
;	O
INTEGER_HASH_1	O
(	O
(	O
(	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
const	O
*	O
)	O
key	*(void)
)	O
->	O
di_dev	long
,	O
result	long
)	O
;	O
INTEGER_HASH_1	O
(	O
(	O
(	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
const	O
*	O
)	O
key	*(void)
)	O
->	O
di_ino	long
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
unsigned	O
long	O
dev_ino_hash_2	(*(void))->(long)
(	O
void	O
const	O
*	O
key	*(void)
)	O
{	O
unsigned	O
long	O
result	long
=	O
0	int
;	O
INTEGER_HASH_2	O
(	O
(	O
(	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
const	O
*	O
)	O
key	*(void)
)	O
->	O
di_dev	long
,	O
result	long
)	O
;	O
INTEGER_HASH_2	O
(	O
(	O
(	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
const	O
*	O
)	O
key	*(void)
)	O
->	O
di_ino	long
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
int	O
dev_ino_hash_compare	(*(void),*(void))->(int)
(	O
void	O
const	O
*	O
x	*(void)
,	O
void	O
const	O
*	O
y	*(void)
)	O
{	O
int	O
result	long
;	O
INTEGER_COMPARE	O
(	O
(	O
(	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
const	O
*	O
)	O
x	*(void)
)	O
->	O
di_ino	long
,	O
(	O
(	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
const	O
*	O
)	O
y	*(void)
)	O
->	O
di_ino	long
,	O
result	long
)	O
;	O
if	O
(	O
result	long
)	O
return	O
result	long
;	O
INTEGER_COMPARE	O
(	O
(	O
(	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
const	O
*	O
)	O
x	*(void)
)	O
->	O
di_dev	long
,	O
(	O
(	O
struct	O
dev_ino	struct(long,long,*(struct(union(*(struct(union`,char,array(char))),long),char,array(char))))
const	O
*	O
)	O
y	*(void)
)	O
->	O
di_dev	long
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
init_walker	(*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))))->(*(struct(union(*(struct`),long),char,array(char))))
(	O
struct	O
idhead	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
*	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
{	O
init_idh_obstacks	(*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))))->(void)
(	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
;	O
init_idh_tables	(*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))))->(void)
(	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
;	O
return	O
get_current_dir_link	()->(*(struct(union(*(struct`),long),char,array(char))))
(	O
)	O
;	O
}	O
void	O
init_idh_obstacks	(*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))))->(void)
(	O
struct	O
idhead	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
*	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
{	O
obstack_init	O
(	O
&	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
idh_member_file_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
obstack_init	O
(	O
&	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
idh_file_link_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
obstack_init	O
(	O
&	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
idh_dev_ino_obstack	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int)
)	O
;	O
}	O
void	O
init_idh_tables	(*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))))->(void)
(	O
struct	O
idhead	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
*	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
)	O
{	O
hash_init	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),long,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))->(void)
(	O
&	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
idh_member_file_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
16	int
*	O
1024	int
,	O
member_file_hash_1	(*(void))->(long)
,	O
member_file_hash_2	(*(void))->(long)
,	O
member_file_hash_compare	(*(void),*(void))->(int)
)	O
;	O
hash_init	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),long,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))->(void)
(	O
&	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
idh_file_link_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
16	int
*	O
1024	int
,	O
file_link_hash_1	(*(void))->(long)
,	O
file_link_hash_2	(*(void))->(long)
,	O
file_link_hash_compare	(*(void),*(void))->(int)
)	O
;	O
hash_init	(*(struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)))),long,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))->(void)
(	O
&	O
idhp	*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char)))))
->	O
idh_dev_ino_table	struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)))
,	O
16	int
*	O
1024	int
,	O
dev_ino_hash_1	(*(void))->(long)
,	O
dev_ino_hash_2	(*(void))->(long)
,	O
dev_ino_hash_compare	(*(void),*(void))->(int)
)	O
;	O
}	O
