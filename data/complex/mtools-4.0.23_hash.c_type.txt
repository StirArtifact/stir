struct	O
hashtable	struct(*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)),long,long,long,long,*(*(void)))
{	O
T_HashFunc	*((*(void))->(long))
f1	*((*(void))->(long))
,	O
f2	*((*(void))->(long))
;	O
T_ComparFunc	*((*(void),*(void))->(int))
compar	*((*(void),*(void))->(int))
;	O
size_t	long
size	long
;	O
size_t	long
fill	long
;	O
size_t	long
inuse	long
;	O
size_t	long
max	long
;	O
T_HashTableEl	*(void)
*	O
entries	*(*(void))
;	O
}	O
;	O
static	O
size_t	long
sizes	array(long)
[	O
]	O
=	O
{	O
5	int
,	O
11	int
,	O
23	int
,	O
47	int
,	O
97	int
,	O
197	int
,	O
397	int
,	O
797	int
,	O
1597	int
,	O
3203	int
,	O
6421	int
,	O
12853	int
,	O
25717	int
,	O
51437	int
,	O
102877	int
,	O
205759	int
,	O
411527	int
,	O
823117	int
,	O
1646237	int
,	O
3292489	int
,	O
6584983	int
,	O
13169977	int
,	O
26339969	int
,	O
52679969	int
,	O
105359939	int
,	O
210719881	int
,	O
421439783	int
,	O
842879579	int
,	O
1685759167	int
,	O
0	int
}	O
;	O
static	O
int	O
deleted	int
=	O
0	int
;	O
static	O
int	O
unallocated	int
=	O
0	int
;	O
static	O
int	O
alloc_ht	(*(struct(*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)),long,long,long,long,*(*(void)))),long)->(int)
(	O
T_HashTable	struct
*	O
H	*(*(struct))
,	O
size_t	long
size	long
)	O
{	O
int	O
i	int
;	O
size_t	long
ii	long
;	O
for	O
(	O
i	int
=	O
0	int
;	O
sizes	array(long)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
sizes	array(long)
[	O
i	int
]	O
>	O
size	long
*	O
4	int
)	O
break	O
;	O
if	O
(	O
!	O
sizes	array(long)
[	O
i	int
]	O
)	O
for	O
(	O
i	int
=	O
0	int
;	O
sizes	array(long)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
sizes	array(long)
[	O
i	int
]	O
>	O
size	long
*	O
2	int
)	O
break	O
;	O
if	O
(	O
!	O
sizes	array(long)
[	O
i	int
]	O
)	O
for	O
(	O
i	int
=	O
0	int
;	O
sizes	array(long)
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
sizes	array(long)
[	O
i	int
]	O
>	O
size	long
)	O
break	O
;	O
if	O
(	O
!	O
sizes	array(long)
[	O
i	int
]	O
)	O
return	O
-	O
1	int
;	O
size	long
=	O
sizes	array(long)
[	O
i	int
]	O
;	O
if	O
(	O
size	long
<	O
H	*(*(struct))
->	O
size	long
)	O
size	long
=	O
H	*(*(struct))
->	O
size	long
;	O
H	*(*(struct))
->	O
max	long
=	O
size	long
*	O
4	int
/	O
5	int
-	O
2	int
;	O
H	*(*(struct))
->	O
size	long
=	O
size	long
;	O
H	*(*(struct))
->	O
fill	long
=	O
0	int
;	O
H	*(*(struct))
->	O
inuse	long
=	O
0	int
;	O
H	*(*(struct))
->	O
entries	*(*(void))
=	O
NewArray	O
(	O
size	long
,	O
T_HashTableEl	*(void)
)	O
;	O
if	O
(	O
H	*(*(struct))
->	O
entries	*(*(void))
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
ii	long
=	O
0	int
;	O
ii	long
<	O
size	long
;	O
ii	long
++	O
)	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
ii	long
]	O
=	O
&	O
unallocated	int
;	O
return	O
0	int
;	O
}	O
int	O
make_ht	(*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int)),long,*(*(struct)))->(int)
(	O
T_HashFunc	*((*(void))->(long))
f1	*((*(void))->(long))
,	O
T_HashFunc	*((*(void))->(long))
f2	*((*(void))->(long))
,	O
T_ComparFunc	*((*(void),*(void))->(int))
c	*((*(void),*(void))->(int))
,	O
size_t	long
size	long
,	O
T_HashTable	struct
*	O
*	O
H	*(*(struct))
)	O
{	O
*	O
H	*(*(struct))
=	O
New	O
(	O
T_HashTable	struct
)	O
;	O
if	O
(	O
*	O
H	*(*(struct))
==	O
NULL	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
(	O
*	O
H	*(*(struct))
)	O
->	O
f1	*((*(void))->(long))
=	O
f1	*((*(void))->(long))
;	O
(	O
*	O
H	*(*(struct))
)	O
->	O
f2	*((*(void))->(long))
=	O
f2	*((*(void))->(long))
;	O
(	O
*	O
H	*(*(struct))
)	O
->	O
compar	*((*(void),*(void))->(int))
=	O
c	*((*(void),*(void))->(int))
;	O
(	O
*	O
H	*(*(struct))
)	O
->	O
size	long
=	O
0	int
;	O
if	O
(	O
alloc_ht	(*(struct(*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)),long,long,long,long,*(*(void)))),long)->(int)
(	O
*	O
H	*(*(struct))
,	O
size	long
)	O
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
free_ht	(*(struct),*((*(void))->(long)))->(int)
(	O
T_HashTable	struct
*	O
H	*(*(struct))
,	O
T_HashFunc	*((*(void))->(long))
entry_free	*((*(void))->(long))
)	O
{	O
size_t	long
i	int
;	O
if	O
(	O
entry_free	*((*(void))->(long))
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
H	*(*(struct))
->	O
size	long
;	O
i	int
++	O
)	O
if	O
(	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
i	int
]	O
!=	O
&	O
unallocated	int
&&	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
i	int
]	O
!=	O
&	O
deleted	int
)	O
entry_free	*((*(void))->(long))
(	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
i	int
]	O
)	O
;	O
Free	O
(	O
H	*(*(struct))
->	O
entries	*(*(void))
)	O
;	O
Free	O
(	O
H	*(*(struct))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_hash_add	(*(struct(*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)),long,long,long,long,*(*(void)))),*(*(void)),*(long))->(int)
(	O
T_HashTable	struct
*	O
H	*(*(struct))
,	O
T_HashTableEl	*(void)
*	O
E	*(*(void))
,	O
size_t	long
*	O
hint	*(long)
)	O
{	O
size_t	long
f2	*((*(void))->(long))
,	O
pos	array(char)
;	O
int	O
ctr	int
;	O
pos	array(char)
=	O
H	*(*(struct))
->	O
f1	*((*(void))->(long))
(	O
E	*(*(void))
)	O
%	O
H	*(*(struct))
->	O
size	long
;	O
f2	*((*(void))->(long))
=	O
(	O
size_t	long
)	O
-	O
1	int
;	O
ctr	int
=	O
0	int
;	O
while	O
(	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
!=	O
&	O
unallocated	int
&&	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
!=	O
&	O
deleted	int
)	O
{	O
if	O
(	O
f2	*((*(void))->(long))
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
f2	*((*(void))->(long))
=	O
H	*(*(struct))
->	O
f2	*((*(void))->(long))
(	O
E	*(*(void))
)	O
%	O
(	O
H	*(*(struct))
->	O
size	long
-	O
1	int
)	O
;	O
pos	array(char)
=	O
(	O
pos	array(char)
+	O
f2	*((*(void))->(long))
+	O
1	int
)	O
%	O
H	*(*(struct))
->	O
size	long
;	O
ctr	int
++	O
;	O
}	O
if	O
(	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
==	O
&	O
unallocated	int
)	O
H	*(*(struct))
->	O
fill	long
++	O
;	O
H	*(*(struct))
->	O
inuse	long
++	O
;	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
=	O
E	*(*(void))
;	O
if	O
(	O
hint	*(long)
)	O
*	O
hint	*(long)
=	O
pos	array(char)
;	O
return	O
0	int
;	O
}	O
static	O
int	O
rehash	(*(struct(*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)),long,long,long,long,*(*(void)))))->(int)
(	O
T_HashTable	struct
*	O
H	*(*(struct))
)	O
{	O
size_t	long
size	long
,	O
i	int
;	O
T_HashTableEl	*(void)
*	O
oldentries	*(*(void))
;	O
size	long
=	O
H	*(*(struct))
->	O
size	long
;	O
oldentries	*(*(void))
=	O
H	*(*(struct))
->	O
entries	*(*(void))
;	O
if	O
(	O
alloc_ht	(*(struct(*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)),long,long,long,long,*(*(void)))),long)->(int)
(	O
H	*(*(struct))
,	O
(	O
(	O
H	*(*(struct))
->	O
inuse	long
+	O
1	int
)	O
*	O
4	int
+	O
H	*(*(struct))
->	O
fill	long
)	O
/	O
5	int
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
oldentries	*(*(void))
[	O
i	int
]	O
!=	O
&	O
unallocated	int
&&	O
oldentries	*(*(void))
[	O
i	int
]	O
!=	O
&	O
deleted	int
)	O
_hash_add	(*(struct(*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)),long,long,long,long,*(*(void)))),*(*(void)),*(long))->(int)
(	O
H	*(*(struct))
,	O
oldentries	*(*(void))
[	O
i	int
]	O
,	O
0	int
)	O
;	O
}	O
Free	O
(	O
oldentries	*(*(void))
)	O
;	O
return	O
0	int
;	O
}	O
int	O
hash_add	(*(struct),*(*(void)),*(long))->(int)
(	O
T_HashTable	struct
*	O
H	*(*(struct))
,	O
T_HashTableEl	*(void)
*	O
E	*(*(void))
,	O
size_t	long
*	O
hint	*(long)
)	O
{	O
if	O
(	O
H	*(*(struct))
->	O
fill	long
>=	O
H	*(*(struct))
->	O
max	long
)	O
rehash	(*(struct(*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)),long,long,long,long,*(*(void)))))->(int)
(	O
H	*(*(struct))
)	O
;	O
if	O
(	O
H	*(*(struct))
->	O
fill	long
==	O
H	*(*(struct))
->	O
size	long
)	O
return	O
-	O
1	int
;	O
return	O
_hash_add	(*(struct(*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)),long,long,long,long,*(*(void)))),*(*(void)),*(long))->(int)
(	O
H	*(*(struct))
,	O
E	*(*(void))
,	O
hint	*(long)
)	O
;	O
}	O
static	O
int	O
_hash_lookup	(*(struct(*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)),long,long,long,long,*(*(void)))),*(*(void)),*(*(*(void))),*(long),int)->(int)
(	O
T_HashTable	struct
*	O
H	*(*(struct))
,	O
T_HashTableEl	*(void)
*	O
E	*(*(void))
,	O
T_HashTableEl	*(void)
*	O
*	O
E2	*(*(*(void)))
,	O
size_t	long
*	O
hint	*(long)
,	O
int	O
isIdentity	int
)	O
{	O
size_t	long
f2	*((*(void))->(long))
,	O
pos	array(char)
,	O
upos	long
,	O
ttl	long
;	O
pos	array(char)
=	O
H	*(*(struct))
->	O
f1	*((*(void))->(long))
(	O
E	*(*(void))
)	O
%	O
H	*(*(struct))
->	O
size	long
;	O
ttl	long
=	O
H	*(*(struct))
->	O
size	long
;	O
f2	*((*(void))->(long))
=	O
(	O
size_t	long
)	O
-	O
1	int
;	O
upos	long
=	O
(	O
size_t	long
)	O
-	O
1	int
;	O
while	O
(	O
ttl	long
&&	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
!=	O
&	O
unallocated	int
&&	O
(	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
==	O
&	O
deleted	int
||	O
(	O
(	O
isIdentity	int
||	O
H	*(*(struct))
->	O
compar	*((*(void),*(void))->(int))
(	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
,	O
E	*(*(void))
)	O
!=	O
0	int
)	O
&&	O
(	O
!	O
isIdentity	int
||	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
!=	O
E	*(*(void))
)	O
)	O
)	O
)	O
{	O
if	O
(	O
f2	*((*(void))->(long))
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
f2	*((*(void))->(long))
=	O
H	*(*(struct))
->	O
f2	*((*(void))->(long))
(	O
E	*(*(void))
)	O
%	O
(	O
H	*(*(struct))
->	O
size	long
-	O
1	int
)	O
;	O
if	O
(	O
upos	long
==	O
(	O
size_t	long
)	O
-	O
1	int
&&	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
==	O
&	O
deleted	int
)	O
upos	long
=	O
pos	array(char)
;	O
pos	array(char)
=	O
(	O
pos	array(char)
+	O
f2	*((*(void))->(long))
+	O
1	int
)	O
%	O
H	*(*(struct))
->	O
size	long
;	O
ttl	long
--	O
;	O
}	O
if	O
(	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
==	O
&	O
unallocated	int
||	O
!	O
ttl	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
upos	long
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
upos	long
]	O
=	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
;	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
=	O
&	O
deleted	int
;	O
pos	array(char)
=	O
upos	long
;	O
}	O
if	O
(	O
hint	*(long)
)	O
*	O
hint	*(long)
=	O
pos	array(char)
;	O
*	O
E2	*(*(*(void)))
=	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
pos	array(char)
]	O
;	O
return	O
0	int
;	O
}	O
int	O
hash_lookup	(*(struct),*(*(void)),*(*(*(void))),*(long))->(int)
(	O
T_HashTable	struct
*	O
H	*(*(struct))
,	O
T_HashTableEl	*(void)
*	O
E	*(*(void))
,	O
T_HashTableEl	*(void)
*	O
*	O
E2	*(*(*(void)))
,	O
size_t	long
*	O
hint	*(long)
)	O
{	O
return	O
_hash_lookup	(*(struct(*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)),long,long,long,long,*(*(void)))),*(*(void)),*(*(*(void))),*(long),int)->(int)
(	O
H	*(*(struct))
,	O
E	*(*(void))
,	O
E2	*(*(*(void)))
,	O
hint	*(long)
,	O
0	int
)	O
;	O
}	O
int	O
hash_remove	(*(struct),*(*(void)),long)->(int)
(	O
T_HashTable	struct
*	O
H	*(*(struct))
,	O
T_HashTableEl	*(void)
*	O
E	*(*(void))
,	O
size_t	long
hint	*(long)
)	O
{	O
T_HashTableEl	*(void)
*	O
E2	*(*(*(void)))
;	O
if	O
(	O
hint	*(long)
>=	O
0	int
&&	O
hint	*(long)
<	O
H	*(*(struct))
->	O
size	long
&&	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
hint	*(long)
]	O
==	O
E	*(*(void))
)	O
{	O
H	*(*(struct))
->	O
inuse	long
--	O
;	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
hint	*(long)
]	O
=	O
&	O
deleted	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
_hash_lookup	(*(struct(*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int)),long,long,long,long,*(*(void)))),*(*(void)),*(*(*(void))),*(long),int)->(int)
(	O
H	*(*(struct))
,	O
E	*(*(void))
,	O
&	O
E2	*(*(*(void)))
,	O
&	O
hint	*(long)
,	O
1	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Removing non-existent entry\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
H	*(*(struct))
->	O
inuse	long
--	O
;	O
H	*(*(struct))
->	O
entries	*(*(void))
[	O
hint	*(long)
]	O
=	O
&	O
deleted	int
;	O
return	O
0	int
;	O
}	O
