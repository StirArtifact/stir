struct	O
_dico_ldap_handle	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
{	O
LDAP	O
*	O
ldap	*(int)
;	O
const	O
char	O
*	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
;	O
char	O
*	O
base	*(void)
;	O
char	O
*	O
binddn	*(char)
;	O
char	O
*	O
passwd	*(char)
;	O
int	O
tls	int
;	O
int	O
debug	int
;	O
char	O
*	O
user_filter	*(char)
;	O
char	O
*	O
group_filter	*(char)
;	O
}	O
;	O
void	O
free_ldap_handle	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))))->(void)
(	O
struct	O
_dico_ldap_handle	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
*	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
{	O
free	(*(void))->(void)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
base	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
binddn	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
passwd	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
user_filter	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
group_filter	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
;	O
}	O
static	O
int	O
_dico_conn_setup	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))))->(int)
(	O
struct	O
_dico_ldap_handle	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
*	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
{	O
int	O
rc	int
;	O
LDAP	O
*	O
ld	O
=	O
NULL	O
;	O
int	O
protocol	int
=	O
LDAP_VERSION3	O
;	O
if	O
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
debug	int
)	O
{	O
if	O
(	O
ber_set_option	()->(int)
(	O
NULL	O
,	O
LBER_OPT_DEBUG_LEVEL	O
,	O
&	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
debug	int
)	O
!=	O
LBER_OPT_SUCCESS	O
)	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot set LBER_OPT_DEBUG_LEVEL %d"	*(char)
)	O
,	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
debug	int
)	O
;	O
if	O
(	O
ldap_set_option	()->(int)
(	O
NULL	O
,	O
LDAP_OPT_DEBUG_LEVEL	O
,	O
&	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
debug	int
)	O
!=	O
LDAP_OPT_SUCCESS	O
)	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"could not set LDAP_OPT_DEBUG_LEVEL %d"	*(char)
)	O
,	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
debug	int
)	O
;	O
}	O
rc	int
=	O
ldap_initialize	()->(int)
(	O
&	O
ld	O
,	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
)	O
;	O
if	O
(	O
rc	int
!=	O
LDAP_SUCCESS	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot create LDAP session handle for URI=%s (%d): %s"	*(char)
)	O
,	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
,	O
rc	int
,	O
ldap_err2string	()->(int)
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
tls	int
)	O
{	O
rc	int
=	O
ldap_start_tls_s	()->(int)
(	O
ld	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
!=	O
LDAP_SUCCESS	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"ldap_start_tls failed: %s"	*(char)
)	O
,	O
ldap_err2string	()->(int)
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
ldap_set_option	()->(int)
(	O
ld	O
,	O
LDAP_OPT_PROTOCOL_VERSION	O
,	O
&	O
protocol	int
)	O
;	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
=	O
ld	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_dico_ldap_bind	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))))->(int)
(	O
struct	O
_dico_ldap_handle	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
*	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
{	O
int	O
msgid	*(char)
,	O
err	int
,	O
rc	int
;	O
LDAPMessage	O
*	O
result	*(int)
;	O
LDAPControl	O
*	O
*	O
ctrls	O
;	O
char	O
msgbuf	array(char)
[	O
256	int
]	O
;	O
char	O
*	O
matched	*(char)
=	O
NULL	O
;	O
char	O
*	O
info	*(char)
=	O
NULL	O
;	O
char	O
*	O
*	O
refs	*(*(char))
=	O
NULL	O
;	O
static	O
struct	O
berval	O
passwd	*(char)
;	O
passwd	*(char)
.	O
bv_val	O
=	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
passwd	*(char)
;	O
passwd	*(char)
.	O
bv_len	O
=	O
passwd	*(char)
.	O
bv_val	O
?	O
strlen	(*(char))->(long)
(	O
passwd	*(char)
.	O
bv_val	O
)	O
:	O
0	int
;	O
msgbuf	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
rc	int
=	O
ldap_sasl_bind	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
binddn	*(char)
,	O
LDAP_SASL_SIMPLE	O
,	O
&	O
passwd	*(char)
,	O
NULL	O
,	O
NULL	O
,	O
&	O
msgid	*(char)
)	O
;	O
if	O
(	O
msgid	*(char)
==	O
-	O
1	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_sasl_bind(SIMPLE) failed: %s"	*(char)
,	O
ldap_err2string	()->(int)
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ldap_result	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
msgid	*(char)
,	O
LDAP_MSG_ALL	O
,	O
NULL	O
,	O
&	O
result	*(int)
)	O
==	O
-	O
1	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_result failed"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
ldap_parse_result	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
result	*(int)
,	O
&	O
err	int
,	O
&	O
matched	*(char)
,	O
&	O
info	*(char)
,	O
&	O
refs	*(*(char))
,	O
&	O
ctrls	O
,	O
1	int
)	O
;	O
if	O
(	O
rc	int
!=	O
LDAP_SUCCESS	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_parse_result failed: %s"	*(char)
,	O
ldap_err2string	()->(int)
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ctrls	O
)	O
ldap_controls_free	()->(int)
(	O
ctrls	O
)	O
;	O
if	O
(	O
err	int
!=	O
LDAP_SUCCESS	O
||	O
msgbuf	array(char)
[	O
0	int
]	O
||	O
(	O
matched	*(char)
&&	O
matched	*(char)
[	O
0	int
]	O
)	O
||	O
(	O
info	*(char)
&&	O
info	*(char)
[	O
0	int
]	O
)	O
||	O
refs	*(*(char))
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_bind: %s (%d)%s"	*(char)
,	O
ldap_err2string	()->(int)
(	O
err	int
)	O
,	O
err	int
,	O
msgbuf	array(char)
)	O
;	O
if	O
(	O
matched	*(char)
&&	O
*	O
matched	*(char)
)	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"matched DN: %s"	*(char)
,	O
matched	*(char)
)	O
;	O
if	O
(	O
info	*(char)
&&	O
*	O
info	*(char)
)	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"additional info: %s"	*(char)
,	O
info	*(char)
)	O
;	O
if	O
(	O
refs	*(*(char))
&&	O
*	O
refs	*(*(char))
)	O
{	O
int	O
i	int
;	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"referrals:"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
refs	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
)	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"%s"	*(char)
,	O
refs	*(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
matched	*(char)
)	O
ber_memfree	()->(int)
(	O
matched	*(char)
)	O
;	O
if	O
(	O
info	*(char)
)	O
ber_memfree	()->(int)
(	O
info	*(char)
)	O
;	O
if	O
(	O
refs	*(*(char))
)	O
ber_memvfree	()->(int)
(	O
(	O
void	O
*	O
*	O
)	O
refs	*(*(char))
)	O
;	O
return	O
err	int
!=	O
LDAP_SUCCESS	O
;	O
}	O
static	O
void	O
_dico_ldap_unbind	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))))->(void)
(	O
struct	O
_dico_ldap_handle	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
*	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
{	O
if	O
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
)	O
{	O
ldap_set_option	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
LDAP_OPT_SERVER_CONTROLS	O
,	O
NULL	O
)	O
;	O
ldap_unbind_ext	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
}	O
static	O
int	O
db_open	(*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))),*(char))->(int)
(	O
void	O
*	O
*	O
phandle	*(*(void))
,	O
dico_url_t	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
,	O
const	O
char	O
*	O
options	*(char)
)	O
{	O
struct	O
_dico_ldap_handle	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
,	O
*	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
;	O
int	O
rc	int
;	O
long	O
debug	int
=	O
0	int
;	O
struct	O
dico_option	struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*`),*((*`,*`)->(int)))),*(char))->(int)))
option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
base	*(void)
)	O
,	O
dico_opt_string	int
,	O
&	O
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
.	O
base	*(void)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
binddn	*(char)
)	O
,	O
dico_opt_string	int
,	O
&	O
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
.	O
binddn	*(char)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
passwd	*(char)
)	O
,	O
dico_opt_string	int
,	O
&	O
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
.	O
passwd	*(char)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
tls	int
)	O
,	O
dico_opt_bool	int
,	O
&	O
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
.	O
tls	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
debug	int
)	O
,	O
dico_opt_long	int
,	O
&	O
debug	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
user	*(char)
-	O
filter	*(char)
)	O
,	O
dico_opt_string	int
,	O
&	O
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
.	O
user_filter	*(char)
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
group	O
-	O
filter	*(char)
)	O
,	O
dico_opt_string	int
,	O
&	O
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
.	O
group_filter	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
,	O
0	int
,	O
sizeof	O
(	O
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
)	O
)	O
;	O
if	O
(	O
options	*(char)
)	O
{	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
ws	*(int)
;	O
if	O
(	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
(	O
options	*(char)
,	O
&	O
ws	*(int)
,	O
WRDSF_DEFFLAGS	O
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot parse options `%s': %s"	*(char)
)	O
,	O
options	*(char)
,	O
wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(*(char))
(	O
&	O
ws	*(int)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
dico_parseopt	(*(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*`)),*((*`,*`)->(int)))),int,*(*(char)),int,*(int))->(int)
(	O
option	array(struct(*(char),long,enum(int,int,int,int,int,int,int,int,int),*(void),union(long,*(*(char))),*((*(struct(*`,long,enum(int,int,int,int,int,int,int,int,int),*`,union`,*`)),*(char))->(int))))
,	O
ws	*(int)
.	O
ws_wordc	long
,	O
ws	*(int)
.	O
ws_wordv	*(*(char))
,	O
DICO_PARSEOPT_PARSE_ARGV0	int
,	O
NULL	O
)	O
;	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(void)
(	O
&	O
ws	*(int)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
1	int
;	O
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
.	O
debug	int
=	O
debug	int
;	O
}	O
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
.	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
=	O
url	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long)))
->	O
string	*(*(char))
;	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
)	O
;	O
if	O
(	O
!	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot allocate handle"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
*	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
=	O
hstr	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
;	O
rc	int
=	O
_dico_conn_setup	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))))->(int)
(	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
||	O
_dico_ldap_bind	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))))->(int)
(	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free_ldap_handle	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))))->(void)
(	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
;	O
}	O
else	O
{	O
*	O
phandle	*(*(void))
=	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
db_close	(*(void))->(int)
(	O
void	O
*	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
{	O
struct	O
_dico_ldap_handle	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
*	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
=	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
;	O
_dico_ldap_unbind	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))))->(void)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
;	O
free_ldap_handle	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))))->(void)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
_dico_ldap_expand_user	(*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
query	*(char)
,	O
const	O
char	O
*	O
user	*(char)
)	O
{	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
ws	*(int)
;	O
const	O
char	O
*	O
env	array(*(char))
[	O
3	int
]	O
;	O
char	O
*	O
res	*(char)
;	O
env	array(*(char))
[	O
0	int
]	O
=	O
"user"	*(char)
;	O
env	array(*(char))
[	O
1	int
]	O
=	O
user	*(char)
;	O
env	array(*(char))
[	O
2	int
]	O
=	O
NULL	O
;	O
ws	*(int)
.	O
ws_env	*(*(char))
=	O
env	array(*(char))
;	O
if	O
(	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
(	O
query	*(char)
,	O
&	O
ws	*(int)
,	O
WRDSF_NOSPLIT	int
|	O
WRDSF_NOCMD	int
|	O
WRDSF_ENV	int
|	O
WRDSF_ENV_KV	int
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot expand query `%s': %s"	*(char)
)	O
,	O
query	*(char)
,	O
wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(*(char))
(	O
&	O
ws	*(int)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
res	*(char)
=	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
;	O
ws	*(int)
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
=	O
NULL	O
;	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(void)
(	O
&	O
ws	*(int)
)	O
;	O
return	O
res	*(char)
;	O
}	O
static	O
LDAPMessage	O
*	O
_dico_ldap_search	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))),*(char),*(char),*(char))->(*(int))
(	O
struct	O
_dico_ldap_handle	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
*	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
,	O
const	O
char	O
*	O
filter_pat	*(char)
,	O
const	O
char	O
*	O
attr	*(char)
,	O
const	O
char	O
*	O
user	*(char)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
filter	*(char)
;	O
LDAPMessage	O
*	O
res	*(char)
;	O
ber_int_t	O
msgid	*(char)
;	O
char	O
*	O
attrs	array(*(char))
[	O
2	int
]	O
;	O
attrs	array(*(char))
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
attr	*(char)
;	O
attrs	array(*(char))
[	O
1	int
]	O
=	O
NULL	O
;	O
if	O
(	O
filter_pat	*(char)
)	O
{	O
filter	*(char)
=	O
_dico_ldap_expand_user	(*(char),*(char))->(*(char))
(	O
filter_pat	*(char)
,	O
user	*(char)
)	O
;	O
if	O
(	O
!	O
filter	*(char)
)	O
{	O
DICO_LOG_MEMERR	O
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
filter	*(char)
=	O
NULL	O
;	O
rc	int
=	O
ldap_search_ext	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
base	*(void)
,	O
LDAP_SCOPE_SUBTREE	O
,	O
filter	*(char)
,	O
attrs	array(*(char))
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
-	O
1	int
,	O
&	O
msgid	*(char)
)	O
;	O
if	O
(	O
filter	*(char)
)	O
free	(*(void))->(void)
(	O
filter	*(char)
)	O
;	O
if	O
(	O
rc	int
!=	O
LDAP_SUCCESS	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_search_ext: %s"	*(char)
,	O
ldap_err2string	()->(int)
(	O
rc	int
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
rc	int
=	O
ldap_result	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
msgid	*(char)
,	O
LDAP_MSG_ALL	O
,	O
NULL	O
,	O
&	O
res	*(char)
)	O
;	O
if	O
(	O
rc	int
<	O
0	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"ldap_result failed"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
res	*(char)
;	O
}	O
static	O
int	O
db_get_pass	(*(void),*(char),*(char),*(*(char)))->(int)
(	O
void	O
*	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
,	O
const	O
char	O
*	O
qpw	*(char)
,	O
const	O
char	O
*	O
key	*(char)
,	O
char	O
*	O
*	O
ppass	*(*(char))
)	O
{	O
struct	O
_dico_ldap_handle	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
*	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
=	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
;	O
LDAPMessage	O
*	O
res	*(char)
,	O
*	O
msg	O
;	O
int	O
rc	int
;	O
struct	O
berval	O
*	O
*	O
values	*(*(struct))
;	O
res	*(char)
=	O
_dico_ldap_search	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))),*(char),*(char),*(char))->(*(int))
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
,	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
user_filter	*(char)
,	O
qpw	*(char)
,	O
key	*(char)
)	O
;	O
if	O
(	O
!	O
res	*(char)
)	O
return	O
1	int
;	O
rc	int
=	O
ldap_count_entries	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
res	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"not enough entires"	*(char)
)	O
;	O
ldap_msgfree	()->(int)
(	O
res	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
msg	O
=	O
ldap_first_entry	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
res	*(char)
)	O
;	O
values	*(*(struct))
=	O
ldap_get_values_len	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
msg	O
,	O
qpw	*(char)
)	O
;	O
if	O
(	O
ldap_count_values_len	()->(int)
(	O
values	*(*(struct))
)	O
==	O
0	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"not enough entires"	*(char)
)	O
;	O
ldap_msgfree	()->(int)
(	O
res	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
*	O
ppass	*(*(char))
=	O
strdup	(*(char))->(*(char))
(	O
values	*(*(struct))
[	O
0	int
]	O
->	O
bv_val	O
)	O
;	O
rc	int
=	O
*	O
ppass	*(*(char))
==	O
NULL	O
;	O
if	O
(	O
rc	int
)	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	*(char)
)	O
;	O
ldap_value_free_len	()->(int)
(	O
values	*(*(struct))
)	O
;	O
ldap_msgfree	()->(int)
(	O
res	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_free_group	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
item	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
db_get_groups	(*(void),*(char),*(char),*(*(struct)))->(int)
(	O
void	O
*	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
,	O
const	O
char	O
*	O
qgr	*(char)
,	O
const	O
char	O
*	O
key	*(char)
,	O
dico_list_t	*(struct)
*	O
pgroups	*(*(struct))
)	O
{	O
struct	O
_dico_ldap_handle	struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))
*	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
=	O
handle	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
;	O
LDAPMessage	O
*	O
res	*(char)
,	O
*	O
msg	O
;	O
int	O
rc	int
;	O
dico_list_t	*(struct)
groups	*(*(struct))
=	O
NULL	O
;	O
res	*(char)
=	O
_dico_ldap_search	(*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char))),*(char),*(char),*(char))->(*(int))
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
,	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
group_filter	*(char)
,	O
qgr	*(char)
,	O
key	*(char)
)	O
;	O
if	O
(	O
!	O
res	*(char)
)	O
return	O
1	int
;	O
rc	int
=	O
ldap_count_entries	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
res	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_INFO	int
,	O
0	int
,	O
"no groups containing %s"	*(char)
,	O
key	*(char)
)	O
;	O
ldap_msgfree	()->(int)
(	O
res	*(char)
)	O
;	O
*	O
pgroups	*(*(struct))
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
groups	*(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
dico_list_set_free_item	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
groups	*(*(struct))
,	O
_free_group	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
*	O
pgroups	*(*(struct))
=	O
groups	*(*(struct))
;	O
rc	int
=	O
0	int
;	O
for	O
(	O
msg	O
=	O
ldap_first_entry	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
res	*(char)
)	O
;	O
msg	O
;	O
msg	O
=	O
ldap_next_entry	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
msg	O
)	O
)	O
{	O
struct	O
berval	O
*	O
*	O
values	*(*(struct))
;	O
size_t	long
i	int
,	O
count	long
;	O
values	*(*(struct))
=	O
ldap_get_values_len	()->(int)
(	O
lp	*(struct(*(int),*(char),*(char),*(char),*(char),int,int,*(char),*(char)))
->	O
ldap	*(int)
,	O
msg	O
,	O
qgr	*(char)
)	O
;	O
count	long
=	O
ldap_count_values_len	()->(int)
(	O
values	*(*(struct))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
char	O
*	O
s	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
values	*(*(struct))
[	O
i	int
]	O
->	O
bv_val	O
)	O
;	O
dico_list_append	(*(struct),*(void))->(int)
(	O
groups	*(*(struct))
,	O
s	*(char)
)	O
;	O
}	O
ldap_value_free_len	()->(int)
(	O
values	*(*(struct))
)	O
;	O
}	O
ldap_msgfree	()->(int)
(	O
res	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
struct	O
dico_udb_def	struct(*(char),*((*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),struct(int,*`,*`,*`,long))),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*(char)))->(int)),*((*(void),*(char),*(char),*(*(struct)))->(int)),*((*(void),*(char),*(char),*(char))->(int)))
ldap_udb_def	struct(*(char),*((*(*(void)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,struct`)),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*(char)))->(int)),*((*(void),*(char),*(char),*(*(struct`)))->(int)),*((*(void),*(char),*(char),*(char))->(int)))
=	O
{	O
"ldap"	*(char)
,	O
db_open	(*(*(void)),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),struct(int,*(char),*(char),*(char),long))),*(char))->(int)
,	O
db_close	(*(void))->(int)
,	O
db_get_pass	(*(void),*(char),*(char),*(*(char)))->(int)
,	O
db_get_groups	(*(void),*(char),*(char),*(*(struct)))->(int)
}	O
;	O
static	O
int	O
dico_ldap_init	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
return	O
dico_udb_define	(*(struct(*(char),*((*`,*`,*`)->(int)),*((*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,*`,*`)->(int)),*((*`,*`,*`,*`)->(int)))))->(int)
(	O
&	O
ldap_udb_def	struct(*(char),*((*(*(void)),*(struct(*`,*`,*`,*`,*`,*`,*`,*`,struct`)),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*(char)))->(int)),*((*(void),*(char),*(char),*(*(struct`)))->(int)),*((*(void),*(char),*(char),*(char))->(int)))
)	O
;	O
}	O
struct	O
dico_database_module	struct(int,int,*((int,*(*(char)))->(int)),*((*(char),int,*(*(char)))->(*(struct))),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(int)),*((*(struct))->(*(char))),*((*(struct))->(*(char))),*((*(struct),array(*(struct)))->(int)),*((*(struct),*(struct),*(char))->(*(struct))),*((*(struct),*(char))->(*(struct))),*((*(struct),long,*(struct))->(int)),*((*(struct))->(long)),*((*(struct))->(long)),*((*(struct))->(void)),*((*(struct),*(struct))->(int)),*((int,*(*(char)))->(int)),*((*(struct))->(*(char))),*((*(char),int,*(*(char)),*(void))->(*(struct))),*((*(struct))->(int)),*((*(struct),long)->(*(struct))))
DICO_EXPORT	O
(	O
ldap	*(int)
,	O
module	O
)	O
=	O
{	O
DICO_MODULE_VERSION	int
,	O
DICO_CAPA_NODB	int
,	O
dico_ldap_init	(int,*(*(char)))->(int)
,	O
}	O
;	O
