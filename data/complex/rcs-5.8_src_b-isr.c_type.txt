void	O
maybe_reset_sigchld	()->(void)
(	O
void	O
)	O
{	O
}	O
static	O
void	O
werr	(*(char))->(void)
(	O
char	O
const	O
*	O
s	*(char)
)	O
{	O
ssize_t	long
len	char
;	O
if	O
(	O
!	O
(	O
len	char
=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
)	O
)	O
return	O
;	O
if	O
(	O
len	char
!=	O
write	*((*(void),*(char),long)->(long))
(	O
STDERR_FILENO	int
,	O
s	*(char)
,	O
len	char
)	O
)	O
PROGRAM	O
(	O
exiterr	*(()->(void))
)	O
(	O
)	O
;	O
}	O
void	O
complain_signal	(*(char),int)->(void)
(	O
char	O
const	O
*	O
msg	*(char)
,	O
int	O
signo	int
)	O
{	O
werr	(*(char))->(void)
(	O
msg	*(char)
)	O
;	O
werr	(*(char))->(void)
(	O
": "	*(char)
)	O
;	O
werr	(*(char))->(void)
(	O
strsignal	(int)->(*(char))
(	O
signo	int
)	O
)	O
;	O
werr	(*(char))->(void)
(	O
"\n"	*(char)
)	O
;	O
}	O
struct	O
isr_scratch	struct(int,int,struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int))),*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int)))),*(char),struct(bool,bool),*(bool))
{	O
sig_atomic_t	int
volatile	O
held	int
,	O
level	int
;	O
siginfo_t	struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int)))
bufinfo	struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int)))
;	O
siginfo_t	struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int)))
*	O
volatile	O
held_info	*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int))))
;	O
char	O
const	O
*	O
access_name	*(char)
;	O
struct	O
{	O
bool	bool
regular	bool
;	O
bool	bool
memory_map	bool
;	O
}	O
catching	struct(bool,bool)
;	O
bool	bool
*	O
be_quiet	*(bool)
;	O
}	O
;	O
void	O
access_page	(*(struct),*(char),*(char))->(void)
(	O
struct	O
isr_scratch	struct(int,int,struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int))),*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int)))),*(char),struct(bool,bool),*(bool))
*	O
scratch	*(struct)
,	O
char	O
const	O
*	O
filename	*(char)
,	O
char	O
const	O
*	O
p	*(char)
)	O
{	O
char	O
volatile	O
t	char
;	O
ISR	O
(	O
access_name	*(char)
)	O
=	O
filename	*(char)
;	O
t	char
=	O
*	O
p	*(char)
;	O
ISR	O
(	O
access_name	*(char)
)	O
=	O
NULL	O
;	O
}	O
static	O
void	O
ignore	(*(struct(int,int,struct(int,int,int,int,union(array(int),struct`,struct`,struct`,struct`,struct`,struct`,struct`)),*(struct(int,int,int,int,union`)),*(char),struct(bool,bool),*(bool))))->(void)
(	O
struct	O
isr_scratch	struct(int,int,struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int))),*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int)))),*(char),struct(bool,bool),*(bool))
*	O
scratch	*(struct)
)	O
{	O
++	O
ISR	O
(	O
level	int
)	O
;	O
}	O
static	O
void	O
catchsigaction	(int,*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union`),struct(int,int,union`),struct(int,int,int,long,long),struct(*`,short,union`),struct(long,int),struct(*`,int,int)))),*(void))->(void)
(	O
int	O
signo	int
,	O
siginfo_t	struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int)))
*	O
info	*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int))))
,	O
RCS_UNUSED	O
void	O
*	O
uc	*(void)
)	O
{	O
struct	O
isr_scratch	struct(int,int,struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int))),*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int)))),*(char),struct(bool,bool),*(bool))
*	O
scratch	*(struct)
=	O
ISR_SCRATCH	O
;	O
bool	bool
from_mmap	bool
=	O
MMAP_SIGNAL	int
&&	O
MMAP_SIGNAL	int
==	O
signo	int
;	O
if	O
(	O
ISR	O
(	O
level	int
)	O
)	O
{	O
ISR	O
(	O
held	int
)	O
=	O
signo	int
;	O
if	O
(	O
info	*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int))))
)	O
{	O
ISR	O
(	O
bufinfo	struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int)))
)	O
=	O
*	O
info	*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int))))
;	O
ISR	O
(	O
held_info	*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int))))
)	O
=	O
&	O
ISR	O
(	O
bufinfo	struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int)))
)	O
;	O
}	O
return	O
;	O
}	O
ignore	(*(struct(int,int,struct(int,int,int,int,union(array(int),struct`,struct`,struct`,struct`,struct`,struct`,struct`)),*(struct(int,int,int,int,union`)),*(char),struct(bool,bool),*(bool))))->(void)
(	O
scratch	*(struct)
)	O
;	O
setrid	()->(void)
(	O
)	O
;	O
if	O
(	O
!	O
*	O
ISR	O
(	O
be_quiet	*(bool)
)	O
)	O
{	O
if	O
(	O
!	O
(	O
from_mmap	bool
&&	O
ISR	O
(	O
access_name	*(char)
)	O
)	O
)	O
{	O
char	O
*	O
nRCS	*(char)
=	O
"\nRCS"	*(char)
;	O
if	O
(	O
from_mmap	bool
&&	O
info	*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int))))
&&	O
info	*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int))))
->	O
si_errno	int
)	O
{	O
errno	O
=	O
info	*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int))))
->	O
si_errno	int
;	O
perror	(*(char))->(void)
(	O
nRCS	*(char)
++	O
)	O
;	O
}	O
if	O
(	O
info	*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int))))
)	O
psiginfo	(*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union`),struct(int,int,union`),struct(int,int,int,long,long),struct(*`,short,union`),struct(long,int),struct(*`,int,int)))),*(char))->(void)
(	O
info	*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int))))
,	O
nRCS	*(char)
)	O
;	O
else	O
complain_signal	(*(char),int)->(void)
(	O
nRCS	*(char)
,	O
signo	int
)	O
;	O
}	O
werr	(*(char))->(void)
(	O
"RCS: "	*(char)
)	O
;	O
if	O
(	O
from_mmap	bool
)	O
{	O
if	O
(	O
ISR	O
(	O
access_name	*(char)
)	O
)	O
{	O
werr	(*(char))->(void)
(	O
ISR	O
(	O
access_name	*(char)
)	O
)	O
;	O
werr	(*(char))->(void)
(	O
": Permission denied.  "	*(char)
)	O
;	O
}	O
else	O
werr	(*(char))->(void)
(	O
"Was a file changed by some other process?  "	*(char)
)	O
;	O
}	O
werr	(*(char))->(void)
(	O
"Cleaning up.\n"	*(char)
)	O
;	O
}	O
PROGRAM	O
(	O
exiterr	*(()->(void))
)	O
(	O
)	O
;	O
}	O
static	O
void	O
setup_catchsig	(long,O)->(void)
(	O
size_t	long
count	long
,	O
int	O
const	O
set	O
[	O
count	long
]	O
)	O
{	O
sigset_t	struct(array(long))
blocked	struct(array(long))
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
blocked	struct(array(long))
)	O
;	O
for	O
(	O
size_t	long
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
MUST	O
(	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
blocked	struct(array(long))
,	O
set	O
[	O
i	int
]	O
)	O
)	O
;	O
for	O
(	O
size_t	long
i	int
=	O
0	int
;	O
i	int
<	O
count	long
;	O
i	int
++	O
)	O
{	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
int	O
sig	int
=	O
set	O
[	O
i	int
]	O
;	O
MUST	O
(	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
sig	int
,	O
NULL	O
,	O
&	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
)	O
;	O
if	O
(	O
SIG_IGN	O
!=	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
)	O
{	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_sigaction	*((int,*(struct(int,int,int,int,union(array(int),struct`,struct`,struct`,struct`,struct`,struct`,struct`))),*(void))->(void))
=	O
catchsigaction	(int,*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union`),struct(int,int,union`),struct(int,int,int,long,long),struct(*`,short,union`),struct(long,int),struct(*`,int,int)))),*(void))->(void)
;	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
|=	O
SA_SIGINFO	int
|	O
SA_ONSTACK	int
;	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
=	O
blocked	struct(array(long))
;	O
if	O
(	O
PROB	O
(	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
sig	int
,	O
&	O
act	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
)	O
)	O
{	O
fail	O
:	O
fatal_sys	(*(char))->(void)
(	O
"signal handling"	*(char)
)	O
;	O
}	O
}	O
}	O
}	O
struct	O
isr_scratch	struct(int,int,struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int))),*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int)))),*(char),struct(bool,bool),*(bool))
*	O
isr_init	(*(bool))->(*(struct))
(	O
bool	bool
*	O
be_quiet	*(bool)
)	O
{	O
struct	O
isr_scratch	struct(int,int,struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int))),*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int)))),*(char),struct(bool,bool),*(bool))
*	O
scratch	*(struct)
=	O
ZLLOC	O
(	O
1	int
,	O
struct	O
isr_scratch	struct(int,int,struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int))),*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int)))),*(char),struct(bool,bool),*(bool))
)	O
;	O
stack_t	struct(*(void),int,long)
ss	struct(*(void),int,long)
=	O
{	O
.	O
ss_sp	*(void)
=	O
alloc	(*(struct(*(char),*(struct),*(void),long)),*(char),long)->(*(void))
(	O
PLEXUS	O
,	O
"sigaltstack"	*(char)
,	O
ISR_STACK_SIZE	O
)	O
,	O
.	O
ss_size	long
=	O
ISR_STACK_SIZE	O
,	O
.	O
ss_flags	int
=	O
0	int
}	O
;	O
if	O
(	O
PROB	O
(	O
sigaltstack	(*(struct(*(void),int,long)),*(struct(*(void),int,long)))->(int)
(	O
&	O
ss	struct(*(void),int,long)
,	O
NULL	O
)	O
)	O
)	O
fatal_sys	(*(char))->(void)
(	O
"sigaltstack"	*(char)
)	O
;	O
ISR	O
(	O
be_quiet	*(bool)
)	O
=	O
be_quiet	*(bool)
;	O
return	O
scratch	*(struct)
;	O
}	O
void	O
isr_do	(*(struct),enum(int,int,int,int))->(void)
(	O
struct	O
isr_scratch	struct(int,int,struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*(void))),struct(int,int,union(int,*(void))),struct(int,int,int,long,long),struct(*(void),short,union(struct(*`,*`),int)),struct(long,int),struct(*(void),int,int))),*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int)))),*(char),struct(bool,bool),*(bool))
*	O
scratch	*(struct)
,	O
enum	O
isr_actions	enum(int,int,int,int)
action	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
action	enum(int,int,int,int)
)	O
{	O
case	O
ISR_CATCHINTS	int
:	O
{	O
int	O
const	O
regular	bool
[	O
]	O
=	O
{	O
SIGHUP	int
,	O
SIGINT	int
,	O
SIGQUIT	int
,	O
SIGPIPE	int
,	O
SIGTERM	int
,	O
SIGXCPU	int
,	O
SIGXFSZ	int
,	O
}	O
;	O
if	O
(	O
!	O
ISR	O
(	O
catching	struct(bool,bool)
.	O
regular	bool
)	O
)	O
{	O
ISR	O
(	O
catching	struct(bool,bool)
.	O
regular	bool
)	O
=	O
true	int
;	O
setup_catchsig	(long,O)->(void)
(	O
COUNT	O
(	O
regular	bool
)	O
,	O
regular	bool
)	O
;	O
}	O
}	O
break	O
;	O
case	O
ISR_IGNOREINTS	int
:	O
ignore	(*(struct(int,int,struct(int,int,int,int,union(array(int),struct`,struct`,struct`,struct`,struct`,struct`,struct`)),*(struct(int,int,int,int,union`)),*(char),struct(bool,bool),*(bool))))->(void)
(	O
scratch	*(struct)
)	O
;	O
break	O
;	O
case	O
ISR_RESTOREINTS	int
:	O
if	O
(	O
!	O
--	O
ISR	O
(	O
level	int
)	O
&&	O
ISR	O
(	O
held	int
)	O
)	O
catchsigaction	(int,*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union`),struct(int,int,union`),struct(int,int,int,long,long),struct(*`,short,union`),struct(long,int),struct(*`,int,int)))),*(void))->(void)
(	O
ISR	O
(	O
held	int
)	O
,	O
ISR	O
(	O
held_info	*(struct(int,int,int,int,union(array(int),struct(int,int),struct(int,int,union(int,*`)),struct(int,int,union(int,*`)),struct(int,int,int,long,long),struct(*(void),short,union(struct`,int)),struct(long,int),struct(*(void),int,int))))
)	O
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
ISR_CATCHMMAPINTS	int
:	O
{	O
int	O
const	O
mmapsigs	array(int)
[	O
]	O
=	O
{	O
MMAP_SIGNAL	int
}	O
;	O
if	O
(	O
MMAP_SIGNAL	int
&&	O
!	O
ISR	O
(	O
catching	struct(bool,bool)
.	O
memory_map	bool
)	O
)	O
{	O
ISR	O
(	O
catching	struct(bool,bool)
.	O
memory_map	bool
)	O
=	O
true	int
;	O
setup_catchsig	(long,O)->(void)
(	O
COUNT	O
(	O
mmapsigs	array(int)
)	O
,	O
mmapsigs	array(int)
)	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
