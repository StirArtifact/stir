double	O
gsl_ldexp	(double,int)->(double)
(	O
const	O
double	O
x	double
,	O
const	O
int	O
e	int
)	O
{	O
int	O
ex	int
;	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
return	O
x	double
;	O
}	O
{	O
double	O
y	double
=	O
gsl_frexp	(double,*(int))->(double)
(	O
x	double
,	O
&	O
ex	int
)	O
;	O
double	O
e2	double
=	O
e	int
+	O
ex	int
,	O
p2	double
;	O
if	O
(	O
e2	double
>=	O
DBL_MAX_EXP	O
)	O
{	O
y	double
*=	O
pow	(double,double)->(double)
(	O
2.0	int
,	O
e2	double
-	O
DBL_MAX_EXP	O
+	O
1	int
)	O
;	O
e2	double
=	O
DBL_MAX_EXP	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
e2	double
<=	O
DBL_MIN_EXP	O
)	O
{	O
y	double
*=	O
pow	(double,double)->(double)
(	O
2.0	int
,	O
e2	double
-	O
DBL_MIN_EXP	O
-	O
1	int
)	O
;	O
e2	double
=	O
DBL_MIN_EXP	O
+	O
1	int
;	O
}	O
p2	double
=	O
pow	(double,double)->(double)
(	O
2.0	int
,	O
e2	double
)	O
;	O
return	O
y	double
*	O
p2	double
;	O
}	O
}	O
double	O
gsl_frexp	(double,*(int))->(double)
(	O
const	O
double	O
x	double
,	O
int	O
*	O
e	int
)	O
{	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
*	O
e	int
=	O
0	int
;	O
return	O
0.0	int
;	O
}	O
else	O
if	O
(	O
!	O
gsl_finite	(double)->(int)
(	O
x	double
)	O
)	O
{	O
*	O
e	int
=	O
0	int
;	O
return	O
x	double
;	O
}	O
else	O
if	O
(	O
fabs	(double)->(double)
(	O
x	double
)	O
>=	O
0.5	int
&&	O
fabs	(double)->(double)
(	O
x	double
)	O
<	O
1	int
)	O
{	O
*	O
e	int
=	O
0	int
;	O
return	O
x	double
;	O
}	O
else	O
{	O
double	O
ex	int
=	O
ceil	(double)->(double)
(	O
log	(double)->(double)
(	O
fabs	(double)->(double)
(	O
x	double
)	O
)	O
/	O
M_LN2	int
)	O
;	O
int	O
ei	int
=	O
(	O
int	O
)	O
ex	int
;	O
double	O
f	*(double)
;	O
if	O
(	O
ei	int
<	O
DBL_MIN_EXP	O
)	O
ei	int
=	O
DBL_MIN_EXP	O
;	O
if	O
(	O
ei	int
>	O
-	O
DBL_MIN_EXP	O
)	O
ei	int
=	O
-	O
DBL_MIN_EXP	O
;	O
f	*(double)
=	O
x	double
*	O
pow	(double,double)->(double)
(	O
2.0	int
,	O
-	O
ei	int
)	O
;	O
if	O
(	O
!	O
gsl_finite	(double)->(int)
(	O
f	*(double)
)	O
)	O
{	O
*	O
e	int
=	O
0	int
;	O
return	O
f	*(double)
;	O
}	O
while	O
(	O
fabs	(double)->(double)
(	O
f	*(double)
)	O
>=	O
1.0	int
)	O
{	O
ei	int
++	O
;	O
f	*(double)
/=	O
2.0	int
;	O
}	O
while	O
(	O
fabs	(double)->(double)
(	O
f	*(double)
)	O
>	O
0	int
&&	O
fabs	(double)->(double)
(	O
f	*(double)
)	O
<	O
0.5	int
)	O
{	O
ei	int
--	O
;	O
f	*(double)
*=	O
2.0	int
;	O
}	O
*	O
e	int
=	O
ei	int
;	O
return	O
f	*(double)
;	O
}	O
}	O
