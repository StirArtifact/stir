MAV_timer	O
Atimer	int
;	O
extern	O
int	O
wire	int
;	O
char	O
files	array(array(char))
[	O
NUM_PARTS	int
]	O
[	O
100	int
]	O
=	O
{	O
"./models/hips.ac"	*(char)
,	O
"./models/neck.ac"	*(char)
,	O
"./models/head.ac"	*(char)
,	O
"./models/left_clavicle.ac"	*(char)
,	O
"./models/right_clavicle.ac"	*(char)
,	O
"./models/right_hand.ac"	*(char)
,	O
"./models/right_lower_arm.ac"	*(char)
,	O
"./models/right_upper_arm.ac"	*(char)
,	O
"./models/left_hand.ac"	*(char)
,	O
"./models/left_lower_arm.ac"	*(char)
,	O
"./models/left_upper_arm.ac"	*(char)
,	O
"./models/lower_torso.ac"	*(char)
,	O
"./models/upper_torso.ac"	*(char)
,	O
"./models/left_upper_leg.ac"	*(char)
,	O
"./models/left_lower_leg.ac"	*(char)
,	O
"./models/left_foot.ac"	*(char)
,	O
"./models/right_upper_leg.ac"	*(char)
,	O
"./models/right_lower_leg.ac"	*(char)
,	O
"./models/right_foot.ac"	*(char)
,	O
}	O
;	O
int	O
part_colours	array(int)
[	O
NUM_PARTS	int
]	O
=	O
{	O
COLOUR_BLUE	int
,	O
COLOUR_SKIN	int
,	O
COLOUR_HAIR	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_SKIN	int
,	O
COLOUR_SKIN	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_SKIN	int
,	O
COLOUR_SKIN	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_WHITE	int
,	O
COLOUR_BLUE	int
,	O
COLOUR_BLUE	int
,	O
COLOUR_BLACK	int
,	O
COLOUR_BLUE	int
,	O
COLOUR_BLUE	int
,	O
COLOUR_BLACK	int
}	O
;	O
MAV_vector	O
offsets	array(int)
[	O
NUM_PARTS	int
]	O
=	O
{	O
{	O
-	O
0.072	int
,	O
7.21202	int
,	O
-	O
1.703075	int
}	O
,	O
{	O
-	O
0.00084	int
,	O
2.90589	int
,	O
1.347075	int
}	O
,	O
{	O
-	O
0.00367	int
,	O
10.65	int
,	O
1.9961	int
}	O
,	O
{	O
-	O
8.31702	int
,	O
-	O
5.29735	int
,	O
0.037970	int
}	O
,	O
{	O
8.31702	int
,	O
-	O
5.29735	int
,	O
0.037970	int
}	O
,	O
{	O
0.970001	int
,	O
-	O
7.85	int
,	O
-	O
4.4	int
}	O
,	O
{	O
0.0	int
,	O
-	O
12.649045	int
,	O
0.0	int
}	O
,	O
{	O
0.488288	int
,	O
-	O
17.43445	int
,	O
0.0	int
}	O
,	O
{	O
-	O
0.97	int
,	O
-	O
7.85	int
,	O
-	O
4.4	int
}	O
,	O
{	O
0.0	int
,	O
-	O
12.649045	int
,	O
0.0	int
}	O
,	O
{	O
-	O
1.063061	int
,	O
-	O
17.43445	int
,	O
0.0	int
}	O
,	O
{	O
0.0	int
,	O
8.124279	int
,	O
5.2517	int
}	O
,	O
{	O
0.483099	int
,	O
-	O
13.877290	int
,	O
2.426865	int
}	O
,	O
{	O
-	O
1.068495	int
,	O
-	O
17.356901	int
,	O
-	O
1.86941	int
}	O
,	O
{	O
0.0	int
,	O
-	O
16.551956	int
,	O
0.0	int
}	O
,	O
{	O
-	O
0.164850	int
,	O
-	O
6.564404	int
,	O
6.861835	int
}	O
,	O
{	O
0.90647	int
,	O
-	O
17.356901	int
,	O
-	O
1.84463	int
}	O
,	O
{	O
0.0	int
,	O
-	O
16.551956	int
,	O
0.0	int
}	O
,	O
{	O
-	O
0.164850	int
,	O
-	O
6.564404	int
,	O
6.861835	int
}	O
,	O
}	O
;	O
int	O
relationship	array(array(int))
[	O
NUM_PARTS	int
]	O
[	O
2	int
]	O
=	O
{	O
{	O
HIPS	int
,	O
-	O
1	int
}	O
,	O
{	O
LEFT_UPPER_LEG	int
,	O
HIPS	int
}	O
,	O
{	O
LEFT_LOWER_LEG	int
,	O
LEFT_UPPER_LEG	int
}	O
,	O
{	O
LEFT_FOOT	int
,	O
LEFT_LOWER_LEG	int
}	O
,	O
{	O
RIGHT_UPPER_LEG	int
,	O
HIPS	int
}	O
,	O
{	O
RIGHT_LOWER_LEG	int
,	O
RIGHT_UPPER_LEG	int
}	O
,	O
{	O
RIGHT_FOOT	int
,	O
RIGHT_LOWER_LEG	int
}	O
,	O
{	O
LOWER_TORSO	int
,	O
HIPS	int
}	O
,	O
{	O
UPPER_TORSO	int
,	O
LOWER_TORSO	int
}	O
,	O
{	O
NECK	int
,	O
UPPER_TORSO	int
}	O
,	O
{	O
HEAD	int
,	O
NECK	int
}	O
,	O
{	O
LEFT_CLAVICLE	int
,	O
UPPER_TORSO	int
}	O
,	O
{	O
RIGHT_CLAVICLE	int
,	O
UPPER_TORSO	int
}	O
,	O
{	O
LEFT_UPPER_ARM	int
,	O
LEFT_CLAVICLE	int
}	O
,	O
{	O
LEFT_LOWER_ARM	int
,	O
LEFT_UPPER_ARM	int
}	O
,	O
{	O
LEFT_HAND	int
,	O
LEFT_LOWER_ARM	int
}	O
,	O
{	O
RIGHT_UPPER_ARM	int
,	O
RIGHT_CLAVICLE	int
}	O
,	O
{	O
RIGHT_LOWER_ARM	int
,	O
RIGHT_UPPER_ARM	int
}	O
,	O
{	O
RIGHT_HAND	int
,	O
RIGHT_LOWER_ARM	int
}	O
}	O
;	O
MAV_vector	O
relative_positions	array(int)
[	O
NUM_PARTS	int
]	O
=	O
{	O
{	O
0.000000	int
,	O
0.000000	int
,	O
0.000000	int
}	O
,	O
{	O
-	O
8.400009	int
,	O
0.000000	int
,	O
0.000000	int
}	O
,	O
{	O
0.000000	int
,	O
-	O
40.720001	int
,	O
0.000000	int
}	O
,	O
{	O
0.000000	int
,	O
-	O
34.529999	int
,	O
0.000000	int
}	O
,	O
{	O
8.399997	int
,	O
0.000000	int
,	O
0.000000	int
}	O
,	O
{	O
0.000004	int
,	O
-	O
40.720001	int
,	O
0.000000	int
}	O
,	O
{	O
0.000003	int
,	O
-	O
34.529999	int
,	O
0.000000	int
}	O
,	O
{	O
0.000000	int
,	O
13.099998	int
,	O
-	O
5.500000	int
}	O
,	O
{	O
0.000000	int
,	O
47.055008	int
,	O
1.463499	int
}	O
,	O
{	O
0.000000	int
,	O
2.174988	int
,	O
0.807901	int
}	O
,	O
{	O
0.000000	int
,	O
4.340012	int
,	O
0.000000	int
}	O
,	O
{	O
-	O
3.680010	int
,	O
-	O
3.215012	int
,	O
0.807901	int
}	O
,	O
{	O
3.680000	int
,	O
-	O
3.215012	int
,	O
0.807901	int
}	O
,	O
{	O
-	O
16.14008	int
,	O
1.029999	int
,	O
0.000000	int
}	O
,	O
{	O
0.000000	int
,	O
-	O
31.339996	int
,	O
0.000000	int
}	O
,	O
{	O
0.969999	int
,	O
-	O
27.020401	int
,	O
4.650000	int
}	O
,	O
{	O
16.14008	int
,	O
1.029999	int
,	O
0.000000	int
}	O
,	O
{	O
0.000000	int
,	O
-	O
31.339996	int
,	O
0.000000	int
}	O
,	O
{	O
-	O
0.970000	int
,	O
-	O
27.020401	int
,	O
4.650000	int
}	O
}	O
;	O
double	O
mav_getTimer	()->(double)
(	O
void	O
)	O
{	O
mav_timerStop	()->(int)
(	O
&	O
Atimer	int
)	O
;	O
return	O
Atimer	int
.	O
wall	O
;	O
}	O
int	O
mav_avatarGetMatrix	(*(int),*(*(int)))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_matrix	O
*	O
*	O
mat	*(*(int))
)	O
{	O
*	O
mat	*(*(int))
=	O
&	O
(	O
(	O
(	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
*	O
)	O
obj	*(int)
->	O
the_data	O
)	O
->	O
matrix	int
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mav_avatarGetUserdef	(*(int),*(*(*(void))))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
void	O
*	O
*	O
*	O
ud	*(*(*(void)))
)	O
{	O
*	O
ud	*(*(*(void)))
=	O
&	O
(	O
(	O
(	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
*	O
)	O
obj	*(int)
->	O
the_data	O
)	O
->	O
userdef	*(void)
)	O
;	O
return	O
1	int
;	O
}	O
void	O
mav_partBBox	(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),int,*(int))->(void)
(	O
MAV_part	struct(int,int,*(int),int,int,*(struct))
*	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
,	O
MAV_matrix	O
mat	*(*(int))
,	O
MAV_BB	O
*	O
bb	int
)	O
{	O
MAV_partptr	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),*(struct(*(struct(int,int,*`,int,int,*`)),*(struct(*`,*`)))))
*	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
;	O
MAV_object	O
*	O
obj	*(int)
;	O
MAV_BB	O
objbb	O
;	O
MAV_BB	O
bbox	O
;	O
mat	*(*(int))
=	O
mav_matrixMult	()->(int)
(	O
mat	*(*(int))
,	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
->	O
position	int
)	O
;	O
mat	*(*(int))
=	O
mav_matrixMult	()->(int)
(	O
mat	*(*(int))
,	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
->	O
rotation	int
)	O
;	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
=	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
->	O
children	*(struct)
;	O
while	O
(	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
)	O
{	O
mav_partBBox	(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),int,*(int))->(void)
(	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
->	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
,	O
mat	*(*(int))
,	O
bb	int
)	O
;	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
=	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
;	O
}	O
mav_listPointerReset	()->(int)
(	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
->	O
objects	*(int)
)	O
;	O
while	O
(	O
mav_listItemNext	()->(int)
(	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
->	O
objects	*(int)
,	O
(	O
void	O
*	O
)	O
&	O
obj	*(int)
)	O
)	O
{	O
mav_callbackBBExec	()->(int)
(	O
mav_win_current	O
,	O
obj	*(int)
,	O
&	O
objbb	O
)	O
;	O
mav_BBAlign	()->(int)
(	O
objbb	O
,	O
mat	*(*(int))
,	O
&	O
bbox	O
)	O
;	O
if	O
(	O
bbox	O
.	O
min	O
.	O
x	O
<	O
bb	int
->	O
min	O
.	O
x	O
)	O
bb	int
->	O
min	O
.	O
x	O
=	O
bbox	O
.	O
min	O
.	O
x	O
;	O
if	O
(	O
bbox	O
.	O
min	O
.	O
y	O
<	O
bb	int
->	O
min	O
.	O
y	O
)	O
bb	int
->	O
min	O
.	O
y	O
=	O
bbox	O
.	O
min	O
.	O
y	O
;	O
if	O
(	O
bbox	O
.	O
min	O
.	O
z	O
<	O
bb	int
->	O
min	O
.	O
z	O
)	O
bb	int
->	O
min	O
.	O
z	O
=	O
bbox	O
.	O
min	O
.	O
z	O
;	O
if	O
(	O
bbox	O
.	O
max	O
.	O
x	O
>	O
bb	int
->	O
max	O
.	O
x	O
)	O
bb	int
->	O
max	O
.	O
x	O
=	O
bbox	O
.	O
max	O
.	O
x	O
;	O
if	O
(	O
bbox	O
.	O
max	O
.	O
y	O
>	O
bb	int
->	O
max	O
.	O
y	O
)	O
bb	int
->	O
max	O
.	O
y	O
=	O
bbox	O
.	O
max	O
.	O
y	O
;	O
if	O
(	O
bbox	O
.	O
max	O
.	O
z	O
>	O
bb	int
->	O
max	O
.	O
z	O
)	O
bb	int
->	O
max	O
.	O
z	O
=	O
bbox	O
.	O
max	O
.	O
z	O
;	O
}	O
}	O
int	O
mav_avatarBBox	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_BB	O
*	O
bb	int
)	O
{	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
*	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
=	O
(	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
*	O
)	O
obj	*(int)
->	O
the_data	O
;	O
MAV_matrix	O
mat	*(*(int))
;	O
MAV_BB	O
bbox	O
;	O
mat	*(*(int))
=	O
MAV_ID_MATRIX	O
;	O
bbox	O
.	O
min	O
.	O
x	O
=	O
bbox	O
.	O
min	O
.	O
y	O
=	O
bbox	O
.	O
min	O
.	O
z	O
=	O
10000000.0	int
;	O
bbox	O
.	O
max	O
.	O
x	O
=	O
bbox	O
.	O
max	O
.	O
y	O
=	O
bbox	O
.	O
max	O
.	O
z	O
=	O
-	O
10000000.0	int
;	O
mav_partBBox	(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),int,*(int))->(void)
(	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
root	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
,	O
mat	*(*(int))
,	O
&	O
bbox	O
)	O
;	O
mav_BBAlign	()->(int)
(	O
bbox	O
,	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
vertical	int
,	O
&	O
bbox	O
)	O
;	O
mav_BBAlign	()->(int)
(	O
bbox	O
,	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
matrix	int
,	O
bb	int
)	O
;	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
bb	int
=	O
*	O
bb	int
;	O
return	O
1	int
;	O
}	O
void	O
mav_BBDisplayWireWithSurfaceParams	(*(int),int,int)->(void)
(	O
MAV_window	O
*	O
w	*(int)
,	O
MAV_BB	O
bb	int
,	O
MAV_surfaceParams	O
sp	int
)	O
{	O
MAV_vector	O
vert	O
[	O
8	int
]	O
;	O
MAV_vector	O
norm	O
;	O
vert	O
[	O
0	int
]	O
.	O
x	O
=	O
bb	int
.	O
min	O
.	O
x	O
;	O
vert	O
[	O
0	int
]	O
.	O
y	O
=	O
bb	int
.	O
min	O
.	O
y	O
;	O
vert	O
[	O
0	int
]	O
.	O
z	O
=	O
bb	int
.	O
min	O
.	O
z	O
;	O
vert	O
[	O
1	int
]	O
.	O
x	O
=	O
bb	int
.	O
min	O
.	O
x	O
;	O
vert	O
[	O
1	int
]	O
.	O
y	O
=	O
bb	int
.	O
max	O
.	O
y	O
;	O
vert	O
[	O
1	int
]	O
.	O
z	O
=	O
bb	int
.	O
min	O
.	O
z	O
;	O
vert	O
[	O
2	int
]	O
.	O
x	O
=	O
bb	int
.	O
max	O
.	O
x	O
;	O
vert	O
[	O
2	int
]	O
.	O
y	O
=	O
bb	int
.	O
min	O
.	O
y	O
;	O
vert	O
[	O
2	int
]	O
.	O
z	O
=	O
bb	int
.	O
min	O
.	O
z	O
;	O
vert	O
[	O
3	int
]	O
.	O
x	O
=	O
bb	int
.	O
max	O
.	O
x	O
;	O
vert	O
[	O
3	int
]	O
.	O
y	O
=	O
bb	int
.	O
max	O
.	O
y	O
;	O
vert	O
[	O
3	int
]	O
.	O
z	O
=	O
bb	int
.	O
min	O
.	O
z	O
;	O
vert	O
[	O
4	int
]	O
.	O
x	O
=	O
bb	int
.	O
min	O
.	O
x	O
;	O
vert	O
[	O
4	int
]	O
.	O
y	O
=	O
bb	int
.	O
min	O
.	O
y	O
;	O
vert	O
[	O
4	int
]	O
.	O
z	O
=	O
bb	int
.	O
max	O
.	O
z	O
;	O
vert	O
[	O
5	int
]	O
.	O
x	O
=	O
bb	int
.	O
min	O
.	O
x	O
;	O
vert	O
[	O
5	int
]	O
.	O
y	O
=	O
bb	int
.	O
max	O
.	O
y	O
;	O
vert	O
[	O
5	int
]	O
.	O
z	O
=	O
bb	int
.	O
max	O
.	O
z	O
;	O
vert	O
[	O
6	int
]	O
.	O
x	O
=	O
bb	int
.	O
max	O
.	O
x	O
;	O
vert	O
[	O
6	int
]	O
.	O
y	O
=	O
bb	int
.	O
min	O
.	O
y	O
;	O
vert	O
[	O
6	int
]	O
.	O
z	O
=	O
bb	int
.	O
max	O
.	O
z	O
;	O
vert	O
[	O
7	int
]	O
.	O
x	O
=	O
bb	int
.	O
max	O
.	O
x	O
;	O
vert	O
[	O
7	int
]	O
.	O
y	O
=	O
bb	int
.	O
max	O
.	O
y	O
;	O
vert	O
[	O
7	int
]	O
.	O
z	O
=	O
bb	int
.	O
max	O
.	O
z	O
;	O
sp	int
.	O
mode	O
=	O
MAV_MATERIAL	O
;	O
mav_surfaceParamsUse	()->(int)
(	O
&	O
sp	int
)	O
;	O
norm	O
.	O
x	O
=	O
0.0	int
;	O
norm	O
.	O
y	O
=	O
0.0	int
;	O
norm	O
.	O
z	O
=	O
-	O
1.0	int
;	O
mav_gfxNormal	()->(int)
(	O
norm	O
)	O
;	O
mav_gfxLineClosedBegin	()->(int)
(	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
0	int
]	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
1	int
]	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
3	int
]	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
2	int
]	O
)	O
;	O
mav_gfxLineClosedEnd	()->(int)
(	O
)	O
;	O
norm	O
.	O
z	O
=	O
1.0	int
;	O
mav_gfxNormal	()->(int)
(	O
norm	O
)	O
;	O
mav_gfxLineClosedBegin	()->(int)
(	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
4	int
]	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
5	int
]	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
7	int
]	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
6	int
]	O
)	O
;	O
mav_gfxLineClosedEnd	()->(int)
(	O
)	O
;	O
norm	O
.	O
x	O
=	O
-	O
1.0	int
;	O
norm	O
.	O
z	O
=	O
0.0	int
;	O
mav_gfxNormal	()->(int)
(	O
norm	O
)	O
;	O
mav_gfxLineBegin	()->(int)
(	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
0	int
]	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
4	int
]	O
)	O
;	O
mav_gfxLineEnd	()->(int)
(	O
)	O
;	O
norm	O
.	O
x	O
=	O
0.0	int
;	O
norm	O
.	O
y	O
=	O
1.0	int
;	O
mav_gfxNormal	()->(int)
(	O
norm	O
)	O
;	O
mav_gfxLineBegin	()->(int)
(	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
1	int
]	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
5	int
]	O
)	O
;	O
mav_gfxLineEnd	()->(int)
(	O
)	O
;	O
mav_gfxLineBegin	()->(int)
(	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
3	int
]	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
7	int
]	O
)	O
;	O
mav_gfxLineEnd	()->(int)
(	O
)	O
;	O
norm	O
.	O
y	O
=	O
-	O
1.0	int
;	O
mav_gfxNormal	()->(int)
(	O
norm	O
)	O
;	O
mav_gfxLineBegin	()->(int)
(	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
2	int
]	O
)	O
;	O
mav_gfxVertex	()->(int)
(	O
vert	O
[	O
6	int
]	O
)	O
;	O
mav_gfxLineEnd	()->(int)
(	O
)	O
;	O
}	O
void	O
mav_partDraw	(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),float)->(void)
(	O
MAV_part	struct(int,int,*(int),int,int,*(struct))
*	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
,	O
float	O
dist	float
)	O
{	O
MAV_partptr	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),*(struct(*(struct(int,int,*`,int,int,*`)),*(struct(*`,*`)))))
*	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
;	O
MAV_object	O
*	O
obj	*(int)
;	O
MAV_composite	O
*	O
comp	O
;	O
MAV_surfaceParams	O
*	O
*	O
sp	int
;	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
->	O
position	int
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
->	O
rotation	int
)	O
;	O
mav_listPointerReset	()->(int)
(	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
->	O
objects	*(int)
)	O
;	O
while	O
(	O
mav_listItemNext	()->(int)
(	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
->	O
objects	*(int)
,	O
(	O
void	O
*	O
)	O
&	O
obj	*(int)
)	O
)	O
{	O
if	O
(	O
!	O
wire	int
&&	O
dist	float
>	O
1000.0	int
)	O
{	O
comp	O
=	O
(	O
MAV_composite	O
*	O
)	O
obj	*(int)
->	O
the_data	O
;	O
if	O
(	O
comp	O
->	O
numobj	O
>	O
0	int
)	O
{	O
mav_callbackGetSurfaceParamsExec	()->(int)
(	O
mav_win_current	O
,	O
comp	O
->	O
obj	*(int)
[	O
0	int
]	O
,	O
&	O
sp	int
)	O
;	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
comp	O
->	O
matrix	int
)	O
;	O
mav_BBDisplayWireWithSurfaceParams	(*(int),int,int)->(void)
(	O
mav_win_current	O
,	O
comp	O
->	O
bb	int
,	O
*	O
*	O
sp	int
)	O
;	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
wire	int
&&	O
dist	float
>	O
500.0	int
)	O
{	O
comp	O
=	O
(	O
MAV_composite	O
*	O
)	O
obj	*(int)
->	O
the_data	O
;	O
if	O
(	O
comp	O
->	O
numobj	O
>	O
0	int
)	O
{	O
mav_callbackGetSurfaceParamsExec	()->(int)
(	O
mav_win_current	O
,	O
comp	O
->	O
obj	*(int)
[	O
0	int
]	O
,	O
&	O
sp	int
)	O
;	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
comp	O
->	O
matrix	int
)	O
;	O
mav_BBDisplayWithSurfaceParams	()->(int)
(	O
mav_win_current	O
,	O
comp	O
->	O
bb	int
,	O
*	O
sp	int
)	O
;	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
}	O
}	O
else	O
mav_callbackDrawExec	()->(int)
(	O
mav_win_current	O
,	O
obj	*(int)
,	O
NULL	O
)	O
;	O
}	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
=	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
->	O
children	*(struct)
;	O
while	O
(	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
)	O
{	O
mav_partDraw	(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),float)->(void)
(	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
->	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
,	O
dist	float
)	O
;	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
=	O
p	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
;	O
}	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
}	O
int	O
mav_avatarDraw	(*(int),*(int))->(int)
(	O
MAV_object	O
*	O
obj	*(int)
,	O
MAV_drawInfo	O
*	O
di	*(int)
)	O
{	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
*	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
=	O
(	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
*	O
)	O
obj	*(int)
->	O
the_data	O
;	O
MAV_vector	O
dr	O
;	O
float	O
dd	float
;	O
dr	O
.	O
x	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
x	O
-	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
matrix	int
.	O
mat	*(*(int))
[	O
MAV_MATRIX_XCOMP	O
]	O
;	O
dr	O
.	O
y	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
y	O
-	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
matrix	int
.	O
mat	*(*(int))
[	O
MAV_MATRIX_YCOMP	O
]	O
;	O
dr	O
.	O
z	O
=	O
mav_win_current	O
->	O
vp	O
->	O
eye	O
.	O
z	O
-	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
matrix	int
.	O
mat	*(*(int))
[	O
MAV_MATRIX_ZCOMP	O
]	O
;	O
dd	float
=	O
dr	O
.	O
x	O
*	O
dr	O
.	O
x	O
+	O
dr	O
.	O
y	O
*	O
dr	O
.	O
y	O
+	O
dr	O
.	O
z	O
*	O
dr	O
.	O
z	O
;	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
drawn	int
=	O
1	int
;	O
if	O
(	O
mav_win_current	O
==	O
mav_win_left	O
)	O
mav_avatarAnimate	(*(struct(*(struct(int,int,*`,int,int,*`)),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*`)),int,int,int,int,int,float,int,float,float,*(void))))->(void)
(	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
)	O
;	O
mav_gfxMatrixPush	()->(int)
(	O
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
matrix	int
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
vertical	int
)	O
;	O
mav_gfxMatrixMult	()->(int)
(	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
rotation	int
)	O
;	O
mav_partDraw	(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),float)->(void)
(	O
a	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
root	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
,	O
dd	float
)	O
;	O
mav_gfxMatrixPop	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
void	O
mav_avatarInitialise	()->(void)
(	O
void	O
)	O
{	O
mav_paletteColourSet	()->(int)
(	O
mav_palette_default	O
,	O
COLOUR_WHITE	int
,	O
0.627	int
,	O
0.743	int
,	O
0.878	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	()->(int)
(	O
mav_palette_default	O
,	O
COLOUR_BLACK	int
,	O
0.267	int
,	O
0.267	int
,	O
0.267	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	()->(int)
(	O
mav_palette_default	O
,	O
COLOUR_SKIN	int
,	O
0.800	int
,	O
0.544	int
,	O
0.455	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	()->(int)
(	O
mav_palette_default	O
,	O
COLOUR_HAIR	int
,	O
0.267	int
,	O
0.145	int
,	O
0.020	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	()->(int)
(	O
mav_palette_default	O
,	O
COLOUR_BLUE	int
,	O
0.043	int
,	O
0.282	int
,	O
0.529	int
,	O
0.0	int
)	O
;	O
mav_timerStart	()->(int)
(	O
&	O
Atimer	int
)	O
;	O
}	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
*	O
mav_avatarBuild	(*(struct(int,*(struct(int,int,float,float,float,int,*`)))),*(int),*(int))->(*(struct(*(struct(int,int,*`,int,int,*`)),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*`)),int,int,int,int,int,float,int,float,float,*(void))))
(	O
MAV_avatarCurves	struct(int,*(struct(int,int,float,float,float,int,*(struct(array(float),array(float))))))
*	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
,	O
MAV_surfaceParams	O
*	O
jumper	*(int)
,	O
MAV_surfaceParams	O
*	O
trousers	*(int)
)	O
{	O
int	O
i	int
,	O
j	int
,	O
n	int
;	O
MAV_matrix	O
matrix	int
;	O
MAV_facet	O
*	O
fc	O
;	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
;	O
MAV_BB	O
bb	int
;	O
MAV_composite	O
*	O
avatarComps	O
[	O
NUM_PARTS	int
]	O
;	O
MAV_partptr	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),*(struct(*(struct(int,int,*`,int,int,*`)),*(struct(*`,*`)))))
*	O
pptr	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
=	O
mav_malloc	()->(int)
(	O
sizeof	O
(	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
)	O
)	O
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
last_time	float
=	O
-	O
1.0	int
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
=	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
offset	float
=	O
0.0	int
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
speed	float
=	O
0.0	int
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
drawn	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_PARTS	int
;	O
i	int
++	O
)	O
{	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
i	int
]	O
=	O
mav_malloc	()->(int)
(	O
sizeof	O
(	O
MAV_part	struct(int,int,*(int),int,int,*(struct))
)	O
)	O
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
i	int
]	O
->	O
part_num	int
=	O
i	int
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
i	int
]	O
->	O
colour	int
=	O
part_colours	array(int)
[	O
i	int
]	O
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
i	int
]	O
->	O
objects	*(int)
=	O
mav_listNew	()->(int)
(	O
)	O
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
i	int
]	O
->	O
position	int
=	O
MAV_ID_MATRIX	O
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
i	int
]	O
->	O
rotation	int
=	O
MAV_ID_MATRIX	O
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
i	int
]	O
->	O
children	*(struct)
=	O
NULL	O
;	O
avatarComps	O
[	O
i	int
]	O
=	O
mav_malloc	()->(int)
(	O
sizeof	O
(	O
MAV_composite	O
)	O
)	O
;	O
matrix	int
=	O
mav_matrixSet	()->(int)
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
offsets	array(int)
[	O
i	int
]	O
.	O
x	O
,	O
offsets	array(int)
[	O
i	int
]	O
.	O
y	O
,	O
offsets	array(int)
[	O
i	int
]	O
.	O
z	O
)	O
;	O
mav_compositeReadAC3D	()->(int)
(	O
files	array(array(char))
[	O
i	int
]	O
,	O
avatarComps	O
[	O
i	int
]	O
,	O
matrix	int
)	O
;	O
avatarComps	O
[	O
i	int
]	O
->	O
matrix	int
=	O
MAV_ID_MATRIX	O
;	O
avatarComps	O
[	O
i	int
]	O
->	O
matrix	int
=	O
mav_matrixScaleSet	()->(int)
(	O
avatarComps	O
[	O
i	int
]	O
->	O
matrix	int
,	O
0.010211582	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
avatarComps	O
[	O
i	int
]	O
->	O
numobj	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
UPPER_TORSO	int
||	O
i	int
==	O
LOWER_TORSO	int
||	O
i	int
==	O
LEFT_CLAVICLE	int
||	O
i	int
==	O
RIGHT_CLAVICLE	int
||	O
i	int
==	O
LEFT_UPPER_ARM	int
||	O
i	int
==	O
RIGHT_UPPER_ARM	int
||	O
i	int
==	O
LEFT_LOWER_ARM	int
||	O
i	int
==	O
RIGHT_LOWER_ARM	int
)	O
{	O
if	O
(	O
avatarComps	O
[	O
i	int
]	O
->	O
obj	*(int)
[	O
j	int
]	O
->	O
the_class	O
==	O
mav_class_facet	O
)	O
{	O
fc	O
=	O
(	O
MAV_facet	O
*	O
)	O
avatarComps	O
[	O
i	int
]	O
->	O
obj	*(int)
[	O
j	int
]	O
->	O
the_data	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
fc	O
->	O
npolys	O
;	O
n	int
++	O
)	O
fc	O
->	O
sp	int
[	O
n	int
]	O
=	O
jumper	*(int)
;	O
}	O
}	O
else	O
if	O
(	O
i	int
==	O
HIPS	int
||	O
i	int
==	O
LEFT_UPPER_LEG	int
||	O
i	int
==	O
RIGHT_UPPER_LEG	int
||	O
i	int
==	O
LEFT_LOWER_LEG	int
||	O
i	int
==	O
RIGHT_LOWER_LEG	int
)	O
{	O
if	O
(	O
avatarComps	O
[	O
i	int
]	O
->	O
obj	*(int)
[	O
j	int
]	O
->	O
the_class	O
==	O
mav_class_facet	O
)	O
{	O
fc	O
=	O
(	O
MAV_facet	O
*	O
)	O
avatarComps	O
[	O
i	int
]	O
->	O
obj	*(int)
[	O
j	int
]	O
->	O
the_data	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
fc	O
->	O
npolys	O
;	O
n	int
++	O
)	O
fc	O
->	O
sp	int
[	O
n	int
]	O
=	O
trousers	*(int)
;	O
}	O
}	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_PARTS	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
relationship	array(array(int))
[	O
i	int
]	O
[	O
1	int
]	O
==	O
-	O
1	int
)	O
{	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
root	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
relationship	array(array(int))
[	O
i	int
]	O
[	O
0	int
]	O
]	O
;	O
mav_listItemAdd	()->(int)
(	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
root	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
->	O
objects	*(int)
,	O
(	O
void	O
*	O
)	O
mav_objectNew	()->(int)
(	O
mav_class_composite	O
,	O
avatarComps	O
[	O
relationship	array(array(int))
[	O
i	int
]	O
[	O
0	int
]	O
]	O
)	O
)	O
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
relationship	array(array(int))
[	O
i	int
]	O
[	O
0	int
]	O
]	O
->	O
position	int
=	O
mav_matrixSet	()->(int)
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0058695	int
,	O
0.901687	int
,	O
-	O
0.0323005	int
)	O
;	O
}	O
else	O
{	O
pptr	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
=	O
mav_malloc	()->(int)
(	O
sizeof	O
(	O
MAV_partptr	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),*(struct(*(struct(int,int,*`,int,int,*`)),*(struct(*`,*`)))))
)	O
)	O
;	O
pptr	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
->	O
part	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
relationship	array(array(int))
[	O
i	int
]	O
[	O
0	int
]	O
]	O
;	O
pptr	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
relationship	array(array(int))
[	O
i	int
]	O
[	O
1	int
]	O
]	O
->	O
children	*(struct)
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
relationship	array(array(int))
[	O
i	int
]	O
[	O
1	int
]	O
]	O
->	O
children	*(struct)
=	O
pptr	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),*(struct(*(struct`),*(struct`)))))
;	O
mav_listItemAdd	()->(int)
(	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
relationship	array(array(int))
[	O
i	int
]	O
[	O
0	int
]	O
]	O
->	O
objects	*(int)
,	O
(	O
void	O
*	O
)	O
mav_objectNew	()->(int)
(	O
mav_class_composite	O
,	O
avatarComps	O
[	O
relationship	array(array(int))
[	O
i	int
]	O
[	O
0	int
]	O
]	O
)	O
)	O
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
relationship	array(array(int))
[	O
i	int
]	O
[	O
0	int
]	O
]	O
->	O
position	int
=	O
mav_matrixSet	()->(int)
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.010211582	int
*	O
relative_positions	array(int)
[	O
i	int
]	O
.	O
x	O
,	O
0.010211582	int
*	O
relative_positions	array(int)
[	O
i	int
]	O
.	O
y	O
,	O
0.010211582	int
*	O
relative_positions	array(int)
[	O
i	int
]	O
.	O
z	O
)	O
;	O
}	O
}	O
mav_partBBox	(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),int,*(int))->(void)
(	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
root	*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))
,	O
MAV_ID_MATRIX	O
,	O
&	O
bb	int
)	O
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
matrix	int
=	O
MAV_ID_MATRIX	O
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
rotation	int
=	O
MAV_ID_MATRIX	O
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
vertical	int
=	O
MAV_ID_MATRIX	O
;	O
return	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
;	O
}	O
static	O
int	O
Find_PartNum	(*(char))->(int)
(	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"HIPS"	*(char)
)	O
==	O
0	int
)	O
return	O
HIPS	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"NECK"	*(char)
)	O
==	O
0	int
)	O
return	O
NECK	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"HEAD"	*(char)
)	O
==	O
0	int
)	O
return	O
HEAD	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"LEFT_CLAVICLE"	*(char)
)	O
==	O
0	int
)	O
return	O
LEFT_CLAVICLE	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"RIGHT_CLAVICLE"	*(char)
)	O
==	O
0	int
)	O
return	O
RIGHT_CLAVICLE	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"RIGHT_HAND"	*(char)
)	O
==	O
0	int
)	O
return	O
NECK	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"RIGHT_LOWER_ARM"	*(char)
)	O
==	O
0	int
)	O
return	O
RIGHT_LOWER_ARM	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"RIGHT_UPPER_ARM"	*(char)
)	O
==	O
0	int
)	O
return	O
RIGHT_UPPER_ARM	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"LEFT_HAND"	*(char)
)	O
==	O
0	int
)	O
return	O
LEFT_HAND	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"LEFT_LOWER_ARM"	*(char)
)	O
==	O
0	int
)	O
return	O
LEFT_LOWER_ARM	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"LEFT_UPPER_ARM"	*(char)
)	O
==	O
0	int
)	O
return	O
LEFT_UPPER_ARM	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"LOWER_TORSO"	*(char)
)	O
==	O
0	int
)	O
return	O
LOWER_TORSO	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"UPPER_TORSO"	*(char)
)	O
==	O
0	int
)	O
return	O
UPPER_TORSO	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"LEFT_UPPER_LEG"	*(char)
)	O
==	O
0	int
)	O
return	O
LEFT_UPPER_LEG	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"LEFT_LOWER_LEG"	*(char)
)	O
==	O
0	int
)	O
return	O
LEFT_LOWER_LEG	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"LEFT_FOOT"	*(char)
)	O
==	O
0	int
)	O
return	O
LEFT_FOOT	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"RIGHT_UPPER_LEG"	*(char)
)	O
==	O
0	int
)	O
return	O
RIGHT_UPPER_LEG	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"RIGHT_LOWER_LEG"	*(char)
)	O
==	O
0	int
)	O
return	O
RIGHT_LOWER_LEG	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"RIGHT_FOOT"	*(char)
)	O
==	O
0	int
)	O
return	O
RIGHT_FOOT	int
;	O
return	O
-	O
1	int
;	O
}	O
MAV_avatarCurves	struct(int,*(struct(int,int,float,float,float,int,*(struct(array(float),array(float))))))
*	O
mav_avatarReadCurves	(*(char))->(*(struct(int,*(struct(int,int,float,float,float,int,*`)))))
(	O
char	O
*	O
filename	*(char)
)	O
{	O
MAV_avatarCurves	struct(int,*(struct(int,int,float,float,float,int,*(struct(array(float),array(float))))))
*	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
;	O
FILE	struct
*	O
in	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
i	int
,	O
j	int
;	O
int	O
num_points	int
;	O
float	O
xcoord	float
,	O
angle	array(float)
;	O
int	O
b	int
,	O
v	int
;	O
char	O
part_name	array(char)
[	O
100	int
]	O
;	O
char	O
axis	int
[	O
100	int
]	O
;	O
in	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
in	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"mav_readAvatarCurves(): can't open file %s\n"	*(char)
,	O
filename	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
=	O
mav_malloc	()->(int)
(	O
sizeof	O
(	O
MAV_avatarCurves	struct(int,*(struct(int,int,float,float,float,int,*(struct(array(float),array(float))))))
)	O
)	O
;	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
in	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d"	*(char)
,	O
&	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
num_joints	int
)	O
;	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
=	O
mav_malloc	()->(int)
(	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
num_joints	int
*	O
sizeof	O
(	O
MAV_joint	struct(int,int,float,float,float,int,*(struct(array(float),array(float))))
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
num_joints	int
;	O
i	int
++	O
)	O
{	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
in	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
part_name	array(char)
)	O
;	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
part_num	int
=	O
Find_PartNum	(*(char))->(int)
(	O
part_name	array(char)
)	O
;	O
if	O
(	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
part_num	int
!=	O
-	O
1	int
)	O
{	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
in	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%f"	*(char)
,	O
&	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
offset	float
)	O
;	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
in	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s"	*(char)
,	O
axis	int
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
axis	int
,	O
"ROLL"	*(char)
)	O
==	O
0	int
)	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
axis	int
=	O
ROLL	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
axis	int
,	O
"PITCH"	*(char)
)	O
==	O
0	int
)	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
axis	int
=	O
PITCH	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
axis	int
,	O
"YAW"	*(char)
)	O
==	O
0	int
)	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
axis	int
=	O
YAW	int
;	O
}	O
else	O
{	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
offset	float
=	O
0.0	int
;	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
axis	int
=	O
-	O
1	int
;	O
}	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
start	float
=	O
0.0	int
;	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
end	float
=	O
1.0	int
;	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
in	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d"	*(char)
,	O
&	O
num_points	int
)	O
;	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
num_beziers	int
=	O
1	int
+	O
(	O
num_points	int
-	O
4	int
)	O
/	O
3	int
;	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
=	O
mav_malloc	()->(int)
(	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
num_beziers	int
*	O
sizeof	O
(	O
MAV_bezier	struct(array(float),array(float))
)	O
)	O
;	O
v	int
=	O
0	int
;	O
b	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_points	int
;	O
j	int
++	O
)	O
{	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
in	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%f"	*(char)
,	O
&	O
xcoord	float
)	O
;	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
b	int
]	O
.	O
value	array(float)
[	O
v	int
]	O
=	O
xcoord	float
;	O
v	int
++	O
;	O
if	O
(	O
v	int
==	O
4	int
)	O
{	O
if	O
(	O
j	int
<	O
num_points	int
-	O
1	int
)	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
b	int
+	O
1	int
]	O
.	O
value	array(float)
[	O
0	int
]	O
=	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
b	int
]	O
.	O
value	array(float)
[	O
3	int
]	O
;	O
b	int
++	O
;	O
v	int
=	O
1	int
;	O
}	O
}	O
v	int
=	O
0	int
;	O
b	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_points	int
;	O
j	int
++	O
)	O
{	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
in	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%f"	*(char)
,	O
&	O
angle	array(float)
)	O
;	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
b	int
]	O
.	O
angle	array(float)
[	O
v	int
]	O
=	O
angle	array(float)
/	O
90.0	int
;	O
v	int
++	O
;	O
if	O
(	O
v	int
==	O
4	int
)	O
{	O
if	O
(	O
j	int
<	O
num_points	int
-	O
1	int
)	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
b	int
+	O
1	int
]	O
.	O
angle	array(float)
[	O
0	int
]	O
=	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
b	int
]	O
.	O
angle	array(float)
[	O
3	int
]	O
;	O
b	int
++	O
;	O
v	int
=	O
1	int
;	O
}	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
;	O
}	O
void	O
mav_avatarUpdatePosition	(*(struct(*(struct(int,int,*`,int,int,*`)),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*`)),int,int,int,int,int,float,int,float,float,*(void))))->(void)
(	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
)	O
{	O
MAV_vector	O
position	int
;	O
float	O
time	float
;	O
MAV_vector	O
new_position	O
;	O
position	int
.	O
x	O
=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
matrix	int
.	O
mat	*(*(int))
[	O
MAV_MATRIX_XCOMP	O
]	O
;	O
position	int
.	O
y	O
=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
matrix	int
.	O
mat	*(*(int))
[	O
MAV_MATRIX_YCOMP	O
]	O
;	O
position	int
.	O
z	O
=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
matrix	int
.	O
mat	*(*(int))
[	O
MAV_MATRIX_ZCOMP	O
]	O
;	O
time	float
=	O
mav_getTimer	()->(double)
(	O
)	O
;	O
if	O
(	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
last_time	float
<	O
0.0	int
)	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
last_time	float
=	O
time	float
;	O
new_position	O
.	O
x	O
=	O
position	int
.	O
x	O
+	O
(	O
time	float
-	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
last_time	float
)	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
velocity	int
.	O
x	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
speed	float
;	O
new_position	O
.	O
y	O
=	O
position	int
.	O
y	O
+	O
(	O
time	float
-	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
last_time	float
)	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
velocity	int
.	O
y	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
speed	float
;	O
new_position	O
.	O
z	O
=	O
position	int
.	O
z	O
+	O
(	O
time	float
-	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
last_time	float
)	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
velocity	int
.	O
z	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
speed	float
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
last_time	float
=	O
time	float
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
matrix	int
=	O
mav_matrixSet	()->(int)
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
new_position	O
.	O
x	O
,	O
new_position	O
.	O
y	O
,	O
new_position	O
.	O
z	O
)	O
;	O
}	O
void	O
mav_avatarAnimate	(*(struct(*(struct(int,int,*`,int,int,*`)),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*`)),int,int,int,int,int,float,int,float,float,*(void))))->(void)
(	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
)	O
{	O
int	O
i	int
,	O
j	int
;	O
float	O
t	float
;	O
float	O
value	array(float)
;	O
float	O
v	int
,	O
val	float
;	O
MAV_vector	O
direction	int
;	O
float	O
s	float
;	O
float	O
angle	array(float)
;	O
float	O
scl	float
;	O
float	O
time	float
;	O
scl	float
=	O
0.85	int
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
speed	float
*	O
sqrt	(double)->(double)
(	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
velocity	int
.	O
x	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
velocity	int
.	O
x	O
+	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
velocity	int
.	O
y	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
velocity	int
.	O
y	O
+	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
velocity	int
.	O
z	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
velocity	int
.	O
z	O
)	O
;	O
direction	int
=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
velocity	int
;	O
s	float
=	O
sqrt	(double)->(double)
(	O
direction	int
.	O
x	O
*	O
direction	int
.	O
x	O
+	O
direction	int
.	O
y	O
*	O
direction	int
.	O
y	O
+	O
direction	int
.	O
z	O
*	O
direction	int
.	O
z	O
)	O
;	O
if	O
(	O
s	float
>	O
0.0	int
)	O
{	O
direction	int
.	O
x	O
/=	O
s	float
;	O
direction	int
.	O
y	O
/=	O
s	float
;	O
direction	int
.	O
z	O
/=	O
s	float
;	O
angle	array(float)
=	O
57.29577951	int
*	O
acos	(double)->(double)
(	O
direction	int
.	O
z	O
)	O
;	O
if	O
(	O
direction	int
.	O
x	O
<	O
0.0	int
)	O
angle	array(float)
=	O
-	O
angle	array(float)
;	O
}	O
else	O
angle	array(float)
=	O
0.0	int
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
rotation	int
=	O
mav_matrixSet	()->(int)
(	O
0.0	int
,	O
0.0	int
,	O
angle	array(float)
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
time	float
=	O
mav_getTimer	()->(double)
(	O
)	O
;	O
value	array(float)
=	O
fmod	(double,double)->(double)
(	O
time	float
,	O
1.0	int
)	O
;	O
value	array(float)
-=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
offset	float
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
num_joints	int
;	O
i	int
++	O
)	O
{	O
v	int
=	O
value	array(float)
-	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
offset	float
;	O
while	O
(	O
v	int
<	O
0.0	int
)	O
v	int
+=	O
1.0	int
;	O
while	O
(	O
v	int
>	O
1.0	int
)	O
v	int
-=	O
1.0	int
;	O
t	float
=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
start	float
+	O
v	int
*	O
(	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
end	float
-	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
start	float
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
num_beziers	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
t	float
>=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
j	int
]	O
.	O
value	array(float)
[	O
0	int
]	O
&&	O
t	float
<=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
j	int
]	O
.	O
value	array(float)
[	O
3	int
]	O
)	O
{	O
val	float
=	O
(	O
t	float
-	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
j	int
]	O
.	O
value	array(float)
[	O
0	int
]	O
)	O
/	O
(	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
j	int
]	O
.	O
value	array(float)
[	O
3	int
]	O
-	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
j	int
]	O
.	O
value	array(float)
[	O
0	int
]	O
)	O
;	O
angle	array(float)
=	O
scl	float
*	O
90.0	int
*	O
(	O
(	O
1.0	int
-	O
val	float
)	O
*	O
(	O
1.0	int
-	O
val	float
)	O
*	O
(	O
1.0	int
-	O
val	float
)	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
j	int
]	O
.	O
angle	array(float)
[	O
0	int
]	O
+	O
3.0	int
*	O
val	float
*	O
(	O
1.0	int
-	O
val	float
)	O
*	O
(	O
1.0	int
-	O
val	float
)	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
j	int
]	O
.	O
angle	array(float)
[	O
1	int
]	O
+	O
3.0	int
*	O
val	float
*	O
val	float
*	O
(	O
1.0	int
-	O
val	float
)	O
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
j	int
]	O
.	O
angle	array(float)
[	O
2	int
]	O
+	O
val	float
*	O
val	float
*	O
val	float
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
beziers	*(struct(array(float),array(float)))
[	O
j	int
]	O
.	O
angle	array(float)
[	O
3	int
]	O
)	O
;	O
if	O
(	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
part_num	int
==	O
-	O
1	int
)	O
{	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
vertical	int
=	O
mav_matrixSet	()->(int)
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
-	O
0.055	int
*	O
angle	array(float)
/	O
105.0	int
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
axis	int
)	O
{	O
case	O
ROLL	int
:	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
part_num	int
]	O
->	O
rotation	int
=	O
mav_matrixSet	()->(int)
(	O
-	O
angle	array(float)
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
break	O
;	O
case	O
PITCH	int
:	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
part_num	int
]	O
->	O
rotation	int
=	O
mav_matrixSet	()->(int)
(	O
0.0	int
,	O
-	O
angle	array(float)
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
break	O
;	O
case	O
YAW	int
:	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
part_list	array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`))))))
[	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
part_num	int
]	O
->	O
rotation	int
=	O
mav_matrixSet	()->(int)
(	O
0.0	int
,	O
0.0	int
,	O
-	O
angle	array(float)
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
break	O
;	O
}	O
}	O
j	int
=	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
curves	*(struct(int,*(struct(int,int,float,float,float,int,*(struct`)))))
->	O
joints	*(struct(int,int,float,float,float,int,*(struct(array(float),array(float)))))
[	O
i	int
]	O
.	O
num_beziers	int
;	O
}	O
}	O
}	O
}	O
void	O
mav_avatarSetVelocity	(*(struct(*(struct(int,int,*`,int,int,*`)),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*`)),int,int,int,int,int,float,int,float,float,*(void))),int,float)->(void)
(	O
MAV_avatar	struct(*(struct(int,int,*(int),int,int,*(struct(*`,*`)))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct(int,int,float,float,float,int,*`)))),int,int,int,int,int,float,int,float,float,*(void))
*	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
,	O
MAV_vector	O
direction	int
,	O
float	O
velocity	int
)	O
{	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
speed	float
=	O
velocity	int
;	O
avatar	*(struct(*(struct(int,int,*(int),int,int,*(struct`))),array(*(struct(int,int,*(int),int,int,*(struct(*(struct`),*(struct`)))))),*(struct(int,*(struct`))),int,int,int,int,int,float,int,float,float,*(void)))
->	O
velocity	int
=	O
direction	int
;	O
}	O
