extern	O
FILE	struct
*	O
option_usage_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
const	O
*	O
const	O
program_name	*(char)
=	O
"shar"	*(char)
;	O
bool	bool
initialization_done	bool
=	O
false	int
;	O
int	O
optidx	int
=	O
0	int
;	O
static	O
char	O
const	O
shar_opt_strs	array(char)
[	O
10323	int
]	O
=	O
"shar (GNU sharutils) 4.15\n"	*(char)
"Copyright (C) 1994-2015 Free Software Foundation, Inc., all rights reserved.\n"	*(char)
"This is free software. It is licensed for use, modification and\n"	*(char)
"redistribution under the terms of the GNU General Public License,\n"	*(char)
"version 3 or later <http://gnu.org/licenses/gpl.html>\n\0"	*(char)
"shar is free software: you can redistribute it and/or modify it under the\n"	*(char)
"terms of the GNU General Public License as published by the Free Software\n"	*(char)
"Foundation, either version 3 of the License, or (at your option) any later\n"	*(char)
"version.\n\n"	*(char)
"shar is distributed in the hope that it will be useful, but WITHOUT ANY\n"	*(char)
"WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n"	*(char)
"FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n"	*(char)
"details.\n\n"	*(char)
"You should have received a copy of the GNU General Public License along\n"	*(char)
"with this program.  If not, see <http://www.gnu.org/licenses/>.\n\0"	*(char)
"Specifying compression:\0"	*(char)
"specify compression for input files\0"	*(char)
"INTERMIX_TYPE\0"	*(char)
"intermix-type\0"	*(char)
"specify compaction (compression) program\0"	*(char)
"COMPACTOR\0"	*(char)
"compactor\0"	*(char)
"pass LEVEL for compression\0"	*(char)
"LEVEL_OF_COMPRESSION\0"	*(char)
"level-of-compression\0"	*(char)
"bzip2 and uuencode files (deprecated)\0"	*(char)
"BZIP2\0"	*(char)
"bzip2\0"	*(char)
"gzip and uuencode files (deprecated)\0"	*(char)
"GZIP\0"	*(char)
"gzip\0"	*(char)
"compress and uuencode files (deprecated)\0"	*(char)
"COMPRESS\0"	*(char)
"compress\0"	*(char)
"an alias for the 'level-of-compression' option (deprecated)\0"	*(char)
"level-for-gzip\0"	*(char)
"pass bits (default 12) to compress (deprecated)\0"	*(char)
"BITS_PER_CODE\0"	*(char)
"bits-per-code\0"	*(char)
"12\0"	*(char)
"Specifying file encoding methodology:\0"	*(char)
"decide uuencoding for each file\0"	*(char)
"MIXED_UUENCODE\0"	*(char)
"mixed-uuencode\0"	*(char)
"treat all files as binary\0"	*(char)
"UUENCODE\0"	*(char)
"uuencode\0"	*(char)
"treat all files as text\0"	*(char)
"TEXT_FILES\0"	*(char)
"text-files\0"	*(char)
"Specifying file selection and output modes:\0"	*(char)
"print output to file PREFIX.nn\0"	*(char)
"OUTPUT_PREFIX\0"	*(char)
"output-prefix\0"	*(char)
"split archive, not files, to size\0"	*(char)
"WHOLE_SIZE_LIMIT\0"	*(char)
"whole-size-limit\0"	*(char)
"split archive or files to size\0"	*(char)
"SPLIT_SIZE_LIMIT\0"	*(char)
"split-size-limit\0"	*(char)
"read file list from a file\0"	*(char)
"INPUT_FILE_LIST\0"	*(char)
"input-file-list\0"	*(char)
"read file list from standard input (deprecated)\0"	*(char)
"STDIN_FILE_LIST\0"	*(char)
"stdin-file-list\0"	*(char)
"Controlling the shar headers:\0"	*(char)
"use name to document the archive\0"	*(char)
"ARCHIVE_NAME\0"	*(char)
"archive-name\0"	*(char)
"override the submitter name\0"	*(char)
"SUBMITTER\0"	*(char)
"submitter\0"	*(char)
"output Submitted-by: & Archive-name: headers\0"	*(char)
"NET_HEADERS\0"	*(char)
"net-headers\0"	*(char)
"start the shar with a cut line\0"	*(char)
"CUT_MARK\0"	*(char)
"cut-mark\0"	*(char)
"translate messages in the script\0"	*(char)
"TRANSLATE\0"	*(char)
"translate\0"	*(char)
"Protecting against transmission issues:\0"	*(char)
"do not use `wc -c' to check size\0"	*(char)
"NO_CHARACTER_COUNT\0"	*(char)
"no-character-count\0"	*(char)
"do not use md5sum digest to verify\0"	*(char)
"NO_MD5_DIGEST\0"	*(char)
"no-md5-digest\0"	*(char)
"apply the prefix character on every line\0"	*(char)
"FORCE_PREFIX\0"	*(char)
"force-prefix\0"	*(char)
"use delim to delimit the files\0"	*(char)
"HERE_DELIMITER\0"	*(char)
"here-delimiter\0"	*(char)
"SHAR_EOF\0"	*(char)
"Producing different kinds of shars:\0"	*(char)
"produce very simple shars\0"	*(char)
"VANILLA_OPERATION\0"	*(char)
"vanilla-operation\0"	*(char)
"use temporary files between programs\0"	*(char)
"NO_PIPING\0"	*(char)
"no-piping\0"	*(char)
"blindly overwrite existing files\0"	*(char)
"NO_CHECK_EXISTING\0"	*(char)
"no-check-existing\0"	*(char)
"ask user before overwriting files\0"	*(char)
"QUERY_USER\0"	*(char)
"query-user\0"	*(char)
"do not restore modification times\0"	*(char)
"NO_TIMESTAMP\0"	*(char)
"no-timestamp\0"	*(char)
"avoid verbose messages at unshar time\0"	*(char)
"QUIET_UNSHAR\0"	*(char)
"quiet-unshar\0"	*(char)
"restore in one directory, despite hierarchy\0"	*(char)
"BASENAME\0"	*(char)
"basename\0"	*(char)
"Internationalization options:\0"	*(char)
"do not internationalize\0"	*(char)
"NO_I18N\0"	*(char)
"no-i18n\0"	*(char)
"print directory with shar messages\0"	*(char)
"PRINT_TEXT_DOMAIN_DIR\0"	*(char)
"print-text-domain-dir\0"	*(char)
"User feedback/entertainment:\0"	*(char)
"do not output verbose messages\0"	*(char)
"QUIET\0"	*(char)
"quiet\0"	*(char)
"an alias for the 'quiet' option\0"	*(char)
"silent\0"	*(char)
"display extended usage information and exit\0"	*(char)
"help\0"	*(char)
"extended usage information passed thru pager\0"	*(char)
"more-help\0"	*(char)
"output version information and exit\0"	*(char)
"version\0"	*(char)
"save the option state to a config file\0"	*(char)
"save-opts\0"	*(char)
"load options from a config file\0"	*(char)
"LOAD_OPTS\0"	*(char)
"no-load-opts\0"	*(char)
"no\0"	*(char)
"SHAR\0"	*(char)
"shar (GNU sharutils) - create a shell archive\n"	*(char)
"Usage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n\0"	*(char)
"$HOME\0"	*(char)
".sharrc\0"	*(char)
"bug-gnu-utils@gnu.org\0"	*(char)
"If no 'file's are specified, the list of input files is read from standard\n"	*(char)
"input.  Standard input must not be a terminal.\n\0"	*(char)
"'shar' creates \"shell archives\" (or shar files) which are in text format\n"	*(char)
"and can be emailed.  These files may be unpacked later by executing them\n"	*(char)
"with '/bin/sh'.  The resulting archive is sent to standard out unless the\n"	*(char)
"'-o' option is given.  A wide range of features provide extensive\n"	*(char)
"flexibility in manufacturing shars and in specifying 'shar' \"smartness\".\n"	*(char)
"Archives may be fairly simple ('--vanilla-operation') or essentially a\n"	*(char)
"mailable 'tar' archive.\n\n"	*(char)
"Options may be specified in any order until a 'file' argument is\n"	*(char)
"recognized.  If the '--intermix-type' option has been specified, more\n"	*(char)
"compression and encoding options will be recognized between the 'file'\n"	*(char)
"arguments.\n\n"	*(char)
"Though this program supports 'uuencode'-d files, they are deprecated.  If\n"	*(char)
"you are emailing files, please consider mime-encoded files.  If you do\n"	*(char)
"'uuencode', base64 is the preferred encoding method.\n\0"	*(char)
"shar (GNU sharutils) 4.15\0"	*(char)
"shar (GNU sharutils) - create a shell archive\n"	*(char)
"Usage:  shar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n\n"	*(char)
"Specify compression:\n"	*(char)
"   -p, --intermix-type        specify compression for input files\n"	*(char)
"                                - prohibits the option 'vanilla-operation'\n"	*(char)
"   -C, --compactor=PROG       specify compaction (compression) program PROG\n"	*(char)
"                                - prohibits the option 'vanilla-operation'\n"	*(char)
"                                - may appear multiple times\n"	*(char)
"                                - it must be known to shar: xz gzip bzip2\n"	*(char)
"   -g, --level-of-compression=LEVEL\n"	*(char)
"                              pass LEVEL for compression\n"	*(char)
"                                - it must be in the range: 1 to 9\n\n"	*(char)
"Specify file encoding methodology:\n"	*(char)
"   -M, --mixed-uuencode       decide uuencoding for each file\n"	*(char)
"   -B, --uuencode             treat all files as binary\n"	*(char)
"                                - an alternate for mixed-uuencode\n"	*(char)
"   -T, --text-files           treat all files as text\n"	*(char)
"                                - an alternate for mixed-uuencode\n\n"	*(char)
"Specifying file selection and output modes:\n"	*(char)
"   -o, --output-prefix=str    print output to file PREFIX.nn\n"	*(char)
"   -l, --whole-size-limit=SIZE\n"	*(char)
"                              split archive, not files, to SIZE\n"	*(char)
"                                - requires the option 'output-prefix'\n"	*(char)
"                                - is scalable with a suffix: k/K/m/M/g/G/t/T\n"	*(char)
"                                - it must lie in one of the ranges:\n"	*(char)
"                                  8 to 1023, or 8192 to 4194304\n"	*(char)
"   -L, --split-size-limit=SIZE\n"	*(char)
"                              split archive or files to SIZE\n"	*(char)
"                                - requires the option 'output-prefix'\n"	*(char)
"                                - is scalable with a suffix: k/K/m/M/g/G/t/T\n"	*(char)
"                                - it must lie in one of the ranges:\n"	*(char)
"                                  8 to 1023, or 8192 to 4194304\n"	*(char)
"                                - an alternate for 'whole-size-limit'\n"	*(char)
"   -I, --input-file-list=FILE read file list from FILE\n\n"	*(char)
"Controlling the shar headers:\n"	*(char)
"   -n, --archive-name=NAME    use NAME to document the archive\n"	*(char)
"   -s, --submitter=NAME       override the submitter name with NAME\n"	*(char)
"   -a, --net-headers          output Submitted-by: & Archive-name: headers\n"	*(char)
"                                - requires the option 'archive-name'\n"	*(char)
"   -c, --cut-mark             start the shar with a cut line\n"	*(char)
"   -t, --translate            translate messages in the script\n\n"	*(char)
"Protecting against transmission issues:\n"	*(char)
"       --no-character-count   do not use `wc -c' to check size\n"	*(char)
"   -D, --no-md5-digest        do not use md5sum digest to verify\n"	*(char)
"   -F, --force-prefix         apply the prefix character on every line\n"	*(char)
"   -d, --here-delimiter=DELIM use DELIM to delimit the files\n\n"	*(char)
"Producing different kinds of shars:\n"	*(char)
"   -V, --vanilla-operation    produce very simple shars\n"	*(char)
"   -P, --no-piping            use temporary files between programs\n"	*(char)
"   -x, --no-check-existing    blindly overwrite existing files\n"	*(char)
"   -X, --query-user           ask user before overwriting files\n"	*(char)
"                                - prohibits the option 'vanilla-operation'\n"	*(char)
"   -m, --no-timestamp         do not restore modification times\n"	*(char)
"   -Q, --quiet-unshar         avoid verbose messages at unshar time\n"	*(char)
"   -f, --basename             restore in one directory, despite hierarchy\n\n"	*(char)
"Internationalization options:\n"	*(char)
"       --no-i18n              do not internationalize\n"	*(char)
"       --print-text-domain-dir  print directory with shar messages\n\n"	*(char)
"User feedback/entertainment:\n"	*(char)
"   -q, --quiet                do not output verbose messages\n"	*(char)
"       --silent               an alias for the 'quiet' option\n\n"	*(char)
"Version, usage and configuration options:\n"	*(char)
"   -v, --version[=MODE]       output version information and exit\n"	*(char)
"   -h, --help                 display extended usage information and exit\n"	*(char)
"   -!, --more-help            extended usage information passed thru pager\n"	*(char)
"   -R, --save-opts[=FILE]     save the option state to a config file FILE\n"	*(char)
"   -r, --load-opts=FILE       load options from the config file FILE\n"	*(char)
"                                - disabled with '--no-load-opts'\n"	*(char)
"                                - may appear multiple times\n\n"	*(char)
"Options are specified by doubled hyphens and their name or by a single\n"	*(char)
"hyphen and the flag character.\n"	*(char)
"If no 'file's are specified, the list of input files is read from a\n"	*(char)
"standard input.  Standard input must not be a terminal.\n\n"	*(char)
"The following option preset mechanisms are supported:\n"	*(char)
" - reading file $HOME/.sharrc\n\n"	*(char)
"'shar' creates \"shell archives\" (or shar files) which are in text format\n"	*(char)
"and can be emailed.  These files may be unpacked later by executing them\n"	*(char)
"with '/bin/sh'.  The resulting archive is sent to standard out unless the\n"	*(char)
"'-o' option is given.  A wide range of features provide extensive\n"	*(char)
"flexibility in manufacturing shars and in specifying 'shar' \"smartness\".\n"	*(char)
"Archives may be fairly simple ('--vanilla-operation') or essentially a\n"	*(char)
"mailable 'tar' archive.\n\n"	*(char)
"Options may be specified in any order until a 'file' argument is\n"	*(char)
"recognized.  If the '--intermix-type' option has been specified, more\n"	*(char)
"compression and encoding options will be recognized between the 'file'\n"	*(char)
"arguments.\n\n"	*(char)
"Though this program supports 'uuencode'-d files, they are deprecated.  If\n"	*(char)
"you are emailing files, please consider mime-encoded files.  If you do\n"	*(char)
"'uuencode', base64 is the preferred encoding method.\n\n"	*(char)
"Please send bug reports to:  <bug-gnu-utils@gnu.org>\n\0"	*(char)
"shar (GNU sharutils) - create a shell archive\n"	*(char)
"Usage:  shar [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [<file>...]\n"	*(char)
"Try 'shar --help' for more information.\n"	*(char)
;	O
static	O
int	O
const	O
aIntermix_TypeCantList	array(int)
[	O
]	O
=	O
{	O
INDEX_OPT_VANILLA_OPERATION	int
,	O
NO_EQUIVALENT	O
}	O
;	O
static	O
int	O
const	O
aCompactorCantList	array(int)
[	O
]	O
=	O
{	O
INDEX_OPT_VANILLA_OPERATION	int
,	O
NO_EQUIVALENT	O
}	O
;	O
static	O
int	O
const	O
aWhole_Size_LimitMustList	array(int)
[	O
]	O
=	O
{	O
INDEX_OPT_OUTPUT_PREFIX	int
,	O
NO_EQUIVALENT	O
}	O
;	O
static	O
int	O
const	O
aSplit_Size_LimitMustList	array(int)
[	O
]	O
=	O
{	O
INDEX_OPT_OUTPUT_PREFIX	int
,	O
NO_EQUIVALENT	O
}	O
;	O
static	O
int	O
const	O
aNet_HeadersMustList	array(int)
[	O
]	O
=	O
{	O
INDEX_OPT_ARCHIVE_NAME	int
,	O
NO_EQUIVALENT	O
}	O
;	O
static	O
int	O
const	O
aQuery_UserCantList	array(int)
[	O
]	O
=	O
{	O
INDEX_OPT_VANILLA_OPERATION	int
,	O
NO_EQUIVALENT	O
}	O
;	O
extern	O
tOptProc	(*(struct),*(struct))->(void)
check_intermixing	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionBooleanVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionNestedVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionNumericVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionPagedUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionPrintVersion	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionResetOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionStackArg	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionTimeDate	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionTimeVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionUnstackArg	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
optionVendorOption	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
set_compaction	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
;	O
static	O
tOptProc	(*(struct),*(struct))->(void)
doOptBzip2	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptGzip	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptInput_File_List	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptLevel_For_Gzip	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptLevel_Of_Compression	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptPrint_Text_Domain_Dir	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptSilent	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptSplit_Size_Limit	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptStdin_File_List	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptVanilla_Operation	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doOptWhole_Size_Limit	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
doUsageOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
;	O
static	O
tOptDesc	struct
optDesc	array(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int),*(void),*(int),*(int),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(void)),*(char),*(char),*(char),*(char),*(char)))
[	O
OPTION_CT	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
COMPRESSION_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
COMPRESSION_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
1	int
,	O
VALUE_OPT_INTERMIX_TYPE	char
,	O
1	int
,	O
VALUE_OPT_INTERMIX_TYPE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
INTERMIX_TYPE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
aIntermix_TypeCantList	array(int)
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
INTERMIX_TYPE_DESC	O
,	O
INTERMIX_TYPE_NAME	O
,	O
INTERMIX_TYPE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
2	int
,	O
VALUE_OPT_COMPACTOR	char
,	O
2	int
,	O
VALUE_OPT_COMPACTOR	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
COMPACTOR_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
aCompactorCantList	array(int)
,	O
set_compaction	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
COMPACTOR_DESC	O
,	O
COMPACTOR_NAME	O
,	O
COMPACTOR_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
3	int
,	O
VALUE_OPT_LEVEL_OF_COMPRESSION	char
,	O
3	int
,	O
VALUE_OPT_LEVEL_OF_COMPRESSION	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
LEVEL_OF_COMPRESSION_FLAGS	O
,	O
0	int
,	O
{	O
LEVEL_OF_COMPRESSION_DFT_ARG	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptLevel_Of_Compression	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
LEVEL_OF_COMPRESSION_DESC	O
,	O
LEVEL_OF_COMPRESSION_NAME	O
,	O
LEVEL_OF_COMPRESSION_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
4	int
,	O
VALUE_OPT_BZIP2	char
,	O
4	int
,	O
VALUE_OPT_BZIP2	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
BZIP2_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptBzip2	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
BZIP2_DESC	O
,	O
BZIP2_NAME	O
,	O
BZIP2_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
5	int
,	O
VALUE_OPT_GZIP	char
,	O
5	int
,	O
VALUE_OPT_GZIP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
GZIP_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptGzip	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
GZIP_DESC	O
,	O
GZIP_NAME	O
,	O
GZIP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
6	int
,	O
VALUE_OPT_COMPRESS	char
,	O
6	int
,	O
VALUE_OPT_COMPRESS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
COMPRESS_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptCompress	O
,	O
COMPRESS_DESC	O
,	O
COMPRESS_NAME	O
,	O
COMPRESS_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
7	int
,	O
VALUE_OPT_LEVEL_FOR_GZIP	int
,	O
7	int
,	O
VALUE_OPT_LEVEL_FOR_GZIP	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
LEVEL_FOR_GZIP_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptLevel_For_Gzip	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
LEVEL_FOR_GZIP_DESC	O
,	O
LEVEL_FOR_GZIP_NAME	O
,	O
LEVEL_FOR_GZIP_name	O
,	O
0	int
,	O
0	int
}	O
,	O
{	O
8	int
,	O
VALUE_OPT_BITS_PER_CODE	char
,	O
8	int
,	O
VALUE_OPT_BITS_PER_CODE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
BITS_PER_CODE_FLAGS	O
,	O
0	int
,	O
{	O
BITS_PER_CODE_DFT_ARG	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptBits_Per_Code	O
,	O
BITS_PER_CODE_DESC	O
,	O
BITS_PER_CODE_NAME	O
,	O
BITS_PER_CODE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
ENCODING_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
ENCODING_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
10	int
,	O
VALUE_OPT_MIXED_UUENCODE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
MIXED_UUENCODE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
check_intermixing	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
MIXED_UUENCODE_DESC	O
,	O
MIXED_UUENCODE_NAME	O
,	O
MIXED_UUENCODE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
11	int
,	O
VALUE_OPT_UUENCODE	char
,	O
NOLIMIT	O
,	O
NOLIMIT	O
,	O
INDEX_OPT_MIXED_UUENCODE	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
UUENCODE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
check_intermixing	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
UUENCODE_DESC	O
,	O
UUENCODE_NAME	O
,	O
UUENCODE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
12	int
,	O
VALUE_OPT_TEXT_FILES	char
,	O
NOLIMIT	O
,	O
NOLIMIT	O
,	O
INDEX_OPT_MIXED_UUENCODE	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
TEXT_FILES_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
check_intermixing	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
TEXT_FILES_DESC	O
,	O
TEXT_FILES_NAME	O
,	O
TEXT_FILES_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
IN_OUT_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
IN_OUT_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
14	int
,	O
VALUE_OPT_OUTPUT_PREFIX	char
,	O
14	int
,	O
VALUE_OPT_OUTPUT_PREFIX	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OUTPUT_PREFIX_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
OUTPUT_PREFIX_DESC	O
,	O
OUTPUT_PREFIX_NAME	O
,	O
OUTPUT_PREFIX_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
15	int
,	O
VALUE_OPT_WHOLE_SIZE_LIMIT	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
WHOLE_SIZE_LIMIT_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
aWhole_Size_LimitMustList	array(int)
,	O
NULL	O
,	O
doOptWhole_Size_Limit	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
WHOLE_SIZE_LIMIT_DESC	O
,	O
WHOLE_SIZE_LIMIT_NAME	O
,	O
WHOLE_SIZE_LIMIT_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
16	int
,	O
VALUE_OPT_SPLIT_SIZE_LIMIT	char
,	O
NOLIMIT	O
,	O
NOLIMIT	O
,	O
INDEX_OPT_WHOLE_SIZE_LIMIT	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
SPLIT_SIZE_LIMIT_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
aSplit_Size_LimitMustList	array(int)
,	O
NULL	O
,	O
doOptSplit_Size_Limit	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
SPLIT_SIZE_LIMIT_DESC	O
,	O
SPLIT_SIZE_LIMIT_NAME	O
,	O
SPLIT_SIZE_LIMIT_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
17	int
,	O
VALUE_OPT_INPUT_FILE_LIST	char
,	O
17	int
,	O
VALUE_OPT_INPUT_FILE_LIST	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
INPUT_FILE_LIST_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptInput_File_List	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
INPUT_FILE_LIST_DESC	O
,	O
INPUT_FILE_LIST_NAME	O
,	O
INPUT_FILE_LIST_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
18	int
,	O
VALUE_OPT_STDIN_FILE_LIST	char
,	O
18	int
,	O
VALUE_OPT_STDIN_FILE_LIST	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
STDIN_FILE_LIST_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptStdin_File_List	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
STDIN_FILE_LIST_DESC	O
,	O
STDIN_FILE_LIST_NAME	O
,	O
STDIN_FILE_LIST_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
HEADERS_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
HEADERS_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
20	int
,	O
VALUE_OPT_ARCHIVE_NAME	char
,	O
20	int
,	O
VALUE_OPT_ARCHIVE_NAME	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
ARCHIVE_NAME_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
ARCHIVE_NAME_DESC	O
,	O
ARCHIVE_NAME_NAME	O
,	O
ARCHIVE_NAME_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
21	int
,	O
VALUE_OPT_SUBMITTER	char
,	O
21	int
,	O
VALUE_OPT_SUBMITTER	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
SUBMITTER_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
SUBMITTER_DESC	O
,	O
SUBMITTER_NAME	O
,	O
SUBMITTER_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
22	int
,	O
VALUE_OPT_NET_HEADERS	char
,	O
22	int
,	O
VALUE_OPT_NET_HEADERS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NET_HEADERS_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
aNet_HeadersMustList	array(int)
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
NET_HEADERS_DESC	O
,	O
NET_HEADERS_NAME	O
,	O
NET_HEADERS_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
23	int
,	O
VALUE_OPT_CUT_MARK	char
,	O
23	int
,	O
VALUE_OPT_CUT_MARK	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
CUT_MARK_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
CUT_MARK_DESC	O
,	O
CUT_MARK_NAME	O
,	O
CUT_MARK_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
24	int
,	O
VALUE_OPT_TRANSLATE	char
,	O
24	int
,	O
VALUE_OPT_TRANSLATE	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
TRANSLATE_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
TRANSLATE_DESC	O
,	O
TRANSLATE_NAME	O
,	O
TRANSLATE_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
XMIT_DEFENSES_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
XMIT_DEFENSES_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
26	int
,	O
VALUE_OPT_NO_CHARACTER_COUNT	int
,	O
26	int
,	O
VALUE_OPT_NO_CHARACTER_COUNT	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_CHARACTER_COUNT_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
NO_CHARACTER_COUNT_DESC	O
,	O
NO_CHARACTER_COUNT_NAME	O
,	O
NO_CHARACTER_COUNT_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
27	int
,	O
VALUE_OPT_NO_MD5_DIGEST	char
,	O
27	int
,	O
VALUE_OPT_NO_MD5_DIGEST	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_MD5_DIGEST_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
NO_MD5_DIGEST_DESC	O
,	O
NO_MD5_DIGEST_NAME	O
,	O
NO_MD5_DIGEST_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
28	int
,	O
VALUE_OPT_FORCE_PREFIX	char
,	O
28	int
,	O
VALUE_OPT_FORCE_PREFIX	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
FORCE_PREFIX_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
FORCE_PREFIX_DESC	O
,	O
FORCE_PREFIX_NAME	O
,	O
FORCE_PREFIX_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
29	int
,	O
VALUE_OPT_HERE_DELIMITER	char
,	O
29	int
,	O
VALUE_OPT_HERE_DELIMITER	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
HERE_DELIMITER_FLAGS	O
,	O
0	int
,	O
{	O
HERE_DELIMITER_DFT_ARG	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
HERE_DELIMITER_DESC	O
,	O
HERE_DELIMITER_NAME	O
,	O
HERE_DELIMITER_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
SHAR_FLAVORS_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
SHAR_FLAVORS_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
31	int
,	O
VALUE_OPT_VANILLA_OPERATION	char
,	O
31	int
,	O
VALUE_OPT_VANILLA_OPERATION	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
VANILLA_OPERATION_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptVanilla_Operation	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
VANILLA_OPERATION_DESC	O
,	O
VANILLA_OPERATION_NAME	O
,	O
VANILLA_OPERATION_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
32	int
,	O
VALUE_OPT_NO_PIPING	char
,	O
32	int
,	O
VALUE_OPT_NO_PIPING	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_PIPING_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
NO_PIPING_DESC	O
,	O
NO_PIPING_NAME	O
,	O
NO_PIPING_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
33	int
,	O
VALUE_OPT_NO_CHECK_EXISTING	char
,	O
33	int
,	O
VALUE_OPT_NO_CHECK_EXISTING	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_CHECK_EXISTING_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
NO_CHECK_EXISTING_DESC	O
,	O
NO_CHECK_EXISTING_NAME	O
,	O
NO_CHECK_EXISTING_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
34	int
,	O
VALUE_OPT_QUERY_USER	char
,	O
34	int
,	O
VALUE_OPT_QUERY_USER	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
QUERY_USER_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
aQuery_UserCantList	array(int)
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
QUERY_USER_DESC	O
,	O
QUERY_USER_NAME	O
,	O
QUERY_USER_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
35	int
,	O
VALUE_OPT_NO_TIMESTAMP	char
,	O
35	int
,	O
VALUE_OPT_NO_TIMESTAMP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_TIMESTAMP_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
NO_TIMESTAMP_DESC	O
,	O
NO_TIMESTAMP_NAME	O
,	O
NO_TIMESTAMP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
36	int
,	O
VALUE_OPT_QUIET_UNSHAR	char
,	O
36	int
,	O
VALUE_OPT_QUIET_UNSHAR	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
QUIET_UNSHAR_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
QUIET_UNSHAR_DESC	O
,	O
QUIET_UNSHAR_NAME	O
,	O
QUIET_UNSHAR_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
37	int
,	O
VALUE_OPT_BASENAME	char
,	O
37	int
,	O
VALUE_OPT_BASENAME	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
BASENAME_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
BASENAME_DESC	O
,	O
BASENAME_NAME	O
,	O
BASENAME_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
INTERNATIONALIZATION_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
INTERNATIONALIZATION_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
39	int
,	O
VALUE_OPT_NO_I18N	int
,	O
39	int
,	O
VALUE_OPT_NO_I18N	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
NO_I18N_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
NO_I18N_DESC	O
,	O
NO_I18N_NAME	O
,	O
NO_I18N_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
40	int
,	O
VALUE_OPT_PRINT_TEXT_DOMAIN_DIR	int
,	O
40	int
,	O
VALUE_OPT_PRINT_TEXT_DOMAIN_DIR	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
PRINT_TEXT_DOMAIN_DIR_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptPrint_Text_Domain_Dir	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
PRINT_TEXT_DOMAIN_DIR_DESC	O
,	O
PRINT_TEXT_DOMAIN_DIR_NAME	O
,	O
PRINT_TEXT_DOMAIN_DIR_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
FEEDBACK_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
FEEDBACK_DESC	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
42	int
,	O
VALUE_OPT_QUIET	char
,	O
42	int
,	O
VALUE_OPT_QUIET	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
QUIET_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
QUIET_DESC	O
,	O
QUIET_NAME	O
,	O
QUIET_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
43	int
,	O
VALUE_OPT_SILENT	int
,	O
43	int
,	O
VALUE_OPT_SILENT	int
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
SILENT_FLAGS	O
,	O
0	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doOptSilent	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
SILENT_DESC	O
,	O
SILENT_NAME	O
,	O
SILENT_name	O
,	O
0	int
,	O
0	int
}	O
,	O
{	O
INDEX_OPT_VERSION	int
,	O
VALUE_OPT_VERSION	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_VERSION	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
VER_FLAGS	O
,	O
AOUSE_VERSION	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
VER_PROC	O
,	O
VER_DESC	O
,	O
NULL	O
,	O
VER_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_HELP	int
,	O
VALUE_OPT_HELP	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_HELP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OPTST_IMM	int
|	O
OPTST_NO_INIT	int
,	O
AOUSE_HELP	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
doUsageOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
HELP_DESC	O
,	O
NULL	O
,	O
HELP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_MORE_HELP	int
,	O
VALUE_OPT_MORE_HELP	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_MORE_HELP	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
MORE_HELP_FLAGS	O
,	O
AOUSE_MORE_HELP	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
optionPagedUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
MORE_HELP_DESC	O
,	O
NULL	O
,	O
MORE_HELP_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_SAVE_OPTS	int
,	O
VALUE_OPT_SAVE_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_SAVE_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
1	int
,	O
0	int
,	O
OPTST_SET_ARGTYPE	O
(	O
OPARG_TYPE_STRING	int
)	O
|	O
OPTST_ARG_OPTIONAL	int
|	O
OPTST_NO_INIT	int
,	O
AOUSE_SAVE_OPTS	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
SAVE_OPTS_DESC	O
,	O
NULL	O
,	O
SAVE_OPTS_name	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
INDEX_OPT_LOAD_OPTS	int
,	O
VALUE_OPT_LOAD_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
VALUE_OPT_LOAD_OPTS	char
,	O
NO_EQUIVALENT	O
,	O
0	int
,	O
NOLIMIT	O
,	O
0	int
,	O
OPTST_SET_ARGTYPE	O
(	O
OPARG_TYPE_STRING	int
)	O
|	O
OPTST_DISABLE_IMM	int
,	O
AOUSE_LOAD_OPTS	int
,	O
{	O
NULL	O
}	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
optionLoadOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
,	O
LOAD_OPTS_DESC	O
,	O
LOAD_OPTS_NAME	O
,	O
LOAD_OPTS_name	O
,	O
NO_LOAD_OPTS_name	O
,	O
LOAD_OPTS_pfx	O
}	O
}	O
;	O
static	O
char	O
const	O
*	O
const	O
apzHomeList	array(*(char))
[	O
2	int
]	O
=	O
{	O
shar_opt_strs	array(char)
+	O
3699	int
,	O
NULL	O
}	O
;	O
static	O
tOptionXlateProc	()->(void)
translate_option_strings	()->(void)
;	O
static	O
void	O
doUsageOpt	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
)	O
{	O
int	O
ex_code	int
;	O
ex_code	int
=	O
SHAR_EXIT_SUCCESS	int
;	O
optionUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int)->(void)
(	O
&	O
sharOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
,	O
ex_code	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
(	O
void	O
)	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
(	O
void	O
)	O
od	*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int),*(void),*(int),*(int),*((*(struct`),*(struct`))->(void)),*(char),*(char),*(char),*(char),*(char)))
;	O
}	O
static	O
void	O
doOptLevel_Of_Compression	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
static	O
struct	O
{	O
long	O
rmin	long
,	O
rmax	long
;	O
}	O
const	O
rng	array(struct(long,long))
[	O
1	int
]	O
=	O
{	O
{	O
1	int
,	O
9	int
}	O
}	O
;	O
int	O
ix	int
;	O
if	O
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
<=	O
OPTPROC_EMIT_LIMIT	O
)	O
goto	O
emit_ranges	O
;	O
optionNumericVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
)	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
1	int
;	O
ix	int
++	O
)	O
{	O
if	O
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argInt	long
<	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmin	long
)	O
continue	O
;	O
if	O
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argInt	long
==	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmin	long
)	O
return	O
;	O
if	O
(	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmax	long
==	O
LONG_MIN	O
)	O
continue	O
;	O
if	O
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argInt	long
<=	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmax	long
)	O
return	O
;	O
}	O
option_usage_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
emit_ranges	O
:	O
optionShowRange	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(void),int)->(void)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
,	O
VOIDP	O
(	O
rng	array(struct(long,long))
)	O
,	O
1	int
)	O
;	O
}	O
static	O
void	O
doOptBzip2	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
SET_OPT_COMPACTOR	O
(	O
"bzip2"	*(char)
)	O
;	O
(	O
void	O
)	O
pOptDesc	*(struct)
;	O
(	O
void	O
)	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
}	O
static	O
void	O
doOptGzip	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
SET_OPT_COMPACTOR	O
(	O
"gzip"	*(char)
)	O
;	O
(	O
void	O
)	O
pOptDesc	*(struct)
;	O
(	O
void	O
)	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
}	O
static	O
void	O
doOptLevel_For_Gzip	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
int	O
res	int
=	O
optionAlias	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),int)->(int)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
,	O
INDEX_OPT_LEVEL_OF_COMPRESSION	int
)	O
;	O
if	O
(	O
(	O
res	int
!=	O
0	int
)	O
&&	O
(	O
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
fOptSet	int
&	O
OPTPROC_ERRSTOP	int
)	O
!=	O
0	int
)	O
)	O
USAGE	O
(	O
SHAR_EXIT_USAGE_ERROR	int
)	O
;	O
}	O
static	O
void	O
doOptWhole_Size_Limit	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
static	O
struct	O
{	O
long	O
rmin	long
,	O
rmax	long
;	O
}	O
const	O
rng	array(struct(long,long))
[	O
2	int
]	O
=	O
{	O
{	O
8	int
,	O
1023	int
}	O
,	O
{	O
8192	int
,	O
4194304	int
}	O
}	O
;	O
int	O
ix	int
;	O
if	O
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
<=	O
OPTPROC_EMIT_LIMIT	O
)	O
goto	O
emit_ranges	O
;	O
optionNumericVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
)	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
2	int
;	O
ix	int
++	O
)	O
{	O
if	O
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argInt	long
<	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmin	long
)	O
continue	O
;	O
if	O
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argInt	long
==	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmin	long
)	O
return	O
;	O
if	O
(	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmax	long
==	O
LONG_MIN	O
)	O
continue	O
;	O
if	O
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argInt	long
<=	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmax	long
)	O
return	O
;	O
}	O
option_usage_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
emit_ranges	O
:	O
optionShowRange	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(void),int)->(void)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
,	O
VOIDP	O
(	O
rng	array(struct(long,long))
)	O
,	O
2	int
)	O
;	O
}	O
static	O
void	O
doOptSplit_Size_Limit	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
static	O
struct	O
{	O
long	O
rmin	long
,	O
rmax	long
;	O
}	O
const	O
rng	array(struct(long,long))
[	O
2	int
]	O
=	O
{	O
{	O
8	int
,	O
1023	int
}	O
,	O
{	O
8192	int
,	O
4194304	int
}	O
}	O
;	O
int	O
ix	int
;	O
if	O
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
<=	O
OPTPROC_EMIT_LIMIT	O
)	O
goto	O
emit_ranges	O
;	O
optionNumericVal	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
)	O
;	O
for	O
(	O
ix	int
=	O
0	int
;	O
ix	int
<	O
2	int
;	O
ix	int
++	O
)	O
{	O
if	O
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argInt	long
<	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmin	long
)	O
continue	O
;	O
if	O
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argInt	long
==	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmin	long
)	O
return	O
;	O
if	O
(	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmax	long
==	O
LONG_MIN	O
)	O
continue	O
;	O
if	O
(	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argInt	long
<=	O
rng	array(struct(long,long))
[	O
ix	int
]	O
.	O
rmax	long
)	O
return	O
;	O
}	O
option_usage_fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
emit_ranges	O
:	O
optionShowRange	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(void),int)->(void)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
,	O
VOIDP	O
(	O
rng	array(struct(long,long))
)	O
,	O
2	int
)	O
;	O
}	O
static	O
void	O
doOptInput_File_List	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
char	O
const	O
*	O
fnm	*(char)
=	O
pOptDesc	*(struct)
->	O
optArg	union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
.	O
argString	*(char)
;	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
fnm	*(char)
,	O
"-"	*(char)
)	O
!=	O
0	int
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
freopen	(*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fnm	*(char)
,	O
"r"	*(char)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
usage_message	(*(char))->(void)
(	O
_	O
(	O
"Cannot reopen %s as stdin"	*(char)
)	O
,	O
fnm	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
doOptStdin_File_List	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
SET_OPT_INPUT_FILE_LIST	O
(	O
"-"	*(char)
)	O
;	O
(	O
void	O
)	O
pOptDesc	*(struct)
;	O
(	O
void	O
)	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
;	O
}	O
static	O
void	O
doOptVanilla_Operation	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
)	O
;	O
SET_OPT_NO_CHARACTER_COUNT	O
;	O
SET_OPT_NO_TIMESTAMP	O
;	O
SET_OPT_NO_MD5_DIGEST	O
;	O
SET_OPT_NO_I18N	O
;	O
SET_OPT_NO_PIPING	O
;	O
SET_OPT_FORCE_PREFIX	O
;	O
}	O
static	O
void	O
doOptPrint_Text_Domain_Dir	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
validate_opt_context	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
)	O
;	O
puts	(*(char))->(int)
(	O
LOCALEDIR	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
doOptSilent	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))))->(void)
(	O
tOptions	struct
*	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
tOptDesc	struct
*	O
pOptDesc	*(struct)
)	O
{	O
int	O
res	int
=	O
optionAlias	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),int)->(int)
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
,	O
pOptDesc	*(struct)
,	O
INDEX_OPT_QUIET	int
)	O
;	O
if	O
(	O
(	O
res	int
!=	O
0	int
)	O
&&	O
(	O
(	O
pOptions	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
fOptSet	int
&	O
OPTPROC_ERRSTOP	int
)	O
!=	O
0	int
)	O
)	O
USAGE	O
(	O
SHAR_EXIT_USAGE_ERROR	int
)	O
;	O
}	O
void	O
vusage_message	(*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
char	O
const	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
char	O
const	O
*	O
er_leader	*(char)
=	O
_	O
(	O
"shar usage error:\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
er_leader	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
optionUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int)->(void)
(	O
&	O
sharOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
,	O
SHAR_EXIT_USAGE_ERROR	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
void	O
usage_message	(*(char))->(void)
(	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vusage_message	(*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
vdie	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
char	O
const	O
*	O
die_leader	*(char)
=	O
_	O
(	O
"shar fatal error:\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
die_leader	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
exit_code	int
)	O
;	O
}	O
void	O
die	(int,*(char))->(void)
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vdie	(int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
exit_code	int
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
fserr	(int,*(char),*(char))->(void)
(	O
int	O
exit_code	int
,	O
char	O
const	O
*	O
op	*(char)
,	O
char	O
const	O
*	O
fname	*(char)
)	O
{	O
char	O
const	O
*	O
fserr_fmt	*(char)
=	O
_	O
(	O
"fserr %d (%s) performing '%s' on %s\n"	*(char)
)	O
;	O
die	(int,*(char))->(void)
(	O
exit_code	int
,	O
fserr_fmt	*(char)
,	O
errno	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
,	O
op	*(char)
,	O
fname	*(char)
)	O
;	O
}	O
tOptions	struct
sharOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
=	O
{	O
OPTIONS_STRUCT_VERSION	int
,	O
0	int
,	O
NULL	O
,	O
(	O
OPTPROC_BASE	O
+	O
OPTPROC_ERRSTOP	int
+	O
OPTPROC_SHORTOPT	int
+	O
OPTPROC_LONGOPT	int
+	O
OPTPROC_NO_REQ_OPT	int
+	O
OPTPROC_GNUUSAGE	int
+	O
OPTPROC_MISUSE	int
)	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
zPROGNAME	O
,	O
zRcName	O
,	O
zCopyright	O
,	O
zLicenseDescrip	O
,	O
zFullVersion	O
,	O
apzHomeList	array(*(char))
,	O
zUsageTitle	O
,	O
zExplain	O
,	O
zDetail	O
,	O
optDesc	array(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int),*(void),*(int),*(int),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))->(void)),*(char),*(char),*(char),*(char),*(char)))
,	O
zBugsAddr	O
,	O
NULL	O
,	O
NULL	O
,	O
optionUsage	(*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),*(char),*(void),*(void),*((*`,int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*`,long,long,long,long,int,*`,int)),*(*(void)),*(char),*(char))),int)->(void)
,	O
translate_option_strings	()->(void)
,	O
{	O
INDEX_OPT_MORE_HELP	int
,	O
INDEX_OPT_SAVE_OPTS	int
,	O
NO_EQUIVALENT	O
,	O
NO_EQUIVALENT	O
}	O
,	O
49	int
,	O
44	int
,	O
shar_full_usage	O
,	O
shar_short_usage	O
,	O
NULL	O
,	O
NULL	O
,	O
PKGDATADIR	*(char)
,	O
shar_packager_info	O
}	O
;	O
static	O
char	O
*	O
AO_gettext	(*(char))->(*(char))
(	O
char	O
const	O
*	O
pz	*(char)
)	O
;	O
static	O
void	O
coerce_it	(*(*(void)))->(void)
(	O
void	O
*	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
static	O
char	O
*	O
AO_gettext	(*(char))->(*(char))
(	O
char	O
const	O
*	O
pz	*(char)
)	O
{	O
char	O
*	O
res	int
;	O
if	O
(	O
pz	*(char)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
!=	O
0	int
)	O
{	O
res	int
=	O
dgettext	(*(char),*(char))->(*(char))
(	O
"libopts"	*(char)
,	O
pz	*(char)
)	O
;	O
if	O
(	O
res	int
==	O
pz	*(char)
)	O
res	int
=	O
(	O
char	O
*	O
)	O
VOIDP	O
(	O
_	O
(	O
pz	*(char)
)	O
)	O
;	O
}	O
else	O
res	int
=	O
(	O
char	O
*	O
)	O
VOIDP	O
(	O
_	O
(	O
pz	*(char)
)	O
)	O
;	O
if	O
(	O
res	int
==	O
pz	*(char)
)	O
return	O
res	int
;	O
res	int
=	O
strdup	(*(char))->(*(char))
(	O
res	int
)	O
;	O
if	O
(	O
res	int
==	O
NULL	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"No memory for duping translated strings\n"	*(char)
)	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
SHAR_EXIT_OPTION_ERROR	int
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
void	O
coerce_it	(*(*(void)))->(void)
(	O
void	O
*	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
=	O
AO_gettext	(*(char))->(*(char))
(	O
*	O
s	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
}	O
static	O
void	O
translate_option_strings	()->(void)
(	O
void	O
)	O
{	O
tOptions	struct
*	O
const	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
=	O
&	O
sharOptions	struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*(char),long,long,long,long,int,*(struct`),int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct(int,int,*`,int,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,struct`,int,int,*`,*`,*`,*`,*`,*`)),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),*(*(void)),*(char),*(char))
;	O
if	O
(	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
!=	O
0	int
)	O
{	O
char	O
*	O
*	O
ppz	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
VOIDP	O
(	O
&	O
(	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
)	O
)	O
;	O
int	O
ix	int
=	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
;	O
do	O
{	O
ppz	*(*(char))
++	O
;	O
*	O
ppz	*(*(char))
=	O
AO_gettext	(*(char))->(*(char))
(	O
*	O
ppz	*(*(char))
)	O
;	O
}	O
while	O
(	O
--	O
ix	int
>	O
0	int
)	O
;	O
option_xlateable_txt	struct(int,*(char),*(char),*(char),*(char),array(*(char)))
.	O
field_ct	int
=	O
0	int
;	O
coerce_it	(*(*(void)))->(void)
(	O
VOIDP	O
(	O
&	O
(	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
pzCopyright	*(char)
)	O
)	O
)	O
;	O
coerce_it	(*(*(void)))->(void)
(	O
VOIDP	O
(	O
&	O
(	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
pzCopyNotice	*(char)
)	O
)	O
)	O
;	O
coerce_it	(*(*(void)))->(void)
(	O
VOIDP	O
(	O
&	O
(	O
opts	*(struct(int,int,*(*(char)),int,int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(*(char)),*(char),*(char),*(char),*(struct(short,short,short,short,short,short,short,short,int,int,union(*`,long,long,long,long,int,*`,int),*(void),*(int),*(int),*((*`,*`)->(void)),*(char),*(char),*(char),*(char),*(char))),*(char),*(void),*(void),*((*(struct`),int)->(void)),*(()->(void)),struct(short,short,short,short),int,int,*(char),*(char),*(union(*(char),long,long,long,long,int,*(struct`),int)),*(*(void)),*(char),*(char)))
->	O
pzFullVersion	*(char)
)	O
)	O
)	O
;	O
}	O
}	O
