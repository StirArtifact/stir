off_t	long
restart_point	long
;	O
static	O
char	O
cbuf	array(char)
[	O
512	int
]	O
;	O
static	O
char	O
*	O
fromname	*(char)
;	O
static	O
int	O
cmd_type	int
;	O
static	O
int	O
cmd_form	int
;	O
static	O
int	O
cmd_bytesz	int
;	O
struct	O
tab	struct(*(char),short,short,short,*(char))
{	O
const	O
char	O
*	O
name	*(char)
;	O
short	O
token	short
;	O
short	O
state	*(int)
;	O
short	O
implemented	short
;	O
const	O
char	O
*	O
help	*(char)
;	O
}	O
;	O
extern	O
struct	O
tab	struct(*(char),short,short,short,*(char))
cmdtab	array(struct(*(char),short,short,short,*(char)))
[	O
]	O
;	O
extern	O
struct	O
tab	struct(*(char),short,short,short,*(char))
sitetab	array(struct(*(char),short,short,short,*(char)))
[	O
]	O
;	O
static	O
char	O
*	O
copy	(*(char))->(*(char))
(	O
char	O
*	O
)	O
;	O
static	O
void	O
help	*(char)
(	O
struct	O
tab	struct(*(char),short,short,short,*(char))
*	O
,	O
char	O
*	O
)	O
;	O
static	O
struct	O
tab	struct(*(char),short,short,short,*(char))
*	O
lookup	(*(struct(*(char),short,short,short,*(char))),*(char))->(*(struct(*(char),short,short,short,*(char))))
(	O
struct	O
tab	struct(*(char),short,short,short,*(char))
*	O
,	O
char	O
*	O
)	O
;	O
static	O
void	O
sizecmd	(*(char))->(void)
(	O
char	O
*	O
)	O
;	O
static	O
int	O
yylex	()->(int)
(	O
void	O
)	O
;	O
static	O
void	O
yyerror	(*(char))->(void)
(	O
const	O
char	O
*	O
s	*(char)
)	O
;	O
enum	O
yytokentype	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
{	O
A	int
=	O
258	int
,	O
B	int
=	O
259	int
,	O
C	int
=	O
260	int
,	O
E	int
=	O
261	int
,	O
F	int
=	O
262	int
,	O
I	int
=	O
263	int
,	O
L	int
=	O
264	int
,	O
N	int
=	O
265	int
,	O
P	int
=	O
266	int
,	O
R	int
=	O
267	int
,	O
S	int
=	O
268	int
,	O
T	int
=	O
269	int
,	O
SP	int
=	O
270	int
,	O
CRLF	int
=	O
271	int
,	O
COMMA	int
=	O
272	int
,	O
USER	int
=	O
273	int
,	O
PASS	int
=	O
274	int
,	O
ACCT	int
=	O
275	int
,	O
REIN	int
=	O
276	int
,	O
QUIT	int
=	O
277	int
,	O
PORT	int
=	O
278	int
,	O
PASV	int
=	O
279	int
,	O
TYPE	int
=	O
280	int
,	O
STRU	int
=	O
281	int
,	O
MODE	int
=	O
282	int
,	O
RETR	int
=	O
283	int
,	O
STOR	int
=	O
284	int
,	O
APPE	int
=	O
285	int
,	O
MLFL	int
=	O
286	int
,	O
MAIL	int
=	O
287	int
,	O
MSND	int
=	O
288	int
,	O
MSOM	int
=	O
289	int
,	O
MSAM	int
=	O
290	int
,	O
MRSQ	int
=	O
291	int
,	O
MRCP	int
=	O
292	int
,	O
ALLO	int
=	O
293	int
,	O
REST	int
=	O
294	int
,	O
RNFR	int
=	O
295	int
,	O
RNTO	int
=	O
296	int
,	O
ABOR	int
=	O
297	int
,	O
DELE	int
=	O
298	int
,	O
CWD	int
=	O
299	int
,	O
LIST	int
=	O
300	int
,	O
NLST	int
=	O
301	int
,	O
SITE	int
=	O
302	int
,	O
STAT	int
=	O
303	int
,	O
HELP	int
=	O
304	int
,	O
NOOP	int
=	O
305	int
,	O
MKD	int
=	O
306	int
,	O
RMD	int
=	O
307	int
,	O
PWD	int
=	O
308	int
,	O
CDUP	int
=	O
309	int
,	O
STOU	int
=	O
310	int
,	O
SMNT	int
=	O
311	int
,	O
SYST	int
=	O
312	int
,	O
SIZE	int
=	O
313	int
,	O
MDTM	int
=	O
314	int
,	O
UMASK	int
=	O
315	int
,	O
IDLE	int
=	O
316	int
,	O
CHMOD	int
=	O
317	int
,	O
LEXERR	int
=	O
318	int
,	O
STRING	int
=	O
319	int
,	O
NUMBER	int
=	O
320	int
}	O
;	O
typedef	O
union	O
YYSTYPE	union(int,*(char))
{	O
int	O
i	int
;	O
char	O
*	O
s	*(char)
;	O
}	O
YYSTYPE	union(int,*(char))
;	O
typedef	O
unsigned	O
char	O
yytype_uint8	char
;	O
typedef	O
signed	O
char	O
yytype_int8	char
;	O
typedef	O
unsigned	O
short	O
int	O
yytype_uint16	short
;	O
typedef	O
short	O
int	O
yytype_int16	short
;	O
union	O
yyalloc	union(short,union(int,*(char)))
{	O
yytype_int16	short
yyss_alloc	short
;	O
YYSTYPE	union(int,*(char))
yyvs_alloc	union(int,*(char))
;	O
}	O
;	O
static	O
const	O
yytype_uint8	char
yytranslate	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
60	int
,	O
61	int
,	O
62	int
,	O
63	int
,	O
64	int
,	O
65	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yyr1	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
66	int
,	O
67	int
,	O
67	int
,	O
67	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
68	int
,	O
69	int
,	O
69	int
,	O
70	int
,	O
71	int
,	O
71	int
,	O
72	int
,	O
73	int
,	O
74	int
,	O
74	int
,	O
74	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
76	int
,	O
76	int
,	O
76	int
,	O
77	int
,	O
77	int
,	O
77	int
,	O
78	int
,	O
79	int
,	O
80	int
,	O
81	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yyr2	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
0	int
,	O
2	int
,	O
2	int
,	O
4	int
,	O
4	int
,	O
5	int
,	O
3	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
8	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
3	int
,	O
5	int
,	O
3	int
,	O
5	int
,	O
5	int
,	O
2	int
,	O
5	int
,	O
5	int
,	O
2	int
,	O
3	int
,	O
5	int
,	O
2	int
,	O
4	int
,	O
2	int
,	O
5	int
,	O
5	int
,	O
3	int
,	O
3	int
,	O
4	int
,	O
6	int
,	O
5	int
,	O
7	int
,	O
9	int
,	O
4	int
,	O
7	int
,	O
5	int
,	O
2	int
,	O
5	int
,	O
5	int
,	O
2	int
,	O
2	int
,	O
5	int
,	O
4	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
11	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yydefact	array(char)
[	O
]	O
=	O
{	O
2	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
75	int
,	O
75	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
0	int
,	O
0	int
,	O
75	int
,	O
75	int
,	O
0	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
0	int
,	O
75	int
,	O
0	int
,	O
0	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
75	int
,	O
0	int
,	O
75	int
,	O
75	int
,	O
3	int
,	O
4	int
,	O
47	int
,	O
0	int
,	O
51	int
,	O
46	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
25	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
22	int
,	O
0	int
,	O
0	int
,	O
28	int
,	O
30	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
43	int
,	O
0	int
,	O
0	int
,	O
50	int
,	O
0	int
,	O
52	int
,	O
0	int
,	O
0	int
,	O
8	int
,	O
58	int
,	O
60	int
,	O
62	int
,	O
63	int
,	O
0	int
,	O
66	int
,	O
68	int
,	O
67	int
,	O
0	int
,	O
70	int
,	O
71	int
,	O
69	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
53	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
26	int
,	O
0	int
,	O
19	int
,	O
0	int
,	O
17	int
,	O
0	int
,	O
75	int
,	O
0	int
,	O
75	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
33	int
,	O
34	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
5	int
,	O
6	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
65	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
73	int
,	O
0	int
,	O
72	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
12	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
35	int
,	O
0	int
,	O
40	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
29	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
7	int
,	O
57	int
,	O
55	int
,	O
56	int
,	O
59	int
,	O
61	int
,	O
64	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
0	int
,	O
48	int
,	O
24	int
,	O
23	int
,	O
27	int
,	O
20	int
,	O
18	int
,	O
0	int
,	O
0	int
,	O
37	int
,	O
0	int
,	O
0	int
,	O
21	int
,	O
31	int
,	O
32	int
,	O
42	int
,	O
44	int
,	O
45	int
,	O
0	int
,	O
0	int
,	O
36	int
,	O
74	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
38	int
,	O
0	int
,	O
41	int
,	O
0	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
39	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
54	int
}	O
;	O
static	O
const	O
yytype_int16	short
yydefgoto	array(short)
[	O
]	O
=	O
{	O
-	O
1	int
,	O
1	int
,	O
36	int
,	O
37	int
,	O
74	int
,	O
76	int
,	O
97	int
,	O
124	int
,	O
164	int
,	O
83	int
,	O
87	int
,	O
91	int
,	O
133	int
,	O
134	int
,	O
192	int
,	O
42	int
}	O
;	O
static	O
const	O
yytype_int16	short
yypact	array(short)
[	O
]	O
=	O
{	O
-	O
94	int
,	O
42	int
,	O
-	O
94	int
,	O
-	O
7	int
,	O
8	int
,	O
17	int
,	O
15	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
20	int
,	O
25	int
,	O
44	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
59	int
,	O
62	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
47	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
83	int
,	O
88	int
,	O
39	int
,	O
98	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
99	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
52	int
,	O
53	int
,	O
-	O
94	int
,	O
103	int
,	O
104	int
,	O
70	int
,	O
6	int
,	O
7	int
,	O
106	int
,	O
107	int
,	O
108	int
,	O
54	int
,	O
60	int
,	O
112	int
,	O
113	int
,	O
-	O
94	int
,	O
114	int
,	O
41	int
,	O
87	int
,	O
91	int
,	O
-	O
46	int
,	O
-	O
94	int
,	O
115	int
,	O
67	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
117	int
,	O
118	int
,	O
119	int
,	O
120	int
,	O
122	int
,	O
-	O
94	int
,	O
123	int
,	O
124	int
,	O
-	O
94	int
,	O
125	int
,	O
-	O
94	int
,	O
126	int
,	O
69	int
,	O
-	O
94	int
,	O
128	int
,	O
129	int
,	O
-	O
94	int
,	O
-	O
13	int
,	O
130	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
131	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
132	int
,	O
76	int
,	O
76	int
,	O
76	int
,	O
93	int
,	O
-	O
94	int
,	O
133	int
,	O
76	int
,	O
76	int
,	O
76	int
,	O
76	int
,	O
-	O
94	int
,	O
76	int
,	O
-	O
94	int
,	O
81	int
,	O
-	O
94	int
,	O
95	int
,	O
-	O
94	int
,	O
134	int
,	O
-	O
94	int
,	O
90	int
,	O
76	int
,	O
136	int
,	O
76	int
,	O
76	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
76	int
,	O
76	int
,	O
76	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
137	int
,	O
139	int
,	O
48	int
,	O
48	int
,	O
60	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
140	int
,	O
-	O
94	int
,	O
141	int
,	O
142	int
,	O
147	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
144	int
,	O
145	int
,	O
146	int
,	O
148	int
,	O
149	int
,	O
150	int
,	O
89	int
,	O
-	O
94	int
,	O
97	int
,	O
-	O
94	int
,	O
152	int
,	O
153	int
,	O
154	int
,	O
-	O
94	int
,	O
155	int
,	O
156	int
,	O
157	int
,	O
158	int
,	O
159	int
,	O
111	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
162	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
163	int
,	O
116	int
,	O
-	O
94	int
,	O
116	int
,	O
121	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
161	int
,	O
127	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
164	int
,	O
167	int
,	O
168	int
,	O
135	int
,	O
169	int
,	O
-	O
94	int
,	O
76	int
,	O
-	O
94	int
,	O
166	int
,	O
-	O
94	int
,	O
171	int
,	O
138	int
,	O
-	O
94	int
,	O
172	int
,	O
143	int
,	O
173	int
,	O
151	int
,	O
-	O
94	int
}	O
;	O
static	O
const	O
yytype_int8	char
yypgoto	array(char)
[	O
]	O
=	O
{	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
78	int
,	O
-	O
94	int
,	O
37	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
94	int
,	O
-	O
93	int
,	O
-	O
94	int
,	O
-	O
11	int
,	O
16	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yytable	array(char)
[	O
]	O
=	O
{	O
135	int
,	O
136	int
,	O
127	int
,	O
107	int
,	O
128	int
,	O
140	int
,	O
141	int
,	O
142	int
,	O
143	int
,	O
38	int
,	O
144	int
,	O
88	int
,	O
89	int
,	O
84	int
,	O
108	int
,	O
109	int
,	O
110	int
,	O
85	int
,	O
86	int
,	O
152	int
,	O
90	int
,	O
154	int
,	O
155	int
,	O
39	int
,	O
43	int
,	O
156	int
,	O
157	int
,	O
158	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
41	int
,	O
40	int
,	O
52	int
,	O
53	int
,	O
44	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
45	int
,	O
61	int
,	O
2	int
,	O
3	int
,	O
65	int
,	O
66	int
,	O
67	int
,	O
68	int
,	O
69	int
,	O
166	int
,	O
71	int
,	O
72	int
,	O
96	int
,	O
161	int
,	O
62	int
,	O
63	int
,	O
101	int
,	O
102	int
,	O
162	int
,	O
46	int
,	O
4	int
,	O
5	int
,	O
163	int
,	O
54	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
79	int
,	O
50	int
,	O
111	int
,	O
80	int
,	O
51	int
,	O
81	int
,	O
82	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
59	int
,	O
33	int
,	O
34	int
,	O
35	int
,	O
103	int
,	O
104	int
,	O
60	int
,	O
202	int
,	O
105	int
,	O
106	int
,	O
137	int
,	O
138	int
,	O
146	int
,	O
147	int
,	O
178	int
,	O
179	int
,	O
64	int
,	O
70	int
,	O
73	int
,	O
75	int
,	O
77	int
,	O
95	int
,	O
78	int
,	O
92	int
,	O
93	int
,	O
94	int
,	O
148	int
,	O
96	int
,	O
150	int
,	O
98	int
,	O
99	int
,	O
100	int
,	O
112	int
,	O
113	int
,	O
114	int
,	O
115	int
,	O
123	int
,	O
116	int
,	O
117	int
,	O
118	int
,	O
119	int
,	O
120	int
,	O
132	int
,	O
121	int
,	O
122	int
,	O
125	int
,	O
126	int
,	O
145	int
,	O
129	int
,	O
130	int
,	O
131	int
,	O
139	int
,	O
149	int
,	O
151	int
,	O
153	int
,	O
177	int
,	O
159	int
,	O
160	int
,	O
167	int
,	O
168	int
,	O
169	int
,	O
170	int
,	O
171	int
,	O
172	int
,	O
173	int
,	O
165	int
,	O
174	int
,	O
175	int
,	O
176	int
,	O
180	int
,	O
181	int
,	O
193	int
,	O
182	int
,	O
183	int
,	O
184	int
,	O
185	int
,	O
186	int
,	O
187	int
,	O
188	int
,	O
189	int
,	O
195	int
,	O
190	int
,	O
197	int
,	O
191	int
,	O
198	int
,	O
203	int
,	O
199	int
,	O
201	int
,	O
194	int
,	O
204	int
,	O
0	int
,	O
206	int
,	O
208	int
,	O
0	int
,	O
196	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
200	int
,	O
0	int
,	O
0	int
,	O
205	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
207	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
209	int
}	O
;	O
static	O
const	O
yytype_int16	short
yycheck	array(short)
[	O
]	O
=	O
{	O
93	int
,	O
94	int
,	O
15	int
,	O
49	int
,	O
82	int
,	O
98	int
,	O
99	int
,	O
100	int
,	O
101	int
,	O
16	int
,	O
103	int
,	O
4	int
,	O
5	int
,	O
7	int
,	O
60	int
,	O
61	int
,	O
62	int
,	O
11	int
,	O
12	int
,	O
112	int
,	O
13	int
,	O
114	int
,	O
115	int
,	O
15	int
,	O
8	int
,	O
118	int
,	O
119	int
,	O
120	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
16	int
,	O
15	int
,	O
17	int
,	O
18	int
,	O
15	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
15	int
,	O
25	int
,	O
0	int
,	O
1	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
127	int
,	O
34	int
,	O
35	int
,	O
65	int
,	O
5	int
,	O
15	int
,	O
16	int
,	O
15	int
,	O
16	int
,	O
10	int
,	O
15	int
,	O
18	int
,	O
19	int
,	O
14	int
,	O
16	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
3	int
,	O
15	int
,	O
59	int
,	O
6	int
,	O
15	int
,	O
8	int
,	O
9	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
15	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
15	int
,	O
16	int
,	O
16	int
,	O
198	int
,	O
15	int
,	O
16	int
,	O
15	int
,	O
16	int
,	O
15	int
,	O
16	int
,	O
15	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
64	int
,	O
64	int
,	O
15	int
,	O
65	int
,	O
16	int
,	O
15	int
,	O
15	int
,	O
15	int
,	O
108	int
,	O
65	int
,	O
110	int
,	O
15	int
,	O
15	int
,	O
15	int
,	O
15	int
,	O
64	int
,	O
15	int
,	O
15	int
,	O
65	int
,	O
16	int
,	O
16	int
,	O
15	int
,	O
15	int
,	O
15	int
,	O
64	int
,	O
16	int
,	O
16	int
,	O
15	int
,	O
15	int
,	O
64	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
61	int
,	O
16	int
,	O
64	int
,	O
17	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
12	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
126	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
15	int
,	O
15	int
,	O
180	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
65	int
,	O
15	int
,	O
17	int
,	O
16	int
,	O
16	int
,	O
65	int
,	O
15	int
,	O
17	int
,	O
16	int
,	O
16	int
,	O
65	int
,	O
16	int
,	O
-	O
1	int
,	O
17	int
,	O
17	int
,	O
-	O
1	int
,	O
65	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
65	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
65	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
65	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
65	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yystos	array(char)
[	O
]	O
=	O
{	O
0	int
,	O
67	int
,	O
0	int
,	O
1	int
,	O
18	int
,	O
19	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
57	int
,	O
58	int
,	O
59	int
,	O
68	int
,	O
69	int
,	O
16	int
,	O
15	int
,	O
15	int
,	O
16	int
,	O
81	int
,	O
81	int
,	O
15	int
,	O
15	int
,	O
15	int
,	O
81	int
,	O
81	int
,	O
81	int
,	O
15	int
,	O
15	int
,	O
81	int
,	O
81	int
,	O
16	int
,	O
81	int
,	O
81	int
,	O
81	int
,	O
81	int
,	O
15	int
,	O
16	int
,	O
81	int
,	O
15	int
,	O
16	int
,	O
16	int
,	O
81	int
,	O
81	int
,	O
81	int
,	O
81	int
,	O
81	int
,	O
16	int
,	O
81	int
,	O
81	int
,	O
64	int
,	O
70	int
,	O
64	int
,	O
71	int
,	O
15	int
,	O
16	int
,	O
3	int
,	O
6	int
,	O
8	int
,	O
9	int
,	O
75	int
,	O
7	int
,	O
11	int
,	O
12	int
,	O
76	int
,	O
4	int
,	O
5	int
,	O
13	int
,	O
77	int
,	O
15	int
,	O
15	int
,	O
15	int
,	O
65	int
,	O
65	int
,	O
72	int
,	O
15	int
,	O
15	int
,	O
15	int
,	O
15	int
,	O
16	int
,	O
15	int
,	O
16	int
,	O
15	int
,	O
16	int
,	O
49	int
,	O
60	int
,	O
61	int
,	O
62	int
,	O
81	int
,	O
15	int
,	O
64	int
,	O
15	int
,	O
15	int
,	O
16	int
,	O
16	int
,	O
15	int
,	O
15	int
,	O
15	int
,	O
16	int
,	O
16	int
,	O
65	int
,	O
73	int
,	O
15	int
,	O
15	int
,	O
15	int
,	O
72	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
64	int
,	O
78	int
,	O
79	int
,	O
78	int
,	O
78	int
,	O
15	int
,	O
16	int
,	O
16	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
64	int
,	O
15	int
,	O
16	int
,	O
81	int
,	O
16	int
,	O
81	int
,	O
61	int
,	O
78	int
,	O
16	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
78	int
,	O
17	int
,	O
16	int
,	O
5	int
,	O
10	int
,	O
14	int
,	O
74	int
,	O
74	int
,	O
72	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
12	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
64	int
,	O
15	int
,	O
16	int
,	O
15	int
,	O
15	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
65	int
,	O
15	int
,	O
16	int
,	O
65	int
,	O
80	int
,	O
80	int
,	O
65	int
,	O
17	int
,	O
65	int
,	O
16	int
,	O
15	int
,	O
16	int
,	O
65	int
,	O
16	int
,	O
78	int
,	O
17	int
,	O
16	int
,	O
65	int
,	O
17	int
,	O
65	int
,	O
17	int
,	O
65	int
}	O
;	O
static	O
void	O
yydestruct	(*(char),int,*(union(int,*(char))))->(void)
(	O
const	O
char	O
*	O
yymsg	*(char)
,	O
int	O
yytype	int
,	O
YYSTYPE	union(int,*(char))
*	O
yyvaluep	*(union(int,*(char)))
)	O
{	O
YYUSE	O
(	O
yyvaluep	*(union(int,*(char)))
)	O
;	O
if	O
(	O
!	O
yymsg	*(char)
)	O
yymsg	*(char)
=	O
"Deleting"	*(char)
;	O
YY_SYMBOL_PRINT	O
(	O
yymsg	*(char)
,	O
yytype	int
,	O
yyvaluep	*(union(int,*(char)))
,	O
yylocationp	O
)	O
;	O
switch	O
(	O
yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
int	O
yyparse	()->(int)
(	O
void	O
)	O
;	O
int	O
yychar	int
;	O
YYSTYPE	union(int,*(char))
yylval	union(int,*(char))
;	O
int	O
yynerrs	int
;	O
int	O
yyparse	()->(int)
(	O
void	O
)	O
{	O
int	O
yystate	int
;	O
int	O
yyerrstatus	int
;	O
yytype_int16	short
yyssa	array(short)
[	O
YYINITDEPTH	int
]	O
;	O
yytype_int16	short
*	O
yyss	*(short)
;	O
yytype_int16	short
*	O
yyssp	*(short)
;	O
YYSTYPE	union(int,*(char))
yyvsa	array(union(int,*(char)))
[	O
YYINITDEPTH	int
]	O
;	O
YYSTYPE	union(int,*(char))
*	O
yyvs	*(union(int,*(char)))
;	O
YYSTYPE	union(int,*(char))
*	O
yyvsp	*(union(int,*(char)))
;	O
YYSIZE_T	O
yystacksize	long
;	O
int	O
yyn	int
;	O
int	O
yyresult	int
;	O
int	O
yytoken	int
;	O
YYSTYPE	union(int,*(char))
yyval	union(int,*(char))
;	O
int	O
yylen	int
=	O
0	int
;	O
yytoken	int
=	O
0	int
;	O
yyss	*(short)
=	O
yyssa	array(short)
;	O
yyvs	*(union(int,*(char)))
=	O
yyvsa	array(union(int,*(char)))
;	O
yystacksize	long
=	O
YYINITDEPTH	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Starting parse\n"	*(char)
)	O
)	O
;	O
yystate	int
=	O
0	int
;	O
yyerrstatus	int
=	O
0	int
;	O
yynerrs	int
=	O
0	int
;	O
yychar	int
=	O
YYEMPTY	O
;	O
yyssp	*(short)
=	O
yyss	*(short)
;	O
yyvsp	*(union(int,*(char)))
=	O
yyvs	*(union(int,*(char)))
;	O
goto	O
yysetstate	O
;	O
yynewstate	O
:	O
yyssp	*(short)
++	O
;	O
yysetstate	O
:	O
*	O
yyssp	*(short)
=	O
yystate	int
;	O
if	O
(	O
yyss	*(short)
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	*(short)
)	O
{	O
YYSIZE_T	O
yysize	long
=	O
yyssp	*(short)
-	O
yyss	*(short)
+	O
1	int
;	O
if	O
(	O
YYMAXDEPTH	int
<=	O
yystacksize	long
)	O
goto	O
yyexhaustedlab	O
;	O
yystacksize	long
*=	O
2	int
;	O
if	O
(	O
YYMAXDEPTH	int
<	O
yystacksize	long
)	O
yystacksize	long
=	O
YYMAXDEPTH	int
;	O
{	O
yytype_int16	short
*	O
yyss1	*(short)
=	O
yyss	*(short)
;	O
union	O
yyalloc	union(short,union(int,*(char)))
*	O
yyptr	*(union(short,union(int,*(char))))
=	O
(	O
union	O
yyalloc	union(short,union(int,*(char)))
*	O
)	O
YYSTACK_ALLOC	O
(	O
YYSTACK_BYTES	O
(	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
!	O
yyptr	*(union(short,union(int,*(char))))
)	O
goto	O
yyexhaustedlab	O
;	O
YYSTACK_RELOCATE	O
(	O
yyss_alloc	short
,	O
yyss	*(short)
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyvs_alloc	union(int,*(char))
,	O
yyvs	*(union(int,*(char)))
)	O
;	O
if	O
(	O
yyss1	*(short)
!=	O
yyssa	array(short)
)	O
YYSTACK_FREE	O
(	O
yyss1	*(short)
)	O
;	O
}	O
yyssp	*(short)
=	O
yyss	*(short)
+	O
yysize	long
-	O
1	int
;	O
yyvsp	*(union(int,*(char)))
=	O
yyvs	*(union(int,*(char)))
+	O
yysize	long
-	O
1	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Stack size increased to %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
yyss	*(short)
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	*(short)
)	O
YYABORT	O
;	O
}	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Entering state %d\n"	*(char)
,	O
yystate	int
)	O
)	O
;	O
if	O
(	O
yystate	int
==	O
YYFINAL	int
)	O
YYACCEPT	O
;	O
goto	O
yybackup	O
;	O
yybackup	O
:	O
yyn	int
=	O
yypact	array(short)
[	O
yystate	int
]	O
;	O
if	O
(	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
goto	O
yydefault	O
;	O
if	O
(	O
yychar	int
==	O
YYEMPTY	O
)	O
{	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Reading a token: "	*(char)
)	O
)	O
;	O
yychar	int
=	O
YYLEX	O
;	O
}	O
if	O
(	O
yychar	int
<=	O
YYEOF	int
)	O
{	O
yychar	int
=	O
yytoken	int
=	O
YYEOF	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Now at end of input.\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
yychar	int
)	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Next token is"	*(char)
,	O
yytoken	int
,	O
&	O
yylval	union(int,*(char))
,	O
&	O
yylloc	O
)	O
;	O
}	O
yyn	int
+=	O
yytoken	int
;	O
if	O
(	O
yyn	int
<	O
0	int
||	O
YYLAST	int
<	O
yyn	int
||	O
yycheck	array(short)
[	O
yyn	int
]	O
!=	O
yytoken	int
)	O
goto	O
yydefault	O
;	O
yyn	int
=	O
yytable	array(char)
[	O
yyn	int
]	O
;	O
if	O
(	O
yyn	int
<=	O
0	int
)	O
{	O
if	O
(	O
yytable_value_is_error	O
(	O
yyn	int
)	O
)	O
goto	O
yyerrlab	O
;	O
yyn	int
=	O
-	O
yyn	int
;	O
goto	O
yyreduce	O
;	O
}	O
if	O
(	O
yyerrstatus	int
)	O
yyerrstatus	int
--	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
yytoken	int
,	O
&	O
yylval	union(int,*(char))
,	O
&	O
yylloc	O
)	O
;	O
yychar	int
=	O
YYEMPTY	O
;	O
yystate	int
=	O
yyn	int
;	O
*	O
++	O
yyvsp	*(union(int,*(char)))
=	O
yylval	union(int,*(char))
;	O
goto	O
yynewstate	O
;	O
yydefault	O
:	O
yyn	int
=	O
yydefact	array(char)
[	O
yystate	int
]	O
;	O
if	O
(	O
yyn	int
==	O
0	int
)	O
goto	O
yyerrlab	O
;	O
goto	O
yyreduce	O
;	O
yyreduce	O
:	O
yylen	int
=	O
yyr2	array(char)
[	O
yyn	int
]	O
;	O
yyval	union(int,*(char))
=	O
yyvsp	*(union(int,*(char)))
[	O
1	int
-	O
yylen	int
]	O
;	O
YY_REDUCE_PRINT	O
(	O
yyn	int
)	O
;	O
switch	O
(	O
yyn	int
)	O
{	O
case	O
3	int
:	O
{	O
free	(*(void))->(void)
(	O
fromname	*(char)
)	O
;	O
fromname	*(char)
=	O
(	O
char	O
*	O
)	O
0	int
;	O
restart_point	long
=	O
(	O
off_t	long
)	O
0	int
;	O
}	O
break	O
;	O
case	O
5	int
:	O
{	O
user	(*(char))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
6	int
:	O
{	O
pass	(*(char))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
s	*(char)
)	O
,	O
0	int
,	O
strlen	(*(char))->(long)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
7	int
:	O
{	O
usedefault	int
=	O
0	int
;	O
if	O
(	O
pdata	int
>=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
pdata	int
)	O
;	O
pdata	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
)	O
{	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
&	O
his_addr	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
,	O
&	O
data_dest	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
,	O
sizeof	O
(	O
data_dest	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
)	O
)	O
==	O
0	int
&&	O
ntohs	(short)->(short)
(	O
data_dest	struct(short,short,struct(int),array(char))
.	O
sin_port	short
)	O
>	O
IPPORT_RESERVED	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"PORT command successful."	*(char)
)	O
;	O
}	O
else	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
data_dest	struct(short,short,struct(int),array(char))
,	O
0	int
,	O
sizeof	O
(	O
data_dest	struct(short,short,struct(int),array(char))
)	O
)	O
;	O
reply	(int,*(char))->(void)
(	O
500	int
,	O
"Illegal PORT Command"	*(char)
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
8	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
i	int
)	O
)	O
passive	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
9	int
:	O
{	O
switch	O
(	O
cmd_type	int
)	O
{	O
case	O
TYPE_A	int
:	O
if	O
(	O
cmd_form	int
==	O
FORM_N	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"Type set to A."	*(char)
)	O
;	O
type	int
=	O
cmd_type	int
;	O
form	int
=	O
cmd_form	int
;	O
}	O
else	O
reply	(int,*(char))->(void)
(	O
504	int
,	O
"Form must be N."	*(char)
)	O
;	O
break	O
;	O
case	O
TYPE_E	int
:	O
reply	(int,*(char))->(void)
(	O
504	int
,	O
"Type E not implemented."	*(char)
)	O
;	O
break	O
;	O
case	O
TYPE_I	int
:	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"Type set to I."	*(char)
)	O
;	O
type	int
=	O
cmd_type	int
;	O
break	O
;	O
case	O
TYPE_L	int
:	O
if	O
(	O
cmd_bytesz	int
==	O
8	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"Type set to L (byte size 8)."	*(char)
)	O
;	O
type	int
=	O
cmd_type	int
;	O
}	O
else	O
reply	(int,*(char))->(void)
(	O
504	int
,	O
"Byte size must be 8."	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
10	int
:	O
{	O
switch	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
i	int
)	O
)	O
{	O
case	O
STRU_F	int
:	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"STRU F ok."	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
reply	(int,*(char))->(void)
(	O
504	int
,	O
"Unimplemented STRU type."	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
11	int
:	O
{	O
switch	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
i	int
)	O
)	O
{	O
case	O
MODE_S	int
:	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"MODE S ok."	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
reply	(int,*(char))->(void)
(	O
502	int
,	O
"Unimplemented MODE type."	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
12	int
:	O
{	O
reply	(int,*(char))->(void)
(	O
202	int
,	O
"ALLO command ignored."	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
13	int
:	O
{	O
reply	(int,*(char))->(void)
(	O
202	int
,	O
"ALLO command ignored."	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
14	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
retrieve	(*(char),*(char))->(void)
(	O
(	O
char	O
*	O
)	O
0	int
,	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
15	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
store	(*(char),*(char),int)->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
,	O
"w"	*(char)
,	O
0	int
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
16	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
store	(*(char),*(char),int)->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
,	O
"a"	*(char)
,	O
0	int
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
17	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
i	int
)	O
)	O
send_file_list	(*(char))->(void)
(	O
"."	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
18	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
send_file_list	(*(char))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
19	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
i	int
)	O
)	O
retrieve	(*(char),*(char))->(void)
(	O
"/bin/ls -lgA"	*(char)
,	O
""	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
20	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
retrieve	(*(char),*(char))->(void)
(	O
"/bin/ls -lgA %s"	*(char)
,	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
21	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
statfilecmd	(*(char))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
22	int
:	O
{	O
statcmd	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
23	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
delete	(*(char))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
24	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
)	O
{	O
if	O
(	O
fromname	*(char)
)	O
{	O
renamecmd	(*(char),*(char))->(void)
(	O
fromname	*(char)
,	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
fromname	*(char)
)	O
;	O
fromname	*(char)
=	O
(	O
char	O
*	O
)	O
0	int
;	O
}	O
else	O
{	O
reply	(int,*(char))->(void)
(	O
503	int
,	O
"Bad sequence of commands."	*(char)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
25	int
:	O
{	O
reply	(int,*(char))->(void)
(	O
225	int
,	O
"ABOR command successful."	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
26	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
i	int
)	O
)	O
cwd	short
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
homedir	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
27	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
cwd	short
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
28	int
:	O
{	O
help	*(char)
(	O
cmdtab	array(struct(*(char),short,short,short,*(char)))
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
29	int
:	O
{	O
char	O
*	O
cp	*(char)
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
s	*(char)
)	O
;	O
if	O
(	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
cp	*(char)
,	O
"SITE"	*(char)
,	O
4	int
)	O
==	O
0	int
)	O
{	O
cp	*(char)
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
s	*(char)
)	O
+	O
4	int
;	O
if	O
(	O
*	O
cp	*(char)
==	O
' '	O
)	O
cp	*(char)
++	O
;	O
if	O
(	O
*	O
cp	*(char)
)	O
help	*(char)
(	O
sitetab	array(struct(*(char),short,short,short,*(char)))
,	O
cp	*(char)
)	O
;	O
else	O
help	*(char)
(	O
sitetab	array(struct(*(char),short,short,short,*(char)))
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
else	O
help	*(char)
(	O
cmdtab	array(struct(*(char),short,short,short,*(char)))
,	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
30	int
:	O
{	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"NOOP command successful."	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
31	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
makedir	(*(char))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
32	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
removedir	(*(char))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
33	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
i	int
)	O
)	O
pwd	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
34	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
i	int
)	O
)	O
cwd	short
(	O
".."	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
35	int
:	O
{	O
help	*(char)
(	O
sitetab	array(struct(*(char),short,short,short,*(char)))
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
36	int
:	O
{	O
help	*(char)
(	O
sitetab	array(struct(*(char),short,short,short,*(char)))
,	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
5	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
5	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
37	int
:	O
{	O
int	O
oldmask	long
;	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
)	O
{	O
oldmask	long
=	O
umask	(int)->(int)
(	O
0	int
)	O
;	O
umask	(int)->(int)
(	O
oldmask	long
)	O
;	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"Current UMASK is %03o"	*(char)
,	O
oldmask	long
)	O
;	O
}	O
}	O
break	O
;	O
case	O
38	int
:	O
{	O
int	O
oldmask	long
;	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
7	int
)	O
]	O
.	O
i	int
)	O
)	O
{	O
if	O
(	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
6	int
)	O
-	O
(	O
7	int
)	O
]	O
.	O
i	int
)	O
==	O
-	O
1	int
)	O
||	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
6	int
)	O
-	O
(	O
7	int
)	O
]	O
.	O
i	int
)	O
>	O
0777	int
)	O
)	O
{	O
reply	(int,*(char))->(void)
(	O
501	int
,	O
"Bad UMASK value"	*(char)
)	O
;	O
}	O
else	O
{	O
oldmask	long
=	O
umask	(int)->(int)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
6	int
)	O
-	O
(	O
7	int
)	O
]	O
.	O
i	int
)	O
)	O
;	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"UMASK set to %03o (was %03o)"	*(char)
,	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
6	int
)	O
-	O
(	O
7	int
)	O
]	O
.	O
i	int
)	O
,	O
oldmask	long
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
39	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
9	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
8	int
)	O
-	O
(	O
9	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
)	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
6	int
)	O
-	O
(	O
9	int
)	O
]	O
.	O
i	int
)	O
>	O
0777	int
)	O
reply	(int,*(char))->(void)
(	O
501	int
,	O
"CHMOD: Mode value must be between 0 and 0777"	*(char)
)	O
;	O
else	O
if	O
(	O
chmod	(*(char),int)->(int)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
8	int
)	O
-	O
(	O
9	int
)	O
]	O
.	O
s	*(char)
)	O
,	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
6	int
)	O
-	O
(	O
9	int
)	O
]	O
.	O
i	int
)	O
)	O
<	O
0	int
)	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
8	int
)	O
-	O
(	O
9	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
else	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"CHMOD command successful."	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
8	int
)	O
-	O
(	O
9	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
40	int
:	O
{	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"Current IDLE time limit is %d seconds; max %d"	*(char)
,	O
timeout	int
,	O
maxtimeout	int
)	O
;	O
}	O
break	O
;	O
case	O
41	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
7	int
)	O
]	O
.	O
i	int
)	O
)	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
6	int
)	O
-	O
(	O
7	int
)	O
]	O
.	O
i	int
)	O
<	O
30	int
||	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
6	int
)	O
-	O
(	O
7	int
)	O
]	O
.	O
i	int
)	O
>	O
maxtimeout	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
501	int
,	O
"Maximum IDLE time must be between 30 and %d seconds"	*(char)
,	O
maxtimeout	int
)	O
;	O
}	O
else	O
{	O
timeout	int
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
6	int
)	O
-	O
(	O
7	int
)	O
]	O
.	O
i	int
)	O
;	O
alarm	(int)->(int)
(	O
(	O
unsigned	O
)	O
timeout	int
)	O
;	O
reply	(int,*(char))->(void)
(	O
200	int
,	O
"Maximum IDLE time set to %d seconds"	*(char)
,	O
timeout	int
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
42	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
store	(*(char),*(char),int)->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
,	O
"w"	*(char)
,	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
43	int
:	O
{	O
const	O
char	O
*	O
sys_type	*(char)
;	O
char	O
*	O
version	array(char)
=	O
0	int
;	O
struct	O
utsname	struct(array(char),array(char),array(char),array(char),array(char),array(char))
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
;	O
if	O
(	O
uname	(*(struct(array(char),array(char),array(char),array(char),array(char),array(char))))->(int)
(	O
&	O
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
)	O
==	O
0	int
)	O
{	O
version	array(char)
=	O
malloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
.	O
sysname	array(char)
)	O
+	O
1	int
+	O
strlen	(*(char))->(long)
(	O
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
.	O
release	array(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
version	array(char)
)	O
sprintf	(*(char),*(char))->(int)
(	O
version	array(char)
,	O
"%s %s"	*(char)
,	O
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
.	O
sysname	array(char)
,	O
u	struct(array(char),array(char),array(char),array(char),array(char),array(char))
.	O
release	array(char)
)	O
;	O
}	O
sys_type	*(char)
=	O
"UNIX"	*(char)
;	O
if	O
(	O
version	array(char)
)	O
reply	(int,*(char))->(void)
(	O
215	int
,	O
"%s Type: L%d Version: %s"	*(char)
,	O
sys_type	*(char)
,	O
NBBY	O
,	O
version	array(char)
)	O
;	O
else	O
reply	(int,*(char))->(void)
(	O
215	int
,	O
"%s Type: L%d"	*(char)
,	O
sys_type	*(char)
,	O
NBBY	O
)	O
;	O
free	(*(void))->(void)
(	O
version	array(char)
)	O
;	O
}	O
break	O
;	O
case	O
44	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
sizecmd	(*(char))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
45	int
:	O
{	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
!=	O
NULL	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
,	O
&	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
)	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"%s: %s"	*(char)
,	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
else	O
if	O
(	O
!	O
S_ISREG	O
(	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"%s: not a plain file."	*(char)
,	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
t	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
;	O
t	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
=	O
gmtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mtime	O
)	O
;	O
reply	(int,*(char))->(void)
(	O
213	int
,	O
"%04d%02d%02d%02d%02d%02d"	*(char)
,	O
1900	int
+	O
t	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_year	int
,	O
t	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_mon	int
+	O
1	int
,	O
t	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_mday	int
,	O
t	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_hour	int
,	O
t	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_min	int
,	O
t	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
->	O
tm_sec	int
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
46	int
:	O
{	O
reply	(int,*(char))->(void)
(	O
221	int
,	O
"Goodbye."	*(char)
)	O
;	O
dologout	(int)->(void)
(	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
47	int
:	O
{	O
yyerrok	O
;	O
}	O
break	O
;	O
case	O
48	int
:	O
{	O
restart_point	long
=	O
(	O
off_t	long
)	O
0	int
;	O
if	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
i	int
)	O
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
{	O
free	(*(void))->(void)
(	O
fromname	*(char)
)	O
;	O
fromname	*(char)
=	O
renamefrom	(*(char))->(*(char))
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
fromname	*(char)
==	O
(	O
char	O
*	O
)	O
0	int
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
49	int
:	O
{	O
free	(*(void))->(void)
(	O
fromname	*(char)
)	O
;	O
fromname	*(char)
=	O
(	O
char	O
*	O
)	O
0	int
;	O
restart_point	long
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
i	int
)	O
;	O
reply	(int,*(char))->(void)
(	O
350	int
,	O
(	O
sizeof	O
(	O
restart_point	long
)	O
>	O
sizeof	O
(	O
long	O
)	O
?	O
"Restarting at %lld. %s"	*(char)
:	O
"Restarting at %ld. %s"	*(char)
)	O
,	O
restart_point	long
,	O
"Send STORE or RETRIEVE to initiate transfer."	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
51	int
:	O
{	O
(	O
yyval	union(int,*(char))
.	O
s	*(char)
)	O
=	O
(	O
char	O
*	O
)	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
54	int
:	O
{	O
char	O
*	O
a	*(char)
,	O
*	O
p	*(char)
;	O
a	*(char)
=	O
(	O
char	O
*	O
)	O
&	O
data_dest	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
;	O
a	*(char)
[	O
0	int
]	O
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
1	int
)	O
-	O
(	O
11	int
)	O
]	O
.	O
i	int
)	O
;	O
a	*(char)
[	O
1	int
]	O
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
11	int
)	O
]	O
.	O
i	int
)	O
;	O
a	*(char)
[	O
2	int
]	O
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
5	int
)	O
-	O
(	O
11	int
)	O
]	O
.	O
i	int
)	O
;	O
a	*(char)
[	O
3	int
]	O
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
7	int
)	O
-	O
(	O
11	int
)	O
]	O
.	O
i	int
)	O
;	O
p	*(char)
=	O
(	O
char	O
*	O
)	O
&	O
data_dest	struct(short,short,struct(int),array(char))
.	O
sin_port	short
;	O
p	*(char)
[	O
0	int
]	O
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
9	int
)	O
-	O
(	O
11	int
)	O
]	O
.	O
i	int
)	O
;	O
p	*(char)
[	O
1	int
]	O
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
11	int
)	O
-	O
(	O
11	int
)	O
]	O
.	O
i	int
)	O
;	O
data_dest	struct(short,short,struct(int),array(char))
.	O
sin_family	short
=	O
AF_INET	O
;	O
}	O
break	O
;	O
case	O
55	int
:	O
{	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
FORM_N	int
;	O
}	O
break	O
;	O
case	O
56	int
:	O
{	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
FORM_T	int
;	O
}	O
break	O
;	O
case	O
57	int
:	O
{	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
FORM_C	int
;	O
}	O
break	O
;	O
case	O
58	int
:	O
{	O
cmd_type	int
=	O
TYPE_A	int
;	O
cmd_form	int
=	O
FORM_N	int
;	O
}	O
break	O
;	O
case	O
59	int
:	O
{	O
cmd_type	int
=	O
TYPE_A	int
;	O
cmd_form	int
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
i	int
)	O
;	O
}	O
break	O
;	O
case	O
60	int
:	O
{	O
cmd_type	int
=	O
TYPE_E	int
;	O
cmd_form	int
=	O
FORM_N	int
;	O
}	O
break	O
;	O
case	O
61	int
:	O
{	O
cmd_type	int
=	O
TYPE_E	int
;	O
cmd_form	int
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
i	int
)	O
;	O
}	O
break	O
;	O
case	O
62	int
:	O
{	O
cmd_type	int
=	O
TYPE_I	int
;	O
}	O
break	O
;	O
case	O
63	int
:	O
{	O
cmd_type	int
=	O
TYPE_L	int
;	O
cmd_bytesz	int
=	O
NBBY	O
;	O
}	O
break	O
;	O
case	O
64	int
:	O
{	O
cmd_type	int
=	O
TYPE_L	int
;	O
cmd_bytesz	int
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
i	int
)	O
;	O
}	O
break	O
;	O
case	O
65	int
:	O
{	O
cmd_type	int
=	O
TYPE_L	int
;	O
cmd_bytesz	int
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
i	int
)	O
;	O
}	O
break	O
;	O
case	O
66	int
:	O
{	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
STRU_F	int
;	O
}	O
break	O
;	O
case	O
67	int
:	O
{	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
STRU_R	int
;	O
}	O
break	O
;	O
case	O
68	int
:	O
{	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
STRU_P	int
;	O
}	O
break	O
;	O
case	O
69	int
:	O
{	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
MODE_S	int
;	O
}	O
break	O
;	O
case	O
70	int
:	O
{	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
MODE_B	int
;	O
}	O
break	O
;	O
case	O
71	int
:	O
{	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
MODE_C	int
;	O
}	O
break	O
;	O
case	O
72	int
:	O
{	O
if	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
logged_in	int
&&	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
s	*(char)
)	O
&&	O
*	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
s	*(char)
)	O
==	O
'~'	O
)	O
{	O
glob_t	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
;	O
int	O
flags	int
=	O
GLOB_NOCHECK	O
;	O
flags	int
|=	O
GLOB_BRACE	O
;	O
flags	int
|=	O
GLOB_TILDE	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
,	O
0	int
,	O
sizeof	O
(	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
)	O
;	O
if	O
(	O
glob	O
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
s	*(char)
)	O
,	O
flags	int
,	O
NULL	O
,	O
&	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
||	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathc	long
==	O
0	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"not found"	*(char)
)	O
;	O
(	O
yyval	union(int,*(char))
.	O
s	*(char)
)	O
=	O
NULL	O
;	O
}	O
else	O
{	O
(	O
yyval	union(int,*(char))
.	O
s	*(char)
)	O
=	O
strdup	(*(char))->(*(char))
(	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
.	O
gl_pathv	*(*(char))
[	O
0	int
]	O
)	O
;	O
}	O
globfree	O
(	O
&	O
gl	struct(long,*(*(char)),long,int,*((*(void))->(void)),*((*(void))->(*(struct))),*((*(char))->(*(void))),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)),*((*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long))))->(int)))
)	O
;	O
free	(*(void))->(void)
(	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
s	*(char)
)	O
)	O
;	O
}	O
else	O
(	O
yyval	union(int,*(char))
.	O
s	*(char)
)	O
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
s	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
74	int
:	O
{	O
int	O
ret	int
,	O
dec	int
,	O
multby	int
,	O
digit	int
;	O
dec	int
=	O
(	O
yyvsp	*(union(int,*(char)))
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
i	int
)	O
;	O
multby	int
=	O
1	int
;	O
ret	int
=	O
0	int
;	O
while	O
(	O
dec	int
)	O
{	O
digit	int
=	O
dec	int
%	O
10	int
;	O
if	O
(	O
digit	int
>	O
7	int
)	O
{	O
ret	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
ret	int
+=	O
digit	int
*	O
multby	int
;	O
multby	int
*=	O
8	int
;	O
dec	int
/=	O
10	int
;	O
}	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
ret	int
;	O
}	O
break	O
;	O
case	O
75	int
:	O
{	O
if	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
logged_in	int
)	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
1	int
;	O
else	O
{	O
reply	(int,*(char))->(void)
(	O
530	int
,	O
"Please login with USER and PASS."	*(char)
)	O
;	O
(	O
yyval	union(int,*(char))
.	O
i	int
)	O
=	O
0	int
;	O
}	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_SYMBOL_PRINT	O
(	O
"-> $$ ="	*(char)
,	O
yyr1	array(char)
[	O
yyn	int
]	O
,	O
&	O
yyval	union(int,*(char))
,	O
&	O
yyloc	O
)	O
;	O
YYPOPSTACK	O
(	O
yylen	int
)	O
;	O
yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
*	O
++	O
yyvsp	*(union(int,*(char)))
=	O
yyval	union(int,*(char))
;	O
yyn	int
=	O
yyr1	array(char)
[	O
yyn	int
]	O
;	O
yystate	int
=	O
yypgoto	array(char)
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
+	O
*	O
yyssp	*(short)
;	O
if	O
(	O
0	int
<=	O
yystate	int
&&	O
yystate	int
<=	O
YYLAST	int
&&	O
yycheck	array(short)
[	O
yystate	int
]	O
==	O
*	O
yyssp	*(short)
)	O
yystate	int
=	O
yytable	array(char)
[	O
yystate	int
]	O
;	O
else	O
yystate	int
=	O
yydefgoto	array(short)
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
;	O
goto	O
yynewstate	O
;	O
yyerrlab	O
:	O
yytoken	int
=	O
yychar	int
==	O
YYEMPTY	O
?	O
YYEMPTY	O
:	O
YYTRANSLATE	O
(	O
yychar	int
)	O
;	O
if	O
(	O
!	O
yyerrstatus	int
)	O
{	O
++	O
yynerrs	int
;	O
yyerror	(*(char))->(void)
(	O
YY_	O
(	O
"syntax error"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
yyerrstatus	int
==	O
3	int
)	O
{	O
if	O
(	O
yychar	int
<=	O
YYEOF	int
)	O
{	O
if	O
(	O
yychar	int
==	O
YYEOF	int
)	O
YYABORT	O
;	O
}	O
else	O
{	O
yydestruct	(*(char),int,*(union(int,*(char))))->(void)
(	O
"Error: discarding"	*(char)
,	O
yytoken	int
,	O
&	O
yylval	union(int,*(char))
)	O
;	O
yychar	int
=	O
YYEMPTY	O
;	O
}	O
}	O
goto	O
yyerrlab1	O
;	O
yyerrorlab	O
:	O
if	O
(	O
0	int
)	O
goto	O
yyerrorlab	O
;	O
YYPOPSTACK	O
(	O
yylen	int
)	O
;	O
yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
yystate	int
=	O
*	O
yyssp	*(short)
;	O
goto	O
yyerrlab1	O
;	O
yyerrlab1	O
:	O
yyerrstatus	int
=	O
3	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
yyn	int
=	O
yypact	array(short)
[	O
yystate	int
]	O
;	O
if	O
(	O
!	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
{	O
yyn	int
+=	O
YYTERROR	int
;	O
if	O
(	O
0	int
<=	O
yyn	int
&&	O
yyn	int
<=	O
YYLAST	int
&&	O
yycheck	array(short)
[	O
yyn	int
]	O
==	O
YYTERROR	int
)	O
{	O
yyn	int
=	O
yytable	array(char)
[	O
yyn	int
]	O
;	O
if	O
(	O
0	int
<	O
yyn	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
yyssp	*(short)
==	O
yyss	*(short)
)	O
YYABORT	O
;	O
yydestruct	(*(char),int,*(union(int,*(char))))->(void)
(	O
"Error: popping"	*(char)
,	O
yystos	array(char)
[	O
yystate	int
]	O
,	O
yyvsp	*(union(int,*(char)))
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
yystate	int
=	O
*	O
yyssp	*(short)
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
}	O
*	O
++	O
yyvsp	*(union(int,*(char)))
=	O
yylval	union(int,*(char))
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	*(char)
,	O
yystos	array(char)
[	O
yyn	int
]	O
,	O
yyvsp	*(union(int,*(char)))
,	O
yylsp	O
)	O
;	O
yystate	int
=	O
yyn	int
;	O
goto	O
yynewstate	O
;	O
yyacceptlab	O
:	O
yyresult	int
=	O
0	int
;	O
goto	O
yyreturn	O
;	O
yyabortlab	O
:	O
yyresult	int
=	O
1	int
;	O
goto	O
yyreturn	O
;	O
yyexhaustedlab	O
:	O
yyerror	(*(char))->(void)
(	O
YY_	O
(	O
"memory exhausted"	*(char)
)	O
)	O
;	O
yyresult	int
=	O
2	int
;	O
yyreturn	O
:	O
if	O
(	O
yychar	int
!=	O
YYEMPTY	O
)	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
yychar	int
)	O
;	O
yydestruct	(*(char),int,*(union(int,*(char))))->(void)
(	O
"Cleanup: discarding lookahead"	*(char)
,	O
yytoken	int
,	O
&	O
yylval	union(int,*(char))
)	O
;	O
}	O
YYPOPSTACK	O
(	O
yylen	int
)	O
;	O
YY_STACK_PRINT	O
(	O
yyss	*(short)
,	O
yyssp	*(short)
)	O
;	O
while	O
(	O
yyssp	*(short)
!=	O
yyss	*(short)
)	O
{	O
yydestruct	(*(char),int,*(union(int,*(char))))->(void)
(	O
"Cleanup: popping"	*(char)
,	O
yystos	array(char)
[	O
*	O
yyssp	*(short)
]	O
,	O
yyvsp	*(union(int,*(char)))
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
yyss	*(short)
!=	O
yyssa	array(short)
)	O
YYSTACK_FREE	O
(	O
yyss	*(short)
)	O
;	O
return	O
YYID	O
(	O
yyresult	int
)	O
;	O
}	O
struct	O
tab	struct(*(char),short,short,short,*(char))
cmdtab	array(struct(*(char),short,short,short,*(char)))
[	O
]	O
=	O
{	O
{	O
"USER"	*(char)
,	O
USER	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> username"	*(char)
}	O
,	O
{	O
"PASS"	*(char)
,	O
PASS	int
,	O
ZSTR1	int
,	O
1	int
,	O
"<sp> password"	*(char)
}	O
,	O
{	O
"ACCT"	*(char)
,	O
ACCT	int
,	O
STR1	int
,	O
0	int
,	O
"(specify account)"	*(char)
}	O
,	O
{	O
"SMNT"	*(char)
,	O
SMNT	int
,	O
ARGS	int
,	O
0	int
,	O
"(structure mount)"	*(char)
}	O
,	O
{	O
"REIN"	*(char)
,	O
REIN	int
,	O
ARGS	int
,	O
0	int
,	O
"(reinitialize server state)"	*(char)
}	O
,	O
{	O
"QUIT"	*(char)
,	O
QUIT	int
,	O
ARGS	int
,	O
1	int
,	O
"(terminate service)"	*(char)
,	O
}	O
,	O
{	O
"PORT"	*(char)
,	O
PORT	int
,	O
ARGS	int
,	O
1	int
,	O
"<sp> b0, b1, b2, b3, b4"	*(char)
}	O
,	O
{	O
"PASV"	*(char)
,	O
PASV	int
,	O
ARGS	int
,	O
1	int
,	O
"(set server in passive mode)"	*(char)
}	O
,	O
{	O
"TYPE"	*(char)
,	O
TYPE	int
,	O
ARGS	int
,	O
1	int
,	O
"<sp> [ A | E | I | L ]"	*(char)
}	O
,	O
{	O
"STRU"	*(char)
,	O
STRU	int
,	O
ARGS	int
,	O
1	int
,	O
"(specify file structure)"	*(char)
}	O
,	O
{	O
"MODE"	*(char)
,	O
MODE	int
,	O
ARGS	int
,	O
1	int
,	O
"(specify transfer mode)"	*(char)
}	O
,	O
{	O
"RETR"	*(char)
,	O
RETR	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> file-name"	*(char)
}	O
,	O
{	O
"STOR"	*(char)
,	O
STOR	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> file-name"	*(char)
}	O
,	O
{	O
"APPE"	*(char)
,	O
APPE	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> file-name"	*(char)
}	O
,	O
{	O
"MLFL"	*(char)
,	O
MLFL	int
,	O
OSTR	int
,	O
0	int
,	O
"(mail file)"	*(char)
}	O
,	O
{	O
"MAIL"	*(char)
,	O
MAIL	int
,	O
OSTR	int
,	O
0	int
,	O
"(mail to user)"	*(char)
}	O
,	O
{	O
"MSND"	*(char)
,	O
MSND	int
,	O
OSTR	int
,	O
0	int
,	O
"(mail send to terminal)"	*(char)
}	O
,	O
{	O
"MSOM"	*(char)
,	O
MSOM	int
,	O
OSTR	int
,	O
0	int
,	O
"(mail send to terminal or mailbox)"	*(char)
}	O
,	O
{	O
"MSAM"	*(char)
,	O
MSAM	int
,	O
OSTR	int
,	O
0	int
,	O
"(mail send to terminal and mailbox)"	*(char)
}	O
,	O
{	O
"MRSQ"	*(char)
,	O
MRSQ	int
,	O
OSTR	int
,	O
0	int
,	O
"(mail recipient scheme question)"	*(char)
}	O
,	O
{	O
"MRCP"	*(char)
,	O
MRCP	int
,	O
STR1	int
,	O
0	int
,	O
"(mail recipient)"	*(char)
}	O
,	O
{	O
"ALLO"	*(char)
,	O
ALLO	int
,	O
ARGS	int
,	O
1	int
,	O
"allocate storage (vacuously)"	*(char)
}	O
,	O
{	O
"REST"	*(char)
,	O
REST	int
,	O
ARGS	int
,	O
1	int
,	O
"<sp> offset (restart command)"	*(char)
}	O
,	O
{	O
"RNFR"	*(char)
,	O
RNFR	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> file-name"	*(char)
}	O
,	O
{	O
"RNTO"	*(char)
,	O
RNTO	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> file-name"	*(char)
}	O
,	O
{	O
"ABOR"	*(char)
,	O
ABOR	int
,	O
ARGS	int
,	O
1	int
,	O
"(abort operation)"	*(char)
}	O
,	O
{	O
"DELE"	*(char)
,	O
DELE	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> file-name"	*(char)
}	O
,	O
{	O
"CWD"	*(char)
,	O
CWD	int
,	O
OSTR	int
,	O
1	int
,	O
"[ <sp> directory-name ]"	*(char)
}	O
,	O
{	O
"XCWD"	*(char)
,	O
CWD	int
,	O
OSTR	int
,	O
1	int
,	O
"[ <sp> directory-name ]"	*(char)
}	O
,	O
{	O
"LIST"	*(char)
,	O
LIST	int
,	O
OSTR	int
,	O
1	int
,	O
"[ <sp> path-name ]"	*(char)
}	O
,	O
{	O
"NLST"	*(char)
,	O
NLST	int
,	O
OSTR	int
,	O
1	int
,	O
"[ <sp> path-name ]"	*(char)
}	O
,	O
{	O
"SITE"	*(char)
,	O
SITE	int
,	O
SITECMD	int
,	O
1	int
,	O
"site-cmd [ <sp> arguments ]"	*(char)
}	O
,	O
{	O
"SYST"	*(char)
,	O
SYST	int
,	O
ARGS	int
,	O
1	int
,	O
"(get type of operating system)"	*(char)
}	O
,	O
{	O
"STAT"	*(char)
,	O
STAT	int
,	O
OSTR	int
,	O
1	int
,	O
"[ <sp> path-name ]"	*(char)
}	O
,	O
{	O
"HELP"	*(char)
,	O
HELP	int
,	O
OSTR	int
,	O
1	int
,	O
"[ <sp> <string> ]"	*(char)
}	O
,	O
{	O
"NOOP"	*(char)
,	O
NOOP	int
,	O
ARGS	int
,	O
1	int
,	O
""	*(char)
}	O
,	O
{	O
"MKD"	*(char)
,	O
MKD	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> path-name"	*(char)
}	O
,	O
{	O
"XMKD"	*(char)
,	O
MKD	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> path-name"	*(char)
}	O
,	O
{	O
"RMD"	*(char)
,	O
RMD	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> path-name"	*(char)
}	O
,	O
{	O
"XRMD"	*(char)
,	O
RMD	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> path-name"	*(char)
}	O
,	O
{	O
"PWD"	*(char)
,	O
PWD	int
,	O
ARGS	int
,	O
1	int
,	O
"(return current directory)"	*(char)
}	O
,	O
{	O
"XPWD"	*(char)
,	O
PWD	int
,	O
ARGS	int
,	O
1	int
,	O
"(return current directory)"	*(char)
}	O
,	O
{	O
"CDUP"	*(char)
,	O
CDUP	int
,	O
ARGS	int
,	O
1	int
,	O
"(change to parent directory)"	*(char)
}	O
,	O
{	O
"XCUP"	*(char)
,	O
CDUP	int
,	O
ARGS	int
,	O
1	int
,	O
"(change to parent directory)"	*(char)
}	O
,	O
{	O
"STOU"	*(char)
,	O
STOU	int
,	O
STR1	int
,	O
1	int
,	O
"<sp> file-name"	*(char)
}	O
,	O
{	O
"SIZE"	*(char)
,	O
SIZE	int
,	O
OSTR	int
,	O
1	int
,	O
"<sp> path-name"	*(char)
}	O
,	O
{	O
"MDTM"	*(char)
,	O
MDTM	int
,	O
OSTR	int
,	O
1	int
,	O
"<sp> path-name"	*(char)
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
struct	O
tab	struct(*(char),short,short,short,*(char))
sitetab	array(struct(*(char),short,short,short,*(char)))
[	O
]	O
=	O
{	O
{	O
"UMASK"	*(char)
,	O
UMASK	int
,	O
ARGS	int
,	O
1	int
,	O
"[ <sp> umask ]"	*(char)
}	O
,	O
{	O
"IDLE"	*(char)
,	O
IDLE	int
,	O
ARGS	int
,	O
1	int
,	O
"[ <sp> maximum-idle-time ]"	*(char)
}	O
,	O
{	O
"CHMOD"	*(char)
,	O
CHMOD	int
,	O
NSTR	int
,	O
1	int
,	O
"<sp> mode <sp> file-name"	*(char)
}	O
,	O
{	O
"HELP"	*(char)
,	O
HELP	int
,	O
OSTR	int
,	O
1	int
,	O
"[ <sp> <string> ]"	*(char)
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
struct	O
tab	struct(*(char),short,short,short,*(char))
*	O
lookup	(*(struct(*(char),short,short,short,*(char))),*(char))->(*(struct(*(char),short,short,short,*(char))))
(	O
struct	O
tab	struct(*(char),short,short,short,*(char))
*	O
p	*(char)
,	O
char	O
*	O
cmd	*(char)
)	O
{	O
for	O
(	O
;	O
p	*(char)
->	O
name	*(char)
!=	O
NULL	O
;	O
p	*(char)
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(char)
,	O
p	*(char)
->	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
p	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
char	O
*	O
telnet_fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
char	O
*	O
s	*(char)
,	O
int	O
n	int
,	O
FILE	struct
*	O
iop	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
c	int
;	O
register	O
char	O
*	O
cs	short
;	O
cs	short
=	O
s	*(char)
;	O
for	O
(	O
c	int
=	O
0	int
;	O
tmpline	array(char)
[	O
c	int
]	O
!=	O
'\0'	O
&&	O
--	O
n	int
>	O
0	int
;	O
++	O
c	int
)	O
{	O
*	O
cs	short
++	O
=	O
tmpline	array(char)
[	O
c	int
]	O
;	O
if	O
(	O
tmpline	array(char)
[	O
c	int
]	O
==	O
'\n'	O
)	O
{	O
*	O
cs	short
++	O
=	O
'\0'	O
;	O
if	O
(	O
debug	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_DEBUG	int
,	O
"command: %s"	*(char)
,	O
s	*(char)
)	O
;	O
tmpline	array(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
s	*(char)
)	O
;	O
}	O
if	O
(	O
c	int
==	O
0	int
)	O
tmpline	array(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
while	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
iop	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
{	O
c	int
&=	O
0377	int
;	O
if	O
(	O
c	int
==	O
IAC	int
)	O
{	O
if	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
iop	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
{	O
c	int
&=	O
0377	int
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
WILL	int
:	O
case	O
WONT	int
:	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
iop	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printf	(*(char))->(int)
(	O
"%c%c%c"	*(char)
,	O
IAC	int
,	O
DONT	int
,	O
0377	int
&	O
c	int
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
continue	O
;	O
case	O
DO	int
:	O
case	O
DONT	int
:	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
iop	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printf	(*(char))->(int)
(	O
"%c%c%c"	*(char)
,	O
IAC	int
,	O
WONT	int
,	O
0377	int
&	O
c	int
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
continue	O
;	O
case	O
IAC	int
:	O
break	O
;	O
default	O
:	O
continue	O
;	O
}	O
}	O
}	O
*	O
cs	short
++	O
=	O
c	int
;	O
if	O
(	O
--	O
n	int
<=	O
0	int
||	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
EOF	O
&&	O
cs	short
==	O
s	*(char)
)	O
return	O
(	O
NULL	O
)	O
;	O
*	O
cs	short
++	O
=	O
'\0'	O
;	O
if	O
(	O
debug	int
)	O
{	O
if	O
(	O
!	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
guest	int
&&	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
"pass "	*(char)
,	O
s	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
{	O
syslog	(int,*(char))->(void)
(	O
LOG_DEBUG	int
,	O
"command: %.5s ???"	*(char)
,	O
s	*(char)
)	O
;	O
}	O
else	O
{	O
register	O
char	O
*	O
cp	*(char)
;	O
register	O
int	O
len	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
;	O
cp	*(char)
=	O
s	*(char)
+	O
len	int
-	O
1	int
;	O
while	O
(	O
cp	*(char)
>=	O
s	*(char)
&&	O
(	O
*	O
cp	*(char)
==	O
'\n'	O
||	O
*	O
cp	*(char)
==	O
'\r'	O
)	O
)	O
{	O
--	O
cp	*(char)
;	O
--	O
len	int
;	O
}	O
syslog	(int,*(char))->(void)
(	O
LOG_DEBUG	int
,	O
"command: %.*s"	*(char)
,	O
len	int
,	O
s	*(char)
)	O
;	O
}	O
}	O
return	O
(	O
s	*(char)
)	O
;	O
}	O
void	O
toolong	(int)->(void)
(	O
int	O
signo	int
)	O
{	O
(	O
void	O
)	O
signo	int
;	O
reply	(int,*(char))->(void)
(	O
421	int
,	O
"Timeout (%d seconds): closing control connection."	*(char)
,	O
timeout	int
)	O
;	O
if	O
(	O
logging	int
)	O
syslog	(int,*(char))->(void)
(	O
LOG_INFO	int
,	O
"User %s timed out after %d seconds"	*(char)
,	O
(	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
name	*(char)
?	O
cred	struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),int,int,int,int,int,int)
.	O
name	*(char)
:	O
"unknown"	*(char)
)	O
,	O
timeout	int
)	O
;	O
dologout	(int)->(void)
(	O
1	int
)	O
;	O
}	O
static	O
int	O
yylex	()->(int)
(	O
void	O
)	O
{	O
static	O
int	O
cpos	int
,	O
state	*(int)
;	O
char	O
*	O
cp	*(char)
,	O
*	O
cp2	*(char)
;	O
struct	O
tab	struct(*(char),short,short,short,*(char))
*	O
p	*(char)
;	O
int	O
n	int
;	O
char	O
c	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
switch	O
(	O
state	*(int)
)	O
{	O
case	O
CMD	int
:	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGALRM	int
,	O
toolong	(int)->(void)
)	O
;	O
alarm	(int)->(int)
(	O
(	O
unsigned	O
)	O
timeout	int
)	O
;	O
if	O
(	O
telnet_fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
cbuf	array(char)
,	O
sizeof	O
(	O
cbuf	array(char)
)	O
-	O
1	int
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
NULL	O
)	O
{	O
reply	(int,*(char))->(void)
(	O
221	int
,	O
"You could at least say goodbye."	*(char)
)	O
;	O
dologout	(int)->(void)
(	O
0	int
)	O
;	O
}	O
alarm	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
(	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cbuf	array(char)
,	O
'\r'	O
)	O
)	O
)	O
{	O
*	O
cp	*(char)
++	O
=	O
'\n'	O
;	O
*	O
cp	*(char)
=	O
'\0'	O
;	O
}	O
if	O
(	O
(	O
cp	*(char)
=	O
strpbrk	(*(char),*(char))->(*(char))
(	O
cbuf	array(char)
,	O
" \n"	*(char)
)	O
)	O
)	O
cpos	int
=	O
cp	*(char)
-	O
cbuf	array(char)
;	O
if	O
(	O
cpos	int
==	O
0	int
)	O
cpos	int
=	O
4	int
;	O
c	int
=	O
cbuf	array(char)
[	O
cpos	int
]	O
;	O
cbuf	array(char)
[	O
cpos	int
]	O
=	O
'\0'	O
;	O
upper	(*(char))->(void)
(	O
cbuf	array(char)
)	O
;	O
p	*(char)
=	O
lookup	(*(struct(*(char),short,short,short,*(char))),*(char))->(*(struct(*(char),short,short,short,*(char))))
(	O
cmdtab	array(struct(*(char),short,short,short,*(char)))
,	O
cbuf	array(char)
)	O
;	O
cbuf	array(char)
[	O
cpos	int
]	O
=	O
c	int
;	O
if	O
(	O
p	*(char)
!=	O
0	int
)	O
{	O
if	O
(	O
p	*(char)
->	O
implemented	short
==	O
0	int
)	O
{	O
nack	(*(char))->(void)
(	O
p	*(char)
->	O
name	*(char)
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
errcatch	array(struct(array(long),int,struct(array(long))))
,	O
0	int
)	O
;	O
}	O
state	*(int)
=	O
p	*(char)
->	O
state	*(int)
;	O
yylval	union(int,*(char))
.	O
s	*(char)
=	O
(	O
char	O
*	O
)	O
p	*(char)
->	O
name	*(char)
;	O
return	O
(	O
p	*(char)
->	O
token	short
)	O
;	O
}	O
break	O
;	O
case	O
SITECMD	int
:	O
if	O
(	O
cbuf	array(char)
[	O
cpos	int
]	O
==	O
' '	O
)	O
{	O
cpos	int
++	O
;	O
return	O
(	O
SP	int
)	O
;	O
}	O
cp	*(char)
=	O
&	O
cbuf	array(char)
[	O
cpos	int
]	O
;	O
if	O
(	O
(	O
cp2	*(char)
=	O
strpbrk	(*(char),*(char))->(*(char))
(	O
cp	*(char)
,	O
" \n"	*(char)
)	O
)	O
)	O
cpos	int
=	O
cp2	*(char)
-	O
cbuf	array(char)
;	O
c	int
=	O
cbuf	array(char)
[	O
cpos	int
]	O
;	O
cbuf	array(char)
[	O
cpos	int
]	O
=	O
'\0'	O
;	O
upper	(*(char))->(void)
(	O
cp	*(char)
)	O
;	O
p	*(char)
=	O
lookup	(*(struct(*(char),short,short,short,*(char))),*(char))->(*(struct(*(char),short,short,short,*(char))))
(	O
sitetab	array(struct(*(char),short,short,short,*(char)))
,	O
cp	*(char)
)	O
;	O
cbuf	array(char)
[	O
cpos	int
]	O
=	O
c	int
;	O
if	O
(	O
p	*(char)
!=	O
0	int
)	O
{	O
if	O
(	O
p	*(char)
->	O
implemented	short
==	O
0	int
)	O
{	O
state	*(int)
=	O
CMD	int
;	O
nack	(*(char))->(void)
(	O
p	*(char)
->	O
name	*(char)
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
errcatch	array(struct(array(long),int,struct(array(long))))
,	O
0	int
)	O
;	O
}	O
state	*(int)
=	O
p	*(char)
->	O
state	*(int)
;	O
yylval	union(int,*(char))
.	O
s	*(char)
=	O
(	O
char	O
*	O
)	O
p	*(char)
->	O
name	*(char)
;	O
return	O
(	O
p	*(char)
->	O
token	short
)	O
;	O
}	O
state	*(int)
=	O
CMD	int
;	O
break	O
;	O
case	O
OSTR	int
:	O
if	O
(	O
cbuf	array(char)
[	O
cpos	int
]	O
==	O
'\n'	O
)	O
{	O
state	*(int)
=	O
CMD	int
;	O
return	O
(	O
CRLF	int
)	O
;	O
}	O
case	O
STR1	int
:	O
case	O
ZSTR1	int
:	O
dostr1	O
:	O
if	O
(	O
cbuf	array(char)
[	O
cpos	int
]	O
==	O
' '	O
)	O
{	O
cpos	int
++	O
;	O
if	O
(	O
state	*(int)
==	O
OSTR	int
)	O
state	*(int)
=	O
STR2	int
;	O
else	O
++	O
state	*(int)
;	O
return	O
(	O
SP	int
)	O
;	O
}	O
break	O
;	O
case	O
ZSTR2	int
:	O
if	O
(	O
cbuf	array(char)
[	O
cpos	int
]	O
==	O
'\n'	O
)	O
{	O
state	*(int)
=	O
CMD	int
;	O
return	O
(	O
CRLF	int
)	O
;	O
}	O
case	O
STR2	int
:	O
cp	*(char)
=	O
&	O
cbuf	array(char)
[	O
cpos	int
]	O
;	O
n	int
=	O
strlen	(*(char))->(long)
(	O
cp	*(char)
)	O
;	O
cpos	int
+=	O
n	int
-	O
1	int
;	O
if	O
(	O
n	int
>	O
1	int
&&	O
cbuf	array(char)
[	O
cpos	int
]	O
==	O
'\n'	O
)	O
{	O
cbuf	array(char)
[	O
cpos	int
]	O
=	O
'\0'	O
;	O
yylval	union(int,*(char))
.	O
s	*(char)
=	O
copy	(*(char))->(*(char))
(	O
cp	*(char)
)	O
;	O
cbuf	array(char)
[	O
cpos	int
]	O
=	O
'\n'	O
;	O
state	*(int)
=	O
ARGS	int
;	O
return	O
(	O
STRING	int
)	O
;	O
}	O
break	O
;	O
case	O
NSTR	int
:	O
if	O
(	O
cbuf	array(char)
[	O
cpos	int
]	O
==	O
' '	O
)	O
{	O
cpos	int
++	O
;	O
return	O
(	O
SP	int
)	O
;	O
}	O
if	O
(	O
isdigit	(int)->(int)
(	O
cbuf	array(char)
[	O
cpos	int
]	O
)	O
)	O
{	O
cp	*(char)
=	O
&	O
cbuf	array(char)
[	O
cpos	int
]	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
cbuf	array(char)
[	O
++	O
cpos	int
]	O
)	O
)	O
;	O
c	int
=	O
cbuf	array(char)
[	O
cpos	int
]	O
;	O
cbuf	array(char)
[	O
cpos	int
]	O
=	O
'\0'	O
;	O
yylval	union(int,*(char))
.	O
i	int
=	O
atoi	(*(char))->(int)
(	O
cp	*(char)
)	O
;	O
cbuf	array(char)
[	O
cpos	int
]	O
=	O
c	int
;	O
state	*(int)
=	O
STR1	int
;	O
return	O
(	O
NUMBER	int
)	O
;	O
}	O
state	*(int)
=	O
STR1	int
;	O
goto	O
dostr1	O
;	O
case	O
ARGS	int
:	O
if	O
(	O
isdigit	(int)->(int)
(	O
cbuf	array(char)
[	O
cpos	int
]	O
)	O
)	O
{	O
cp	*(char)
=	O
&	O
cbuf	array(char)
[	O
cpos	int
]	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
cbuf	array(char)
[	O
++	O
cpos	int
]	O
)	O
)	O
;	O
c	int
=	O
cbuf	array(char)
[	O
cpos	int
]	O
;	O
cbuf	array(char)
[	O
cpos	int
]	O
=	O
'\0'	O
;	O
yylval	union(int,*(char))
.	O
i	int
=	O
atoi	(*(char))->(int)
(	O
cp	*(char)
)	O
;	O
cbuf	array(char)
[	O
cpos	int
]	O
=	O
c	int
;	O
return	O
(	O
NUMBER	int
)	O
;	O
}	O
switch	O
(	O
cbuf	array(char)
[	O
cpos	int
++	O
]	O
)	O
{	O
case	O
'\n'	O
:	O
state	*(int)
=	O
CMD	int
;	O
return	O
(	O
CRLF	int
)	O
;	O
case	O
' '	O
:	O
return	O
(	O
SP	int
)	O
;	O
case	O
','	O
:	O
return	O
(	O
COMMA	int
)	O
;	O
case	O
'A'	O
:	O
case	O
'a'	O
:	O
return	O
(	O
A	int
)	O
;	O
case	O
'B'	O
:	O
case	O
'b'	O
:	O
return	O
(	O
B	int
)	O
;	O
case	O
'C'	O
:	O
case	O
'c'	O
:	O
return	O
(	O
C	int
)	O
;	O
case	O
'E'	O
:	O
case	O
'e'	O
:	O
return	O
(	O
E	int
)	O
;	O
case	O
'F'	O
:	O
case	O
'f'	O
:	O
return	O
(	O
F	int
)	O
;	O
case	O
'I'	O
:	O
case	O
'i'	O
:	O
return	O
(	O
I	int
)	O
;	O
case	O
'L'	O
:	O
case	O
'l'	O
:	O
return	O
(	O
L	int
)	O
;	O
case	O
'N'	O
:	O
case	O
'n'	O
:	O
return	O
(	O
N	int
)	O
;	O
case	O
'P'	O
:	O
case	O
'p'	O
:	O
return	O
(	O
P	int
)	O
;	O
case	O
'R'	O
:	O
case	O
'r'	O
:	O
return	O
(	O
R	int
)	O
;	O
case	O
'S'	O
:	O
case	O
's'	O
:	O
return	O
(	O
S	int
)	O
;	O
case	O
'T'	O
:	O
case	O
't'	O
:	O
return	O
(	O
T	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
fatal	(*(char))->(void)
(	O
"Unknown state in scanner."	*(char)
)	O
;	O
}	O
yyerror	(*(char))->(void)
(	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
state	*(int)
=	O
CMD	int
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
errcatch	array(struct(array(long),int,struct(array(long))))
,	O
0	int
)	O
;	O
}	O
}	O
void	O
upper	(*(char))->(void)
(	O
char	O
*	O
s	*(char)
)	O
{	O
while	O
(	O
*	O
s	*(char)
!=	O
'\0'	O
)	O
{	O
if	O
(	O
islower	(int)->(int)
(	O
*	O
s	*(char)
)	O
)	O
*	O
s	*(char)
=	O
toupper	(int)->(int)
(	O
*	O
s	*(char)
)	O
;	O
s	*(char)
++	O
;	O
}	O
}	O
static	O
char	O
*	O
copy	(*(char))->(*(char))
(	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
*	O
p	*(char)
;	O
p	*(char)
=	O
malloc	(long)->(*(void))
(	O
(	O
unsigned	O
)	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
+	O
1	int
)	O
;	O
if	O
(	O
p	*(char)
==	O
NULL	O
)	O
fatal	(*(char))->(void)
(	O
"Ran out of memory."	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(char)
,	O
s	*(char)
)	O
;	O
return	O
(	O
p	*(char)
)	O
;	O
}	O
static	O
void	O
help	*(char)
(	O
struct	O
tab	struct(*(char),short,short,short,*(char))
*	O
ctab	*(struct(*(char),short,short,short,*(char)))
,	O
char	O
*	O
s	*(char)
)	O
{	O
struct	O
tab	struct(*(char),short,short,short,*(char))
*	O
c	int
;	O
int	O
width	int
,	O
NCMDS	int
;	O
const	O
char	O
*	O
help_type	*(char)
;	O
if	O
(	O
ctab	*(struct(*(char),short,short,short,*(char)))
==	O
sitetab	array(struct(*(char),short,short,short,*(char)))
)	O
help_type	*(char)
=	O
"SITE "	*(char)
;	O
else	O
help_type	*(char)
=	O
""	*(char)
;	O
width	int
=	O
0	int
,	O
NCMDS	int
=	O
0	int
;	O
for	O
(	O
c	int
=	O
ctab	*(struct(*(char),short,short,short,*(char)))
;	O
c	int
->	O
name	*(char)
!=	O
NULL	O
;	O
c	int
++	O
)	O
{	O
int	O
len	int
=	O
strlen	(*(char))->(long)
(	O
c	int
->	O
name	*(char)
)	O
;	O
if	O
(	O
len	int
>	O
width	int
)	O
width	int
=	O
len	int
;	O
NCMDS	int
++	O
;	O
}	O
width	int
=	O
(	O
width	int
+	O
8	int
)	O
&	O
~	O
7	int
;	O
if	O
(	O
s	*(char)
==	O
0	int
)	O
{	O
int	O
i	int
,	O
j	int
,	O
w	int
;	O
int	O
columns	int
,	O
lines	int
;	O
lreply	(int,*(char))->(void)
(	O
214	int
,	O
"The following %scommands are recognized %s."	*(char)
,	O
help_type	*(char)
,	O
"(* =>'s unimplemented)"	*(char)
)	O
;	O
columns	int
=	O
76	int
/	O
width	int
;	O
if	O
(	O
columns	int
==	O
0	int
)	O
columns	int
=	O
1	int
;	O
lines	int
=	O
(	O
NCMDS	int
+	O
columns	int
-	O
1	int
)	O
/	O
columns	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
lines	int
;	O
i	int
++	O
)	O
{	O
printf	(*(char))->(int)
(	O
"   "	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
columns	int
;	O
j	int
++	O
)	O
{	O
c	int
=	O
ctab	*(struct(*(char),short,short,short,*(char)))
+	O
j	int
*	O
lines	int
+	O
i	int
;	O
printf	(*(char))->(int)
(	O
"%s%c"	*(char)
,	O
c	int
->	O
name	*(char)
,	O
c	int
->	O
implemented	short
?	O
' '	O
:	O
'*'	O
)	O
;	O
if	O
(	O
c	int
+	O
lines	int
>=	O
&	O
ctab	*(struct(*(char),short,short,short,*(char)))
[	O
NCMDS	int
]	O
)	O
break	O
;	O
w	int
=	O
strlen	(*(char))->(long)
(	O
c	int
->	O
name	*(char)
)	O
+	O
1	int
;	O
while	O
(	O
w	int
<	O
width	int
)	O
{	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
w	int
++	O
;	O
}	O
}	O
printf	(*(char))->(int)
(	O
"\r\n"	*(char)
)	O
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
reply	(int,*(char))->(void)
(	O
214	int
,	O
"Direct comments to ftp-bugs@%s."	*(char)
,	O
hostname	*(char)
)	O
;	O
return	O
;	O
}	O
upper	(*(char))->(void)
(	O
s	*(char)
)	O
;	O
c	int
=	O
lookup	(*(struct(*(char),short,short,short,*(char))),*(char))->(*(struct(*(char),short,short,short,*(char))))
(	O
ctab	*(struct(*(char),short,short,short,*(char)))
,	O
s	*(char)
)	O
;	O
if	O
(	O
c	int
==	O
(	O
struct	O
tab	struct(*(char),short,short,short,*(char))
*	O
)	O
0	int
)	O
{	O
reply	(int,*(char))->(void)
(	O
502	int
,	O
"Unknown command %s."	*(char)
,	O
s	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
c	int
->	O
implemented	short
)	O
reply	(int,*(char))->(void)
(	O
214	int
,	O
"Syntax: %s%s %s"	*(char)
,	O
help_type	*(char)
,	O
c	int
->	O
name	*(char)
,	O
c	int
->	O
help	*(char)
)	O
;	O
else	O
reply	(int,*(char))->(void)
(	O
214	int
,	O
"%s%-*s\t%s; unimplemented."	*(char)
,	O
help_type	*(char)
,	O
width	int
,	O
c	int
->	O
name	*(char)
,	O
c	int
->	O
help	*(char)
)	O
;	O
}	O
static	O
void	O
sizecmd	(*(char))->(void)
(	O
char	O
*	O
filename	*(char)
)	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
TYPE_L	int
:	O
case	O
TYPE_I	int
:	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
filename	*(char)
,	O
&	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
||	O
!	O
S_ISREG	O
(	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"%s: not a plain file."	*(char)
,	O
filename	*(char)
)	O
;	O
else	O
reply	(int,*(char))->(void)
(	O
213	int
,	O
(	O
sizeof	O
(	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
>	O
sizeof	O
(	O
long	O
)	O
?	O
"%llu"	*(char)
:	O
"%lu"	*(char)
)	O
,	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
)	O
;	O
break	O
;	O
}	O
case	O
TYPE_A	int
:	O
{	O
FILE	struct
*	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
c	int
;	O
off_t	long
count	long
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
perror_reply	(int,*(char))->(void)
(	O
550	int
,	O
filename	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
&	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
<	O
0	int
||	O
!	O
S_ISREG	O
(	O
stbuf	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
reply	(int,*(char))->(void)
(	O
550	int
,	O
"%s: not a plain file."	*(char)
,	O
filename	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
;	O
}	O
count	long
=	O
0	int
;	O
while	O
(	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
count	long
++	O
;	O
count	long
++	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
reply	(int,*(char))->(void)
(	O
213	int
,	O
sizeof	O
(	O
count	long
)	O
>	O
sizeof	O
(	O
long	O
)	O
?	O
"%lld"	*(char)
:	O
"%ld"	*(char)
,	O
count	long
)	O
;	O
break	O
;	O
}	O
default	O
:	O
reply	(int,*(char))->(void)
(	O
504	int
,	O
"SIZE not implemented for Type %c."	*(char)
,	O
"?AEIL"	*(char)
[	O
type	int
]	O
)	O
;	O
}	O
}	O
static	O
void	O
yyerror	(*(char))->(void)
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
*	O
cp	*(char)
;	O
(	O
void	O
)	O
s	*(char)
;	O
cp	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cbuf	array(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
cp	*(char)
!=	O
NULL	O
)	O
*	O
cp	*(char)
=	O
'\0'	O
;	O
reply	(int,*(char))->(void)
(	O
500	int
,	O
"'%s': command not understood."	*(char)
,	O
cbuf	array(char)
)	O
;	O
}	O
