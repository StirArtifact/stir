static	O
struct	O
TreeStore	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(char),*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`))))),int,int)
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
;	O
static	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
tree_store_add_entry	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
const	O
char	O
*	O
name	*(char)
)	O
;	O
static	O
void	O
tree_store_dirty	(int)->(void)
(	O
int	O
state	*(int)
)	O
{	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
dirty	int
=	O
state	*(int)
;	O
}	O
static	O
size_t	long
str_common	(*(char),*(char))->(long)
(	O
const	O
char	O
*	O
s1	*(char)
,	O
const	O
char	O
*	O
s2	*(char)
)	O
{	O
size_t	long
result	long
=	O
0	int
;	O
while	O
(	O
*	O
s1	*(char)
!=	O
'\0'	O
&&	O
*	O
s2	*(char)
!=	O
'\0'	O
&&	O
*	O
s1	*(char)
++	O
==	O
*	O
s2	*(char)
++	O
)	O
result	long
++	O
;	O
return	O
result	long
;	O
}	O
static	O
int	O
pathcmp	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
p1	*(char)
,	O
const	O
char	O
*	O
p2	*(char)
)	O
{	O
for	O
(	O
;	O
*	O
p1	*(char)
==	O
*	O
p2	*(char)
;	O
p1	*(char)
++	O
,	O
p2	*(char)
++	O
)	O
if	O
(	O
*	O
p1	*(char)
==	O
'\0'	O
)	O
return	O
0	int
;	O
if	O
(	O
*	O
p1	*(char)
==	O
'\0'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
p2	*(char)
==	O
'\0'	O
)	O
return	O
1	int
;	O
if	O
(	O
*	O
p1	*(char)
==	O
PATH_SEP	char
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
p2	*(char)
==	O
PATH_SEP	char
)	O
return	O
1	int
;	O
return	O
(	O
*	O
p1	*(char)
-	O
*	O
p2	*(char)
)	O
;	O
}	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
tree_store_whereis	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
=	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
int	O
flag	int
=	O
-	O
1	int
;	O
while	O
(	O
current	*(struct)
&&	O
(	O
flag	int
=	O
pathcmp	(*(char),*(char))->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
name	*(char)
)	O
)	O
<	O
0	int
)	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
flag	int
==	O
0	int
)	O
return	O
current	*(struct)
;	O
else	O
return	O
NULL	O
;	O
}	O
struct	O
TreeStore	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(char),*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`))))),int,int)
*	O
tree_store_get	()->(*(struct(*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)),*(char),*(struct(*`,*`,*`)),int,int)))
(	O
void	O
)	O
{	O
return	O
&	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
;	O
}	O
static	O
char	O
*	O
decode	(*(char))->(*(char))
(	O
char	O
*	O
buffer	*(char)
)	O
{	O
char	O
*	O
res	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
buffer	*(char)
)	O
;	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(char)
;	O
for	O
(	O
p	*(void)
=	O
q	*(char)
=	O
res	*(char)
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
,	O
q	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
p	*(void)
==	O
'\n'	O
)	O
{	O
*	O
q	*(char)
=	O
0	int
;	O
return	O
res	*(char)
;	O
}	O
if	O
(	O
*	O
p	*(void)
!=	O
'\\'	O
)	O
{	O
*	O
q	*(char)
=	O
*	O
p	*(void)
;	O
continue	O
;	O
}	O
p	*(void)
++	O
;	O
switch	O
(	O
*	O
p	*(void)
)	O
{	O
case	O
'n'	O
:	O
*	O
q	*(char)
=	O
'\n'	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
*	O
q	*(char)
=	O
'\\'	O
;	O
break	O
;	O
}	O
}	O
*	O
q	*(char)
=	O
*	O
p	*(void)
;	O
return	O
res	*(char)
;	O
}	O
static	O
int	O
tree_store_load_from	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
FILE	struct
*	O
file	*(char)
;	O
char	O
buffer	*(char)
[	O
MC_MAXPATHLEN	O
+	O
20	int
]	O
,	O
oldname	array(char)
[	O
MC_MAXPATHLEN	O
]	O
;	O
char	O
*	O
different	*(char)
;	O
int	O
len	int
,	O
common	int
;	O
int	O
do_load	int
;	O
g_return_val_if_fail	O
(	O
name	*(char)
!=	O
NULL	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
loaded	int
)	O
return	O
TRUE	O
;	O
file	*(char)
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
file	*(char)
)	O
{	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buffer	*(char)
,	O
sizeof	O
(	O
buffer	*(char)
)	O
,	O
file	*(char)
)	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
buffer	*(char)
,	O
TREE_SIGNATURE	*(char)
,	O
strlen	(*(char))->(long)
(	O
TREE_SIGNATURE	*(char)
)	O
)	O
!=	O
0	int
)	O
{	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
;	O
do_load	int
=	O
FALSE	O
;	O
}	O
else	O
do_load	int
=	O
TRUE	O
;	O
}	O
else	O
do_load	int
=	O
FALSE	O
;	O
if	O
(	O
do_load	int
)	O
{	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
loaded	int
=	O
TRUE	O
;	O
oldname	array(char)
[	O
0	int
]	O
=	O
0	int
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buffer	*(char)
,	O
MC_MAXPATHLEN	O
,	O
file	*(char)
)	O
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
e	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
int	O
scanned	int
;	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
(	O
buffer	*(char)
[	O
0	int
]	O
!=	O
'0'	O
&&	O
buffer	*(char)
[	O
0	int
]	O
!=	O
'1'	O
)	O
)	O
continue	O
;	O
if	O
(	O
buffer	*(char)
[	O
1	int
]	O
!=	O
':'	O
)	O
continue	O
;	O
scanned	int
=	O
buffer	*(char)
[	O
0	int
]	O
==	O
'1'	O
;	O
name	*(char)
=	O
decode	(*(char))->(*(char))
(	O
buffer	*(char)
+	O
2	int
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
!=	O
PATH_SEP	char
)	O
{	O
char	O
*	O
s	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
name	*(char)
,	O
" "	*(char)
)	O
;	O
if	O
(	O
s	*(char)
)	O
{	O
common	int
=	O
atoi	(*(char))->(int)
(	O
s	*(char)
)	O
;	O
different	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
NULL	O
,	O
""	*(char)
)	O
;	O
if	O
(	O
different	*(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
oldname	array(char)
+	O
common	int
,	O
different	*(char)
)	O
;	O
if	O
(	O
vfs_file_is_local	(*(char))->(int)
(	O
oldname	array(char)
)	O
)	O
{	O
e	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
tree_store_add_entry	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
oldname	array(char)
)	O
;	O
e	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
scanned	int
=	O
scanned	int
;	O
}	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
vfs_file_is_local	(*(char))->(int)
(	O
name	*(char)
)	O
)	O
{	O
e	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
tree_store_add_entry	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
name	*(char)
)	O
;	O
e	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
scanned	int
=	O
scanned	int
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
oldname	array(char)
,	O
name	*(char)
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
{	O
tree_store_add_entry	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
PATH_SEP_STR	*(char)
)	O
;	O
tree_store_rescan	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
PATH_SEP_STR	*(char)
)	O
;	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
loaded	int
=	O
TRUE	O
;	O
}	O
return	O
TRUE	O
;	O
}	O
int	O
tree_store_load	()->(int)
(	O
void	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
retval	*(void)
;	O
name	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
home_dir	*(char)
,	O
MC_TREE	*(char)
)	O
;	O
retval	*(void)
=	O
tree_store_load_from	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
return	O
retval	*(void)
;	O
}	O
static	O
char	O
*	O
encode	(*(char))->(*(char))
(	O
const	O
char	O
*	O
string	*(char)
)	O
{	O
int	O
special_chars	int
;	O
const	O
char	O
*	O
p	*(void)
;	O
char	O
*	O
q	*(char)
;	O
char	O
*	O
res	*(char)
;	O
for	O
(	O
special_chars	int
=	O
0	int
,	O
p	*(void)
=	O
string	*(char)
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
{	O
if	O
(	O
*	O
p	*(void)
==	O
'\n'	O
||	O
*	O
p	*(void)
==	O
'\\'	O
)	O
special_chars	int
++	O
;	O
}	O
res	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
p	*(void)
-	O
string	*(char)
+	O
special_chars	int
+	O
1	int
)	O
;	O
for	O
(	O
p	*(void)
=	O
string	*(char)
,	O
q	*(char)
=	O
res	*(char)
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
,	O
q	*(char)
++	O
)	O
{	O
if	O
(	O
*	O
p	*(void)
!=	O
'\n'	O
&&	O
*	O
p	*(void)
!=	O
'\\'	O
)	O
{	O
*	O
q	*(char)
=	O
*	O
p	*(void)
;	O
continue	O
;	O
}	O
*	O
q	*(char)
++	O
=	O
'\\'	O
;	O
switch	O
(	O
*	O
p	*(void)
)	O
{	O
case	O
'\n'	O
:	O
*	O
q	*(char)
=	O
'n'	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
*	O
q	*(char)
=	O
'\\'	O
;	O
break	O
;	O
}	O
}	O
*	O
q	*(char)
=	O
0	int
;	O
return	O
res	*(char)
;	O
}	O
static	O
int	O
tree_store_save_to	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
;	O
FILE	struct
*	O
file	*(char)
;	O
file	*(char)
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
"w"	*(char)
)	O
;	O
if	O
(	O
!	O
file	*(char)
)	O
return	O
errno	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"%s\n"	*(char)
,	O
TREE_SIGNATURE	*(char)
)	O
;	O
current	*(struct)
=	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
while	O
(	O
current	*(struct)
)	O
{	O
int	O
i	array(int)
,	O
common	int
;	O
if	O
(	O
vfs_file_is_local	(*(char))->(int)
(	O
current	*(struct)
->	O
name	*(char)
)	O
)	O
{	O
if	O
(	O
current	*(struct)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
&&	O
(	O
common	int
=	O
str_common	(*(char),*(char))->(long)
(	O
current	*(struct)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
current	*(struct)
->	O
name	*(char)
)	O
)	O
>	O
2	int
)	O
{	O
char	O
*	O
encoded	*(char)
=	O
encode	(*(char))->(*(char))
(	O
current	*(struct)
->	O
name	*(char)
+	O
common	int
)	O
;	O
i	array(int)
=	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"%d:%d %s\n"	*(char)
,	O
current	*(struct)
->	O
scanned	int
,	O
common	int
,	O
encoded	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
encoded	*(char)
)	O
;	O
}	O
else	O
{	O
char	O
*	O
encoded	*(char)
=	O
encode	(*(char))->(*(char))
(	O
current	*(struct)
->	O
name	*(char)
)	O
;	O
i	array(int)
=	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
file	*(char)
,	O
"%d:%s\n"	*(char)
,	O
current	*(struct)
->	O
scanned	int
,	O
encoded	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
encoded	*(char)
)	O
;	O
}	O
if	O
(	O
i	array(int)
==	O
EOF	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Cannot write to the %s file:\n%s\n"	*(char)
)	O
,	O
name	*(char)
,	O
unix_error_string	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
break	O
;	O
}	O
}	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
tree_store_dirty	(int)->(void)
(	O
FALSE	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
tree_store_save	()->(int)
(	O
void	O
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
char	O
*	O
name	*(char)
;	O
int	O
retval	*(void)
;	O
tmp	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
home_dir	*(char)
,	O
MC_TREE_TMP	*(char)
)	O
;	O
retval	*(void)
=	O
tree_store_save_to	(*(char))->(int)
(	O
tmp	*(char)
)	O
;	O
if	O
(	O
retval	*(void)
)	O
{	O
g_free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
return	O
retval	*(void)
;	O
}	O
name	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
home_dir	*(char)
,	O
MC_TREE	*(char)
)	O
;	O
retval	*(void)
=	O
rename	(*(char),*(char))->(int)
(	O
tmp	*(char)
,	O
name	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
if	O
(	O
retval	*(void)
)	O
return	O
errno	O
;	O
else	O
return	O
0	int
;	O
}	O
static	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
tree_store_add_entry	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
flag	int
=	O
-	O
1	int
;	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
=	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
NULL	O
;	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
int	O
i	array(int)
,	O
len	int
;	O
int	O
submask	long
=	O
0	int
;	O
if	O
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_last	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
&&	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_last	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
abort	()->(void)
(	O
)	O
;	O
while	O
(	O
current	*(struct)
&&	O
(	O
flag	int
=	O
pathcmp	(*(char),*(char))->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
name	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
current	*(struct)
;	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
if	O
(	O
flag	int
==	O
0	int
)	O
return	O
current	*(struct)
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
g_new0	O
(	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
,	O
1	int
)	O
;	O
if	O
(	O
!	O
current	*(struct)
)	O
{	O
if	O
(	O
!	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
{	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
}	O
else	O
{	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
}	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_last	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
}	O
else	O
{	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
if	O
(	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
{	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
}	O
else	O
{	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
}	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
}	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
name	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
name	*(char)
)	O
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
sublevel	int
=	O
0	int
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
i	array(int)
<	O
len	int
;	O
i	array(int)
++	O
)	O
if	O
(	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
name	*(char)
[	O
i	array(int)
]	O
==	O
PATH_SEP	char
)	O
{	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
sublevel	int
++	O
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
subname	*(char)
=	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
name	*(char)
+	O
i	array(int)
+	O
1	int
;	O
}	O
if	O
(	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
submask	long
=	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
submask	long
;	O
else	O
submask	long
=	O
0	int
;	O
submask	long
|=	O
1	int
<<	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
sublevel	int
;	O
submask	long
&=	O
(	O
2	int
<<	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
sublevel	int
)	O
-	O
1	int
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
submask	long
=	O
submask	long
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
mark	int
=	O
0	int
;	O
current	*(struct)
=	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
while	O
(	O
current	*(struct)
&&	O
current	*(struct)
->	O
sublevel	int
>	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
sublevel	int
)	O
{	O
current	*(struct)
->	O
submask	long
|=	O
1	int
<<	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
sublevel	int
;	O
current	*(struct)
=	O
current	*(struct)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
if	O
(	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
sublevel	int
>	O
1	int
)	O
{	O
char	O
*	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
g_strdup	(*(char))->(*(char))
(	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
name	*(char)
)	O
;	O
int	O
i	array(int)
;	O
for	O
(	O
i	array(int)
=	O
strlen	(*(char))->(long)
(	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
-	O
1	int
;	O
i	array(int)
>	O
1	int
;	O
i	array(int)
--	O
)	O
{	O
if	O
(	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
==	O
PATH_SEP	char
)	O
{	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
[	O
i	array(int)
]	O
=	O
0	int
;	O
tree_store_add_entry	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
break	O
;	O
}	O
}	O
g_free	(*(void))->(void)
(	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
}	O
tree_store_dirty	(int)->(void)
(	O
TRUE	O
)	O
;	O
return	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
}	O
static	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
*	O
remove_entry_hooks	*(struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct`)))))
;	O
void	O
tree_store_add_entry_remove_hook	(*((*(struct(*`,int,long,*`,int,int,*`,*`)),*(void))->(void)),*(void))->(void)
(	O
tree_store_remove_fn	*((*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(void))->(void))
callback	*((*(void))->(int))
,	O
void	O
*	O
data	*(void)
)	O
{	O
add_hook	(*(*(struct(*((*`)->(void)),*(void),*(struct`)))),*((*(void))->(void)),*(void))->(void)
(	O
&	O
remove_entry_hooks	*(struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct`)))))
,	O
(	O
void	O
(	O
*	O
)	O
(	O
void	O
*	O
)	O
)	O
callback	*((*(void))->(int))
,	O
data	*(void)
)	O
;	O
}	O
void	O
tree_store_remove_entry_remove_hook	(*((*(struct(*`,int,long,*`,int,int,*`,*`)),*(void))->(void)))->(void)
(	O
tree_store_remove_fn	*((*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(void))->(void))
callback	*((*(void))->(int))
)	O
{	O
delete_hook	(*(*(struct(*((*`)->(void)),*(void),*(struct`)))),*((*(void))->(void)))->(void)
(	O
&	O
remove_entry_hooks	*(struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct`)))))
,	O
(	O
void	O
(	O
*	O
)	O
(	O
void	O
*	O
)	O
)	O
callback	*((*(void))->(int))
)	O
;	O
}	O
static	O
void	O
tree_store_notify_remove	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))->(void)
(	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
{	O
Hook	struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct(*`,*`,*`)))))
*	O
p	*(void)
=	O
remove_entry_hooks	*(struct(*((*(void))->(void)),*(void),*(struct(*((*`)->(void)),*(void),*(struct`)))))
;	O
tree_store_remove_fn	*((*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(void))->(void))
r	*((*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(void))->(void))
;	O
while	O
(	O
p	*(void)
)	O
{	O
r	*((*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(void))->(void))
=	O
(	O
tree_store_remove_fn	*((*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(void))->(void))
)	O
p	*(void)
->	O
hook_fn	*((*(void))->(void))
;	O
r	*((*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(void))->(void))
(	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
,	O
p	*(void)
->	O
hook_data	*(void)
)	O
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
}	O
static	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
remove_entry	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
=	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
long	O
submask	long
=	O
0	int
;	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
ret	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
NULL	O
;	O
tree_store_notify_remove	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))->(void)
(	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
;	O
if	O
(	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
submask	long
=	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
submask	long
;	O
while	O
(	O
current	*(struct)
&&	O
current	*(struct)
->	O
sublevel	int
>	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
sublevel	int
)	O
{	O
submask	long
|=	O
1	int
<<	O
current	*(struct)
->	O
sublevel	int
;	O
submask	long
&=	O
(	O
2	int
<<	O
current	*(struct)
->	O
sublevel	int
)	O
-	O
1	int
;	O
current	*(struct)
->	O
submask	long
=	O
submask	long
;	O
current	*(struct)
=	O
current	*(struct)
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
if	O
(	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
else	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_first	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
else	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
tree_last	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
prev	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
g_free	(*(void))->(void)
(	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
name	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
;	O
return	O
ret	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
}	O
void	O
tree_store_remove_entry	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
,	O
*	O
base	int
,	O
*	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
int	O
len	int
;	O
g_return_if_fail	O
(	O
name	*(char)
!=	O
NULL	O
)	O
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
PATH_SEP	char
&&	O
name	*(char)
[	O
1	int
]	O
==	O
0	int
)	O
return	O
;	O
base	int
=	O
tree_store_whereis	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
base	int
)	O
return	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
base	int
->	O
name	*(char)
)	O
;	O
current	*(struct)
=	O
base	int
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
while	O
(	O
current	*(struct)
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
base	int
->	O
name	*(char)
,	O
len	int
)	O
==	O
0	int
&&	O
(	O
current	*(struct)
->	O
name	*(char)
[	O
len	int
]	O
==	O
'\0'	O
||	O
current	*(struct)
->	O
name	*(char)
[	O
len	int
]	O
==	O
PATH_SEP	char
)	O
)	O
{	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
current	*(struct)
;	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
remove_entry	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
}	O
remove_entry	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
base	int
)	O
;	O
tree_store_dirty	(int)->(void)
(	O
TRUE	O
)	O
;	O
return	O
;	O
}	O
void	O
tree_store_mark_checked	(*(char))->(void)
(	O
const	O
char	O
*	O
subname	*(char)
)	O
{	O
char	O
*	O
name	*(char)
;	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
,	O
*	O
base	int
;	O
int	O
flag	int
=	O
1	int
,	O
len	int
;	O
if	O
(	O
!	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
loaded	int
)	O
return	O
;	O
if	O
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
subname	*(char)
[	O
0	int
]	O
==	O
'.'	O
&&	O
(	O
subname	*(char)
[	O
1	int
]	O
==	O
0	int
||	O
(	O
subname	*(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
subname	*(char)
[	O
2	int
]	O
==	O
0	int
)	O
)	O
)	O
return	O
;	O
if	O
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
[	O
0	int
]	O
==	O
PATH_SEP	char
&&	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
[	O
1	int
]	O
==	O
0	int
)	O
name	*(char)
=	O
g_strconcat	(*(char))->(*(char))
(	O
PATH_SEP_STR	*(char)
,	O
subname	*(char)
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
else	O
name	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
,	O
subname	*(char)
)	O
;	O
current	*(struct)
=	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_start	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
while	O
(	O
current	*(struct)
&&	O
(	O
flag	int
=	O
pathcmp	(*(char),*(char))->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
name	*(char)
)	O
)	O
<	O
0	int
)	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
flag	int
!=	O
0	int
)	O
{	O
current	*(struct)
=	O
tree_store_add_entry	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
name	*(char)
)	O
;	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
add_queue	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
g_list_prepend	(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),*(void))->(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
add_queue	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
g_strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
base	int
=	O
current	*(struct)
;	O
if	O
(	O
base	int
)	O
{	O
len	int
=	O
strlen	(*(char))->(long)
(	O
base	int
->	O
name	*(char)
)	O
;	O
base	int
->	O
mark	int
=	O
0	int
;	O
current	*(struct)
=	O
base	int
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
while	O
(	O
current	*(struct)
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
base	int
->	O
name	*(char)
,	O
len	int
)	O
==	O
0	int
&&	O
(	O
current	*(struct)
->	O
name	*(char)
[	O
len	int
]	O
==	O
'\0'	O
||	O
current	*(struct)
->	O
name	*(char)
[	O
len	int
]	O
==	O
PATH_SEP	char
||	O
len	int
==	O
1	int
)	O
)	O
{	O
current	*(struct)
->	O
mark	int
=	O
0	int
;	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
}	O
}	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
tree_store_start_check	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
const	O
char	O
*	O
path	*(char)
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
,	O
*	O
retval	*(void)
;	O
int	O
len	int
;	O
if	O
(	O
!	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
loaded	int
)	O
return	O
NULL	O
;	O
g_return_val_if_fail	O
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
==	O
NULL	O
,	O
NULL	O
)	O
;	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_start	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
NULL	O
;	O
current	*(struct)
=	O
tree_store_whereis	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
path	*(char)
)	O
;	O
if	O
(	O
!	O
current	*(struct)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
s	*(char)
;	O
if	O
(	O
mc_stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
path	*(char)
,	O
&	O
s	*(char)
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
S_ISDIR	O
(	O
s	*(char)
.	O
st_mode	int
)	O
)	O
return	O
NULL	O
;	O
current	*(struct)
=	O
tree_store_add_entry	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
path	*(char)
)	O
;	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
path	*(char)
)	O
;	O
return	O
current	*(struct)
;	O
}	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
path	*(char)
)	O
;	O
retval	*(void)
=	O
current	*(struct)
;	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_start	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
)	O
;	O
current	*(struct)
=	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_start	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
while	O
(	O
current	*(struct)
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
,	O
len	int
)	O
==	O
0	int
&&	O
(	O
current	*(struct)
->	O
name	*(char)
[	O
len	int
]	O
==	O
'\0'	O
||	O
current	*(struct)
->	O
name	*(char)
[	O
len	int
]	O
==	O
PATH_SEP	char
||	O
len	int
==	O
1	int
)	O
)	O
{	O
current	*(struct)
->	O
mark	int
=	O
1	int
;	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
return	O
retval	*(void)
;	O
}	O
void	O
tree_store_end_check	()->(void)
(	O
void	O
)	O
{	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
current	*(struct)
,	O
*	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
int	O
len	int
;	O
GList	struct
*	O
the_queue	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
,	O
*	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
if	O
(	O
!	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
loaded	int
)	O
return	O
;	O
g_return_if_fail	O
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
!=	O
NULL	O
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
)	O
;	O
current	*(struct)
=	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_start	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
while	O
(	O
current	*(struct)
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
current	*(struct)
->	O
name	*(char)
,	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
,	O
len	int
)	O
==	O
0	int
&&	O
(	O
current	*(struct)
->	O
name	*(char)
[	O
len	int
]	O
==	O
'\0'	O
||	O
current	*(struct)
->	O
name	*(char)
[	O
len	int
]	O
==	O
PATH_SEP	char
||	O
len	int
==	O
1	int
)	O
)	O
{	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
current	*(struct)
;	O
current	*(struct)
=	O
current	*(struct)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
mark	int
)	O
remove_entry	(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
old	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
}	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
add_queue	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
g_list_reverse	(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
add_queue	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
;	O
the_queue	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
add_queue	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
add_queue	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
g_free	(*(void))->(void)
(	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
)	O
;	O
ts	struct(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))),*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,int)
.	O
check_name	*(char)
=	O
NULL	O
;	O
for	O
(	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
the_queue	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
g_free	(*(void))->(void)
(	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
data	*(void)
)	O
;	O
}	O
g_list_free	(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))->(void)
(	O
the_queue	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
)	O
;	O
}	O
static	O
void	O
process_special_dirs	(*(*(struct(*(void),*(struct`),*(struct`)))),*(char))->(void)
(	O
GList	struct
*	O
*	O
special_dirs	*(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
,	O
char	O
*	O
file	*(char)
)	O
{	O
char	O
*	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
char	O
*	O
buffer	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
4096	int
)	O
;	O
char	O
*	O
s	*(char)
;	O
GetPrivateProfileString	(*(char),*(char),*(char),*(char),short,*(char))->(short)
(	O
"Special dirs"	*(char)
,	O
"list"	*(char)
,	O
""	*(char)
,	O
buffer	*(char)
,	O
4096	int
,	O
file	*(char)
)	O
;	O
s	*(char)
=	O
buffer	*(char)
;	O
while	O
(	O
(	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
s	*(char)
,	O
","	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
*	O
special_dirs	*(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
=	O
g_list_prepend	(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),*(void))->(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
*	O
special_dirs	*(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
,	O
g_strdup	(*(char))->(*(char))
(	O
token	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
s	*(char)
=	O
NULL	O
;	O
}	O
g_free	(*(void))->(void)
(	O
buffer	*(char)
)	O
;	O
}	O
static	O
gboolean	int
should_skip_directory	(*(char))->(int)
(	O
const	O
char	O
*	O
dir	*(struct)
)	O
{	O
static	O
GList	struct
*	O
special_dirs	*(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
GList	struct
*	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
static	O
int	O
loaded	int
;	O
if	O
(	O
loaded	int
==	O
0	int
)	O
{	O
loaded	int
=	O
1	int
;	O
setup_init	()->(*(char))
(	O
)	O
;	O
process_special_dirs	(*(*(struct(*(void),*(struct`),*(struct`)))),*(char))->(void)
(	O
&	O
special_dirs	*(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
,	O
profile_name	*(char)
)	O
;	O
process_special_dirs	(*(*(struct(*(void),*(struct`),*(struct`)))),*(char))->(void)
(	O
&	O
special_dirs	*(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
,	O
global_profile_name	*(char)
)	O
;	O
}	O
for	O
(	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
special_dirs	*(*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
;	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
=	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
dir	*(struct)
,	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
data	*(void)
,	O
strlen	(*(char))->(long)
(	O
l	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
->	O
data	*(void)
)	O
)	O
==	O
0	int
)	O
return	O
TRUE	O
;	O
}	O
return	O
FALSE	O
;	O
}	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
tree_store_rescan	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
const	O
char	O
*	O
dir	*(struct)
)	O
{	O
DIR	struct
*	O
dirp	*(struct)
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
dp	*(struct(long,long,short,char,array(char)))
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
buf	*(char)
;	O
tree_entry	struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))),*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))))))
*	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
if	O
(	O
should_skip_directory	(*(char))->(int)
(	O
dir	*(struct)
)	O
)	O
{	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
tree_store_add_entry	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
dir	*(struct)
)	O
;	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
scanned	int
=	O
1	int
;	O
return	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
}	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
=	O
tree_store_start_check	(*(char))->(*(struct(*(char),int,long,*(char),int,int,*(struct(*`,int,long,*`,int,int,*`,*`)),*(struct(*`,int,long,*`,int,int,*`,*`)))))
(	O
dir	*(struct)
)	O
;	O
if	O
(	O
!	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
)	O
return	O
NULL	O
;	O
dirp	*(struct)
=	O
mc_opendir	(*(char))->(*(struct))
(	O
dir	*(struct)
)	O
;	O
if	O
(	O
dirp	*(struct)
)	O
{	O
for	O
(	O
dp	*(struct(long,long,short,char,array(char)))
=	O
mc_readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dirp	*(struct)
)	O
;	O
dp	*(struct(long,long,short,char,array(char)))
;	O
dp	*(struct(long,long,short,char,array(char)))
=	O
mc_readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
dirp	*(struct)
)	O
)	O
{	O
char	O
*	O
full_name	*(char)
;	O
if	O
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
if	O
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
0	int
||	O
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
1	int
]	O
==	O
'.'	O
&&	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
2	int
]	O
==	O
0	int
)	O
)	O
continue	O
;	O
}	O
full_name	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
dir	*(struct)
,	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
if	O
(	O
mc_lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
full_name	*(char)
,	O
&	O
buf	*(char)
)	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
buf	*(char)
.	O
st_mode	int
)	O
)	O
tree_store_mark_checked	(*(char))->(void)
(	O
dp	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
}	O
g_free	(*(void))->(void)
(	O
full_name	*(char)
)	O
;	O
}	O
mc_closedir	(*(struct))->(int)
(	O
dirp	*(struct)
)	O
;	O
}	O
tree_store_end_check	()->(void)
(	O
)	O
;	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
->	O
scanned	int
=	O
1	int
;	O
return	O
entry	*(struct(*(char),int,long,*(char),int,int,*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`))),*(struct(*(char),int,long,*(char),int,int,*(struct`),*(struct`)))))
;	O
}	O
