const	O
char	O
*	O
progname	*(char)
=	O
"tek2plot"	*(char)
;	O
const	O
char	O
*	O
written	*(char)
=	O
"Written by Robert S. Maier."	*(char)
;	O
const	O
char	O
*	O
copyright	*(char)
=	O
"Copyright (C) 2009 Free Software Foundation, Inc."	*(char)
;	O
const	O
char	O
*	O
usage_appendage	*(char)
=	O
" [FILE]...\nWith no FILE, or when FILE is -, read standard input.\n"	*(char)
;	O
extern	O
int	O
Talptable	array(int)
[	O
]	O
;	O
extern	O
int	O
Tbestable	array(int)
[	O
]	O
;	O
extern	O
int	O
Tbyptable	array(int)
[	O
]	O
;	O
extern	O
int	O
Tesctable	array(int)
[	O
]	O
;	O
extern	O
int	O
Tipltable	array(int)
[	O
]	O
;	O
extern	O
int	O
Tplttable	array(int)
[	O
]	O
;	O
extern	O
int	O
Tpttable	array(int)
[	O
]	O
;	O
extern	O
int	O
Tspttable	array(int)
[	O
]	O
;	O
struct	O
Tek_Char	struct(int,int,int,int)
{	O
int	O
hsize	int
;	O
int	O
vsize	int
;	O
int	O
charsperline	int
;	O
int	O
nlines	int
;	O
}	O
;	O
static	O
const	O
struct	O
Tek_Char	struct(int,int,int,int)
TekChar	array(struct(int,int,int,int))
[	O
4	int
]	O
=	O
{	O
{	O
56	int
,	O
88	int
,	O
74	int
,	O
35	int
}	O
,	O
{	O
51	int
,	O
82	int
,	O
81	int
,	O
38	int
}	O
,	O
{	O
34	int
,	O
53	int
,	O
121	int
,	O
58	int
}	O
,	O
{	O
31	int
,	O
48	int
,	O
133	int
,	O
64	int
}	O
,	O
}	O
;	O
const	O
char	O
*	O
linemodes	array(*(char))
[	O
8	int
]	O
=	O
{	O
"solid"	*(char)
,	O
"dotted"	*(char)
,	O
"dotdashed"	*(char)
,	O
"shortdashed"	*(char)
,	O
"longdashed"	*(char)
,	O
"solid"	*(char)
,	O
"solid"	*(char)
,	O
"solid"	*(char)
}	O
;	O
enum	O
{	O
PENDOWN	int
,	O
PENUP	int
}	O
;	O
enum	O
{	O
NORTH	int
=	O
04	int
,	O
SOUTH	int
=	O
010	int
,	O
EAST	int
=	O
01	int
,	O
WEST	int
=	O
02	int
}	O
;	O
const	O
char	O
*	O
optstring	*(char)
=	O
"Op:F:W:T:"	*(char)
;	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"output-format"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'T'	O
}	O
,	O
{	O
"display-type"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'T'	O
<<	O
8	int
}	O
,	O
{	O
"bg-color"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'q'	O
<<	O
8	int
}	O
,	O
{	O
"bitmap-size"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'B'	O
<<	O
8	int
}	O
,	O
{	O
"emulate-color"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'e'	O
<<	O
8	int
}	O
,	O
{	O
"font-name"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
{	O
"line-width"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'W'	O
}	O
,	O
{	O
"pen-color"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'C'	O
<<	O
8	int
}	O
,	O
{	O
"max-line-length"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'M'	O
<<	O
8	int
}	O
,	O
{	O
"page-number"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"page-size"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'P'	O
<<	O
8	int
}	O
,	O
{	O
"position-chars"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'S'	O
<<	O
8	int
}	O
,	O
{	O
"rotation"	*(char)
,	O
ARG_REQUIRED	int
,	O
NULL	O
,	O
'r'	O
<<	O
8	int
}	O
,	O
{	O
"use-tek-fonts"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
't'	O
<<	O
8	int
}	O
,	O
{	O
"portable-output"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'O'	O
}	O
,	O
{	O
"help-fonts"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'f'	O
<<	O
8	int
}	O
,	O
{	O
"list-fonts"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'l'	O
<<	O
8	int
}	O
,	O
{	O
"version"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'V'	O
<<	O
8	int
}	O
,	O
{	O
"help"	*(char)
,	O
ARG_NONE	int
,	O
NULL	O
,	O
'h'	O
<<	O
8	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
const	O
int	O
hidden_options	array(int)
[	O
]	O
=	O
{	O
(	O
int	O
)	O
(	O
'T'	O
<<	O
8	int
)	O
,	O
0	int
}	O
;	O
typedef	O
struct	O
{	O
int	O
red	int
;	O
int	O
green	int
;	O
int	O
blue	int
;	O
}	O
Color	struct(int,int,int)
;	O
const	O
Color	struct(int,int,int)
ansi_color	array(struct(int,int,int))
[	O
16	int
]	O
=	O
{	O
{	O
0x0000	int
,	O
0x0000	int
,	O
0x0000	int
}	O
,	O
{	O
0x8b8b	int
,	O
0x0000	int
,	O
0x0000	int
}	O
,	O
{	O
0x0000	int
,	O
0x8b8b	int
,	O
0x0000	int
}	O
,	O
{	O
0x8b8b	int
,	O
0x8b8b	int
,	O
0x0000	int
}	O
,	O
{	O
0x0000	int
,	O
0x0000	int
,	O
0x8b8b	int
}	O
,	O
{	O
0x8b8b	int
,	O
0x0000	int
,	O
0x8b8b	int
}	O
,	O
{	O
0x0000	int
,	O
0x8b8b	int
,	O
0x8b8b	int
}	O
,	O
{	O
0x8b8b	int
,	O
0x8b8b	int
,	O
0x8b8b	int
}	O
,	O
{	O
0x4d4d	int
,	O
0x4d4d	int
,	O
0x4d4d	int
}	O
,	O
{	O
0xffff	int
,	O
0x0000	int
,	O
0x0000	int
}	O
,	O
{	O
0x0000	int
,	O
0xffff	int
,	O
0x0000	int
}	O
,	O
{	O
0xffff	int
,	O
0xffff	int
,	O
0x0000	int
}	O
,	O
{	O
0x0000	int
,	O
0x0000	int
,	O
0xffff	int
}	O
,	O
{	O
0xffff	int
,	O
0x0000	int
,	O
0xffff	int
}	O
,	O
{	O
0x0000	int
,	O
0xffff	int
,	O
0xffff	int
}	O
,	O
{	O
0xffff	int
,	O
0xffff	int
,	O
0xffff	int
}	O
}	O
;	O
bool	enum(int,int)
position_indiv_chars	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
single_page_is_requested	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
use_tek_fonts	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
force_hershey_default	enum(int,int)
=	O
false	int
;	O
char	O
*	O
font_name	*(char)
=	O
NULL	O
;	O
char	O
*	O
pen_color	*(char)
=	O
NULL	O
;	O
double	O
line_width	double
=	O
-	O
1.0	int
;	O
int	O
requested_page	int
=	O
0	int
;	O
bool	enum(int,int)
plotter_open	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
plotter_opened	enum(int,int)
=	O
false	int
;	O
int	O
cur_X	int
=	O
0	int
,	O
cur_Y	int
=	O
0	int
;	O
int	O
current_page	int
=	O
0	int
;	O
bool	enum(int,int)
getpoint	(*(int),*(int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int),*(int))->(enum(int,int))
(	O
int	O
*	O
xcoor	*(int)
,	O
int	O
*	O
ycoor	*(int)
,	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
*	O
badstatus	*(int)
,	O
int	O
*	O
margin	*(int)
)	O
;	O
bool	enum(int,int)
read_plot	(*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(enum(int,int))
(	O
plPlotter	struct
*	O
plotter	*(struct)
,	O
FILE	struct
*	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
int	O
read_byte	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(int)
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
*	O
badstatus	*(int)
)	O
;	O
void	O
begin_page	(*(struct))->(void)
(	O
plPlotter	struct
*	O
plotter	*(struct)
)	O
;	O
void	O
end_page	(*(struct))->(void)
(	O
plPlotter	struct
*	O
plotter	*(struct)
)	O
;	O
void	O
set_font_size	(*(struct),int)->(void)
(	O
plPlotter	struct
*	O
plotter	*(struct)
,	O
int	O
new_fontsize	int
)	O
;	O
void	O
unread_byte	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(void)
(	O
int	O
byte	int
,	O
FILE	struct
*	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
*	O
badstatus	*(int)
)	O
;	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
plPlotter	struct
*	O
plotter	*(struct)
;	O
plPlotterParams	struct
*	O
plotter_params	*(struct)
;	O
bool	enum(int,int)
do_list_fonts	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
show_fonts	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
show_usage	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
show_version	enum(int,int)
=	O
false	int
;	O
char	O
*	O
output_format	*(char)
=	O
(	O
char	O
*	O
)	O
"meta"	*(char)
;	O
double	O
local_line_width	double
;	O
int	O
errcnt	int
=	O
0	int
;	O
int	O
local_page_number	int
;	O
int	O
opt_index	int
;	O
int	O
option	struct(*(char),int,*(int),int)
;	O
int	O
retval	int
;	O
plotter_params	*(struct)
=	O
pl_newplparams	()->(*(struct))
(	O
)	O
;	O
while	O
(	O
(	O
option	struct(*(char),int,*(int),int)
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
optstring	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
&	O
opt_index	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
option	struct(*(char),int,*(int),int)
==	O
0	int
)	O
option	struct(*(char),int,*(int),int)
=	O
long_options	array(struct(*(char),int,*(int),int))
[	O
opt_index	int
]	O
.	O
val	int
;	O
switch	O
(	O
option	struct(*(char),int,*(int),int)
)	O
{	O
case	O
'T'	O
:	O
case	O
'T'	O
<<	O
8	int
:	O
output_format	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
output_format	*(char)
,	O
optarg	*(char)
)	O
;	O
if	O
(	O
strcasecmp	(*(char),*(char))->(int)
(	O
output_format	*(char)
,	O
"hpgl"	*(char)
)	O
==	O
0	int
)	O
force_hershey_default	enum(int,int)
=	O
true	int
;	O
else	O
force_hershey_default	enum(int,int)
=	O
false	int
;	O
break	O
;	O
case	O
'F'	O
:	O
font_name	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
font_name	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%d"	*(char)
,	O
&	O
local_page_number	int
)	O
<=	O
0	int
||	O
local_page_number	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the page number `%s' is bad (it should be a nonnegative integer)\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
}	O
else	O
{	O
requested_page	int
=	O
local_page_number	int
;	O
single_page_is_requested	enum(int,int)
=	O
true	int
;	O
}	O
break	O
;	O
case	O
'W'	O
:	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"%lf"	*(char)
,	O
&	O
local_line_width	double
)	O
<=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the line thickness `%s' is bad (it should be a number)\n"	*(char)
,	O
progname	*(char)
,	O
optarg	*(char)
)	O
;	O
errcnt	int
++	O
;	O
break	O
;	O
}	O
if	O
(	O
local_line_width	double
<	O
0.0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the request for a negative line thickness `%f' is disregarded\n"	*(char)
,	O
progname	*(char)
,	O
local_line_width	double
)	O
;	O
else	O
line_width	double
=	O
local_line_width	double
;	O
break	O
;	O
case	O
'O'	O
:	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"META_PORTABLE"	*(char)
,	O
(	O
void	O
*	O
)	O
"yes"	*(char)
)	O
;	O
break	O
;	O
case	O
'e'	O
<<	O
8	int
:	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"EMULATE_COLOR"	*(char)
,	O
(	O
void	O
*	O
)	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'q'	O
<<	O
8	int
:	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"BG_COLOR"	*(char)
,	O
(	O
void	O
*	O
)	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'B'	O
<<	O
8	int
:	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"BITMAPSIZE"	*(char)
,	O
(	O
void	O
*	O
)	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'C'	O
<<	O
8	int
:	O
pen_color	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
pen_color	*(char)
,	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'M'	O
<<	O
8	int
:	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"MAX_LINE_LENGTH"	*(char)
,	O
(	O
void	O
*	O
)	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'P'	O
<<	O
8	int
:	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"PAGESIZE"	*(char)
,	O
(	O
void	O
*	O
)	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'S'	O
<<	O
8	int
:	O
position_indiv_chars	enum(int,int)
=	O
true	int
;	O
break	O
;	O
case	O
'r'	O
<<	O
8	int
:	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"ROTATION"	*(char)
,	O
(	O
void	O
*	O
)	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
't'	O
<<	O
8	int
:	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
output_format	*(char)
,	O
"X"	*(char)
)	O
==	O
0	int
)	O
use_tek_fonts	enum(int,int)
=	O
true	int
;	O
break	O
;	O
case	O
'f'	O
<<	O
8	int
:	O
show_fonts	enum(int,int)
=	O
true	int
;	O
break	O
;	O
case	O
'l'	O
<<	O
8	int
:	O
do_list_fonts	enum(int,int)
=	O
true	int
;	O
break	O
;	O
case	O
'h'	O
<<	O
8	int
:	O
show_usage	enum(int,int)
=	O
true	int
;	O
break	O
;	O
case	O
'V'	O
<<	O
8	int
:	O
show_version	enum(int,int)
=	O
true	int
;	O
break	O
;	O
default	O
:	O
errcnt	int
++	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
errcnt	int
>	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Try `%s --help' for more information\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
show_version	enum(int,int)
)	O
{	O
display_version	(*(char),*(char),*(char))->(void)
(	O
progname	*(char)
,	O
written	*(char)
,	O
copyright	*(char)
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
if	O
(	O
do_list_fonts	enum(int,int)
)	O
{	O
int	O
success	int
;	O
success	int
=	O
list_fonts	(*(char),*(char))->(int)
(	O
output_format	*(char)
,	O
progname	*(char)
)	O
;	O
if	O
(	O
success	int
)	O
return	O
EXIT_SUCCESS	int
;	O
else	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
show_fonts	enum(int,int)
)	O
{	O
int	O
success	int
;	O
success	int
=	O
display_fonts	(*(char),*(char))->(int)
(	O
output_format	*(char)
,	O
progname	*(char)
)	O
;	O
if	O
(	O
success	int
)	O
return	O
EXIT_SUCCESS	int
;	O
else	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
show_usage	enum(int,int)
)	O
{	O
display_usage	(*(char),*(int),*(char),int)->(void)
(	O
progname	*(char)
,	O
hidden_options	array(int)
,	O
usage_appendage	*(char)
,	O
2	int
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
pl_setplparam	(*(struct),*(char),*(void))->(int)
(	O
plotter_params	*(struct)
,	O
"GIF_ANIMATION"	*(char)
,	O
(	O
void	O
*	O
)	O
"no"	*(char)
)	O
;	O
if	O
(	O
(	O
plotter	*(struct)
=	O
pl_newpl_r	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct))->(*(struct))
(	O
output_format	*(char)
,	O
NULL	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
plotter_params	*(struct)
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the plot device could not be created\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
retval	int
=	O
EXIT_SUCCESS	int
;	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
{	O
FILE	struct
*	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
{	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: %s: %s\n"	*(char)
,	O
progname	*(char)
,	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: this file is ignored.\n"	*(char)
,	O
progname	*(char)
)	O
;	O
errno	O
=	O
0	int
;	O
retval	int
=	O
EXIT_FAILURE	int
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
read_plot	(*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(enum(int,int))
(	O
plotter	*(struct)
,	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
false	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the input file `%s' could not be parsed\n"	*(char)
,	O
progname	*(char)
,	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
;	O
retval	int
=	O
EXIT_FAILURE	int
;	O
continue	O
;	O
}	O
if	O
(	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
data_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the input file `%s' could not be closed\n"	*(char)
,	O
progname	*(char)
,	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
read_plot	(*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(enum(int,int))
(	O
plotter	*(struct)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
false	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the input could not be parsed\n"	*(char)
,	O
progname	*(char)
)	O
;	O
retval	int
=	O
EXIT_FAILURE	int
;	O
}	O
}	O
if	O
(	O
plotter_opened	enum(int,int)
==	O
false	int
)	O
{	O
if	O
(	O
single_page_is_requested	enum(int,int)
==	O
false	int
)	O
{	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
end_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
requested_page	int
>=	O
current_page	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the requested page does not exist\n"	*(char)
,	O
progname	*(char)
)	O
;	O
retval	int
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
{	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
end_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
}	O
}	O
}	O
if	O
(	O
pl_deletepl_r	(*(struct))->(int)
(	O
plotter	*(struct)
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the plot device could not be deleted\n"	*(char)
,	O
progname	*(char)
)	O
;	O
retval	int
=	O
EXIT_FAILURE	int
;	O
}	O
pl_deleteplparams	(*(struct))->(int)
(	O
plotter_params	*(struct)
)	O
;	O
return	O
retval	int
;	O
}	O
void	O
unread_byte	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(void)
(	O
int	O
c	int
,	O
FILE	struct
*	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
*	O
badstatus	*(int)
)	O
{	O
if	O
(	O
*	O
badstatus	*(int)
==	O
0	int
)	O
{	O
if	O
(	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
c	int
,	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
*	O
badstatus	*(int)
=	O
2	int
;	O
}	O
}	O
int	O
read_byte	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(int)
(	O
FILE	struct
*	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
*	O
badstatus	*(int)
)	O
{	O
int	O
i	int
;	O
if	O
(	O
*	O
badstatus	*(int)
==	O
1	int
)	O
return	O
0	int
;	O
i	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
i	int
==	O
EOF	O
)	O
{	O
*	O
badstatus	*(int)
=	O
2	int
;	O
return	O
0	int
;	O
}	O
return	O
(	O
i	int
&	O
0x7f	int
)	O
;	O
}	O
bool	enum(int,int)
getpoint	(*(int),*(int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int),*(int))->(enum(int,int))
(	O
int	O
*	O
xcoor	*(int)
,	O
int	O
*	O
ycoor	*(int)
,	O
FILE	struct
*	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
*	O
badstatus	*(int)
,	O
int	O
*	O
margin	*(int)
)	O
{	O
int	O
status_one	int
=	O
0	int
,	O
status_three	int
=	O
0	int
;	O
bool	enum(int,int)
got_lo_y	enum(int,int)
=	O
false	int
;	O
bool	enum(int,int)
got_hi_x	enum(int,int)
=	O
false	int
,	O
got_hi_y	enum(int,int)
=	O
false	int
;	O
int	O
lo_x	int
=	O
0	int
,	O
lo_y	int
=	O
0	int
,	O
hi_x	int
=	O
0	int
,	O
hi_y	int
=	O
0	int
;	O
bool	enum(int,int)
got_egm	enum(int,int)
=	O
false	int
;	O
int	O
egm	int
=	O
0	int
;	O
int	O
temp_three	int
=	O
0	int
;	O
static	O
int	O
saved_lo_y	int
=	O
0	int
,	O
saved_hi_x	int
=	O
0	int
,	O
saved_hi_y	int
=	O
0	int
;	O
static	O
bool	enum(int,int)
margin_reset	enum(int,int)
=	O
false	int
;	O
int	O
byte_read	int
,	O
type	*(char)
;	O
if	O
(	O
*	O
badstatus	*(int)
)	O
return	O
false	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
byte_read	int
=	O
read_byte	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(int)
(	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
badstatus	*(int)
)	O
;	O
if	O
(	O
*	O
badstatus	*(int)
)	O
return	O
false	int
;	O
type	*(char)
=	O
(	O
byte_read	int
>>	O
5	int
)	O
&	O
TWO_BITS	O
;	O
byte_read	int
&=	O
FIVE_BITS	O
;	O
switch	O
(	O
type	*(char)
)	O
{	O
case	O
0	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: an incomplete point in the input is ignored\n"	*(char)
,	O
progname	*(char)
)	O
;	O
if	O
(	O
byte_read	int
==	O
'\n'	O
||	O
byte_read	int
==	O
'\r'	O
||	O
byte_read	int
==	O
'\0'	O
)	O
continue	O
;	O
else	O
unread_byte	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(void)
(	O
byte_read	int
,	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
badstatus	*(int)
)	O
;	O
return	O
false	int
;	O
case	O
1	int
:	O
switch	O
(	O
status_one	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
status_three	int
)	O
{	O
hi_x	int
=	O
byte_read	int
;	O
got_hi_x	enum(int,int)
=	O
true	int
;	O
if	O
(	O
status_three	int
==	O
1	int
)	O
{	O
lo_y	int
=	O
temp_three	int
;	O
got_lo_y	enum(int,int)
=	O
true	int
;	O
}	O
status_one	int
=	O
2	int
;	O
status_three	int
=	O
2	int
;	O
}	O
else	O
{	O
hi_y	int
=	O
byte_read	int
;	O
got_hi_y	enum(int,int)
=	O
true	int
;	O
status_one	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
status_three	int
==	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: a point in the input has Hi_Y, Hi_X bytes with no Lo_Y between\n"	*(char)
,	O
progname	*(char)
)	O
;	O
*	O
badstatus	*(int)
=	O
1	int
;	O
return	O
false	int
;	O
}	O
if	O
(	O
status_three	int
==	O
1	int
)	O
{	O
lo_y	int
=	O
temp_three	int
;	O
got_lo_y	enum(int,int)
=	O
true	int
;	O
}	O
hi_x	int
=	O
byte_read	int
;	O
got_hi_x	enum(int,int)
=	O
true	int
;	O
status_one	int
=	O
2	int
;	O
status_three	int
=	O
2	int
;	O
break	O
;	O
case	O
2	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: a point in the input contains too many Hi_Y/Hi_X bytes\n"	*(char)
,	O
progname	*(char)
)	O
;	O
*	O
badstatus	*(int)
=	O
1	int
;	O
return	O
false	int
;	O
}	O
break	O
;	O
case	O
3	int
:	O
switch	O
(	O
status_three	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
status_one	int
==	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: a point in the input has an EGM/Lo_Y byte after 2 Hi_X/Hi_Y bytes\n"	*(char)
,	O
progname	*(char)
)	O
;	O
*	O
badstatus	*(int)
=	O
1	int
;	O
return	O
false	int
;	O
}	O
else	O
{	O
temp_three	int
=	O
byte_read	int
;	O
status_three	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
status_one	int
==	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: a point in the input has an EGM/Lo_Y byte after 2 Hi_X/Hi_Y bytes\n"	*(char)
,	O
progname	*(char)
)	O
;	O
*	O
badstatus	*(int)
=	O
1	int
;	O
return	O
false	int
;	O
}	O
egm	int
=	O
temp_three	int
;	O
got_egm	enum(int,int)
=	O
true	int
;	O
lo_y	int
=	O
byte_read	int
;	O
got_lo_y	enum(int,int)
=	O
true	int
;	O
status_three	int
=	O
2	int
;	O
break	O
;	O
case	O
2	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: a point in the input has too many EGM/Lo_Y bytes\n"	*(char)
,	O
progname	*(char)
)	O
;	O
*	O
badstatus	*(int)
=	O
1	int
;	O
return	O
false	int
;	O
}	O
break	O
;	O
case	O
2	int
:	O
{	O
int	O
low_res_x	int
,	O
low_res_y	int
;	O
int	O
x	int
,	O
y	int
;	O
if	O
(	O
status_three	int
==	O
1	int
)	O
{	O
lo_y	int
=	O
temp_three	int
;	O
got_lo_y	enum(int,int)
=	O
true	int
;	O
}	O
lo_x	int
=	O
byte_read	int
;	O
lo_y	int
=	O
got_lo_y	enum(int,int)
?	O
lo_y	int
:	O
saved_lo_y	int
;	O
hi_x	int
=	O
got_hi_x	enum(int,int)
?	O
hi_x	int
:	O
saved_hi_x	int
;	O
hi_y	int
=	O
got_hi_y	enum(int,int)
?	O
hi_y	int
:	O
saved_hi_y	int
;	O
saved_lo_y	int
=	O
lo_y	int
;	O
saved_hi_x	int
=	O
hi_x	int
;	O
saved_hi_y	int
=	O
hi_y	int
;	O
if	O
(	O
(	O
egm	int
>>	O
4	int
)	O
&	O
ONE_BIT	O
)	O
{	O
*	O
margin	*(int)
=	O
MARGIN2	int
;	O
if	O
(	O
margin_reset	enum(int,int)
==	O
false	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: the left margin of the Tektronix was reset by the input\n"	*(char)
,	O
progname	*(char)
)	O
;	O
margin_reset	enum(int,int)
=	O
true	int
;	O
}	O
low_res_x	int
=	O
(	O
hi_x	int
<<	O
5	int
)	O
|	O
lo_x	int
;	O
low_res_y	int
=	O
(	O
hi_y	int
<<	O
5	int
)	O
|	O
lo_y	int
;	O
x	int
=	O
(	O
low_res_x	int
<<	O
2	int
)	O
|	O
(	O
egm	int
&	O
TWO_BITS	O
)	O
;	O
y	int
=	O
(	O
low_res_y	int
<<	O
2	int
)	O
|	O
(	O
(	O
egm	int
>>	O
2	int
)	O
&	O
TWO_BITS	O
)	O
;	O
*	O
xcoor	*(int)
=	O
x	int
;	O
*	O
ycoor	*(int)
=	O
y	int
;	O
return	O
true	int
;	O
}	O
}	O
}	O
}	O
bool	enum(int,int)
read_plot	(*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(enum(int,int))
(	O
plPlotter	struct
*	O
plotter	*(struct)
,	O
FILE	struct
*	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
int	O
*	O
Tparsestate	*(int)
=	O
Talptable	array(int)
;	O
int	O
*	O
curstate	*(int)
=	O
Talptable	array(int)
;	O
int	O
pen	int
=	O
PENUP	int
;	O
int	O
linetype	int
=	O
0	int
;	O
int	O
fontsize	int
=	O
0	int
;	O
int	O
margin	*(int)
=	O
MARGIN1	int
;	O
char	O
text	array(char)
[	O
TEXT_BUFFER_SIZE	int
]	O
;	O
int	O
badstatus	*(int)
=	O
0	int
;	O
while	O
(	O
!	O
badstatus	*(int)
)	O
{	O
int	O
c	int
;	O
int	O
x	int
,	O
y	int
;	O
c	int
=	O
read_byte	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(int)
(	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
)	O
;	O
if	O
(	O
badstatus	*(int)
)	O
break	O
;	O
switch	O
(	O
Tparsestate	*(int)
[	O
c	int
]	O
)	O
{	O
case	O
CASE_ALP_STATE	O
:	O
Tparsestate	*(int)
=	O
curstate	*(int)
=	O
Talptable	array(int)
;	O
break	O
;	O
case	O
CASE_PLT_STATE	O
:	O
Tparsestate	*(int)
=	O
curstate	*(int)
=	O
Tplttable	array(int)
;	O
c	int
=	O
read_byte	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(int)
(	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
)	O
;	O
if	O
(	O
c	int
==	O
BEL	int
)	O
pen	int
=	O
PENDOWN	int
;	O
else	O
{	O
pen	int
=	O
PENUP	int
;	O
unread_byte	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(void)
(	O
c	int
,	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
)	O
;	O
}	O
break	O
;	O
case	O
CASE_PT_STATE	O
:	O
Tparsestate	*(int)
=	O
curstate	*(int)
=	O
Tpttable	array(int)
;	O
break	O
;	O
case	O
CASE_SPT_STATE	O
:	O
Tparsestate	*(int)
=	O
curstate	*(int)
=	O
Tspttable	array(int)
;	O
break	O
;	O
case	O
CASE_IPL_STATE	O
:	O
Tparsestate	*(int)
=	O
curstate	*(int)
=	O
Tipltable	array(int)
;	O
break	O
;	O
case	O
CASE_PRINT	O
:	O
{	O
char	O
*	O
cp	*(char)
=	O
text	array(char)
;	O
int	O
x_here	int
,	O
y_here	int
,	O
n	int
;	O
x_here	int
=	O
cur_X	int
,	O
y_here	int
=	O
cur_Y	int
;	O
unread_byte	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(void)
(	O
c	int
,	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
)	O
;	O
if	O
(	O
badstatus	*(int)
)	O
break	O
;	O
n	int
=	O
(	O
position_indiv_chars	enum(int,int)
?	O
1	int
:	O
TEXT_BUFFER_SIZE	int
-	O
1	int
)	O
;	O
y	int
=	O
cur_Y	int
;	O
while	O
(	O
!	O
badstatus	*(int)
&&	O
n	int
--	O
>	O
0	int
&&	O
y	int
==	O
cur_Y	int
)	O
{	O
c	int
=	O
read_byte	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(int)
(	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
)	O
;	O
if	O
(	O
badstatus	*(int)
)	O
{	O
break	O
;	O
}	O
if	O
(	O
!	O
PRINTABLE_ASCII	O
(	O
c	int
)	O
)	O
{	O
unread_byte	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(void)
(	O
c	int
,	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
)	O
;	O
break	O
;	O
}	O
*	O
cp	*(char)
++	O
=	O
c	int
;	O
{	O
const	O
struct	O
Tek_Char	struct(int,int,int,int)
*	O
t	*(struct(int,int,int,int))
=	O
&	O
TekChar	array(struct(int,int,int,int))
[	O
fontsize	int
]	O
;	O
int	O
l	int
;	O
cur_X	int
+=	O
t	*(struct(int,int,int,int))
->	O
hsize	int
;	O
if	O
(	O
cur_X	int
>	O
TEK_WIDTH	int
)	O
{	O
l	int
=	O
cur_Y	int
/	O
t	*(struct(int,int,int,int))
->	O
vsize	int
-	O
1	int
;	O
if	O
(	O
l	int
<	O
0	int
)	O
{	O
margin	*(int)
=	O
!	O
margin	*(int)
;	O
l	int
=	O
t	*(struct(int,int,int,int))
->	O
nlines	int
-	O
1	int
;	O
}	O
cur_Y	int
=	O
l	int
*	O
t	*(struct(int,int,int,int))
->	O
vsize	int
;	O
cur_X	int
=	O
(	O
margin	*(int)
==	O
MARGIN1	int
?	O
0	int
:	O
TEK_WIDTH	int
/	O
2	int
)	O
;	O
}	O
}	O
}	O
*	O
cp	*(char)
=	O
'\0'	O
;	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum(int,int)
)	O
{	O
if	O
(	O
plotter_open	enum(int,int)
==	O
false	int
)	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
if	O
(	O
position_indiv_chars	enum(int,int)
)	O
{	O
int	O
halfwidth	int
=	O
TekChar	array(struct(int,int,int,int))
[	O
fontsize	int
]	O
.	O
hsize	int
/	O
2	int
;	O
pl_move_r	(*(struct),int,int)->(int)
(	O
plotter	*(struct)
,	O
x_here	int
+	O
halfwidth	int
,	O
y_here	int
+	O
YOFFSET	int
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
plotter	*(struct)
,	O
'c'	O
,	O
'b'	O
,	O
text	array(char)
)	O
;	O
}	O
else	O
{	O
pl_move_r	(*(struct),int,int)->(int)
(	O
plotter	*(struct)
,	O
x_here	int
,	O
y_here	int
+	O
YOFFSET	int
)	O
;	O
pl_alabel_r	(*(struct),int,int,*(char))->(int)
(	O
plotter	*(struct)
,	O
'l'	O
,	O
'b'	O
,	O
text	array(char)
)	O
;	O
}	O
pl_move_r	(*(struct),int,int)->(int)
(	O
plotter	*(struct)
,	O
cur_X	int
,	O
cur_Y	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
CASE_PLT_VEC	O
:	O
unread_byte	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(void)
(	O
c	int
,	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
)	O
;	O
if	O
(	O
getpoint	(*(int),*(int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int),*(int))->(enum(int,int))
(	O
&	O
x	int
,	O
&	O
y	int
,	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
,	O
&	O
margin	*(int)
)	O
&&	O
!	O
badstatus	*(int)
)	O
{	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum(int,int)
)	O
{	O
if	O
(	O
pen	int
==	O
PENDOWN	int
)	O
{	O
if	O
(	O
plotter_open	enum(int,int)
==	O
false	int
)	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
pl_cont_r	(*(struct),int,int)->(int)
(	O
plotter	*(struct)
,	O
x	int
,	O
y	int
+	O
YOFFSET	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
plotter_open	enum(int,int)
==	O
true	int
)	O
pl_move_r	(*(struct),int,int)->(int)
(	O
plotter	*(struct)
,	O
x	int
,	O
y	int
+	O
YOFFSET	int
)	O
;	O
}	O
}	O
cur_X	int
=	O
x	int
;	O
cur_Y	int
=	O
y	int
;	O
pen	int
=	O
PENDOWN	int
;	O
}	O
break	O
;	O
case	O
CASE_PT_POINT	O
:	O
unread_byte	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(void)
(	O
c	int
,	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
)	O
;	O
if	O
(	O
getpoint	(*(int),*(int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int),*(int))->(enum(int,int))
(	O
&	O
x	int
,	O
&	O
y	int
,	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
,	O
&	O
margin	*(int)
)	O
&&	O
!	O
badstatus	*(int)
)	O
{	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum(int,int)
)	O
{	O
if	O
(	O
plotter_open	enum(int,int)
==	O
false	int
)	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
pl_fmarker_r	(*(struct),double,double,int,double)->(int)
(	O
plotter	*(struct)
,	O
(	O
double	O
)	O
x	int
,	O
(	O
double	O
)	O
(	O
y	int
+	O
YOFFSET	int
)	O
,	O
M_DOT	int
,	O
(	O
double	O
)	O
DOT_SIZE	int
)	O
;	O
}	O
cur_X	int
=	O
x	int
;	O
cur_Y	int
=	O
y	int
;	O
}	O
break	O
;	O
case	O
CASE_SPT_POINT	O
:	O
if	O
(	O
getpoint	(*(int),*(int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int),*(int))->(enum(int,int))
(	O
&	O
x	int
,	O
&	O
y	int
,	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
,	O
&	O
margin	*(int)
)	O
&&	O
!	O
badstatus	*(int)
)	O
{	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum(int,int)
)	O
{	O
if	O
(	O
plotter_open	enum(int,int)
==	O
false	int
)	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
pl_fmarker_r	(*(struct),double,double,int,double)->(int)
(	O
plotter	*(struct)
,	O
(	O
double	O
)	O
x	int
,	O
(	O
double	O
)	O
(	O
y	int
+	O
YOFFSET	int
)	O
,	O
M_DOT	int
,	O
(	O
double	O
)	O
(	O
DOT_SIZE	int
)	O
)	O
;	O
}	O
cur_X	int
=	O
x	int
;	O
cur_Y	int
=	O
y	int
;	O
}	O
break	O
;	O
case	O
CASE_PENUP	O
:	O
pen	int
=	O
PENUP	int
;	O
break	O
;	O
case	O
CASE_PENDOWN	O
:	O
pen	int
=	O
PENDOWN	int
;	O
break	O
;	O
case	O
CASE_IPL_POINT	O
:	O
x	int
=	O
cur_X	int
;	O
y	int
=	O
cur_Y	int
;	O
if	O
(	O
c	int
&	O
NORTH	int
)	O
y	int
++	O
;	O
else	O
if	O
(	O
c	int
&	O
SOUTH	int
)	O
y	int
--	O
;	O
if	O
(	O
c	int
&	O
EAST	int
)	O
x	int
++	O
;	O
else	O
if	O
(	O
c	int
&	O
WEST	int
)	O
x	int
--	O
;	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum(int,int)
)	O
{	O
if	O
(	O
pen	int
==	O
PENDOWN	int
)	O
{	O
if	O
(	O
plotter_open	enum(int,int)
==	O
false	int
)	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
pl_cont_r	(*(struct),int,int)->(int)
(	O
plotter	*(struct)
,	O
x	int
,	O
y	int
+	O
YOFFSET	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
plotter_open	enum(int,int)
==	O
true	int
)	O
pl_move_r	(*(struct),int,int)->(int)
(	O
plotter	*(struct)
,	O
x	int
,	O
y	int
+	O
YOFFSET	int
)	O
;	O
}	O
}	O
cur_X	int
=	O
x	int
;	O
cur_Y	int
=	O
y	int
;	O
break	O
;	O
case	O
CASE_BES_STATE	O
:	O
Tparsestate	*(int)
=	O
Tbestable	array(int)
;	O
break	O
;	O
case	O
CASE_BYP_STATE	O
:	O
Tparsestate	*(int)
=	O
Tbyptable	array(int)
;	O
break	O
;	O
case	O
CASE_ESC_STATE	O
:	O
Tparsestate	*(int)
=	O
Tesctable	array(int)
;	O
break	O
;	O
case	O
CASE_CR	O
:	O
cur_X	int
=	O
(	O
margin	*(int)
==	O
MARGIN1	int
?	O
0	int
:	O
TEK_WIDTH	int
/	O
2	int
)	O
;	O
Tparsestate	*(int)
=	O
curstate	*(int)
=	O
Talptable	array(int)
;	O
break	O
;	O
case	O
CASE_BS	O
:	O
Tparsestate	*(int)
=	O
curstate	*(int)
;	O
{	O
const	O
struct	O
Tek_Char	struct(int,int,int,int)
*	O
t	*(struct(int,int,int,int))
;	O
int	O
x	int
,	O
l	int
;	O
x	int
=	O
(	O
cur_X	int
-=	O
(	O
t	*(struct(int,int,int,int))
=	O
&	O
TekChar	array(struct(int,int,int,int))
[	O
fontsize	int
]	O
)	O
->	O
hsize	int
)	O
;	O
if	O
(	O
(	O
margin	*(int)
==	O
MARGIN1	int
&&	O
x	int
<	O
0	int
)	O
||	O
(	O
margin	*(int)
==	O
MARGIN2	int
&&	O
x	int
<	O
TEK_WIDTH	int
/	O
2	int
)	O
)	O
{	O
if	O
(	O
(	O
l	int
=	O
(	O
cur_Y	int
+	O
(	O
t	*(struct(int,int,int,int))
->	O
vsize	int
-	O
1	int
)	O
)	O
/	O
t	*(struct(int,int,int,int))
->	O
vsize	int
+	O
1	int
)	O
>=	O
t	*(struct(int,int,int,int))
->	O
nlines	int
)	O
{	O
margin	*(int)
=	O
!	O
margin	*(int)
;	O
l	int
=	O
0	int
;	O
}	O
cur_Y	int
=	O
l	int
*	O
t	*(struct(int,int,int,int))
->	O
vsize	int
;	O
cur_X	int
=	O
(	O
t	*(struct(int,int,int,int))
->	O
charsperline	int
-	O
1	int
)	O
*	O
t	*(struct(int,int,int,int))
->	O
hsize	int
;	O
}	O
}	O
break	O
;	O
case	O
CASE_TAB	O
:	O
Tparsestate	*(int)
=	O
curstate	*(int)
;	O
case	O
CASE_SP	O
:	O
{	O
const	O
struct	O
Tek_Char	struct(int,int,int,int)
*	O
t	*(struct(int,int,int,int))
=	O
&	O
TekChar	array(struct(int,int,int,int))
[	O
fontsize	int
]	O
;	O
int	O
l	int
;	O
cur_X	int
+=	O
t	*(struct(int,int,int,int))
->	O
hsize	int
;	O
if	O
(	O
cur_X	int
>	O
TEK_WIDTH	int
)	O
{	O
l	int
=	O
cur_Y	int
/	O
t	*(struct(int,int,int,int))
->	O
vsize	int
-	O
1	int
;	O
if	O
(	O
l	int
<	O
0	int
)	O
{	O
margin	*(int)
=	O
!	O
margin	*(int)
;	O
l	int
=	O
t	*(struct(int,int,int,int))
->	O
nlines	int
-	O
1	int
;	O
}	O
cur_Y	int
=	O
l	int
*	O
t	*(struct(int,int,int,int))
->	O
vsize	int
;	O
cur_X	int
=	O
(	O
margin	*(int)
==	O
MARGIN1	int
?	O
0	int
:	O
TEK_WIDTH	int
/	O
2	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
CASE_LF	O
:	O
{	O
const	O
struct	O
Tek_Char	struct(int,int,int,int)
*	O
t	*(struct(int,int,int,int))
;	O
int	O
l	int
;	O
t	*(struct(int,int,int,int))
=	O
&	O
TekChar	array(struct(int,int,int,int))
[	O
fontsize	int
]	O
;	O
if	O
(	O
(	O
l	int
=	O
cur_Y	int
/	O
t	*(struct(int,int,int,int))
->	O
vsize	int
-	O
1	int
)	O
<	O
0	int
)	O
{	O
l	int
=	O
t	*(struct(int,int,int,int))
->	O
nlines	int
-	O
1	int
;	O
if	O
(	O
(	O
margin	*(int)
=	O
!	O
margin	*(int)
)	O
!=	O
MARGIN1	int
)	O
{	O
if	O
(	O
cur_X	int
<	O
TEK_WIDTH	int
/	O
2	int
)	O
cur_X	int
+=	O
TEK_WIDTH	int
/	O
2	int
;	O
}	O
else	O
if	O
(	O
cur_X	int
>=	O
TEK_WIDTH	int
/	O
2	int
)	O
cur_X	int
-=	O
TEK_WIDTH	int
/	O
2	int
;	O
}	O
cur_Y	int
=	O
l	int
*	O
t	*(struct(int,int,int,int))
->	O
vsize	int
;	O
}	O
break	O
;	O
case	O
CASE_UP	O
:	O
Tparsestate	*(int)
=	O
curstate	*(int)
;	O
{	O
const	O
struct	O
Tek_Char	struct(int,int,int,int)
*	O
t	*(struct(int,int,int,int))
;	O
int	O
l	int
;	O
t	*(struct(int,int,int,int))
=	O
&	O
TekChar	array(struct(int,int,int,int))
[	O
fontsize	int
]	O
;	O
if	O
(	O
(	O
l	int
=	O
(	O
cur_Y	int
+	O
(	O
t	*(struct(int,int,int,int))
->	O
vsize	int
-	O
1	int
)	O
)	O
/	O
t	*(struct(int,int,int,int))
->	O
vsize	int
+	O
1	int
)	O
>=	O
t	*(struct(int,int,int,int))
->	O
nlines	int
)	O
{	O
l	int
=	O
0	int
;	O
if	O
(	O
(	O
margin	*(int)
=	O
!	O
margin	*(int)
)	O
!=	O
MARGIN1	int
)	O
{	O
if	O
(	O
cur_X	int
<	O
TEK_WIDTH	int
/	O
2	int
)	O
cur_X	int
+=	O
TEK_WIDTH	int
/	O
2	int
;	O
}	O
else	O
if	O
(	O
cur_X	int
>=	O
TEK_WIDTH	int
/	O
2	int
)	O
cur_X	int
-=	O
TEK_WIDTH	int
/	O
2	int
;	O
}	O
cur_Y	int
=	O
l	int
*	O
t	*(struct(int,int,int,int))
->	O
vsize	int
;	O
}	O
break	O
;	O
case	O
CASE_PAGE	O
:	O
if	O
(	O
plotter_open	enum(int,int)
==	O
true	int
)	O
end_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
if	O
(	O
single_page_is_requested	enum(int,int)
&&	O
current_page	int
==	O
requested_page	int
)	O
{	O
badstatus	*(int)
=	O
2	int
;	O
break	O
;	O
}	O
current_page	int
++	O
;	O
if	O
(	O
single_page_is_requested	enum(int,int)
&&	O
current_page	int
==	O
requested_page	int
)	O
{	O
if	O
(	O
linetype	int
!=	O
0	int
)	O
{	O
if	O
(	O
plotter_open	enum(int,int)
==	O
false	int
)	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
linemodes	array(*(char))
[	O
linetype	int
]	O
)	O
;	O
}	O
if	O
(	O
fontsize	int
!=	O
0	int
)	O
{	O
if	O
(	O
plotter_open	enum(int,int)
==	O
false	int
)	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
set_font_size	(*(struct),int)->(void)
(	O
plotter	*(struct)
,	O
fontsize	int
)	O
;	O
}	O
}	O
cur_X	int
=	O
0	int
;	O
cur_Y	int
=	O
TEKHOME	O
;	O
break	O
;	O
case	O
CASE_CHAR_SIZE	O
:	O
fontsize	int
=	O
c	int
&	O
03	int
;	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum(int,int)
)	O
{	O
if	O
(	O
plotter_open	enum(int,int)
==	O
false	int
)	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
set_font_size	(*(struct),int)->(void)
(	O
plotter	*(struct)
,	O
fontsize	int
)	O
;	O
}	O
Tparsestate	*(int)
=	O
curstate	*(int)
;	O
break	O
;	O
case	O
CASE_BEAM_VEC	O
:	O
c	int
&=	O
07	int
;	O
if	O
(	O
c	int
!=	O
linetype	int
)	O
if	O
(	O
current_page	int
==	O
requested_page	int
||	O
!	O
single_page_is_requested	enum(int,int)
)	O
{	O
if	O
(	O
plotter_open	enum(int,int)
==	O
false	int
)	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
linetype	int
=	O
c	int
;	O
pl_linemod_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
linemodes	array(*(char))
[	O
linetype	int
]	O
)	O
;	O
}	O
Tparsestate	*(int)
=	O
curstate	*(int)
;	O
break	O
;	O
case	O
CASE_OSC	O
:	O
do	O
c	int
=	O
read_byte	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(int)
(	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
)	O
;	O
while	O
(	O
!	O
badstatus	*(int)
&&	O
PRINTABLE_ASCII	O
(	O
c	int
)	O
)	O
;	O
Tparsestate	*(int)
=	O
curstate	*(int)
;	O
break	O
;	O
case	O
CASE_ANSI	O
:	O
{	O
char	O
ansi	array(char)
[	O
BUFFER_SIZE	int
]	O
;	O
char	O
type	*(char)
=	O
0	int
;	O
int	O
i	int
;	O
i	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
read_byte	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(int))->(int)
(	O
in_stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
&	O
badstatus	*(int)
)	O
;	O
if	O
(	O
badstatus	*(int)
)	O
break	O
;	O
if	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
c	int
==	O
';'	O
||	O
(	O
i	int
==	O
0	int
&&	O
c	int
==	O
'?'	O
)	O
)	O
ansi	array(char)
[	O
i	int
++	O
]	O
=	O
c	int
;	O
else	O
{	O
type	*(char)
=	O
c	int
;	O
if	O
(	O
!	O
(	O
PRINTABLE_ASCII	O
(	O
type	*(char)
)	O
)	O
)	O
badstatus	*(int)
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
BUFFER_SIZE	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: an overly long ANSI escape sequence was encountered\n"	*(char)
,	O
progname	*(char)
)	O
;	O
badstatus	*(int)
=	O
1	int
;	O
break	O
;	O
}	O
}	O
Tparsestate	*(int)
=	O
curstate	*(int)
;	O
if	O
(	O
badstatus	*(int)
)	O
break	O
;	O
if	O
(	O
i	int
==	O
3	int
&&	O
(	O
type	*(char)
==	O
'h'	O
||	O
type	*(char)
==	O
'l'	O
)	O
&&	O
(	O
ansi	array(char)
[	O
0	int
]	O
==	O
'?'	O
&&	O
ansi	array(char)
[	O
1	int
]	O
==	O
'3'	O
&&	O
ansi	array(char)
[	O
2	int
]	O
==	O
'8'	O
)	O
)	O
break	O
;	O
if	O
(	O
i	int
==	O
4	int
&&	O
type	*(char)
==	O
'm'	O
&&	O
(	O
ansi	array(char)
[	O
0	int
]	O
==	O
'0'	O
||	O
ansi	array(char)
[	O
0	int
]	O
==	O
'1'	O
)	O
&&	O
ansi	array(char)
[	O
1	int
]	O
==	O
';'	O
&&	O
ansi	array(char)
[	O
2	int
]	O
==	O
'3'	O
&&	O
ansi	array(char)
[	O
3	int
]	O
>=	O
'0'	O
&&	O
ansi	array(char)
[	O
3	int
]	O
<=	O
'7'	O
)	O
{	O
int	O
intensity	int
,	O
color_index	int
;	O
if	O
(	O
plotter_open	enum(int,int)
==	O
false	int
)	O
begin_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
intensity	int
=	O
ansi	array(char)
[	O
0	int
]	O
-	O
'0'	O
;	O
color_index	int
=	O
ansi	array(char)
[	O
3	int
]	O
-	O
'0'	O
;	O
pl_pencolor_r	(*(struct),int,int,int)->(int)
(	O
plotter	*(struct)
,	O
ansi_color	array(struct(int,int,int))
[	O
8	int
*	O
intensity	int
+	O
color_index	int
]	O
.	O
red	int
,	O
ansi_color	array(struct(int,int,int))
[	O
8	int
*	O
intensity	int
+	O
color_index	int
]	O
.	O
green	int
,	O
ansi_color	array(struct(int,int,int))
[	O
8	int
*	O
intensity	int
+	O
color_index	int
]	O
.	O
blue	int
)	O
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
CASE_IGNORE	O
:	O
break	O
;	O
case	O
CASE_REPORT	int
:	O
case	O
CASE_VT_MODE	O
:	O
case	O
CASE_BEL	O
:	O
case	O
CASE_COPY	O
:	O
case	O
CASE_CURSTATE	O
:	O
Tparsestate	*(int)
=	O
curstate	*(int)
;	O
break	O
;	O
case	O
CASE_ASCII	O
:	O
Tparsestate	*(int)
=	O
curstate	*(int)
;	O
break	O
;	O
case	O
CASE_APL	O
:	O
Tparsestate	*(int)
=	O
curstate	*(int)
;	O
break	O
;	O
case	O
CASE_GIN	O
:	O
Tparsestate	*(int)
=	O
Tbyptable	array(int)
;	O
break	O
;	O
}	O
}	O
if	O
(	O
plotter_open	enum(int,int)
==	O
true	int
)	O
end_page	(*(struct))->(void)
(	O
plotter	*(struct)
)	O
;	O
current_page	int
++	O
;	O
return	O
(	O
badstatus	*(int)
==	O
2	int
?	O
true	int
:	O
false	int
)	O
;	O
}	O
void	O
set_font_size	(*(struct),int)->(void)
(	O
plPlotter	struct
*	O
plotter	*(struct)
,	O
int	O
new_fontsize	int
)	O
{	O
if	O
(	O
use_tek_fonts	enum(int,int)
)	O
{	O
switch	O
(	O
new_fontsize	int
)	O
{	O
case	O
0	int
:	O
default	O
:	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
"tekfont0"	*(char)
)	O
;	O
break	O
;	O
case	O
1	int
:	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
"tekfont1"	*(char)
)	O
;	O
break	O
;	O
case	O
2	int
:	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
"tekfont2"	*(char)
)	O
;	O
break	O
;	O
case	O
3	int
:	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
"tekfont3"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
else	O
pl_ffontsize_r	(*(struct),double)->(double)
(	O
plotter	*(struct)
,	O
(	O
double	O
)	O
(	O
TekChar	array(struct(int,int,int,int))
[	O
new_fontsize	int
]	O
.	O
hsize	int
)	O
/	O
CHAR_WIDTH	int
)	O
;	O
}	O
void	O
begin_page	(*(struct))->(void)
(	O
plPlotter	struct
*	O
plotter	*(struct)
)	O
{	O
if	O
(	O
pl_openpl_r	(*(struct))->(int)
(	O
plotter	*(struct)
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the plot device could not be opened\n"	*(char)
,	O
progname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
plotter_open	enum(int,int)
=	O
true	int
;	O
plotter_opened	enum(int,int)
=	O
true	int
;	O
pl_erase_r	(*(struct))->(int)
(	O
plotter	*(struct)
)	O
;	O
pl_space_r	(*(struct),int,int,int,int)->(int)
(	O
plotter	*(struct)
,	O
0	int
,	O
0	int
,	O
TEK_WIDTH	int
-	O
1	int
,	O
TEK_WIDTH	int
-	O
1	int
)	O
;	O
pl_joinmod_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
"round"	*(char)
)	O
;	O
pl_capmod_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
"round"	*(char)
)	O
;	O
if	O
(	O
pen_color	*(char)
)	O
pl_pencolorname_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
pen_color	*(char)
)	O
;	O
if	O
(	O
use_tek_fonts	enum(int,int)
)	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
"tekfont0"	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
font_name	*(char)
)	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
font_name	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
!	O
force_hershey_default	enum(int,int)
)	O
{	O
if	O
(	O
pl_havecap_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
"PS_FONTS"	*(char)
)	O
==	O
1	int
)	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
DEFAULT_PS_FONT_NAME	*(char)
)	O
;	O
else	O
if	O
(	O
pl_havecap_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
"PCL_FONTS"	*(char)
)	O
==	O
1	int
)	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
DEFAULT_PCL_FONT_NAME	*(char)
)	O
;	O
else	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
DEFAULT_HERSHEY_FONT_NAME	*(char)
)	O
;	O
}	O
else	O
pl_fontname_r	(*(struct),*(char))->(int)
(	O
plotter	*(struct)
,	O
DEFAULT_HERSHEY_FONT_NAME	*(char)
)	O
;	O
}	O
pl_ffontsize_r	(*(struct),double)->(double)
(	O
plotter	*(struct)
,	O
(	O
double	O
)	O
(	O
TekChar	array(struct(int,int,int,int))
[	O
0	int
]	O
.	O
hsize	int
)	O
/	O
CHAR_WIDTH	int
)	O
;	O
}	O
if	O
(	O
line_width	double
>=	O
0.0	int
)	O
pl_flinewidth_r	(*(struct),double)->(int)
(	O
plotter	*(struct)
,	O
line_width	double
*	O
TEK_WIDTH	int
)	O
;	O
pl_move_r	(*(struct),int,int)->(int)
(	O
plotter	*(struct)
,	O
cur_X	int
,	O
cur_Y	int
+	O
YOFFSET	int
)	O
;	O
}	O
void	O
end_page	(*(struct))->(void)
(	O
plPlotter	struct
*	O
plotter	*(struct)
)	O
{	O
if	O
(	O
pl_closepl_r	(*(struct))->(int)
(	O
plotter	*(struct)
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: error: the plot device could not be closed\n"	*(char)
,	O
progname	*(char)
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
plotter_open	enum(int,int)
=	O
false	int
;	O
}	O
