struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
{	O
void	O
*	O
data	*(void)
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
;	O
struct	O
hash_table	struct(*(struct(*(void),*(struct(*(void),*(struct`))))),*(struct(*(void),*(struct(*(void),*(struct`))))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct(*(void),*(struct`))))))
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
size_t	long
n_buckets	long
;	O
size_t	long
n_buckets_used	long
;	O
size_t	long
n_entries	long
;	O
const	O
Hash_tuning	struct(float,float,float,float,bool)
*	O
tuning	*(struct(float,float,float,float,bool))
;	O
Hash_hasher	*((*(void),long)->(long))
hasher	*((*(void),long)->(long))
;	O
Hash_comparator	*((*(void),*(void))->(bool))
comparator	*((*(void),*(void))->(bool))
;	O
Hash_data_freer	*((*(void))->(void))
data_freer	*((*(void))->(void))
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
;	O
static	O
const	O
Hash_tuning	struct(float,float,float,float,bool)
default_tuning	struct(float,float,float,float,bool)
=	O
{	O
DEFAULT_SHRINK_THRESHOLD	int
,	O
DEFAULT_SHRINK_FACTOR	int
,	O
DEFAULT_GROWTH_THRESHOLD	int
,	O
DEFAULT_GROWTH_FACTOR	int
,	O
false	int
}	O
;	O
size_t	long
hash_get_n_buckets	(*(struct))->(long)
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
)	O
{	O
return	O
table	*(struct)
->	O
n_buckets	long
;	O
}	O
size_t	long
hash_get_n_buckets_used	(*(struct))->(long)
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
)	O
{	O
return	O
table	*(struct)
->	O
n_buckets_used	long
;	O
}	O
size_t	long
hash_get_n_entries	(*(struct))->(long)
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
)	O
{	O
return	O
table	*(struct)
->	O
n_entries	long
;	O
}	O
size_t	long
hash_get_max_bucket_length	(*(struct))->(long)
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
size_t	long
max_bucket_length	long
=	O
0	int
;	O
for	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
<	O
table	*(struct)
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
++	O
)	O
{	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
size_t	long
bucket_length	long
=	O
1	int
;	O
while	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
,	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
bucket_length	long
++	O
;	O
if	O
(	O
bucket_length	long
>	O
max_bucket_length	long
)	O
max_bucket_length	long
=	O
bucket_length	long
;	O
}	O
}	O
return	O
max_bucket_length	long
;	O
}	O
bool	bool
hash_table_ok	(*(struct))->(bool)
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
size_t	long
n_buckets_used	long
=	O
0	int
;	O
size_t	long
n_entries	long
=	O
0	int
;	O
for	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
<	O
table	*(struct)
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
++	O
)	O
{	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
n_buckets_used	long
++	O
;	O
n_entries	long
++	O
;	O
while	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
,	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
n_entries	long
++	O
;	O
}	O
}	O
if	O
(	O
n_buckets_used	long
==	O
table	*(struct)
->	O
n_buckets_used	long
&&	O
n_entries	long
==	O
table	*(struct)
->	O
n_entries	long
)	O
return	O
true	int
;	O
return	O
false	int
;	O
}	O
void	O
hash_print_statistics	(*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
,	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
size_t	long
n_entries	long
=	O
hash_get_n_entries	(*(struct))->(long)
(	O
table	*(struct)
)	O
;	O
size_t	long
n_buckets	long
=	O
hash_get_n_buckets	(*(struct))->(long)
(	O
table	*(struct)
)	O
;	O
size_t	long
n_buckets_used	long
=	O
hash_get_n_buckets_used	(*(struct))->(long)
(	O
table	*(struct)
)	O
;	O
size_t	long
max_bucket_length	long
=	O
hash_get_max_bucket_length	(*(struct))->(long)
(	O
table	*(struct)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"# entries:         %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
n_entries	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"# buckets:         %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
n_buckets	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"# buckets used:    %lu (%.2f%%)\n"	*(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
n_buckets_used	long
,	O
(	O
100.0	int
*	O
n_buckets_used	long
)	O
/	O
n_buckets	long
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"max bucket length: %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
int	O
)	O
max_bucket_length	long
)	O
;	O
}	O
static	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
safe_hasher	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(void))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
,	O
const	O
void	O
*	O
key	*(void)
)	O
{	O
size_t	long
n	int
=	O
table	*(struct)
->	O
hasher	*((*(void),long)->(long))
(	O
key	*(void)
,	O
table	*(struct)
->	O
n_buckets	long
)	O
;	O
if	O
(	O
!	O
(	O
n	int
<	O
table	*(struct)
->	O
n_buckets	long
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
return	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
+	O
n	int
;	O
}	O
void	O
*	O
hash_lookup	(*(struct),*(void))->(*(void))
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
,	O
const	O
void	O
*	O
entry	*(void)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
safe_hasher	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(void))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
table	*(struct)
,	O
entry	*(void)
)	O
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
if	O
(	O
entry	*(void)
==	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
||	O
table	*(struct)
->	O
comparator	*((*(void),*(void))->(bool))
(	O
entry	*(void)
,	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
)	O
return	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
;	O
return	O
NULL	O
;	O
}	O
void	O
*	O
hash_get_first	(*(struct))->(*(void))
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
if	O
(	O
table	*(struct)
->	O
n_entries	long
==	O
0	int
)	O
return	O
NULL	O
;	O
for	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
++	O
)	O
if	O
(	O
!	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
<	O
table	*(struct)
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
else	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
return	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
;	O
}	O
void	O
*	O
hash_get_next	(*(struct),*(void))->(*(void))
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
,	O
const	O
void	O
*	O
entry	*(void)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
safe_hasher	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(void))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
table	*(struct)
,	O
entry	*(void)
)	O
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
do	O
{	O
if	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
==	O
entry	*(void)
&&	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
return	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
while	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
!=	O
NULL	O
)	O
;	O
while	O
(	O
++	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
<	O
table	*(struct)
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
return	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
;	O
return	O
NULL	O
;	O
}	O
size_t	long
hash_get_entries	(*(struct),*(*(void)),long)->(long)
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
,	O
void	O
*	O
*	O
buffer	*(*(void))
,	O
size_t	long
buffer_size	long
)	O
{	O
size_t	long
counter	long
=	O
0	int
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
for	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
<	O
table	*(struct)
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
++	O
)	O
{	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
{	O
for	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
if	O
(	O
counter	long
>=	O
buffer_size	long
)	O
return	O
counter	long
;	O
buffer	*(*(void))
[	O
counter	long
++	O
]	O
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
;	O
}	O
}	O
}	O
return	O
counter	long
;	O
}	O
size_t	long
hash_do_for_each	(*(struct),*((*(void),*(void))->(bool)),*(void))->(long)
(	O
const	O
Hash_table	struct
*	O
table	*(struct)
,	O
Hash_processor	*((*(void),*(void))->(bool))
processor	*((*(void),*(void))->(bool))
,	O
void	O
*	O
processor_data	*(void)
)	O
{	O
size_t	long
counter	long
=	O
0	int
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
const	O
*	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
for	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
<	O
table	*(struct)
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
++	O
)	O
{	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
{	O
for	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
if	O
(	O
!	O
processor	*((*(void),*(void))->(bool))
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
,	O
processor_data	*(void)
)	O
)	O
return	O
counter	long
;	O
counter	long
++	O
;	O
}	O
}	O
}	O
return	O
counter	long
;	O
}	O
size_t	long
hash_string	(*(char),long)->(long)
(	O
const	O
char	O
*	O
string	*(char)
,	O
size_t	long
n_buckets	long
)	O
{	O
size_t	long
value	long
=	O
0	int
;	O
unsigned	O
char	O
ch	char
;	O
for	O
(	O
;	O
(	O
ch	char
=	O
*	O
string	*(char)
)	O
;	O
string	*(char)
++	O
)	O
value	long
=	O
(	O
value	long
*	O
31	int
+	O
ch	char
)	O
%	O
n_buckets	long
;	O
return	O
value	long
;	O
}	O
static	O
bool	bool
_GL_ATTRIBUTE_CONST	O
is_prime	(long)->(bool)
(	O
size_t	long
candidate	long
)	O
{	O
size_t	long
divisor	long
=	O
3	int
;	O
size_t	long
square	long
=	O
divisor	long
*	O
divisor	long
;	O
while	O
(	O
square	long
<	O
candidate	long
&&	O
(	O
candidate	long
%	O
divisor	long
)	O
)	O
{	O
divisor	long
++	O
;	O
square	long
+=	O
4	int
*	O
divisor	long
;	O
divisor	long
++	O
;	O
}	O
return	O
(	O
candidate	long
%	O
divisor	long
?	O
true	int
:	O
false	int
)	O
;	O
}	O
static	O
size_t	long
_GL_ATTRIBUTE_CONST	O
next_prime	(long)->(long)
(	O
size_t	long
candidate	long
)	O
{	O
if	O
(	O
candidate	long
<	O
10	int
)	O
candidate	long
=	O
10	int
;	O
candidate	long
|=	O
1	int
;	O
while	O
(	O
SIZE_MAX	O
!=	O
candidate	long
&&	O
!	O
is_prime	(long)->(bool)
(	O
candidate	long
)	O
)	O
candidate	long
+=	O
2	int
;	O
return	O
candidate	long
;	O
}	O
void	O
hash_reset_tuning	(*(struct(float,float,float,float,bool)))->(void)
(	O
Hash_tuning	struct(float,float,float,float,bool)
*	O
tuning	*(struct(float,float,float,float,bool))
)	O
{	O
*	O
tuning	*(struct(float,float,float,float,bool))
=	O
default_tuning	struct(float,float,float,float,bool)
;	O
}	O
static	O
size_t	long
raw_hasher	(*(void),long)->(long)
(	O
const	O
void	O
*	O
data	*(void)
,	O
size_t	long
n	int
)	O
{	O
size_t	long
val	long
=	O
rotr_sz	(long,int)->(long)
(	O
(	O
size_t	long
)	O
data	*(void)
,	O
3	int
)	O
;	O
return	O
val	long
%	O
n	int
;	O
}	O
static	O
bool	bool
raw_comparator	(*(void),*(void))->(bool)
(	O
const	O
void	O
*	O
a	*(void)
,	O
const	O
void	O
*	O
b	*(void)
)	O
{	O
return	O
a	*(void)
==	O
b	*(void)
;	O
}	O
static	O
bool	bool
check_tuning	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))))->(bool)
(	O
Hash_table	struct
*	O
table	*(struct)
)	O
{	O
const	O
Hash_tuning	struct(float,float,float,float,bool)
*	O
tuning	*(struct(float,float,float,float,bool))
=	O
table	*(struct)
->	O
tuning	*(struct(float,float,float,float,bool))
;	O
float	O
epsilon	float
;	O
if	O
(	O
tuning	*(struct(float,float,float,float,bool))
==	O
&	O
default_tuning	struct(float,float,float,float,bool)
)	O
return	O
true	int
;	O
epsilon	float
=	O
0.1f	int
;	O
if	O
(	O
epsilon	float
<	O
tuning	*(struct(float,float,float,float,bool))
->	O
growth_threshold	float
&&	O
tuning	*(struct(float,float,float,float,bool))
->	O
growth_threshold	float
<	O
1	int
-	O
epsilon	float
&&	O
1	int
+	O
epsilon	float
<	O
tuning	*(struct(float,float,float,float,bool))
->	O
growth_factor	float
&&	O
0	int
<=	O
tuning	*(struct(float,float,float,float,bool))
->	O
shrink_threshold	float
&&	O
tuning	*(struct(float,float,float,float,bool))
->	O
shrink_threshold	float
+	O
epsilon	float
<	O
tuning	*(struct(float,float,float,float,bool))
->	O
shrink_factor	float
&&	O
tuning	*(struct(float,float,float,float,bool))
->	O
shrink_factor	float
<=	O
1	int
&&	O
tuning	*(struct(float,float,float,float,bool))
->	O
shrink_threshold	float
+	O
epsilon	float
<	O
tuning	*(struct(float,float,float,float,bool))
->	O
growth_threshold	float
)	O
return	O
true	int
;	O
table	*(struct)
->	O
tuning	*(struct(float,float,float,float,bool))
=	O
&	O
default_tuning	struct(float,float,float,float,bool)
;	O
return	O
false	int
;	O
}	O
static	O
size_t	long
_GL_ATTRIBUTE_PURE	O
compute_bucket_size	(long,*(struct(float,float,float,float,bool)))->(long)
(	O
size_t	long
candidate	long
,	O
const	O
Hash_tuning	struct(float,float,float,float,bool)
*	O
tuning	*(struct(float,float,float,float,bool))
)	O
{	O
if	O
(	O
!	O
tuning	*(struct(float,float,float,float,bool))
->	O
is_n_buckets	bool
)	O
{	O
float	O
new_candidate	float
=	O
candidate	long
/	O
tuning	*(struct(float,float,float,float,bool))
->	O
growth_threshold	float
;	O
if	O
(	O
SIZE_MAX	O
<=	O
new_candidate	float
)	O
return	O
0	int
;	O
candidate	long
=	O
new_candidate	float
;	O
}	O
candidate	long
=	O
next_prime	(long)->(long)
(	O
candidate	long
)	O
;	O
if	O
(	O
xalloc_oversized	O
(	O
candidate	long
,	O
sizeof	O
(	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
)	O
)	O
)	O
return	O
0	int
;	O
return	O
candidate	long
;	O
}	O
Hash_table	struct
*	O
hash_initialize	(long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)))->(*(struct))
(	O
size_t	long
candidate	long
,	O
const	O
Hash_tuning	struct(float,float,float,float,bool)
*	O
tuning	*(struct(float,float,float,float,bool))
,	O
Hash_hasher	*((*(void),long)->(long))
hasher	*((*(void),long)->(long))
,	O
Hash_comparator	*((*(void),*(void))->(bool))
comparator	*((*(void),*(void))->(bool))
,	O
Hash_data_freer	*((*(void))->(void))
data_freer	*((*(void))->(void))
)	O
{	O
Hash_table	struct
*	O
table	*(struct)
;	O
if	O
(	O
hasher	*((*(void),long)->(long))
==	O
NULL	O
)	O
hasher	*((*(void),long)->(long))
=	O
raw_hasher	(*(void),long)->(long)
;	O
if	O
(	O
comparator	*((*(void),*(void))->(bool))
==	O
NULL	O
)	O
comparator	*((*(void),*(void))->(bool))
=	O
raw_comparator	(*(void),*(void))->(bool)
;	O
table	*(struct)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
*	O
table	*(struct)
)	O
;	O
if	O
(	O
table	*(struct)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
tuning	*(struct(float,float,float,float,bool))
)	O
tuning	*(struct(float,float,float,float,bool))
=	O
&	O
default_tuning	struct(float,float,float,float,bool)
;	O
table	*(struct)
->	O
tuning	*(struct(float,float,float,float,bool))
=	O
tuning	*(struct(float,float,float,float,bool))
;	O
if	O
(	O
!	O
check_tuning	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))))->(bool)
(	O
table	*(struct)
)	O
)	O
{	O
goto	O
fail	O
;	O
}	O
table	*(struct)
->	O
n_buckets	long
=	O
compute_bucket_size	(long,*(struct(float,float,float,float,bool)))->(long)
(	O
candidate	long
,	O
tuning	*(struct(float,float,float,float,bool))
)	O
;	O
if	O
(	O
!	O
table	*(struct)
->	O
n_buckets	long
)	O
goto	O
fail	O
;	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
calloc	(long,long)->(*(void))
(	O
table	*(struct)
->	O
n_buckets	long
,	O
sizeof	O
*	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
if	O
(	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
==	O
NULL	O
)	O
goto	O
fail	O
;	O
table	*(struct)
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
+	O
table	*(struct)
->	O
n_buckets	long
;	O
table	*(struct)
->	O
n_buckets_used	long
=	O
0	int
;	O
table	*(struct)
->	O
n_entries	long
=	O
0	int
;	O
table	*(struct)
->	O
hasher	*((*(void),long)->(long))
=	O
hasher	*((*(void),long)->(long))
;	O
table	*(struct)
->	O
comparator	*((*(void),*(void))->(bool))
=	O
comparator	*((*(void),*(void))->(bool))
;	O
table	*(struct)
->	O
data_freer	*((*(void))->(void))
=	O
data_freer	*((*(void))->(void))
;	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
NULL	O
;	O
return	O
table	*(struct)
;	O
fail	O
:	O
free	(*(void))->(void)
(	O
table	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
hash_clear	(*(struct))->(void)
(	O
Hash_table	struct
*	O
table	*(struct)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
for	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
<	O
table	*(struct)
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
++	O
)	O
{	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
for	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
if	O
(	O
table	*(struct)
->	O
data_freer	*((*(void))->(void))
)	O
table	*(struct)
->	O
data_freer	*((*(void))->(void))
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
=	O
NULL	O
;	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
if	O
(	O
table	*(struct)
->	O
data_freer	*((*(void))->(void))
)	O
table	*(struct)
->	O
data_freer	*((*(void))->(void))
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
=	O
NULL	O
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
NULL	O
;	O
}	O
}	O
table	*(struct)
->	O
n_buckets_used	long
=	O
0	int
;	O
table	*(struct)
->	O
n_entries	long
=	O
0	int
;	O
}	O
void	O
hash_free	(*(struct))->(void)
(	O
Hash_table	struct
*	O
table	*(struct)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
if	O
(	O
table	*(struct)
->	O
data_freer	*((*(void))->(void))
&&	O
table	*(struct)
->	O
n_entries	long
)	O
{	O
for	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
<	O
table	*(struct)
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
++	O
)	O
{	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
{	O
for	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
table	*(struct)
->	O
data_freer	*((*(void))->(void))
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
;	O
}	O
}	O
}	O
for	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
<	O
table	*(struct)
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
++	O
)	O
{	O
for	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
free	(*(void))->(void)
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
}	O
}	O
for	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
free	(*(void))->(void)
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
table	*(struct)
)	O
;	O
}	O
static	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
allocate_entry	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
Hash_table	struct
*	O
table	*(struct)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
new	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
if	O
(	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
new	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
new	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
else	O
{	O
new	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
*	O
new	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
}	O
return	O
new	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
static	O
void	O
free_entry	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(struct(*(void),*(struct(*`,*`)))))->(void)
(	O
Hash_table	struct
*	O
table	*(struct)
,	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
entry	*(void)
)	O
{	O
entry	*(void)
->	O
data	*(void)
=	O
NULL	O
;	O
entry	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
entry	*(void)
;	O
}	O
static	O
void	O
*	O
hash_find_entry	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(void),*(*(struct(*(void),*(struct`)))),bool)->(*(void))
(	O
Hash_table	struct
*	O
table	*(struct)
,	O
const	O
void	O
*	O
entry	*(void)
,	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
*	O
bucket_head	*(*(struct(*(void),*(struct(*`,*`)))))
,	O
bool	bool
delete	bool
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
safe_hasher	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(void))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
table	*(struct)
,	O
entry	*(void)
)	O
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
*	O
bucket_head	*(*(struct(*(void),*(struct(*`,*`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
entry	*(void)
==	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
||	O
table	*(struct)
->	O
comparator	*((*(void),*(void))->(bool))
(	O
entry	*(void)
,	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
)	O
{	O
void	O
*	O
data	*(void)
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
;	O
if	O
(	O
delete	bool
)	O
{	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
free_entry	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(struct(*(void),*(struct(*`,*`)))))->(void)
(	O
table	*(struct)
,	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
}	O
else	O
{	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
=	O
NULL	O
;	O
}	O
}	O
return	O
data	*(void)
;	O
}	O
for	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
if	O
(	O
entry	*(void)
==	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
||	O
table	*(struct)
->	O
comparator	*((*(void),*(void))->(bool))
(	O
entry	*(void)
,	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
)	O
{	O
void	O
*	O
data	*(void)
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
;	O
if	O
(	O
delete	bool
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
free_entry	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(struct(*(void),*(struct(*`,*`)))))->(void)
(	O
table	*(struct)
,	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
}	O
return	O
data	*(void)
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
bool	bool
transfer_entries	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),bool)->(bool)
(	O
Hash_table	struct
*	O
dst	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
,	O
Hash_table	struct
*	O
src	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
,	O
bool	bool
safe	bool
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
for	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
src	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
<	O
src	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
++	O
)	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
{	O
void	O
*	O
data	*(void)
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
new_bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
for	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
data	*(void)
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
;	O
new_bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
safe_hasher	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(void))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
dst	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
,	O
data	*(void)
)	O
;	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
if	O
(	O
new_bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
{	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
new_bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
new_bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
else	O
{	O
new_bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
=	O
data	*(void)
;	O
dst	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
n_buckets_used	long
++	O
;	O
free_entry	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(struct(*(void),*(struct(*`,*`)))))->(void)
(	O
dst	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
,	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
}	O
}	O
data	*(void)
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
safe	bool
)	O
continue	O
;	O
new_bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
safe_hasher	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(void))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
dst	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
,	O
data	*(void)
)	O
;	O
if	O
(	O
new_bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
new_entry	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
allocate_entry	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
dst	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
)	O
;	O
if	O
(	O
new_entry	*(struct(*(void),*(struct(*(void),*(struct`)))))
==	O
NULL	O
)	O
return	O
false	int
;	O
new_entry	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
=	O
data	*(void)
;	O
new_entry	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
new_bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
new_bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
new_entry	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
else	O
{	O
new_bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
=	O
data	*(void)
;	O
dst	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
n_buckets_used	long
++	O
;	O
}	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
=	O
NULL	O
;	O
src	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
n_buckets_used	long
--	O
;	O
}	O
return	O
true	int
;	O
}	O
bool	bool
hash_rehash	(*(struct),long)->(bool)
(	O
Hash_table	struct
*	O
table	*(struct)
,	O
size_t	long
candidate	long
)	O
{	O
Hash_table	struct
storage	struct(*(struct(*(void),*(struct(*`,*`)))),*(struct(*(void),*(struct(*`,*`)))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct(*`,*`)))))
;	O
Hash_table	struct
*	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
;	O
size_t	long
new_size	long
=	O
compute_bucket_size	(long,*(struct(float,float,float,float,bool)))->(long)
(	O
candidate	long
,	O
table	*(struct)
->	O
tuning	*(struct(float,float,float,float,bool))
)	O
;	O
if	O
(	O
!	O
new_size	long
)	O
return	O
false	int
;	O
if	O
(	O
new_size	long
==	O
table	*(struct)
->	O
n_buckets	long
)	O
return	O
true	int
;	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
=	O
&	O
storage	struct(*(struct(*(void),*(struct(*`,*`)))),*(struct(*(void),*(struct(*`,*`)))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct(*`,*`)))))
;	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
calloc	(long,long)->(*(void))
(	O
new_size	long
,	O
sizeof	O
*	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
if	O
(	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
==	O
NULL	O
)	O
return	O
false	int
;	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
n_buckets	long
=	O
new_size	long
;	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
+	O
new_size	long
;	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
n_buckets_used	long
=	O
0	int
;	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
n_entries	long
=	O
0	int
;	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
tuning	*(struct(float,float,float,float,bool))
=	O
table	*(struct)
->	O
tuning	*(struct(float,float,float,float,bool))
;	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
hasher	*((*(void),long)->(long))
=	O
table	*(struct)
->	O
hasher	*((*(void),long)->(long))
;	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
comparator	*((*(void),*(void))->(bool))
=	O
table	*(struct)
->	O
comparator	*((*(void),*(void))->(bool))
;	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
data_freer	*((*(void))->(void))
=	O
table	*(struct)
->	O
data_freer	*((*(void))->(void))
;	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
if	O
(	O
transfer_entries	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),bool)->(bool)
(	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
,	O
table	*(struct)
,	O
false	int
)	O
)	O
{	O
free	(*(void))->(void)
(	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
table	*(struct)
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
table	*(struct)
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
bucket_limit	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
table	*(struct)
->	O
n_buckets	long
=	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
n_buckets	long
;	O
table	*(struct)
->	O
n_buckets_used	long
=	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
n_buckets_used	long
;	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
return	O
true	int
;	O
}	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
if	O
(	O
!	O
(	O
transfer_entries	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),bool)->(bool)
(	O
table	*(struct)
,	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
,	O
true	int
)	O
&&	O
transfer_entries	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),bool)->(bool)
(	O
table	*(struct)
,	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
,	O
false	int
)	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
free	(*(void))->(void)
(	O
new_table	*(struct(*(struct(*(void),*(struct`))),*(struct(*(void),*(struct`))),long,long,long,*(struct(float,float,float,float,bool)),*((*(void),long)->(long)),*((*(void),*(void))->(bool)),*((*(void))->(void)),*(struct(*(void),*(struct`)))))
->	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
return	O
false	int
;	O
}	O
int	O
hash_insert_if_absent	(*(struct),*(void),*(*(void)))->(int)
(	O
Hash_table	struct
*	O
table	*(struct)
,	O
void	O
const	O
*	O
entry	*(void)
,	O
void	O
const	O
*	O
*	O
matched_ent	*(*(void))
)	O
{	O
void	O
*	O
data	*(void)
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
if	O
(	O
!	O
entry	*(void)
)	O
abort	()->(void)
(	O
)	O
;	O
if	O
(	O
(	O
data	*(void)
=	O
hash_find_entry	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(void),*(*(struct(*(void),*(struct`)))),bool)->(*(void))
(	O
table	*(struct)
,	O
entry	*(void)
,	O
&	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
,	O
false	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
matched_ent	*(*(void))
)	O
*	O
matched_ent	*(*(void))
=	O
data	*(void)
;	O
return	O
0	int
;	O
}	O
if	O
(	O
table	*(struct)
->	O
n_buckets_used	long
>	O
table	*(struct)
->	O
tuning	*(struct(float,float,float,float,bool))
->	O
growth_threshold	float
*	O
table	*(struct)
->	O
n_buckets	long
)	O
{	O
check_tuning	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))))->(bool)
(	O
table	*(struct)
)	O
;	O
if	O
(	O
table	*(struct)
->	O
n_buckets_used	long
>	O
table	*(struct)
->	O
tuning	*(struct(float,float,float,float,bool))
->	O
growth_threshold	float
*	O
table	*(struct)
->	O
n_buckets	long
)	O
{	O
const	O
Hash_tuning	struct(float,float,float,float,bool)
*	O
tuning	*(struct(float,float,float,float,bool))
=	O
table	*(struct)
->	O
tuning	*(struct(float,float,float,float,bool))
;	O
float	O
candidate	long
=	O
(	O
tuning	*(struct(float,float,float,float,bool))
->	O
is_n_buckets	bool
?	O
(	O
table	*(struct)
->	O
n_buckets	long
*	O
tuning	*(struct(float,float,float,float,bool))
->	O
growth_factor	float
)	O
:	O
(	O
table	*(struct)
->	O
n_buckets	long
*	O
tuning	*(struct(float,float,float,float,bool))
->	O
growth_factor	float
*	O
tuning	*(struct(float,float,float,float,bool))
->	O
growth_threshold	float
)	O
)	O
;	O
if	O
(	O
SIZE_MAX	O
<=	O
candidate	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
hash_rehash	(*(struct),long)->(bool)
(	O
table	*(struct)
,	O
candidate	long
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
hash_find_entry	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(void),*(*(struct(*(void),*(struct`)))),bool)->(*(void))
(	O
table	*(struct)
,	O
entry	*(void)
,	O
&	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
,	O
false	int
)	O
!=	O
NULL	O
)	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
new_entry	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
allocate_entry	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))))->(*(struct(*(void),*(struct(*`,*`)))))
(	O
table	*(struct)
)	O
;	O
if	O
(	O
new_entry	*(struct(*(void),*(struct(*(void),*(struct`)))))
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
new_entry	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
=	O
(	O
void	O
*	O
)	O
entry	*(void)
;	O
new_entry	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
new_entry	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
table	*(struct)
->	O
n_entries	long
++	O
;	O
return	O
1	int
;	O
}	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
=	O
(	O
void	O
*	O
)	O
entry	*(void)
;	O
table	*(struct)
->	O
n_entries	long
++	O
;	O
table	*(struct)
->	O
n_buckets_used	long
++	O
;	O
return	O
1	int
;	O
}	O
void	O
*	O
hash_insert	(*(struct),*(void))->(*(void))
(	O
Hash_table	struct
*	O
table	*(struct)
,	O
void	O
const	O
*	O
entry	*(void)
)	O
{	O
void	O
const	O
*	O
matched_ent	*(*(void))
;	O
int	O
err	int
=	O
hash_insert_if_absent	(*(struct),*(void),*(*(void)))->(int)
(	O
table	*(struct)
,	O
entry	*(void)
,	O
&	O
matched_ent	*(*(void))
)	O
;	O
return	O
(	O
err	int
==	O
-	O
1	int
?	O
NULL	O
:	O
(	O
void	O
*	O
)	O
(	O
err	int
==	O
0	int
?	O
matched_ent	*(*(void))
:	O
entry	*(void)
)	O
)	O
;	O
}	O
void	O
*	O
hash_delete	(*(struct),*(void))->(*(void))
(	O
Hash_table	struct
*	O
table	*(struct)
,	O
const	O
void	O
*	O
entry	*(void)
)	O
{	O
void	O
*	O
data	*(void)
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
data	*(void)
=	O
hash_find_entry	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))),*(void),*(*(struct(*(void),*(struct`)))),bool)->(*(void))
(	O
table	*(struct)
,	O
entry	*(void)
,	O
&	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
,	O
true	int
)	O
;	O
if	O
(	O
!	O
data	*(void)
)	O
return	O
NULL	O
;	O
table	*(struct)
->	O
n_entries	long
--	O
;	O
if	O
(	O
!	O
bucket	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
data	*(void)
)	O
{	O
table	*(struct)
->	O
n_buckets_used	long
--	O
;	O
if	O
(	O
table	*(struct)
->	O
n_buckets_used	long
<	O
table	*(struct)
->	O
tuning	*(struct(float,float,float,float,bool))
->	O
shrink_threshold	float
*	O
table	*(struct)
->	O
n_buckets	long
)	O
{	O
check_tuning	(*(struct(*(struct(*`,*`)),*(struct(*`,*`)),long,long,long,*(struct(float,float,float,float,bool)),*((*`,long)->(long)),*((*`,*`)->(bool)),*((*`)->(void)),*(struct(*`,*`)))))->(bool)
(	O
table	*(struct)
)	O
;	O
if	O
(	O
table	*(struct)
->	O
n_buckets_used	long
<	O
table	*(struct)
->	O
tuning	*(struct(float,float,float,float,bool))
->	O
shrink_threshold	float
*	O
table	*(struct)
->	O
n_buckets	long
)	O
{	O
const	O
Hash_tuning	struct(float,float,float,float,bool)
*	O
tuning	*(struct(float,float,float,float,bool))
=	O
table	*(struct)
->	O
tuning	*(struct(float,float,float,float,bool))
;	O
size_t	long
candidate	long
=	O
(	O
tuning	*(struct(float,float,float,float,bool))
->	O
is_n_buckets	bool
?	O
table	*(struct)
->	O
n_buckets	long
*	O
tuning	*(struct(float,float,float,float,bool))
->	O
shrink_factor	float
:	O
(	O
table	*(struct)
->	O
n_buckets	long
*	O
tuning	*(struct(float,float,float,float,bool))
->	O
shrink_factor	float
*	O
tuning	*(struct(float,float,float,float,bool))
->	O
growth_threshold	float
)	O
)	O
;	O
if	O
(	O
!	O
hash_rehash	(*(struct),long)->(bool)
(	O
table	*(struct)
,	O
candidate	long
)	O
)	O
{	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
struct	O
hash_entry	struct(*(void),*(struct(*(void),*(struct(*(void),*(struct`))))))
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
while	O
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
{	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
free	(*(void))->(void)
(	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
)	O
;	O
cursor	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
next	*(struct(*(void),*(struct(*(void),*(struct`)))))
;	O
}	O
table	*(struct)
->	O
free_entry_list	*(struct(*(void),*(struct(*(void),*(struct`)))))
=	O
NULL	O
;	O
}	O
}	O
}	O
}	O
return	O
data	*(void)
;	O
}	O
