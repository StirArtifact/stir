static	O
int	O
bisquare	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
i	long
;	O
size_t	long
n	int
=	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
ri	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
ri	double
)	O
<	O
1.0	int
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
i	long
,	O
(	O
1.0	int
-	O
ri	double
*	O
ri	double
)	O
*	O
(	O
1.0	int
-	O
ri	double
*	O
ri	double
)	O
)	O
;	O
else	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
i	long
,	O
0.0	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
bisquare_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
size_t	long
i	long
;	O
size_t	long
n	int
=	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
ri	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
ri	double
)	O
<	O
1.0	int
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
(	O
1.0	int
-	O
ri	double
*	O
ri	double
)	O
*	O
(	O
1.0	int
-	O
5.0	int
*	O
ri	double
*	O
ri	double
)	O
)	O
;	O
else	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
0.0	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
bisquare_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
=	O
{	O
"bisquare"	*(char)
,	O
&	O
bisquare	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
&	O
bisquare_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
TUNING_BISQUARE	O
}	O
;	O
static	O
int	O
cauchy	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
i	long
;	O
size_t	long
n	int
=	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
ri	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
i	long
,	O
1.0	int
/	O
(	O
1.0	int
+	O
ri	double
*	O
ri	double
)	O
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
cauchy_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
size_t	long
i	long
;	O
size_t	long
n	int
=	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
ri	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
double	O
rsq	double
=	O
ri	double
*	O
ri	double
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
(	O
1	int
-	O
rsq	double
)	O
/	O
(	O
1.0	int
+	O
rsq	double
)	O
/	O
(	O
1.0	int
+	O
rsq	double
)	O
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
cauchy_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
=	O
{	O
"cauchy"	*(char)
,	O
&	O
cauchy	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
&	O
cauchy_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
TUNING_CAUCHY	O
}	O
;	O
static	O
int	O
fair	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
i	long
;	O
size_t	long
n	int
=	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
ri	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
i	long
,	O
1.0	int
/	O
(	O
1.0	int
+	O
fabs	(double)->(double)
(	O
ri	double
)	O
)	O
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
fair_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
size_t	long
i	long
;	O
size_t	long
n	int
=	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
ri	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
1.0	int
/	O
(	O
1.0	int
+	O
fabs	(double)->(double)
(	O
ri	double
)	O
)	O
/	O
(	O
1.0	int
+	O
fabs	(double)->(double)
(	O
ri	double
)	O
)	O
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
fair_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
=	O
{	O
"fair"	*(char)
,	O
&	O
fair	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
&	O
fair_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
TUNING_FAIR	O
}	O
;	O
static	O
int	O
huber	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
i	long
;	O
size_t	long
n	int
=	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
absri	double
=	O
fabs	(double)->(double)
(	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
)	O
;	O
if	O
(	O
absri	double
<=	O
1.0	int
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
i	long
,	O
1.0	int
)	O
;	O
else	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
i	long
,	O
1.0	int
/	O
absri	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
huber_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
size_t	long
i	long
;	O
size_t	long
n	int
=	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
ri	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
if	O
(	O
fabs	(double)->(double)
(	O
ri	double
)	O
<=	O
1.0	int
)	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
1.0	int
)	O
;	O
else	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
0.0	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
huber_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
=	O
{	O
"huber"	*(char)
,	O
&	O
huber	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
&	O
huber_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
TUNING_HUBER	O
}	O
;	O
static	O
int	O
ols	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
gsl_vector_set_all	(*(struct(long,long,*(double),*(struct(long,*`)),int)),double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
1.0	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
ols_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
gsl_vector_set_all	(*(struct(long,long,*(double),*(struct(long,*`)),int)),double)->(void)
(	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
1.0	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
ols_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
=	O
{	O
"ols"	*(char)
,	O
&	O
ols	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
&	O
ols_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
TUNING_OLS	O
}	O
;	O
static	O
int	O
welsch	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
)	O
{	O
size_t	long
i	long
;	O
size_t	long
n	int
=	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
ri	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
w	*(struct(long,long,*(long double),*(struct(long,*(long double))),int))
,	O
i	long
,	O
exp	(double)->(double)
(	O
-	O
ri	double
*	O
ri	double
)	O
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
welsch_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
{	O
size_t	long
i	long
;	O
size_t	long
n	int
=	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
ri	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
r	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
dpsi	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
(	O
1.0	int
-	O
2.0	int
*	O
ri	double
*	O
ri	double
)	O
*	O
exp	(double)->(double)
(	O
-	O
ri	double
*	O
ri	double
)	O
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
welsch_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
=	O
{	O
"welsch"	*(char)
,	O
&	O
welsch	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
&	O
welsch_dpsi	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
,	O
TUNING_WELSCH	O
}	O
;	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
*	O
gsl_multifit_robust_default	*(struct(*(char),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),double))
=	O
&	O
bisquare_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
;	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
*	O
gsl_multifit_robust_bisquare	*(struct(*(char),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),double))
=	O
&	O
bisquare_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
;	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
*	O
gsl_multifit_robust_cauchy	*(struct(*(char),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),double))
=	O
&	O
cauchy_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
;	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
*	O
gsl_multifit_robust_fair	*(struct(*(char),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),double))
=	O
&	O
fair_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
;	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
*	O
gsl_multifit_robust_huber	*(struct(*(char),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),double))
=	O
&	O
huber_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
;	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
*	O
gsl_multifit_robust_ols	*(struct(*(char),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),double))
=	O
&	O
ols_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
;	O
const	O
gsl_multifit_robust_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
*	O
gsl_multifit_robust_welsch	*(struct(*(char),*((*(struct`),*(struct`))->(int)),*((*(struct`),*(struct`))->(int)),double))
=	O
&	O
welsch_type	struct(*(char),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),*((*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)))->(int)),double)
;	O
