const	O
char	O
*	O
short_illegals	*(char)
=	O
";+=[]',\"*\\<>/?:|"	*(char)
;	O
const	O
char	O
*	O
long_illegals	*(char)
=	O
"\"*\\<>/?:|\005"	*(char)
;	O
static	O
void	O
autorename	(*(char),char,char,*(char),int,int)->(void)
(	O
char	O
*	O
name	*(char)
,	O
char	O
tilda	char
,	O
char	O
dot	char
,	O
const	O
char	O
*	O
illegals	*(char)
,	O
int	O
limit	int
,	O
int	O
bump	int
)	O
{	O
int	O
tildapos	int
,	O
dotpos	int
;	O
unsigned	O
int	O
seqnum	int
=	O
0	int
,	O
maxseq	int
=	O
0	int
;	O
char	O
tmp	char
;	O
char	O
*	O
p	*(char)
;	O
tildapos	int
=	O
-	O
1	int
;	O
for	O
(	O
p	*(char)
=	O
name	*(char)
;	O
*	O
p	*(char)
;	O
p	*(char)
++	O
)	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
illegals	*(char)
,	O
*	O
p	*(char)
)	O
)	O
{	O
*	O
p	*(char)
=	O
'_'	O
;	O
bump	int
=	O
0	int
;	O
}	O
for	O
(	O
dotpos	int
=	O
0	int
;	O
name	*(char)
[	O
dotpos	int
]	O
&&	O
dotpos	int
<	O
limit	int
&&	O
name	*(char)
[	O
dotpos	int
]	O
!=	O
dot	char
;	O
dotpos	int
++	O
)	O
{	O
if	O
(	O
name	*(char)
[	O
dotpos	int
]	O
==	O
tilda	char
)	O
{	O
tildapos	int
=	O
dotpos	int
;	O
seqnum	int
=	O
0	int
;	O
maxseq	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
name	*(char)
[	O
dotpos	int
]	O
>=	O
'0'	O
&&	O
name	*(char)
[	O
dotpos	int
]	O
<=	O
'9'	O
)	O
{	O
seqnum	int
=	O
seqnum	int
*	O
10	int
+	O
name	*(char)
[	O
dotpos	int
]	O
-	O
'0'	O
;	O
maxseq	int
=	O
maxseq	int
*	O
10	int
;	O
}	O
else	O
tildapos	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
tildapos	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
dotpos	int
>	O
limit	int
-	O
2	int
)	O
{	O
tildapos	int
=	O
limit	int
-	O
2	int
;	O
dotpos	int
=	O
limit	int
;	O
}	O
else	O
{	O
tildapos	int
=	O
dotpos	int
;	O
dotpos	int
+=	O
2	int
;	O
}	O
seqnum	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
bump	int
)	O
seqnum	int
++	O
;	O
if	O
(	O
seqnum	int
>	O
999999	int
)	O
{	O
seqnum	int
=	O
1	int
;	O
tildapos	int
=	O
dotpos	int
-	O
2	int
;	O
}	O
if	O
(	O
seqnum	int
==	O
maxseq	int
)	O
{	O
if	O
(	O
dotpos	int
>=	O
limit	int
)	O
tildapos	int
--	O
;	O
else	O
dotpos	int
++	O
;	O
}	O
}	O
tmp	char
=	O
name	*(char)
[	O
dotpos	int
]	O
;	O
if	O
(	O
(	O
bump	int
&&	O
seqnum	int
==	O
1	int
)	O
||	O
seqnum	int
>	O
1	int
||	O
mtools_numeric_tail	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
name	*(char)
+	O
tildapos	int
,	O
"%c%d"	*(char)
,	O
tilda	char
,	O
seqnum	int
)	O
;	O
if	O
(	O
dot	char
)	O
name	*(char)
[	O
dotpos	int
]	O
=	O
tmp	char
;	O
}	O
void	O
autorename_short	(*(struct),int)->(void)
(	O
dos_name_t	struct
*	O
name	*(char)
,	O
int	O
bump	int
)	O
{	O
autorename	(*(char),char,char,*(char),int,int)->(void)
(	O
name	*(char)
->	O
base	int
,	O
'~'	O
,	O
' '	O
,	O
short_illegals	*(char)
,	O
8	int
,	O
bump	int
)	O
;	O
}	O
void	O
autorename_long	(*(char),int)->(void)
(	O
char	O
*	O
name	*(char)
,	O
int	O
bump	int
)	O
{	O
autorename	(*(char),char,char,*(char),int,int)->(void)
(	O
name	*(char)
,	O
'-'	O
,	O
'\0'	O
,	O
long_illegals	*(char)
,	O
255	int
,	O
bump	int
)	O
;	O
}	O
static	O
__inline__	O
int	O
unicode_read	(*(struct(char,char)),*(int),int)->(int)
(	O
struct	O
unicode_char	struct(char,char)
*	O
in	*(struct(char,char))
,	O
wchar_t	int
*	O
out	*(int)
,	O
int	O
num	int
)	O
{	O
wchar_t	int
*	O
end_out	*(int)
=	O
out	*(int)
+	O
num	int
;	O
while	O
(	O
out	*(int)
<	O
end_out	*(int)
)	O
{	O
*	O
out	*(int)
=	O
in	*(struct(char,char))
->	O
lchar	char
|	O
(	O
(	O
in	*(struct(char,char))
->	O
uchar	char
)	O
<<	O
8	int
)	O
;	O
++	O
out	*(int)
;	O
++	O
in	*(struct(char,char))
;	O
}	O
return	O
num	int
;	O
}	O
void	O
clear_vfat	(*(struct(array(int),int,int,char,int)))->(void)
(	O
struct	O
vfat_state	struct(array(int),int,int,char,int)
*	O
v	*(struct(array(int),int,int,char,int))
)	O
{	O
v	*(struct(array(int),int,int,char,int))
->	O
subentries	int
=	O
0	int
;	O
v	*(struct(array(int),int,int,char,int))
->	O
status	int
=	O
0	int
;	O
v	*(struct(array(int),int,int,char,int))
->	O
present	int
=	O
0	int
;	O
}	O
static	O
__inline__	O
unsigned	O
char	O
sum_shortname	(*(struct(array(char),array(char),char)))->(char)
(	O
const	O
dos_name_t	struct
*	O
dn	*(struct)
)	O
{	O
unsigned	O
char	O
sum	char
;	O
const	O
char	O
*	O
name	*(char)
=	O
dn	*(struct)
->	O
base	int
;	O
const	O
char	O
*	O
end	*(int)
=	O
name	*(char)
+	O
11	int
;	O
for	O
(	O
sum	char
=	O
0	int
;	O
name	*(char)
<	O
end	*(int)
;	O
++	O
name	*(char)
)	O
sum	char
=	O
(	O
(	O
sum	char
&	O
1	int
)	O
?	O
0x80	int
:	O
0	int
)	O
+	O
(	O
sum	char
>>	O
1	int
)	O
+	O
*	O
name	*(char)
;	O
return	O
(	O
sum	char
)	O
;	O
}	O
static	O
__inline__	O
void	O
check_vfat	(*(struct(array(int),int,int,char,int)),*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))))->(void)
(	O
struct	O
vfat_state	struct(array(int),int,int,char,int)
*	O
v	*(struct(array(int),int,int,char,int))
,	O
struct	O
directory	struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))
*	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
)	O
{	O
dos_name_t	struct
dn	*(struct)
;	O
;	O
if	O
(	O
!	O
v	*(struct(array(int),int,int,char,int))
->	O
subentries	int
)	O
{	O
return	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dn	*(struct)
.	O
base	int
,	O
(	O
char	O
*	O
)	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
->	O
name	*(char)
,	O
8	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dn	*(struct)
.	O
ext	array(char)
,	O
(	O
char	O
*	O
)	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
->	O
ext	array(char)
,	O
3	int
)	O
;	O
if	O
(	O
v	*(struct(array(int),int,int,char,int))
->	O
sum	char
!=	O
sum_shortname	(*(struct(array(char),array(char),char)))->(char)
(	O
&	O
dn	*(struct)
)	O
)	O
return	O
;	O
if	O
(	O
(	O
v	*(struct(array(int),int,int,char,int))
->	O
status	int
&	O
(	O
(	O
1	int
<<	O
v	*(struct(array(int),int,int,char,int))
->	O
subentries	int
)	O
-	O
1	int
)	O
)	O
!=	O
(	O
1	int
<<	O
v	*(struct(array(int),int,int,char,int))
->	O
subentries	int
)	O
-	O
1	int
)	O
return	O
;	O
v	*(struct(array(int),int,int,char,int))
->	O
name	*(char)
[	O
VSE_NAMELEN	int
*	O
v	*(struct(array(int),int,int,char,int))
->	O
subentries	int
]	O
=	O
0	int
;	O
v	*(struct(array(int),int,int,char,int))
->	O
present	int
=	O
1	int
;	O
}	O
int	O
clear_vses	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),int,long)->(int)
(	O
Stream_t	struct(*(struct),int,*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))))
*	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
int	O
entrySlot	int
,	O
size_t	long
last	long
)	O
{	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
entry	int
;	O
dirCache_t	struct(*(*(struct)),int,int,array(int),array(int),array(int))
*	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
;	O
int	O
error	*(int)
;	O
entry	int
.	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
=	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
;	O
entry	int
.	O
entry	int
=	O
entrySlot	int
;	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
=	O
allocDirCache	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),int)->(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))))
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
last	long
)	O
;	O
if	O
(	O
!	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Out of memory error in clear_vses\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
addFreeEntry	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int,int)->(*(struct))
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
entry	int
.	O
entry	int
,	O
last	long
)	O
;	O
for	O
(	O
;	O
entry	int
.	O
entry	int
<	O
(	O
signed	O
int	O
)	O
last	long
;	O
++	O
entry	int
.	O
entry	int
)	O
{	O
dir_read	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(int))->(*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))))
(	O
&	O
entry	int
,	O
&	O
error	*(int)
)	O
;	O
if	O
(	O
error	*(int)
)	O
return	O
error	*(int)
;	O
if	O
(	O
!	O
entry	int
.	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
name	*(char)
[	O
0	int
]	O
||	O
entry	int
.	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
name	*(char)
[	O
0	int
]	O
==	O
DELMARK	O
)	O
break	O
;	O
entry	int
.	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
name	*(char)
[	O
0	int
]	O
=	O
DELMARK	O
;	O
if	O
(	O
entry	int
.	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
attr	char
==	O
0xf	int
)	O
entry	int
.	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
attr	char
=	O
'\0'	O
;	O
low_level_dir_write	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(void)
(	O
&	O
entry	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
write_vfat	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(struct),*(char),int,*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int)
(	O
Stream_t	struct(*(struct),int,*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))))
*	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
dos_name_t	struct
*	O
shortname	*(char)
,	O
char	O
*	O
longname	*(char)
,	O
int	O
start	array(char)
,	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
*	O
mainEntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
)	O
{	O
struct	O
vfat_subentry	struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char)))
*	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
;	O
int	O
vse_id	int
,	O
num_vses	int
;	O
wchar_t	int
*	O
c	*(int)
;	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
entry	int
;	O
dirCache_t	struct(*(*(struct)),int,int,array(int),array(int),array(int))
*	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
;	O
wchar_t	int
unixyName	array(int)
[	O
13	int
]	O
;	O
doscp_t	struct
*	O
cp	*(struct)
=	O
GET_DOSCONVERT	O
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
;	O
wchar_t	int
wlongname	array(int)
[	O
MAX_VNAMELEN	O
+	O
1	int
]	O
;	O
int	O
wlen	int
;	O
if	O
(	O
longname	*(char)
)	O
{	O
entry	int
.	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
=	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
;	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
=	O
(	O
struct	O
vfat_subentry	struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char)))
*	O
)	O
&	O
entry	int
.	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
;	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
attribute	char
=	O
0x0f	int
;	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
hash1	char
=	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
sector_l	char
=	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
sector_u	char
=	O
0	int
;	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
sum	char
=	O
sum_shortname	(*(struct(array(char),array(char),char)))->(char)
(	O
shortname	*(char)
)	O
;	O
wlen	int
=	O
native_to_wchar	(*(char),*(int),long,*(char),*(int))->(int)
(	O
longname	*(char)
,	O
wlongname	array(int)
,	O
MAX_VNAMELEN	O
+	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
num_vses	int
=	O
(	O
wlen	int
+	O
VSE_NAMELEN	int
-	O
1	int
)	O
/	O
VSE_NAMELEN	int
;	O
for	O
(	O
vse_id	int
=	O
num_vses	int
;	O
vse_id	int
;	O
--	O
vse_id	int
)	O
{	O
int	O
end	*(int)
=	O
0	int
;	O
c	*(int)
=	O
wlongname	array(int)
+	O
(	O
vse_id	int
-	O
1	int
)	O
*	O
VSE_NAMELEN	int
;	O
c	*(int)
+=	O
unicode_write	(*(int),*(struct(char,char)),int,*(int))->(int)
(	O
c	*(int)
,	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
text1	array(struct(char,char))
,	O
VSE1SIZE	int
,	O
&	O
end	*(int)
)	O
;	O
c	*(int)
+=	O
unicode_write	(*(int),*(struct(char,char)),int,*(int))->(int)
(	O
c	*(int)
,	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
text2	array(struct(char,char))
,	O
VSE2SIZE	int
,	O
&	O
end	*(int)
)	O
;	O
c	*(int)
+=	O
unicode_write	(*(int),*(struct(char,char)),int,*(int))->(int)
(	O
c	*(int)
,	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
text3	array(struct(char,char))
,	O
VSE3SIZE	int
,	O
&	O
end	*(int)
)	O
;	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
id	char
=	O
(	O
vse_id	int
==	O
num_vses	int
)	O
?	O
(	O
vse_id	int
|	O
VSE_LAST	int
)	O
:	O
vse_id	int
;	O
entry	int
.	O
entry	int
=	O
start	array(char)
+	O
num_vses	int
-	O
vse_id	int
;	O
low_level_dir_write	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(void)
(	O
&	O
entry	int
)	O
;	O
}	O
}	O
else	O
{	O
num_vses	int
=	O
0	int
;	O
wlongname	array(int)
[	O
0	int
]	O
=	O
'\0'	O
;	O
}	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
=	O
allocDirCache	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),int)->(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))))
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
start	array(char)
+	O
num_vses	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Out of memory error\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
unix_name	(*(struct),*(char),*(char),char,*(int))->(*(int))
(	O
cp	*(struct)
,	O
shortname	*(char)
->	O
base	int
,	O
shortname	*(char)
->	O
ext	array(char)
,	O
0	int
,	O
unixyName	array(int)
)	O
;	O
addUsedEntry	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int,int,*(int),*(int),*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))))->(*(struct))
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
start	array(char)
,	O
start	array(char)
+	O
num_vses	int
+	O
1	int
,	O
wlongname	array(int)
,	O
unixyName	array(int)
,	O
&	O
mainEntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
)	O
;	O
low_level_dir_write	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(void)
(	O
mainEntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
)	O
;	O
return	O
start	array(char)
+	O
num_vses	int
;	O
}	O
void	O
dir_write	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(void)
(	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
*	O
entry	int
)	O
{	O
dirCacheEntry_t	struct
*	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
;	O
dirCache_t	struct(*(*(struct)),int,int,array(int),array(int),array(int))
*	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
;	O
if	O
(	O
entry	int
->	O
entry	int
==	O
-	O
3	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Attempt to write root directory pointer\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
=	O
allocDirCache	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),int)->(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))))
(	O
entry	int
->	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
entry	int
->	O
entry	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Out of memory error in dir_write\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
=	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
->	O
entries	*(*(struct))
[	O
entry	int
->	O
entry	int
]	O
;	O
if	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
)	O
{	O
if	O
(	O
entry	int
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
name	*(char)
[	O
0	int
]	O
==	O
DELMARK	O
)	O
{	O
addFreeEntry	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int,int)->(*(struct))
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
beginSlot	int
,	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
endSlot	int
)	O
;	O
}	O
else	O
{	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
=	O
entry	int
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
;	O
}	O
}	O
low_level_dir_write	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(void)
(	O
entry	int
)	O
;	O
}	O
static	O
__inline__	O
void	O
parse_vses	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct(array(int),int,int,char,int)))->(void)
(	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
*	O
entry	int
,	O
struct	O
vfat_state	struct(array(int),int,int,char,int)
*	O
v	*(struct(array(int),int,int,char,int))
)	O
{	O
struct	O
vfat_subentry	struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char)))
*	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
;	O
unsigned	O
char	O
id	char
,	O
last_flag	char
;	O
wchar_t	int
*	O
c	*(int)
;	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
=	O
(	O
struct	O
vfat_subentry	struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char)))
*	O
)	O
&	O
entry	int
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
;	O
id	char
=	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
id	char
&	O
VSE_MASK	int
;	O
last_flag	char
=	O
(	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
id	char
&	O
VSE_LAST	int
)	O
;	O
if	O
(	O
id	char
>	O
MAX_VFAT_SUBENTRIES	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"parse_vses: invalid VSE ID %d at %d.\n"	*(char)
,	O
id	char
,	O
entry	int
->	O
entry	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
v	*(struct(array(int),int,int,char,int))
->	O
sum	char
!=	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
sum	char
)	O
{	O
clear_vfat	(*(struct(array(int),int,int,char,int)))->(void)
(	O
v	*(struct(array(int),int,int,char,int))
)	O
;	O
v	*(struct(array(int),int,int,char,int))
->	O
sum	char
=	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
sum	char
;	O
}	O
v	*(struct(array(int),int,int,char,int))
->	O
status	int
|=	O
1	int
<<	O
(	O
id	char
-	O
1	int
)	O
;	O
if	O
(	O
last_flag	char
)	O
v	*(struct(array(int),int,int,char,int))
->	O
subentries	int
=	O
id	char
;	O
c	*(int)
=	O
&	O
(	O
v	*(struct(array(int),int,int,char,int))
->	O
name	*(char)
[	O
VSE_NAMELEN	int
*	O
(	O
id	char
-	O
1	int
)	O
]	O
)	O
;	O
c	*(int)
+=	O
unicode_read	(*(struct(char,char)),*(int),int)->(int)
(	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
text1	array(struct(char,char))
,	O
c	*(int)
,	O
VSE1SIZE	int
)	O
;	O
c	*(int)
+=	O
unicode_read	(*(struct(char,char)),*(int),int)->(int)
(	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
text2	array(struct(char,char))
,	O
c	*(int)
,	O
VSE2SIZE	int
)	O
;	O
c	*(int)
+=	O
unicode_read	(*(struct(char,char)),*(int),int)->(int)
(	O
vse	*(struct(char,array(struct(char,char)),char,char,char,array(struct(char,char)),char,char,array(struct(char,char))))
->	O
text3	array(struct(char,char))
,	O
c	*(int)
,	O
VSE3SIZE	int
)	O
;	O
if	O
(	O
last_flag	char
)	O
*	O
c	*(int)
=	O
'\0'	O
;	O
}	O
static	O
dirCacheEntry_t	struct
*	O
vfat_lookup_loop_common	(*(struct),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int,*(int))->(*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)))
(	O
doscp_t	struct
*	O
cp	*(struct)
,	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
*	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
dirCache_t	struct(*(*(struct)),int,int,array(int),array(int),array(int))
*	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
int	O
lookForFreeSpace	int
,	O
int	O
*	O
io_error	*(int)
)	O
{	O
wchar_t	int
newfile	array(int)
[	O
13	int
]	O
;	O
int	O
initpos	int
=	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
+	O
1	int
;	O
struct	O
vfat_state	struct(array(int),int,int,char,int)
vfat	struct(array(int),int,int,char,int)
;	O
wchar_t	int
*	O
longname	*(char)
;	O
int	O
error	*(int)
;	O
int	O
endmarkSeen	int
=	O
0	int
;	O
*	O
io_error	*(int)
=	O
0	int
;	O
clear_vfat	(*(struct(array(int),int,int,char,int)))->(void)
(	O
&	O
vfat	struct(array(int),int,int,char,int)
)	O
;	O
while	O
(	O
1	int
)	O
{	O
++	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
;	O
if	O
(	O
!	O
dir_read	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(int))->(*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))))
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
&	O
error	*(int)
)	O
)	O
{	O
if	O
(	O
error	*(int)
)	O
{	O
*	O
io_error	*(int)
=	O
error	*(int)
;	O
return	O
NULL	O
;	O
}	O
addFreeEndEntry	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int,int,int)->(*(struct))
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
initpos	int
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
,	O
endmarkSeen	int
)	O
;	O
return	O
addEndEntry	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int)->(*(struct))
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
)	O
;	O
}	O
if	O
(	O
endmarkSeen	int
||	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
name	*(char)
[	O
0	int
]	O
==	O
ENDMARK	O
)	O
{	O
if	O
(	O
lookForFreeSpace	int
)	O
{	O
endmarkSeen	int
=	O
1	int
;	O
continue	O
;	O
}	O
return	O
addEndEntry	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int)->(*(struct))
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
)	O
;	O
}	O
if	O
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
name	*(char)
[	O
0	int
]	O
!=	O
DELMARK	O
&&	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
attr	char
==	O
0x0f	int
)	O
parse_vses	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct(array(int),int,int,char,int)))->(void)
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
&	O
vfat	struct(array(int),int,int,char,int)
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
name	*(char)
[	O
0	int
]	O
==	O
DELMARK	O
)	O
{	O
return	O
addFreeEntry	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int,int)->(*(struct))
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
initpos	int
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
+	O
1	int
)	O
;	O
}	O
check_vfat	(*(struct(array(int),int,int,char,int)),*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))))->(void)
(	O
&	O
vfat	struct(array(int),int,int,char,int)
,	O
&	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
)	O
;	O
if	O
(	O
!	O
vfat	struct(array(int),int,int,char,int)
.	O
present	int
)	O
vfat	struct(array(int),int,int,char,int)
.	O
subentries	int
=	O
0	int
;	O
addFreeEntry	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int,int)->(*(struct))
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
initpos	int
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
-	O
vfat	struct(array(int),int,int,char,int)
.	O
subentries	int
)	O
;	O
if	O
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
attr	char
&	O
0x8	int
)	O
{	O
wchar_t	int
*	O
ptr	*(int)
=	O
newfile	array(int)
;	O
if	O
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
name	*(char)
[	O
0	int
]	O
==	O
'\x05'	O
)	O
{	O
ptr	*(int)
+=	O
dos_to_wchar	(*(struct),*(char),*(int),long)->(int)
(	O
cp	*(struct)
,	O
"\xE5"	*(char)
,	O
ptr	*(int)
,	O
1	int
)	O
;	O
ptr	*(int)
+=	O
dos_to_wchar	(*(struct),*(char),*(int),long)->(int)
(	O
cp	*(struct)
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
name	*(char)
+	O
1	int
,	O
ptr	*(int)
,	O
7	int
)	O
;	O
}	O
else	O
{	O
ptr	*(int)
+=	O
dos_to_wchar	(*(struct),*(char),*(int),long)->(int)
(	O
cp	*(struct)
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
name	*(char)
,	O
ptr	*(int)
,	O
8	int
)	O
;	O
}	O
ptr	*(int)
+=	O
dos_to_wchar	(*(struct),*(char),*(int),long)->(int)
(	O
cp	*(struct)
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
ext	array(char)
,	O
ptr	*(int)
,	O
3	int
)	O
;	O
*	O
ptr	*(int)
=	O
'\0'	O
;	O
}	O
else	O
unix_name	(*(struct),*(char),*(char),char,*(int))->(*(int))
(	O
cp	*(struct)
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
name	*(char)
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
ext	array(char)
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
Case	char
,	O
newfile	array(int)
)	O
;	O
if	O
(	O
vfat	struct(array(int),int,int,char,int)
.	O
present	int
)	O
longname	*(char)
=	O
vfat	struct(array(int),int,int,char,int)
.	O
name	*(char)
;	O
else	O
longname	*(char)
=	O
0	int
;	O
return	O
addUsedEntry	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int,int,*(int),*(int),*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))))->(*(struct))
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
-	O
vfat	struct(array(int),int,int,char,int)
.	O
subentries	int
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
+	O
1	int
,	O
longname	*(char)
,	O
newfile	array(int)
,	O
&	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
)	O
;	O
}	O
static	O
__inline__	O
dirCacheEntry_t	struct
*	O
vfat_lookup_loop_for_read	(*(struct),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),*(int))->(*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)))
(	O
doscp_t	struct
*	O
cp	*(struct)
,	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
*	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
dirCache_t	struct(*(*(struct)),int,int,array(int),array(int),array(int))
*	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
int	O
*	O
io_error	*(int)
)	O
{	O
int	O
initpos	int
=	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
+	O
1	int
;	O
dirCacheEntry_t	struct
*	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
;	O
*	O
io_error	*(int)
=	O
0	int
;	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
=	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
->	O
entries	*(*(struct))
[	O
initpos	int
]	O
;	O
if	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
)	O
{	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
endSlot	int
-	O
1	int
;	O
return	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
;	O
}	O
else	O
{	O
return	O
vfat_lookup_loop_common	(*(struct),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int,*(int))->(*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)))
(	O
cp	*(struct)
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
0	int
,	O
io_error	*(int)
)	O
;	O
}	O
}	O
typedef	O
enum	O
result_t	enum(int,int,int,int)
{	O
RES_NOMATCH	int
,	O
RES_MATCH	int
,	O
RES_END	int
,	O
RES_ERROR	int
}	O
result_t	enum(int,int,int,int)
;	O
static	O
result_t	enum(int,int,int,int)
checkNameForMatch	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)),*(int),int,int)->(enum(int,int,int,int))
(	O
struct	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
*	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
dirCacheEntry_t	struct
*	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
,	O
const	O
wchar_t	int
*	O
filename	*(char)
,	O
int	O
length	int
,	O
int	O
flags	int
)	O
{	O
switch	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DCET_FREE	int
:	O
return	O
RES_NOMATCH	int
;	O
case	O
DCET_END	int
:	O
return	O
RES_END	int
;	O
case	O
DCET_USED	int
:	O
break	O
;	O
}	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
;	O
if	O
(	O
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
attr	char
&	O
0x8	int
)	O
&&	O
!	O
(	O
flags	int
&	O
ACCEPT_LABEL	int
)	O
)	O
return	O
RES_NOMATCH	int
;	O
if	O
(	O
!	O
(	O
(	O
flags	int
&	O
MATCH_ANY	int
)	O
||	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
longName	*(int)
&&	O
match	(*(int),*(int),*(int),int,int)->(int)
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
longName	*(int)
,	O
filename	*(char)
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
name	*(char)
,	O
0	int
,	O
length	int
)	O
)	O
||	O
match	(*(int),*(int),*(int),int,int)->(int)
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
shortName	*(int)
,	O
filename	*(char)
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
name	*(char)
,	O
1	int
,	O
length	int
)	O
)	O
)	O
{	O
return	O
RES_NOMATCH	int
;	O
}	O
if	O
(	O
IS_DIR	O
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
)	O
&&	O
!	O
(	O
flags	int
&	O
ACCEPT_DIR	int
)	O
)	O
{	O
if	O
(	O
!	O
(	O
flags	int
&	O
(	O
ACCEPT_LABEL	int
|	O
MATCH_ANY	int
|	O
NO_MSG	int
)	O
)	O
)	O
{	O
char	O
tmp	char
[	O
4	int
*	O
13	int
+	O
1	int
]	O
;	O
WCHAR_TO_NATIVE	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
shortName	*(int)
,	O
tmp	char
,	O
13	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Skipping \"%s\", is a directory\n"	*(char)
,	O
tmp	char
)	O
;	O
}	O
return	O
RES_NOMATCH	int
;	O
}	O
if	O
(	O
!	O
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
attr	char
&	O
(	O
ATTR_LABEL	int
|	O
ATTR_DIR	int
)	O
)	O
&&	O
!	O
(	O
flags	int
&	O
ACCEPT_PLAIN	int
)	O
)	O
{	O
if	O
(	O
!	O
(	O
flags	int
&	O
(	O
ACCEPT_LABEL	int
|	O
MATCH_ANY	int
|	O
NO_MSG	int
)	O
)	O
)	O
{	O
char	O
tmp	char
[	O
4	int
*	O
13	int
+	O
1	int
]	O
;	O
WCHAR_TO_NATIVE	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
shortName	*(int)
,	O
tmp	char
,	O
13	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Skipping \"%s\", is not a directory\n"	*(char)
,	O
tmp	char
)	O
;	O
}	O
return	O
RES_NOMATCH	int
;	O
}	O
return	O
RES_MATCH	int
;	O
}	O
int	O
vfat_lookup	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(char),int,int,*(char),long,*(char),long)->(int)
(	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
*	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
const	O
char	O
*	O
filename	*(char)
,	O
int	O
length	int
,	O
int	O
flags	int
,	O
char	O
*	O
shortname	*(char)
,	O
size_t	long
shortname_size	long
,	O
char	O
*	O
longname	*(char)
,	O
size_t	long
longname_size	long
)	O
{	O
dirCacheEntry_t	struct
*	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
;	O
result_t	enum(int,int,int,int)
result	enum(int,int,int,int)
;	O
dirCache_t	struct(*(*(struct)),int,int,array(int),array(int),array(int))
*	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
;	O
int	O
io_error	*(int)
;	O
wchar_t	int
wfilename	array(int)
[	O
MAX_VNAMELEN	O
+	O
1	int
]	O
;	O
doscp_t	struct
*	O
cp	*(struct)
=	O
GET_DOSCONVERT	O
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
;	O
if	O
(	O
length	int
==	O
-	O
1	int
&&	O
filename	*(char)
)	O
length	int
=	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
;	O
if	O
(	O
filename	*(char)
!=	O
NULL	O
)	O
length	int
=	O
native_to_wchar	(*(char),*(int),long,*(char),*(int))->(int)
(	O
filename	*(char)
,	O
wfilename	array(int)
,	O
MAX_VNAMELEN	O
,	O
filename	*(char)
+	O
length	int
,	O
0	int
)	O
;	O
else	O
length	int
=	O
0	int
;	O
if	O
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
==	O
-	O
2	int
)	O
return	O
-	O
1	int
;	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
=	O
allocDirCache	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),int)->(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))))
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Out of memory error in vfat_lookup [0]\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
do	O
{	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
=	O
vfat_lookup_loop_for_read	(*(struct),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),*(int))->(*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)))
(	O
cp	*(struct)
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
&	O
io_error	*(int)
)	O
;	O
if	O
(	O
!	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
)	O
{	O
if	O
(	O
io_error	*(int)
)	O
return	O
-	O
2	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Out of memory error in vfat_lookup\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
result	enum(int,int,int,int)
=	O
checkNameForMatch	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)),*(int),int,int)->(enum(int,int,int,int))
(	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
,	O
wfilename	array(int)
,	O
length	int
,	O
flags	int
)	O
;	O
}	O
while	O
(	O
result	enum(int,int,int,int)
==	O
RES_NOMATCH	int
)	O
;	O
if	O
(	O
result	enum(int,int,int,int)
==	O
RES_MATCH	int
)	O
{	O
if	O
(	O
longname	*(char)
)	O
{	O
if	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
longName	*(int)
)	O
wchar_to_native	(*(int),*(char),long,long)->(int)
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
longName	*(int)
,	O
longname	*(char)
,	O
MAX_VNAMELEN	O
,	O
longname_size	long
)	O
;	O
else	O
*	O
longname	*(char)
=	O
'\0'	O
;	O
}	O
if	O
(	O
shortname	*(char)
)	O
wchar_to_native	(*(int),*(char),long,long)->(int)
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
shortName	*(int)
,	O
shortname	*(char)
,	O
12	int
,	O
shortname_size	long
)	O
;	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
beginSlot	int
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
beginSlot	int
;	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
endSlot	int
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
endSlot	int
-	O
1	int
;	O
return	O
0	int
;	O
}	O
else	O
{	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
=	O
-	O
2	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
static	O
__inline__	O
dirCacheEntry_t	struct
*	O
vfat_lookup_loop_for_insert	(*(struct),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),int,*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))))->(*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)))
(	O
doscp_t	struct
*	O
cp	*(struct)
,	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
*	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
int	O
initpos	int
,	O
dirCache_t	struct(*(*(struct)),int,int,array(int),array(int),array(int))
*	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
)	O
{	O
dirCacheEntry_t	struct
*	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
;	O
int	O
io_error	*(int)
;	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
=	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
->	O
entries	*(*(struct))
[	O
initpos	int
]	O
;	O
if	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
&&	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
type	enum(int,int,int,int)
!=	O
DCET_END	int
)	O
{	O
return	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
;	O
}	O
else	O
{	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
entry	int
=	O
initpos	int
-	O
1	int
;	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
=	O
vfat_lookup_loop_common	(*(struct),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int,*(int))->(*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)))
(	O
cp	*(struct)
,	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
1	int
,	O
&	O
io_error	*(int)
)	O
;	O
if	O
(	O
!	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
)	O
{	O
if	O
(	O
io_error	*(int)
)	O
{	O
return	O
NULL	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Out of memory error in vfat_lookup_loop\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
->	O
entries	*(*(struct))
[	O
initpos	int
]	O
;	O
}	O
}	O
static	O
void	O
accountFreeSlots	(*(struct(int,int,int,int,int,int,int,int,int)),*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)))->(void)
(	O
struct	O
scan_state	struct(int,int,int,int,int,int,int,int,int)
*	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
,	O
dirCacheEntry_t	struct
*	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
)	O
{	O
if	O
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
got_slots	int
)	O
return	O
;	O
if	O
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_end	int
!=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
beginSlot	int
)	O
{	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_start	int
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
beginSlot	int
;	O
}	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_end	int
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
endSlot	int
;	O
if	O
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_end	int
-	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_start	int
>=	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
size_needed	int
)	O
{	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
got_slots	int
=	O
1	int
;	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
slot	int
=	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_start	int
+	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
size_needed	int
-	O
1	int
;	O
}	O
}	O
static	O
void	O
clear_scan	(*(int),int,*(struct(int,int,int,int,int,int,int,int,int)))->(void)
(	O
wchar_t	int
*	O
longname	*(char)
,	O
int	O
use_longname	int
,	O
struct	O
scan_state	struct(int,int,int,int,int,int,int,int,int)
*	O
s	*(struct(int,int,int,int,int,int,int,int,int))
)	O
{	O
s	*(struct(int,int,int,int,int,int,int,int,int))
->	O
shortmatch	int
=	O
s	*(struct(int,int,int,int,int,int,int,int,int))
->	O
longmatch	int
=	O
s	*(struct(int,int,int,int,int,int,int,int,int))
->	O
slot	int
=	O
-	O
1	int
;	O
s	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_end	int
=	O
s	*(struct(int,int,int,int,int,int,int,int,int))
->	O
got_slots	int
=	O
s	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_start	int
=	O
0	int
;	O
if	O
(	O
use_longname	int
&	O
1	int
)	O
s	*(struct(int,int,int,int,int,int,int,int,int))
->	O
size_needed	int
=	O
1	int
+	O
(	O
wcslen	(*(int))->(long)
(	O
longname	*(char)
)	O
+	O
VSE_NAMELEN	int
-	O
1	int
)	O
/	O
VSE_NAMELEN	int
;	O
else	O
s	*(struct(int,int,int,int,int,int,int,int,int))
->	O
size_needed	int
=	O
1	int
;	O
}	O
int	O
lookupForInsert	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct),*(char),*(struct(int,int,int,int,int,int,int,int,int)),int,int,int,int)->(int)
(	O
Stream_t	struct(*(struct),int,*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))))
*	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
struct	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
*	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
,	O
dos_name_t	struct
*	O
dosname	*(struct)
,	O
char	O
*	O
longname	*(char)
,	O
struct	O
scan_state	struct(int,int,int,int,int,int,int,int,int)
*	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
,	O
int	O
ignore_entry	int
,	O
int	O
source_entry	int
,	O
int	O
pessimisticShortRename	int
,	O
int	O
use_longname	int
)	O
{	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
entry	int
;	O
int	O
ignore_match	int
;	O
dirCacheEntry_t	struct
*	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
;	O
dirCache_t	struct(*(*(struct)),int,int,array(int),array(int),array(int))
*	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
;	O
int	O
pos	array(char)
;	O
wchar_t	int
shortName	*(int)
[	O
13	int
]	O
;	O
wchar_t	int
wlongname	array(int)
[	O
MAX_VNAMELEN	O
+	O
1	int
]	O
;	O
doscp_t	struct
*	O
cp	*(struct)
=	O
GET_DOSCONVERT	O
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
;	O
native_to_wchar	(*(char),*(int),long,*(char),*(int))->(int)
(	O
longname	*(char)
,	O
wlongname	array(int)
,	O
MAX_VNAMELEN	O
+	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
clear_scan	(*(int),int,*(struct(int,int,int,int,int,int,int,int,int)))->(void)
(	O
wlongname	array(int)
,	O
use_longname	int
,	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
ignore_match	int
=	O
(	O
ignore_entry	int
==	O
-	O
2	int
)	O
;	O
initializeDirentry	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))))->(void)
(	O
&	O
entry	int
,	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
;	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
match_free	int
=	O
0	int
;	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
=	O
allocDirCache	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),int)->(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))))
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
1	int
)	O
;	O
if	O
(	O
!	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Out of memory error in lookupForInsert\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
ignore_match	int
)	O
unix_name	(*(struct),*(char),*(char),char,*(int))->(*(int))
(	O
cp	*(struct)
,	O
dosname	*(struct)
->	O
base	int
,	O
dosname	*(struct)
->	O
ext	array(char)
,	O
0	int
,	O
shortName	*(int)
)	O
;	O
pos	array(char)
=	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
->	O
nrHashed	int
;	O
if	O
(	O
source_entry	int
>=	O
0	int
||	O
(	O
pos	array(char)
&&	O
isHashed	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),*(int))->(int)
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
wlongname	array(int)
)	O
)	O
)	O
{	O
pos	array(char)
=	O
0	int
;	O
}	O
else	O
if	O
(	O
pos	array(char)
&&	O
!	O
ignore_match	int
&&	O
isHashed	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),*(int))->(int)
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
shortName	*(int)
)	O
)	O
{	O
if	O
(	O
pessimisticShortRename	int
)	O
{	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
shortmatch	int
=	O
-	O
2	int
;	O
return	O
1	int
;	O
}	O
pos	array(char)
=	O
0	int
;	O
}	O
else	O
if	O
(	O
growDirCache	(*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))),int)->(int)
(	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
,	O
pos	array(char)
)	O
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Out of memory error in vfat_looup [0]\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
do	O
{	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
=	O
vfat_lookup_loop_for_insert	(*(struct),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),int,*(struct(*(*(struct`)),int,int,array(int),array(int),array(int))))->(*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)))
(	O
cp	*(struct)
,	O
&	O
entry	int
,	O
pos	array(char)
,	O
cache	*(struct(*(*(struct)),int,int,array(int),array(int),array(int)))
)	O
;	O
switch	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DCET_FREE	int
:	O
accountFreeSlots	(*(struct(int,int,int,int,int,int,int,int,int)),*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)))->(void)
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
,	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
)	O
;	O
break	O
;	O
case	O
DCET_USED	int
:	O
if	O
(	O
!	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
attr	char
&	O
0x8	int
)	O
&&	O
(	O
signed	O
int	O
)	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
endSlot	int
-	O
1	int
==	O
source_entry	int
)	O
accountFreeSlots	(*(struct(int,int,int,int,int,int,int,int,int)),*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int)))->(void)
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
,	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
)	O
;	O
if	O
(	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
attr	char
&	O
0x8	int
)	O
||	O
(	O
(	O
signed	O
int	O
)	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
endSlot	int
-	O
1	int
==	O
ignore_entry	int
)	O
)	O
break	O
;	O
if	O
(	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
longName	*(int)
&&	O
!	O
wcscasecmp	(*(int),*(int))->(int)
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
longName	*(int)
,	O
wlongname	array(int)
)	O
)	O
||	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
shortName	*(int)
&&	O
!	O
wcscasecmp	(*(int),*(int))->(int)
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
shortName	*(int)
,	O
wlongname	array(int)
)	O
)	O
)	O
{	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
longmatch	int
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
endSlot	int
-	O
1	int
;	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
beginSlot	int
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
beginSlot	int
;	O
direntry	*(struct(*(struct(*(struct`),int,*(struct`),*(struct`))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int))
->	O
endSlot	int
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
endSlot	int
-	O
1	int
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
ignore_match	int
&&	O
!	O
wcscasecmp	(*(int),*(int))->(int)
(	O
shortName	*(int)
,	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
shortName	*(int)
)	O
)	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
shortmatch	int
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
endSlot	int
-	O
1	int
;	O
break	O
;	O
case	O
DCET_END	int
:	O
break	O
;	O
}	O
pos	array(char)
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
endSlot	int
;	O
}	O
while	O
(	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
type	enum(int,int,int,int)
!=	O
DCET_END	int
)	O
;	O
if	O
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
shortmatch	int
>	O
-	O
1	int
)	O
return	O
1	int
;	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
max_entry	int
=	O
dce	*(struct(enum(int,int,int),int,int,*(int),*(int),struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),int))
->	O
beginSlot	int
;	O
if	O
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
got_slots	int
)	O
return	O
6	int
;	O
if	O
(	O
!	O
isRootDir	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))))->(int)
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
)	O
return	O
5	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"No directory slots\n"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
