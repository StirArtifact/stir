static	O
void	O
_prepare_chord_table	(double,array(double))->(void)
(	O
double	O
sagitta	double
,	O
double	O
custom_chord_table	array(double)
[	O
TABULATED_ARC_SUBDIVISIONS	int
]	O
)	O
;	O
static	O
void	O
_fakearc	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),int,*(double),array(double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
p0	struct(double,double)
,	O
plPoint	struct(double,double)
p1	struct(double,double)
,	O
int	O
arc_type	int
,	O
const	O
double	O
*	O
custom_chord_table	array(double)
,	O
const	O
double	O
m	array(double)
[	O
4	int
]	O
)	O
;	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
_new_plPath	()->(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
(	O
void	O
)	O
{	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
=	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
=	O
PATH_SEGMENT_LIST	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
NULL	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
=	O
0	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
=	O
0	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
primitive	enum(int,int)
=	O
false	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
llx	double
=	O
DBL_MAX	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
lly	double
=	O
DBL_MAX	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
urx	double
=	O
-	O
(	O
DBL_MAX	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
ury	double
=	O
-	O
(	O
DBL_MAX	O
)	O
;	O
return	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
;	O
}	O
void	O
_delete_plPath	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
==	O
PATH_SEGMENT_LIST	int
&&	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
>	O
0	int
)	O
free	(*(void))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
free	(*(void))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
)	O
;	O
}	O
void	O
_reset_plPath	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
==	O
PATH_SEGMENT_LIST	int
&&	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
>	O
0	int
)	O
free	(*(void))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
NULL	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
=	O
0	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
=	O
PATH_SEGMENT_LIST	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
=	O
0	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
primitive	enum(int,int)
=	O
false	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
llx	double
=	O
DBL_MAX	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
lly	double
=	O
DBL_MAX	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
urx	double
=	O
-	O
(	O
DBL_MAX	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
ury	double
=	O
-	O
(	O
DBL_MAX	O
)	O
;	O
}	O
void	O
_add_moveto	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
p	struct(double,double)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
0	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_MOVETO	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
0	int
]	O
.	O
p	struct(double,double)
=	O
p	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
=	O
1	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
llx	double
=	O
p	struct(double,double)
.	O
x	double
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
lly	double
=	O
p	struct(double,double)
.	O
y	double
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
urx	double
=	O
p	struct(double,double)
.	O
x	double
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
ury	double
=	O
p	struct(double,double)
.	O
y	double
;	O
}	O
void	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
p	struct(double,double)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
{	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
}	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
)	O
{	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xrealloc	(*(void),long)->(*(void))
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
2	int
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_LINE	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
p	struct(double,double)
=	O
p	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
++	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
llx	double
=	O
DMIN	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
llx	double
,	O
p	struct(double,double)
.	O
x	double
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
lly	double
=	O
DMIN	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
lly	double
,	O
p	struct(double,double)
.	O
y	double
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
urx	double
=	O
DMAX	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
urx	double
,	O
p	struct(double,double)
.	O
x	double
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
ury	double
=	O
DMAX	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
ury	double
,	O
p	struct(double,double)
.	O
y	double
)	O
;	O
}	O
void	O
_add_closepath	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
)	O
{	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xrealloc	(*(void),long)->(*(void))
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
2	int
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_CLOSEPATH	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
p	struct(double,double)
=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
0	int
]	O
.	O
p	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
++	O
;	O
}	O
void	O
_add_bezier2	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
plPoint	struct(double,double)
p	struct(double,double)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
{	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
}	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
)	O
{	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xrealloc	(*(void),long)->(*(void))
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
2	int
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_QUAD	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
p	struct(double,double)
=	O
p	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
pc	struct(double,double)
=	O
pc	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
++	O
;	O
}	O
void	O
_add_bezier3	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
plPoint	struct(double,double)
pd	struct(double,double)
,	O
plPoint	struct(double,double)
p	struct(double,double)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
{	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
}	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
)	O
{	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xrealloc	(*(void),long)->(*(void))
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
2	int
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_CUBIC	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
p	struct(double,double)
=	O
p	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
pc	struct(double,double)
=	O
pc	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
pd	struct(double,double)
=	O
pd	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
++	O
;	O
}	O
void	O
_add_arc	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
plPoint	struct(double,double)
p1	struct(double,double)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
{	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
}	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
)	O
{	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xrealloc	(*(void),long)->(*(void))
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
2	int
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_ARC	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
p	struct(double,double)
=	O
p1	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
pc	struct(double,double)
=	O
pc	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
++	O
;	O
}	O
void	O
_add_ellarc	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
plPoint	struct(double,double)
p1	struct(double,double)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
{	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
DATAPOINTS_BUFSIZ	O
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
=	O
DATAPOINTS_BUFSIZ	O
;	O
}	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
)	O
{	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xrealloc	(*(void),long)->(*(void))
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
2	int
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
*=	O
2	int
;	O
}	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_ELLARC	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
p	struct(double,double)
=	O
p1	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
pc	struct(double,double)
=	O
pc	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
++	O
;	O
}	O
void	O
_add_box	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),enum(int,int))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
p0	struct(double,double)
,	O
plPoint	struct(double,double)
p1	struct(double,double)
,	O
bool	enum(int,int)
clockwise	enum(int,int)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
=	O
PATH_BOX	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
p0	struct(double,double)
=	O
p0	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
p1	struct(double,double)
=	O
p1	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
clockwise	enum(int,int)
=	O
clockwise	enum(int,int)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
llx	double
=	O
DMIN	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
llx	double
,	O
p0	struct(double,double)
.	O
x	double
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
lly	double
=	O
DMIN	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
lly	double
,	O
p0	struct(double,double)
.	O
y	double
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
urx	double
=	O
DMAX	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
urx	double
,	O
p0	struct(double,double)
.	O
x	double
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
ury	double
=	O
DMAX	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
ury	double
,	O
p0	struct(double,double)
.	O
y	double
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
llx	double
=	O
DMIN	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
llx	double
,	O
p1	struct(double,double)
.	O
x	double
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
lly	double
=	O
DMIN	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
lly	double
,	O
p1	struct(double,double)
.	O
y	double
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
urx	double
=	O
DMAX	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
urx	double
,	O
p1	struct(double,double)
.	O
x	double
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
ury	double
=	O
DMAX	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
ury	double
,	O
p1	struct(double,double)
.	O
y	double
)	O
;	O
}	O
void	O
_add_circle	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,enum(int,int))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
double	O
radius	double
,	O
bool	enum(int,int)
clockwise	enum(int,int)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
=	O
PATH_CIRCLE	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
pc	struct(double,double)
=	O
pc	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
radius	double
=	O
radius	double
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
clockwise	enum(int,int)
=	O
clockwise	enum(int,int)
;	O
}	O
void	O
_add_ellipse	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,double,double,enum(int,int))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
,	O
bool	enum(int,int)
clockwise	enum(int,int)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
=	O
PATH_ELLIPSE	int
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
pc	struct(double,double)
=	O
pc	struct(double,double)
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
rx	double
=	O
rx	double
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
ry	double
=	O
ry	double
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
angle	double
=	O
angle	double
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
clockwise	enum(int,int)
=	O
clockwise	enum(int,int)
;	O
}	O
void	O
_add_arc_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
plPoint	struct(double,double)
p1	struct(double,double)
)	O
{	O
plPoint	struct(double,double)
p0	struct(double,double)
;	O
plPoint	struct(double,double)
pb	struct(double,double)
,	O
pm	struct(double,double)
;	O
double	O
m	array(double)
[	O
4	int
]	O
;	O
plVector	struct(double,double)
v	*(struct(double,double))
,	O
v0	struct(double,double)
,	O
v1	struct(double,double)
;	O
double	O
radius	double
,	O
sagitta	double
;	O
double	O
cross	double
,	O
orientation	int
;	O
double	O
custom_chord_table	array(double)
[	O
TABULATED_ARC_SUBDIVISIONS	int
]	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct(double,double)
=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct(double,double)
;	O
if	O
(	O
p0	struct(double,double)
.	O
x	double
==	O
p1	struct(double,double)
.	O
x	double
&&	O
p0	struct(double,double)
.	O
y	double
==	O
p1	struct(double,double)
.	O
y	double
)	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
p0	struct(double,double)
)	O
;	O
else	O
{	O
v0	struct(double,double)
.	O
x	double
=	O
p0	struct(double,double)
.	O
x	double
-	O
pc	struct(double,double)
.	O
x	double
;	O
v0	struct(double,double)
.	O
y	double
=	O
p0	struct(double,double)
.	O
y	double
-	O
pc	struct(double,double)
.	O
y	double
;	O
v1	struct(double,double)
.	O
x	double
=	O
p1	struct(double,double)
.	O
x	double
-	O
pc	struct(double,double)
.	O
x	double
;	O
v1	struct(double,double)
.	O
y	double
=	O
p1	struct(double,double)
.	O
y	double
-	O
pc	struct(double,double)
.	O
y	double
;	O
cross	double
=	O
v0	struct(double,double)
.	O
x	double
*	O
v1	struct(double,double)
.	O
y	double
-	O
v1	struct(double,double)
.	O
x	double
*	O
v0	struct(double,double)
.	O
y	double
;	O
orientation	int
=	O
(	O
cross	double
>=	O
0.0	int
?	O
1.0	int
:	O
-	O
1.0	int
)	O
;	O
radius	double
=	O
DIST	O
(	O
pc	struct(double,double)
,	O
p0	struct(double,double)
)	O
;	O
pm	struct(double,double)
.	O
x	double
=	O
0.5	int
*	O
(	O
p0	struct(double,double)
.	O
x	double
+	O
p1	struct(double,double)
.	O
x	double
)	O
;	O
pm	struct(double,double)
.	O
y	double
=	O
0.5	int
*	O
(	O
p0	struct(double,double)
.	O
y	double
+	O
p1	struct(double,double)
.	O
y	double
)	O
;	O
v	*(struct(double,double))
.	O
x	double
=	O
p1	struct(double,double)
.	O
x	double
-	O
p0	struct(double,double)
.	O
x	double
;	O
v	*(struct(double,double))
.	O
y	double
=	O
p1	struct(double,double)
.	O
y	double
-	O
p0	struct(double,double)
.	O
y	double
;	O
_vscale	(*(struct(double,double)),double)->(*(struct(double,double)))
(	O
&	O
v	*(struct(double,double))
,	O
radius	double
)	O
;	O
pb	struct(double,double)
.	O
x	double
=	O
pc	struct(double,double)
.	O
x	double
+	O
orientation	int
*	O
v	*(struct(double,double))
.	O
y	double
;	O
pb	struct(double,double)
.	O
y	double
=	O
pc	struct(double,double)
.	O
y	double
-	O
orientation	int
*	O
v	*(struct(double,double))
.	O
x	double
;	O
sagitta	double
=	O
DIST	O
(	O
pb	struct(double,double)
,	O
pm	struct(double,double)
)	O
/	O
radius	double
;	O
_prepare_chord_table	(double,array(double))->(void)
(	O
sagitta	double
,	O
custom_chord_table	array(double)
)	O
;	O
m	array(double)
[	O
0	int
]	O
=	O
0.0	int
,	O
m	array(double)
[	O
1	int
]	O
=	O
orientation	int
,	O
m	array(double)
[	O
2	int
]	O
=	O
-	O
orientation	int
,	O
m	array(double)
[	O
3	int
]	O
=	O
0.0	int
;	O
_fakearc	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),int,*(double),array(double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
p0	struct(double,double)
,	O
p1	struct(double,double)
,	O
USER_DEFINED_ARC	O
,	O
custom_chord_table	array(double)
,	O
m	array(double)
)	O
;	O
}	O
}	O
void	O
_add_ellarc_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
plPoint	struct(double,double)
p1	struct(double,double)
)	O
{	O
plPoint	struct(double,double)
p0	struct(double,double)
;	O
plVector	struct(double,double)
v0	struct(double,double)
,	O
v1	struct(double,double)
;	O
double	O
cross	double
;	O
double	O
m	array(double)
[	O
4	int
]	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct(double,double)
=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct(double,double)
;	O
v0	struct(double,double)
.	O
x	double
=	O
p0	struct(double,double)
.	O
x	double
-	O
pc	struct(double,double)
.	O
x	double
;	O
v0	struct(double,double)
.	O
y	double
=	O
p0	struct(double,double)
.	O
y	double
-	O
pc	struct(double,double)
.	O
y	double
;	O
v1	struct(double,double)
.	O
x	double
=	O
p1	struct(double,double)
.	O
x	double
-	O
pc	struct(double,double)
.	O
x	double
;	O
v1	struct(double,double)
.	O
y	double
=	O
p1	struct(double,double)
.	O
y	double
-	O
pc	struct(double,double)
.	O
y	double
;	O
cross	double
=	O
v0	struct(double,double)
.	O
x	double
*	O
v1	struct(double,double)
.	O
y	double
-	O
v1	struct(double,double)
.	O
x	double
*	O
v0	struct(double,double)
.	O
y	double
;	O
if	O
(	O
FROUND	O
(	O
cross	double
)	O
==	O
0.0	int
)	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
p1	struct(double,double)
)	O
;	O
else	O
{	O
m	array(double)
[	O
0	int
]	O
=	O
-	O
(	O
v0	struct(double,double)
.	O
x	double
*	O
v0	struct(double,double)
.	O
y	double
+	O
v1	struct(double,double)
.	O
x	double
*	O
v1	struct(double,double)
.	O
y	double
)	O
/	O
cross	double
;	O
m	array(double)
[	O
1	int
]	O
=	O
(	O
v0	struct(double,double)
.	O
x	double
*	O
v0	struct(double,double)
.	O
x	double
+	O
v1	struct(double,double)
.	O
x	double
*	O
v1	struct(double,double)
.	O
x	double
)	O
/	O
cross	double
;	O
m	array(double)
[	O
2	int
]	O
=	O
-	O
(	O
v0	struct(double,double)
.	O
y	double
*	O
v0	struct(double,double)
.	O
y	double
+	O
v1	struct(double,double)
.	O
y	double
*	O
v1	struct(double,double)
.	O
y	double
)	O
/	O
cross	double
;	O
m	array(double)
[	O
3	int
]	O
=	O
(	O
v0	struct(double,double)
.	O
x	double
*	O
v0	struct(double,double)
.	O
y	double
+	O
v1	struct(double,double)
.	O
x	double
*	O
v1	struct(double,double)
.	O
y	double
)	O
/	O
cross	double
;	O
_fakearc	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),int,*(double),array(double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
p0	struct(double,double)
,	O
p1	struct(double,double)
,	O
QUARTER_ARC	int
,	O
(	O
double	O
*	O
)	O
NULL	O
,	O
m	array(double)
)	O
;	O
}	O
}	O
void	O
_add_arc_as_bezier3	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
plPoint	struct(double,double)
p1	struct(double,double)
)	O
{	O
plPoint	struct(double,double)
p0	struct(double,double)
;	O
plVector	struct(double,double)
v0	struct(double,double)
,	O
v1	struct(double,double)
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct(double,double)
=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct(double,double)
;	O
v0	struct(double,double)
.	O
x	double
=	O
p0	struct(double,double)
.	O
x	double
-	O
pc	struct(double,double)
.	O
x	double
;	O
v0	struct(double,double)
.	O
y	double
=	O
p0	struct(double,double)
.	O
y	double
-	O
pc	struct(double,double)
.	O
y	double
;	O
v1	struct(double,double)
.	O
x	double
=	O
p1	struct(double,double)
.	O
x	double
-	O
pc	struct(double,double)
.	O
x	double
;	O
v1	struct(double,double)
.	O
y	double
=	O
p1	struct(double,double)
.	O
y	double
-	O
pc	struct(double,double)
.	O
y	double
;	O
if	O
(	O
(	O
v0	struct(double,double)
.	O
x	double
==	O
0.0	int
&&	O
v0	struct(double,double)
.	O
y	double
==	O
0.0	int
)	O
||	O
(	O
v1	struct(double,double)
.	O
x	double
==	O
0.0	int
&&	O
v1	struct(double,double)
.	O
y	double
==	O
0.0	int
)	O
||	O
(	O
v0	struct(double,double)
.	O
x	double
==	O
v1	struct(double,double)
.	O
x	double
&&	O
v0	struct(double,double)
.	O
y	double
==	O
v1	struct(double,double)
.	O
y	double
)	O
)	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
p1	struct(double,double)
)	O
;	O
else	O
{	O
double	O
oldangle	double
,	O
newangle	double
,	O
anglerange	int
;	O
double	O
cross	double
;	O
int	O
orientation	int
;	O
cross	double
=	O
v0	struct(double,double)
.	O
x	double
*	O
v1	struct(double,double)
.	O
y	double
-	O
v1	struct(double,double)
.	O
x	double
*	O
v0	struct(double,double)
.	O
y	double
;	O
orientation	int
=	O
(	O
cross	double
>=	O
0.0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
oldangle	double
=	O
_xatan2	(double,double)->(double)
(	O
v0	struct(double,double)
.	O
y	double
,	O
v0	struct(double,double)
.	O
x	double
)	O
;	O
newangle	double
=	O
_xatan2	(double,double)->(double)
(	O
v1	struct(double,double)
.	O
y	double
,	O
v1	struct(double,double)
.	O
x	double
)	O
;	O
anglerange	int
=	O
newangle	double
-	O
oldangle	double
;	O
if	O
(	O
anglerange	int
>	O
M_PI	int
)	O
anglerange	int
-=	O
(	O
2	int
*	O
M_PI	int
)	O
;	O
if	O
(	O
anglerange	int
<=	O
-	O
(	O
M_PI	int
)	O
)	O
anglerange	int
+=	O
(	O
2	int
*	O
M_PI	int
)	O
;	O
if	O
(	O
FABS	O
(	O
anglerange	int
)	O
>	O
0.51	int
*	O
M_PI	int
)	O
{	O
double	O
radius	double
;	O
plPoint	struct(double,double)
pb	struct(double,double)
;	O
plVector	struct(double,double)
v	*(struct(double,double))
;	O
radius	double
=	O
DIST	O
(	O
pc	struct(double,double)
,	O
p0	struct(double,double)
)	O
;	O
v	*(struct(double,double))
.	O
x	double
=	O
p1	struct(double,double)
.	O
x	double
-	O
p0	struct(double,double)
.	O
x	double
;	O
v	*(struct(double,double))
.	O
y	double
=	O
p1	struct(double,double)
.	O
y	double
-	O
p0	struct(double,double)
.	O
y	double
;	O
_vscale	(*(struct(double,double)),double)->(*(struct(double,double)))
(	O
&	O
v	*(struct(double,double))
,	O
radius	double
)	O
;	O
pb	struct(double,double)
.	O
x	double
=	O
pc	struct(double,double)
.	O
x	double
+	O
orientation	int
*	O
v	*(struct(double,double))
.	O
y	double
;	O
pb	struct(double,double)
.	O
y	double
=	O
pc	struct(double,double)
.	O
y	double
-	O
orientation	int
*	O
v	*(struct(double,double))
.	O
x	double
;	O
_add_arc_as_bezier3	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
pb	struct(double,double)
)	O
;	O
_add_arc_as_bezier3	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
p1	struct(double,double)
)	O
;	O
}	O
else	O
{	O
double	O
halfangle	double
,	O
sinhalf	double
,	O
coshalf	double
,	O
kappa	double
;	O
plPoint	struct(double,double)
pc_bezier3	struct(double,double)
,	O
pd_bezier3	struct(double,double)
;	O
halfangle	double
=	O
0.5	int
*	O
FABS	O
(	O
anglerange	int
)	O
;	O
sinhalf	double
=	O
sin	(double)->(double)
(	O
halfangle	double
)	O
;	O
coshalf	double
=	O
cos	(double)->(double)
(	O
halfangle	double
)	O
;	O
if	O
(	O
FABS	O
(	O
sinhalf	double
)	O
<	O
0.5	int
)	O
kappa	double
=	O
(	O
4.0	int
/	O
3.0	int
)	O
*	O
sinhalf	double
/	O
(	O
1.0	int
+	O
coshalf	double
)	O
;	O
else	O
kappa	double
=	O
(	O
4.0	int
/	O
3.0	int
)	O
*	O
(	O
1.0	int
-	O
coshalf	double
)	O
/	O
sinhalf	double
;	O
pc_bezier3	struct(double,double)
.	O
x	double
=	O
p0	struct(double,double)
.	O
x	double
-	O
kappa	double
*	O
orientation	int
*	O
v0	struct(double,double)
.	O
y	double
;	O
pc_bezier3	struct(double,double)
.	O
y	double
=	O
p0	struct(double,double)
.	O
y	double
+	O
kappa	double
*	O
orientation	int
*	O
v0	struct(double,double)
.	O
x	double
;	O
pd_bezier3	struct(double,double)
.	O
x	double
=	O
p1	struct(double,double)
.	O
x	double
+	O
kappa	double
*	O
orientation	int
*	O
v1	struct(double,double)
.	O
y	double
;	O
pd_bezier3	struct(double,double)
.	O
y	double
=	O
p1	struct(double,double)
.	O
y	double
-	O
kappa	double
*	O
orientation	int
*	O
v1	struct(double,double)
.	O
x	double
;	O
_add_bezier3	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc_bezier3	struct(double,double)
,	O
pd_bezier3	struct(double,double)
,	O
p1	struct(double,double)
)	O
;	O
}	O
}	O
}	O
void	O
_add_ellarc_as_bezier3	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
plPoint	struct(double,double)
p1	struct(double,double)
)	O
{	O
plPoint	struct(double,double)
p0	struct(double,double)
,	O
pc_bezier3	struct(double,double)
,	O
pd_bezier3	struct(double,double)
;	O
plVector	struct(double,double)
v0	struct(double,double)
,	O
v1	struct(double,double)
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct(double,double)
=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct(double,double)
;	O
v0	struct(double,double)
.	O
x	double
=	O
p0	struct(double,double)
.	O
x	double
-	O
pc	struct(double,double)
.	O
x	double
;	O
v0	struct(double,double)
.	O
y	double
=	O
p0	struct(double,double)
.	O
y	double
-	O
pc	struct(double,double)
.	O
y	double
;	O
v1	struct(double,double)
.	O
x	double
=	O
p1	struct(double,double)
.	O
x	double
-	O
pc	struct(double,double)
.	O
x	double
;	O
v1	struct(double,double)
.	O
y	double
=	O
p1	struct(double,double)
.	O
y	double
-	O
pc	struct(double,double)
.	O
y	double
;	O
pc_bezier3	struct(double,double)
.	O
x	double
=	O
p0	struct(double,double)
.	O
x	double
+	O
KAPPA_FOR_QUARTER_CIRCLE	int
*	O
v1	struct(double,double)
.	O
x	double
;	O
pc_bezier3	struct(double,double)
.	O
y	double
=	O
p0	struct(double,double)
.	O
y	double
+	O
KAPPA_FOR_QUARTER_CIRCLE	int
*	O
v1	struct(double,double)
.	O
y	double
;	O
pd_bezier3	struct(double,double)
.	O
x	double
=	O
p1	struct(double,double)
.	O
x	double
+	O
KAPPA_FOR_QUARTER_CIRCLE	int
*	O
v0	struct(double,double)
.	O
x	double
;	O
pd_bezier3	struct(double,double)
.	O
y	double
=	O
p1	struct(double,double)
.	O
y	double
+	O
KAPPA_FOR_QUARTER_CIRCLE	int
*	O
v0	struct(double,double)
.	O
y	double
;	O
_add_bezier3	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc_bezier3	struct(double,double)
,	O
pd_bezier3	struct(double,double)
,	O
p1	struct(double,double)
)	O
;	O
}	O
void	O
_add_bezier2_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
plPoint	struct(double,double)
p	struct(double,double)
)	O
{	O
plPoint	struct(double,double)
r0	array(struct(double,double))
[	O
MAX_NUM_BEZIER2_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
r1	array(struct(double,double))
[	O
MAX_NUM_BEZIER2_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
r2	array(struct(double,double))
[	O
MAX_NUM_BEZIER2_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
level	int
[	O
MAX_NUM_BEZIER2_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
n	array(double)
=	O
0	int
;	O
int	O
segments_drawn	int
=	O
0	int
;	O
plPoint	struct(double,double)
p0	struct(double,double)
;	O
double	O
sqdist	double
,	O
max_squared_length	double
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct(double,double)
=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct(double,double)
;	O
sqdist	double
=	O
(	O
p	struct(double,double)
.	O
x	double
-	O
p0	struct(double,double)
.	O
x	double
)	O
*	O
(	O
p	struct(double,double)
.	O
x	double
-	O
p0	struct(double,double)
.	O
x	double
)	O
+	O
(	O
p	struct(double,double)
.	O
y	double
-	O
p0	struct(double,double)
.	O
y	double
)	O
*	O
(	O
p	struct(double,double)
.	O
y	double
-	O
p0	struct(double,double)
.	O
y	double
)	O
;	O
max_squared_length	double
=	O
REL_QUAD_FLATNESS	int
*	O
REL_QUAD_FLATNESS	int
*	O
sqdist	double
;	O
r0	array(struct(double,double))
[	O
0	int
]	O
=	O
p0	struct(double,double)
;	O
r1	array(struct(double,double))
[	O
0	int
]	O
=	O
pc	struct(double,double)
;	O
r2	array(struct(double,double))
[	O
0	int
]	O
=	O
p	struct(double,double)
;	O
level	int
[	O
0	int
]	O
=	O
0	int
;	O
while	O
(	O
n	array(double)
>=	O
0	int
)	O
{	O
int	O
current_level	int
;	O
plPoint	struct(double,double)
q0	struct(double,double)
,	O
q1	struct(double,double)
,	O
q2	struct(double,double)
;	O
current_level	int
=	O
level	int
[	O
n	array(double)
]	O
;	O
q0	struct(double,double)
=	O
r0	array(struct(double,double))
[	O
n	array(double)
]	O
;	O
q1	struct(double,double)
=	O
r1	array(struct(double,double))
[	O
n	array(double)
]	O
;	O
q2	struct(double,double)
=	O
r2	array(struct(double,double))
[	O
n	array(double)
]	O
;	O
if	O
(	O
current_level	int
>=	O
MAX_NUM_BEZIER2_SUBDIVISIONS	int
)	O
{	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
q2	struct(double,double)
)	O
;	O
segments_drawn	int
++	O
;	O
n	array(double)
--	O
;	O
}	O
else	O
{	O
plPoint	struct(double,double)
qq0	struct(double,double)
,	O
qq1	struct(double,double)
;	O
plPoint	struct(double,double)
qqq0	struct(double,double)
;	O
plVector	struct(double,double)
vec1	struct(double,double)
;	O
vec1	struct(double,double)
.	O
x	double
=	O
q0	struct(double,double)
.	O
x	double
-	O
2	int
*	O
q1	struct(double,double)
.	O
x	double
+	O
q2	struct(double,double)
.	O
x	double
;	O
vec1	struct(double,double)
.	O
y	double
=	O
q0	struct(double,double)
.	O
y	double
-	O
2	int
*	O
q1	struct(double,double)
.	O
y	double
+	O
q2	struct(double,double)
.	O
y	double
;	O
if	O
(	O
vec1	struct(double,double)
.	O
x	double
*	O
vec1	struct(double,double)
.	O
x	double
+	O
vec1	struct(double,double)
.	O
y	double
*	O
vec1	struct(double,double)
.	O
y	double
<	O
max_squared_length	double
)	O
{	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
q2	struct(double,double)
)	O
;	O
segments_drawn	int
++	O
;	O
n	array(double)
--	O
;	O
}	O
else	O
{	O
qq0	struct(double,double)
.	O
x	double
=	O
MIDWAY	O
(	O
q0	struct(double,double)
.	O
x	double
,	O
q1	struct(double,double)
.	O
x	double
)	O
;	O
qq0	struct(double,double)
.	O
y	double
=	O
MIDWAY	O
(	O
q0	struct(double,double)
.	O
y	double
,	O
q1	struct(double,double)
.	O
y	double
)	O
;	O
qq1	struct(double,double)
.	O
x	double
=	O
MIDWAY	O
(	O
q1	struct(double,double)
.	O
x	double
,	O
q2	struct(double,double)
.	O
x	double
)	O
;	O
qq1	struct(double,double)
.	O
y	double
=	O
MIDWAY	O
(	O
q1	struct(double,double)
.	O
y	double
,	O
q2	struct(double,double)
.	O
y	double
)	O
;	O
qqq0	struct(double,double)
.	O
x	double
=	O
MIDWAY	O
(	O
qq0	struct(double,double)
.	O
x	double
,	O
qq1	struct(double,double)
.	O
x	double
)	O
;	O
qqq0	struct(double,double)
.	O
y	double
=	O
MIDWAY	O
(	O
qq0	struct(double,double)
.	O
y	double
,	O
qq1	struct(double,double)
.	O
y	double
)	O
;	O
r0	array(struct(double,double))
[	O
n	array(double)
+	O
1	int
]	O
=	O
q0	struct(double,double)
;	O
r1	array(struct(double,double))
[	O
n	array(double)
+	O
1	int
]	O
=	O
qq0	struct(double,double)
;	O
r2	array(struct(double,double))
[	O
n	array(double)
+	O
1	int
]	O
=	O
qqq0	struct(double,double)
;	O
level	int
[	O
n	array(double)
+	O
1	int
]	O
=	O
current_level	int
+	O
1	int
;	O
r0	array(struct(double,double))
[	O
n	array(double)
]	O
=	O
qqq0	struct(double,double)
;	O
r1	array(struct(double,double))
[	O
n	array(double)
]	O
=	O
qq1	struct(double,double)
;	O
r2	array(struct(double,double))
[	O
n	array(double)
]	O
=	O
q2	struct(double,double)
;	O
level	int
[	O
n	array(double)
]	O
=	O
current_level	int
+	O
1	int
;	O
n	array(double)
++	O
;	O
}	O
}	O
}	O
}	O
void	O
_add_bezier3_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),struct(double,double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
plPoint	struct(double,double)
pd	struct(double,double)
,	O
plPoint	struct(double,double)
p	struct(double,double)
)	O
{	O
plPoint	struct(double,double)
r0	array(struct(double,double))
[	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
r1	array(struct(double,double))
[	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
r2	array(struct(double,double))
[	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
r3	array(struct(double,double))
[	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
level	int
[	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
n	array(double)
=	O
0	int
;	O
int	O
segments_drawn	int
=	O
0	int
;	O
plPoint	struct(double,double)
p0	struct(double,double)
;	O
double	O
sqdist	double
,	O
max_squared_length	double
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
p0	struct(double,double)
=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct(double,double)
;	O
sqdist	double
=	O
(	O
p	struct(double,double)
.	O
x	double
-	O
p0	struct(double,double)
.	O
x	double
)	O
*	O
(	O
p	struct(double,double)
.	O
x	double
-	O
p0	struct(double,double)
.	O
x	double
)	O
+	O
(	O
p	struct(double,double)
.	O
y	double
-	O
p0	struct(double,double)
.	O
y	double
)	O
*	O
(	O
p	struct(double,double)
.	O
y	double
-	O
p0	struct(double,double)
.	O
y	double
)	O
;	O
max_squared_length	double
=	O
REL_CUBIC_FLATNESS	int
*	O
REL_CUBIC_FLATNESS	int
*	O
sqdist	double
;	O
r0	array(struct(double,double))
[	O
0	int
]	O
=	O
p0	struct(double,double)
;	O
r1	array(struct(double,double))
[	O
0	int
]	O
=	O
pc	struct(double,double)
;	O
r2	array(struct(double,double))
[	O
0	int
]	O
=	O
pd	struct(double,double)
;	O
r3	array(struct(double,double))
[	O
0	int
]	O
=	O
p	struct(double,double)
;	O
level	int
[	O
0	int
]	O
=	O
0	int
;	O
while	O
(	O
n	array(double)
>=	O
0	int
)	O
{	O
int	O
current_level	int
;	O
plPoint	struct(double,double)
q0	struct(double,double)
,	O
q1	struct(double,double)
,	O
q2	struct(double,double)
,	O
q3	struct(double,double)
;	O
current_level	int
=	O
level	int
[	O
n	array(double)
]	O
;	O
q0	struct(double,double)
=	O
r0	array(struct(double,double))
[	O
n	array(double)
]	O
;	O
q1	struct(double,double)
=	O
r1	array(struct(double,double))
[	O
n	array(double)
]	O
;	O
q2	struct(double,double)
=	O
r2	array(struct(double,double))
[	O
n	array(double)
]	O
;	O
q3	struct(double,double)
=	O
r3	array(struct(double,double))
[	O
n	array(double)
]	O
;	O
if	O
(	O
current_level	int
>=	O
MAX_NUM_BEZIER3_SUBDIVISIONS	int
)	O
{	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
q3	struct(double,double)
)	O
;	O
segments_drawn	int
++	O
;	O
n	array(double)
--	O
;	O
}	O
else	O
{	O
plPoint	struct(double,double)
qq0	struct(double,double)
,	O
qq1	struct(double,double)
,	O
qq2	struct(double,double)
;	O
plPoint	struct(double,double)
qqq0	struct(double,double)
,	O
qqq1	struct(double,double)
;	O
plPoint	struct(double,double)
qqqq0	struct(double,double)
;	O
plVector	struct(double,double)
vec1	struct(double,double)
,	O
vec2	struct(double,double)
;	O
vec1	struct(double,double)
.	O
x	double
=	O
q0	struct(double,double)
.	O
x	double
-	O
2	int
*	O
q1	struct(double,double)
.	O
x	double
+	O
q2	struct(double,double)
.	O
x	double
;	O
vec1	struct(double,double)
.	O
y	double
=	O
q0	struct(double,double)
.	O
y	double
-	O
2	int
*	O
q1	struct(double,double)
.	O
y	double
+	O
q2	struct(double,double)
.	O
y	double
;	O
vec2	struct(double,double)
.	O
x	double
=	O
q1	struct(double,double)
.	O
x	double
-	O
2	int
*	O
q2	struct(double,double)
.	O
x	double
+	O
q3	struct(double,double)
.	O
x	double
;	O
vec2	struct(double,double)
.	O
y	double
=	O
q1	struct(double,double)
.	O
y	double
-	O
2	int
*	O
q2	struct(double,double)
.	O
y	double
+	O
q3	struct(double,double)
.	O
y	double
;	O
if	O
(	O
vec1	struct(double,double)
.	O
x	double
*	O
vec1	struct(double,double)
.	O
x	double
+	O
vec1	struct(double,double)
.	O
y	double
*	O
vec1	struct(double,double)
.	O
y	double
<	O
max_squared_length	double
&&	O
vec2	struct(double,double)
.	O
x	double
*	O
vec2	struct(double,double)
.	O
x	double
+	O
vec2	struct(double,double)
.	O
y	double
*	O
vec2	struct(double,double)
.	O
y	double
<	O
max_squared_length	double
)	O
{	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
q3	struct(double,double)
)	O
;	O
segments_drawn	int
++	O
;	O
n	array(double)
--	O
;	O
}	O
else	O
{	O
qq0	struct(double,double)
.	O
x	double
=	O
MIDWAY	O
(	O
q0	struct(double,double)
.	O
x	double
,	O
q1	struct(double,double)
.	O
x	double
)	O
;	O
qq0	struct(double,double)
.	O
y	double
=	O
MIDWAY	O
(	O
q0	struct(double,double)
.	O
y	double
,	O
q1	struct(double,double)
.	O
y	double
)	O
;	O
qq1	struct(double,double)
.	O
x	double
=	O
MIDWAY	O
(	O
q1	struct(double,double)
.	O
x	double
,	O
q2	struct(double,double)
.	O
x	double
)	O
;	O
qq1	struct(double,double)
.	O
y	double
=	O
MIDWAY	O
(	O
q1	struct(double,double)
.	O
y	double
,	O
q2	struct(double,double)
.	O
y	double
)	O
;	O
qq2	struct(double,double)
.	O
x	double
=	O
MIDWAY	O
(	O
q2	struct(double,double)
.	O
x	double
,	O
q3	struct(double,double)
.	O
x	double
)	O
;	O
qq2	struct(double,double)
.	O
y	double
=	O
MIDWAY	O
(	O
q2	struct(double,double)
.	O
y	double
,	O
q3	struct(double,double)
.	O
y	double
)	O
;	O
qqq0	struct(double,double)
.	O
x	double
=	O
MIDWAY	O
(	O
qq0	struct(double,double)
.	O
x	double
,	O
qq1	struct(double,double)
.	O
x	double
)	O
;	O
qqq0	struct(double,double)
.	O
y	double
=	O
MIDWAY	O
(	O
qq0	struct(double,double)
.	O
y	double
,	O
qq1	struct(double,double)
.	O
y	double
)	O
;	O
qqq1	struct(double,double)
.	O
x	double
=	O
MIDWAY	O
(	O
qq1	struct(double,double)
.	O
x	double
,	O
qq2	struct(double,double)
.	O
x	double
)	O
;	O
qqq1	struct(double,double)
.	O
y	double
=	O
MIDWAY	O
(	O
qq1	struct(double,double)
.	O
y	double
,	O
qq2	struct(double,double)
.	O
y	double
)	O
;	O
qqqq0	struct(double,double)
.	O
x	double
=	O
MIDWAY	O
(	O
qqq0	struct(double,double)
.	O
x	double
,	O
qqq1	struct(double,double)
.	O
x	double
)	O
;	O
qqqq0	struct(double,double)
.	O
y	double
=	O
MIDWAY	O
(	O
qqq0	struct(double,double)
.	O
y	double
,	O
qqq1	struct(double,double)
.	O
y	double
)	O
;	O
level	int
[	O
n	array(double)
+	O
1	int
]	O
=	O
current_level	int
+	O
1	int
;	O
r0	array(struct(double,double))
[	O
n	array(double)
+	O
1	int
]	O
=	O
q0	struct(double,double)
;	O
r1	array(struct(double,double))
[	O
n	array(double)
+	O
1	int
]	O
=	O
qq0	struct(double,double)
;	O
r2	array(struct(double,double))
[	O
n	array(double)
+	O
1	int
]	O
=	O
qqq0	struct(double,double)
;	O
r3	array(struct(double,double))
[	O
n	array(double)
+	O
1	int
]	O
=	O
qqqq0	struct(double,double)
;	O
level	int
[	O
n	array(double)
]	O
=	O
current_level	int
+	O
1	int
;	O
r0	array(struct(double,double))
[	O
n	array(double)
]	O
=	O
qqqq0	struct(double,double)
;	O
r1	array(struct(double,double))
[	O
n	array(double)
]	O
=	O
qqq1	struct(double,double)
;	O
r2	array(struct(double,double))
[	O
n	array(double)
]	O
=	O
qq2	struct(double,double)
;	O
r3	array(struct(double,double))
[	O
n	array(double)
]	O
=	O
q3	struct(double,double)
;	O
n	array(double)
++	O
;	O
}	O
}	O
}	O
}	O
void	O
_add_box_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),enum(int,int))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
p0	struct(double,double)
,	O
plPoint	struct(double,double)
p1	struct(double,double)
,	O
bool	enum(int,int)
clockwise	enum(int,int)
)	O
{	O
bool	enum(int,int)
x_move_is_first	enum(int,int)
;	O
plPoint	struct(double,double)
newpoint	struct(double,double)
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
_add_moveto	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
p0	struct(double,double)
)	O
;	O
x_move_is_first	enum(int,int)
=	O
(	O
(	O
p1	struct(double,double)
.	O
x	double
>=	O
p0	struct(double,double)
.	O
x	double
&&	O
p1	struct(double,double)
.	O
y	double
>=	O
p0	struct(double,double)
.	O
y	double
)	O
||	O
(	O
p1	struct(double,double)
.	O
x	double
<	O
p0	struct(double,double)
.	O
x	double
&&	O
p1	struct(double,double)
.	O
y	double
<	O
p0	struct(double,double)
.	O
y	double
)	O
?	O
true	int
:	O
false	int
)	O
;	O
if	O
(	O
clockwise	enum(int,int)
)	O
x_move_is_first	enum(int,int)
=	O
(	O
x_move_is_first	enum(int,int)
==	O
true	int
?	O
false	int
:	O
true	int
)	O
;	O
if	O
(	O
x_move_is_first	enum(int,int)
)	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
p1	struct(double,double)
.	O
x	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
p0	struct(double,double)
.	O
y	double
;	O
}	O
else	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
p0	struct(double,double)
.	O
x	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
p1	struct(double,double)
.	O
y	double
;	O
}	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
newpoint	struct(double,double)
)	O
;	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
p1	struct(double,double)
)	O
;	O
if	O
(	O
x_move_is_first	enum(int,int)
)	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
p0	struct(double,double)
.	O
x	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
p1	struct(double,double)
.	O
y	double
;	O
}	O
else	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
p1	struct(double,double)
.	O
x	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
p0	struct(double,double)
.	O
y	double
;	O
}	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
newpoint	struct(double,double)
)	O
;	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
p0	struct(double,double)
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
primitive	enum(int,int)
=	O
true	int
;	O
}	O
void	O
_add_ellipse_as_bezier3s	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,double,double,enum(int,int))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
,	O
bool	enum(int,int)
clockwise	enum(int,int)
)	O
{	O
plPoint	struct(double,double)
startpoint	struct(double,double)
,	O
newpoint	struct(double,double)
;	O
double	O
theta	double
,	O
costheta	double
,	O
sintheta	double
;	O
double	O
xc	int
,	O
yc	int
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
theta	double
=	O
(	O
M_PI	int
/	O
180.0	int
)	O
*	O
angle	double
;	O
costheta	double
=	O
cos	(double)->(double)
(	O
theta	double
)	O
;	O
sintheta	double
=	O
sin	(double)->(double)
(	O
theta	double
)	O
;	O
xc	int
=	O
pc	struct(double,double)
.	O
x	double
;	O
yc	int
=	O
pc	struct(double,double)
.	O
y	double
;	O
startpoint	struct(double,double)
.	O
x	double
=	O
xc	int
+	O
rx	double
*	O
costheta	double
;	O
startpoint	struct(double,double)
.	O
y	double
=	O
yc	int
+	O
rx	double
*	O
sintheta	double
;	O
_add_moveto	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
startpoint	struct(double,double)
)	O
;	O
if	O
(	O
clockwise	enum(int,int)
)	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc_as_bezier3	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
newpoint	struct(double,double)
)	O
;	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
-	O
rx	double
*	O
costheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
-	O
rx	double
*	O
sintheta	double
;	O
_add_ellarc_as_bezier3	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
newpoint	struct(double,double)
)	O
;	O
if	O
(	O
clockwise	enum(int,int)
)	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc_as_bezier3	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
newpoint	struct(double,double)
)	O
;	O
_add_ellarc_as_bezier3	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
startpoint	struct(double,double)
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
primitive	enum(int,int)
=	O
true	int
;	O
}	O
void	O
_add_ellipse_as_ellarcs	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,double,double,enum(int,int))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
,	O
bool	enum(int,int)
clockwise	enum(int,int)
)	O
{	O
plPoint	struct(double,double)
startpoint	struct(double,double)
,	O
newpoint	struct(double,double)
;	O
double	O
theta	double
,	O
costheta	double
,	O
sintheta	double
;	O
double	O
xc	int
,	O
yc	int
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
theta	double
=	O
(	O
M_PI	int
/	O
180.0	int
)	O
*	O
angle	double
;	O
costheta	double
=	O
cos	(double)->(double)
(	O
theta	double
)	O
;	O
sintheta	double
=	O
sin	(double)->(double)
(	O
theta	double
)	O
;	O
xc	int
=	O
pc	struct(double,double)
.	O
x	double
;	O
yc	int
=	O
pc	struct(double,double)
.	O
y	double
;	O
startpoint	struct(double,double)
.	O
x	double
=	O
xc	int
+	O
rx	double
*	O
costheta	double
;	O
startpoint	struct(double,double)
.	O
y	double
=	O
yc	int
+	O
rx	double
*	O
sintheta	double
;	O
_add_moveto	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
startpoint	struct(double,double)
)	O
;	O
if	O
(	O
clockwise	enum(int,int)
)	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
newpoint	struct(double,double)
)	O
;	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
-	O
rx	double
*	O
costheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
-	O
rx	double
*	O
sintheta	double
;	O
_add_ellarc	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
newpoint	struct(double,double)
)	O
;	O
if	O
(	O
clockwise	enum(int,int)
)	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
newpoint	struct(double,double)
)	O
;	O
_add_ellarc	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
startpoint	struct(double,double)
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
primitive	enum(int,int)
=	O
true	int
;	O
}	O
void	O
_add_ellipse_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,double,double,enum(int,int))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
,	O
bool	enum(int,int)
clockwise	enum(int,int)
)	O
{	O
plPoint	struct(double,double)
startpoint	struct(double,double)
,	O
newpoint	struct(double,double)
;	O
double	O
theta	double
,	O
costheta	double
,	O
sintheta	double
;	O
double	O
xc	int
,	O
yc	int
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
>	O
0	int
)	O
return	O
;	O
theta	double
=	O
(	O
M_PI	int
/	O
180.0	int
)	O
*	O
angle	double
;	O
costheta	double
=	O
cos	(double)->(double)
(	O
theta	double
)	O
;	O
sintheta	double
=	O
sin	(double)->(double)
(	O
theta	double
)	O
;	O
xc	int
=	O
pc	struct(double,double)
.	O
x	double
;	O
yc	int
=	O
pc	struct(double,double)
.	O
y	double
;	O
startpoint	struct(double,double)
.	O
x	double
=	O
xc	int
+	O
rx	double
*	O
costheta	double
;	O
startpoint	struct(double,double)
.	O
y	double
=	O
yc	int
+	O
rx	double
*	O
sintheta	double
;	O
_add_moveto	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
startpoint	struct(double,double)
)	O
;	O
if	O
(	O
clockwise	enum(int,int)
)	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
newpoint	struct(double,double)
)	O
;	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
-	O
rx	double
*	O
costheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
-	O
rx	double
*	O
sintheta	double
;	O
_add_ellarc_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
newpoint	struct(double,double)
)	O
;	O
if	O
(	O
clockwise	enum(int,int)
)	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
-	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
+	O
ry	double
*	O
costheta	double
;	O
}	O
else	O
{	O
newpoint	struct(double,double)
.	O
x	double
=	O
xc	int
+	O
ry	double
*	O
sintheta	double
;	O
newpoint	struct(double,double)
.	O
y	double
=	O
yc	int
-	O
ry	double
*	O
costheta	double
;	O
}	O
_add_ellarc_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
newpoint	struct(double,double)
)	O
;	O
_add_ellarc_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
startpoint	struct(double,double)
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
primitive	enum(int,int)
=	O
true	int
;	O
}	O
void	O
_add_circle_as_bezier3s	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,enum(int,int))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
double	O
radius	double
,	O
bool	enum(int,int)
clockwise	enum(int,int)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
_add_ellipse_as_bezier3s	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,double,double,enum(int,int))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
clockwise	enum(int,int)
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
primitive	enum(int,int)
=	O
true	int
;	O
}	O
void	O
_add_circle_as_ellarcs	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,enum(int,int))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
double	O
radius	double
,	O
bool	enum(int,int)
clockwise	enum(int,int)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
_add_ellipse_as_ellarcs	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,double,double,enum(int,int))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
clockwise	enum(int,int)
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
primitive	enum(int,int)
=	O
true	int
;	O
}	O
void	O
_add_circle_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,enum(int,int))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
pc	struct(double,double)
,	O
double	O
radius	double
,	O
bool	enum(int,int)
clockwise	enum(int,int)
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
;	O
_add_ellipse_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,double,double,enum(int,int))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
pc	struct(double,double)
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
clockwise	enum(int,int)
)	O
;	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
primitive	enum(int,int)
=	O
true	int
;	O
}	O
static	O
void	O
_fakearc	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),int,*(double),array(double))->(void)
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
plPoint	struct(double,double)
p0	struct(double,double)
,	O
plPoint	struct(double,double)
p1	struct(double,double)
,	O
int	O
arc_type	int
,	O
const	O
double	O
*	O
custom_chord_table	array(double)
,	O
const	O
double	O
m	array(double)
[	O
4	int
]	O
)	O
{	O
plPoint	struct(double,double)
p	struct(double,double)
[	O
NUM_ARC_SUBDIVISIONS	int
+	O
1	int
]	O
,	O
q	array(struct(double,double))
[	O
NUM_ARC_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
level	int
[	O
NUM_ARC_SUBDIVISIONS	int
+	O
1	int
]	O
;	O
int	O
n	array(double)
=	O
0	int
;	O
int	O
segments_drawn	int
=	O
0	int
;	O
const	O
double	O
*	O
our_chord_table	*(double)
;	O
if	O
(	O
arc_type	int
==	O
USER_DEFINED_ARC	O
)	O
our_chord_table	*(double)
=	O
custom_chord_table	array(double)
;	O
else	O
our_chord_table	*(double)
=	O
_chord_table	array(array(double))
[	O
arc_type	int
]	O
;	O
p	struct(double,double)
[	O
0	int
]	O
=	O
p0	struct(double,double)
;	O
q	array(struct(double,double))
[	O
0	int
]	O
=	O
p1	struct(double,double)
;	O
level	int
[	O
0	int
]	O
=	O
0	int
;	O
while	O
(	O
n	array(double)
>=	O
0	int
)	O
{	O
if	O
(	O
level	int
[	O
n	array(double)
]	O
>=	O
NUM_ARC_SUBDIVISIONS	int
)	O
{	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
q	array(struct(double,double))
[	O
n	array(double)
]	O
)	O
;	O
segments_drawn	int
++	O
;	O
n	array(double)
--	O
;	O
}	O
else	O
{	O
plVector	struct(double,double)
v	*(struct(double,double))
;	O
plPoint	struct(double,double)
pm	struct(double,double)
,	O
pb	struct(double,double)
;	O
v	*(struct(double,double))
.	O
x	double
=	O
q	array(struct(double,double))
[	O
n	array(double)
]	O
.	O
x	double
-	O
p	struct(double,double)
[	O
n	array(double)
]	O
.	O
x	double
;	O
v	*(struct(double,double))
.	O
y	double
=	O
q	array(struct(double,double))
[	O
n	array(double)
]	O
.	O
y	double
-	O
p	struct(double,double)
[	O
n	array(double)
]	O
.	O
y	double
;	O
pm	struct(double,double)
.	O
x	double
=	O
p	struct(double,double)
[	O
n	array(double)
]	O
.	O
x	double
+	O
0.5	int
*	O
v	*(struct(double,double))
.	O
x	double
;	O
pm	struct(double,double)
.	O
y	double
=	O
p	struct(double,double)
[	O
n	array(double)
]	O
.	O
y	double
+	O
0.5	int
*	O
v	*(struct(double,double))
.	O
y	double
;	O
pb	struct(double,double)
.	O
x	double
=	O
pm	struct(double,double)
.	O
x	double
+	O
our_chord_table	*(double)
[	O
level	int
[	O
n	array(double)
]	O
]	O
*	O
(	O
m	array(double)
[	O
0	int
]	O
*	O
v	*(struct(double,double))
.	O
x	double
+	O
m	array(double)
[	O
1	int
]	O
*	O
v	*(struct(double,double))
.	O
y	double
)	O
;	O
pb	struct(double,double)
.	O
y	double
=	O
pm	struct(double,double)
.	O
y	double
+	O
our_chord_table	*(double)
[	O
level	int
[	O
n	array(double)
]	O
]	O
*	O
(	O
m	array(double)
[	O
2	int
]	O
*	O
v	*(struct(double,double))
.	O
x	double
+	O
m	array(double)
[	O
3	int
]	O
*	O
v	*(struct(double,double))
.	O
y	double
)	O
;	O
p	struct(double,double)
[	O
n	array(double)
+	O
1	int
]	O
=	O
p	struct(double,double)
[	O
n	array(double)
]	O
;	O
q	array(struct(double,double))
[	O
n	array(double)
+	O
1	int
]	O
=	O
pb	struct(double,double)
;	O
level	int
[	O
n	array(double)
+	O
1	int
]	O
=	O
level	int
[	O
n	array(double)
]	O
+	O
1	int
;	O
p	struct(double,double)
[	O
n	array(double)
]	O
=	O
pb	struct(double,double)
;	O
q	array(struct(double,double))
[	O
n	array(double)
]	O
=	O
q	array(struct(double,double))
[	O
n	array(double)
]	O
;	O
level	int
[	O
n	array(double)
]	O
=	O
level	int
[	O
n	array(double)
]	O
+	O
1	int
;	O
n	array(double)
++	O
;	O
}	O
}	O
}	O
static	O
void	O
_prepare_chord_table	(double,array(double))->(void)
(	O
double	O
sagitta	double
,	O
double	O
custom_chord_table	array(double)
[	O
TABULATED_ARC_SUBDIVISIONS	int
]	O
)	O
{	O
double	O
half_chord_length	double
;	O
int	O
i	int
;	O
half_chord_length	double
=	O
sqrt	(double)->(double)
(	O
sagitta	double
*	O
(	O
2.0	int
-	O
sagitta	double
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
TABULATED_ARC_SUBDIVISIONS	int
;	O
i	int
++	O
)	O
{	O
custom_chord_table	array(double)
[	O
i	int
]	O
=	O
0.5	int
*	O
sagitta	double
/	O
half_chord_length	double
;	O
sagitta	double
=	O
1.0	int
-	O
sqrt	(double)->(double)
(	O
1.0	int
-	O
0.5	int
*	O
sagitta	double
)	O
;	O
half_chord_length	double
=	O
0.5	int
*	O
half_chord_length	double
/	O
(	O
1.0	int
-	O
sagitta	double
)	O
;	O
}	O
}	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
_flatten_path	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))->(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
(	O
const	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
)	O
{	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
==	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
)	O
return	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
;	O
switch	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
PATH_SEGMENT_LIST	int
:	O
{	O
bool	enum(int,int)
do_flatten	enum(int,int)
=	O
false	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
!=	O
S_MOVETO	int
&&	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
!=	O
S_LINE	int
&&	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
!=	O
S_CLOSEPATH	int
)	O
{	O
do_flatten	enum(int,int)
=	O
true	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
do_flatten	enum(int,int)
==	O
false	int
)	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
=	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
;	O
else	O
{	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
=	O
_new_plPath	()->(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
(	O
int	O
)	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
)	O
)	O
{	O
case	O
(	O
int	O
)	O
S_MOVETO	int
:	O
_add_moveto	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
p	struct(double,double)
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_LINE	int
:	O
_add_line	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double))->(void)
(	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
p	struct(double,double)
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_CLOSEPATH	int
:	O
_add_closepath	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))->(void)
(	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_ARC	int
:	O
_add_arc_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
pc	struct(double,double)
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
p	struct(double,double)
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_ELLARC	int
:	O
_add_ellarc_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
pc	struct(double,double)
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
p	struct(double,double)
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_QUAD	int
:	O
_add_bezier2_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double))->(void)
(	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
pc	struct(double,double)
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
p	struct(double,double)
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
S_CUBIC	int
:	O
_add_bezier3_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),struct(double,double))->(void)
(	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
pc	struct(double,double)
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
pd	struct(double,double)
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
p	struct(double,double)
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
break	O
;	O
}	O
case	O
PATH_CIRCLE	int
:	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
=	O
_new_plPath	()->(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
(	O
)	O
;	O
_add_circle_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,enum(int,int))->(void)
(	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
pc	struct(double,double)
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
radius	double
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
clockwise	enum(int,int)
)	O
;	O
break	O
;	O
case	O
PATH_ELLIPSE	int
:	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
=	O
_new_plPath	()->(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
(	O
)	O
;	O
_add_ellipse_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),double,double,double,enum(int,int))->(void)
(	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
pc	struct(double,double)
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
rx	double
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
ry	double
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
angle	double
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
clockwise	enum(int,int)
)	O
;	O
break	O
;	O
case	O
PATH_BOX	int
:	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
=	O
_new_plPath	()->(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
(	O
)	O
;	O
_add_box_as_lines	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))),struct(double,double),struct(double,double),enum(int,int))->(void)
(	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
p0	struct(double,double)
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
p1	struct(double,double)
,	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
clockwise	enum(int,int)
)	O
;	O
break	O
;	O
default	O
:	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
=	O
_new_plPath	()->(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
(	O
)	O
;	O
break	O
;	O
}	O
return	O
newpath	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
;	O
}	O
typedef	O
struct	O
subpath_struct	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
{	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
;	O
int	O
num_segments	int
;	O
struct	O
subpath_struct	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
parents	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
;	O
struct	O
subpath_struct	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
;	O
struct	O
subpath_struct	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
;	O
int	O
num_children	int
;	O
int	O
num_outside	int
;	O
double	O
llx	double
,	O
lly	double
,	O
urx	double
,	O
ury	double
;	O
bool	enum(int,int)
inserted	enum(int,int)
;	O
}	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
;	O
static	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
new_subpath	()->(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
(	O
void	O
)	O
;	O
static	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
new_subpath_array	(int)->(*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))))
(	O
int	O
n	array(double)
)	O
;	O
static	O
void	O
delete_subpath	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(void)
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
s	*(char)
)	O
;	O
static	O
void	O
delete_subpath_array	(*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int)->(void)
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
s	*(char)
,	O
int	O
n	array(double)
)	O
;	O
static	O
bool	enum(int,int)
is_inside_of	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(enum(int,int))
(	O
const	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
s	*(char)
,	O
const	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
)	O
;	O
static	O
double	O
_cheap_lower_bound_on_distance	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(double)
(	O
const	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
path1	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
,	O
const	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
path2	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
)	O
;	O
static	O
void	O
linearize_subpath	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(void)
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
s	*(char)
)	O
;	O
static	O
void	O
read_into_subpath	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))->(void)
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
s	*(char)
,	O
const	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
)	O
;	O
static	O
void	O
find_parents_in_subpath_list	(*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int)->(void)
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
,	O
int	O
num_paths	int
)	O
;	O
static	O
void	O
insert_subpath	(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,int,int)->(void)
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
parent_segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
const	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
child_segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
int	O
parent_size	int
,	O
int	O
child_size	int
,	O
int	O
parent_index	int
,	O
int	O
child_index	int
)	O
;	O
static	O
void	O
_compute_closest	(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,*(double),*(int),*(int))->(void)
(	O
const	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
p1	struct(double,double)
,	O
const	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
p2	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
int	O
size1	int
,	O
int	O
size2	int
,	O
double	O
*	O
distance	*(double)
,	O
int	O
*	O
index1	*(int)
,	O
int	O
*	O
index2	*(int)
)	O
;	O
static	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
new_subpath	()->(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
(	O
void	O
)	O
{	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
s	*(char)
;	O
s	*(char)
=	O
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
)	O
)	O
;	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
NULL	O
;	O
s	*(char)
->	O
num_segments	int
=	O
0	int
;	O
s	*(char)
->	O
parents	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
=	O
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
)	O
NULL	O
;	O
s	*(char)
->	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
=	O
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
)	O
NULL	O
;	O
s	*(char)
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
=	O
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
)	O
NULL	O
;	O
s	*(char)
->	O
num_children	int
=	O
0	int
;	O
s	*(char)
->	O
num_outside	int
=	O
0	int
;	O
s	*(char)
->	O
llx	double
=	O
DBL_MAX	O
;	O
s	*(char)
->	O
lly	double
=	O
DBL_MAX	O
;	O
s	*(char)
->	O
urx	double
=	O
-	O
DBL_MAX	O
;	O
s	*(char)
->	O
ury	double
=	O
-	O
DBL_MAX	O
;	O
s	*(char)
->	O
inserted	enum(int,int)
=	O
false	int
;	O
return	O
s	*(char)
;	O
}	O
static	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
new_subpath_array	(int)->(*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))))
(	O
int	O
n	array(double)
)	O
{	O
int	O
i	int
;	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
s	*(char)
;	O
s	*(char)
=	O
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
n	array(double)
*	O
sizeof	O
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	array(double)
;	O
i	int
++	O
)	O
s	*(char)
[	O
i	int
]	O
=	O
new_subpath	()->(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
(	O
)	O
;	O
return	O
s	*(char)
;	O
}	O
static	O
void	O
delete_subpath	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(void)
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
s	*(char)
)	O
{	O
if	O
(	O
s	*(char)
)	O
{	O
if	O
(	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
)	O
free	(*(void))->(void)
(	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
)	O
;	O
if	O
(	O
s	*(char)
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
)	O
free	(*(void))->(void)
(	O
s	*(char)
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
)	O
;	O
if	O
(	O
s	*(char)
->	O
parents	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
)	O
free	(*(void))->(void)
(	O
s	*(char)
->	O
parents	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
delete_subpath_array	(*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int)->(void)
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
s	*(char)
,	O
int	O
n	array(double)
)	O
{	O
int	O
i	int
;	O
if	O
(	O
s	*(char)
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	array(double)
;	O
i	int
++	O
)	O
delete_subpath	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(void)
(	O
s	*(char)
[	O
i	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
s	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
linearize_subpath	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(void)
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
s	*(char)
)	O
{	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
0	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_LINE	int
;	O
if	O
(	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
s	*(char)
->	O
num_segments	int
-	O
1	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
==	O
S_CLOSEPATH	int
)	O
{	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
s	*(char)
->	O
num_segments	int
-	O
1	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_LINE	int
;	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
s	*(char)
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct(double,double)
=	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
0	int
]	O
.	O
p	struct(double,double)
;	O
}	O
}	O
static	O
void	O
read_into_subpath	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))->(void)
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
s	*(char)
,	O
const	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
)	O
{	O
bool	enum(int,int)
need_to_close	enum(int,int)
=	O
false	int
;	O
int	O
i	int
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
type	enum(int,int,int,int,int,int,int)
!=	O
PATH_SEGMENT_LIST	int
)	O
return	O
;	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
s	*(char)
->	O
num_segments	int
=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
-	O
1	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
!=	O
S_CLOSEPATH	int
&&	O
(	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct(double,double)
.	O
x	double
!=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
0	int
]	O
.	O
p	struct(double,double)
.	O
x	double
||	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct(double,double)
.	O
y	double
!=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
0	int
]	O
.	O
p	struct(double,double)
.	O
y	double
)	O
)	O
need_to_close	enum(int,int)
=	O
true	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
e	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
;	O
e	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
;	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
=	O
e	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
;	O
if	O
(	O
e	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
.	O
p	struct(double,double)
.	O
x	double
<	O
s	*(char)
->	O
llx	double
)	O
s	*(char)
->	O
llx	double
=	O
e	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
.	O
p	struct(double,double)
.	O
x	double
;	O
if	O
(	O
e	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
.	O
p	struct(double,double)
.	O
y	double
<	O
s	*(char)
->	O
lly	double
)	O
s	*(char)
->	O
lly	double
=	O
e	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
.	O
p	struct(double,double)
.	O
y	double
;	O
if	O
(	O
e	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
.	O
p	struct(double,double)
.	O
x	double
>	O
s	*(char)
->	O
urx	double
)	O
s	*(char)
->	O
urx	double
=	O
e	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
.	O
p	struct(double,double)
.	O
x	double
;	O
if	O
(	O
e	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
.	O
p	struct(double,double)
.	O
y	double
>	O
s	*(char)
->	O
ury	double
)	O
s	*(char)
->	O
ury	double
=	O
e	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
.	O
p	struct(double,double)
.	O
y	double
;	O
}	O
if	O
(	O
need_to_close	enum(int,int)
)	O
{	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_LINE	int
;	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
]	O
.	O
p	struct(double,double)
=	O
path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
0	int
]	O
.	O
p	struct(double,double)
;	O
s	*(char)
->	O
num_segments	int
++	O
;	O
}	O
}	O
static	O
bool	enum(int,int)
is_inside_of	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(enum(int,int))
(	O
const	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
s	*(char)
,	O
const	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
)	O
{	O
int	O
inside	int
=	O
0	int
;	O
int	O
outside	int
=	O
0	int
;	O
int	O
i	int
;	O
if	O
(	O
!	O
(	O
(	O
s	*(char)
->	O
llx	double
>=	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
llx	double
)	O
&&	O
(	O
s	*(char)
->	O
lly	double
>=	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
lly	double
)	O
&&	O
(	O
s	*(char)
->	O
urx	double
<=	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
urx	double
)	O
&&	O
(	O
s	*(char)
->	O
ury	double
<=	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
ury	double
)	O
)	O
)	O
return	O
false	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
s	*(char)
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
bool	enum(int,int)
point_is_inside	enum(int,int)
;	O
if	O
(	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
==	O
S_CLOSEPATH	int
)	O
continue	O
;	O
{	O
plPoint	struct(double,double)
p	struct(double,double)
;	O
int	O
k	int
,	O
crossings	int
;	O
double	O
x1	double
,	O
y1	(double)->(double)
;	O
double	O
x2	double
,	O
y2	double
;	O
p	struct(double,double)
=	O
s	*(char)
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
i	int
]	O
.	O
p	struct(double,double)
;	O
x1	double
=	O
(	O
DMAX	O
(	O
p	struct(double,double)
.	O
x	double
,	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
urx	double
)	O
+	O
SMALL_X_FACTOR	O
*	O
(	O
DMAX	O
(	O
p	struct(double,double)
.	O
x	double
,	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
urx	double
)	O
-	O
DMIN	O
(	O
p	struct(double,double)
.	O
x	double
,	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
llx	double
)	O
)	O
)	O
;	O
y1	(double)->(double)
=	O
(	O
DMAX	O
(	O
p	struct(double,double)
.	O
y	double
,	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
ury	double
)	O
+	O
SMALL_Y_FACTOR	O
*	O
(	O
DMAX	O
(	O
p	struct(double,double)
.	O
y	double
,	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
ury	double
)	O
-	O
DMIN	O
(	O
p	struct(double,double)
.	O
y	double
,	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
lly	double
)	O
)	O
)	O
;	O
x2	double
=	O
p	struct(double,double)
.	O
x	double
;	O
y2	double
=	O
p	struct(double,double)
.	O
y	double
;	O
crossings	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_segments	int
;	O
k	int
++	O
)	O
{	O
int	O
j	int
;	O
double	O
x3	double
,	O
y3	double
,	O
x4	double
,	O
y4	double
,	O
det	double
,	O
det1	double
,	O
det2	double
;	O
if	O
(	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
k	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
==	O
S_CLOSEPATH	int
)	O
{	O
x3	double
=	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
k	int
-	O
1	int
]	O
.	O
p	struct(double,double)
.	O
x	double
;	O
y3	double
=	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
k	int
-	O
1	int
]	O
.	O
p	struct(double,double)
.	O
y	double
;	O
}	O
else	O
{	O
x3	double
=	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
k	int
]	O
.	O
p	struct(double,double)
.	O
x	double
;	O
y3	double
=	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
k	int
]	O
.	O
p	struct(double,double)
.	O
y	double
;	O
}	O
j	int
=	O
(	O
k	int
==	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_segments	int
-	O
1	int
?	O
0	int
:	O
k	int
+	O
1	int
)	O
;	O
if	O
(	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
j	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
==	O
S_CLOSEPATH	int
)	O
continue	O
;	O
x4	double
=	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
j	int
]	O
.	O
p	struct(double,double)
.	O
x	double
;	O
y4	double
=	O
other	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
j	int
]	O
.	O
p	struct(double,double)
.	O
y	double
;	O
det	double
=	O
(	O
x2	double
-	O
x1	double
)	O
*	O
(	O
-	O
(	O
y4	double
-	O
y3	double
)	O
)	O
-	O
(	O
-	O
(	O
x4	double
-	O
x3	double
)	O
)	O
*	O
(	O
y2	double
-	O
y1	(double)->(double)
)	O
;	O
if	O
(	O
det	double
==	O
0.0	int
)	O
continue	O
;	O
det1	double
=	O
(	O
x3	double
-	O
x1	double
)	O
*	O
(	O
-	O
(	O
y4	double
-	O
y3	double
)	O
)	O
-	O
(	O
-	O
(	O
x4	double
-	O
x3	double
)	O
)	O
*	O
(	O
y3	double
-	O
y1	(double)->(double)
)	O
;	O
det2	double
=	O
(	O
x2	double
-	O
x1	double
)	O
*	O
(	O
y3	double
-	O
y1	(double)->(double)
)	O
-	O
(	O
x3	double
-	O
x1	double
)	O
*	O
(	O
y2	double
-	O
y1	(double)->(double)
)	O
;	O
if	O
(	O
(	O
det	double
<	O
0.0	int
&&	O
(	O
det1	double
>	O
0.0	int
||	O
det2	double
>	O
0.0	int
||	O
det1	double
<	O
det	double
||	O
det2	double
<	O
det	double
)	O
)	O
||	O
(	O
det	double
>	O
0.0	int
&&	O
(	O
det1	double
<	O
0.0	int
||	O
det2	double
<	O
0.0	int
||	O
det1	double
>	O
det	double
||	O
det2	double
>	O
det	double
)	O
)	O
)	O
continue	O
;	O
crossings	int
++	O
;	O
}	O
point_is_inside	enum(int,int)
=	O
(	O
crossings	int
&	O
1	int
)	O
?	O
true	int
:	O
false	int
;	O
}	O
if	O
(	O
point_is_inside	enum(int,int)
)	O
inside	int
++	O
;	O
else	O
outside	int
++	O
;	O
}	O
return	O
(	O
inside	int
>	O
outside	int
?	O
true	int
:	O
false	int
)	O
;	O
}	O
static	O
void	O
find_parents_in_subpath_list	(*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int)->(void)
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
,	O
int	O
num_paths	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
{	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
parents	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
=	O
new_subpath_array	(int)->(*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))))
(	O
num_paths	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_paths	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
!=	O
i	int
)	O
{	O
if	O
(	O
is_inside_of	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(enum(int,int))
(	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
,	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
)	O
)	O
{	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
parents	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
num_outside	int
]	O
=	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
;	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
num_outside	int
++	O
;	O
}	O
}	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
num_outside	int
&	O
1	int
)	O
==	O
0	int
)	O
{	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
=	O
new_subpath_array	(int)->(*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))))
(	O
num_paths	int
)	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
num_outside	int
&	O
1	int
)	O
==	O
0	int
)	O
continue	O
;	O
else	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
num_outside	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
num_outside	int
==	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
parents	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
->	O
num_outside	int
+	O
1	int
)	O
{	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
=	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
parents	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
;	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
=	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
;	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
]	O
=	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
;	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
++	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
_compute_closest	(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,*(double),*(int),*(int))->(void)
(	O
const	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
p1	struct(double,double)
,	O
const	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
p2	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
int	O
size1	int
,	O
int	O
size2	int
,	O
double	O
*	O
distance	*(double)
,	O
int	O
*	O
index1	*(int)
,	O
int	O
*	O
index2	*(int)
)	O
{	O
int	O
best_i	int
=	O
0	int
,	O
best_j	int
=	O
0	int
;	O
double	O
best_distance	double
=	O
DBL_MAX	O
;	O
int	O
ii	int
,	O
jj	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
size1	int
;	O
ii	int
++	O
)	O
{	O
plPoint	struct(double,double)
point1	struct(double,double)
;	O
point1	struct(double,double)
=	O
p1	struct(double,double)
[	O
ii	int
]	O
.	O
p	struct(double,double)
;	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
size2	int
;	O
jj	int
++	O
)	O
{	O
double	O
tmp1	double
,	O
tmp2	double
,	O
distance	*(double)
;	O
plPoint	struct(double,double)
point2	struct(double,double)
;	O
point2	struct(double,double)
=	O
p2	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
jj	int
]	O
.	O
p	struct(double,double)
;	O
tmp1	double
=	O
point1	struct(double,double)
.	O
x	double
-	O
point2	struct(double,double)
.	O
x	double
;	O
tmp2	double
=	O
point1	struct(double,double)
.	O
y	double
-	O
point2	struct(double,double)
.	O
y	double
;	O
distance	*(double)
=	O
tmp1	double
*	O
tmp1	double
+	O
tmp2	double
*	O
tmp2	double
;	O
if	O
(	O
distance	*(double)
<	O
best_distance	double
)	O
{	O
best_distance	double
=	O
distance	*(double)
;	O
best_i	int
=	O
ii	int
;	O
best_j	int
=	O
jj	int
;	O
}	O
}	O
}	O
*	O
distance	*(double)
=	O
best_distance	double
;	O
*	O
index1	*(int)
=	O
best_i	int
;	O
*	O
index2	*(int)
=	O
best_j	int
;	O
}	O
static	O
double	O
_cheap_lower_bound_on_distance	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(double)
(	O
const	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
path1	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
,	O
const	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
path2	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
)	O
{	O
double	O
xdist	double
=	O
0.0	int
,	O
ydist	double
=	O
0.0	int
,	O
dist	double
;	O
if	O
(	O
path1	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
urx	double
<	O
path2	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
llx	double
)	O
xdist	double
=	O
path2	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
llx	double
-	O
path1	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
urx	double
;	O
else	O
if	O
(	O
path2	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
urx	double
<	O
path1	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
llx	double
)	O
xdist	double
=	O
path1	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
llx	double
-	O
path2	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
urx	double
;	O
if	O
(	O
path1	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
ury	double
<	O
path2	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
lly	double
)	O
ydist	double
=	O
path2	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
lly	double
-	O
path1	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
ury	double
;	O
else	O
if	O
(	O
path2	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
ury	double
<	O
path1	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
lly	double
)	O
ydist	double
=	O
path1	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
lly	double
-	O
path2	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
ury	double
;	O
dist	double
=	O
xdist	double
*	O
xdist	double
+	O
ydist	double
*	O
ydist	double
;	O
return	O
dist	double
;	O
}	O
static	O
void	O
insert_subpath	(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,int,int)->(void)
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
,	O
const	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
child	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
int	O
parent_size	int
,	O
int	O
child_size	int
,	O
int	O
parent_index	int
,	O
int	O
child_index	int
)	O
{	O
int	O
i	int
;	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
e1	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
,	O
e2	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
;	O
int	O
src_index	int
;	O
if	O
(	O
child_index	int
==	O
child_size	int
-	O
1	int
)	O
child_index	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
parent_size	int
-	O
1	int
;	O
i	int
>=	O
parent_index	int
+	O
1	int
;	O
i	int
--	O
)	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
[	O
i	int
+	O
child_size	int
+	O
1	int
]	O
=	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
[	O
i	int
]	O
;	O
e1	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
=	O
child	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
child_index	int
]	O
;	O
e1	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_LINE	int
;	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
[	O
parent_index	int
+	O
1	int
]	O
=	O
e1	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
;	O
src_index	int
=	O
child_index	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
child_size	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
src_index	int
++	O
;	O
if	O
(	O
src_index	int
==	O
child_size	int
-	O
1	int
)	O
src_index	int
=	O
0	int
;	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
[	O
parent_index	int
+	O
2	int
+	O
i	int
]	O
=	O
child	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
src_index	int
]	O
;	O
}	O
e2	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
=	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
[	O
parent_index	int
]	O
;	O
e2	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_LINE	int
;	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
[	O
parent_index	int
+	O
child_size	int
+	O
1	int
]	O
=	O
e2	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
;	O
}	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
*	O
_merge_paths	(*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct`),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))),int)->(*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct`),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))))
(	O
const	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
*	O
paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
,	O
int	O
num_paths	int
)	O
{	O
int	O
i	int
;	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
*	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
;	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
*	O
flattened_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
;	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
*	O
merged_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
;	O
flattened_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
=	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
num_paths	int
*	O
sizeof	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
{	O
flattened_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
[	O
i	int
]	O
=	O
_flatten_path	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))->(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
(	O
paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
[	O
i	int
]	O
)	O
;	O
}	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
=	O
new_subpath_array	(int)->(*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))))
(	O
num_paths	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
read_into_subpath	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))->(void)
(	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
,	O
flattened_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
if	O
(	O
flattened_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
[	O
i	int
]	O
!=	O
paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
[	O
i	int
]	O
)	O
_delete_plPath	(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))->(void)
(	O
flattened_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
[	O
i	int
]	O
)	O
;	O
find_parents_in_subpath_list	(*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int)->(void)
(	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
,	O
num_paths	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
if	O
(	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
!=	O
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
)	O
NULL	O
)	O
linearize_subpath	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(void)
(	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
)	O
;	O
merged_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
=	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
num_paths	int
*	O
sizeof	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_paths	int
;	O
i	int
++	O
)	O
{	O
int	O
j	int
,	O
k	int
,	O
num_segments_in_merged_path	int
;	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
;	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
;	O
double	O
*	O
parent_to_child_distances	*(double)
;	O
int	O
*	O
child_best_indices	*(int)
,	O
*	O
parent_best_indices	*(int)
;	O
if	O
(	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
!=	O
(	O
subpath	struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int))
*	O
)	O
NULL	O
)	O
{	O
merged_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
[	O
i	int
]	O
=	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
NULL	O
;	O
continue	O
;	O
}	O
if	O
(	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
->	O
num_children	int
==	O
0	int
)	O
{	O
merged_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
[	O
i	int
]	O
=	O
(	O
plPath	struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))
*	O
)	O
paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
[	O
i	int
]	O
;	O
continue	O
;	O
}	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
=	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
i	int
]	O
;	O
num_segments_in_merged_path	int
=	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_segments	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
;	O
j	int
++	O
)	O
num_segments_in_merged_path	int
+=	O
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
->	O
num_segments	int
+	O
1	int
)	O
;	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
=	O
_new_plPath	()->(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
(	O
)	O
;	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
=	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
num_segments_in_merged_path	int
*	O
sizeof	O
(	O
plPathSegment	struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))
)	O
)	O
;	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
=	O
0	int
;	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments_len	int
=	O
num_segments_in_merged_path	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_segments	int
;	O
j	int
++	O
)	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
j	int
]	O
=	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
j	int
]	O
;	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
=	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_segments	int
;	O
parent_to_child_distances	*(double)
=	O
(	O
double	O
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
parent_best_indices	*(int)
=	O
(	O
int	O
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
child_best_indices	*(int)
=	O
(	O
int	O
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
;	O
j	int
++	O
)	O
_compute_closest	(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,*(double),*(int),*(int))->(void)
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_segments	int
,	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
->	O
num_segments	int
,	O
&	O
(	O
parent_to_child_distances	*(double)
[	O
j	int
]	O
)	O
,	O
&	O
(	O
parent_best_indices	*(int)
[	O
j	int
]	O
)	O
,	O
&	O
(	O
child_best_indices	*(int)
[	O
j	int
]	O
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
;	O
k	int
++	O
)	O
{	O
double	O
min_distance	double
;	O
int	O
closest	int
=	O
0	int
;	O
double	O
*	O
new_parent_to_child_distances	*(double)
;	O
int	O
*	O
new_child_best_indices	*(int)
,	O
*	O
new_parent_best_indices	*(int)
;	O
new_parent_to_child_distances	*(double)
=	O
(	O
double	O
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
new_parent_best_indices	*(int)
=	O
(	O
int	O
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
new_child_best_indices	*(int)
=	O
(	O
int	O
*	O
)	O
_pl_xmalloc	(long)->(*(void))
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
;	O
j	int
++	O
)	O
{	O
new_parent_to_child_distances	*(double)
[	O
j	int
]	O
=	O
parent_to_child_distances	*(double)
[	O
j	int
]	O
;	O
new_parent_best_indices	*(int)
[	O
j	int
]	O
=	O
parent_best_indices	*(int)
[	O
j	int
]	O
;	O
new_child_best_indices	*(int)
[	O
j	int
]	O
=	O
child_best_indices	*(int)
[	O
j	int
]	O
;	O
}	O
min_distance	double
=	O
DBL_MAX	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
->	O
inserted	enum(int,int)
)	O
continue	O
;	O
if	O
(	O
parent_to_child_distances	*(double)
[	O
j	int
]	O
<	O
min_distance	double
)	O
{	O
closest	int
=	O
j	int
;	O
min_distance	double
=	O
parent_to_child_distances	*(double)
[	O
j	int
]	O
;	O
}	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
;	O
j	int
++	O
)	O
{	O
double	O
inter_child_distance	double
;	O
int	O
inter_child_best_index1	int
,	O
inter_child_best_index2	int
;	O
double	O
lower_bound_on_inter_child_distance	double
;	O
bool	enum(int,int)
compute_carefully	enum(int,int)
;	O
if	O
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
->	O
inserted	enum(int,int)
)	O
continue	O
;	O
if	O
(	O
j	int
==	O
closest	int
)	O
continue	O
;	O
lower_bound_on_inter_child_distance	double
=	O
_cheap_lower_bound_on_distance	(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))),*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))->(double)
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
,	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
closest	int
]	O
)	O
;	O
compute_carefully	enum(int,int)
=	O
(	O
lower_bound_on_inter_child_distance	double
<	O
parent_to_child_distances	*(double)
[	O
j	int
]	O
)	O
?	O
true	int
:	O
false	int
;	O
if	O
(	O
compute_carefully	enum(int,int)
)	O
_compute_closest	(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,*(double),*(int),*(int))->(void)
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
closest	int
]	O
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
j	int
]	O
->	O
num_segments	int
,	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
closest	int
]	O
->	O
num_segments	int
,	O
&	O
inter_child_distance	double
,	O
&	O
inter_child_best_index1	int
,	O
&	O
inter_child_best_index2	int
)	O
;	O
if	O
(	O
compute_carefully	enum(int,int)
&&	O
inter_child_distance	double
<	O
parent_to_child_distances	*(double)
[	O
j	int
]	O
)	O
{	O
int	O
nearest_index_in_closest_child	int
;	O
new_parent_to_child_distances	*(double)
[	O
j	int
]	O
=	O
inter_child_distance	double
;	O
new_child_best_indices	*(int)
[	O
j	int
]	O
=	O
inter_child_best_index1	int
;	O
nearest_index_in_closest_child	int
=	O
inter_child_best_index2	int
;	O
if	O
(	O
nearest_index_in_closest_child	int
==	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
closest	int
]	O
->	O
num_segments	int
-	O
1	int
)	O
nearest_index_in_closest_child	int
=	O
0	int
;	O
new_parent_best_indices	*(int)
[	O
j	int
]	O
=	O
CHILD_VERTEX_IN_MERGED_PATH	O
(	O
nearest_index_in_closest_child	int
,	O
parent_best_indices	*(int)
[	O
closest	int
]	O
,	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
,	O
child_best_indices	*(int)
[	O
closest	int
]	O
,	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
closest	int
]	O
->	O
num_segments	int
)	O
;	O
}	O
else	O
{	O
int	O
nearest_index_in_parent	int
;	O
nearest_index_in_parent	int
=	O
parent_best_indices	*(int)
[	O
j	int
]	O
;	O
new_parent_best_indices	*(int)
[	O
j	int
]	O
=	O
PARENT_VERTEX_IN_MERGED_PATH	O
(	O
nearest_index_in_parent	int
,	O
parent_best_indices	*(int)
[	O
closest	int
]	O
,	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
,	O
child_best_indices	*(int)
[	O
closest	int
]	O
,	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
closest	int
]	O
->	O
num_segments	int
)	O
;	O
}	O
}	O
insert_subpath	(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,int,int)->(void)
(	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
closest	int
]	O
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
,	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
,	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
closest	int
]	O
->	O
num_segments	int
,	O
parent_best_indices	*(int)
[	O
closest	int
]	O
,	O
child_best_indices	*(int)
[	O
closest	int
]	O
)	O
;	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
num_segments	int
+=	O
(	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
closest	int
]	O
->	O
num_segments	int
+	O
1	int
)	O
;	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
children	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
[	O
closest	int
]	O
->	O
inserted	enum(int,int)
=	O
true	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
parent	*(struct(*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int))),*(*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int)))),int,int,double,double,double,double,enum(int,int)))
->	O
num_children	int
;	O
j	int
++	O
)	O
{	O
parent_to_child_distances	*(double)
[	O
j	int
]	O
=	O
new_parent_to_child_distances	*(double)
[	O
j	int
]	O
;	O
parent_best_indices	*(int)
[	O
j	int
]	O
=	O
new_parent_best_indices	*(int)
[	O
j	int
]	O
;	O
child_best_indices	*(int)
[	O
j	int
]	O
=	O
new_child_best_indices	*(int)
[	O
j	int
]	O
;	O
}	O
free	(*(void))->(void)
(	O
new_parent_to_child_distances	*(double)
)	O
;	O
free	(*(void))->(void)
(	O
new_parent_best_indices	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
new_child_best_indices	*(int)
)	O
;	O
}	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
->	O
segments	*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double)))
[	O
0	int
]	O
.	O
type	enum(int,int,int,int,int,int,int)
=	O
S_MOVETO	int
;	O
merged_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
[	O
i	int
]	O
=	O
merged_path	*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct(double,double),struct(double,double),struct(double,double))),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int)))
;	O
free	(*(void))->(void)
(	O
parent_to_child_distances	*(double)
)	O
;	O
free	(*(void))->(void)
(	O
parent_best_indices	*(int)
)	O
;	O
free	(*(void))->(void)
(	O
child_best_indices	*(int)
)	O
;	O
}	O
delete_subpath_array	(*(*(struct(*(struct`),int,*(*`),*(struct`),*(*`),int,int,double,double,double,double,enum(int,int)))),int)->(void)
(	O
annotated_paths	*(*(struct(*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,*(*(struct`)),*(struct(*`,int,*`,*`,*`,int,int,double,double,double,double,enum(int,int))),*(*(struct`)),int,int,double,double,double,double,enum(int,int))))
,	O
num_paths	int
)	O
;	O
return	O
merged_paths	*(*(struct(enum(int,int,int,int),double,double,double,double,*(struct(enum(int,int,int,int,int,int,int),struct`,struct`,struct`)),int,int,enum(int,int),struct(double,double),double,double,double,double,struct(double,double),struct(double,double),enum(int,int))))
;	O
}	O
