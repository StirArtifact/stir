static	O
size_t	long
MHD_sys_page_size_	long
=	O
MHD_DEF_PAGE_SIZE_	O
;	O
void	O
MHD_init_mem_pools_	()->(void)
(	O
void	O
)	O
{	O
MHD_sys_page_size_	long
=	O
MHD_DEF_PAGE_SIZE_	O
;	O
}	O
struct	O
MemoryPool	struct(*(char),long,long,long,bool)
{	O
uint8_t	char
*	O
memory	*(char)
;	O
size_t	long
size	long
;	O
size_t	long
pos	long
;	O
size_t	long
end	long
;	O
bool	bool
is_mmap	bool
;	O
}	O
;	O
struct	O
MemoryPool	struct(*(char),long,long,long,bool)
*	O
MHD_pool_create	(long)->(*(struct))
(	O
size_t	long
max	long
)	O
{	O
struct	O
MemoryPool	struct(*(char),long,long,long,bool)
*	O
pool	*(struct)
;	O
size_t	long
alloc_size	long
;	O
pool	*(struct)
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
MemoryPool	struct(*(char),long,long,long,bool)
)	O
)	O
;	O
if	O
(	O
NULL	O
==	O
pool	*(struct)
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
max	long
<=	O
32	int
*	O
1024	int
)	O
||	O
(	O
max	long
<	O
MHD_sys_page_size_	long
*	O
4	int
/	O
3	int
)	O
)	O
{	O
pool	*(struct)
->	O
memory	*(char)
=	O
MAP_FAILED	O
;	O
}	O
else	O
{	O
alloc_size	long
=	O
max	long
+	O
MHD_sys_page_size_	long
-	O
1	int
;	O
alloc_size	long
-=	O
alloc_size	long
%	O
MHD_sys_page_size_	long
;	O
pool	*(struct)
->	O
memory	*(char)
=	O
mmap	(*(void),long,int,int,int,long)->(*(void))
(	O
NULL	O
,	O
alloc_size	long
,	O
PROT_READ	int
|	O
PROT_WRITE	int
,	O
MAP_PRIVATE	int
|	O
MAP_ANONYMOUS	int
,	O
-	O
1	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
MAP_FAILED	O
==	O
pool	*(struct)
->	O
memory	*(char)
)	O
{	O
alloc_size	long
=	O
ROUND_TO_ALIGN	O
(	O
max	long
)	O
;	O
pool	*(struct)
->	O
memory	*(char)
=	O
malloc	(long)->(*(void))
(	O
alloc_size	long
)	O
;	O
if	O
(	O
NULL	O
==	O
pool	*(struct)
->	O
memory	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
pool	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
pool	*(struct)
->	O
is_mmap	bool
=	O
false	int
;	O
}	O
else	O
{	O
pool	*(struct)
->	O
is_mmap	bool
=	O
true	int
;	O
}	O
pool	*(struct)
->	O
pos	long
=	O
0	int
;	O
pool	*(struct)
->	O
end	long
=	O
alloc_size	long
;	O
pool	*(struct)
->	O
size	long
=	O
alloc_size	long
;	O
return	O
pool	*(struct)
;	O
}	O
void	O
MHD_pool_destroy	(*(struct))->(void)
(	O
struct	O
MemoryPool	struct(*(char),long,long,long,bool)
*	O
pool	*(struct)
)	O
{	O
if	O
(	O
NULL	O
==	O
pool	*(struct)
)	O
return	O
;	O
mhd_assert	O
(	O
pool	*(struct)
->	O
end	long
>=	O
pool	*(struct)
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
pool	*(struct)
->	O
size	long
>=	O
pool	*(struct)
->	O
end	long
-	O
pool	*(struct)
->	O
pos	long
)	O
;	O
if	O
(	O
!	O
pool	*(struct)
->	O
is_mmap	bool
)	O
free	(*(void))->(void)
(	O
pool	*(struct)
->	O
memory	*(char)
)	O
;	O
else	O
munmap	(*(void),long)->(int)
(	O
pool	*(struct)
->	O
memory	*(char)
,	O
pool	*(struct)
->	O
size	long
)	O
;	O
free	(*(void))->(void)
(	O
pool	*(struct)
)	O
;	O
}	O
size_t	long
MHD_pool_get_free	(*(struct))->(long)
(	O
struct	O
MemoryPool	struct(*(char),long,long,long,bool)
*	O
pool	*(struct)
)	O
{	O
mhd_assert	O
(	O
pool	*(struct)
->	O
end	long
>=	O
pool	*(struct)
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
pool	*(struct)
->	O
size	long
>=	O
pool	*(struct)
->	O
end	long
-	O
pool	*(struct)
->	O
pos	long
)	O
;	O
return	O
(	O
pool	*(struct)
->	O
end	long
-	O
pool	*(struct)
->	O
pos	long
)	O
;	O
}	O
void	O
*	O
MHD_pool_allocate	(*(struct),long,bool)->(*(void))
(	O
struct	O
MemoryPool	struct(*(char),long,long,long,bool)
*	O
pool	*(struct)
,	O
size_t	long
size	long
,	O
bool	bool
from_end	bool
)	O
{	O
void	O
*	O
ret	*(void)
;	O
size_t	long
asize	long
;	O
mhd_assert	O
(	O
pool	*(struct)
->	O
end	long
>=	O
pool	*(struct)
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
pool	*(struct)
->	O
size	long
>=	O
pool	*(struct)
->	O
end	long
-	O
pool	*(struct)
->	O
pos	long
)	O
;	O
asize	long
=	O
ROUND_TO_ALIGN	O
(	O
size	long
)	O
;	O
if	O
(	O
(	O
0	int
==	O
asize	long
)	O
&&	O
(	O
0	int
!=	O
size	long
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
pool	*(struct)
->	O
pos	long
+	O
asize	long
>	O
pool	*(struct)
->	O
end	long
)	O
||	O
(	O
pool	*(struct)
->	O
pos	long
+	O
asize	long
<	O
pool	*(struct)
->	O
pos	long
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
from_end	bool
)	O
{	O
ret	*(void)
=	O
&	O
pool	*(struct)
->	O
memory	*(char)
[	O
pool	*(struct)
->	O
end	long
-	O
asize	long
]	O
;	O
pool	*(struct)
->	O
end	long
-=	O
asize	long
;	O
}	O
else	O
{	O
ret	*(void)
=	O
&	O
pool	*(struct)
->	O
memory	*(char)
[	O
pool	*(struct)
->	O
pos	long
]	O
;	O
pool	*(struct)
->	O
pos	long
+=	O
asize	long
;	O
}	O
return	O
ret	*(void)
;	O
}	O
void	O
*	O
MHD_pool_reallocate	(*(struct),*(void),long,long)->(*(void))
(	O
struct	O
MemoryPool	struct(*(char),long,long,long,bool)
*	O
pool	*(struct)
,	O
void	O
*	O
old	*(void)
,	O
size_t	long
old_size	long
,	O
size_t	long
new_size	long
)	O
{	O
size_t	long
asize	long
;	O
uint8_t	char
*	O
new_blc	*(char)
;	O
mhd_assert	O
(	O
pool	*(struct)
->	O
end	long
>=	O
pool	*(struct)
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
pool	*(struct)
->	O
size	long
>=	O
pool	*(struct)
->	O
end	long
-	O
pool	*(struct)
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
old	*(void)
!=	O
NULL	O
||	O
old_size	long
==	O
0	int
)	O
;	O
mhd_assert	O
(	O
old	*(void)
==	O
NULL	O
||	O
pool	*(struct)
->	O
memory	*(char)
<=	O
(	O
uint8_t	char
*	O
)	O
old	*(void)
)	O
;	O
mhd_assert	O
(	O
old	*(void)
==	O
NULL	O
||	O
pool	*(struct)
->	O
memory	*(char)
+	O
pool	*(struct)
->	O
size	long
>=	O
(	O
uint8_t	char
*	O
)	O
old	*(void)
+	O
old_size	long
)	O
;	O
mhd_assert	O
(	O
old	*(void)
==	O
NULL	O
||	O
pool	*(struct)
->	O
memory	*(char)
+	O
pool	*(struct)
->	O
pos	long
>	O
(	O
uint8_t	char
*	O
)	O
old	*(void)
)	O
;	O
if	O
(	O
0	int
!=	O
old_size	long
)	O
{	O
const	O
size_t	long
old_offset	long
=	O
(	O
uint8_t	char
*	O
)	O
old	*(void)
-	O
pool	*(struct)
->	O
memory	*(char)
;	O
const	O
bool	bool
shrinking	bool
=	O
(	O
old_size	long
>	O
new_size	long
)	O
;	O
if	O
(	O
shrinking	bool
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
uint8_t	char
*	O
)	O
old	*(void)
+	O
new_size	long
,	O
0	int
,	O
old_size	long
-	O
new_size	long
)	O
;	O
}	O
if	O
(	O
pool	*(struct)
->	O
pos	long
==	O
ROUND_TO_ALIGN	O
(	O
old_offset	long
+	O
old_size	long
)	O
)	O
{	O
const	O
size_t	long
new_apos	long
=	O
ROUND_TO_ALIGN	O
(	O
old_offset	long
+	O
new_size	long
)	O
;	O
if	O
(	O
!	O
shrinking	bool
)	O
{	O
if	O
(	O
(	O
new_apos	long
>	O
pool	*(struct)
->	O
end	long
)	O
||	O
(	O
new_apos	long
<	O
pool	*(struct)
->	O
pos	long
)	O
)	O
return	O
NULL	O
;	O
}	O
pool	*(struct)
->	O
pos	long
=	O
new_apos	long
;	O
return	O
old	*(void)
;	O
}	O
if	O
(	O
shrinking	bool
)	O
return	O
old	*(void)
;	O
}	O
asize	long
=	O
ROUND_TO_ALIGN	O
(	O
new_size	long
)	O
;	O
if	O
(	O
(	O
(	O
0	int
==	O
asize	long
)	O
&&	O
(	O
0	int
!=	O
new_size	long
)	O
)	O
||	O
(	O
asize	long
>	O
pool	*(struct)
->	O
end	long
-	O
pool	*(struct)
->	O
pos	long
)	O
)	O
return	O
NULL	O
;	O
new_blc	*(char)
=	O
pool	*(struct)
->	O
memory	*(char)
+	O
pool	*(struct)
->	O
pos	long
;	O
pool	*(struct)
->	O
pos	long
+=	O
asize	long
;	O
if	O
(	O
0	int
!=	O
old_size	long
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_blc	*(char)
,	O
old	*(void)
,	O
old_size	long
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
old	*(void)
,	O
0	int
,	O
old_size	long
)	O
;	O
}	O
return	O
new_blc	*(char)
;	O
}	O
void	O
*	O
MHD_pool_reset	(*(struct),*(void),long,long)->(*(void))
(	O
struct	O
MemoryPool	struct(*(char),long,long,long,bool)
*	O
pool	*(struct)
,	O
void	O
*	O
keep	*(void)
,	O
size_t	long
copy_bytes	long
,	O
size_t	long
new_size	long
)	O
{	O
mhd_assert	O
(	O
pool	*(struct)
->	O
end	long
>=	O
pool	*(struct)
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
pool	*(struct)
->	O
size	long
>=	O
pool	*(struct)
->	O
end	long
-	O
pool	*(struct)
->	O
pos	long
)	O
;	O
mhd_assert	O
(	O
copy_bytes	long
<	O
new_size	long
)	O
;	O
mhd_assert	O
(	O
keep	*(void)
!=	O
NULL	O
||	O
copy_bytes	long
==	O
0	int
)	O
;	O
mhd_assert	O
(	O
keep	*(void)
==	O
NULL	O
||	O
pool	*(struct)
->	O
memory	*(char)
<=	O
(	O
uint8_t	char
*	O
)	O
keep	*(void)
)	O
;	O
mhd_assert	O
(	O
keep	*(void)
==	O
NULL	O
||	O
pool	*(struct)
->	O
memory	*(char)
+	O
pool	*(struct)
->	O
size	long
>=	O
(	O
uint8_t	char
*	O
)	O
keep	*(void)
+	O
copy_bytes	long
)	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
keep	*(void)
)	O
&&	O
(	O
keep	*(void)
!=	O
pool	*(struct)
->	O
memory	*(char)
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
copy_bytes	long
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
pool	*(struct)
->	O
memory	*(char)
,	O
keep	*(void)
,	O
copy_bytes	long
)	O
;	O
}	O
if	O
(	O
pool	*(struct)
->	O
size	long
>	O
copy_bytes	long
)	O
{	O
size_t	long
to_zero	long
;	O
to_zero	long
=	O
pool	*(struct)
->	O
size	long
-	O
copy_bytes	long
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
pool	*(struct)
->	O
memory	*(char)
[	O
copy_bytes	long
]	O
,	O
0	int
,	O
to_zero	long
)	O
;	O
}	O
pool	*(struct)
->	O
pos	long
=	O
ROUND_TO_ALIGN	O
(	O
new_size	long
)	O
;	O
pool	*(struct)
->	O
end	long
=	O
pool	*(struct)
->	O
size	long
;	O
return	O
pool	*(struct)
->	O
memory	*(char)
;	O
}	O
