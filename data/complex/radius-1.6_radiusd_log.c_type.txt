static	O
int	O
logging_category	int
=	O
GRAD_LOG_CAT	O
(	O
GRAD_LOG_MAIN	O
)	O
;	O
static	O
grad_list_t	struct
*	O
chanlist	*(struct)
;	O
static	O
char	O
*	O
log_prefix_hook	*(char)
;	O
static	O
char	O
*	O
log_suffix_hook	*(char)
;	O
struct	O
log_data	struct(int,int,*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))),*(char),*(char),*(char))
{	O
int	O
cat	int
;	O
int	O
pri	int
;	O
const	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
;	O
const	O
char	O
*	O
prefix	*(char)
;	O
const	O
char	O
*	O
text	*(char)
;	O
const	O
char	O
*	O
errtext	*(char)
;	O
}	O
;	O
struct	O
logbuf	struct(*(char),long,long)
{	O
char	O
*	O
ptr	*(*(void))
;	O
size_t	long
size	int
;	O
size_t	long
pos	long
;	O
}	O
;	O
void	O
logbuf_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
struct	O
logbuf	struct(*(char),long,long)
*	O
buf	*(char)
,	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
size_t	long
length	short
=	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
;	O
size_t	long
rest	*(char)
=	O
buf	*(char)
->	O
size	int
-	O
buf	*(char)
->	O
pos	long
;	O
if	O
(	O
rest	*(char)
<=	O
1	int
)	O
buf	*(char)
->	O
ptr	*(*(void))
[	O
buf	*(char)
->	O
pos	long
-	O
1	int
]	O
=	O
'>'	O
;	O
else	O
if	O
(	O
rest	*(char)
==	O
2	int
)	O
buf	*(char)
->	O
ptr	*(*(void))
[	O
buf	*(char)
->	O
pos	long
++	O
]	O
=	O
'>'	O
;	O
else	O
if	O
(	O
length	short
>=	O
rest	*(char)
)	O
{	O
if	O
(	O
--	O
rest	*(char)
>	O
1	int
)	O
{	O
if	O
(	O
rest	*(char)
>=	O
2	int
)	O
rest	*(char)
--	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	*(char)
->	O
ptr	*(*(void))
+	O
buf	*(char)
->	O
pos	long
,	O
str	*(char)
,	O
rest	*(char)
)	O
;	O
buf	*(char)
->	O
pos	long
+=	O
rest	*(char)
;	O
}	O
buf	*(char)
->	O
ptr	*(*(void))
[	O
buf	*(char)
->	O
pos	long
++	O
]	O
=	O
'>'	O
;	O
}	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
buf	*(char)
->	O
ptr	*(*(void))
+	O
buf	*(char)
->	O
pos	long
,	O
str	*(char)
,	O
length	short
)	O
;	O
buf	*(char)
->	O
pos	long
+=	O
length	short
;	O
}	O
}	O
void	O
logbuf_append_line	(*(struct(*(char),long,long)),long)->(void)
(	O
struct	O
logbuf	struct(*(char),long,long)
*	O
buf	*(char)
,	O
size_t	long
line	long
)	O
{	O
char	O
linestr	array(char)
[	O
64	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
linestr	array(char)
,	O
sizeof	O
(	O
linestr	array(char)
)	O
,	O
"%lu"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
line	long
)	O
;	O
logbuf_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
buf	*(char)
,	O
linestr	array(char)
)	O
;	O
}	O
void	O
logbuf_vformat	(*(struct(*(char),long,long)),*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
struct	O
logbuf	struct(*(char),long,long)
*	O
buf	*(char)
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
size_t	long
rest	*(char)
=	O
buf	*(char)
->	O
size	int
-	O
buf	*(char)
->	O
pos	long
;	O
size_t	long
length	short
;	O
int	O
n	long
;	O
if	O
(	O
rest	*(char)
<=	O
1	int
)	O
return	O
;	O
n	long
=	O
vsnprintf	(*(char),long,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
buf	*(char)
->	O
ptr	*(*(void))
+	O
buf	*(char)
->	O
pos	long
,	O
rest	*(char)
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
length	short
=	O
strlen	(*(char))->(long)
(	O
buf	*(char)
->	O
ptr	*(*(void))
+	O
buf	*(char)
->	O
pos	long
)	O
;	O
buf	*(char)
->	O
pos	long
+=	O
length	short
;	O
if	O
(	O
n	long
==	O
-	O
1	int
||	O
length	short
<	O
n	long
)	O
buf	*(char)
->	O
ptr	*(*(void))
[	O
buf	*(char)
->	O
pos	long
-	O
1	int
]	O
=	O
'>'	O
;	O
}	O
char	O
*	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
struct	O
logbuf	struct(*(char),long,long)
*	O
buf	*(char)
)	O
{	O
buf	*(char)
->	O
ptr	*(*(void))
[	O
buf	*(char)
->	O
pos	long
]	O
=	O
0	int
;	O
return	O
buf	*(char)
->	O
ptr	*(*(void))
;	O
}	O
size_t	long
logbuf_printable_length	(*(struct(*(char),long,long)))->(long)
(	O
struct	O
logbuf	struct(*(char),long,long)
*	O
buf	*(char)
)	O
{	O
return	O
buf	*(char)
->	O
pos	long
;	O
}	O
static	O
int	O
log_get_category	()->(int)
(	O
)	O
{	O
return	O
logging_category	int
;	O
}	O
static	O
void	O
log_set_category	(int)->(void)
(	O
int	O
cat	int
)	O
{	O
logging_category	int
=	O
GRAD_LOG_CAT	O
(	O
cat	int
)	O
;	O
}	O
void	O
log_open	(int)->(void)
(	O
int	O
cat	int
)	O
{	O
log_set_category	(int)->(void)
(	O
cat	int
)	O
;	O
}	O
void	O
log_close	()->(void)
(	O
)	O
{	O
log_set_category	(int)->(void)
(	O
GRAD_LOG_MAIN	O
)	O
;	O
}	O
static	O
char	O
*	O
catname	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"none"	*(char)
)	O
,	O
N_	O
(	O
"Main"	*(char)
)	O
,	O
N_	O
(	O
"Auth"	*(char)
)	O
,	O
N_	O
(	O
"Acct"	*(char)
)	O
,	O
N_	O
(	O
"Proxy"	*(char)
)	O
,	O
N_	O
(	O
"SNMP"	*(char)
)	O
,	O
}	O
;	O
static	O
char	O
*	O
priname	array(*(char))
[	O
]	O
=	O
{	O
N_	O
(	O
"emerg"	*(char)
)	O
,	O
N_	O
(	O
"alert"	*(char)
)	O
,	O
N_	O
(	O
"crit"	*(char)
)	O
,	O
N_	O
(	O
"error"	*(char)
)	O
,	O
N_	O
(	O
"warning"	*(char)
)	O
,	O
N_	O
(	O
"notice"	*(char)
)	O
,	O
N_	O
(	O
"info"	*(char)
)	O
,	O
N_	O
(	O
"debug"	*(char)
)	O
}	O
;	O
static	O
char	O
*	O
run_log_hook	(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(char))->(*(char))
(	O
const	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
const	O
char	O
*	O
hook_name	*(char)
)	O
{	O
grad_value_t	struct(enum(int,int,int),union(int,struct(long,*(char))))
val	array(int)
;	O
char	O
nasbuf	array(char)
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
val	array(int)
,	O
0	int
,	O
sizeof	O
(	O
val	array(int)
)	O
)	O
;	O
if	O
(	O
rewrite_invoke	(enum(int,int,int),*(struct(enum(int,int,int),union(int,struct(long,*`)))),*(char),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(char))->(int)
(	O
String	int
,	O
&	O
val	array(int)
,	O
hook_name	*(char)
,	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
"isi"	*(char)
,	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
code	char
,	O
grad_nas_request_to_name	(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(char),long)->(*(char))
(	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
nasbuf	array(char)
,	O
sizeof	O
nasbuf	array(char)
)	O
,	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
->	O
id	char
)	O
)	O
return	O
NULL	O
;	O
return	O
val	array(int)
.	O
datum	union(int,struct(long,*(char)))
.	O
sval	struct(long,*(char))
.	O
data	*(void)
;	O
}	O
static	O
void	O
log_format_hook	(*(struct(*(char),long,long)),*(*(char)),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))->(void)
(	O
struct	O
logbuf	struct(*(char),long,long)
*	O
bufp	*(struct(*(char),long,long))
,	O
char	O
*	O
*	O
hook_name_ptr	*(*(char))
,	O
const	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
{	O
char	O
*	O
hook_res	*(char)
=	O
NULL	O
;	O
if	O
(	O
*	O
hook_name_ptr	*(*(char))
)	O
{	O
hook_res	*(char)
=	O
run_log_hook	(*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(char))->(*(char))
(	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
*	O
hook_name_ptr	*(*(char))
)	O
;	O
if	O
(	O
!	O
hook_res	*(char)
)	O
*	O
hook_name_ptr	*(*(char))
=	O
NULL	O
;	O
}	O
if	O
(	O
hook_res	*(char)
)	O
{	O
logbuf_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
bufp	*(struct(*(char),long,long))
,	O
hook_res	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
hook_res	*(char)
)	O
;	O
}	O
}	O
static	O
FILE	struct
*	O
channel_open_file	(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
Channel	struct
*	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
{	O
FILE	struct
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
NULL	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
file	*(char)
,	O
"stdout"	*(char)
)	O
)	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
file	*(char)
,	O
"a"	*(char)
)	O
;	O
return	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
?	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
:	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
static	O
void	O
channel_close_file	(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
Channel	struct
*	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
,	O
FILE	struct
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
{	O
if	O
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
!=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
;	O
}	O
int	O
log_to_channel	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
pdata	*(void)
)	O
{	O
Channel	struct
*	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
item	*(void)
;	O
struct	O
log_data	struct(int,int,*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))),*(char),*(char),*(char))
*	O
data	*(void)
=	O
pdata	*(void)
;	O
LOGBUF_DECL	O
(	O
pri_prefix	struct(*(char),long,long)
,	O
64	int
)	O
;	O
LOGBUF_DECL	O
(	O
req_prefix	struct(*(char),long,long)
,	O
256	int
)	O
;	O
LOGBUF_DECL	O
(	O
req_suffix	struct(*(char),long,long)
,	O
256	int
)	O
;	O
time_t	long
timeval	struct(long,long)
;	O
char	O
buffer	*(char)
[	O
256	int
]	O
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
,	O
tms	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
int	O
spri	int
;	O
FILE	struct
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
if	O
(	O
!	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
pmask	array(int)
[	O
data	*(void)
->	O
cat	int
]	O
&	O
GRAD_LOG_MASK	O
(	O
data	*(void)
->	O
pri	int
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
options	int
&	O
LO_CAT	int
)	O
{	O
logbuf_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
pri_prefix	struct(*(char),long,long)
,	O
_	O
(	O
catname	array(*(char))
[	O
data	*(void)
->	O
cat	int
]	O
)	O
)	O
;	O
logbuf_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
pri_prefix	struct(*(char),long,long)
,	O
"."	*(char)
)	O
;	O
}	O
if	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
options	int
&	O
LO_PRI	int
)	O
logbuf_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
pri_prefix	struct(*(char),long,long)
,	O
_	O
(	O
priname	array(*(char))
[	O
data	*(void)
->	O
pri	int
]	O
)	O
)	O
;	O
if	O
(	O
data	*(void)
->	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
{	O
log_format_hook	(*(struct(*(char),long,long)),*(*(char)),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))->(void)
(	O
&	O
req_prefix	struct(*(char),long,long)
,	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
prefix_hook	*(char)
?	O
&	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
prefix_hook	*(char)
:	O
&	O
log_prefix_hook	*(char)
,	O
data	*(void)
->	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
;	O
log_format_hook	(*(struct(*(char),long,long)),*(*(char)),*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))))->(void)
(	O
&	O
req_suffix	struct(*(char),long,long)
,	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
suffix_hook	*(char)
?	O
&	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
suffix_hook	*(char)
:	O
&	O
log_suffix_hook	*(char)
,	O
data	*(void)
->	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
)	O
;	O
}	O
switch	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
mode	int
)	O
{	O
case	O
LM_FILE	int
:	O
if	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
options	int
&	O
LO_MSEC	int
)	O
{	O
struct	O
timeval	struct(long,long)
tv	*(struct(long,long))
;	O
int	O
len	int
;	O
gettimeofday	(*(struct(long,long)),*(void))->(int)
(	O
&	O
tv	*(struct(long,long))
,	O
NULL	O
)	O
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
localtime_r	(*(long),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
tv	*(struct(long,long))
.	O
tv_sec	long
,	O
&	O
tms	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
buffer	*(char)
,	O
sizeof	O
(	O
buffer	*(char)
)	O
,	O
"%b %d %H:%M:%S"	*(char)
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
buffer	*(char)
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	*(char)
+	O
len	int
,	O
sizeof	O
(	O
buffer	*(char)
)	O
-	O
len	int
,	O
".%06d"	*(char)
,	O
(	O
int	O
)	O
tv	*(struct(long,long))
.	O
tv_usec	long
)	O
;	O
}	O
else	O
{	O
timeval	struct(long,long)
=	O
time	struct(long,long)
(	O
NULL	O
)	O
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
localtime_r	(*(long),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
timeval	struct(long,long)
,	O
&	O
tms	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
buffer	*(char)
,	O
sizeof	O
(	O
buffer	*(char)
)	O
,	O
"%b %d %H:%M:%S"	*(char)
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
)	O
;	O
}	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
channel_open_file	(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
;	O
if	O
(	O
!	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
break	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"%s "	*(char)
,	O
buffer	*(char)
)	O
;	O
if	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
options	int
&	O
LO_PID	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"[%lu]: "	*(char)
,	O
(	O
u_long	long
)	O
getpid	()->(int)
(	O
)	O
)	O
;	O
if	O
(	O
logbuf_printable_length	(*(struct(*(char),long,long)))->(long)
(	O
&	O
pri_prefix	struct(*(char),long,long)
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"%s: "	*(char)
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
pri_prefix	struct(*(char),long,long)
)	O
)	O
;	O
if	O
(	O
data	*(void)
->	O
prefix	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"%s"	*(char)
,	O
data	*(void)
->	O
prefix	*(char)
)	O
;	O
if	O
(	O
logbuf_printable_length	(*(struct(*(char),long,long)))->(long)
(	O
&	O
req_prefix	struct(*(char),long,long)
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"%s"	*(char)
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
req_prefix	struct(*(char),long,long)
)	O
)	O
;	O
if	O
(	O
data	*(void)
->	O
text	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"%s"	*(char)
,	O
data	*(void)
->	O
text	*(char)
)	O
;	O
if	O
(	O
data	*(void)
->	O
errtext	*(char)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
": %s"	*(char)
,	O
data	*(void)
->	O
errtext	*(char)
)	O
;	O
if	O
(	O
logbuf_printable_length	(*(struct(*(char),long,long)))->(long)
(	O
&	O
req_suffix	struct(*(char),long,long)
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"%s"	*(char)
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
req_suffix	struct(*(char),long,long)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
,	O
"\n"	*(char)
)	O
;	O
channel_close_file	(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
,	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
;	O
break	O
;	O
case	O
LM_SYSLOG	int
:	O
spri	int
=	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
prio	int
;	O
openlog	(*(char),int,int)->(void)
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
tag	char
?	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
tag	char
:	O
"radiusd"	*(char)
,	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
options	int
&	O
LO_PID	int
)	O
?	O
LOG_PID	int
:	O
0	int
,	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
fac	int
)	O
;	O
if	O
(	O
logbuf_printable_length	(*(struct(*(char),long,long)))->(long)
(	O
&	O
pri_prefix	struct(*(char),long,long)
)	O
)	O
{	O
if	O
(	O
data	*(void)
->	O
errtext	*(char)
)	O
syslog	(int,*(char))->(void)
(	O
spri	int
,	O
"%s: %s%s%s: %s%s"	*(char)
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
pri_prefix	struct(*(char),long,long)
)	O
,	O
SP	O
(	O
data	*(void)
->	O
prefix	*(char)
)	O
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
req_prefix	struct(*(char),long,long)
)	O
,	O
SP	O
(	O
data	*(void)
->	O
text	*(char)
)	O
,	O
data	*(void)
->	O
errtext	*(char)
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
req_suffix	struct(*(char),long,long)
)	O
)	O
;	O
else	O
syslog	(int,*(char))->(void)
(	O
spri	int
,	O
"%s: %s%s%s%s"	*(char)
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
pri_prefix	struct(*(char),long,long)
)	O
,	O
SP	O
(	O
data	*(void)
->	O
prefix	*(char)
)	O
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
req_prefix	struct(*(char),long,long)
)	O
,	O
SP	O
(	O
data	*(void)
->	O
text	*(char)
)	O
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
req_suffix	struct(*(char),long,long)
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
data	*(void)
->	O
errtext	*(char)
)	O
syslog	(int,*(char))->(void)
(	O
spri	int
,	O
"%s%s%s: %s%s"	*(char)
,	O
SP	O
(	O
data	*(void)
->	O
prefix	*(char)
)	O
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
req_prefix	struct(*(char),long,long)
)	O
,	O
SP	O
(	O
data	*(void)
->	O
text	*(char)
)	O
,	O
data	*(void)
->	O
errtext	*(char)
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
req_suffix	struct(*(char),long,long)
)	O
)	O
;	O
else	O
syslog	(int,*(char))->(void)
(	O
spri	int
,	O
"%s%s%s%s"	*(char)
,	O
SP	O
(	O
data	*(void)
->	O
prefix	*(char)
)	O
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
req_prefix	struct(*(char),long,long)
)	O
,	O
SP	O
(	O
data	*(void)
->	O
text	*(char)
)	O
,	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
req_suffix	struct(*(char),long,long)
)	O
)	O
;	O
}	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
radiusd_logger	(int,*(struct(int,short,char,char,array(char),*(char),*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)))),*(struct(*(char),long)),*(char),int,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
int	O
level	int
,	O
const	O
grad_request_t	struct(int,short,char,char,array(char),*(char),*(struct(*(struct(*`,*`,int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union`)),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*`)))))
*	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
,	O
const	O
grad_locus_t	struct(*(char),long)
*	O
loc	struct(*(char),long)
,	O
const	O
char	O
*	O
func_name	*(char)
,	O
int	O
en	int
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
)	O
{	O
Channel	struct
*	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
;	O
int	O
cat	int
,	O
pri	int
;	O
struct	O
log_data	struct(int,int,*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))),*(char),*(char),*(char))
log_data	struct(int,int,*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))),*(char),*(char),*(char))
;	O
LOGBUF_DECL	O
(	O
buf1	struct(*(char),long,long)
,	O
256	int
)	O
;	O
LOGBUF_DECL	O
(	O
buf2	struct(*(char),long,long)
,	O
1024	int
)	O
;	O
char	O
*	O
errstr	*(char)
=	O
NULL	O
;	O
cat	int
=	O
GRAD_LOG_CAT	O
(	O
level	int
)	O
;	O
if	O
(	O
cat	int
==	O
0	int
)	O
cat	int
=	O
log_get_category	()->(int)
(	O
)	O
;	O
pri	int
=	O
GRAD_LOG_PRI	O
(	O
level	int
)	O
;	O
if	O
(	O
loc	struct(*(char),long)
&&	O
loc	struct(*(char),long)
->	O
file	*(char)
)	O
{	O
logbuf_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buf1	struct(*(char),long,long)
,	O
loc	struct(*(char),long)
->	O
file	*(char)
)	O
;	O
logbuf_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buf1	struct(*(char),long,long)
,	O
":"	*(char)
)	O
;	O
logbuf_append_line	(*(struct(*(char),long,long)),long)->(void)
(	O
&	O
buf1	struct(*(char),long,long)
,	O
loc	struct(*(char),long)
->	O
line	long
)	O
;	O
if	O
(	O
func_name	*(char)
)	O
{	O
logbuf_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buf1	struct(*(char),long,long)
,	O
":"	*(char)
)	O
;	O
logbuf_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buf1	struct(*(char),long,long)
,	O
func_name	*(char)
)	O
;	O
}	O
logbuf_append	(*(struct(*(char),long,long)),*(char))->(void)
(	O
&	O
buf1	struct(*(char),long,long)
,	O
": "	*(char)
)	O
;	O
}	O
if	O
(	O
en	int
)	O
errstr	*(char)
=	O
strerror	(int)->(*(char))
(	O
en	int
)	O
;	O
logbuf_vformat	(*(struct(*(char),long,long)),*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
&	O
buf2	struct(*(char),long,long)
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
log_data	struct(int,int,*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))),*(char),*(char),*(char))
.	O
cat	int
=	O
cat	int
;	O
log_data	struct(int,int,*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))),*(char),*(char),*(char))
.	O
pri	int
=	O
pri	int
;	O
log_data	struct(int,int,*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))),*(char),*(char),*(char))
.	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
=	O
req	*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`)))))
;	O
log_data	struct(int,int,*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))),*(char),*(char),*(char))
.	O
prefix	*(char)
=	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buf1	struct(*(char),long,long)
)	O
;	O
log_data	struct(int,int,*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))),*(char),*(char),*(char))
.	O
text	*(char)
=	O
logbuf_ptr	(*(struct(*(char),long,long)))->(*(char))
(	O
&	O
buf2	struct(*(char),long,long)
)	O
;	O
log_data	struct(int,int,*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))),*(char),*(char),*(char))
.	O
errtext	*(char)
=	O
errstr	*(char)
;	O
grad_list_iterate	(*(struct),*((*(void),*(void))->(int)),*(void))->(void)
(	O
chanlist	*(struct)
,	O
log_to_channel	(*(void),*(void))->(int)
,	O
&	O
log_data	struct(int,int,*(struct(int,short,char,char,array(char),*(char),*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))))),*(char),*(char),*(char))
)	O
;	O
}	O
void	O
channel_free	(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(void)
(	O
Channel	struct
*	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
{	O
grad_free	(*(void))->(void)
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
mode	int
==	O
LM_FILE	int
)	O
grad_free	(*(void))->(void)
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
file	*(char)
)	O
;	O
else	O
grad_free	(*(void))->(void)
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
tag	char
)	O
;	O
grad_free	(*(void))->(void)
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
prefix_hook	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
suffix_hook	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
;	O
}	O
Channel	struct
*	O
log_mark	()->(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))
(	O
)	O
{	O
return	O
grad_list_item	(*(struct),long)->(*(void))
(	O
chanlist	*(struct)
,	O
0	int
)	O
;	O
}	O
void	O
log_release	()->(void)
(	O
Channel	struct
*	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
{	O
Channel	struct
*	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
;	O
int	O
emerg	int
,	O
alert	int
,	O
crit	int
;	O
grad_iterator_t	struct
*	O
itr	*((*(void),*(void))->(int))
=	O
grad_iterator_create	(*(struct))->(*(struct))
(	O
chanlist	*(struct)
)	O
;	O
for	O
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
grad_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
;	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
grad_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
if	O
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
==	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
break	O
;	O
for	O
(	O
;	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
;	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
grad_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
if	O
(	O
!	O
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
options	int
&	O
LO_PERSIST	int
)	O
)	O
{	O
grad_list_remove	(*(struct),*(void),*((*(void),*(void))->(int)))->(*(void))
(	O
chanlist	*(struct)
,	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
,	O
NULL	O
)	O
;	O
channel_free	(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(void)
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
;	O
}	O
}	O
emerg	int
=	O
GRAD_LOG_EMERG	int
;	O
alert	int
=	O
GRAD_LOG_ALERT	int
;	O
crit	int
=	O
GRAD_LOG_CRIT	int
;	O
for	O
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
grad_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
;	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
grad_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
GRAD_LOG_NCAT	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
emerg	int
&&	O
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
pmask	array(int)
[	O
i	int
]	O
&	O
GRAD_LOG_MASK	O
(	O
emerg	int
)	O
)	O
)	O
emerg	int
=	O
0	int
;	O
if	O
(	O
alert	int
&&	O
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
pmask	array(int)
[	O
i	int
]	O
&	O
GRAD_LOG_MASK	O
(	O
alert	int
)	O
)	O
)	O
alert	int
=	O
0	int
;	O
if	O
(	O
crit	int
&&	O
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
pmask	array(int)
[	O
i	int
]	O
&	O
GRAD_LOG_MASK	O
(	O
crit	int
)	O
)	O
)	O
crit	int
=	O
0	int
;	O
}	O
}	O
grad_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
if	O
(	O
emerg	int
||	O
alert	int
||	O
crit	int
)	O
log_set_default	(*(char),int,int)->(void)
(	O
"##emerg##"	*(char)
,	O
-	O
1	int
,	O
emerg	int
|	O
alert	int
|	O
crit	int
)	O
;	O
}	O
int	O
log_change_owner	(*(struct(*(char),int,int)))->(int)
(	O
RADIUS_USER	struct(*(char),int,int)
*	O
usr	*(struct(*(char),int,int))
)	O
{	O
Channel	struct
*	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
;	O
int	O
errcnt	long
=	O
0	int
;	O
grad_iterator_t	struct
*	O
itr	*((*(void),*(void))->(int))
=	O
grad_iterator_create	(*(struct))->(*(struct))
(	O
chanlist	*(struct)
)	O
;	O
for	O
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
grad_iterator_first	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
;	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
;	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
grad_iterator_next	(*(struct))->(*(void))
(	O
itr	*((*(void),*(void))->(int))
)	O
)	O
{	O
if	O
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
mode	int
==	O
LM_FILE	int
&&	O
chown	(*(char),int,int)->(int)
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
file	*(char)
,	O
usr	*(struct(*(char),int,int))
->	O
uid	int
,	O
usr	*(struct(*(char),int,int))
->	O
gid	int
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"%s: cannot change owner to %d:%d"	*(char)
)	O
,	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
file	*(char)
,	O
usr	*(struct(*(char),int,int))
->	O
uid	int
,	O
usr	*(struct(*(char),int,int))
->	O
gid	int
)	O
;	O
errcnt	long
++	O
;	O
}	O
}	O
grad_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*((*(void),*(void))->(int))
)	O
;	O
return	O
errcnt	long
;	O
}	O
static	O
int	O
_chancmp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
data	*(void)
)	O
{	O
const	O
Channel	struct
*	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
item	*(void)
;	O
const	O
char	O
*	O
name	*(char)
=	O
data	*(void)
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
name	*(char)
,	O
name	*(char)
)	O
;	O
}	O
Channel	struct
*	O
channel_lookup	(*(char))->(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))
(	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
grad_list_locate	(*(struct),*(void),*((*(void),*(void))->(int)))->(*(void))
(	O
chanlist	*(struct)
,	O
name	*(char)
,	O
_chancmp	(*(void),*(void))->(int)
)	O
;	O
}	O
void	O
register_channel	(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(void)
(	O
Channel	struct
*	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
{	O
FILE	struct
*	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
;	O
Channel	struct
*	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
;	O
char	O
*	O
filename	*(char)
;	O
if	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
mode	int
==	O
LM_FILE	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
file	*(char)
,	O
"stdout"	*(char)
)	O
)	O
{	O
filename	*(char)
=	O
grad_mkfilename	(*(char),*(char))->(*(char))
(	O
grad_log_dir	*(char)
?	O
grad_log_dir	*(char)
:	O
RADLOG_DIR	O
,	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
file	*(char)
)	O
;	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"a"	*(char)
)	O
;	O
if	O
(	O
!	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_CRIT	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't access log file `%s'"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
grad_free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
filename	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
"stdout"	*(char)
)	O
;	O
}	O
else	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*((*(void),*(char),*(struct(*(char),int,int,int,int,*((*`,*`)->(int)))))->(int))
)	O
;	O
}	O
else	O
filename	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
"stdout"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
mode	int
==	O
LM_SYSLOG	int
)	O
{	O
}	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
=	O
grad_emalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
)	O
)	O
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
->	O
name	*(char)
=	O
grad_estrdup	(*(char))->(*(char))
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
name	*(char)
)	O
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
->	O
mode	int
=	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
mode	int
;	O
if	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
mode	int
==	O
LM_FILE	int
)	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
->	O
id	char
.	O
file	*(char)
=	O
filename	*(char)
;	O
else	O
if	O
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
mode	int
==	O
LM_SYSLOG	int
)	O
{	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
prio	int
=	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
prio	int
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
fac	int
=	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
fac	int
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
tag	char
=	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
tag	char
?	O
grad_estrdup	(*(char))->(*(char))
(	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
tag	char
)	O
:	O
NULL	O
;	O
}	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
->	O
options	int
=	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
options	int
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
->	O
prefix_hook	*(char)
=	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
prefix_hook	*(char)
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
->	O
suffix_hook	*(char)
=	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
suffix_hook	*(char)
;	O
if	O
(	O
!	O
chanlist	*(struct)
)	O
chanlist	*(struct)
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
grad_list_prepend	(*(struct),*(void))->(void)
(	O
chanlist	*(struct)
,	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
)	O
;	O
}	O
void	O
register_category0	(int,int,*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(void)
(	O
int	O
cat	int
,	O
int	O
pri	int
,	O
Channel	struct
*	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
{	O
if	O
(	O
cat	int
==	O
-	O
1	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
GRAD_LOG_NCAT	int
;	O
i	int
++	O
)	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
pmask	array(int)
[	O
i	int
]	O
|=	O
pri	int
;	O
}	O
else	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
pmask	array(int)
[	O
GRAD_LOG_CAT	O
(	O
cat	int
)	O
]	O
|=	O
pri	int
;	O
}	O
struct	O
category_closure	struct(int,int)
{	O
int	O
cat	int
;	O
int	O
pri	int
;	O
}	O
;	O
static	O
int	O
_regcat	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
Channel	struct
*	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
item	*(void)
;	O
struct	O
category_closure	struct(int,int)
*	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
data	*(void)
;	O
register_category0	(int,int,*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(void)
(	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
cat	int
,	O
cp	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
->	O
pri	int
,	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
;	O
return	O
0	int
;	O
}	O
void	O
register_category	(int,int,*(struct))->(void)
(	O
int	O
cat	int
,	O
int	O
pri	int
,	O
grad_list_t	struct
*	O
clist	*(struct)
)	O
{	O
struct	O
category_closure	struct(int,int)
clos	struct(int,int)
;	O
if	O
(	O
pri	int
==	O
-	O
1	int
)	O
pri	int
=	O
GRAD_LOG_UPTO	O
(	O
GRAD_LOG_DEBUG	int
)	O
;	O
clos	struct(int,int)
.	O
cat	int
=	O
cat	int
;	O
clos	struct(int,int)
.	O
pri	int
=	O
pri	int
;	O
grad_list_iterate	(*(struct),*((*(void),*(void))->(int)),*(void))->(void)
(	O
clist	*(struct)
,	O
_regcat	(*(void),*(void))->(int)
,	O
&	O
clos	struct(int,int)
)	O
;	O
}	O
void	O
log_set_to_console	(int,int)->(void)
(	O
int	O
cat	int
,	O
int	O
pri	int
)	O
{	O
Channel	struct
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
;	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
.	O
mode	int
=	O
LM_FILE	int
;	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
.	O
name	*(char)
=	O
"stdout"	*(char)
;	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
.	O
id	char
.	O
file	*(char)
=	O
"stdout"	*(char)
;	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
.	O
options	int
=	O
LO_CAT	int
|	O
LO_PRI	int
|	O
LO_PERSIST	int
;	O
register_channel	(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(void)
(	O
&	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
;	O
register_category0	(int,int,*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(void)
(	O
cat	int
,	O
pri	int
,	O
channel_lookup	(*(char))->(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))
(	O
"stdout"	*(char)
)	O
)	O
;	O
}	O
void	O
log_set_default	(*(char),int,int)->(void)
(	O
char	O
*	O
name	*(char)
,	O
int	O
cat	int
,	O
int	O
pri	int
)	O
{	O
Channel	struct
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
;	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
.	O
mode	int
=	O
LM_FILE	int
;	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
.	O
name	*(char)
=	O
name	*(char)
;	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
.	O
id	char
.	O
file	*(char)
=	O
"radius.log"	*(char)
;	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
.	O
options	int
=	O
LO_CAT	int
|	O
LO_PRI	int
;	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
.	O
prefix_hook	*(char)
=	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
.	O
suffix_hook	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
channel_lookup	(*(char))->(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))
(	O
name	*(char)
)	O
)	O
register_channel	(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(void)
(	O
&	O
chan	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
;	O
register_category0	(int,int,*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(void)
(	O
cat	int
,	O
pri	int
,	O
channel_lookup	(*(char))->(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))
(	O
name	*(char)
)	O
)	O
;	O
}	O
void	O
format_exit_status	(*(char),int,int)->(void)
(	O
char	O
*	O
buffer	*(char)
,	O
int	O
buflen	int
,	O
int	O
status	int
)	O
{	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	*(char)
,	O
buflen	int
,	O
_	O
(	O
"exited with status %d"	*(char)
)	O
,	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	*(char)
,	O
buflen	int
,	O
_	O
(	O
"terminated on signal %d"	*(char)
)	O
,	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
}	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
buffer	*(char)
,	O
buflen	int
,	O
_	O
(	O
"terminated"	*(char)
)	O
)	O
;	O
}	O
static	O
Channel	struct
*	O
mark	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
,	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
;	O
static	O
struct	O
category_def	struct(int,int,int,*(struct),int)
{	O
int	O
init	int
;	O
int	O
cat	int
;	O
int	O
pri	int
;	O
grad_list_t	struct
*	O
clist	*(struct)
;	O
int	O
level	int
;	O
}	O
cat_def	struct(int,int,int,*(struct),int)
;	O
static	O
grad_keyword_t	struct
syslog_facility	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"user"	*(char)
,	O
LOG_USER	O
}	O
,	O
{	O
"daemon"	*(char)
,	O
LOG_DAEMON	O
}	O
,	O
{	O
"auth"	*(char)
,	O
LOG_AUTH	O
}	O
,	O
{	O
"local0"	*(char)
,	O
LOG_LOCAL0	O
}	O
,	O
{	O
"local1"	*(char)
,	O
LOG_LOCAL1	O
}	O
,	O
{	O
"local2"	*(char)
,	O
LOG_LOCAL2	O
}	O
,	O
{	O
"local3"	*(char)
,	O
LOG_LOCAL3	O
}	O
,	O
{	O
"local4"	*(char)
,	O
LOG_LOCAL4	O
}	O
,	O
{	O
"local5"	*(char)
,	O
LOG_LOCAL5	O
}	O
,	O
{	O
"local6"	*(char)
,	O
LOG_LOCAL6	O
}	O
,	O
{	O
"local7"	*(char)
,	O
LOG_LOCAL7	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
grad_keyword_t	struct
syslog_priority	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"emerg"	*(char)
,	O
LOG_EMERG	int
}	O
,	O
{	O
"alert"	*(char)
,	O
LOG_ALERT	int
}	O
,	O
{	O
"crit"	*(char)
,	O
LOG_CRIT	int
}	O
,	O
{	O
"err"	*(char)
,	O
LOG_ERR	int
}	O
,	O
{	O
"warning"	*(char)
,	O
LOG_WARNING	int
}	O
,	O
{	O
"notice"	*(char)
,	O
LOG_NOTICE	int
}	O
,	O
{	O
"info"	*(char)
,	O
LOG_INFO	int
}	O
,	O
{	O
"debug"	*(char)
,	O
LOG_DEBUG	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
grad_keyword_t	struct
log_categories	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"main"	*(char)
,	O
GRAD_LOG_MAIN	O
}	O
,	O
{	O
"auth"	*(char)
,	O
GRAD_LOG_AUTH	O
}	O
,	O
{	O
"acct"	*(char)
,	O
GRAD_LOG_ACCT	O
}	O
,	O
{	O
"snmp"	*(char)
,	O
GRAD_LOG_SNMP	O
}	O
,	O
{	O
"proxy"	*(char)
,	O
GRAD_LOG_PROXY	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
grad_keyword_t	struct
log_priorities	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"emerg"	*(char)
,	O
GRAD_LOG_EMERG	int
}	O
,	O
{	O
"alert"	*(char)
,	O
GRAD_LOG_ALERT	int
}	O
,	O
{	O
"crit"	*(char)
,	O
GRAD_LOG_CRIT	int
}	O
,	O
{	O
"err"	*(char)
,	O
GRAD_LOG_ERR	int
}	O
,	O
{	O
"warning"	*(char)
,	O
GRAD_LOG_WARN	int
}	O
,	O
{	O
"notice"	*(char)
,	O
GRAD_LOG_NOTICE	int
}	O
,	O
{	O
"info"	*(char)
,	O
GRAD_LOG_INFO	int
}	O
,	O
{	O
"debug"	*(char)
,	O
GRAD_LOG_DEBUG	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
int	O
logging_stmt_handler	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
mark	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
=	O
log_mark	()->(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))
(	O
)	O
;	O
grad_free	(*(void))->(void)
(	O
log_prefix_hook	*(char)
)	O
;	O
log_prefix_hook	*(char)
=	O
NULL	O
;	O
grad_free	(*(void))->(void)
(	O
log_suffix_hook	*(char)
)	O
;	O
log_suffix_hook	*(char)
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
int	O
logging_stmt_end	(*(void),*(void))->(int)
(	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
log_release	()->(void)
(	O
mark	*(struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char)))
)	O
;	O
return	O
0	int
;	O
}	O
int	O
logging_stmt_begin	(int,*(void),*(void))->(int)
(	O
int	O
finish	int
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_stmt_handler	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
cfg_argc_error	(int)->(void)
(	O
argc	int
<	O
2	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	(int)->(void)
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
,	O
0	int
,	O
sizeof	O
(	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
)	O
)	O
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
mode	int
=	O
LM_UNKNOWN	O
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
name	*(char)
=	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
;	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_stmt_end	(*(void),*(void))->(int)
(	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
mode	int
==	O
LM_UNKNOWN	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"%s:%d: no channel mode for `%s'"	*(char)
)	O
,	O
cfg_filename	*(char)
,	O
cfg_line_num	int
,	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
name	*(char)
)	O
;	O
}	O
else	O
register_channel	(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))->(void)
(	O
&	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
get_priority	(*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))))->(int)
(	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
argv	*(*(char))
[	O
0	int
]	O
.	O
type	int
!=	O
CFG_CHAR	int
||	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
return	O
1	int
;	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
=	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
log_priorities	array(struct(*(char),int))
,	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
switch	O
(	O
argv	*(*(char))
[	O
0	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ch	char
)	O
{	O
case	O
'!'	O
:	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
=	O
GRAD_LOG_UPTO	O
(	O
GRAD_LOG_DEBUG	int
)	O
&	O
~	O
GRAD_LOG_MASK	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
=	O
GRAD_LOG_MASK	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
category_stmt_handler	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
cat_def	struct(int,int,int,*(struct),int)
.	O
init	int
=	O
0	int
;	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
=	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
=	O
-	O
1	int
;	O
cat_def	struct(int,int,int,*(struct),int)
.	O
level	int
=	O
0	int
;	O
switch	O
(	O
argc	int
)	O
{	O
case	O
2	int
:	O
switch	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_CHAR	int
:	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ch	char
==	O
'*'	O
)	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
=	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
=	O
-	O
1	int
;	O
else	O
return	O
1	int
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
=	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
log_categories	array(struct(*(char),int))
,	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
==	O
-	O
1	int
)	O
{	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
=	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
log_priorities	array(struct(*(char),int))
,	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
=	O
GRAD_LOG_UPTO	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
get_priority	(*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))))->(int)
(	O
argv	*(*(char))
+	O
1	int
)	O
)	O
return	O
1	int
;	O
break	O
;	O
case	O
4	int
:	O
if	O
(	O
!	O
(	O
argv	*(*(char))
[	O
2	int
]	O
.	O
type	int
==	O
CFG_CHAR	int
&&	O
argv	*(*(char))
[	O
2	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ch	char
==	O
'.'	O
)	O
)	O
return	O
1	int
;	O
switch	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_CHAR	int
:	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ch	char
==	O
'*'	O
)	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
=	O
-	O
1	int
;	O
else	O
return	O
1	int
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
=	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
log_categories	array(struct(*(char),int))
,	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
switch	O
(	O
argv	*(*(char))
[	O
3	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_CHAR	int
:	O
if	O
(	O
argv	*(*(char))
[	O
3	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ch	char
==	O
'*'	O
)	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
=	O
-	O
1	int
;	O
else	O
return	O
1	int
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
=	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
log_priorities	array(struct(*(char),int))
,	O
argv	*(*(char))
[	O
3	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
=	O
GRAD_LOG_UPTO	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
break	O
;	O
case	O
5	int
:	O
if	O
(	O
!	O
(	O
argv	*(*(char))
[	O
2	int
]	O
.	O
type	int
==	O
CFG_CHAR	int
&&	O
argv	*(*(char))
[	O
2	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ch	char
==	O
'.'	O
)	O
)	O
return	O
1	int
;	O
switch	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_CHAR	int
:	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ch	char
==	O
'*'	O
)	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
=	O
-	O
1	int
;	O
else	O
return	O
1	int
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
=	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
log_categories	array(struct(*(char),int))
,	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
,	O
-	O
1	int
)	O
;	O
if	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
if	O
(	O
get_priority	(*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))))->(int)
(	O
argv	*(*(char))
+	O
3	int
)	O
)	O
return	O
1	int
;	O
break	O
;	O
default	O
:	O
cfg_argc_error	(int)->(void)
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
cat_def	struct(int,int,int,*(struct),int)
.	O
init	int
=	O
1	int
;	O
cat_def	struct(int,int,int,*(struct),int)
.	O
clist	*(struct)
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
category_stmt_end	(*(void),*(void))->(int)
(	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
init	int
)	O
{	O
switch	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
)	O
{	O
case	O
GRAD_LOG_AUTH	O
:	O
log_mode	int
=	O
cat_def	struct(int,int,int,*(struct),int)
.	O
level	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
level	int
)	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_WARN	int
,	O
"%s:%d: %s"	*(char)
,	O
cfg_filename	*(char)
,	O
cfg_line_num	int
,	O
_	O
(	O
"no levels applicable for this category"	*(char)
)	O
)	O
;	O
}	O
register_category	(int,int,*(struct))->(void)
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
cat	int
,	O
cat_def	struct(int,int,int,*(struct),int)
.	O
pri	int
,	O
cat_def	struct(int,int,int,*(struct),int)
.	O
clist	*(struct)
)	O
;	O
grad_list_destroy	(*(*(struct)),*((*(void),*(void))->(int)),*(void))->(void)
(	O
&	O
cat_def	struct(int,int,int,*(struct),int)
.	O
clist	*(struct)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
category_set_channel	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
Channel	struct
*	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
cfg_argc_error	(int)->(void)
(	O
argc	int
<	O
2	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	(int)->(void)
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
=	O
channel_lookup	(*(char))->(*(struct(*(char),array(int),int,union(struct(int,int,*`),*(char)),int,*(char),*(char))))
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
)	O
;	O
if	O
(	O
!	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"%s:%d: channel `%s' not defined"	*(char)
)	O
,	O
cfg_filename	*(char)
,	O
cfg_line_num	int
,	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
cat_def	struct(int,int,int,*(struct),int)
.	O
clist	*(struct)
)	O
cat_def	struct(int,int,int,*(struct),int)
.	O
clist	*(struct)
=	O
grad_list_create	()->(*(struct))
(	O
)	O
;	O
grad_list_append	(*(struct),*(void))->(void)
(	O
cat_def	struct(int,int,int,*(struct),int)
.	O
clist	*(struct)
,	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
category_set_flag	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
int	O
flag	int
=	O
(	O
int	O
)	O
handler_data	*(void)
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
cfg_argc_error	(int)->(void)
(	O
argc	int
<	O
2	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_BOOLEAN	int
)	O
{	O
cfg_type_error	(int)->(void)
(	O
CFG_BOOLEAN	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
bool	int
)	O
cat_def	struct(int,int,int,*(struct),int)
.	O
level	int
|=	O
flag	int
;	O
else	O
cat_def	struct(int,int,int,*(struct),int)
.	O
level	int
&=	O
~	O
flag	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
category_set_level	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
int	O
i	int
;	O
grad_clear_debug	()->(void)
(	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
)	O
{	O
char	O
*	O
modname	*(char)
;	O
int	O
level	int
;	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"%s:%d: list item %d has wrong datatype"	*(char)
)	O
,	O
cfg_filename	*(char)
,	O
cfg_line_num	int
,	O
i	int
)	O
;	O
return	O
1	int
;	O
}	O
modname	*(char)
=	O
argv	*(*(char))
[	O
i	int
++	O
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
;	O
level	int
=	O
-	O
1	int
;	O
if	O
(	O
i	int
<	O
argc	int
&&	O
argv	*(*(char))
[	O
i	int
]	O
.	O
type	int
==	O
CFG_CHAR	int
&&	O
argv	*(*(char))
[	O
i	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ch	char
==	O
'='	O
)	O
{	O
i	int
++	O
;	O
if	O
(	O
i	int
==	O
argc	int
||	O
argv	*(*(char))
[	O
i	int
]	O
.	O
type	int
!=	O
CFG_INTEGER	int
)	O
return	O
1	int
;	O
level	int
=	O
argv	*(*(char))
[	O
i	int
++	O
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
number	long
;	O
}	O
if	O
(	O
grad_set_module_debug_level	(*(char),int)->(int)
(	O
modname	*(char)
,	O
level	int
)	O
)	O
{	O
grad_log	(int,*(char))->(void)
(	O
GRAD_LOG_WARN	int
,	O
_	O
(	O
"%s:%d: no such module name: %s"	*(char)
)	O
,	O
cfg_filename	*(char)
,	O
cfg_line_num	int
,	O
modname	*(char)
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_file_handler	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
cfg_argc_error	(int)->(void)
(	O
argc	int
<	O
2	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	(int)->(void)
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
mode	int
=	O
LM_FILE	int
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
id	char
.	O
file	*(char)
=	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
;	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_syslog_handler	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
int	O
facility	int
;	O
int	O
prio	int
;	O
if	O
(	O
argc	int
<	O
4	int
||	O
argc	int
>	O
5	int
)	O
{	O
cfg_argc_error	(int)->(void)
(	O
argc	int
<	O
4	int
)	O
;	O
return	O
0	int
;	O
}	O
switch	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_INTEGER	int
:	O
facility	int
=	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
number	long
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
facility	int
=	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
syslog_facility	array(struct(*(char),int))
,	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
,	O
-	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
if	O
(	O
facility	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
argv	*(*(char))
[	O
2	int
]	O
.	O
type	int
!=	O
CFG_CHAR	int
||	O
argv	*(*(char))
[	O
2	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
ch	char
!=	O
'.'	O
)	O
return	O
1	int
;	O
switch	O
(	O
argv	*(*(char))
[	O
3	int
]	O
.	O
type	int
)	O
{	O
case	O
CFG_INTEGER	int
:	O
prio	int
=	O
argv	*(*(char))
[	O
3	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
number	long
;	O
break	O
;	O
case	O
CFG_STRING	int
:	O
prio	int
=	O
grad_xlat_keyword	(*(struct(*(char),int)),*(char),int)->(int)
(	O
syslog_priority	array(struct(*(char),int))
,	O
argv	*(*(char))
[	O
3	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
,	O
-	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
if	O
(	O
prio	int
==	O
-	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
argc	int
==	O
5	int
)	O
{	O
if	O
(	O
argv	*(*(char))
[	O
4	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	(int)->(void)
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
tag	char
=	O
argv	*(*(char))
[	O
4	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
;	O
}	O
else	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
tag	char
=	O
NULL	O
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
mode	int
=	O
LM_SYSLOG	int
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
prio	int
=	O
prio	int
;	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
id	char
.	O
sl	struct(int,int,*(char))
.	O
fac	int
=	O
facility	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
channel_set_flag	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
int	O
flag	int
=	O
(	O
int	O
)	O
handler_data	*(void)
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
cfg_argc_error	(int)->(void)
(	O
argc	int
<	O
2	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_BOOLEAN	int
)	O
{	O
cfg_type_error	(int)->(void)
(	O
CFG_BOOLEAN	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
bool	int
)	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
options	int
|=	O
flag	int
;	O
else	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
options	int
&=	O
~	O
flag	int
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
channel_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
=	O
{	O
{	O
"file"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_file_handler	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"syslog"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_syslog_handler	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-pid"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
(	O
void	O
*	O
)	O
LO_PID	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-cons"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
(	O
void	O
*	O
)	O
LO_CONS	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-level"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
(	O
void	O
*	O
)	O
LO_PRI	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-category"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
(	O
void	O
*	O
)	O
LO_CAT	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-priority"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
(	O
void	O
*	O
)	O
LO_PRI	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-milliseconds"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
channel_set_flag	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
(	O
void	O
*	O
)	O
LO_MSEC	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"prefix-hook"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
prefix_hook	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"suffix-hook"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
channel	struct(*(char),array(int),int,union(struct(int,int,*(char)),*(char)),int,*(char),*(char))
.	O
suffix_hook	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
category_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
=	O
{	O
{	O
"channel"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
category_set_channel	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-auth"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
category_set_flag	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
(	O
void	O
*	O
)	O
RLOG_AUTH	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-failed-pass"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
category_set_flag	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
(	O
void	O
*	O
)	O
RLOG_FAILED_PASS	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"print-pass"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
category_set_flag	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
(	O
void	O
*	O
)	O
RLOG_AUTH_PASS	int
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"level"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
category_set_level	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
logging_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
=	O
{	O
{	O
"channel"	*(char)
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
channel_stmt_handler	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
channel_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
channel_stmt_end	(*(void),*(void))->(int)
}	O
,	O
{	O
"category"	*(char)
,	O
CS_BLOCK	int
,	O
NULL	O
,	O
category_stmt_handler	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
category_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
,	O
category_stmt_end	(*(void),*(void))->(int)
}	O
,	O
{	O
"prefix-hook"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
log_prefix_hook	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
"suffix-hook"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
cfg_get_string	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
&	O
log_suffix_hook	*(char)
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
,	O
}	O
;	O
