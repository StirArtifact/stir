int	O
mou_auto_repeat	int
=	O
100	int
;	O
int	O
double_click_speed	int
=	O
250	int
;	O
int	O
old_esc_mode	int
=	O
0	int
;	O
int	O
keyboard_key_timeout	int
=	O
1000000	int
;	O
int	O
use_8th_bit_as_meta	int
=	O
0	int
;	O
typedef	O
struct	O
key_def	struct(char,int,*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),int)
{	O
char	O
ch	int
;	O
int	O
code	int
;	O
struct	O
key_def	struct(char,int,*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),int)
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
struct	O
key_def	struct(char,int,*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),int)
*	O
child	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
action	int
;	O
}	O
key_def	struct(char,int,*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),int)
;	O
static	O
key_def	struct(char,int,*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),int)
*	O
keys	*(struct(*(char),int))
=	O
NULL	O
;	O
static	O
int	O
input_fd	int
;	O
static	O
int	O
disabled_channels	int
=	O
0	int
;	O
static	O
int	O
xgetch_second	()->(int)
(	O
void	O
)	O
;	O
static	O
int	O
get_modifier	()->(int)
(	O
void	O
)	O
;	O
typedef	O
struct	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
{	O
int	O
fd	int
;	O
select_fn	*((int,*(void))->(int))
callback	*((*(void))->(int))
;	O
void	O
*	O
info	*(void)
;	O
struct	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
*	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
;	O
static	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
*	O
select_list	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
=	O
NULL	O
;	O
void	O
add_select_channel	(int,*((int,*(void))->(int)),*(void))->(void)
(	O
int	O
fd	int
,	O
select_fn	*((int,*(void))->(int))
callback	*((*(void))->(int))
,	O
void	O
*	O
info	*(void)
)	O
{	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
*	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
g_new	O
(	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
,	O
1	int
)	O
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
fd	int
=	O
fd	int
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
callback	*((*(void))->(int))
=	O
callback	*((*(void))->(int))
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
info	*(void)
=	O
info	*(void)
;	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
select_list	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
;	O
select_list	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
=	O
new	*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
}	O
void	O
delete_select_channel	(int)->(void)
(	O
int	O
fd	int
)	O
{	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
*	O
p	*(void)
=	O
select_list	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
;	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
*	O
p_prev	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
=	O
NULL	O
;	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
*	O
p_next	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
;	O
while	O
(	O
p	*(void)
)	O
{	O
if	O
(	O
p	*(void)
->	O
fd	int
==	O
fd	int
)	O
{	O
p_next	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
=	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
p_prev	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
)	O
p_prev	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
p_next	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
;	O
else	O
select_list	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
=	O
p_next	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
;	O
g_free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
p	*(void)
=	O
p_next	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
;	O
continue	O
;	O
}	O
p_prev	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
=	O
p	*(void)
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
}	O
inline	O
static	O
int	O
add_selects	(*(struct(array(long))))->(int)
(	O
fd_set	struct(array(long))
*	O
select_set	*(struct(array(long)))
)	O
{	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
*	O
p	*(void)
;	O
int	O
top_fd	int
=	O
0	int
;	O
if	O
(	O
disabled_channels	int
)	O
return	O
0	int
;	O
for	O
(	O
p	*(void)
=	O
select_list	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
;	O
p	*(void)
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
FD_SET	O
(	O
p	*(void)
->	O
fd	int
,	O
select_set	*(struct(array(long)))
)	O
;	O
if	O
(	O
p	*(void)
->	O
fd	int
>	O
top_fd	int
)	O
top_fd	int
=	O
p	*(void)
->	O
fd	int
;	O
}	O
return	O
top_fd	int
;	O
}	O
static	O
void	O
check_selects	(*(struct(array(long))))->(void)
(	O
fd_set	struct(array(long))
*	O
select_set	*(struct(array(long)))
)	O
{	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
*	O
p	*(void)
;	O
gboolean	int
retry	int
;	O
if	O
(	O
disabled_channels	int
)	O
return	O
;	O
do	O
{	O
retry	int
=	O
FALSE	O
;	O
for	O
(	O
p	*(void)
=	O
select_list	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
;	O
p	*(void)
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
if	O
(	O
FD_ISSET	O
(	O
p	*(void)
->	O
fd	int
,	O
select_set	*(struct(array(long)))
)	O
)	O
{	O
FD_CLR	O
(	O
p	*(void)
->	O
fd	int
,	O
select_set	*(struct(array(long)))
)	O
;	O
(	O
*	O
p	*(void)
->	O
callback	*((*(void))->(int))
)	O
(	O
p	*(void)
->	O
fd	int
,	O
p	*(void)
->	O
info	*(void)
)	O
;	O
retry	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
}	O
while	O
(	O
retry	int
)	O
;	O
}	O
void	O
channels_down	()->(void)
(	O
void	O
)	O
{	O
disabled_channels	int
++	O
;	O
}	O
void	O
channels_up	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
!	O
disabled_channels	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Error: channels_up called with disabled_channels = 0\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
disabled_channels	int
--	O
;	O
}	O
typedef	O
const	O
struct	O
{	O
int	O
code	int
;	O
const	O
char	O
*	O
seq	*(struct)
;	O
int	O
action	int
;	O
}	O
key_define_t	struct(int,*(char),int)
;	O
static	O
key_define_t	struct(int,*(char),int)
xterm_key_defines	array(struct(int,*(char),int))
[	O
]	O
=	O
{	O
{	O
KEY_F	O
(	O
1	int
)	O
,	O
ESC_STR	*(char)
"OP"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
2	int
)	O
,	O
ESC_STR	*(char)
"OQ"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
3	int
)	O
,	O
ESC_STR	*(char)
"OR"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
4	int
)	O
,	O
ESC_STR	*(char)
"OS"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
1	int
)	O
,	O
ESC_STR	*(char)
"[11~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
2	int
)	O
,	O
ESC_STR	*(char)
"[12~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
3	int
)	O
,	O
ESC_STR	*(char)
"[13~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
4	int
)	O
,	O
ESC_STR	*(char)
"[14~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
5	int
)	O
,	O
ESC_STR	*(char)
"[15~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
6	int
)	O
,	O
ESC_STR	*(char)
"[17~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
7	int
)	O
,	O
ESC_STR	*(char)
"[18~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
8	int
)	O
,	O
ESC_STR	*(char)
"[19~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
9	int
)	O
,	O
ESC_STR	*(char)
"[20~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_F	O
(	O
10	int
)	O
,	O
ESC_STR	*(char)
"[21~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"O2A"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"O2B"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"O2C"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"O2D"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"[1;2A"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"[1;2B"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"[1;2C"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"[1;2D"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_PPAGE	int
,	O
ESC_STR	*(char)
"[5;5~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_NPAGE	int
,	O
ESC_STR	*(char)
"[6;5~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_IC	int
,	O
ESC_STR	*(char)
"[2;5~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DC	int
,	O
ESC_STR	*(char)
"[3;5~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_HOME	int
,	O
ESC_STR	*(char)
"[1;5H"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_END	int
,	O
ESC_STR	*(char)
"[1;5F"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_HOME	int
,	O
ESC_STR	*(char)
"[1;2H"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_END	int
,	O
ESC_STR	*(char)
"[1;2F"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"[1;5A"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"[1;5B"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"[1;5C"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"[1;5D"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_IC	int
,	O
ESC_STR	*(char)
"[2;2~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DC	int
,	O
ESC_STR	*(char)
"[3;2~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"[1;6A"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"[1;6B"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"[1;6C"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"[1;6D"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"[a"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"[b"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"[c"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"[d"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"Oa"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"Ob"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"Oc"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"Od"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_PPAGE	int
,	O
ESC_STR	*(char)
"[5^"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_NPAGE	int
,	O
ESC_STR	*(char)
"[6^"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_HOME	int
,	O
ESC_STR	*(char)
"[7^"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_END	int
,	O
ESC_STR	*(char)
"[8^"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_HOME	int
,	O
ESC_STR	*(char)
"[7$"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_END	int
,	O
ESC_STR	*(char)
"[8$"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_IC	int
,	O
ESC_STR	*(char)
"[2^"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DC	int
,	O
ESC_STR	*(char)
"[3^"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DC	int
,	O
ESC_STR	*(char)
"[3$"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_HOME	int
,	O
ESC_STR	*(char)
"O2H"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_END	int
,	O
ESC_STR	*(char)
"O2F"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"[2A"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"[2B"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"[2C"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"[2D"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"[5A"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"[5B"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"[5C"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"[5D"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"[6A"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"[6B"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"[6C"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"[6D"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"O5A"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"O5B"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"O5C"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"O5D"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"O6A"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"O6B"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"O6C"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"O6D"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_PPAGE	int
,	O
ESC_STR	*(char)
"[5;2~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
KEY_NPAGE	int
,	O
ESC_STR	*(char)
"[6;2~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_IC	int
,	O
ESC_STR	*(char)
"Op"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_DC	int
,	O
ESC_STR	*(char)
"On"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
'/'	O
,	O
ESC_STR	*(char)
"Oo"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
'\n'	O
,	O
ESC_STR	*(char)
"OM"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
MCKEY_NOACTION	int
}	O
,	O
}	O
;	O
static	O
key_define_t	struct(int,*(char),int)
qansi_key_defines	array(struct(int,*(char),int))
[	O
]	O
=	O
{	O
{	O
KEY_M_CTRL	int
|	O
KEY_NPAGE	int
,	O
ESC_STR	*(char)
"[u"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_PPAGE	int
,	O
ESC_STR	*(char)
"[v"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_HOME	int
,	O
ESC_STR	*(char)
"[h"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_END	int
,	O
ESC_STR	*(char)
"[y"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_IC	int
,	O
ESC_STR	*(char)
"[`"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DC	int
,	O
ESC_STR	*(char)
"[p"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_LEFT	int
,	O
ESC_STR	*(char)
"[d"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_RIGHT	int
,	O
ESC_STR	*(char)
"[c"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_DOWN	int
,	O
ESC_STR	*(char)
"[b"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_UP	int
,	O
ESC_STR	*(char)
"[a"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_KP_ADD	int
,	O
ESC_STR	*(char)
"[s"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_KP_SUBTRACT	int
,	O
ESC_STR	*(char)
"[t"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
'\t'	O
,	O
ESC_STR	*(char)
"[z"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_SHIFT	int
|	O
'\t'	O
,	O
ESC_STR	*(char)
"[Z"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
1	int
)	O
,	O
ESC_STR	*(char)
"[1~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
2	int
)	O
,	O
ESC_STR	*(char)
"[2~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
3	int
)	O
,	O
ESC_STR	*(char)
"[3~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
4	int
)	O
,	O
ESC_STR	*(char)
"[4~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
5	int
)	O
,	O
ESC_STR	*(char)
"[5~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
6	int
)	O
,	O
ESC_STR	*(char)
"[6~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
7	int
)	O
,	O
ESC_STR	*(char)
"[7~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
8	int
)	O
,	O
ESC_STR	*(char)
"[8~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
9	int
)	O
,	O
ESC_STR	*(char)
"[9~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
10	int
)	O
,	O
ESC_STR	*(char)
"[10~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
11	int
)	O
,	O
ESC_STR	*(char)
"[11~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_CTRL	int
|	O
KEY_F	O
(	O
12	int
)	O
,	O
ESC_STR	*(char)
"[12~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
1	int
)	O
,	O
ESC_STR	*(char)
"[17~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
2	int
)	O
,	O
ESC_STR	*(char)
"[18~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
3	int
)	O
,	O
ESC_STR	*(char)
"[19~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
4	int
)	O
,	O
ESC_STR	*(char)
"[20~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
5	int
)	O
,	O
ESC_STR	*(char)
"[21~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
6	int
)	O
,	O
ESC_STR	*(char)
"[22~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
7	int
)	O
,	O
ESC_STR	*(char)
"[23~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
8	int
)	O
,	O
ESC_STR	*(char)
"[24~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
9	int
)	O
,	O
ESC_STR	*(char)
"[25~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
10	int
)	O
,	O
ESC_STR	*(char)
"[26~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
11	int
)	O
,	O
ESC_STR	*(char)
"[27~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
KEY_F	O
(	O
12	int
)	O
,	O
ESC_STR	*(char)
"[28~"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'a'	O
,	O
ESC_STR	*(char)
"Na"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'b'	O
,	O
ESC_STR	*(char)
"Nb"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'c'	O
,	O
ESC_STR	*(char)
"Nc"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'd'	O
,	O
ESC_STR	*(char)
"Nd"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'e'	O
,	O
ESC_STR	*(char)
"Ne"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'f'	O
,	O
ESC_STR	*(char)
"Nf"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'g'	O
,	O
ESC_STR	*(char)
"Ng"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'i'	O
,	O
ESC_STR	*(char)
"Ni"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'j'	O
,	O
ESC_STR	*(char)
"Nj"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'k'	O
,	O
ESC_STR	*(char)
"Nk"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'l'	O
,	O
ESC_STR	*(char)
"Nl"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'm'	O
,	O
ESC_STR	*(char)
"Nm"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'n'	O
,	O
ESC_STR	*(char)
"Nn"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'o'	O
,	O
ESC_STR	*(char)
"No"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'p'	O
,	O
ESC_STR	*(char)
"Np"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'q'	O
,	O
ESC_STR	*(char)
"Nq"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
's'	O
,	O
ESC_STR	*(char)
"Ns"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
't'	O
,	O
ESC_STR	*(char)
"Nt"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'u'	O
,	O
ESC_STR	*(char)
"Nu"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'v'	O
,	O
ESC_STR	*(char)
"Nv"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'w'	O
,	O
ESC_STR	*(char)
"Nw"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'x'	O
,	O
ESC_STR	*(char)
"Nx"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'y'	O
,	O
ESC_STR	*(char)
"Ny"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_M_ALT	int
|	O
'z'	O
,	O
ESC_STR	*(char)
"Nz"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_KP_SUBTRACT	int
,	O
ESC_STR	*(char)
"[S"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
KEY_KP_ADD	int
,	O
ESC_STR	*(char)
"[T"	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
MCKEY_NOACTION	int
}	O
,	O
}	O
;	O
static	O
key_define_t	struct(int,*(char),int)
mc_default_keys	array(struct(int,*(char),int))
[	O
]	O
=	O
{	O
{	O
ESC_CHAR	char
,	O
ESC_STR	*(char)
,	O
MCKEY_ESCAPE	int
}	O
,	O
{	O
ESC_CHAR	char
,	O
ESC_STR	*(char)
ESC_STR	*(char)
,	O
MCKEY_NOACTION	int
}	O
,	O
{	O
0	int
,	O
NULL	O
,	O
MCKEY_NOACTION	int
}	O
,	O
}	O
;	O
static	O
void	O
define_sequences	(*(struct(int,*(char),int)))->(void)
(	O
key_define_t	struct(int,*(char),int)
*	O
kd	*(struct(int,*(char),int))
)	O
{	O
int	O
i	array(int)
;	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
kd	*(struct(int,*(char),int))
[	O
i	array(int)
]	O
.	O
code	int
!=	O
0	int
;	O
i	array(int)
++	O
)	O
define_sequence	(int,*(char),int)->(int)
(	O
kd	*(struct(int,*(char),int))
[	O
i	array(int)
]	O
.	O
code	int
,	O
kd	*(struct(int,*(char),int))
[	O
i	array(int)
]	O
.	O
seq	*(struct)
,	O
kd	*(struct(int,*(char),int))
[	O
i	array(int)
]	O
.	O
action	int
)	O
;	O
}	O
void	O
init_key	()->(void)
(	O
void	O
)	O
{	O
const	O
char	O
*	O
term	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TERM"	*(char)
)	O
;	O
char	O
*	O
kt	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"KEYBOARD_KEY_TIMEOUT_US"	*(char)
)	O
;	O
if	O
(	O
kt	*(char)
!=	O
NULL	O
)	O
keyboard_key_timeout	int
=	O
atoi	(*(char))->(int)
(	O
kt	*(char)
)	O
;	O
define_sequences	(*(struct(int,*(char),int)))->(void)
(	O
mc_default_keys	array(struct(int,*(char),int))
)	O
;	O
if	O
(	O
xterm_flag	int
||	O
(	O
term	*(char)
!=	O
NULL	O
&&	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"iris-ansi"	*(char)
,	O
9	int
)	O
==	O
0	int
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"xterm"	*(char)
,	O
5	int
)	O
==	O
0	int
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"rxvt"	*(char)
,	O
4	int
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
term	*(char)
,	O
"screen"	*(char)
)	O
==	O
0	int
)	O
)	O
)	O
define_sequences	(*(struct(int,*(char),int)))->(void)
(	O
xterm_key_defines	array(struct(int,*(char),int))
)	O
;	O
load_xtra_key_defines	()->(void)
(	O
)	O
;	O
if	O
(	O
term	*(char)
!=	O
NULL	O
&&	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
term	*(char)
,	O
"qansi-m"	*(char)
,	O
7	int
)	O
==	O
0	int
)	O
)	O
{	O
define_sequences	(*(struct(int,*(char),int)))->(void)
(	O
qansi_key_defines	array(struct(int,*(char),int))
)	O
;	O
}	O
}	O
void	O
init_key_input_fd	()->(void)
(	O
void	O
)	O
{	O
input_fd	int
=	O
SLang_TT_Read_FD	int
;	O
}	O
static	O
void	O
xmouse_get_event	(*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int))))->(void)
(	O
Gpm_Event	struct(int,int,int,enum(int,int,int,int,int,int,int,int,int))
*	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
)	O
{	O
int	O
btn	int
;	O
static	O
struct	O
timeval	struct(long,long)
tv1	struct(long,long)
=	O
{	O
0	int
,	O
0	int
}	O
;	O
static	O
struct	O
timeval	struct(long,long)
tv2	struct(long,long)
;	O
static	O
int	O
clicks	int
;	O
static	O
int	O
last_btn	int
=	O
0	int
;	O
btn	int
=	O
getch	()->(int)
(	O
)	O
-	O
32	int
;	O
if	O
(	O
btn	int
==	O
3	int
)	O
{	O
if	O
(	O
last_btn	int
)	O
{	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
type	enum(int,int,int,int)
=	O
GPM_UP	int
|	O
(	O
GPM_SINGLE	int
<<	O
clicks	int
)	O
;	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
buttons	int
=	O
0	int
;	O
last_btn	int
=	O
0	int
;	O
GET_TIME	O
(	O
tv1	struct(long,long)
)	O
;	O
clicks	int
=	O
0	int
;	O
}	O
else	O
{	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
type	enum(int,int,int,int)
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
btn	int
>=	O
32	int
&&	O
btn	int
<=	O
34	int
)	O
{	O
btn	int
-=	O
32	int
;	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
type	enum(int,int,int,int)
=	O
GPM_DRAG	int
;	O
}	O
else	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
type	enum(int,int,int,int)
=	O
GPM_DOWN	int
;	O
GET_TIME	O
(	O
tv2	struct(long,long)
)	O
;	O
if	O
(	O
tv1	struct(long,long)
.	O
tv_sec	long
&&	O
(	O
DIF_TIME	O
(	O
tv1	struct(long,long)
,	O
tv2	struct(long,long)
)	O
<	O
double_click_speed	int
)	O
)	O
{	O
clicks	int
++	O
;	O
clicks	int
%=	O
3	int
;	O
}	O
else	O
clicks	int
=	O
0	int
;	O
switch	O
(	O
btn	int
)	O
{	O
case	O
0	int
:	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
buttons	int
=	O
GPM_B_LEFT	O
;	O
break	O
;	O
case	O
1	int
:	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
buttons	int
=	O
GPM_B_MIDDLE	O
;	O
break	O
;	O
case	O
2	int
:	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
buttons	int
=	O
GPM_B_RIGHT	O
;	O
break	O
;	O
case	O
64	int
:	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
buttons	int
=	O
GPM_B_UP	O
;	O
clicks	int
=	O
0	int
;	O
break	O
;	O
case	O
65	int
:	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
buttons	int
=	O
GPM_B_DOWN	O
;	O
clicks	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
type	enum(int,int,int,int)
=	O
0	int
;	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
buttons	int
=	O
0	int
;	O
break	O
;	O
}	O
last_btn	int
=	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
buttons	int
;	O
}	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
x	array(long)
=	O
getch	()->(int)
(	O
)	O
-	O
32	int
;	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
y	short
=	O
getch	()->(int)
(	O
)	O
-	O
32	int
;	O
}	O
static	O
key_def	struct(char,int,*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),int)
*	O
create_sequence	(*(char),int,int)->(*(struct(char,int,*(struct(char,int,*`,*`,int)),*(struct(char,int,*`,*`,int)),int)))
(	O
const	O
char	O
*	O
seq	*(struct)
,	O
int	O
code	int
,	O
int	O
action	int
)	O
{	O
key_def	struct(char,int,*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),int)
*	O
base	int
,	O
*	O
p	*(void)
,	O
*	O
attach	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
;	O
for	O
(	O
base	int
=	O
attach	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
NULL	O
;	O
*	O
seq	*(struct)
;	O
seq	*(struct)
++	O
)	O
{	O
p	*(void)
=	O
g_new	O
(	O
key_def	struct(char,int,*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),int)
,	O
1	int
)	O
;	O
if	O
(	O
!	O
base	int
)	O
base	int
=	O
p	*(void)
;	O
if	O
(	O
attach	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
)	O
attach	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
->	O
child	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
p	*(void)
;	O
p	*(void)
->	O
ch	int
=	O
*	O
seq	*(struct)
;	O
p	*(void)
->	O
code	int
=	O
code	int
;	O
p	*(void)
->	O
child	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
p	*(void)
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
!	O
seq	*(struct)
[	O
1	int
]	O
)	O
p	*(void)
->	O
action	int
=	O
action	int
;	O
else	O
p	*(void)
->	O
action	int
=	O
MCKEY_NOACTION	int
;	O
attach	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
p	*(void)
;	O
}	O
return	O
base	int
;	O
}	O
static	O
int	O
seq_buffer	array(int)
[	O
SEQ_BUFFER_LEN	int
]	O
;	O
static	O
int	O
*	O
seq_append	*(int)
=	O
0	int
;	O
static	O
int	O
push_char	(int)->(int)
(	O
int	O
c	int
)	O
{	O
if	O
(	O
!	O
seq_append	*(int)
)	O
seq_append	*(int)
=	O
seq_buffer	array(int)
;	O
if	O
(	O
seq_append	*(int)
==	O
&	O
(	O
seq_buffer	array(int)
[	O
SEQ_BUFFER_LEN	int
-	O
2	int
]	O
)	O
)	O
return	O
0	int
;	O
*	O
(	O
seq_append	*(int)
++	O
)	O
=	O
c	int
;	O
*	O
seq_append	*(int)
=	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
define_sequence	(int,*(char),int)->(int)
(	O
int	O
code	int
,	O
const	O
char	O
*	O
seq	*(struct)
,	O
int	O
action	int
)	O
{	O
key_def	struct(char,int,*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),int)
*	O
base	int
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
seq	*(struct)
)	O
>	O
SEQ_BUFFER_LEN	int
-	O
1	int
)	O
return	O
0	int
;	O
for	O
(	O
base	int
=	O
keys	*(struct(*(char),int))
;	O
(	O
base	int
!=	O
0	int
)	O
&&	O
*	O
seq	*(struct)
;	O
)	O
{	O
if	O
(	O
*	O
seq	*(struct)
==	O
base	int
->	O
ch	int
)	O
{	O
if	O
(	O
base	int
->	O
child	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
==	O
0	int
)	O
{	O
if	O
(	O
*	O
(	O
seq	*(struct)
+	O
1	int
)	O
)	O
{	O
base	int
->	O
child	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
create_sequence	(*(char),int,int)->(*(struct(char,int,*(struct(char,int,*`,*`,int)),*(struct(char,int,*`,*`,int)),int)))
(	O
seq	*(struct)
+	O
1	int
,	O
code	int
,	O
action	int
)	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
base	int
->	O
code	int
=	O
code	int
;	O
base	int
->	O
action	int
=	O
action	int
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
base	int
=	O
base	int
->	O
child	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
seq	*(struct)
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
base	int
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
base	int
=	O
base	int
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
else	O
{	O
base	int
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
create_sequence	(*(char),int,int)->(*(struct(char,int,*(struct(char,int,*`,*`,int)),*(struct(char,int,*`,*`,int)),int)))
(	O
seq	*(struct)
,	O
code	int
,	O
action	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
*	O
seq	*(struct)
)	O
{	O
return	O
0	int
;	O
}	O
keys	*(struct(*(char),int))
=	O
create_sequence	(*(char),int,int)->(*(struct(char,int,*(struct(char,int,*`,*`,int)),*(struct(char,int,*`,*`,int)),int)))
(	O
seq	*(struct)
,	O
code	int
,	O
action	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
*	O
pending_keys	*(int)
;	O
static	O
int	O
correct_key_code	(int)->(int)
(	O
int	O
code	int
)	O
{	O
unsigned	O
int	O
c	int
=	O
code	int
&	O
~	O
KEY_M_MASK	int
;	O
unsigned	O
int	O
mod	int
=	O
code	int
&	O
KEY_M_MASK	int
;	O
if	O
(	O
c	int
<	O
32	int
||	O
c	int
>=	O
256	int
)	O
{	O
mod	int
|=	O
get_modifier	()->(int)
(	O
)	O
;	O
}	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
c	int
=	O
'\n'	O
;	O
if	O
(	O
c	int
==	O
KEY_SCANCEL	int
)	O
c	int
=	O
'\t'	O
;	O
if	O
(	O
(	O
c	int
==	O
'\t'	O
)	O
&&	O
(	O
mod	int
&	O
(	O
KEY_M_SHIFT	int
|	O
KEY_M_CTRL	int
)	O
)	O
)	O
{	O
c	int
=	O
KEY_BTAB	int
;	O
mod	int
=	O
0	int
;	O
}	O
if	O
(	O
c	int
==	O
KEY_F	O
(	O
0	int
)	O
)	O
c	int
=	O
KEY_F	O
(	O
10	int
)	O
;	O
if	O
(	O
c	int
<	O
32	int
&&	O
c	int
!=	O
ESC_CHAR	char
&&	O
c	int
!=	O
'\t'	O
&&	O
c	int
!=	O
'\n'	O
)	O
{	O
mod	int
|=	O
KEY_M_CTRL	int
;	O
}	O
if	O
(	O
c	int
==	O
0177	int
)	O
{	O
c	int
=	O
KEY_BACKSPACE	int
;	O
}	O
if	O
(	O
c	int
==	O
(	O
31	int
&	O
'd'	O
)	O
)	O
{	O
c	int
=	O
KEY_DC	int
;	O
mod	int
&=	O
~	O
KEY_M_CTRL	int
;	O
}	O
if	O
(	O
c	int
==	O
(	O
31	int
&	O
'h'	O
)	O
)	O
{	O
c	int
=	O
KEY_BACKSPACE	int
;	O
mod	int
&=	O
~	O
KEY_M_CTRL	int
;	O
}	O
if	O
(	O
c	int
==	O
KEY_BACKSPACE	int
&&	O
(	O
mod	int
&	O
KEY_M_SHIFT	int
)	O
)	O
{	O
mod	int
&=	O
~	O
KEY_M_SHIFT	int
;	O
}	O
if	O
(	O
c	int
>=	O
KEY_F	O
(	O
1	int
)	O
&&	O
c	int
<=	O
KEY_F	O
(	O
10	int
)	O
&&	O
(	O
mod	int
&	O
KEY_M_SHIFT	int
)	O
)	O
{	O
c	int
+=	O
10	int
;	O
}	O
if	O
(	O
c	int
>=	O
KEY_F	O
(	O
1	int
)	O
&&	O
c	int
<=	O
KEY_F	O
(	O
20	int
)	O
)	O
{	O
mod	int
&=	O
~	O
KEY_M_SHIFT	int
;	O
}	O
if	O
(	O
!	O
alternate_plus_minus	int
)	O
switch	O
(	O
c	int
)	O
{	O
case	O
KEY_KP_ADD	int
:	O
c	int
=	O
'+'	O
;	O
break	O
;	O
case	O
KEY_KP_SUBTRACT	int
:	O
c	int
=	O
'-'	O
;	O
break	O
;	O
case	O
KEY_KP_MULTIPLY	int
:	O
c	int
=	O
'*'	O
;	O
break	O
;	O
}	O
return	O
(	O
mod	int
|	O
c	int
)	O
;	O
}	O
int	O
get_key_code	(int)->(int)
(	O
int	O
no_delay	int
)	O
{	O
int	O
c	int
;	O
static	O
key_def	struct(char,int,*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),int)
*	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
NULL	O
,	O
*	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
static	O
struct	O
timeval	struct(long,long)
esctime	struct(long,long)
=	O
{	O
-	O
1	int
,	O
-	O
1	int
}	O
;	O
static	O
int	O
lastnodelay	int
=	O
-	O
1	int
;	O
if	O
(	O
no_delay	int
!=	O
lastnodelay	int
)	O
{	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
NULL	O
;	O
lastnodelay	int
=	O
no_delay	int
;	O
}	O
pend_send	O
:	O
if	O
(	O
pending_keys	*(int)
)	O
{	O
int	O
d	double
=	O
*	O
pending_keys	*(int)
++	O
;	O
check_pend	O
:	O
if	O
(	O
!	O
*	O
pending_keys	*(int)
)	O
{	O
pending_keys	*(int)
=	O
0	int
;	O
seq_append	*(int)
=	O
0	int
;	O
}	O
if	O
(	O
d	double
==	O
ESC_CHAR	char
&&	O
pending_keys	*(int)
)	O
{	O
d	double
=	O
ALT	O
(	O
*	O
pending_keys	*(int)
++	O
)	O
;	O
goto	O
check_pend	O
;	O
}	O
if	O
(	O
(	O
d	double
>	O
127	int
&&	O
d	double
<	O
256	int
)	O
&&	O
use_8th_bit_as_meta	int
)	O
d	double
=	O
ALT	O
(	O
d	double
&	O
0x7f	int
)	O
;	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
NULL	O
;	O
return	O
correct_key_code	(int)->(int)
(	O
d	double
)	O
;	O
}	O
nodelay_try_again	O
:	O
if	O
(	O
no_delay	int
)	O
{	O
nodelay	int
(	O
stdscr	O
,	O
TRUE	O
)	O
;	O
}	O
c	int
=	O
getch	()->(int)
(	O
)	O
;	O
if	O
(	O
no_delay	int
)	O
{	O
nodelay	int
(	O
stdscr	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
!=	O
NULL	O
&&	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
&&	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
action	int
==	O
MCKEY_ESCAPE	int
&&	O
old_esc_mode	int
)	O
{	O
struct	O
timeval	struct(long,long)
current	*(struct)
,	O
timeout	long
;	O
if	O
(	O
esctime	struct(long,long)
.	O
tv_sec	long
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
GET_TIME	O
(	O
current	*(struct)
)	O
;	O
timeout	long
.	O
tv_sec	long
=	O
keyboard_key_timeout	int
/	O
1000000	int
+	O
esctime	struct(long,long)
.	O
tv_sec	long
;	O
timeout	long
.	O
tv_usec	long
=	O
keyboard_key_timeout	int
%	O
1000000	int
+	O
esctime	struct(long,long)
.	O
tv_usec	long
;	O
if	O
(	O
timeout	long
.	O
tv_usec	long
>	O
1000000	int
)	O
{	O
timeout	long
.	O
tv_usec	long
-=	O
1000000	int
;	O
timeout	long
.	O
tv_sec	long
++	O
;	O
}	O
if	O
(	O
current	*(struct)
.	O
tv_sec	long
<	O
timeout	long
.	O
tv_sec	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
current	*(struct)
.	O
tv_sec	long
==	O
timeout	long
.	O
tv_sec	long
&&	O
current	*(struct)
.	O
tv_usec	long
<	O
timeout	long
.	O
tv_usec	long
)	O
return	O
-	O
1	int
;	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
NULL	O
;	O
pending_keys	*(int)
=	O
seq_append	*(int)
=	O
NULL	O
;	O
return	O
ESC_CHAR	char
;	O
}	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
seq_append	*(int)
)	O
{	O
pending_keys	*(int)
=	O
seq_buffer	array(int)
;	O
goto	O
pend_send	O
;	O
}	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
NULL	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
no_delay	int
||	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
==	O
NULL	O
)	O
{	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
keys	*(struct(*(char),int))
;	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
(	O
c	int
>	O
127	int
&&	O
c	int
<	O
256	int
)	O
&&	O
use_8th_bit_as_meta	int
)	O
{	O
c	int
&=	O
0x7f	int
;	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
keys	*(struct(*(char),int))
;	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
keys	*(struct(*(char),int))
->	O
child	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
}	O
while	O
(	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
)	O
{	O
if	O
(	O
c	int
==	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
->	O
ch	int
)	O
{	O
if	O
(	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
->	O
child	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
if	O
(	O
!	O
push_char	(int)->(int)
(	O
c	int
)	O
)	O
{	O
pending_keys	*(int)
=	O
seq_buffer	array(int)
;	O
goto	O
pend_send	O
;	O
}	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
;	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
->	O
child	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
action	int
==	O
MCKEY_ESCAPE	int
&&	O
old_esc_mode	int
)	O
{	O
if	O
(	O
no_delay	int
)	O
{	O
GET_TIME	O
(	O
esctime	struct(long,long)
)	O
;	O
if	O
(	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
==	O
NULL	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Internal error\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
goto	O
nodelay_try_again	O
;	O
}	O
esctime	struct(long,long)
.	O
tv_sec	long
=	O
-	O
1	int
;	O
c	int
=	O
xgetch_second	()->(int)
(	O
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
{	O
pending_keys	*(int)
=	O
seq_append	*(int)
=	O
NULL	O
;	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
NULL	O
;	O
return	O
ESC_CHAR	char
;	O
}	O
}	O
else	O
{	O
if	O
(	O
no_delay	int
)	O
goto	O
nodelay_try_again	O
;	O
c	int
=	O
getch	()->(int)
(	O
)	O
;	O
}	O
}	O
else	O
{	O
int	O
code	int
;	O
pending_keys	*(int)
=	O
seq_append	*(int)
=	O
NULL	O
;	O
code	int
=	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
->	O
code	int
;	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
NULL	O
;	O
return	O
correct_key_code	(int)->(int)
(	O
code	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
else	O
{	O
if	O
(	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
!=	O
NULL	O
&&	O
parent	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
action	int
==	O
MCKEY_ESCAPE	int
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
c	int
)	O
)	O
c	int
=	O
KEY_F	O
(	O
c	int
-	O
'0'	O
)	O
;	O
else	O
if	O
(	O
c	int
==	O
' '	O
)	O
c	int
=	O
ESC_CHAR	char
;	O
else	O
c	int
=	O
ALT	O
(	O
c	int
)	O
;	O
pending_keys	*(int)
=	O
seq_append	*(int)
=	O
NULL	O
;	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
NULL	O
;	O
return	O
correct_key_code	(int)->(int)
(	O
c	int
)	O
;	O
}	O
push_char	(int)->(int)
(	O
c	int
)	O
;	O
pending_keys	*(int)
=	O
seq_buffer	array(int)
;	O
goto	O
pend_send	O
;	O
}	O
}	O
}	O
this	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
=	O
NULL	O
;	O
return	O
correct_key_code	(int)->(int)
(	O
c	int
)	O
;	O
}	O
static	O
void	O
try_channels	(int)->(void)
(	O
int	O
set_timeout	int
)	O
{	O
struct	O
timeval	struct(long,long)
timeout	long
;	O
static	O
fd_set	struct(array(long))
select_set	*(struct(array(long)))
;	O
struct	O
timeval	struct(long,long)
*	O
timeptr	*(struct(long,long))
;	O
int	O
v	*(void)
;	O
int	O
maxfdp	int
;	O
while	O
(	O
1	int
)	O
{	O
FD_ZERO	O
(	O
&	O
select_set	*(struct(array(long)))
)	O
;	O
FD_SET	O
(	O
input_fd	int
,	O
&	O
select_set	*(struct(array(long)))
)	O
;	O
maxfdp	int
=	O
max	long
(	O
add_selects	(*(struct(array(long))))->(int)
(	O
&	O
select_set	*(struct(array(long)))
)	O
,	O
input_fd	int
)	O
;	O
if	O
(	O
set_timeout	int
)	O
{	O
timeout	long
.	O
tv_sec	long
=	O
0	int
;	O
timeout	long
.	O
tv_usec	long
=	O
100000	int
;	O
timeptr	*(struct(long,long))
=	O
&	O
timeout	long
;	O
}	O
else	O
timeptr	*(struct(long,long))
=	O
0	int
;	O
v	*(void)
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
maxfdp	int
+	O
1	int
,	O
&	O
select_set	*(struct(array(long)))
,	O
NULL	O
,	O
NULL	O
,	O
timeptr	*(struct(long,long))
)	O
;	O
if	O
(	O
v	*(void)
>	O
0	int
)	O
{	O
check_selects	(*(struct(array(long))))->(void)
(	O
&	O
select_set	*(struct(array(long)))
)	O
;	O
if	O
(	O
FD_ISSET	O
(	O
input_fd	int
,	O
&	O
select_set	*(struct(array(long)))
)	O
)	O
return	O
;	O
}	O
}	O
}	O
static	O
int	O
getch_with_delay	()->(int)
(	O
void	O
)	O
{	O
int	O
c	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
!	O
pending_keys	*(int)
)	O
try_channels	(int)->(void)
(	O
0	int
)	O
;	O
c	int
=	O
get_key_code	(int)->(int)
(	O
0	int
)	O
;	O
if	O
(	O
c	int
!=	O
-	O
1	int
)	O
break	O
;	O
try_channels	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
c	int
;	O
}	O
int	O
get_event	(*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int))),int,int)->(int)
(	O
struct	O
Gpm_Event	struct(int,int,int,enum(int,int,int,int,int,int,int,int,int))
*	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
,	O
int	O
redo_event	int
,	O
int	O
block	int
)	O
{	O
int	O
c	int
;	O
static	O
int	O
flag	int
;	O
struct	O
timeval	struct(long,long)
timeout	long
;	O
struct	O
timeval	struct(long,long)
*	O
time_addr	*(struct(long,long))
=	O
NULL	O
;	O
static	O
int	O
dirty	int
=	O
3	int
;	O
if	O
(	O
(	O
dirty	int
==	O
3	int
)	O
||	O
is_idle	()->(int)
(	O
)	O
)	O
{	O
mc_refresh	()->(void)
(	O
)	O
;	O
doupdate	O
(	O
)	O
;	O
dirty	int
=	O
1	int
;	O
}	O
else	O
dirty	int
++	O
;	O
vfs_timeout_handler	()->(void)
(	O
)	O
;	O
if	O
(	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
x	array(long)
>	O
0	int
)	O
{	O
show_mouse_pointer	O
(	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
x	array(long)
,	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
y	short
)	O
;	O
if	O
(	O
!	O
redo_event	int
)	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
x	array(long)
=	O
-	O
1	int
;	O
}	O
while	O
(	O
mouse_enabled	int
&&	O
!	O
pending_keys	*(int)
)	O
{	O
int	O
maxfdp	int
;	O
fd_set	struct(array(long))
select_set	*(struct(array(long)))
;	O
FD_ZERO	O
(	O
&	O
select_set	*(struct(array(long)))
)	O
;	O
FD_SET	O
(	O
input_fd	int
,	O
&	O
select_set	*(struct(array(long)))
)	O
;	O
maxfdp	int
=	O
max	long
(	O
add_selects	(*(struct(array(long))))->(int)
(	O
&	O
select_set	*(struct(array(long)))
)	O
,	O
input_fd	int
)	O
;	O
if	O
(	O
redo_event	int
)	O
{	O
timeout	long
.	O
tv_usec	long
=	O
mou_auto_repeat	int
*	O
1000	int
;	O
timeout	long
.	O
tv_sec	long
=	O
0	int
;	O
time_addr	*(struct(long,long))
=	O
&	O
timeout	long
;	O
}	O
else	O
{	O
int	O
seconds	int
;	O
if	O
(	O
(	O
seconds	int
=	O
vfs_timeouts	()->(int)
(	O
)	O
)	O
)	O
{	O
timeout	long
.	O
tv_sec	long
=	O
seconds	int
;	O
timeout	long
.	O
tv_usec	long
=	O
0	int
;	O
time_addr	*(struct(long,long))
=	O
&	O
timeout	long
;	O
}	O
else	O
time_addr	*(struct(long,long))
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
block	int
||	O
winch_flag	int
)	O
{	O
time_addr	*(struct(long,long))
=	O
&	O
timeout	long
;	O
timeout	long
.	O
tv_sec	long
=	O
0	int
;	O
timeout	long
.	O
tv_usec	long
=	O
0	int
;	O
}	O
enable_interrupt_key	O
(	O
)	O
;	O
flag	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
maxfdp	int
+	O
1	int
,	O
&	O
select_set	*(struct(array(long)))
,	O
NULL	O
,	O
NULL	O
,	O
time_addr	*(struct(long,long))
)	O
;	O
disable_interrupt_key	O
(	O
)	O
;	O
if	O
(	O
flag	int
==	O
0	int
)	O
{	O
if	O
(	O
redo_event	int
)	O
return	O
EV_MOUSE	O
;	O
if	O
(	O
!	O
block	int
||	O
winch_flag	int
)	O
return	O
EV_NONE	O
;	O
vfs_timeout_handler	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
flag	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
return	O
EV_NONE	O
;	O
check_selects	(*(struct(array(long))))->(void)
(	O
&	O
select_set	*(struct(array(long)))
)	O
;	O
if	O
(	O
FD_ISSET	O
(	O
input_fd	int
,	O
&	O
select_set	*(struct(array(long)))
)	O
)	O
break	O
;	O
}	O
c	int
=	O
block	int
?	O
getch_with_delay	()->(int)
(	O
)	O
:	O
get_key_code	(int)->(int)
(	O
1	int
)	O
;	O
if	O
(	O
c	int
==	O
MCKEY_MOUSE	O
)	O
{	O
xmouse_get_event	(*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int))))->(void)
(	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
)	O
;	O
if	O
(	O
event	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
->	O
type	enum(int,int,int,int)
)	O
return	O
EV_MOUSE	O
;	O
else	O
return	O
EV_NONE	O
;	O
}	O
return	O
c	int
;	O
}	O
int	O
mi_getch	()->(int)
(	O
)	O
{	O
Gpm_Event	struct(int,int,int,enum(int,int,int,int,int,int,int,int,int))
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
;	O
int	O
key	*(void)
;	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
.	O
x	array(long)
=	O
-	O
1	int
;	O
while	O
(	O
(	O
key	*(void)
=	O
get_event	(*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int))),int,int)->(int)
(	O
&	O
ev	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int)))
,	O
0	int
,	O
1	int
)	O
)	O
==	O
EV_NONE	O
)	O
;	O
return	O
key	*(void)
;	O
}	O
static	O
int	O
xgetch_second	()->(int)
(	O
void	O
)	O
{	O
fd_set	struct(array(long))
Read_FD_Set	struct(array(long))
;	O
int	O
c	int
;	O
struct	O
timeval	struct(long,long)
timeout	long
;	O
timeout	long
.	O
tv_sec	long
=	O
keyboard_key_timeout	int
/	O
1000000	int
;	O
timeout	long
.	O
tv_usec	long
=	O
keyboard_key_timeout	int
%	O
1000000	int
;	O
nodelay	int
(	O
stdscr	O
,	O
TRUE	O
)	O
;	O
FD_ZERO	O
(	O
&	O
Read_FD_Set	struct(array(long))
)	O
;	O
FD_SET	O
(	O
input_fd	int
,	O
&	O
Read_FD_Set	struct(array(long))
)	O
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
input_fd	int
+	O
1	int
,	O
&	O
Read_FD_Set	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
&	O
timeout	long
)	O
;	O
c	int
=	O
getch	()->(int)
(	O
)	O
;	O
nodelay	int
(	O
stdscr	O
,	O
FALSE	O
)	O
;	O
return	O
c	int
;	O
}	O
static	O
void	O
learn_store_key	(*(char),*(*(char)),int)->(void)
(	O
char	O
*	O
buffer	*(char)
,	O
char	O
*	O
*	O
p	*(void)
,	O
int	O
c	int
)	O
{	O
if	O
(	O
*	O
p	*(void)
-	O
buffer	*(char)
>	O
253	int
)	O
return	O
;	O
if	O
(	O
c	int
==	O
ESC_CHAR	char
)	O
{	O
*	O
(	O
*	O
p	*(void)
)	O
++	O
=	O
'\\'	O
;	O
*	O
(	O
*	O
p	*(void)
)	O
++	O
=	O
'e'	O
;	O
}	O
else	O
if	O
(	O
c	int
<	O
' '	O
)	O
{	O
*	O
(	O
*	O
p	*(void)
)	O
++	O
=	O
'^'	O
;	O
*	O
(	O
*	O
p	*(void)
)	O
++	O
=	O
c	int
+	O
'a'	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'^'	O
)	O
{	O
*	O
(	O
*	O
p	*(void)
)	O
++	O
=	O
'^'	O
;	O
*	O
(	O
*	O
p	*(void)
)	O
++	O
=	O
'^'	O
;	O
}	O
else	O
*	O
(	O
*	O
p	*(void)
)	O
++	O
=	O
(	O
char	O
)	O
c	int
;	O
}	O
char	O
*	O
learn_key	()->(*(char))
(	O
void	O
)	O
{	O
fd_set	struct(array(long))
Read_FD_Set	struct(array(long))
;	O
struct	O
timeval	struct(long,long)
endtime	struct(long,long)
;	O
struct	O
timeval	struct(long,long)
timeout	long
;	O
int	O
c	int
;	O
char	O
buffer	*(char)
[	O
256	int
]	O
;	O
char	O
*	O
p	*(void)
=	O
buffer	*(char)
;	O
keypad	O
(	O
stdscr	O
,	O
FALSE	O
)	O
;	O
c	int
=	O
getch	()->(int)
(	O
)	O
;	O
while	O
(	O
c	int
==	O
-	O
1	int
)	O
c	int
=	O
getch	()->(int)
(	O
)	O
;	O
learn_store_key	(*(char),*(*(char)),int)->(void)
(	O
buffer	*(char)
,	O
&	O
p	*(void)
,	O
c	int
)	O
;	O
GET_TIME	O
(	O
endtime	struct(long,long)
)	O
;	O
endtime	struct(long,long)
.	O
tv_usec	long
+=	O
LEARN_TIMEOUT	int
;	O
if	O
(	O
endtime	struct(long,long)
.	O
tv_usec	long
>	O
1000000	int
)	O
{	O
endtime	struct(long,long)
.	O
tv_usec	long
-=	O
1000000	int
;	O
endtime	struct(long,long)
.	O
tv_sec	long
++	O
;	O
}	O
nodelay	int
(	O
stdscr	O
,	O
TRUE	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
(	O
c	int
=	O
getch	()->(int)
(	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
GET_TIME	O
(	O
timeout	long
)	O
;	O
timeout	long
.	O
tv_usec	long
=	O
endtime	struct(long,long)
.	O
tv_usec	long
-	O
timeout	long
.	O
tv_usec	long
;	O
if	O
(	O
timeout	long
.	O
tv_usec	long
<	O
0	int
)	O
timeout	long
.	O
tv_sec	long
++	O
;	O
timeout	long
.	O
tv_sec	long
=	O
endtime	struct(long,long)
.	O
tv_sec	long
-	O
timeout	long
.	O
tv_sec	long
;	O
if	O
(	O
timeout	long
.	O
tv_sec	long
>=	O
0	int
&&	O
timeout	long
.	O
tv_usec	long
>	O
0	int
)	O
{	O
FD_ZERO	O
(	O
&	O
Read_FD_Set	struct(array(long))
)	O
;	O
FD_SET	O
(	O
input_fd	int
,	O
&	O
Read_FD_Set	struct(array(long))
)	O
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
input_fd	int
+	O
1	int
,	O
&	O
Read_FD_Set	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
&	O
timeout	long
)	O
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
learn_store_key	(*(char),*(*(char)),int)->(void)
(	O
buffer	*(char)
,	O
&	O
p	*(void)
,	O
c	int
)	O
;	O
}	O
keypad	O
(	O
stdscr	O
,	O
TRUE	O
)	O
;	O
nodelay	int
(	O
stdscr	O
,	O
FALSE	O
)	O
;	O
*	O
p	*(void)
=	O
0	int
;	O
return	O
g_strdup	(*(char))->(*(char))
(	O
buffer	*(char)
)	O
;	O
}	O
void	O
numeric_keypad_mode	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
console_flag	char
||	O
xterm_flag	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\033>"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
void	O
application_keypad_mode	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
console_flag	char
||	O
xterm_flag	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\033="	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
int	O
is_idle	()->(int)
(	O
void	O
)	O
{	O
int	O
maxfdp	int
;	O
fd_set	struct(array(long))
select_set	*(struct(array(long)))
;	O
struct	O
timeval	struct(long,long)
timeout	long
;	O
FD_ZERO	O
(	O
&	O
select_set	*(struct(array(long)))
)	O
;	O
FD_SET	O
(	O
input_fd	int
,	O
&	O
select_set	*(struct(array(long)))
)	O
;	O
maxfdp	int
=	O
input_fd	int
;	O
timeout	long
.	O
tv_sec	long
=	O
0	int
;	O
timeout	long
.	O
tv_usec	long
=	O
0	int
;	O
return	O
(	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
maxfdp	int
+	O
1	int
,	O
&	O
select_set	*(struct(array(long)))
,	O
0	int
,	O
0	int
,	O
&	O
timeout	long
)	O
<=	O
0	int
)	O
;	O
}	O
static	O
int	O
get_modifier	()->(int)
(	O
void	O
)	O
{	O
int	O
result	long
=	O
0	int
;	O
{	O
unsigned	O
char	O
modifiers	char
=	O
6	int
;	O
if	O
(	O
ioctl	(int,long)->(int)
(	O
0	int
,	O
TIOCLINUX	int
,	O
&	O
modifiers	char
)	O
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
modifiers	char
&	O
SHIFT_PRESSED	O
)	O
result	long
|=	O
KEY_M_SHIFT	int
;	O
if	O
(	O
modifiers	char
&	O
(	O
ALTL_PRESSED	O
|	O
ALTR_PRESSED	O
)	O
)	O
result	long
|=	O
KEY_M_ALT	int
;	O
if	O
(	O
modifiers	char
&	O
CONTROL_PRESSED	O
)	O
result	long
|=	O
KEY_M_CTRL	int
;	O
}	O
return	O
result	long
;	O
}	O
static	O
void	O
k_dispose	(*(struct(char,int,*(struct(char,int,*`,*`,int)),*(struct(char,int,*`,*`,int)),int)))->(void)
(	O
key_def	struct(char,int,*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int)),int)
*	O
k	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
)	O
{	O
if	O
(	O
!	O
k	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
)	O
return	O
;	O
k_dispose	(*(struct(char,int,*(struct(char,int,*`,*`,int)),*(struct(char,int,*`,*`,int)),int)))->(void)
(	O
k	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
->	O
child	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
k_dispose	(*(struct(char,int,*(struct(char,int,*`,*`,int)),*(struct(char,int,*`,*`,int)),int)))->(void)
(	O
k	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
g_free	(*(void))->(void)
(	O
k	*(struct(char,int,*(struct(char,int,*(struct`),*(struct`),int)),*(struct(char,int,*(struct`),*(struct`),int)),int))
)	O
;	O
}	O
static	O
void	O
s_dispose	(*(struct(int,*((int,*`)->(int)),*(void),*(struct(int,*`,*`,*`)))))->(void)
(	O
SelectList	struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`))))))
*	O
sel	int
)	O
{	O
if	O
(	O
!	O
sel	int
)	O
return	O
;	O
s_dispose	(*(struct(int,*((int,*`)->(int)),*(void),*(struct(int,*`,*`,*`)))))->(void)
(	O
sel	int
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
;	O
g_free	(*(void))->(void)
(	O
sel	int
)	O
;	O
}	O
void	O
done_key	()->(void)
(	O
)	O
{	O
k_dispose	(*(struct(char,int,*(struct(char,int,*`,*`,int)),*(struct(char,int,*`,*`,int)),int)))->(void)
(	O
keys	*(struct(*(char),int))
)	O
;	O
s_dispose	(*(struct(int,*((int,*`)->(int)),*(void),*(struct(int,*`,*`,*`)))))->(void)
(	O
select_list	*(struct(int,*((int,*(void))->(int)),*(void),*(struct(int,*((int,*`)->(int)),*(void),*(struct`)))))
)	O
;	O
}	O
