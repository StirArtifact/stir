char	O
*	O
unix_normalize	(*(struct),*(char),*(struct),long)->(*(char))
(	O
doscp_t	struct
*	O
cp	*(struct)
,	O
char	O
*	O
ans	*(char)
,	O
dos_name_t	struct
*	O
dn	*(struct)
,	O
size_t	long
ans_size	long
)	O
{	O
char	O
buffer	array(char)
[	O
13	int
]	O
;	O
wchar_t	int
wbuffer	array(int)
[	O
13	int
]	O
;	O
char	O
*	O
a	*(char)
;	O
int	O
j	int
;	O
for	O
(	O
a	*(char)
=	O
buffer	array(char)
,	O
j	int
=	O
0	int
;	O
(	O
j	int
<	O
8	int
)	O
&&	O
(	O
dn	*(struct)
->	O
base	int
[	O
j	int
]	O
>	O
' '	O
)	O
;	O
++	O
j	int
,	O
++	O
a	*(char)
)	O
*	O
a	*(char)
=	O
dn	*(struct)
->	O
base	int
[	O
j	int
]	O
;	O
if	O
(	O
dn	*(struct)
->	O
ext	array(char)
[	O
0	int
]	O
>	O
' '	O
)	O
{	O
*	O
a	*(char)
++	O
=	O
'.'	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
3	int
&&	O
dn	*(struct)
->	O
ext	array(char)
[	O
j	int
]	O
>	O
' '	O
;	O
++	O
j	int
,	O
++	O
a	*(char)
)	O
*	O
a	*(char)
=	O
dn	*(struct)
->	O
ext	array(char)
[	O
j	int
]	O
;	O
}	O
*	O
a	*(char)
++	O
=	O
'\0'	O
;	O
dos_to_wchar	(*(struct),*(char),*(int),long)->(int)
(	O
cp	*(struct)
,	O
buffer	array(char)
,	O
wbuffer	array(int)
,	O
13	int
)	O
;	O
wchar_to_native	(*(int),*(char),long,long)->(int)
(	O
wbuffer	array(int)
,	O
ans	*(char)
,	O
13	int
,	O
ans_size	long
)	O
;	O
return	O
ans	*(char)
;	O
}	O
typedef	O
enum	O
Case_l	enum(int,int,int)
{	O
NONE	int
,	O
UPPER	int
,	O
LOWER	int
}	O
Case_t	enum(int,int,int)
;	O
static	O
void	O
TranslateToDos	(*(struct),*(char),*(char),long,*(char),*(enum(int,int,int)),*(int))->(void)
(	O
doscp_t	struct
*	O
toDos	*(struct)
,	O
const	O
char	O
*	O
in	*(char)
,	O
char	O
*	O
out	*(char)
,	O
size_t	long
count	array(char)
,	O
char	O
*	O
end	*(int)
,	O
Case_t	enum(int,int,int)
*	O
Case	char
,	O
int	O
*	O
mangled	*(int)
)	O
{	O
wchar_t	int
buffer	array(char)
[	O
12	int
]	O
;	O
wchar_t	int
*	O
s	*(int)
=	O
buffer	array(char)
;	O
size_t	long
t_idx	long
=	O
0	int
;	O
native_to_wchar	(*(char),*(int),long,*(char),*(int))->(int)
(	O
in	*(char)
,	O
buffer	array(char)
,	O
count	array(char)
,	O
end	*(int)
,	O
mangled	*(int)
)	O
;	O
buffer	array(char)
[	O
count	array(char)
]	O
=	O
'\0'	O
;	O
*	O
Case	char
=	O
NONE	int
;	O
for	O
(	O
;	O
*	O
s	*(int)
;	O
s	*(int)
++	O
)	O
{	O
if	O
(	O
*	O
s	*(int)
==	O
' '	O
||	O
*	O
s	*(int)
==	O
'.'	O
)	O
{	O
*	O
mangled	*(int)
|=	O
3	int
;	O
continue	O
;	O
}	O
if	O
(	O
iswcntrl	(int)->(int)
(	O
(	O
wint_t	int
)	O
*	O
s	*(int)
)	O
)	O
{	O
*	O
mangled	*(int)
|=	O
3	int
;	O
buffer	array(char)
[	O
t_idx	long
]	O
=	O
'_'	O
;	O
}	O
else	O
if	O
(	O
iswlower	(int)->(int)
(	O
(	O
wint_t	int
)	O
*	O
s	*(int)
)	O
)	O
{	O
buffer	array(char)
[	O
t_idx	long
]	O
=	O
ch_towupper	(int)->(int)
(	O
*	O
s	*(int)
)	O
;	O
if	O
(	O
*	O
Case	char
==	O
UPPER	int
&&	O
!	O
mtools_no_vfat	int
)	O
*	O
mangled	*(int)
|=	O
1	int
;	O
else	O
*	O
Case	char
=	O
LOWER	int
;	O
}	O
else	O
if	O
(	O
iswupper	(int)->(int)
(	O
(	O
wint_t	int
)	O
*	O
s	*(int)
)	O
)	O
{	O
buffer	array(char)
[	O
t_idx	long
]	O
=	O
*	O
s	*(int)
;	O
if	O
(	O
*	O
Case	char
==	O
LOWER	int
&&	O
!	O
mtools_no_vfat	int
)	O
*	O
mangled	*(int)
|=	O
1	int
;	O
else	O
*	O
Case	char
=	O
UPPER	int
;	O
}	O
else	O
buffer	array(char)
[	O
t_idx	long
]	O
=	O
*	O
s	*(int)
;	O
t_idx	long
++	O
;	O
}	O
wchar_to_dos	(*(struct),*(int),*(char),long,*(int))->(void)
(	O
toDos	*(struct)
,	O
buffer	array(char)
,	O
out	*(char)
,	O
t_idx	long
,	O
mangled	*(int)
)	O
;	O
}	O
void	O
dos_name	(*(struct),*(char),int,*(int),*(struct))->(void)
(	O
doscp_t	struct
*	O
toDos	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
,	O
int	O
verbose	int
UNUSEDP	O
,	O
int	O
*	O
mangled	*(int)
,	O
dos_name_t	struct
*	O
dn	*(struct)
)	O
{	O
char	O
*	O
s	*(int)
,	O
*	O
ext	array(char)
;	O
size_t	long
i	long
;	O
Case_t	enum(int,int,int)
BaseCase	enum(int,int,int)
,	O
ExtCase	enum(int,int,int)
=	O
UPPER	int
;	O
*	O
mangled	*(int)
=	O
0	int
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
&&	O
name	*(char)
[	O
1	int
]	O
==	O
':'	O
)	O
name	*(char)
=	O
&	O
name	*(char)
[	O
2	int
]	O
;	O
name	*(char)
=	O
(	O
char	O
*	O
)	O
_basename	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
if	O
(	O
(	O
s	*(int)
=	O
strrchr	(*(char),int)->(*(char))
(	O
name	*(char)
,	O
'\\'	O
)	O
)	O
)	O
name	*(char)
=	O
s	*(int)
+	O
1	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
dn	*(struct)
,	O
' '	O
,	O
11	int
)	O
;	O
i	long
=	O
strspn	(*(char),*(char))->(long)
(	O
name	*(char)
,	O
". "	*(char)
)	O
;	O
if	O
(	O
i	long
)	O
{	O
name	*(char)
+=	O
i	long
;	O
*	O
mangled	*(int)
=	O
3	int
;	O
}	O
ext	array(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
name	*(char)
,	O
'.'	O
)	O
;	O
TranslateToDos	(*(struct),*(char),*(char),long,*(char),*(enum(int,int,int)),*(int))->(void)
(	O
toDos	*(struct)
,	O
name	*(char)
,	O
dn	*(struct)
->	O
base	int
,	O
8	int
,	O
ext	array(char)
,	O
&	O
BaseCase	enum(int,int,int)
,	O
mangled	*(int)
)	O
;	O
if	O
(	O
ext	array(char)
)	O
TranslateToDos	(*(struct),*(char),*(char),long,*(char),*(enum(int,int,int)),*(int))->(void)
(	O
toDos	*(struct)
,	O
ext	array(char)
+	O
1	int
,	O
dn	*(struct)
->	O
ext	array(char)
,	O
3	int
,	O
0	int
,	O
&	O
ExtCase	enum(int,int,int)
,	O
mangled	*(int)
)	O
;	O
if	O
(	O
*	O
mangled	*(int)
&	O
2	int
)	O
autorename_short	(*(struct),int)->(void)
(	O
dn	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
!	O
*	O
mangled	*(int)
)	O
{	O
if	O
(	O
BaseCase	enum(int,int,int)
==	O
LOWER	int
)	O
*	O
mangled	*(int)
|=	O
BASECASE	int
;	O
if	O
(	O
ExtCase	enum(int,int,int)
==	O
LOWER	int
)	O
*	O
mangled	*(int)
|=	O
EXTCASE	int
;	O
}	O
}	O
wchar_t	int
*	O
unix_name	(*(struct),*(char),*(char),char,*(int))->(*(int))
(	O
doscp_t	struct
*	O
dosCp	*(struct)
,	O
const	O
char	O
*	O
base	int
,	O
const	O
char	O
*	O
ext	array(char)
,	O
char	O
Case	char
,	O
wchar_t	int
*	O
ret	*(int)
)	O
{	O
char	O
*	O
s	*(int)
,	O
tname	array(char)
[	O
9	int
]	O
,	O
text	array(char)
[	O
4	int
]	O
,	O
ans	*(char)
[	O
13	int
]	O
;	O
int	O
i	long
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
tname	array(char)
,	O
base	int
,	O
8	int
)	O
;	O
tname	array(char)
[	O
8	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
s	*(int)
=	O
strchr	(*(char),int)->(*(char))
(	O
tname	array(char)
,	O
' '	O
)	O
)	O
)	O
*	O
s	*(int)
=	O
'\0'	O
;	O
if	O
(	O
tname	array(char)
[	O
0	int
]	O
==	O
'\x05'	O
)	O
tname	array(char)
[	O
0	int
]	O
=	O
'\xE5'	O
;	O
if	O
(	O
!	O
(	O
Case	char
&	O
(	O
BASECASE	int
|	O
EXTCASE	int
)	O
)	O
&&	O
mtools_ignore_short_case	int
)	O
Case	char
|=	O
BASECASE	int
|	O
EXTCASE	int
;	O
if	O
(	O
Case	char
&	O
BASECASE	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
8	int
&&	O
tname	array(char)
[	O
i	long
]	O
;	O
i	long
++	O
)	O
tname	array(char)
[	O
i	long
]	O
=	O
ch_tolower	(char)->(char)
(	O
tname	array(char)
[	O
i	long
]	O
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
text	array(char)
,	O
ext	array(char)
,	O
3	int
)	O
;	O
text	array(char)
[	O
3	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
s	*(int)
=	O
strchr	(*(char),int)->(*(char))
(	O
text	array(char)
,	O
' '	O
)	O
)	O
)	O
*	O
s	*(int)
=	O
'\0'	O
;	O
if	O
(	O
Case	char
&	O
EXTCASE	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
3	int
&&	O
text	array(char)
[	O
i	long
]	O
;	O
i	long
++	O
)	O
text	array(char)
[	O
i	long
]	O
=	O
ch_tolower	(char)->(char)
(	O
text	array(char)
[	O
i	long
]	O
)	O
;	O
if	O
(	O
*	O
text	array(char)
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
ans	*(char)
,	O
tname	array(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
ans	*(char)
,	O
"."	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
ans	*(char)
,	O
text	array(char)
)	O
;	O
}	O
else	O
strcpy	(*(char),*(char))->(*(char))
(	O
ans	*(char)
,	O
tname	array(char)
)	O
;	O
dos_to_wchar	(*(struct),*(char),*(int),long)->(int)
(	O
dosCp	*(struct)
,	O
ans	*(char)
,	O
ret	*(int)
,	O
12	int
)	O
;	O
return	O
ret	*(int)
;	O
}	O
int	O
unicode_write	(*(int),*(struct(char,char)),int,*(int))->(int)
(	O
wchar_t	int
*	O
in	*(char)
,	O
struct	O
unicode_char	struct(char,char)
*	O
out	*(char)
,	O
int	O
num	int
,	O
int	O
*	O
end_p	*(int)
)	O
{	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num	int
;	O
++	O
j	int
)	O
{	O
if	O
(	O
*	O
end_p	*(int)
)	O
out	*(char)
->	O
uchar	char
=	O
out	*(char)
->	O
lchar	char
=	O
0xff	int
;	O
else	O
{	O
out	*(char)
->	O
uchar	char
=	O
(	O
*	O
in	*(char)
&	O
0xffff	int
)	O
>>	O
8	int
;	O
out	*(char)
->	O
lchar	char
=	O
*	O
in	*(char)
&	O
0xff	int
;	O
if	O
(	O
!	O
*	O
in	*(char)
)	O
{	O
*	O
end_p	*(int)
=	O
VSE_LAST	int
;	O
}	O
}	O
++	O
out	*(char)
;	O
++	O
in	*(char)
;	O
}	O
return	O
num	int
;	O
}	O
