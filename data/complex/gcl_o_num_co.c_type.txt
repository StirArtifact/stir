object	O
plus_half	int
,	O
minus_half	O
;	O
extern	O
void	O
zero_divisor	()->(void)
(	O
void	O
)	O
;	O
int	O
gcl_isnormal_double	(double)->(int)
(	O
double	O
d	double
)	O
{	O
union	O
{	O
double	O
d	double
;	O
int	O
i	array(int)
[	O
2	int
]	O
;	O
}	O
u	union(double,array(int))
;	O
if	O
(	O
!	O
ISFINITE	()->(int)
(	O
d	double
)	O
||	O
!	O
d	double
)	O
return	O
0	int
;	O
u	union(double,array(int))
.	O
d	double
=	O
d	double
;	O
return	O
(	O
u	union(double,array(int))
.	O
i	array(int)
[	O
HIND	O
]	O
&	O
0x7ff00000	int
)	O
!=	O
0	int
;	O
}	O
int	O
gcl_isnormal_float	(float)->(int)
(	O
float	O
f	float
)	O
{	O
union	O
{	O
float	O
f	float
;	O
int	O
i	array(int)
;	O
}	O
u	union(double,array(int))
;	O
if	O
(	O
!	O
ISFINITE	()->(int)
(	O
f	float
)	O
||	O
!	O
f	float
)	O
return	O
0	int
;	O
u	union(double,array(int))
.	O
f	float
=	O
f	float
;	O
return	O
(	O
u	union(double,array(int))
.	O
i	array(int)
&	O
0x7f800000	int
)	O
!=	O
0	int
;	O
}	O
static	O
void	O
integer_decode_double	(double,*(int),*(int),*(int),*(int))->(void)
(	O
double	O
d	double
,	O
int	O
*	O
hp	*(int)
,	O
int	O
*	O
lp	*(int)
,	O
int	O
*	O
ep	*(int)
,	O
int	O
*	O
sp	*(int)
)	O
{	O
int	O
h	int
,	O
l	int
;	O
union	O
{	O
double	O
d	double
;	O
int	O
i	array(int)
[	O
2	int
]	O
;	O
}	O
u	union(double,array(int))
;	O
if	O
(	O
d	double
==	O
0.0	int
)	O
{	O
*	O
hp	*(int)
=	O
*	O
lp	*(int)
=	O
0	int
;	O
*	O
ep	*(int)
=	O
0	int
;	O
*	O
sp	*(int)
=	O
1	int
;	O
return	O
;	O
}	O
u	union(double,array(int))
.	O
d	double
=	O
d	double
;	O
h	int
=	O
u	union(double,array(int))
.	O
i	array(int)
[	O
HIND	O
]	O
;	O
l	int
=	O
u	union(double,array(int))
.	O
i	array(int)
[	O
LIND	O
]	O
;	O
if	O
(	O
ISNORMAL	O
(	O
d	double
)	O
)	O
{	O
*	O
ep	*(int)
=	O
(	O
(	O
h	int
&	O
0x7ff00000	int
)	O
>>	O
20	int
)	O
-	O
1022	int
-	O
53	int
;	O
h	int
=	O
(	O
(	O
h	int
&	O
0x000fffff	int
)	O
|	O
0x00100000	int
)	O
;	O
}	O
else	O
{	O
*	O
ep	*(int)
=	O
(	O
(	O
h	int
&	O
0x7fe00000	int
)	O
>>	O
20	int
)	O
-	O
1022	int
-	O
53	int
+	O
1	int
;	O
h	int
=	O
(	O
h	int
&	O
0x001fffff	int
)	O
;	O
}	O
if	O
(	O
32	int
-	O
BIG_RADIX	O
)	O
{	O
h	int
=	O
h	int
<<	O
(	O
32	int
-	O
BIG_RADIX	O
)	O
;	O
h	int
|=	O
(	O
(	O
l	int
&	O
(	O
-	O
1	int
<<	O
(	O
32	int
-	O
BIG_RADIX	O
)	O
)	O
)	O
>>	O
(	O
32	int
-	O
BIG_RADIX	O
)	O
)	O
;	O
l	int
&=	O
~	O
(	O
-	O
1	int
<<	O
(	O
32	int
-	O
BIG_RADIX	O
)	O
)	O
;	O
}	O
*	O
hp	*(int)
=	O
h	int
;	O
*	O
lp	*(int)
=	O
l	int
;	O
*	O
sp	*(int)
=	O
(	O
d	double
>	O
0.0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
}	O
static	O
void	O
integer_decode_float	(double,*(int),*(int),*(int))->(void)
(	O
double	O
d	double
,	O
int	O
*	O
mp	*(int)
,	O
int	O
*	O
ep	*(int)
,	O
int	O
*	O
sp	*(int)
)	O
{	O
float	O
f	float
;	O
int	O
m	int
;	O
union	O
{	O
float	O
f	float
;	O
int	O
i	array(int)
;	O
}	O
u	union(double,array(int))
;	O
f	float
=	O
d	double
;	O
if	O
(	O
f	float
==	O
0.0	int
)	O
{	O
*	O
mp	*(int)
=	O
0	int
;	O
*	O
ep	*(int)
=	O
0	int
;	O
*	O
sp	*(int)
=	O
1	int
;	O
return	O
;	O
}	O
u	union(double,array(int))
.	O
f	float
=	O
f	float
;	O
m	int
=	O
u	union(double,array(int))
.	O
i	array(int)
;	O
if	O
(	O
ISNORMAL	O
(	O
f	float
)	O
)	O
{	O
*	O
ep	*(int)
=	O
(	O
(	O
m	int
&	O
0x7f800000	int
)	O
>>	O
23	int
)	O
-	O
126	int
-	O
24	int
;	O
*	O
mp	*(int)
=	O
(	O
m	int
&	O
0x007fffff	int
)	O
|	O
0x00800000	int
;	O
}	O
else	O
{	O
*	O
ep	*(int)
=	O
(	O
(	O
m	int
&	O
0x7f000000	int
)	O
>>	O
23	int
)	O
-	O
126	int
-	O
24	int
+	O
1	int
;	O
*	O
mp	*(int)
=	O
m	int
&	O
0x00ffffff	int
;	O
}	O
*	O
sp	*(int)
=	O
(	O
f	float
>	O
0.0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
}	O
static	O
int	O
double_exponent	(double)->(int)
(	O
double	O
d	double
)	O
{	O
union	O
{	O
double	O
d	double
;	O
int	O
i	array(int)
[	O
2	int
]	O
;	O
}	O
u	union(double,array(int))
;	O
if	O
(	O
d	double
==	O
0.0	int
)	O
return	O
(	O
0	int
)	O
;	O
u	union(double,array(int))
.	O
d	double
=	O
d	double
;	O
return	O
(	O
(	O
(	O
u	union(double,array(int))
.	O
i	array(int)
[	O
HIND	O
]	O
&	O
0x7ff00000	int
)	O
>>	O
20	int
)	O
-	O
1022	int
)	O
;	O
}	O
static	O
double	O
set_exponent	(double,int)->(double)
(	O
double	O
d	double
,	O
int	O
e	int
)	O
{	O
union	O
{	O
double	O
d	double
;	O
int	O
i	array(int)
[	O
2	int
]	O
;	O
}	O
u	union(double,array(int))
;	O
if	O
(	O
d	double
==	O
0.0	int
)	O
return	O
(	O
0.0	int
)	O
;	O
u	union(double,array(int))
.	O
d	double
=	O
d	double
;	O
u	union(double,array(int))
.	O
i	array(int)
[	O
HIND	O
]	O
=	O
(	O
u	union(double,array(int))
.	O
i	array(int)
[	O
HIND	O
]	O
&	O
0x800fffff	int
)	O
|	O
(	O
(	O
(	O
e	int
+	O
1022	int
)	O
<<	O
20	int
)	O
&	O
0x7ff00000	int
)	O
;	O
return	O
(	O
u	union(double,array(int))
.	O
d	double
)	O
;	O
}	O
object	O
double_to_integer	(double)->(int)
(	O
double	O
d	double
)	O
{	O
int	O
h	int
,	O
l	int
,	O
e	int
,	O
s	int
;	O
object	O
x	int
;	O
vs_mark	O
;	O
if	O
(	O
d	double
==	O
0.0	int
)	O
return	O
(	O
small_fixnum	()->(int)
(	O
0	int
)	O
)	O
;	O
integer_decode_double	(double,*(int),*(int),*(int),*(int))->(void)
(	O
d	double
,	O
&	O
h	int
,	O
&	O
l	int
,	O
&	O
e	int
,	O
&	O
s	int
)	O
;	O
if	O
(	O
e	int
<=	O
-	O
BIG_RADIX	O
)	O
{	O
e	int
=	O
(	O
-	O
e	int
)	O
-	O
BIG_RADIX	O
;	O
if	O
(	O
e	int
>=	O
BIG_RADIX	O
)	O
return	O
(	O
small_fixnum	()->(int)
(	O
0	int
)	O
)	O
;	O
h	int
>>=	O
e	int
;	O
return	O
(	O
make_fixnum	()->(int)
(	O
s	int
*	O
h	int
)	O
)	O
;	O
}	O
if	O
(	O
h	int
!=	O
0	int
||	O
l	int
<	O
0	int
)	O
x	int
=	O
bignum2	()->(int)
(	O
h	int
,	O
l	int
)	O
;	O
else	O
x	int
=	O
make_fixnum	()->(int)
(	O
l	int
)	O
;	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
x	int
=	O
integer_fix_shift	()->(int)
(	O
x	int
,	O
e	int
)	O
;	O
if	O
(	O
s	int
<	O
0	int
)	O
{	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
x	int
=	O
number_negate	()->(int)
(	O
x	int
)	O
;	O
}	O
vs_reset	O
;	O
return	O
(	O
x	int
)	O
;	O
}	O
static	O
object	O
num_remainder	(int,int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
,	O
object	O
q	int
)	O
{	O
object	O
z	int
;	O
z	int
=	O
number_times	()->(int)
(	O
q	int
,	O
y	int
)	O
;	O
vs_push	()->(int)
(	O
z	int
)	O
;	O
z	int
=	O
number_minus	()->(int)
(	O
x	int
,	O
z	int
)	O
;	O
vs_popp	O
;	O
return	O
(	O
z	int
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lfloat	int
)	O
(	O
void	O
)	O
{	O
double	O
d	double
;	O
int	O
narg	int
;	O
object	O
x	int
;	O
enum	O
type	O
t	enum
=	O
t_longfloat	O
;	O
narg	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	int
<	O
1	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
else	O
if	O
(	O
narg	int
>	O
2	int
)	O
too_many_arguments	()->(int)
(	O
)	O
;	O
if	O
(	O
narg	int
==	O
2	int
)	O
{	O
check_type_float	()->(int)
(	O
&	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
t	enum
=	O
type_of	()->(int)
(	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
}	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
if	O
(	O
narg	int
>	O
1	int
&&	O
t	enum
==	O
t_shortfloat	O
)	O
x	int
=	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
(	O
fix	()->(int)
(	O
x	int
)	O
)	O
)	O
;	O
else	O
x	int
=	O
make_longfloat	()->(int)
(	O
(	O
double	O
)	O
(	O
fix	()->(int)
(	O
x	int
)	O
)	O
)	O
;	O
break	O
;	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
d	double
=	O
number_to_double	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
narg	int
>	O
1	int
&&	O
t	enum
==	O
t_shortfloat	O
)	O
x	int
=	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
d	double
)	O
;	O
else	O
x	int
=	O
make_longfloat	()->(int)
(	O
d	double
)	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
if	O
(	O
narg	int
>	O
1	int
&&	O
t	enum
==	O
t_shortfloat	O
)	O
;	O
else	O
x	int
=	O
make_longfloat	()->(int)
(	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
)	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
if	O
(	O
narg	int
>	O
1	int
&&	O
t	enum
==	O
t_shortfloat	O
)	O
x	int
=	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
(	O
lf	()->(int)
(	O
x	int
)	O
)	O
)	O
;	O
break	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
TSor_rational_float	O
,	O
x	int
)	O
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lnumerator	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_rational	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
==	O
t_ratio	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
vs_base	O
[	O
0	int
]	O
->	O
rat	O
.	O
rat_num	O
;	O
}	O
LFD	(int)->(int)
(	O
Ldenominator	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_rational	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
==	O
t_ratio	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
vs_base	O
[	O
0	int
]	O
->	O
rat	O
.	O
rat_den	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
small_fixnum	()->(int)
(	O
1	int
)	O
;	O
}	O
inline	O
void	O
intdivrem	(int,int,int,*(int),*(int))->(void)
(	O
object	O
x	int
,	O
object	O
y	int
,	O
fixnum	O
d	double
,	O
object	O
*	O
q	int
,	O
object	O
*	O
r	*(int)
)	O
{	O
enum	O
type	O
tx	enum
=	O
type_of	()->(int)
(	O
x	int
)	O
,	O
ty	enum
=	O
type_of	()->(int)
(	O
y	int
)	O
;	O
object	O
z	int
,	O
q2	O
,	O
q1	O
;	O
if	O
(	O
number_zerop	()->(int)
(	O
y	int
)	O
==	O
TRUE	O
)	O
zero_divisor	()->(void)
(	O
)	O
;	O
switch	O
(	O
tx	enum
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
switch	O
(	O
ty	enum
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
integer_quotient_remainder_1	()->(int)
(	O
x	int
,	O
y	int
,	O
q	int
,	O
r	*(int)
,	O
d	double
)	O
;	O
return	O
;	O
case	O
t_ratio	O
:	O
z	int
=	O
integer_divide1	()->(int)
(	O
number_times	()->(int)
(	O
y	int
->	O
rat	O
.	O
rat_den	O
,	O
x	int
)	O
,	O
y	int
->	O
rat	O
.	O
rat_num	O
,	O
d	double
)	O
;	O
if	O
(	O
q	int
)	O
*	O
q	int
=	O
z	int
;	O
if	O
(	O
r	*(int)
)	O
*	O
r	*(int)
=	O
num_remainder	(int,int,int)->(int)
(	O
x	int
,	O
y	int
,	O
z	int
)	O
;	O
return	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
t_ratio	O
:	O
switch	O
(	O
ty	enum
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
z	int
=	O
integer_divide1	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
y	int
)	O
,	O
d	double
)	O
;	O
if	O
(	O
q	int
)	O
*	O
q	int
=	O
z	int
;	O
if	O
(	O
r	*(int)
)	O
*	O
r	*(int)
=	O
num_remainder	(int,int,int)->(int)
(	O
x	int
,	O
y	int
,	O
z	int
)	O
;	O
return	O
;	O
case	O
t_ratio	O
:	O
z	int
=	O
integer_divide1	()->(int)
(	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_num	O
,	O
y	int
->	O
rat	O
.	O
rat_den	O
)	O
,	O
number_times	()->(int)
(	O
x	int
->	O
rat	O
.	O
rat_den	O
,	O
y	int
->	O
rat	O
.	O
rat_num	O
)	O
,	O
d	double
)	O
;	O
if	O
(	O
q	int
)	O
*	O
q	int
=	O
z	int
;	O
if	O
(	O
r	*(int)
)	O
*	O
r	*(int)
=	O
num_remainder	(int,int,int)->(int)
(	O
x	int
,	O
y	int
,	O
z	int
)	O
;	O
return	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
q2	O
=	O
number_divide	()->(int)
(	O
x	int
,	O
y	int
)	O
;	O
q1	O
=	O
double_to_integer	(double)->(int)
(	O
number_to_double	()->(int)
(	O
q2	O
)	O
)	O
;	O
if	O
(	O
d	double
&&	O
(	O
d	double
<	O
0	int
?	O
number_minusp	()->(int)
(	O
q2	O
)	O
:	O
number_plusp	()->(int)
(	O
q2	O
)	O
)	O
&&	O
number_compare	()->(int)
(	O
q2	O
,	O
q1	O
)	O
)	O
q1	O
=	O
d	double
<	O
0	int
?	O
one_minus	()->(int)
(	O
q1	O
)	O
:	O
one_plus	()->(int)
(	O
q1	O
)	O
;	O
if	O
(	O
q	int
)	O
*	O
q	int
=	O
q1	O
;	O
if	O
(	O
r	*(int)
)	O
*	O
r	*(int)
=	O
num_remainder	(int,int,int)->(int)
(	O
x	int
,	O
y	int
,	O
q1	O
)	O
;	O
return	O
;	O
}	O
object	O
number_ldb	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
return	O
ifuncall2	()->(int)
(	O
sLldb	O
,	O
x	int
,	O
y	int
)	O
;	O
}	O
object	O
number_ldbt	(int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
return	O
ifuncall2	()->(int)
(	O
sLldb_test	O
,	O
x	int
,	O
y	int
)	O
;	O
}	O
object	O
number_dpb	(int,int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
,	O
object	O
z	int
)	O
{	O
return	O
ifuncall3	()->(int)
(	O
sLdpb	O
,	O
x	int
,	O
y	int
,	O
z	int
)	O
;	O
}	O
object	O
number_dpf	(int,int,int)->(int)
(	O
object	O
x	int
,	O
object	O
y	int
,	O
object	O
z	int
)	O
{	O
return	O
ifuncall3	()->(int)
(	O
sLdeposit_field	O
,	O
x	int
,	O
y	int
,	O
z	int
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lfloor	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
,	O
y	int
;	O
int	O
n	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
if	O
(	O
n	int
>	O
2	int
)	O
too_many_arguments	()->(int)
(	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
y	int
=	O
n	int
>	O
1	int
?	O
vs_base	O
[	O
1	int
]	O
:	O
small_fixnum	()->(int)
(	O
1	int
)	O
;	O
intdivrem	(int,int,int,*(int),*(int))->(void)
(	O
x	int
,	O
y	int
,	O
-	O
1	int
,	O
&	O
x	int
,	O
&	O
y	int
)	O
;	O
vs_top	O
=	O
vs_base	O
;	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
y	int
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lceiling	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
,	O
y	int
;	O
int	O
n	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
if	O
(	O
n	int
>	O
2	int
)	O
too_many_arguments	()->(int)
(	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
y	int
=	O
n	int
>	O
1	int
?	O
vs_base	O
[	O
1	int
]	O
:	O
small_fixnum	()->(int)
(	O
1	int
)	O
;	O
intdivrem	(int,int,int,*(int),*(int))->(void)
(	O
x	int
,	O
y	int
,	O
1	int
,	O
&	O
x	int
,	O
&	O
y	int
)	O
;	O
vs_top	O
=	O
vs_base	O
;	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
y	int
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Ltruncate	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
,	O
y	int
;	O
int	O
n	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
if	O
(	O
n	int
>	O
2	int
)	O
too_many_arguments	()->(int)
(	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
y	int
=	O
n	int
>	O
1	int
?	O
vs_base	O
[	O
1	int
]	O
:	O
small_fixnum	()->(int)
(	O
1	int
)	O
;	O
intdivrem	(int,int,int,*(int),*(int))->(void)
(	O
x	int
,	O
y	int
,	O
0	int
,	O
&	O
x	int
,	O
&	O
y	int
)	O
;	O
vs_top	O
=	O
vs_base	O
;	O
vs_push	()->(int)
(	O
x	int
)	O
;	O
vs_push	()->(int)
(	O
y	int
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lround	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
,	O
y	int
,	O
q	int
,	O
q1	O
,	O
r	*(int)
;	O
double	O
d	double
;	O
int	O
n	int
,	O
c	int
;	O
object	O
one_plus	()->(int)
(	O
object	O
x	int
)	O
,	O
one_minus	()->(int)
(	O
object	O
x	int
)	O
;	O
n	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
if	O
(	O
n	int
>	O
1	int
)	O
goto	O
TWO_ARG	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
vs_push	()->(int)
(	O
small_fixnum	()->(int)
(	O
0	int
)	O
)	O
;	O
return	O
;	O
case	O
t_ratio	O
:	O
q	int
=	O
x	int
;	O
y	int
=	O
small_fixnum	()->(int)
(	O
1	int
)	O
;	O
goto	O
RATIO	O
;	O
case	O
t_shortfloat	O
:	O
d	double
=	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
;	O
if	O
(	O
d	double
>=	O
0.0	int
)	O
q	int
=	O
double_to_integer	(double)->(int)
(	O
d	double
+	O
0.5	int
)	O
;	O
else	O
q	int
=	O
double_to_integer	(double)->(int)
(	O
d	double
-	O
0.5	int
)	O
;	O
d	double
-=	O
number_to_double	()->(int)
(	O
q	int
)	O
;	O
if	O
(	O
d	double
==	O
0.5	int
&&	O
number_oddp	()->(int)
(	O
q	int
)	O
)	O
{	O
vs_push	()->(int)
(	O
q	int
)	O
;	O
q	int
=	O
one_plus	()->(int)
(	O
q	int
)	O
;	O
d	double
=	O
-	O
0.5	int
;	O
}	O
if	O
(	O
d	double
==	O
-	O
0.5	int
&&	O
number_oddp	()->(int)
(	O
q	int
)	O
)	O
{	O
vs_push	()->(int)
(	O
q	int
)	O
;	O
q	int
=	O
one_minus	()->(int)
(	O
q	int
)	O
;	O
d	double
=	O
0.5	int
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
q	int
)	O
;	O
vs_push	()->(int)
(	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
d	double
)	O
)	O
;	O
return	O
;	O
case	O
t_longfloat	O
:	O
d	double
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
d	double
>=	O
0.0	int
)	O
q	int
=	O
double_to_integer	(double)->(int)
(	O
d	double
+	O
0.5	int
)	O
;	O
else	O
q	int
=	O
double_to_integer	(double)->(int)
(	O
d	double
-	O
0.5	int
)	O
;	O
d	double
-=	O
number_to_double	()->(int)
(	O
q	int
)	O
;	O
if	O
(	O
d	double
==	O
0.5	int
&&	O
number_oddp	()->(int)
(	O
q	int
)	O
)	O
{	O
vs_push	()->(int)
(	O
q	int
)	O
;	O
q	int
=	O
one_plus	()->(int)
(	O
q	int
)	O
;	O
d	double
=	O
-	O
0.5	int
;	O
}	O
if	O
(	O
d	double
==	O
-	O
0.5	int
&&	O
number_oddp	()->(int)
(	O
q	int
)	O
)	O
{	O
vs_push	()->(int)
(	O
q	int
)	O
;	O
q	int
=	O
one_minus	()->(int)
(	O
q	int
)	O
;	O
d	double
=	O
0.5	int
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
q	int
)	O
;	O
vs_push	()->(int)
(	O
make_longfloat	()->(int)
(	O
d	double
)	O
)	O
;	O
return	O
;	O
default	O
:	O
FEwrong_type_argument	()->(int)
(	O
TSor_rational_float	O
,	O
x	int
)	O
;	O
}	O
TWO_ARG	O
:	O
if	O
(	O
n	int
>	O
2	int
)	O
too_many_arguments	()->(int)
(	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
y	int
=	O
vs_base	O
[	O
1	int
]	O
;	O
check_type_or_rational_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
check_type_or_rational_float	()->(int)
(	O
&	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
q	int
=	O
number_divide	()->(int)
(	O
x	int
,	O
y	int
)	O
;	O
vs_push	()->(int)
(	O
q	int
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
q	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
q	int
)	O
;	O
vs_push	()->(int)
(	O
small_fixnum	()->(int)
(	O
0	int
)	O
)	O
;	O
break	O
;	O
case	O
t_ratio	O
:	O
RATIO	O
:	O
q1	O
=	O
integer_divide1	()->(int)
(	O
q	int
->	O
rat	O
.	O
rat_num	O
,	O
q	int
->	O
rat	O
.	O
rat_den	O
,	O
0	int
)	O
;	O
vs_push	()->(int)
(	O
q1	O
)	O
;	O
r	*(int)
=	O
number_minus	()->(int)
(	O
q	int
,	O
q1	O
)	O
;	O
vs_push	()->(int)
(	O
r	*(int)
)	O
;	O
if	O
(	O
(	O
c	int
=	O
number_compare	()->(int)
(	O
r	*(int)
,	O
plus_half	int
)	O
)	O
>	O
0	int
||	O
(	O
c	int
==	O
0	int
&&	O
number_oddp	()->(int)
(	O
q1	O
)	O
)	O
)	O
q1	O
=	O
one_plus	()->(int)
(	O
q1	O
)	O
;	O
if	O
(	O
(	O
c	int
=	O
number_compare	()->(int)
(	O
r	*(int)
,	O
minus_half	O
)	O
)	O
<	O
0	int
||	O
(	O
c	int
==	O
0	int
&&	O
number_oddp	()->(int)
(	O
q1	O
)	O
)	O
)	O
q1	O
=	O
one_minus	()->(int)
(	O
q1	O
)	O
;	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
q1	O
)	O
;	O
vs_push	()->(int)
(	O
num_remainder	(int,int,int)->(int)
(	O
x	int
,	O
y	int
,	O
q1	O
)	O
)	O
;	O
return	O
;	O
case	O
t_shortfloat	O
:	O
case	O
t_longfloat	O
:	O
d	double
=	O
number_to_double	()->(int)
(	O
q	int
)	O
;	O
if	O
(	O
d	double
>=	O
0.0	int
)	O
q1	O
=	O
double_to_integer	(double)->(int)
(	O
d	double
+	O
0.5	int
)	O
;	O
else	O
q1	O
=	O
double_to_integer	(double)->(int)
(	O
d	double
-	O
0.5	int
)	O
;	O
d	double
-=	O
number_to_double	()->(int)
(	O
q1	O
)	O
;	O
if	O
(	O
d	double
==	O
0.5	int
&&	O
number_oddp	()->(int)
(	O
q1	O
)	O
)	O
{	O
vs_push	()->(int)
(	O
q1	O
)	O
;	O
q1	O
=	O
one_plus	()->(int)
(	O
q1	O
)	O
;	O
}	O
if	O
(	O
d	double
==	O
-	O
0.5	int
&&	O
number_oddp	()->(int)
(	O
q1	O
)	O
)	O
{	O
vs_push	()->(int)
(	O
q1	O
)	O
;	O
q1	O
=	O
one_minus	()->(int)
(	O
q1	O
)	O
;	O
}	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
q1	O
)	O
;	O
vs_push	()->(int)
(	O
num_remainder	(int,int,int)->(int)
(	O
x	int
,	O
y	int
,	O
q1	O
)	O
)	O
;	O
return	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
LFD	(int)->(int)
(	O
Lmod	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
2	int
)	O
;	O
intdivrem	(int,int,int,*(int),*(int))->(void)
(	O
vs_base	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
1	int
]	O
,	O
-	O
1	int
,	O
NULL	O
,	O
vs_base	O
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
LFD	(int)->(int)
(	O
Lrem	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
2	int
)	O
;	O
intdivrem	(int,int,int,*(int),*(int))->(void)
(	O
vs_base	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
1	int
]	O
,	O
0	int
,	O
NULL	O
,	O
vs_base	O
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
LFD	(int)->(int)
(	O
Ldecode_float	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
;	O
double	O
d	double
;	O
int	O
e	int
,	O
s	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_shortfloat	O
)	O
d	double
=	O
sf	()->(int)
(	O
x	int
)	O
;	O
else	O
d	double
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
d	double
>=	O
0.0	int
)	O
s	int
=	O
1	int
;	O
else	O
{	O
d	double
=	O
-	O
d	double
;	O
s	int
=	O
-	O
1	int
;	O
}	O
e	int
=	O
0	int
;	O
if	O
(	O
!	O
ISNORMAL	O
(	O
d	double
)	O
)	O
{	O
int	O
hp	*(int)
,	O
lp	*(int)
,	O
sp	*(int)
;	O
integer_decode_double	(double,*(int),*(int),*(int),*(int))->(void)
(	O
d	double
,	O
&	O
hp	*(int)
,	O
&	O
lp	*(int)
,	O
&	O
e	int
,	O
&	O
sp	*(int)
)	O
;	O
if	O
(	O
hp	*(int)
!=	O
0	int
||	O
lp	*(int)
<	O
0	int
)	O
d	double
=	O
number_to_double	()->(int)
(	O
bignum2	()->(int)
(	O
hp	*(int)
,	O
lp	*(int)
)	O
)	O
;	O
else	O
d	double
=	O
lp	*(int)
;	O
}	O
e	int
+=	O
double_exponent	(double)->(int)
(	O
d	double
)	O
;	O
d	double
=	O
set_exponent	(double,int)->(double)
(	O
d	double
,	O
0	int
)	O
;	O
vs_top	O
=	O
vs_base	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_shortfloat	O
)	O
{	O
vs_push	()->(int)
(	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
d	double
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
e	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
s	int
)	O
)	O
;	O
}	O
else	O
{	O
vs_push	()->(int)
(	O
make_longfloat	()->(int)
(	O
d	double
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
e	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_longfloat	()->(int)
(	O
(	O
double	O
)	O
s	int
)	O
)	O
;	O
}	O
}	O
LFD	(int)->(int)
(	O
Lscale_float	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
;	O
double	O
d	double
;	O
int	O
e	int
,	O
k	int
=	O
0	int
;	O
check_arg	()->(int)
(	O
2	int
)	O
;	O
check_type_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
1	int
]	O
)	O
==	O
t_fixnum	O
)	O
k	int
=	O
fix	()->(int)
(	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
else	O
FEerror	()->(int)
(	O
"~S is an illegal exponent."	*(char)
,	O
1	int
,	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_shortfloat	O
)	O
d	double
=	O
sf	()->(int)
(	O
x	int
)	O
;	O
else	O
d	double
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
e	int
=	O
double_exponent	(double)->(int)
(	O
d	double
)	O
+	O
k	int
;	O
{	O
for	O
(	O
;	O
k	int
>	O
0	int
;	O
d	double
*=	O
2.0	int
,	O
k	int
--	O
)	O
;	O
for	O
(	O
;	O
k	int
<	O
0	int
;	O
d	double
*=	O
0.5	int
,	O
k	int
++	O
)	O
;	O
}	O
else	O
d	double
=	O
set_exponent	(double,int)->(double)
(	O
d	double
,	O
e	int
)	O
;	O
vs_popp	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_shortfloat	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
d	double
)	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
make_longfloat	()->(int)
(	O
d	double
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lfloat_radix	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lfloat_sign	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
;	O
int	O
narg	int
;	O
double	O
d	double
,	O
f	float
;	O
narg	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	int
<	O
1	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
else	O
if	O
(	O
narg	int
>	O
2	int
)	O
too_many_arguments	()->(int)
(	O
)	O
;	O
check_type_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_shortfloat	O
)	O
d	double
=	O
sf	()->(int)
(	O
x	int
)	O
;	O
else	O
d	double
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
narg	int
==	O
1	int
)	O
f	float
=	O
1.0	int
;	O
else	O
{	O
check_type_float	()->(int)
(	O
&	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
1	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_shortfloat	O
)	O
f	float
=	O
sf	()->(int)
(	O
x	int
)	O
;	O
else	O
f	float
=	O
lf	()->(int)
(	O
x	int
)	O
;	O
if	O
(	O
f	float
<	O
0.0	int
)	O
f	float
=	O
-	O
f	float
;	O
}	O
if	O
(	O
d	double
<	O
0.0	int
)	O
f	float
=	O
-	O
f	float
;	O
vs_top	O
=	O
vs_base	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_shortfloat	O
)	O
vs_push	()->(int)
(	O
make_shortfloat	()->(int)
(	O
(	O
shortfloat	O
)	O
f	float
)	O
)	O
;	O
else	O
vs_push	()->(int)
(	O
make_longfloat	()->(int)
(	O
f	float
)	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lfloat_digits	int
)	O
(	O
void	O
)	O
{	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
==	O
t_shortfloat	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
small_fixnum	()->(int)
(	O
24	int
)	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
small_fixnum	()->(int)
(	O
53	int
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lfloat_precision	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_shortfloat	O
)	O
if	O
(	O
sf	()->(int)
(	O
x	int
)	O
==	O
0.0	int
)	O
vs_base	O
[	O
0	int
]	O
=	O
small_fixnum	()->(int)
(	O
0	int
)	O
;	O
else	O
vs_base	O
[	O
0	int
]	O
=	O
small_fixnum	()->(int)
(	O
24	int
)	O
;	O
else	O
if	O
(	O
lf	()->(int)
(	O
x	int
)	O
==	O
0.0	int
)	O
vs_base	O
[	O
0	int
]	O
=	O
small_fixnum	()->(int)
(	O
0	int
)	O
;	O
else	O
}	O
LFD	(int)->(int)
(	O
Linteger_decode_float	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
;	O
int	O
h	int
,	O
l	int
,	O
e	int
,	O
s	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_base	O
=	O
vs_top	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_longfloat	O
)	O
{	O
integer_decode_double	(double,*(int),*(int),*(int),*(int))->(void)
(	O
lf	()->(int)
(	O
x	int
)	O
,	O
&	O
h	int
,	O
&	O
l	int
,	O
&	O
e	int
,	O
&	O
s	int
)	O
;	O
if	O
(	O
h	int
!=	O
0	int
||	O
l	int
<	O
0	int
)	O
vs_push	()->(int)
(	O
bignum2	()->(int)
(	O
h	int
,	O
l	int
)	O
)	O
;	O
else	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
l	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
e	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
s	int
)	O
)	O
;	O
}	O
else	O
{	O
integer_decode_float	(double,*(int),*(int),*(int))->(void)
(	O
(	O
double	O
)	O
(	O
sf	()->(int)
(	O
x	int
)	O
)	O
,	O
&	O
h	int
,	O
&	O
e	int
,	O
&	O
s	int
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
h	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
e	int
)	O
)	O
;	O
vs_push	()->(int)
(	O
make_fixnum	()->(int)
(	O
s	int
)	O
)	O
;	O
}	O
}	O
LFD	(int)->(int)
(	O
Lcomplex	int
)	O
(	O
void	O
)	O
{	O
object	O
r	*(int)
,	O
i	array(int)
;	O
int	O
narg	int
;	O
narg	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
narg	int
<	O
1	int
)	O
too_few_arguments	()->(int)
(	O
)	O
;	O
if	O
(	O
narg	int
>	O
2	int
)	O
too_many_arguments	()->(int)
(	O
)	O
;	O
check_type_or_rational_float	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
r	*(int)
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
narg	int
==	O
1	int
)	O
i	array(int)
=	O
small_fixnum	()->(int)
(	O
0	int
)	O
;	O
else	O
{	O
check_type_or_rational_float	()->(int)
(	O
&	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
i	array(int)
=	O
vs_base	O
[	O
1	int
]	O
;	O
}	O
vs_top	O
=	O
vs_base	O
;	O
vs_push	()->(int)
(	O
make_complex	()->(int)
(	O
r	*(int)
,	O
i	array(int)
)	O
)	O
;	O
}	O
LFD	(int)->(int)
(	O
Lrealpart	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
if	O
(	O
type_of	()->(int)
(	O
x	int
)	O
==	O
t_complex	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
x	int
->	O
cmp	O
.	O
cmp_real	O
;	O
}	O
LFD	(int)->(int)
(	O
Limagpart	int
)	O
(	O
void	O
)	O
{	O
object	O
x	int
;	O
check_arg	()->(int)
(	O
1	int
)	O
;	O
check_type_number	()->(int)
(	O
&	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
x	int
=	O
vs_base	O
[	O
0	int
]	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
x	int
)	O
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
small_fixnum	()->(int)
(	O
0	int
)	O
;	O
break	O
;	O
case	O
t_shortfloat	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
shortfloat_zero	O
;	O
break	O
;	O
case	O
t_longfloat	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
longfloat_zero	O
;	O
break	O
;	O
case	O
t_complex	O
:	O
vs_base	O
[	O
0	int
]	O
=	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
gcl_init_num_co	()->(void)
(	O
void	O
)	O
{	O
float	O
smallest_float	float
,	O
smallest_norm_float	float
,	O
biggest_float	float
;	O
double	O
smallest_double	double
,	O
smallest_norm_double	double
,	O
biggest_double	double
;	O
float	O
float_epsilon	float
,	O
float_negative_epsilon	float
;	O
double	O
double_epsilon	double
,	O
double_negative_epsilon	double
;	O
union	O
{	O
double	O
d	double
;	O
int	O
i	array(int)
[	O
2	int
]	O
;	O
}	O
u	union(double,array(int))
;	O
union	O
{	O
float	O
f	float
;	O
int	O
i	array(int)
;	O
}	O
uf	union(float,int)
;	O
{	O
volatile	O
double	O
rd	double
,	O
dd	double
,	O
td	double
,	O
td1	double
;	O
volatile	O
float	O
rf	float
,	O
df	float
,	O
tf	float
,	O
tf1	float
;	O
int	O
i	array(int)
,	O
j	int
;	O
for	O
(	O
rf	float
=	O
1.0f	int
,	O
df	float
=	O
0.5f	int
,	O
i	array(int)
=	O
j	int
=	O
0	int
;	O
i	array(int)
<	O
MAX	int
&&	O
j	int
<	O
MAX	int
&&	O
df	float
!=	O
1.0f	int
;	O
i	array(int)
++	O
,	O
df	float
=	O
1.0f	int
-	O
(	O
0.5f	int
*	O
(	O
1.0f	int
-	O
df	float
)	O
)	O
)	O
for	O
(	O
tf	float
=	O
rf	float
,	O
tf1	float
=	O
tf	float
+	O
1.0f	int
,	O
j	int
=	O
0	int
;	O
j	int
<	O
MAX	int
&&	O
tf1	float
!=	O
1.0f	int
;	O
j	int
++	O
,	O
rf	float
=	O
tf	float
,	O
tf	float
*=	O
df	float
,	O
tf1	float
=	O
tf	float
+	O
1.0f	int
)	O
;	O
if	O
(	O
i	array(int)
==	O
MAX	int
||	O
j	int
==	O
MAX	int
)	O
printf	O
(	O
"WARNING, cannot calculate float_epsilon: %d %d %f   %f %f %f\n"	*(char)
,	O
i	array(int)
,	O
j	int
,	O
rf	float
,	O
df	float
,	O
tf	float
,	O
tf1	float
)	O
;	O
float_epsilon	float
=	O
rf	float
;	O
for	O
(	O
rf	float
=	O
1.0f	int
,	O
df	float
=	O
0.5f	int
,	O
i	array(int)
=	O
j	int
=	O
0	int
;	O
i	array(int)
<	O
MAX	int
&&	O
j	int
<	O
MAX	int
&&	O
df	float
!=	O
1.0f	int
;	O
i	array(int)
++	O
,	O
df	float
=	O
1.0f	int
-	O
(	O
0.5f	int
*	O
(	O
1.0f	int
-	O
df	float
)	O
)	O
)	O
for	O
(	O
tf	float
=	O
rf	float
,	O
tf1	float
=	O
1.0f	int
-	O
tf	float
,	O
j	int
=	O
0	int
;	O
j	int
<	O
MAX	int
&&	O
tf1	float
!=	O
1.0f	int
;	O
j	int
++	O
,	O
rf	float
=	O
tf	float
,	O
tf	float
*=	O
df	float
,	O
tf1	float
=	O
1.0f	int
-	O
tf	float
)	O
;	O
if	O
(	O
i	array(int)
==	O
MAX	int
||	O
j	int
==	O
MAX	int
)	O
printf	O
(	O
"WARNING, cannot calculate float_negative_epsilon: %d %d %f   %f %f %f\n"	*(char)
,	O
i	array(int)
,	O
j	int
,	O
rf	float
,	O
df	float
,	O
tf	float
,	O
tf1	float
)	O
;	O
float_negative_epsilon	float
=	O
rf	float
;	O
for	O
(	O
rd	double
=	O
1.0	int
,	O
dd	double
=	O
0.5	int
,	O
i	array(int)
=	O
j	int
=	O
0	int
;	O
i	array(int)
<	O
MAX	int
&&	O
j	int
<	O
MAX	int
&&	O
dd	double
!=	O
1.0	int
;	O
i	array(int)
++	O
,	O
dd	double
=	O
1.0	int
-	O
(	O
0.5	int
*	O
(	O
1.0	int
-	O
dd	double
)	O
)	O
)	O
for	O
(	O
td	double
=	O
rd	double
,	O
td1	double
=	O
td	double
+	O
1.0	int
,	O
j	int
=	O
0	int
;	O
j	int
<	O
MAX	int
&&	O
td1	double
!=	O
1.0	int
;	O
j	int
++	O
,	O
rd	double
=	O
td	double
,	O
td	double
*=	O
dd	double
,	O
td1	double
=	O
td	double
+	O
1.0	int
)	O
;	O
if	O
(	O
i	array(int)
==	O
MAX	int
||	O
j	int
==	O
MAX	int
)	O
printf	O
(	O
"WARNING, cannot calculate double_epsilon: %d %d %f   %f %f %f\n"	*(char)
,	O
i	array(int)
,	O
j	int
,	O
rd	double
,	O
dd	double
,	O
td	double
,	O
td1	double
)	O
;	O
double_epsilon	double
=	O
rd	double
;	O
for	O
(	O
rd	double
=	O
1.0	int
,	O
dd	double
=	O
0.5	int
,	O
i	array(int)
=	O
j	int
=	O
0	int
;	O
i	array(int)
<	O
MAX	int
&&	O
j	int
<	O
MAX	int
&&	O
dd	double
!=	O
1.0	int
;	O
i	array(int)
++	O
,	O
dd	double
=	O
1.0	int
-	O
(	O
0.5	int
*	O
(	O
1.0	int
-	O
dd	double
)	O
)	O
)	O
for	O
(	O
td	double
=	O
rd	double
,	O
td1	double
=	O
1.0	int
-	O
td	double
,	O
j	int
=	O
0	int
;	O
j	int
<	O
MAX	int
&&	O
td1	double
!=	O
1.0	int
;	O
j	int
++	O
,	O
rd	double
=	O
td	double
,	O
td	double
*=	O
dd	double
,	O
td1	double
=	O
1.0	int
-	O
td	double
)	O
;	O
if	O
(	O
i	array(int)
==	O
MAX	int
||	O
j	int
==	O
MAX	int
)	O
printf	O
(	O
"WARNING, cannot calculate double_negative_epsilon: %d %d %f   %f %f %f\n"	*(char)
,	O
i	array(int)
,	O
j	int
,	O
rd	double
,	O
dd	double
,	O
td	double
,	O
td1	double
)	O
;	O
double_negative_epsilon	double
=	O
rd	double
;	O
}	O
make_constant	()->(int)
(	O
"MOST-POSITIVE-SHORT-FLOAT"	*(char)
,	O
make_shortfloat	()->(int)
(	O
biggest_float	float
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-POSITIVE-SHORT-FLOAT"	*(char)
,	O
make_shortfloat	()->(int)
(	O
smallest_float	float
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-NEGATIVE-SHORT-FLOAT"	*(char)
,	O
make_shortfloat	()->(int)
(	O
-	O
smallest_float	float
)	O
)	O
;	O
make_constant	()->(int)
(	O
"MOST-NEGATIVE-SHORT-FLOAT"	*(char)
,	O
make_shortfloat	()->(int)
(	O
-	O
biggest_float	float
)	O
)	O
;	O
make_constant	()->(int)
(	O
"MOST-POSITIVE-SINGLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
biggest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-POSITIVE-SINGLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
smallest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-NEGATIVE-SINGLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
-	O
smallest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"MOST-NEGATIVE-SINGLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
-	O
biggest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"MOST-POSITIVE-DOUBLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
biggest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-POSITIVE-DOUBLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
smallest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-NEGATIVE-DOUBLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
-	O
smallest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"MOST-NEGATIVE-DOUBLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
-	O
biggest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"MOST-POSITIVE-LONG-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
biggest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-POSITIVE-LONG-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
smallest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-NEGATIVE-LONG-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
-	O
smallest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"MOST-NEGATIVE-LONG-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
-	O
biggest_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"SHORT-FLOAT-EPSILON"	*(char)
,	O
make_shortfloat	()->(int)
(	O
float_epsilon	float
)	O
)	O
;	O
make_constant	()->(int)
(	O
"SINGLE-FLOAT-EPSILON"	*(char)
,	O
make_longfloat	()->(int)
(	O
double_epsilon	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"DOUBLE-FLOAT-EPSILON"	*(char)
,	O
make_longfloat	()->(int)
(	O
double_epsilon	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LONG-FLOAT-EPSILON"	*(char)
,	O
make_longfloat	()->(int)
(	O
double_epsilon	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"SHORT-FLOAT-NEGATIVE-EPSILON"	*(char)
,	O
make_shortfloat	()->(int)
(	O
float_negative_epsilon	float
)	O
)	O
;	O
make_constant	()->(int)
(	O
"SINGLE-FLOAT-NEGATIVE-EPSILON"	*(char)
,	O
make_longfloat	()->(int)
(	O
double_negative_epsilon	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"DOUBLE-FLOAT-NEGATIVE-EPSILON"	*(char)
,	O
make_longfloat	()->(int)
(	O
double_negative_epsilon	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LONG-FLOAT-NEGATIVE-EPSILON"	*(char)
,	O
make_longfloat	()->(int)
(	O
double_negative_epsilon	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-POSITIVE-NORMALIZED-SHORT-FLOAT"	*(char)
,	O
make_shortfloat	()->(int)
(	O
smallest_norm_float	float
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-NEGATIVE-NORMALIZED-SHORT-FLOAT"	*(char)
,	O
make_shortfloat	()->(int)
(	O
-	O
smallest_norm_float	float
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-POSITIVE-NORMALIZED-SINGLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
smallest_norm_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-NEGATIVE-NORMALIZED-SINGLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
-	O
smallest_norm_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-POSITIVE-NORMALIZED-DOUBLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
smallest_norm_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-NEGATIVE-NORMALIZED-DOUBLE-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
-	O
smallest_norm_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-POSITIVE-NORMALIZED-LONG-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
smallest_norm_double	double
)	O
)	O
;	O
make_constant	()->(int)
(	O
"LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT"	*(char)
,	O
make_longfloat	()->(int)
(	O
-	O
smallest_norm_double	double
)	O
)	O
;	O
plus_half	int
=	O
make_ratio	()->(int)
(	O
small_fixnum	()->(int)
(	O
1	int
)	O
,	O
small_fixnum	()->(int)
(	O
2	int
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
plus_half	int
)	O
;	O
minus_half	O
=	O
make_ratio	()->(int)
(	O
small_fixnum	()->(int)
(	O
-	O
1	int
)	O
,	O
small_fixnum	()->(int)
(	O
2	int
)	O
)	O
;	O
enter_mark_origin	()->(int)
(	O
&	O
minus_half	O
)	O
;	O
make_function	()->(int)
(	O
"FLOAT"	*(char)
,	O
Lfloat	int
)	O
;	O
make_function	()->(int)
(	O
"NUMERATOR"	*(char)
,	O
Lnumerator	int
)	O
;	O
make_function	()->(int)
(	O
"DENOMINATOR"	*(char)
,	O
Ldenominator	int
)	O
;	O
make_function	()->(int)
(	O
"FLOOR"	*(char)
,	O
Lfloor	int
)	O
;	O
make_function	()->(int)
(	O
"CEILING"	*(char)
,	O
Lceiling	int
)	O
;	O
make_function	()->(int)
(	O
"TRUNCATE"	*(char)
,	O
Ltruncate	int
)	O
;	O
make_function	()->(int)
(	O
"ROUND"	*(char)
,	O
Lround	int
)	O
;	O
make_function	()->(int)
(	O
"MOD"	*(char)
,	O
Lmod	int
)	O
;	O
make_function	()->(int)
(	O
"REM"	*(char)
,	O
Lrem	int
)	O
;	O
make_function	()->(int)
(	O
"DECODE-FLOAT"	*(char)
,	O
Ldecode_float	int
)	O
;	O
make_function	()->(int)
(	O
"SCALE-FLOAT"	*(char)
,	O
Lscale_float	int
)	O
;	O
make_function	()->(int)
(	O
"FLOAT-RADIX"	*(char)
,	O
Lfloat_radix	int
)	O
;	O
make_function	()->(int)
(	O
"FLOAT-SIGN"	*(char)
,	O
Lfloat_sign	int
)	O
;	O
make_function	()->(int)
(	O
"FLOAT-DIGITS"	*(char)
,	O
Lfloat_digits	int
)	O
;	O
make_function	()->(int)
(	O
"FLOAT-PRECISION"	*(char)
,	O
Lfloat_precision	int
)	O
;	O
make_function	()->(int)
(	O
"INTEGER-DECODE-FLOAT"	*(char)
,	O
Linteger_decode_float	int
)	O
;	O
make_function	()->(int)
(	O
"COMPLEX"	*(char)
,	O
Lcomplex	int
)	O
;	O
make_function	()->(int)
(	O
"REALPART"	*(char)
,	O
Lrealpart	int
)	O
;	O
make_function	()->(int)
(	O
"IMAGPART"	*(char)
,	O
Limagpart	int
)	O
;	O
}	O
