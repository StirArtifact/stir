char	O
*	O
skipws	(*(char))->(*(char))
(	O
char	O
*	O
buf	*(void)
)	O
{	O
while	O
(	O
*	O
buf	*(void)
&&	O
isascii	(int)->(int)
(	O
*	O
buf	*(void)
)	O
&&	O
isspace	(int)->(int)
(	O
*	O
buf	*(void)
)	O
)	O
buf	*(void)
++	O
;	O
return	O
buf	*(void)
;	O
}	O
int	O
hostcmp	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
a	*(struct)
,	O
const	O
char	O
*	O
b	*(struct)
)	O
{	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
hp	*(struct)
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
a	*(struct)
)	O
;	O
char	O
*	O
*	O
addrlist	*(*(char))
;	O
char	O
*	O
dptr	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
;	O
char	O
*	O
*	O
addr	*(*(char))
;	O
size_t	long
i	long
,	O
count	long
;	O
size_t	long
entry_length	long
;	O
int	O
entry_type	int
;	O
if	O
(	O
!	O
hp	*(struct)
)	O
return	O
1	int
;	O
for	O
(	O
count	long
=	O
1	int
,	O
addr	*(*(char))
=	O
hp	*(struct)
->	O
h_addr_list	*(*(char))
;	O
*	O
addr	*(*(char))
;	O
addr	*(*(char))
++	O
)	O
count	long
++	O
;	O
addrlist	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
count	long
*	O
(	O
sizeof	O
*	O
addrlist	*(*(char))
+	O
hp	*(struct)
->	O
h_length	int
)	O
-	O
hp	*(struct)
->	O
h_length	int
)	O
;	O
dptr	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
=	O
(	O
char	O
*	O
)	O
(	O
addrlist	*(*(char))
+	O
count	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
count	long
-	O
1	int
;	O
i	long
++	O
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dptr	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
,	O
hp	*(struct)
->	O
h_addr_list	*(*(char))
[	O
i	long
]	O
,	O
hp	*(struct)
->	O
h_length	int
)	O
;	O
addrlist	*(*(char))
[	O
i	long
]	O
=	O
dptr	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
;	O
dptr	*(struct(*(char),*((*(*`),*(struct`),*(char))->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(*`))->(int)),*((*(void),*(char),*(char),*(char))->(int))))
+=	O
hp	*(struct)
->	O
h_length	int
;	O
}	O
addrlist	*(*(char))
[	O
i	long
]	O
=	O
NULL	O
;	O
entry_length	long
=	O
hp	*(struct)
->	O
h_length	int
;	O
entry_type	int
=	O
hp	*(struct)
->	O
h_addrtype	int
;	O
hp	*(struct)
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
b	*(struct)
)	O
;	O
if	O
(	O
!	O
hp	*(struct)
||	O
entry_length	long
!=	O
hp	*(struct)
->	O
h_length	int
||	O
entry_type	int
!=	O
hp	*(struct)
->	O
h_addrtype	int
)	O
{	O
free	(*(void))->(void)
(	O
addrlist	*(*(char))
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
addr	*(*(char))
=	O
addrlist	*(*(char))
;	O
*	O
addr	*(*(char))
;	O
addr	*(*(char))
++	O
)	O
{	O
char	O
*	O
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
hp	*(struct)
->	O
h_addr_list	*(*(char))
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
{	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
*	O
addr	*(*(char))
,	O
*	O
p	*(void)
,	O
entry_length	long
)	O
==	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
addrlist	*(*(char))
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
free	(*(void))->(void)
(	O
addrlist	*(*(char))
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
begins_with	(*(char),*(char))->(int)
(	O
const	O
char	O
*	O
str	*(char)
,	O
const	O
char	O
*	O
prefix	array(*(char))
)	O
{	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
prefix	array(*(char))
)	O
;	O
return	O
strlen	(*(char))->(long)
(	O
str	*(char)
)	O
>=	O
len	long
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
str	*(char)
,	O
prefix	array(*(char))
,	O
len	long
)	O
==	O
0	int
&&	O
(	O
str	*(char)
[	O
len	long
]	O
==	O
0	int
||	O
str	*(char)
[	O
len	long
]	O
==	O
' '	O
||	O
str	*(char)
[	O
len	long
]	O
==	O
'\t'	O
)	O
;	O
}	O
enum	O
kw_tok	enum(int,int,int,int,int,int,int,int,int)
{	O
kw_login	int
,	O
kw_password	int
,	O
kw_noauth	int
,	O
kw_nosasl	int
,	O
kw_sasl	int
,	O
kw_mechanism	int
,	O
kw_realm	int
,	O
kw_service	int
,	O
kw_host	int
}	O
;	O
struct	O
keyword	struct(*(char),int,enum(int,int,int,int,int,int,int,int,int))
{	O
char	O
*	O
name	*(char)
;	O
int	O
arg	*(char)
;	O
enum	O
kw_tok	enum(int,int,int,int,int,int,int,int,int)
tok	enum(int,int,int,int,int,int,int,int,int)
;	O
}	O
;	O
static	O
struct	O
keyword	struct(*(char),int,enum(int,int,int,int,int,int,int,int,int))
kwtab	array(struct(*(char),int,enum(int,int,int,int,int,int,int,int,int)))
[	O
]	O
=	O
{	O
{	O
"login"	*(char)
,	O
1	int
,	O
kw_login	int
}	O
,	O
{	O
"password"	*(char)
,	O
1	int
,	O
kw_password	int
}	O
,	O
{	O
"noauth"	*(char)
,	O
0	int
,	O
kw_noauth	int
}	O
,	O
{	O
"nosasl"	*(char)
,	O
0	int
,	O
kw_nosasl	int
}	O
,	O
{	O
"sasl"	*(char)
,	O
0	int
,	O
kw_sasl	int
}	O
,	O
{	O
"mechanism"	*(char)
,	O
1	int
,	O
kw_mechanism	int
}	O
,	O
{	O
"realm"	*(char)
,	O
1	int
,	O
kw_realm	int
}	O
,	O
{	O
"service"	*(char)
,	O
1	int
,	O
kw_service	int
}	O
,	O
{	O
"host"	*(char)
,	O
1	int
,	O
kw_host	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
keyword	struct(*(char),int,enum(int,int,int,int,int,int,int,int,int))
*	O
findkw	(*(char))->(*(struct(*(char),int,enum(int,int,int,int,int,int,int,int,int))))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
struct	O
keyword	struct(*(char),int,enum(int,int,int,int,int,int,int,int,int))
*	O
p	*(void)
;	O
for	O
(	O
p	*(void)
=	O
kwtab	array(struct(*(char),int,enum(int,int,int,int,int,int,int,int,int)))
;	O
p	*(void)
->	O
name	*(char)
;	O
p	*(void)
++	O
)	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(void)
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
p	*(void)
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
_cred_free	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
item	*(void)
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
{	O
const	O
char	O
*	O
host	*(char)
;	O
int	O
def_line	int
;	O
int	O
def_argc	int
;	O
char	O
*	O
*	O
def_argv	*(*(char))
;	O
int	O
host_argc	int
;	O
char	O
*	O
*	O
host_argv	*(*(char))
;	O
}	O
;	O
static	O
int	O
match_line	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)),*(struct(*(char),int,int,*(*(char)),int,*(*(char)))),int)->(int)
(	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
*	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
,	O
struct	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
*	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
,	O
int	O
line	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
->	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"machine"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
hostcmp	(*(char),*(char))->(int)
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
->	O
ws_wordv	*(*(char))
[	O
1	int
]	O
,	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
host	*(char)
)	O
==	O
0	int
)	O
{	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
_	O
(	O
"Found matching line %d\n"	*(char)
)	O
,	O
line	int
)	O
;	O
if	O
(	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
host_argv	*(*(char))
)	O
dico_argcv_free	(int,*(*(char)))->(void)
(	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
host_argc	int
,	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
host_argv	*(*(char))
)	O
;	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
host_argc	int
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
->	O
ws_wordc	long
;	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
host_argv	*(*(char))
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
->	O
ws_wordv	*(*(char))
;	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
def_line	int
=	O
line	int
;	O
rc	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
->	O
ws_wordv	*(*(char))
[	O
0	int
]	O
,	O
"default"	*(char)
)	O
==	O
0	int
)	O
{	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
_	O
(	O
"Found default line %d\n"	*(char)
)	O
,	O
line	int
)	O
;	O
if	O
(	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
def_argv	*(*(char))
)	O
dico_argcv_free	(int,*(*(char)))->(void)
(	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
def_argc	int
,	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
def_argv	*(*(char))
)	O
;	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
def_argc	int
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
->	O
ws_wordc	long
;	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
def_argv	*(*(char))
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
->	O
ws_wordv	*(*(char))
;	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
->	O
def_line	int
=	O
line	int
;	O
}	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
->	O
ws_wordc	long
=	O
0	int
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
->	O
ws_wordv	*(*(char))
=	O
NULL	O
;	O
return	O
rc	int
;	O
}	O
int	O
parse_autologin	(*(char),*(char),*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))),*(int))->(int)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
char	O
*	O
host	*(char)
,	O
struct	O
auth_cred	struct(*(char),*(char),int,*(struct),*(char),*(char),*(char))
*	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
,	O
int	O
*	O
pflags	*(int)
)	O
{	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
buf	*(void)
=	O
NULL	O
;	O
size_t	long
n	long
=	O
0	int
;	O
struct	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
;	O
char	O
*	O
*	O
p_argv	*(*(char))
=	O
NULL	O
;	O
int	O
line	int
=	O
0	int
;	O
int	O
flags	int
=	O
0	int
;	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
;	O
int	O
wsflags	int
=	O
0	int
;	O
int	O
beg_line	int
=	O
0	int
;	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"Cannot open autologin file %s"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
}	O
return	O
1	int
;	O
}	O
else	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
_	O
(	O
"Reading autologin file %s...\n"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
,	O
0	int
,	O
sizeof	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
)	O
;	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
.	O
host	*(char)
=	O
host	*(char)
;	O
while	O
(	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
buf	*(void)
,	O
&	O
n	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
>	O
0	int
&&	O
n	long
>	O
0	int
)	O
{	O
char	O
*	O
p	*(void)
;	O
line	int
++	O
;	O
p	*(void)
=	O
skipws	(*(char))->(*(char))
(	O
buf	*(void)
)	O
;	O
if	O
(	O
(	O
wsflags	int
&	O
WRDSF_APPEND	int
)	O
&&	O
(	O
begins_with	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"machine"	*(char)
)	O
||	O
begins_with	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"default"	*(char)
)	O
)	O
)	O
{	O
wsflags	int
&=	O
~	O
WRDSF_APPEND	int
;	O
if	O
(	O
match_line	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)),*(struct(*(char),int,int,*(*(char)),int,*(*(char)))),int)->(int)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
,	O
&	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
,	O
beg_line	int
)	O
)	O
break	O
;	O
beg_line	int
=	O
line	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
wsflags	int
&	O
WRDSF_REUSE	int
)	O
)	O
beg_line	int
=	O
line	int
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
.	O
ws_comment	*(char)
=	O
"#"	*(char)
;	O
if	O
(	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
(	O
p	*(void)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
,	O
WRDSF_DEFFLAGS	O
|	O
WRDSF_COMMENT	int
|	O
wsflags	int
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"failed to parse command `%s': %s"	*(char)
)	O
,	O
p	*(void)
,	O
wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
if	O
(	O
wsflags	int
&	O
WRDSF_REUSE	int
)	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
)	O
;	O
return	O
1	int
;	O
}	O
wsflags	int
|=	O
WRDSF_REUSE	int
|	O
WRDSF_APPEND	int
;	O
if	O
(	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
(	O
"#"	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
,	O
WRDSF_DEFFLAGS	O
|	O
WRDSF_NOSPLIT	int
|	O
wsflags	int
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"failed to add line marker: %s"	*(char)
)	O
,	O
wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
)	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
if	O
(	O
wsflags	int
&	O
WRDSF_REUSE	int
)	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
wsflags	int
&	O
WRDSF_APPEND	int
)	O
match_line	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)),*(struct(*(char),int,int,*(*(char)),int,*(*(char)))),int)->(int)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
,	O
&	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
,	O
line	int
)	O
;	O
if	O
(	O
wsflags	int
&	O
WRDSF_REUSE	int
)	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(void)
)	O
;	O
if	O
(	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
.	O
host_argv	*(*(char))
)	O
p_argv	*(*(char))
=	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
.	O
host_argv	*(*(char))
+	O
2	int
;	O
else	O
if	O
(	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
.	O
def_argv	*(*(char))
)	O
p_argv	*(*(char))
=	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
.	O
def_argv	*(*(char))
+	O
1	int
;	O
else	O
{	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"No matching line found\n"	*(char)
)	O
)	O
;	O
p_argv	*(*(char))
=	O
NULL	O
;	O
}	O
if	O
(	O
p_argv	*(*(char))
)	O
{	O
line	int
=	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
.	O
def_line	int
;	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
sasl	int
=	O
sasl_enabled_p	()->(int)
(	O
)	O
;	O
while	O
(	O
*	O
p_argv	*(*(char))
)	O
{	O
if	O
(	O
*	O
*	O
p_argv	*(*(char))
==	O
'#'	O
)	O
{	O
line	int
++	O
;	O
p_argv	*(*(char))
++	O
;	O
}	O
else	O
{	O
struct	O
keyword	struct(*(char),int,enum(int,int,int,int,int,int,int,int,int))
*	O
kw	*(struct(*(char),int,enum(int,int,int,int,int,int,int,int,int)))
=	O
findkw	(*(char))->(*(struct(*(char),int,enum(int,int,int,int,int,int,int,int,int))))
(	O
*	O
p_argv	*(*(char))
)	O
;	O
char	O
*	O
arg	*(char)
;	O
if	O
(	O
!	O
kw	*(struct(*(char),int,enum(int,int,int,int,int,int,int,int,int)))
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s:%d: unknown keyword"	*(char)
)	O
,	O
filename	*(char)
,	O
line	int
)	O
;	O
p_argv	*(*(char))
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
kw	*(struct(*(char),int,enum(int,int,int,int,int,int,int,int,int)))
->	O
arg	*(char)
)	O
{	O
if	O
(	O
!	O
p_argv	*(*(char))
[	O
1	int
]	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s:%d: %s without argument"	*(char)
)	O
,	O
filename	*(char)
,	O
line	int
,	O
p_argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
arg	*(char)
=	O
p_argv	*(*(char))
[	O
1	int
]	O
;	O
p_argv	*(*(char))
+=	O
2	int
;	O
}	O
else	O
p_argv	*(*(char))
++	O
;	O
switch	O
(	O
kw	*(struct(*(char),int,enum(int,int,int,int,int,int,int,int,int)))
->	O
tok	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
kw_login	int
:	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
user	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
flags	int
|=	O
AUTOLOGIN_USERNAME	int
;	O
break	O
;	O
case	O
kw_password	int
:	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
pass	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
flags	int
|=	O
AUTOLOGIN_PASSWORD	int
;	O
break	O
;	O
case	O
kw_service	int
:	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
service	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
kw_realm	int
:	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
realm	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
kw_host	int
:	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
hostname	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
break	O
;	O
case	O
kw_noauth	int
:	O
flags	int
|=	O
AUTOLOGIN_NOAUTH	int
;	O
break	O
;	O
case	O
kw_nosasl	int
:	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
sasl	int
=	O
0	int
;	O
break	O
;	O
case	O
kw_sasl	int
:	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
sasl	int
=	O
1	int
;	O
break	O
;	O
case	O
kw_mechanism	int
:	O
{	O
int	O
i	long
;	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
mechws	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*`,long,long,int,int,long,long,*`,*`,array(*(char)),*`,*`,*`,*`,*`,long,long,*`,*`,*`,*`,long,long,int,*`,*`,*`,int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
AUTOLOGIN_MECH	int
)	O
)	O
{	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
mech	*(char)
=	O
xdico_list_create	()->(*(struct))
(	O
)	O
;	O
dico_list_set_free_item	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
mech	*(char)
,	O
_cred_free	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
flags	int
|=	O
AUTOLOGIN_MECH	int
;	O
}	O
mechws	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*`,long,long,int,int,long,long,*`,*`,array(*(char)),*`,*`,*`,*`,*`,long,long,*`,*`,*`,*`,long,long,int,*`,*`,*`,int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
.	O
ws_delim	*(char)
=	O
","	*(char)
;	O
if	O
(	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
(	O
arg	*(char)
,	O
&	O
mechws	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*`,long,long,int,int,long,long,*`,*`,array(*(char)),*`,*`,*`,*`,*`,long,long,*`,*`,*`,*`,long,long,int,*`,*`,*`,int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
,	O
WRDSF_NOVAR	int
|	O
WRDSF_NOCMD	int
|	O
WRDSF_DELIM	int
|	O
WRDSF_WS	int
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s:%d: failed to parse line: %s"	*(char)
)	O
,	O
filename	*(char)
,	O
line	int
,	O
wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(*(char))
(	O
&	O
mechws	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*`,long,long,int,int,long,long,*`,*`,array(*(char)),*`,*`,*`,*`,*`,long,long,*`,*`,*`,*`,long,long,int,*`,*`,*`,int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
mechws	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*`,long,long,int,int,long,long,*`,*`,array(*(char)),*`,*`,*`,*`,*`,long,long,*`,*`,*`,*`,long,long,int,*`,*`,*`,int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
xdico_list_append	(*(struct),*(void))->(void)
(	O
pcred	*(struct(*(char),*(char),int,*(struct),*(char),*(char),*(char)))
->	O
mech	*(char)
,	O
mechws	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*`,long,long,int,int,long,long,*`,*`,array(*(char)),*`,*`,*`,*`,*`,long,long,*`,*`,*`,*`,long,long,int,*`,*`,*`,int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
.	O
ws_wordv	*(*(char))
[	O
i	long
]	O
)	O
;	O
mechws	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*`,long,long,int,int,long,long,*`,*`,array(*(char)),*`,*`,*`,*`,*`,long,long,*`,*`,*`,*`,long,long,int,*`,*`,*`,int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
.	O
ws_wordc	long
=	O
0	int
;	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(void)
(	O
&	O
mechws	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*`,long,long,int,int,long,long,*`,*`,array(*(char)),*`,*`,*`,*`,*`,long,long,*`,*`,*`,*`,long,long,int,*`,*`,*`,int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
)	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
dico_argcv_free	(int,*(*(char)))->(void)
(	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
.	O
def_argc	int
,	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
.	O
def_argv	*(*(char))
)	O
;	O
dico_argcv_free	(int,*(*(char)))->(void)
(	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
.	O
host_argc	int
,	O
matches	struct(*(char),int,int,*(*(char)),int,*(*(char)))
.	O
host_argv	*(*(char))
)	O
;	O
if	O
(	O
pflags	*(int)
)	O
*	O
pflags	*(int)
=	O
flags	int
;	O
return	O
0	int
;	O
}	O
