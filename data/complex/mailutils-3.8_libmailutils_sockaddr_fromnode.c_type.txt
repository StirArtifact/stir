static	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
match_sa	(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int)->(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
(	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
,	O
struct	O
sockaddr	struct(short,array(char))
*	O
sa	*(struct(short,array(char)))
,	O
socklen_t	int
len	int
)	O
{	O
for	O
(	O
;	O
list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
;	O
list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
=	O
list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
)	O
if	O
(	O
len	int
==	O
list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
->	O
addrlen	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
->	O
addr	*(struct(short,array(char)))
,	O
sa	*(struct(short,array(char)))
,	O
len	int
)	O
==	O
0	int
)	O
break	O
;	O
return	O
list	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
;	O
}	O
int	O
mu_sockaddr_from_node	(*(*(struct(*(struct`),*(struct`),*(struct`),int,*(char)))),*(char),*(char),*(struct(int,int,int,int,short)))->(int)
(	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
*	O
retval	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
,	O
const	O
char	O
*	O
node	*(char)
,	O
const	O
char	O
*	O
serv	*(char)
,	O
struct	O
mu_sockaddr_hints	struct(int,int,int,int,short)
*	O
mh	*(struct(int,int,int,int,short))
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
!	O
mh	*(struct(int,int,int,int,short))
)	O
{	O
static	O
struct	O
mu_sockaddr_hints	struct(int,int,int,int,short)
nullhints	struct(int,int,int,int,short)
=	O
{	O
0	int
,	O
AF_UNSPEC	O
}	O
;	O
mh	*(struct(int,int,int,int,short))
=	O
&	O
nullhints	struct(int,int,int,int,short)
;	O
}	O
if	O
(	O
mh	*(struct(int,int,int,int,short))
->	O
family	int
==	O
AF_UNIX	O
)	O
{	O
size_t	long
slen	long
;	O
struct	O
sockaddr_un	struct(short,array(char))
s_un	struct(short,array(char))
;	O
if	O
(	O
!	O
node	*(char)
)	O
return	O
MU_ERR_NONAME	O
;	O
slen	long
=	O
strlen	(*(char))->(long)
(	O
node	*(char)
)	O
;	O
if	O
(	O
slen	long
>=	O
sizeof	O
s_un	struct(short,array(char))
.	O
sun_path	array(char)
)	O
return	O
MU_ERR_BUFSPACE	O
;	O
s_un	struct(short,array(char))
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
s_un	struct(short,array(char))
.	O
sun_path	array(char)
,	O
node	*(char)
)	O
;	O
return	O
mu_sockaddr_create	(*(*(struct(*(struct`),*(struct`),*(struct`),int,*(char)))),*(struct(short,array(char))),int)->(int)
(	O
retval	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
&	O
s_un	struct(short,array(char))
,	O
sizeof	O
(	O
s_un	struct(short,array(char))
)	O
)	O
;	O
}	O
else	O
{	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
hints	*(struct(int,int,int,int,short))
;	O
struct	O
addrinfo	struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`))))))
*	O
res	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
,	O
*	O
ap	array(struct(int,int,*(void),*(void)))
;	O
char	O
portbuf	array(char)
[	O
64	int
]	O
;	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
tail	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
=	O
NULL	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
hints	*(struct(int,int,int,int,short))
,	O
0	int
,	O
sizeof	O
(	O
hints	*(struct(int,int,int,int,short))
)	O
)	O
;	O
hints	*(struct(int,int,int,int,short))
.	O
ai_family	int
=	O
mh	*(struct(int,int,int,int,short))
->	O
family	int
;	O
hints	*(struct(int,int,int,int,short))
.	O
ai_socktype	int
=	O
mh	*(struct(int,int,int,int,short))
->	O
socktype	int
;	O
hints	*(struct(int,int,int,int,short))
.	O
ai_protocol	int
=	O
mh	*(struct(int,int,int,int,short))
->	O
protocol	int
;	O
if	O
(	O
!	O
node	*(char)
)	O
{	O
if	O
(	O
mh	*(struct(int,int,int,int,short))
->	O
flags	int
&	O
MU_AH_PASSIVE	int
)	O
hints	*(struct(int,int,int,int,short))
.	O
ai_flags	int
|=	O
AI_PASSIVE	int
;	O
else	O
return	O
MU_ERR_NONAME	O
;	O
}	O
if	O
(	O
!	O
serv	*(char)
&&	O
mh	*(struct(int,int,int,int,short))
->	O
port	short
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
portbuf	array(char)
,	O
sizeof	O
portbuf	array(char)
,	O
"%hu"	*(char)
,	O
mh	*(struct(int,int,int,int,short))
->	O
port	short
)	O
;	O
serv	*(char)
=	O
portbuf	array(char)
;	O
}	O
rc	int
=	O
getaddrinfo	(*(char),*(char),*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))),*(*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))->(int)
(	O
node	*(char)
,	O
serv	*(char)
,	O
&	O
hints	*(struct(int,int,int,int,short))
,	O
&	O
res	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
EAI_FAIL	O
:	O
return	O
MU_ERR_GETHOSTBYNAME	O
;	O
case	O
EAI_FAMILY	O
:	O
return	O
MU_ERR_FAMILY	O
;	O
case	O
EAI_NONAME	O
:	O
return	O
MU_ERR_NONAME	O
;	O
case	O
EAI_SERVICE	O
:	O
return	O
MU_ERR_SERVICE	O
;	O
case	O
EAI_SYSTEM	O
:	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s:%s: cannot parse address: %s"	*(char)
)	O
,	O
node	*(char)
,	O
serv	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
errno	O
;	O
case	O
EAI_BADFLAGS	O
:	O
return	O
MU_ERR_BADFLAGS	O
;	O
case	O
EAI_SOCKTYPE	O
:	O
return	O
MU_ERR_SOCKTYPE	O
;	O
case	O
EAI_MEMORY	O
:	O
return	O
ENOMEM	int
;	O
default	O
:	O
mu_error	(*(char))->(int)
(	O
"%s:%s: %s"	*(char)
,	O
node	*(char)
,	O
serv	*(char)
,	O
gai_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
MU_ERR_FAILURE	O
;	O
}	O
*	O
retval	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
=	O
NULL	O
;	O
for	O
(	O
ap	array(struct(int,int,*(void),*(void)))
=	O
res	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
;	O
ap	array(struct(int,int,*(void),*(void)))
;	O
ap	array(struct(int,int,*(void),*(void)))
=	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_next	*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*(struct`),*(char),*(struct`)))))
)	O
if	O
(	O
mh	*(struct(int,int,int,int,short))
->	O
family	int
==	O
AF_UNSPEC	O
||	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_addr	*(struct(short,array(char)))
->	O
sa_family	short
==	O
mh	*(struct(int,int,int,int,short))
->	O
family	int
)	O
{	O
struct	O
mu_sockaddr	struct(*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int,*(char))
*	O
sa	*(struct(short,array(char)))
;	O
if	O
(	O
match_sa	(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))),*(struct(short,array(char))),int)->(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
(	O
*	O
retval	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
,	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_addr	*(struct(short,array(char)))
,	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_addrlen	int
)	O
)	O
continue	O
;	O
rc	int
=	O
mu_sockaddr_create	(*(*(struct(*(struct`),*(struct`),*(struct`),int,*(char)))),*(struct(short,array(char))),int)->(int)
(	O
&	O
sa	*(struct(short,array(char)))
,	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_addr	*(struct(short,array(char)))
,	O
ap	array(struct(int,int,*(void),*(void)))
->	O
ai_addrlen	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sockaddr_free_list	(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))->(void)
(	O
*	O
retval	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
)	O
;	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
res	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
tail	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
)	O
mu_sockaddr_insert	(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))),*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))),int)->(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
(	O
tail	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
,	O
sa	*(struct(short,array(char)))
,	O
0	int
)	O
;	O
else	O
*	O
retval	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
=	O
sa	*(struct(short,array(char)))
;	O
tail	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(*(struct`),*(struct`),*(struct`),int,*(char))),*(struct(short,array(char))),int,*(char)))
=	O
sa	*(struct(short,array(char)))
;	O
}	O
freeaddrinfo	(*(struct(int,int,int,int,int,*(struct(short,array(char))),*(char),*(struct(int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
res	*(*(struct(*(struct(*`,*`,*`,int,*`)),*(struct(*`,*`,*`,int,*`)),*(struct(short,array(char))),int,*(char))))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
