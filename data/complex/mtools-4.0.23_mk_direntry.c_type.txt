static	O
__inline__	O
int	O
convert_to_shortname	(*(struct),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),*(char),*(struct(array(char),array(char),char)))->(int)
(	O
doscp_t	struct
*	O
cp	*(struct)
,	O
ClashHandling_t	struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*(struct),*(char),int,*(int),*(struct))->(void)),int)
*	O
ch	char
,	O
const	O
char	O
*	O
un	*(char)
,	O
dos_name_t	struct
*	O
dn	*(struct)
)	O
{	O
int	O
mangled	*(int)
;	O
ch	char
->	O
name_converter	*((*(struct),*(char),int,*(int),*(struct))->(void))
(	O
cp	*(struct)
,	O
un	*(char)
,	O
0	int
,	O
&	O
mangled	*(int)
,	O
dn	*(struct)
)	O
;	O
dn	*(struct)
->	O
sentinel	char
=	O
'\0'	O
;	O
if	O
(	O
dn	*(struct)
->	O
base	int
[	O
0	int
]	O
==	O
'\xE5'	O
)	O
dn	*(struct)
->	O
base	int
[	O
0	int
]	O
=	O
'\x05'	O
;	O
return	O
mangled	*(int)
;	O
}	O
static	O
__inline__	O
void	O
chomp	(*(char))->(void)
(	O
char	O
*	O
line	*(char)
)	O
{	O
int	O
l	int
=	O
strlen	(*(char))->(long)
(	O
line	*(char)
)	O
;	O
while	O
(	O
l	int
>	O
0	int
&&	O
(	O
line	*(char)
[	O
l	int
-	O
1	int
]	O
==	O
'\n'	O
||	O
line	*(char)
[	O
l	int
-	O
1	int
]	O
==	O
'\r'	O
)	O
)	O
{	O
line	*(char)
[	O
--	O
l	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
static	O
__inline__	O
int	O
ask_rename	(*(struct),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),*(struct(array(char),array(char),char)),*(char),int)->(int)
(	O
doscp_t	struct
*	O
cp	*(struct)
,	O
ClashHandling_t	struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*(struct),*(char),int,*(int),*(struct))->(void)),int)
*	O
ch	char
,	O
dos_name_t	struct
*	O
shortname	*(char)
,	O
char	O
*	O
longname	*(char)
,	O
int	O
isprimary	int
)	O
{	O
int	O
mangled	*(int)
;	O
if	O
(	O
!	O
opentty	(int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
0	int
)	O
)	O
return	O
0	int
;	O
mangled	*(int)
=	O
0	int
;	O
do	O
{	O
char	O
tname	array(char)
[	O
4	int
*	O
MAX_VNAMELEN	O
+	O
1	int
]	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"New %s name for \"%s\": "	*(char)
,	O
isprimary	int
?	O
"primary"	*(char)
:	O
"secondary"	*(char)
,	O
longname	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
tname	array(char)
,	O
4	int
*	O
MAX_VNAMELEN	O
+	O
1	int
,	O
opentty	(int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
0	int
)	O
)	O
)	O
return	O
0	int
;	O
chomp	(*(char))->(void)
(	O
tname	array(char)
)	O
;	O
if	O
(	O
isprimary	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
longname	*(char)
,	O
tname	array(char)
)	O
;	O
else	O
mangled	*(int)
=	O
convert_to_shortname	(*(struct),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),*(char),*(struct(array(char),array(char),char)))->(int)
(	O
cp	*(struct)
,	O
ch	char
,	O
tname	array(char)
,	O
shortname	*(char)
)	O
;	O
}	O
while	O
(	O
mangled	*(int)
&	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
__inline__	O
clash_action	enum(int,int,int,int,int,int,int,int,int,int)
ask_namematch	(*(struct),*(struct(array(char),array(char),char)),*(char),int,*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),int,int)->(enum(int,int,int,int,int,int,int,int,int,int))
(	O
doscp_t	struct
*	O
cp	*(struct)
,	O
dos_name_t	struct
*	O
dosname	*(struct)
,	O
char	O
*	O
longname	*(char)
,	O
int	O
isprimary	int
,	O
ClashHandling_t	struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*(struct),*(char),int,*(int),*(struct))->(void)),int)
*	O
ch	char
,	O
int	O
no_overwrite	int
,	O
int	O
reason	int
)	O
{	O
char	O
ans	*(char)
[	O
10	int
]	O
;	O
clash_action	enum(int,int,int,int,int,int,int,int,int,int)
a	enum(int,int,int,int,int,int,int,int,int,int)
;	O
int	O
perm	int
;	O
char	O
name_buffer	array(char)
[	O
4	int
*	O
13	int
]	O
;	O
char	O
*	O
name	*(char)
;	O
static	O
const	O
char	O
*	O
reasons	array(*(char))
[	O
]	O
=	O
{	O
"already exists"	*(char)
,	O
"is reserved"	*(char)
,	O
"contains illegal character(s)"	*(char)
}	O
;	O
a	enum(int,int,int,int,int,int,int,int,int,int)
=	O
ch	char
->	O
action	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
isprimary	int
]	O
;	O
if	O
(	O
a	enum(int,int,int,int,int,int,int,int,int,int)
==	O
NAMEMATCH_NONE	int
&&	O
!	O
opentty	(int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
1	int
)	O
)	O
{	O
return	O
NAMEMATCH_SKIP	int
;	O
}	O
if	O
(	O
!	O
isprimary	int
)	O
name	*(char)
=	O
unix_normalize	(*(struct),*(char),*(struct),long)->(*(char))
(	O
cp	*(struct)
,	O
name_buffer	array(char)
,	O
dosname	*(struct)
,	O
sizeof	O
(	O
*	O
dosname	*(struct)
)	O
)	O
;	O
else	O
name	*(char)
=	O
longname	*(char)
;	O
perm	int
=	O
0	int
;	O
while	O
(	O
a	enum(int,int,int,int,int,int,int,int,int,int)
==	O
NAMEMATCH_NONE	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s file name \"%s\" %s.\n"	*(char)
,	O
isprimary	int
?	O
"Long"	*(char)
:	O
"Short"	*(char)
,	O
name	*(char)
,	O
reasons	array(*(char))
[	O
reason	int
]	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"a)utorename A)utorename-all r)ename R)ename-all "	*(char)
)	O
;	O
if	O
(	O
!	O
no_overwrite	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"o)verwrite O)verwrite-all"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\ns)kip S)kip-all q)uit (aArR"	*(char)
)	O
;	O
if	O
(	O
!	O
no_overwrite	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"oO"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"sSq): "	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
opentty	(int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
1	int
)	O
)	O
;	O
if	O
(	O
mtools_raw_tty	int
)	O
{	O
int	O
rep	int
;	O
rep	int
=	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
opentty	(int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
1	int
)	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
rep	int
==	O
EOF	O
)	O
ans	*(char)
[	O
0	int
]	O
=	O
'q'	O
;	O
else	O
ans	*(char)
[	O
0	int
]	O
=	O
rep	int
;	O
}	O
else	O
{	O
if	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
ans	*(char)
,	O
9	int
,	O
opentty	(int)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
0	int
)	O
)	O
==	O
NULL	O
)	O
ans	*(char)
[	O
0	int
]	O
=	O
'q'	O
;	O
}	O
perm	int
=	O
isupper	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
ans	*(char)
[	O
0	int
]	O
)	O
;	O
switch	O
(	O
tolower	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
ans	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
case	O
'a'	O
:	O
a	enum(int,int,int,int,int,int,int,int,int,int)
=	O
NAMEMATCH_AUTORENAME	int
;	O
break	O
;	O
case	O
'r'	O
:	O
if	O
(	O
isprimary	int
)	O
a	enum(int,int,int,int,int,int,int,int,int,int)
=	O
NAMEMATCH_PRENAME	int
;	O
else	O
a	enum(int,int,int,int,int,int,int,int,int,int)
=	O
NAMEMATCH_RENAME	int
;	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
no_overwrite	int
)	O
continue	O
;	O
a	enum(int,int,int,int,int,int,int,int,int,int)
=	O
NAMEMATCH_OVERWRITE	int
;	O
break	O
;	O
case	O
's'	O
:	O
a	enum(int,int,int,int,int,int,int,int,int,int)
=	O
NAMEMATCH_SKIP	int
;	O
break	O
;	O
case	O
'q'	O
:	O
perm	int
=	O
0	int
;	O
a	enum(int,int,int,int,int,int,int,int,int,int)
=	O
NAMEMATCH_QUIT	int
;	O
break	O
;	O
default	O
:	O
perm	int
=	O
0	int
;	O
}	O
}	O
ch	char
->	O
action	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
isprimary	int
]	O
=	O
a	enum(int,int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
perm	int
)	O
ch	char
->	O
namematch_default	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
isprimary	int
]	O
=	O
a	enum(int,int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
a	enum(int,int,int,int,int,int,int,int,int,int)
==	O
NAMEMATCH_OVERWRITE	int
)	O
ch	char
->	O
action	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
isprimary	int
]	O
=	O
NAMEMATCH_NONE	int
;	O
return	O
a	enum(int,int,int,int,int,int,int,int,int,int)
;	O
}	O
static	O
__inline__	O
clash_action	enum(int,int,int,int,int,int,int,int,int,int)
process_namematch	(*(struct),*(struct(array(char),array(char),char)),*(char),int,*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),int,int)->(enum(int,int,int,int,int,int,int,int,int,int))
(	O
doscp_t	struct
*	O
cp	*(struct)
,	O
dos_name_t	struct
*	O
dosname	*(struct)
,	O
char	O
*	O
longname	*(char)
,	O
int	O
isprimary	int
,	O
ClashHandling_t	struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*(struct),*(char),int,*(int),*(struct))->(void)),int)
*	O
ch	char
,	O
int	O
no_overwrite	int
,	O
int	O
reason	int
)	O
{	O
clash_action	enum(int,int,int,int,int,int,int,int,int,int)
action	array(enum(int,int,int,int,int,int,int,int,int,int))
;	O
action	array(enum(int,int,int,int,int,int,int,int,int,int))
=	O
ask_namematch	(*(struct),*(struct(array(char),array(char),char)),*(char),int,*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),int,int)->(enum(int,int,int,int,int,int,int,int,int,int))
(	O
cp	*(struct)
,	O
dosname	*(struct)
,	O
longname	*(char)
,	O
isprimary	int
,	O
ch	char
,	O
no_overwrite	int
,	O
reason	int
)	O
;	O
switch	O
(	O
action	array(enum(int,int,int,int,int,int,int,int,int,int))
)	O
{	O
case	O
NAMEMATCH_QUIT	int
:	O
got_signal	int
=	O
1	int
;	O
return	O
NAMEMATCH_SKIP	int
;	O
case	O
NAMEMATCH_SKIP	int
:	O
return	O
NAMEMATCH_SKIP	int
;	O
case	O
NAMEMATCH_RENAME	int
:	O
case	O
NAMEMATCH_PRENAME	int
:	O
ask_rename	(*(struct),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),*(struct(array(char),array(char),char)),*(char),int)->(int)
(	O
cp	*(struct)
,	O
ch	char
,	O
dosname	*(struct)
,	O
longname	*(char)
,	O
isprimary	int
)	O
;	O
return	O
action	array(enum(int,int,int,int,int,int,int,int,int,int))
;	O
case	O
NAMEMATCH_AUTORENAME	int
:	O
if	O
(	O
isprimary	int
)	O
{	O
autorename_long	(*(char),int)->(void)
(	O
longname	*(char)
,	O
1	int
)	O
;	O
return	O
NAMEMATCH_PRENAME	int
;	O
}	O
else	O
{	O
autorename_short	(*(struct),int)->(void)
(	O
dosname	*(struct)
,	O
1	int
)	O
;	O
return	O
NAMEMATCH_RENAME	int
;	O
}	O
case	O
NAMEMATCH_OVERWRITE	int
:	O
if	O
(	O
no_overwrite	int
)	O
return	O
NAMEMATCH_SKIP	int
;	O
else	O
return	O
NAMEMATCH_OVERWRITE	int
;	O
default	O
:	O
return	O
NAMEMATCH_NONE	int
;	O
}	O
}	O
static	O
int	O
contains_illegals	(*(char),*(char),int)->(int)
(	O
const	O
char	O
*	O
string	*(char)
,	O
const	O
char	O
*	O
illegals	*(char)
,	O
int	O
len	long
)	O
{	O
for	O
(	O
;	O
*	O
string	*(char)
&&	O
len	long
--	O
;	O
string	*(char)
++	O
)	O
if	O
(	O
(	O
*	O
string	*(char)
<	O
' '	O
&&	O
*	O
string	*(char)
!=	O
'\005'	O
&&	O
!	O
(	O
*	O
string	*(char)
&	O
0x80	int
)	O
)	O
||	O
strchr	(*(char),int)->(*(char))
(	O
illegals	*(char)
,	O
*	O
string	*(char)
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
is_reserved	(*(char),int)->(int)
(	O
char	O
*	O
ans	*(char)
,	O
int	O
islong	int
)	O
{	O
unsigned	O
int	O
i	int
;	O
static	O
const	O
char	O
*	O
dev3	array(*(char))
[	O
]	O
=	O
{	O
"CON"	*(char)
,	O
"AUX"	*(char)
,	O
"PRN"	*(char)
,	O
"NUL"	*(char)
,	O
"   "	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
dev4	array(*(char))
[	O
]	O
=	O
{	O
"COM"	*(char)
,	O
"LPT"	*(char)
}	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
dev3	array(*(char))
)	O
/	O
sizeof	O
(	O
*	O
dev3	array(*(char))
)	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ans	*(char)
,	O
dev3	array(*(char))
[	O
i	int
]	O
,	O
3	int
)	O
&&	O
(	O
(	O
islong	int
&&	O
!	O
ans	*(char)
[	O
3	int
]	O
)	O
||	O
(	O
!	O
islong	int
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
ans	*(char)
+	O
3	int
,	O
"     "	*(char)
,	O
5	int
)	O
)	O
)	O
)	O
return	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
dev4	array(*(char))
)	O
/	O
sizeof	O
(	O
*	O
dev4	array(*(char))
)	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
strncasecmp	(*(char),*(char),long)->(int)
(	O
ans	*(char)
,	O
dev4	array(*(char))
[	O
i	int
]	O
,	O
3	int
)	O
&&	O
(	O
ans	*(char)
[	O
3	int
]	O
>=	O
'1'	O
&&	O
ans	*(char)
[	O
3	int
]	O
<=	O
'4'	O
)	O
&&	O
(	O
(	O
islong	int
&&	O
!	O
ans	*(char)
[	O
4	int
]	O
)	O
||	O
(	O
!	O
islong	int
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
ans	*(char)
+	O
4	int
,	O
"    "	*(char)
,	O
4	int
)	O
)	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
__inline__	O
clash_action	enum(int,int,int,int,int,int,int,int,int,int)
get_slots	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(struct(array(char),array(char),char)),*(char),*(struct(int,int,int,int,int,int,int,int,int)),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)))->(enum(int,int,int,int,int,int,int,int,int,int))
(	O
Stream_t	struct(*(struct),int,*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))))
*	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
dos_name_t	struct
*	O
dosname	*(struct)
,	O
char	O
*	O
longname	*(char)
,	O
struct	O
scan_state	struct(int,int,int,int,int,int,int,int,int)
*	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
,	O
ClashHandling_t	struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*(struct),*(char),int,*(int),*(struct))->(void)),int)
*	O
ch	char
)	O
{	O
int	O
error	*(int)
;	O
clash_action	enum(int,int,int,int,int,int,int,int,int,int)
ret	enum(int,int,int,int,int,int,int,int,int,int)
;	O
int	O
match_pos	int
=	O
0	int
;	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
entry	int
;	O
int	O
isprimary	int
;	O
int	O
no_overwrite	int
;	O
int	O
reason	int
;	O
int	O
pessimisticShortRename	int
;	O
doscp_t	struct
*	O
cp	*(struct)
=	O
GET_DOSCONVERT	O
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
;	O
pessimisticShortRename	int
=	O
(	O
ch	char
->	O
action	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
0	int
]	O
==	O
NAMEMATCH_AUTORENAME	int
)	O
;	O
entry	int
.	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
=	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
;	O
no_overwrite	int
=	O
1	int
;	O
if	O
(	O
(	O
is_reserved	(*(char),int)->(int)
(	O
longname	*(char)
,	O
1	int
)	O
)	O
||	O
longname	*(char)
[	O
strspn	(*(char),*(char))->(long)
(	O
longname	*(char)
,	O
". "	*(char)
)	O
]	O
==	O
'\0'	O
)	O
{	O
reason	int
=	O
RESERVED	int
;	O
isprimary	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
contains_illegals	(*(char),*(char),int)->(int)
(	O
longname	*(char)
,	O
long_illegals	*(char)
,	O
1024	int
)	O
)	O
{	O
reason	int
=	O
ILLEGALS	int
;	O
isprimary	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
is_reserved	(*(char),int)->(int)
(	O
dosname	*(struct)
->	O
base	int
,	O
0	int
)	O
)	O
{	O
reason	int
=	O
RESERVED	int
;	O
ch	char
->	O
use_longname	int
=	O
1	int
;	O
isprimary	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
ch	char
->	O
is_label	int
&&	O
contains_illegals	(*(char),*(char),int)->(int)
(	O
dosname	*(struct)
->	O
base	int
,	O
short_illegals	*(char)
,	O
11	int
)	O
)	O
{	O
reason	int
=	O
ILLEGALS	int
;	O
ch	char
->	O
use_longname	int
=	O
1	int
;	O
isprimary	int
=	O
0	int
;	O
}	O
else	O
{	O
reason	int
=	O
EXISTS	int
;	O
switch	O
(	O
lookupForInsert	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(struct),*(char),*(struct(int,int,int,int,int,int,int,int,int)),int,int,int,int)->(int)
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
&	O
entry	int
,	O
dosname	*(struct)
,	O
longname	*(char)
,	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
,	O
ch	char
->	O
ignore_entry	int
,	O
ch	char
->	O
source_entry	int
,	O
pessimisticShortRename	int
&&	O
ch	char
->	O
use_longname	int
,	O
ch	char
->	O
use_longname	int
)	O
)	O
{	O
case	O
-	O
1	int
:	O
return	O
NAMEMATCH_ERROR	int
;	O
case	O
0	int
:	O
return	O
NAMEMATCH_SKIP	int
;	O
case	O
5	int
:	O
return	O
NAMEMATCH_GREW	int
;	O
case	O
6	int
:	O
return	O
NAMEMATCH_SUCCESS	int
;	O
}	O
match_pos	int
=	O
-	O
2	int
;	O
if	O
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
longmatch	int
>	O
-	O
1	int
)	O
{	O
match_pos	int
=	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
longmatch	int
;	O
isprimary	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
ch	char
->	O
use_longname	int
&	O
1	int
)	O
&&	O
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
shortmatch	int
!=	O
-	O
1	int
)	O
)	O
{	O
match_pos	int
=	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
shortmatch	int
;	O
isprimary	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
shortmatch	int
>=	O
0	int
)	O
{	O
match_pos	int
=	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
shortmatch	int
;	O
isprimary	int
=	O
1	int
;	O
}	O
else	O
return	O
NAMEMATCH_RENAME	int
;	O
if	O
(	O
match_pos	int
>	O
-	O
1	int
)	O
{	O
entry	int
.	O
entry	int
=	O
match_pos	int
;	O
dir_read	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)),*(int))->(*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))))
(	O
&	O
entry	int
,	O
&	O
error	*(int)
)	O
;	O
if	O
(	O
error	*(int)
)	O
return	O
NAMEMATCH_ERROR	int
;	O
no_overwrite	int
=	O
(	O
match_pos	int
==	O
ch	char
->	O
source	short
||	O
IS_DIR	O
(	O
&	O
entry	int
)	O
)	O
;	O
}	O
}	O
ret	enum(int,int,int,int,int,int,int,int,int,int)
=	O
process_namematch	(*(struct),*(struct(array(char),array(char),char)),*(char),int,*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),int,int)->(enum(int,int,int,int,int,int,int,int,int,int))
(	O
cp	*(struct)
,	O
dosname	*(struct)
,	O
longname	*(char)
,	O
isprimary	int
,	O
ch	char
,	O
no_overwrite	int
,	O
reason	int
)	O
;	O
if	O
(	O
ret	enum(int,int,int,int,int,int,int,int,int,int)
==	O
NAMEMATCH_OVERWRITE	int
&&	O
match_pos	int
>	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
entry	int
.	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
attr	char
&	O
0x5	int
)	O
&&	O
(	O
ask_confirmation	(*(char))->(int)
(	O
"file is read only, overwrite anyway (y/n) ? "	*(char)
)	O
)	O
)	O
return	O
NAMEMATCH_RENAME	int
;	O
if	O
(	O
fatFreeWithDirentry	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int)
(	O
&	O
entry	int
)	O
)	O
return	O
NAMEMATCH_ERROR	int
;	O
{	O
wipeEntry	(*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(void)
(	O
&	O
entry	int
)	O
;	O
return	O
NAMEMATCH_RENAME	int
;	O
}	O
}	O
return	O
ret	enum(int,int,int,int,int,int,int,int,int,int)
;	O
}	O
static	O
__inline__	O
int	O
write_slots	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(struct(array(char),array(char),char)),*(char),*(struct(int,int,int,int,int,int,int,int,int)),*((*(struct(array(char),array(char),char)),*(char),*(void),*(struct(*`,int,struct`,array(int),int,int)))->(int)),*(void),int)->(int)
(	O
Stream_t	struct(*(struct),int,*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))))
*	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
dos_name_t	struct
*	O
dosname	*(struct)
,	O
char	O
*	O
longname	*(char)
,	O
struct	O
scan_state	struct(int,int,int,int,int,int,int,int,int)
*	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
,	O
write_data_callback	(*(struct),*(char),*(void),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int)
*	O
cb	*((*(struct),*(char),*(void),*(struct(*(struct`),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int))
,	O
void	O
*	O
arg	*(void)
,	O
int	O
Case	char
)	O
{	O
direntry_t	struct(*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)
entry	int
;	O
if	O
(	O
fat_error	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))))->(int)
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
)	O
return	O
0	int
;	O
entry	int
.	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
=	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
;	O
entry	int
.	O
entry	int
=	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
slot	int
;	O
native_to_wchar	(*(char),*(int),long,*(char),*(int))->(int)
(	O
longname	*(char)
,	O
entry	int
.	O
name	*(char)
,	O
MAX_VNAMELEN	O
,	O
0	int
,	O
0	int
)	O
;	O
entry	int
.	O
name	*(char)
[	O
MAX_VNAMELEN	O
]	O
=	O
'\0'	O
;	O
entry	int
.	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
.	O
Case	char
=	O
Case	char
&	O
(	O
EXTCASE	int
|	O
BASECASE	int
)	O
;	O
if	O
(	O
cb	*((*(struct),*(char),*(void),*(struct(*(struct`),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int))
(	O
dosname	*(struct)
,	O
longname	*(char)
,	O
arg	*(void)
,	O
&	O
entry	int
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
size_needed	int
>	O
1	int
)	O
&&	O
(	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_end	int
-	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_start	int
>=	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
size_needed	int
)	O
)	O
{	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
slot	int
=	O
write_vfat	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(struct),*(char),int,*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int)
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
dosname	*(struct)
,	O
longname	*(char)
,	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_start	int
,	O
&	O
entry	int
)	O
;	O
}	O
else	O
{	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
size_needed	int
=	O
1	int
;	O
write_vfat	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(struct),*(char),int,*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int)
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
dosname	*(struct)
,	O
0	int
,	O
ssp	*(struct(int,int,int,int,int,int,int,int,int))
->	O
free_start	int
,	O
&	O
entry	int
)	O
;	O
}	O
}	O
else	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
stripspaces	(*(char))->(void)
(	O
char	O
*	O
name	*(char)
)	O
{	O
char	O
*	O
p	*(char)
,	O
*	O
non_space	*(char)
;	O
non_space	*(char)
=	O
name	*(char)
;	O
for	O
(	O
p	*(char)
=	O
name	*(char)
;	O
*	O
p	*(char)
;	O
p	*(char)
++	O
)	O
if	O
(	O
*	O
p	*(char)
!=	O
' '	O
)	O
non_space	*(char)
=	O
p	*(char)
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
)	O
non_space	*(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
static	O
int	O
_mwrite_one	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(char),*(char),*((*(struct(array(char),array(char),char)),*(char),*(void),*(struct(*`,int,struct`,array(int),int,int)))->(int)),*(void),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)))->(int)
(	O
Stream_t	struct(*(struct),int,*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))))
*	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
char	O
*	O
argname	*(char)
,	O
char	O
*	O
shortname	*(char)
,	O
write_data_callback	(*(struct),*(char),*(void),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int)
*	O
cb	*((*(struct),*(char),*(void),*(struct(*(struct`),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int))
,	O
void	O
*	O
arg	*(void)
,	O
ClashHandling_t	struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*(struct),*(char),int,*(int),*(struct))->(void)),int)
*	O
ch	char
)	O
{	O
char	O
longname	*(char)
[	O
VBUFSIZE	O
]	O
;	O
const	O
char	O
*	O
dstname	*(char)
;	O
dos_name_t	struct
dosname	*(struct)
;	O
int	O
expanded	int
;	O
struct	O
scan_state	struct(int,int,int,int,int,int,int,int,int)
scan	struct(int,int,int,int,int,int,int,int,int)
;	O
clash_action	enum(int,int,int,int,int,int,int,int,int,int)
ret	enum(int,int,int,int,int,int,int,int,int,int)
;	O
doscp_t	struct
*	O
cp	*(struct)
=	O
GET_DOSCONVERT	O
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
)	O
;	O
expanded	int
=	O
0	int
;	O
if	O
(	O
isSpecial	(*(char))->(int)
(	O
argname	*(char)
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Cannot create entry named . or ..\n"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
ch	char
->	O
name_converter	*((*(struct),*(char),int,*(int),*(struct))->(void))
==	O
dos_name	(*(struct),*(char),int,*(int),*(struct))->(void)
)	O
{	O
if	O
(	O
shortname	*(char)
)	O
stripspaces	(*(char))->(void)
(	O
shortname	*(char)
)	O
;	O
if	O
(	O
argname	*(char)
)	O
stripspaces	(*(char))->(void)
(	O
argname	*(char)
)	O
;	O
}	O
if	O
(	O
shortname	*(char)
)	O
{	O
convert_to_shortname	(*(struct),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),*(char),*(struct(array(char),array(char),char)))->(int)
(	O
cp	*(struct)
,	O
ch	char
,	O
shortname	*(char)
,	O
&	O
dosname	*(struct)
)	O
;	O
if	O
(	O
ch	char
->	O
use_longname	int
&	O
1	int
)	O
{	O
argname	*(char)
=	O
shortname	*(char)
;	O
shortname	*(char)
=	O
0	int
;	O
}	O
}	O
if	O
(	O
argname	*(char)
[	O
0	int
]	O
&&	O
(	O
argname	*(char)
[	O
1	int
]	O
==	O
':'	O
)	O
)	O
{	O
dstname	*(char)
=	O
argname	*(char)
+	O
2	int
;	O
}	O
else	O
{	O
dstname	*(char)
=	O
argname	*(char)
;	O
}	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
longname	*(char)
,	O
dstname	*(char)
,	O
VBUFSIZE	O
-	O
1	int
)	O
;	O
if	O
(	O
shortname	*(char)
)	O
{	O
ch	char
->	O
use_longname	int
=	O
convert_to_shortname	(*(struct),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),*(char),*(struct(array(char),array(char),char)))->(int)
(	O
cp	*(struct)
,	O
ch	char
,	O
shortname	*(char)
,	O
&	O
dosname	*(struct)
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
shortname	*(char)
,	O
longname	*(char)
)	O
)	O
ch	char
->	O
use_longname	int
|=	O
1	int
;	O
}	O
else	O
{	O
ch	char
->	O
use_longname	int
=	O
convert_to_shortname	(*(struct),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),*(char),*(struct(array(char),array(char),char)))->(int)
(	O
cp	*(struct)
,	O
ch	char
,	O
longname	*(char)
,	O
&	O
dosname	*(struct)
)	O
;	O
}	O
ch	char
->	O
action	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
0	int
]	O
=	O
ch	char
->	O
namematch_default	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
0	int
]	O
;	O
ch	char
->	O
action	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
1	int
]	O
=	O
ch	char
->	O
namematch_default	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
1	int
]	O
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
(	O
ret	enum(int,int,int,int,int,int,int,int,int,int)
=	O
get_slots	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(struct(array(char),array(char),char)),*(char),*(struct(int,int,int,int,int,int,int,int,int)),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)))->(enum(int,int,int,int,int,int,int,int,int,int))
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
&	O
dosname	*(struct)
,	O
longname	*(char)
,	O
&	O
scan	struct(int,int,int,int,int,int,int,int,int)
,	O
ch	char
)	O
)	O
)	O
{	O
case	O
NAMEMATCH_ERROR	int
:	O
return	O
-	O
1	int
;	O
case	O
NAMEMATCH_SKIP	int
:	O
return	O
-	O
1	int
;	O
case	O
NAMEMATCH_PRENAME	int
:	O
ch	char
->	O
use_longname	int
=	O
convert_to_shortname	(*(struct),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),*(char),*(struct(array(char),array(char),char)))->(int)
(	O
cp	*(struct)
,	O
ch	char
,	O
longname	*(char)
,	O
&	O
dosname	*(struct)
)	O
;	O
continue	O
;	O
case	O
NAMEMATCH_RENAME	int
:	O
continue	O
;	O
case	O
NAMEMATCH_GREW	int
:	O
if	O
(	O
expanded	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s: No directory slots\n"	*(char)
,	O
progname	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
expanded	int
=	O
1	int
;	O
if	O
(	O
dir_grow	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),int)->(int)
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
scan	struct(int,int,int,int,int,int,int,int,int)
.	O
max_entry	int
)	O
)	O
return	O
-	O
1	int
;	O
continue	O
;	O
case	O
NAMEMATCH_OVERWRITE	int
:	O
case	O
NAMEMATCH_SUCCESS	int
:	O
return	O
write_slots	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(struct(array(char),array(char),char)),*(char),*(struct(int,int,int,int,int,int,int,int,int)),*((*(struct(array(char),array(char),char)),*(char),*(void),*(struct(*`,int,struct`,array(int),int,int)))->(int)),*(void),int)->(int)
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
&	O
dosname	*(struct)
,	O
longname	*(char)
,	O
&	O
scan	struct(int,int,int,int,int,int,int,int,int)
,	O
cb	*((*(struct),*(char),*(void),*(struct(*(struct`),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int))
,	O
arg	*(void)
,	O
ch	char
->	O
use_longname	int
)	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Internal error: clash_action=%d\n"	*(char)
,	O
ret	enum(int,int,int,int,int,int,int,int,int,int)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
int	O
mwrite_one	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(char),*(char),*((*(struct),*(char),*(void),*(struct(*`,int,struct`,array(int),int,int)))->(int)),*(void),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)))->(int)
(	O
Stream_t	struct(*(struct),int,*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))),*(struct(*(struct),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`))))))
*	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
const	O
char	O
*	O
_argname	*(char)
,	O
const	O
char	O
*	O
_shortname	*(char)
,	O
write_data_callback	(*(struct),*(char),*(void),*(struct(*(struct(*`,int,*`,*`)),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int)
*	O
cb	*((*(struct),*(char),*(void),*(struct(*(struct`),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int))
,	O
void	O
*	O
arg	*(void)
,	O
ClashHandling_t	struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*(struct),*(char),int,*(int),*(struct))->(void)),int)
*	O
ch	char
)	O
{	O
char	O
*	O
argname	*(char)
;	O
char	O
*	O
shortname	*(char)
;	O
int	O
ret	enum(int,int,int,int,int,int,int,int,int,int)
;	O
if	O
(	O
_argname	*(char)
)	O
argname	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
_argname	*(char)
)	O
;	O
else	O
argname	*(char)
=	O
0	int
;	O
if	O
(	O
_shortname	*(char)
)	O
shortname	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
_shortname	*(char)
)	O
;	O
else	O
shortname	*(char)
=	O
0	int
;	O
ret	enum(int,int,int,int,int,int,int,int,int,int)
=	O
_mwrite_one	(*(struct(*(struct(*`,*`,*`,*`,*`,*`,*`,*`,*`)),int,*(struct(*`,int,*`,*`)),*(struct(*`,int,*`,*`)))),*(char),*(char),*((*(struct(array(char),array(char),char)),*(char),*(void),*(struct(*`,int,struct`,array(int),int,int)))->(int)),*(void),*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)))->(int)
(	O
Dir	*(struct(*(struct(*((*`,*`,long,long)->(int)),*((*`,*`,long,long)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`,*`,int,*`)->(int)),*((*`,*`,*`,*`,*`)->(int)),*((*`,long)->(int)),*((*`)->(*`)),*((*`)->(int)))),int,*(struct(*(struct`),int,*(struct`),*(struct`))),*(struct(*(struct`),int,*(struct`),*(struct`)))))
,	O
argname	*(char)
,	O
shortname	*(char)
,	O
cb	*((*(struct),*(char),*(void),*(struct(*(struct`),int,struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)),array(int),int,int)))->(int))
,	O
arg	*(void)
,	O
ch	char
)	O
;	O
if	O
(	O
argname	*(char)
)	O
free	(*(void))->(void)
(	O
argname	*(char)
)	O
;	O
if	O
(	O
shortname	*(char)
)	O
free	(*(void))->(void)
(	O
shortname	*(char)
)	O
;	O
return	O
ret	enum(int,int,int,int,int,int,int,int,int,int)
;	O
}	O
void	O
init_clash_handling	(*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)))->(void)
(	O
ClashHandling_t	struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*(struct),*(char),int,*(int),*(struct))->(void)),int)
*	O
ch	char
)	O
{	O
ch	char
->	O
ignore_entry	int
=	O
-	O
1	int
;	O
ch	char
->	O
source_entry	int
=	O
-	O
2	int
;	O
ch	char
->	O
nowarn	int
=	O
0	int
;	O
ch	char
->	O
namematch_default	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
0	int
]	O
=	O
NAMEMATCH_AUTORENAME	int
;	O
ch	char
->	O
namematch_default	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
1	int
]	O
=	O
NAMEMATCH_NONE	int
;	O
ch	char
->	O
name_converter	*((*(struct),*(char),int,*(int),*(struct))->(void))
=	O
dos_name	(*(struct),*(char),int,*(int),*(struct))->(void)
;	O
ch	char
->	O
source	short
=	O
-	O
2	int
;	O
ch	char
->	O
is_label	int
=	O
0	int
;	O
}	O
int	O
handle_clash_options	(*(struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*`,*`,int,*`,*`)->(void)),int)),char)->(int)
(	O
ClashHandling_t	struct(array(enum(int,int,int,int,int,int,int,int,int,int)),array(enum(int,int,int,int,int,int,int,int,int,int)),int,int,int,*(char),*(char),int,int,int,int,int,*((*(struct),*(char),int,*(int),*(struct))->(void)),int)
*	O
ch	char
,	O
char	O
c	char
)	O
{	O
int	O
isprimary	int
;	O
if	O
(	O
isupper	(int)->(int)
(	O
c	char
)	O
)	O
isprimary	int
=	O
0	int
;	O
else	O
isprimary	int
=	O
1	int
;	O
c	char
=	O
ch_tolower	(char)->(char)
(	O
c	char
)	O
;	O
switch	O
(	O
c	char
)	O
{	O
case	O
'o'	O
:	O
ch	char
->	O
namematch_default	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
isprimary	int
]	O
=	O
NAMEMATCH_OVERWRITE	int
;	O
return	O
0	int
;	O
case	O
'r'	O
:	O
ch	char
->	O
namematch_default	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
isprimary	int
]	O
=	O
NAMEMATCH_RENAME	int
;	O
return	O
0	int
;	O
case	O
's'	O
:	O
ch	char
->	O
namematch_default	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
isprimary	int
]	O
=	O
NAMEMATCH_SKIP	int
;	O
return	O
0	int
;	O
case	O
'm'	O
:	O
ch	char
->	O
namematch_default	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
isprimary	int
]	O
=	O
NAMEMATCH_NONE	int
;	O
return	O
0	int
;	O
case	O
'a'	O
:	O
ch	char
->	O
namematch_default	array(enum(int,int,int,int,int,int,int,int,int,int))
[	O
isprimary	int
]	O
=	O
NAMEMATCH_AUTORENAME	int
;	O
return	O
0	int
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
void	O
dosnameToDirentry	(*(struct),*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))))->(void)
(	O
const	O
struct	O
dos_name_t	struct
*	O
dn	*(struct)
,	O
struct	O
directory	struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char))
*	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
->	O
name	*(char)
,	O
dn	*(struct)
->	O
base	int
,	O
8	int
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
dir	*(struct(array(char),array(char),char,char,char,array(char),array(char),array(char),array(char),array(char),array(char),array(char),array(char)))
->	O
ext	array(char)
,	O
dn	*(struct)
->	O
ext	array(char)
,	O
3	int
)	O
;	O
}	O
