verify	O
(	O
RSYNC_WIN	int
<	O
MAX_DIST	O
)	O
;	O
typedef	O
ush	short
Pos	short
;	O
typedef	O
unsigned	O
IPos	int
;	O
static	O
ulg	long
window_size	long
=	O
(	O
ulg	long
)	O
2	int
*	O
WSIZE	int
;	O
long	O
block_start	long
;	O
local	O
unsigned	O
ins_h	int
;	O
unsigned	O
int	O
near	O
prev_length	int
;	O
unsigned	O
near	O
strstart	int
;	O
unsigned	O
near	O
match_start	int
;	O
local	O
int	O
eofile	int
;	O
local	O
unsigned	O
lookahead	int
;	O
unsigned	O
max_chain_length	int
;	O
local	O
unsigned	O
int	O
max_lazy_match	int
;	O
local	O
int	O
compr_level	int
;	O
unsigned	O
good_match	int
;	O
local	O
ulg	long
rsync_sum	long
;	O
local	O
ulg	long
rsync_chunk_end	long
;	O
typedef	O
struct	O
config	struct(short,short,short,short)
{	O
ush	short
good_length	short
;	O
ush	short
max_lazy	short
;	O
ush	short
nice_length	short
;	O
ush	short
max_chain	short
;	O
}	O
config	struct(short,short,short,short)
;	O
static_unless_ASMV	O
int	O
nice_match	int
;	O
local	O
config	struct(short,short,short,short)
configuration_table	array(struct(short,short,short,short))
[	O
10	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
4	int
,	O
4	int
,	O
8	int
,	O
4	int
}	O
,	O
{	O
4	int
,	O
5	int
,	O
16	int
,	O
8	int
}	O
,	O
{	O
4	int
,	O
6	int
,	O
32	int
,	O
32	int
}	O
,	O
{	O
4	int
,	O
4	int
,	O
16	int
,	O
16	int
}	O
,	O
{	O
8	int
,	O
16	int
,	O
32	int
,	O
32	int
}	O
,	O
{	O
8	int
,	O
16	int
,	O
128	int
,	O
128	int
}	O
,	O
{	O
8	int
,	O
32	int
,	O
128	int
,	O
256	int
}	O
,	O
{	O
32	int
,	O
128	int
,	O
258	int
,	O
1024	int
}	O
,	O
{	O
32	int
,	O
258	int
,	O
258	int
,	O
4096	int
}	O
}	O
;	O
local	O
void	O
fill_window	()->(void)
(	O
void	O
)	O
;	O
local	O
off_t	long
deflate_fast	()->(long)
(	O
void	O
)	O
;	O
void	O
lm_init	(int,*(short))->(void)
(	O
pack_level	int
,	O
flags	*(short)
)	O
int	O
pack_level	int
;	O
ush	short
*	O
flags	*(short)
;	O
{	O
register	O
unsigned	O
j	int
;	O
if	O
(	O
pack_level	int
<	O
1	int
||	O
pack_level	int
>	O
9	int
)	O
gzip_error	(*(char))->(void)
(	O
"bad pack level"	*(char)
)	O
;	O
compr_level	int
=	O
pack_level	int
;	O
memzero	O
(	O
(	O
char	O
*	O
)	O
head	O
,	O
HASH_SIZE	O
*	O
sizeof	O
(	O
*	O
head	O
)	O
)	O
;	O
rsync_chunk_end	long
=	O
0xFFFFFFFFUL	int
;	O
rsync_sum	long
=	O
0	int
;	O
max_lazy_match	int
=	O
configuration_table	array(struct(short,short,short,short))
[	O
pack_level	int
]	O
.	O
max_lazy	short
;	O
good_match	int
=	O
configuration_table	array(struct(short,short,short,short))
[	O
pack_level	int
]	O
.	O
good_length	short
;	O
nice_match	int
=	O
configuration_table	array(struct(short,short,short,short))
[	O
pack_level	int
]	O
.	O
nice_length	short
;	O
max_chain_length	int
=	O
configuration_table	array(struct(short,short,short,short))
[	O
pack_level	int
]	O
.	O
max_chain	short
;	O
if	O
(	O
pack_level	int
==	O
1	int
)	O
{	O
*	O
flags	*(short)
|=	O
FAST	int
;	O
}	O
else	O
if	O
(	O
pack_level	int
==	O
9	int
)	O
{	O
*	O
flags	*(short)
|=	O
SLOW	int
;	O
}	O
strstart	int
=	O
0	int
;	O
block_start	long
=	O
0L	int
;	O
lookahead	int
=	O
read_buf	*((*(char),int)->(int))
(	O
(	O
char	O
*	O
)	O
window	array(char)
,	O
sizeof	O
(	O
int	O
)	O
<=	O
2	int
?	O
(	O
unsigned	O
)	O
WSIZE	int
:	O
2	int
*	O
WSIZE	int
)	O
;	O
if	O
(	O
lookahead	int
==	O
0	int
||	O
lookahead	int
==	O
(	O
unsigned	O
)	O
EOF	O
)	O
{	O
eofile	int
=	O
1	int
,	O
lookahead	int
=	O
0	int
;	O
return	O
;	O
}	O
eofile	int
=	O
0	int
;	O
while	O
(	O
lookahead	int
<	O
MIN_LOOKAHEAD	O
&&	O
!	O
eofile	int
)	O
fill_window	()->(void)
(	O
)	O
;	O
ins_h	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
MIN_MATCH	int
-	O
1	int
;	O
j	int
++	O
)	O
UPDATE_HASH	O
(	O
ins_h	int
,	O
window	array(char)
[	O
j	int
]	O
)	O
;	O
}	O
static	O
int	O
longest_match	(int)->(int)
(	O
IPos	int
cur_match	int
)	O
{	O
unsigned	O
chain_length	int
=	O
max_chain_length	int
;	O
register	O
uch	char
*	O
scan	*(char)
=	O
window	array(char)
+	O
strstart	int
;	O
register	O
uch	char
*	O
match	*(char)
;	O
register	O
int	O
len	int
;	O
int	O
best_len	int
=	O
prev_length	int
;	O
IPos	int
limit	int
=	O
strstart	int
>	O
(	O
IPos	int
)	O
MAX_DIST	O
?	O
strstart	int
-	O
(	O
IPos	int
)	O
MAX_DIST	O
:	O
NIL	int
;	O
register	O
uch	char
*	O
strend	*(char)
=	O
window	array(char)
+	O
strstart	int
+	O
MAX_MATCH	int
;	O
register	O
uch	char
scan_end1	char
=	O
scan	*(char)
[	O
best_len	int
-	O
1	int
]	O
;	O
register	O
uch	char
scan_end	char
=	O
scan	*(char)
[	O
best_len	int
]	O
;	O
if	O
(	O
prev_length	int
>=	O
good_match	int
)	O
{	O
chain_length	int
>>=	O
2	int
;	O
}	O
Assert	O
(	O
strstart	int
<=	O
window_size	long
-	O
MIN_LOOKAHEAD	O
,	O
"insufficient lookahead"	*(char)
)	O
;	O
do	O
{	O
Assert	O
(	O
cur_match	int
<	O
strstart	int
,	O
"no future"	*(char)
)	O
;	O
match	*(char)
=	O
window	array(char)
+	O
cur_match	int
;	O
if	O
(	O
match	*(char)
[	O
best_len	int
]	O
!=	O
scan_end	char
||	O
match	*(char)
[	O
best_len	int
-	O
1	int
]	O
!=	O
scan_end1	char
||	O
*	O
match	*(char)
!=	O
*	O
scan	*(char)
||	O
*	O
++	O
match	*(char)
!=	O
scan	*(char)
[	O
1	int
]	O
)	O
continue	O
;	O
scan	*(char)
+=	O
2	int
,	O
match	*(char)
++	O
;	O
do	O
{	O
}	O
while	O
(	O
*	O
++	O
scan	*(char)
==	O
*	O
++	O
match	*(char)
&&	O
*	O
++	O
scan	*(char)
==	O
*	O
++	O
match	*(char)
&&	O
*	O
++	O
scan	*(char)
==	O
*	O
++	O
match	*(char)
&&	O
*	O
++	O
scan	*(char)
==	O
*	O
++	O
match	*(char)
&&	O
*	O
++	O
scan	*(char)
==	O
*	O
++	O
match	*(char)
&&	O
*	O
++	O
scan	*(char)
==	O
*	O
++	O
match	*(char)
&&	O
*	O
++	O
scan	*(char)
==	O
*	O
++	O
match	*(char)
&&	O
*	O
++	O
scan	*(char)
==	O
*	O
++	O
match	*(char)
&&	O
scan	*(char)
<	O
strend	*(char)
)	O
;	O
len	int
=	O
MAX_MATCH	int
-	O
(	O
int	O
)	O
(	O
strend	*(char)
-	O
scan	*(char)
)	O
;	O
scan	*(char)
=	O
strend	*(char)
-	O
MAX_MATCH	int
;	O
if	O
(	O
len	int
>	O
best_len	int
)	O
{	O
match_start	int
=	O
cur_match	int
;	O
best_len	int
=	O
len	int
;	O
if	O
(	O
len	int
>=	O
nice_match	int
)	O
break	O
;	O
scan_end1	char
=	O
scan	*(char)
[	O
best_len	int
-	O
1	int
]	O
;	O
scan_end	char
=	O
scan	*(char)
[	O
best_len	int
]	O
;	O
}	O
}	O
while	O
(	O
(	O
cur_match	int
=	O
prev	array(short)
[	O
cur_match	int
&	O
WMASK	O
]	O
)	O
>	O
limit	int
&&	O
--	O
chain_length	int
!=	O
0	int
)	O
;	O
return	O
best_len	int
;	O
}	O
local	O
void	O
fill_window	()->(void)
(	O
)	O
{	O
register	O
unsigned	O
n	int
,	O
m	*(char)
;	O
unsigned	O
more	int
=	O
(	O
unsigned	O
)	O
(	O
window_size	long
-	O
(	O
ulg	long
)	O
lookahead	int
-	O
(	O
ulg	long
)	O
strstart	int
)	O
;	O
if	O
(	O
more	int
==	O
(	O
unsigned	O
)	O
EOF	O
)	O
{	O
more	int
--	O
;	O
}	O
else	O
if	O
(	O
strstart	int
>=	O
WSIZE	int
+	O
MAX_DIST	O
)	O
{	O
Assert	O
(	O
window_size	long
==	O
(	O
ulg	long
)	O
2	int
*	O
WSIZE	int
,	O
"no sliding with BIG_MEM"	*(char)
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
(	O
char	O
*	O
)	O
window	array(char)
,	O
(	O
char	O
*	O
)	O
window	array(char)
+	O
WSIZE	int
,	O
(	O
unsigned	O
)	O
WSIZE	int
)	O
;	O
match_start	int
-=	O
WSIZE	int
;	O
strstart	int
-=	O
WSIZE	int
;	O
if	O
(	O
rsync_chunk_end	long
!=	O
0xFFFFFFFFUL	int
)	O
rsync_chunk_end	long
-=	O
WSIZE	int
;	O
block_start	long
-=	O
(	O
long	O
)	O
WSIZE	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
HASH_SIZE	O
;	O
n	int
++	O
)	O
{	O
m	*(char)
=	O
head	O
[	O
n	int
]	O
;	O
head	O
[	O
n	int
]	O
=	O
(	O
Pos	short
)	O
(	O
m	*(char)
>=	O
WSIZE	int
?	O
m	*(char)
-	O
WSIZE	int
:	O
NIL	int
)	O
;	O
}	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
WSIZE	int
;	O
n	int
++	O
)	O
{	O
m	*(char)
=	O
prev	array(short)
[	O
n	int
]	O
;	O
prev	array(short)
[	O
n	int
]	O
=	O
(	O
Pos	short
)	O
(	O
m	*(char)
>=	O
WSIZE	int
?	O
m	*(char)
-	O
WSIZE	int
:	O
NIL	int
)	O
;	O
}	O
more	int
+=	O
WSIZE	int
;	O
}	O
if	O
(	O
!	O
eofile	int
)	O
{	O
n	int
=	O
read_buf	*((*(char),int)->(int))
(	O
(	O
char	O
*	O
)	O
window	array(char)
+	O
strstart	int
+	O
lookahead	int
,	O
more	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
||	O
n	int
==	O
(	O
unsigned	O
)	O
EOF	O
)	O
{	O
eofile	int
=	O
1	int
;	O
memzero	O
(	O
window	array(char)
+	O
strstart	int
+	O
lookahead	int
,	O
MIN_MATCH	int
-	O
1	int
)	O
;	O
}	O
else	O
{	O
lookahead	int
+=	O
n	int
;	O
}	O
}	O
}	O
local	O
void	O
rsync_roll	(int,int)->(void)
(	O
unsigned	O
int	O
start	int
,	O
unsigned	O
int	O
num	long
)	O
{	O
unsigned	O
i	int
;	O
if	O
(	O
start	int
<	O
RSYNC_WIN	int
)	O
{	O
for	O
(	O
i	int
=	O
start	int
;	O
i	int
<	O
RSYNC_WIN	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
start	int
+	O
num	long
)	O
return	O
;	O
rsync_sum	long
+=	O
(	O
ulg	long
)	O
window	array(char)
[	O
i	int
]	O
;	O
}	O
num	long
-=	O
(	O
RSYNC_WIN	int
-	O
start	int
)	O
;	O
start	int
=	O
RSYNC_WIN	int
;	O
}	O
for	O
(	O
i	int
=	O
start	int
;	O
i	int
<	O
start	int
+	O
num	long
;	O
i	int
++	O
)	O
{	O
rsync_sum	long
+=	O
(	O
ulg	long
)	O
window	array(char)
[	O
i	int
]	O
;	O
rsync_sum	long
-=	O
(	O
ulg	long
)	O
window	array(char)
[	O
i	int
-	O
RSYNC_WIN	int
]	O
;	O
if	O
(	O
rsync_chunk_end	long
==	O
0xFFFFFFFFUL	int
&&	O
RSYNC_SUM_MATCH	O
(	O
rsync_sum	long
)	O
)	O
rsync_chunk_end	long
=	O
i	int
;	O
}	O
}	O
local	O
off_t	long
deflate_fast	()->(long)
(	O
)	O
{	O
IPos	int
hash_head	int
;	O
int	O
flush	int
=	O
0	int
;	O
unsigned	O
match_length	int
=	O
0	int
;	O
prev_length	int
=	O
MIN_MATCH	int
-	O
1	int
;	O
while	O
(	O
lookahead	int
!=	O
0	int
)	O
{	O
INSERT_STRING	O
(	O
strstart	int
,	O
hash_head	int
)	O
;	O
if	O
(	O
hash_head	int
!=	O
NIL	int
&&	O
strstart	int
-	O
hash_head	int
<=	O
MAX_DIST	O
&&	O
strstart	int
<=	O
window_size	long
-	O
MIN_LOOKAHEAD	O
)	O
{	O
match_length	int
=	O
longest_match	(int)->(int)
(	O
hash_head	int
)	O
;	O
if	O
(	O
match_length	int
>	O
lookahead	int
)	O
match_length	int
=	O
lookahead	int
;	O
}	O
if	O
(	O
match_length	int
>=	O
MIN_MATCH	int
)	O
{	O
check_match	O
(	O
strstart	int
,	O
match_start	int
,	O
match_length	int
)	O
;	O
flush	int
=	O
ct_tally	(int,int)->(int)
(	O
strstart	int
-	O
match_start	int
,	O
match_length	int
-	O
MIN_MATCH	int
)	O
;	O
lookahead	int
-=	O
match_length	int
;	O
RSYNC_ROLL	O
(	O
strstart	int
,	O
match_length	int
)	O
;	O
if	O
(	O
match_length	int
<=	O
max_insert_length	O
)	O
{	O
match_length	int
--	O
;	O
do	O
{	O
strstart	int
++	O
;	O
INSERT_STRING	O
(	O
strstart	int
,	O
hash_head	int
)	O
;	O
}	O
while	O
(	O
--	O
match_length	int
!=	O
0	int
)	O
;	O
strstart	int
++	O
;	O
}	O
else	O
{	O
strstart	int
+=	O
match_length	int
;	O
match_length	int
=	O
0	int
;	O
ins_h	int
=	O
window	array(char)
[	O
strstart	int
]	O
;	O
UPDATE_HASH	O
(	O
ins_h	int
,	O
window	array(char)
[	O
strstart	int
+	O
1	int
]	O
)	O
;	O
}	O
}	O
else	O
{	O
Tracevv	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%c"	*(char)
,	O
window	array(char)
[	O
strstart	int
]	O
)	O
)	O
;	O
flush	int
=	O
ct_tally	(int,int)->(int)
(	O
0	int
,	O
window	array(char)
[	O
strstart	int
]	O
)	O
;	O
RSYNC_ROLL	O
(	O
strstart	int
,	O
1	int
)	O
;	O
lookahead	int
--	O
;	O
strstart	int
++	O
;	O
}	O
if	O
(	O
rsync	int
&&	O
strstart	int
>	O
rsync_chunk_end	long
)	O
{	O
rsync_chunk_end	long
=	O
0xFFFFFFFFUL	int
;	O
flush	int
=	O
2	int
;	O
}	O
if	O
(	O
flush	int
)	O
FLUSH_BLOCK	O
(	O
0	int
)	O
,	O
block_start	long
=	O
strstart	int
;	O
while	O
(	O
lookahead	int
<	O
MIN_LOOKAHEAD	O
&&	O
!	O
eofile	int
)	O
fill_window	()->(void)
(	O
)	O
;	O
}	O
return	O
FLUSH_BLOCK	O
(	O
1	int
)	O
;	O
}	O
off_t	long
deflate	()->(long)
(	O
)	O
{	O
IPos	int
hash_head	int
;	O
IPos	int
prev_match	int
;	O
int	O
flush	int
=	O
0	int
;	O
int	O
match_available	int
=	O
0	int
;	O
register	O
unsigned	O
match_length	int
=	O
MIN_MATCH	int
-	O
1	int
;	O
if	O
(	O
compr_level	int
<=	O
3	int
)	O
return	O
deflate_fast	()->(long)
(	O
)	O
;	O
while	O
(	O
lookahead	int
!=	O
0	int
)	O
{	O
INSERT_STRING	O
(	O
strstart	int
,	O
hash_head	int
)	O
;	O
prev_length	int
=	O
match_length	int
,	O
prev_match	int
=	O
match_start	int
;	O
match_length	int
=	O
MIN_MATCH	int
-	O
1	int
;	O
if	O
(	O
hash_head	int
!=	O
NIL	int
&&	O
prev_length	int
<	O
max_lazy_match	int
&&	O
strstart	int
-	O
hash_head	int
<=	O
MAX_DIST	O
&&	O
strstart	int
<=	O
window_size	long
-	O
MIN_LOOKAHEAD	O
)	O
{	O
match_length	int
=	O
longest_match	(int)->(int)
(	O
hash_head	int
)	O
;	O
if	O
(	O
match_length	int
>	O
lookahead	int
)	O
match_length	int
=	O
lookahead	int
;	O
if	O
(	O
match_length	int
==	O
MIN_MATCH	int
&&	O
strstart	int
-	O
match_start	int
>	O
TOO_FAR	int
)	O
{	O
match_length	int
--	O
;	O
}	O
}	O
if	O
(	O
prev_length	int
>=	O
MIN_MATCH	int
&&	O
match_length	int
<=	O
prev_length	int
)	O
{	O
check_match	O
(	O
strstart	int
-	O
1	int
,	O
prev_match	int
,	O
prev_length	int
)	O
;	O
flush	int
=	O
ct_tally	(int,int)->(int)
(	O
strstart	int
-	O
1	int
-	O
prev_match	int
,	O
prev_length	int
-	O
MIN_MATCH	int
)	O
;	O
lookahead	int
-=	O
prev_length	int
-	O
1	int
;	O
prev_length	int
-=	O
2	int
;	O
RSYNC_ROLL	O
(	O
strstart	int
,	O
prev_length	int
+	O
1	int
)	O
;	O
do	O
{	O
strstart	int
++	O
;	O
INSERT_STRING	O
(	O
strstart	int
,	O
hash_head	int
)	O
;	O
}	O
while	O
(	O
--	O
prev_length	int
!=	O
0	int
)	O
;	O
match_available	int
=	O
0	int
;	O
match_length	int
=	O
MIN_MATCH	int
-	O
1	int
;	O
strstart	int
++	O
;	O
if	O
(	O
rsync	int
&&	O
strstart	int
>	O
rsync_chunk_end	long
)	O
{	O
rsync_chunk_end	long
=	O
0xFFFFFFFFUL	int
;	O
flush	int
=	O
2	int
;	O
}	O
if	O
(	O
flush	int
)	O
FLUSH_BLOCK	O
(	O
0	int
)	O
,	O
block_start	long
=	O
strstart	int
;	O
}	O
else	O
if	O
(	O
match_available	int
)	O
{	O
Tracevv	O
(	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%c"	*(char)
,	O
window	array(char)
[	O
strstart	int
-	O
1	int
]	O
)	O
)	O
;	O
flush	int
=	O
ct_tally	(int,int)->(int)
(	O
0	int
,	O
window	array(char)
[	O
strstart	int
-	O
1	int
]	O
)	O
;	O
if	O
(	O
rsync	int
&&	O
strstart	int
>	O
rsync_chunk_end	long
)	O
{	O
rsync_chunk_end	long
=	O
0xFFFFFFFFUL	int
;	O
flush	int
=	O
2	int
;	O
}	O
if	O
(	O
flush	int
)	O
FLUSH_BLOCK	O
(	O
0	int
)	O
,	O
block_start	long
=	O
strstart	int
;	O
RSYNC_ROLL	O
(	O
strstart	int
,	O
1	int
)	O
;	O
strstart	int
++	O
;	O
lookahead	int
--	O
;	O
}	O
else	O
{	O
if	O
(	O
rsync	int
&&	O
strstart	int
>	O
rsync_chunk_end	long
)	O
{	O
rsync_chunk_end	long
=	O
0xFFFFFFFFUL	int
;	O
flush	int
=	O
2	int
;	O
FLUSH_BLOCK	O
(	O
0	int
)	O
,	O
block_start	long
=	O
strstart	int
;	O
}	O
match_available	int
=	O
1	int
;	O
RSYNC_ROLL	O
(	O
strstart	int
,	O
1	int
)	O
;	O
strstart	int
++	O
;	O
lookahead	int
--	O
;	O
}	O
Assert	O
(	O
strstart	int
<=	O
bytes_in	long
&&	O
lookahead	int
<=	O
bytes_in	long
,	O
"a bit too far"	*(char)
)	O
;	O
while	O
(	O
lookahead	int
<	O
MIN_LOOKAHEAD	O
&&	O
!	O
eofile	int
)	O
fill_window	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
match_available	int
)	O
ct_tally	(int,int)->(int)
(	O
0	int
,	O
window	array(char)
[	O
strstart	int
-	O
1	int
]	O
)	O
;	O
return	O
FLUSH_BLOCK	O
(	O
1	int
)	O
;	O
}	O
