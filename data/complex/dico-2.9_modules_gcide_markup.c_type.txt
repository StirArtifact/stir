typedef	O
int8_t	char
flex_int8_t	char
;	O
typedef	O
uint8_t	char
flex_uint8_t	char
;	O
typedef	O
int16_t	short
flex_int16_t	short
;	O
typedef	O
uint16_t	short
flex_uint16_t	short
;	O
typedef	O
int32_t	int
flex_int32_t	int
;	O
typedef	O
uint32_t	int
flex_uint32_t	int
;	O
typedef	O
struct	O
yy_buffer_state	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)
*	O
YY_BUFFER_STATE	*(struct)
;	O
typedef	O
size_t	long
yy_size_t	long
;	O
extern	O
yy_size_t	long
yyleng	O
;	O
extern	O
FILE	struct
*	O
yyin	O
,	O
*	O
yyout	O
;	O
struct	O
yy_buffer_state	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)
{	O
FILE	struct
*	O
yy_input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
yy_ch_buf	*(char)
;	O
char	O
*	O
yy_buf_pos	*(char)
;	O
yy_size_t	long
yy_buf_size	long
;	O
yy_size_t	long
yy_n_chars	long
;	O
int	O
yy_is_our_buffer	int
;	O
int	O
yy_is_interactive	int
;	O
int	O
yy_at_bol	int
;	O
int	O
yy_bs_lineno	int
;	O
int	O
yy_bs_column	int
;	O
int	O
yy_fill_buffer	int
;	O
int	O
yy_buffer_status	int
;	O
}	O
;	O
static	O
size_t	long
yy_buffer_stack_top	long
=	O
0	int
;	O
static	O
size_t	long
yy_buffer_stack_max	long
=	O
0	int
;	O
static	O
YY_BUFFER_STATE	*(struct)
*	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
=	O
0	int
;	O
static	O
char	O
yy_hold_char	char
;	O
static	O
yy_size_t	long
yy_n_chars	long
;	O
yy_size_t	long
yyleng	O
;	O
static	O
char	O
*	O
yy_c_buf_p	*(char)
=	O
(	O
char	O
*	O
)	O
0	int
;	O
static	O
int	O
yy_init	int
=	O
0	int
;	O
static	O
int	O
yy_start	int
=	O
0	int
;	O
static	O
int	O
yy_did_buffer_switch_on_eof	int
;	O
void	O
yyrestart	O
(	O
FILE	struct
*	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
void	O
yy_switch_to_buffer	O
(	O
YY_BUFFER_STATE	*(struct)
new_buffer	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int))
)	O
;	O
YY_BUFFER_STATE	*(struct)
yy_create_buffer	O
(	O
FILE	struct
*	O
file	*(char)
,	O
int	O
size	long
)	O
;	O
void	O
yy_delete_buffer	O
(	O
YY_BUFFER_STATE	*(struct)
b	*(struct)
)	O
;	O
void	O
yy_flush_buffer	O
(	O
YY_BUFFER_STATE	*(struct)
b	*(struct)
)	O
;	O
void	O
yypush_buffer_state	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))->(void)
(	O
YY_BUFFER_STATE	*(struct)
new_buffer	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int))
)	O
;	O
void	O
yypop_buffer_state	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
yyensure_buffer_stack	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
yy_load_buffer_state	O
(	O
void	O
)	O
;	O
static	O
void	O
yy_init_buffer	O
(	O
YY_BUFFER_STATE	*(struct)
b	*(struct)
,	O
FILE	struct
*	O
file	*(char)
)	O
;	O
YY_BUFFER_STATE	*(struct)
yy_scan_buffer	(*(char),long)->(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
(	O
char	O
*	O
base	*(void)
,	O
yy_size_t	long
size	long
)	O
;	O
YY_BUFFER_STATE	*(struct)
yy_scan_string	(*(char))->(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
(	O
yyconst	O
char	O
*	O
yy_str	*(char)
)	O
;	O
YY_BUFFER_STATE	*(struct)
yy_scan_bytes	(*(char),long)->(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
(	O
yyconst	O
char	O
*	O
bytes	*(char)
,	O
yy_size_t	long
len	int
)	O
;	O
void	O
*	O
yyalloc	O
(	O
yy_size_t	long
)	O
;	O
void	O
*	O
yyrealloc	O
(	O
void	O
*	O
,	O
yy_size_t	long
)	O
;	O
void	O
yyfree	O
(	O
void	O
*	O
)	O
;	O
typedef	O
unsigned	O
char	O
YY_CHAR	char
;	O
FILE	struct
*	O
yyin	O
=	O
(	O
FILE	struct
*	O
)	O
0	int
,	O
*	O
yyout	O
=	O
(	O
FILE	struct
*	O
)	O
0	int
;	O
typedef	O
int	O
yy_state_type	int
;	O
extern	O
int	O
yylineno	O
;	O
int	O
yylineno	O
=	O
1	int
;	O
extern	O
char	O
*	O
yytext	O
;	O
static	O
yy_state_type	int
yy_get_previous_state	()->(int)
(	O
void	O
)	O
;	O
static	O
yy_state_type	int
yy_try_NUL_trans	(int)->(int)
(	O
yy_state_type	int
current_state	int
)	O
;	O
static	O
int	O
yy_get_next_buffer	()->(int)
(	O
void	O
)	O
;	O
static	O
void	O
yy_fatal_error	(array(char))->(void)
(	O
yyconst	O
char	O
msg	array(char)
[	O
]	O
)	O
;	O
struct	O
yy_trans_info	struct(int,int)
{	O
flex_int32_t	int
yy_verify	int
;	O
flex_int32_t	int
yy_nxt	int
;	O
}	O
;	O
static	O
yyconst	O
flex_int16_t	short
yy_accept	array(short)
[	O
39	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
16	int
,	O
10	int
,	O
11	int
,	O
9	int
,	O
7	int
,	O
10	int
,	O
10	int
,	O
13	int
,	O
13	int
,	O
14	int
,	O
2	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
12	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
6	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
4	int
,	O
3	int
,	O
0	int
,	O
0	int
,	O
5	int
,	O
3	int
,	O
8	int
,	O
0	int
}	O
;	O
static	O
yyconst	O
flex_int32_t	int
yy_ec	array(int)
[	O
256	int
]	O
=	O
{	O
0	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
4	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
5	int
,	O
6	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
7	int
,	O
1	int
,	O
1	int
,	O
6	int
,	O
1	int
,	O
1	int
,	O
8	int
,	O
1	int
,	O
9	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
10	int
,	O
1	int
,	O
1	int
,	O
11	int
,	O
1	int
,	O
12	int
,	O
13	int
,	O
1	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
1	int
,	O
15	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
6	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
17	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
}	O
;	O
static	O
yyconst	O
flex_int32_t	int
yy_meta	array(int)
[	O
18	int
]	O
=	O
{	O
0	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
3	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
4	int
,	O
1	int
,	O
4	int
,	O
4	int
}	O
;	O
static	O
yyconst	O
flex_int16_t	short
yy_base	array(short)
[	O
46	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
13	int
,	O
27	int
,	O
37	int
,	O
37	int
,	O
102	int
,	O
102	int
,	O
102	int
,	O
102	int
,	O
44	int
,	O
29	int
,	O
23	int
,	O
102	int
,	O
22	int
,	O
102	int
,	O
25	int
,	O
15	int
,	O
22	int
,	O
53	int
,	O
62	int
,	O
2	int
,	O
15	int
,	O
102	int
,	O
102	int
,	O
14	int
,	O
13	int
,	O
102	int
,	O
14	int
,	O
1	int
,	O
10	int
,	O
102	int
,	O
102	int
,	O
4	int
,	O
9	int
,	O
102	int
,	O
102	int
,	O
102	int
,	O
102	int
,	O
79	int
,	O
83	int
,	O
87	int
,	O
1	int
,	O
89	int
,	O
93	int
,	O
97	int
}	O
;	O
static	O
yyconst	O
flex_int16_t	short
yy_def	array(short)
[	O
46	int
]	O
=	O
{	O
0	int
,	O
39	int
,	O
39	int
,	O
40	int
,	O
40	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
41	int
,	O
38	int
,	O
41	int
,	O
38	int
,	O
38	int
,	O
42	int
,	O
43	int
,	O
44	int
,	O
44	int
,	O
38	int
,	O
41	int
,	O
38	int
,	O
38	int
,	O
45	int
,	O
45	int
,	O
38	int
,	O
43	int
,	O
44	int
,	O
20	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
45	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
0	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
}	O
;	O
static	O
yyconst	O
flex_int16_t	short
yy_nxt	int
[	O
120	int
]	O
=	O
{	O
0	int
,	O
38	int
,	O
38	int
,	O
7	int
,	O
8	int
,	O
25	int
,	O
9	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
10	int
,	O
33	int
,	O
31	int
,	O
37	int
,	O
11	int
,	O
7	int
,	O
8	int
,	O
33	int
,	O
9	int
,	O
37	int
,	O
35	int
,	O
31	int
,	O
27	int
,	O
10	int
,	O
36	int
,	O
35	int
,	O
23	int
,	O
11	int
,	O
13	int
,	O
14	int
,	O
27	int
,	O
26	int
,	O
24	int
,	O
23	int
,	O
23	int
,	O
21	int
,	O
38	int
,	O
13	int
,	O
13	int
,	O
14	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
13	int
,	O
15	int
,	O
38	int
,	O
38	int
,	O
16	int
,	O
17	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
18	int
,	O
19	int
,	O
38	int
,	O
19	int
,	O
20	int
,	O
27	int
,	O
30	int
,	O
38	int
,	O
31	int
,	O
38	int
,	O
30	int
,	O
38	int
,	O
30	int
,	O
30	int
,	O
27	int
,	O
30	int
,	O
38	int
,	O
32	int
,	O
38	int
,	O
30	int
,	O
38	int
,	O
30	int
,	O
30	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
6	int
,	O
12	int
,	O
12	int
,	O
12	int
,	O
12	int
,	O
22	int
,	O
38	int
,	O
22	int
,	O
22	int
,	O
28	int
,	O
28	int
,	O
29	int
,	O
29	int
,	O
29	int
,	O
29	int
,	O
34	int
,	O
34	int
,	O
34	int
,	O
34	int
,	O
5	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
}	O
;	O
static	O
yyconst	O
flex_int16_t	short
yy_chk	array(short)
[	O
120	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
42	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
29	int
,	O
1	int
,	O
21	int
,	O
29	int
,	O
33	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
21	int
,	O
2	int
,	O
33	int
,	O
34	int
,	O
30	int
,	O
28	int
,	O
2	int
,	O
26	int
,	O
25	int
,	O
22	int
,	O
2	int
,	O
3	int
,	O
3	int
,	O
18	int
,	O
17	int
,	O
16	int
,	O
14	int
,	O
12	int
,	O
11	int
,	O
5	int
,	O
3	int
,	O
4	int
,	O
4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
4	int
,	O
10	int
,	O
0	int
,	O
0	int
,	O
10	int
,	O
10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
10	int
,	O
10	int
,	O
0	int
,	O
10	int
,	O
10	int
,	O
19	int
,	O
19	int
,	O
0	int
,	O
19	int
,	O
0	int
,	O
19	int
,	O
0	int
,	O
19	int
,	O
19	int
,	O
20	int
,	O
20	int
,	O
0	int
,	O
20	int
,	O
0	int
,	O
20	int
,	O
0	int
,	O
20	int
,	O
20	int
,	O
39	int
,	O
39	int
,	O
39	int
,	O
39	int
,	O
40	int
,	O
40	int
,	O
40	int
,	O
40	int
,	O
41	int
,	O
0	int
,	O
41	int
,	O
41	int
,	O
43	int
,	O
43	int
,	O
44	int
,	O
44	int
,	O
44	int
,	O
44	int
,	O
45	int
,	O
45	int
,	O
45	int
,	O
45	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
,	O
38	int
}	O
;	O
static	O
yy_state_type	int
yy_last_accepting_state	int
;	O
static	O
char	O
*	O
yy_last_accepting_cpos	*(char)
;	O
extern	O
int	O
yy_flex_debug	O
;	O
int	O
yy_flex_debug	O
=	O
1	int
;	O
static	O
yyconst	O
flex_int16_t	short
yy_rule_linenum	array(short)
[	O
15	int
]	O
=	O
{	O
0	int
,	O
267	int
,	O
268	int
,	O
269	int
,	O
270	int
,	O
284	int
,	O
295	int
,	O
303	int
,	O
304	int
,	O
316	int
,	O
317	int
,	O
318	int
,	O
321	int
,	O
325	int
,	O
326	int
}	O
;	O
char	O
*	O
yytext	O
;	O
static	O
char	O
const	O
*	O
input_buf	*(char)
;	O
static	O
size_t	long
input_len	long
;	O
static	O
unsigned	O
token_beg	int
;	O
static	O
unsigned	O
token_end	int
;	O
static	O
char	O
*	O
textspace	*(char)
;	O
static	O
size_t	long
textsize	long
;	O
static	O
size_t	long
textpos	long
;	O
static	O
size_t	long
textstart	long
;	O
static	O
dico_list_t	*(struct)
tagstk	*(struct)
;	O
static	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
;	O
static	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
errbuf	array(struct(array(long),int,struct(array(long))))
;	O
static	O
void	O
memerr	(*(char))->(void)
(	O
const	O
char	O
*	O
text	*(char)
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
ENOMEM	int
,	O
"%s"	*(char)
,	O
text	*(char)
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
errbuf	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
static	O
int	O
retstate	int
;	O
static	O
char	O
*	O
endtag	*(char)
;	O
static	O
void	O
text_add_str	(*(char),long)->(void)
(	O
char	O
const	O
*	O
s	*(char)
,	O
size_t	long
l	long
)	O
{	O
size_t	long
rest	long
=	O
textsize	long
-	O
textpos	long
;	O
if	O
(	O
rest	long
<	O
l	long
)	O
{	O
size_t	long
nsize	long
=	O
2	int
*	O
textsize	long
;	O
char	O
*	O
newp	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
textspace	*(char)
,	O
nsize	long
)	O
;	O
if	O
(	O
!	O
newp	*(char)
)	O
memerr	(*(char))->(void)
(	O
"text_add"	*(char)
)	O
;	O
textspace	*(char)
=	O
newp	*(char)
;	O
textsize	long
=	O
nsize	long
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
textspace	*(char)
+	O
textpos	long
,	O
s	*(char)
,	O
l	long
)	O
;	O
textpos	long
+=	O
l	long
;	O
}	O
static	O
void	O
text_add_chr	(int)->(void)
(	O
int	O
ch	int
)	O
{	O
char	O
c	int
=	O
ch	int
;	O
text_add_str	(*(char),long)->(void)
(	O
&	O
c	int
,	O
1	int
)	O
;	O
}	O
static	O
size_t	long
text_segment_finish	()->(long)
(	O
)	O
{	O
size_t	long
ret	*(*(char))
=	O
textstart	long
;	O
text_add_chr	(int)->(void)
(	O
0	int
)	O
;	O
textstart	long
=	O
textpos	long
;	O
return	O
ret	*(*(char))
;	O
}	O
static	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
alloc_tag	(*(char),long)->(*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*`,enum(int,int,int),*`,union`)),union(*(char),long,*(struct`)))))
(	O
const	O
char	O
*	O
text	*(char)
,	O
size_t	long
len	int
)	O
{	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
;	O
struct	O
wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct`),*(struct`),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)
ws	*(int)
;	O
if	O
(	O
wordsplit_len	(*(char),long,*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)),int)->(int)
(	O
text	*(char)
,	O
len	int
,	O
&	O
ws	*(int)
,	O
WRDSF_DEFFLAGS	O
&	O
~	O
WRDSF_CESCAPES	int
)	O
)	O
{	O
dico_log	(int,int,*(char))->(void)
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"cannot parse line %.*s: %s"	*(char)
)	O
,	O
(	O
int	O
)	O
len	int
,	O
text	*(char)
,	O
wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(*(char))
(	O
&	O
ws	*(int)
)	O
)	O
;	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
errbuf	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
)	O
;	O
if	O
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
{	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_parmc	long
=	O
ws	*(int)
.	O
ws_wordc	long
;	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_parmv	*(*(char))
=	O
ws	*(int)
.	O
ws_wordv	*(*(char))
;	O
ws	*(int)
.	O
ws_wordc	long
=	O
0	int
;	O
ws	*(int)
.	O
ws_wordv	*(*(char))
=	O
NULL	O
;	O
}	O
else	O
memerr	(*(char))->(void)
(	O
"gcide alloc_tag"	*(char)
)	O
;	O
wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(struct),*(struct),int)))->(void)
(	O
&	O
ws	*(int)
)	O
;	O
return	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
;	O
}	O
static	O
int	O
free_tag	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
item	*(void)
;	O
if	O
(	O
!	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
return	O
0	int
;	O
switch	O
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_type	enum(int,int,int)
)	O
{	O
case	O
gcide_content_unspecified	int
:	O
case	O
gcide_content_text	int
:	O
break	O
;	O
case	O
gcide_content_taglist	int
:	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
taglist	*(struct)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
append_tag	(*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*`,enum(int,int,int),*`,union`)),union(*(char),long,*(struct`)))))->(void)
(	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
{	O
dico_list_t	*(struct)
list	array(*(struct))
;	O
switch	O
(	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_type	enum(int,int,int)
)	O
{	O
case	O
gcide_content_unspecified	int
:	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
list	array(*(struct))
)	O
{	O
free	(*(void))->(void)
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
;	O
memerr	(*(char))->(void)
(	O
"append_tag"	*(char)
)	O
;	O
}	O
dico_list_set_free_item	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
list	array(*(struct))
,	O
free_tag	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_type	enum(int,int,int)
=	O
gcide_content_taglist	int
;	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
taglist	*(struct)
=	O
list	array(*(struct))
;	O
break	O
;	O
case	O
gcide_content_text	int
:	O
{	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
subtag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
)	O
;	O
if	O
(	O
!	O
subtag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
memerr	(*(char))->(void)
(	O
"append_tag"	*(char)
)	O
;	O
subtag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_type	enum(int,int,int)
=	O
gcide_content_text	int
;	O
subtag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
textpos	long
=	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
textpos	long
;	O
list	array(*(struct))
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
list	array(*(struct))
)	O
{	O
free	(*(void))->(void)
(	O
subtag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
;	O
free	(*(void))->(void)
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
;	O
memerr	(*(char))->(void)
(	O
"append_tag"	*(char)
)	O
;	O
}	O
dico_list_set_free_item	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
list	array(*(struct))
,	O
free_tag	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
dico_list_append	(*(struct),*(void))->(int)
(	O
list	array(*(struct))
,	O
subtag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
;	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_type	enum(int,int,int)
=	O
gcide_content_taglist	int
;	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
taglist	*(struct)
=	O
list	array(*(struct))
;	O
break	O
;	O
}	O
case	O
gcide_content_taglist	int
:	O
break	O
;	O
}	O
dico_list_append	(*(struct),*(void))->(int)
(	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
taglist	*(struct)
,	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
;	O
}	O
static	O
int	O
in_grk	int
;	O
static	O
void	O
push_tag	(*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*`,enum(int,int,int),*`,union`)),union(*(char),long,*(struct`)))))->(void)
(	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
{	O
append_tag	(*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*`,enum(int,int,int),*`,union`)),union(*(char),long,*(struct`)))))->(void)
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
;	O
dico_list_push	O
(	O
tagstk	*(struct)
,	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
;	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
;	O
in_grk	int
=	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_parmc	long
&&	O
strcmp	(*(char),*(char))->(int)
(	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_name	O
,	O
"grk"	*(char)
)	O
==	O
0	int
;	O
}	O
static	O
void	O
pop_tag	(*(char),long)->(void)
(	O
const	O
char	O
*	O
tagstr	*(char)
,	O
size_t	long
taglen	long
)	O
{	O
size_t	long
len	int
;	O
for	O
(	O
len	int
=	O
0	int
;	O
len	int
<	O
taglen	long
;	O
len	int
++	O
)	O
if	O
(	O
tagstr	*(char)
[	O
len	int
]	O
==	O
' '	O
||	O
tagstr	*(char)
[	O
len	int
]	O
==	O
'\t'	O
)	O
break	O
;	O
if	O
(	O
len	int
==	O
3	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
tagstr	*(char)
,	O
"grk"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
in_grk	int
=	O
0	int
;	O
if	O
(	O
TAG_HAS_NAME	O
(	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
&&	O
strlen	(*(char))->(long)
(	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_name	O
)	O
==	O
len	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_name	O
,	O
tagstr	*(char)
,	O
len	int
)	O
==	O
0	int
)	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
dico_list_pop	(*(struct))->(*(void))
(	O
tagstk	*(struct)
)	O
;	O
else	O
dico_log	(int,int,*(char))->(void)
(	O
L_WARN	int
,	O
0	int
,	O
"%u: unexpected close tag"	*(char)
,	O
token_beg	int
)	O
;	O
}	O
static	O
int	O
yy_init_globals	()->(int)
(	O
void	O
)	O
;	O
int	O
yylex_destroy	O
(	O
void	O
)	O
;	O
int	O
yyget_debug	O
(	O
void	O
)	O
;	O
void	O
yyset_debug	O
(	O
int	O
debug_flag	int
)	O
;	O
YY_EXTRA_TYPE	O
yyget_extra	O
(	O
void	O
)	O
;	O
void	O
yyset_extra	O
(	O
YY_EXTRA_TYPE	O
user_defined	*(void)
)	O
;	O
FILE	struct
*	O
yyget_in	O
(	O
void	O
)	O
;	O
void	O
yyset_in	O
(	O
FILE	struct
*	O
in_str	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
FILE	struct
*	O
yyget_out	O
(	O
void	O
)	O
;	O
void	O
yyset_out	O
(	O
FILE	struct
*	O
out_str	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
yy_size_t	long
yyget_leng	O
(	O
void	O
)	O
;	O
char	O
*	O
yyget_text	O
(	O
void	O
)	O
;	O
int	O
yyget_lineno	O
(	O
void	O
)	O
;	O
void	O
yyset_lineno	O
(	O
int	O
line_number	int
)	O
;	O
extern	O
int	O
yywrap	O
(	O
void	O
)	O
;	O
extern	O
int	O
yylex	O
(	O
void	O
)	O
;	O
YY_DECL	O
{	O
register	O
yy_state_type	int
yy_current_state	int
;	O
register	O
char	O
*	O
yy_cp	*(char)
,	O
*	O
yy_bp	*(char)
;	O
register	O
int	O
yy_act	int
;	O
if	O
(	O
!	O
(	O
yy_init	int
)	O
)	O
{	O
(	O
yy_init	int
)	O
=	O
1	int
;	O
if	O
(	O
!	O
(	O
yy_start	int
)	O
)	O
(	O
yy_start	int
)	O
=	O
1	int
;	O
if	O
(	O
!	O
yyin	O
)	O
yyin	O
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
if	O
(	O
!	O
yyout	O
)	O
yyout	O
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
if	O
(	O
!	O
YY_CURRENT_BUFFER	O
)	O
{	O
yyensure_buffer_stack	()->(void)
(	O
)	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
=	O
yy_create_buffer	O
(	O
yyin	O
,	O
YY_BUF_SIZE	int
)	O
;	O
}	O
yy_load_buffer_state	O
(	O
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
yy_cp	*(char)
=	O
(	O
yy_c_buf_p	*(char)
)	O
;	O
*	O
yy_cp	*(char)
=	O
(	O
yy_hold_char	char
)	O
;	O
yy_bp	*(char)
=	O
yy_cp	*(char)
;	O
yy_current_state	int
=	O
(	O
yy_start	int
)	O
;	O
yy_match	O
:	O
do	O
{	O
register	O
YY_CHAR	char
yy_c	char
=	O
yy_ec	array(int)
[	O
YY_SC_TO_UI	O
(	O
*	O
yy_cp	*(char)
)	O
]	O
;	O
if	O
(	O
yy_accept	array(short)
[	O
yy_current_state	int
]	O
)	O
{	O
(	O
yy_last_accepting_state	int
)	O
=	O
yy_current_state	int
;	O
(	O
yy_last_accepting_cpos	*(char)
)	O
=	O
yy_cp	*(char)
;	O
}	O
while	O
(	O
yy_chk	array(short)
[	O
yy_base	array(short)
[	O
yy_current_state	int
]	O
+	O
yy_c	char
]	O
!=	O
yy_current_state	int
)	O
{	O
yy_current_state	int
=	O
(	O
int	O
)	O
yy_def	array(short)
[	O
yy_current_state	int
]	O
;	O
if	O
(	O
yy_current_state	int
>=	O
39	int
)	O
yy_c	char
=	O
yy_meta	array(int)
[	O
(	O
unsigned	O
int	O
)	O
yy_c	char
]	O
;	O
}	O
yy_current_state	int
=	O
yy_nxt	int
[	O
yy_base	array(short)
[	O
yy_current_state	int
]	O
+	O
(	O
unsigned	O
int	O
)	O
yy_c	char
]	O
;	O
++	O
yy_cp	*(char)
;	O
}	O
while	O
(	O
yy_base	array(short)
[	O
yy_current_state	int
]	O
!=	O
102	int
)	O
;	O
yy_find_action	O
:	O
yy_act	int
=	O
yy_accept	array(short)
[	O
yy_current_state	int
]	O
;	O
if	O
(	O
yy_act	int
==	O
0	int
)	O
{	O
yy_cp	*(char)
=	O
(	O
yy_last_accepting_cpos	*(char)
)	O
;	O
yy_current_state	int
=	O
(	O
yy_last_accepting_state	int
)	O
;	O
yy_act	int
=	O
yy_accept	array(short)
[	O
yy_current_state	int
]	O
;	O
}	O
YY_DO_BEFORE_ACTION	O
;	O
do_action	O
:	O
if	O
(	O
yy_flex_debug	O
)	O
{	O
if	O
(	O
yy_act	int
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"--scanner backing up\n"	*(char)
)	O
;	O
else	O
if	O
(	O
yy_act	int
<	O
15	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"--accepting rule at line %ld (\"%s\")\n"	*(char)
,	O
(	O
long	O
)	O
yy_rule_linenum	array(short)
[	O
yy_act	int
]	O
,	O
yytext	O
)	O
;	O
else	O
if	O
(	O
yy_act	int
==	O
15	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"--accepting default rule (\"%s\")\n"	*(char)
,	O
yytext	O
)	O
;	O
else	O
if	O
(	O
yy_act	int
==	O
16	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"--(end of buffer or a NUL)\n"	*(char)
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"--EOF (start condition %d)\n"	*(char)
,	O
YY_START	O
)	O
;	O
}	O
switch	O
(	O
yy_act	int
)	O
{	O
case	O
0	int
:	O
*	O
yy_cp	*(char)
=	O
(	O
yy_hold_char	char
)	O
;	O
yy_cp	*(char)
=	O
(	O
yy_last_accepting_cpos	*(char)
)	O
;	O
yy_current_state	int
=	O
(	O
yy_last_accepting_state	int
)	O
;	O
goto	O
yy_find_action	O
;	O
case	O
1	int
:	O
YY_RULE_SETUP	O
BEGIN_COMMENT	O
(	O
"-->"	*(char)
)	O
;	O
YY_BREAK	O
case	O
2	int
:	O
YY_RULE_SETUP	O
BEGIN_COMMENT	O
(	O
"!>"	*(char)
)	O
;	O
YY_BREAK	O
case	O
3	int
:	O
YY_RULE_SETUP	O
;	O
YY_BREAK	O
case	O
4	int
:	O
YY_RULE_SETUP	O
{	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
;	O
if	O
(	O
text_segment_length	O
(	O
)	O
)	O
{	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
)	O
;	O
if	O
(	O
!	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
memerr	(*(char))->(void)
(	O
"gcide lexer"	*(char)
)	O
;	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_type	enum(int,int,int)
=	O
gcide_content_text	int
;	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
textpos	long
=	O
text_segment_finish	()->(long)
(	O
)	O
;	O
append_tag	(*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*`,enum(int,int,int),*`,union`)),union(*(char),long,*(struct`)))))->(void)
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
;	O
}	O
push_tag	(*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*`,enum(int,int,int),*`,union`)),union(*(char),long,*(struct`)))))->(void)
(	O
alloc_tag	(*(char),long)->(*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*`,enum(int,int,int),*`,union`)),union(*(char),long,*(struct`)))))
(	O
yytext	O
+	O
1	int
,	O
yyleng	O
-	O
2	int
)	O
)	O
;	O
}	O
YY_BREAK	O
case	O
5	int
:	O
YY_RULE_SETUP	O
{	O
if	O
(	O
text_segment_length	O
(	O
)	O
)	O
{	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
)	O
;	O
if	O
(	O
!	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
memerr	(*(char))->(void)
(	O
"gcide lexer"	*(char)
)	O
;	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_type	enum(int,int,int)
=	O
gcide_content_text	int
;	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
textpos	long
=	O
text_segment_finish	()->(long)
(	O
)	O
;	O
append_tag	(*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*`,enum(int,int,int),*`,union`)),union(*(char),long,*(struct`)))))->(void)
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
;	O
}	O
pop_tag	(*(char),long)->(void)
(	O
yytext	O
+	O
2	int
,	O
yyleng	O
-	O
3	int
)	O
;	O
}	O
YY_BREAK	O
case	O
6	int
:	O
YY_RULE_SETUP	O
{	O
char	O
const	O
*	O
s	*(char)
=	O
gcide_entity_to_utf8	(*(char))->(*(char))
(	O
yytext	O
)	O
;	O
if	O
(	O
s	*(char)
)	O
text_add_str	(*(char),long)->(void)
(	O
s	*(char)
,	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
)	O
;	O
else	O
dico_log	(int,int,*(char))->(void)
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"%u: unrecognized entity: %s"	*(char)
)	O
,	O
token_beg	int
,	O
yytext	O
)	O
;	O
}	O
YY_BREAK	O
case	O
7	int
:	O
YY_RULE_SETUP	O
{	O
if	O
(	O
in_grk	int
)	O
text_add_chr	(int)->(void)
(	O
yytext	O
[	O
0	int
]	O
)	O
;	O
}	O
YY_BREAK	O
case	O
8	int
:	O
YY_RULE_SETUP	O
{	O
char	O
const	O
*	O
s	*(char)
=	O
gcide_escape_to_utf8	(*(char))->(*(char))
(	O
yytext	O
+	O
2	int
)	O
;	O
if	O
(	O
s	*(char)
)	O
text_add_str	(*(char),long)->(void)
(	O
s	*(char)
,	O
strlen	(*(char))->(long)
(	O
s	*(char)
)	O
)	O
;	O
else	O
{	O
text_add_str	(*(char),long)->(void)
(	O
yytext	O
,	O
yyleng	O
)	O
;	O
dico_log	(int,int,*(char))->(void)
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"%u: unknown character sequence %s"	*(char)
)	O
,	O
token_beg	int
,	O
yytext	O
)	O
;	O
}	O
}	O
YY_BREAK	O
case	O
9	int
:	O
YY_RULE_SETUP	O
;	O
YY_BREAK	O
case	O
10	int
:	O
YY_RULE_SETUP	O
text_add_str	(*(char),long)->(void)
(	O
yytext	O
,	O
yyleng	O
)	O
;	O
YY_BREAK	O
case	O
11	int
:	O
YY_RULE_SETUP	O
text_add_str	(*(char),long)->(void)
(	O
yytext	O
,	O
yyleng	O
)	O
;	O
YY_BREAK	O
case	O
12	int
:	O
YY_RULE_SETUP	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
yytext	O
,	O
endtag	*(char)
)	O
==	O
0	int
)	O
BEGIN	O
(	O
retstate	int
)	O
;	O
}	O
YY_BREAK	O
case	O
13	int
:	O
YY_RULE_SETUP	O
;	O
YY_BREAK	O
case	O
14	int
:	O
YY_RULE_SETUP	O
;	O
YY_BREAK	O
case	O
15	int
:	O
YY_RULE_SETUP	O
ECHO	O
;	O
YY_BREAK	O
case	O
YY_STATE_EOF	O
(	O
INITIAL	int
)	O
:	O
case	O
YY_STATE_EOF	O
(	O
COMMENT	int
)	O
:	O
yyterminate	O
(	O
)	O
;	O
case	O
YY_END_OF_BUFFER	int
:	O
{	O
int	O
yy_amount_of_matched_text	int
=	O
(	O
int	O
)	O
(	O
yy_cp	*(char)
-	O
(	O
yytext_ptr	O
)	O
)	O
-	O
1	int
;	O
*	O
yy_cp	*(char)
=	O
(	O
yy_hold_char	char
)	O
;	O
YY_RESTORE_YY_MORE_OFFSET	O
if	O
(	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_buffer_status	int
==	O
YY_BUFFER_NEW	int
)	O
{	O
(	O
yy_n_chars	long
)	O
=	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_n_chars	long
;	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
yyin	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_buffer_status	int
=	O
YY_BUFFER_NORMAL	int
;	O
}	O
if	O
(	O
(	O
yy_c_buf_p	*(char)
)	O
<=	O
&	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_ch_buf	*(char)
[	O
(	O
yy_n_chars	long
)	O
]	O
)	O
{	O
yy_state_type	int
yy_next_state	int
;	O
(	O
yy_c_buf_p	*(char)
)	O
=	O
(	O
yytext_ptr	O
)	O
+	O
yy_amount_of_matched_text	int
;	O
yy_current_state	int
=	O
yy_get_previous_state	()->(int)
(	O
)	O
;	O
yy_next_state	int
=	O
yy_try_NUL_trans	(int)->(int)
(	O
yy_current_state	int
)	O
;	O
yy_bp	*(char)
=	O
(	O
yytext_ptr	O
)	O
+	O
YY_MORE_ADJ	int
;	O
if	O
(	O
yy_next_state	int
)	O
{	O
yy_cp	*(char)
=	O
++	O
(	O
yy_c_buf_p	*(char)
)	O
;	O
yy_current_state	int
=	O
yy_next_state	int
;	O
goto	O
yy_match	O
;	O
}	O
else	O
{	O
yy_cp	*(char)
=	O
(	O
yy_c_buf_p	*(char)
)	O
;	O
goto	O
yy_find_action	O
;	O
}	O
}	O
else	O
switch	O
(	O
yy_get_next_buffer	()->(int)
(	O
)	O
)	O
{	O
case	O
EOB_ACT_END_OF_FILE	int
:	O
{	O
(	O
yy_did_buffer_switch_on_eof	int
)	O
=	O
0	int
;	O
if	O
(	O
yywrap	O
(	O
)	O
)	O
{	O
(	O
yy_c_buf_p	*(char)
)	O
=	O
(	O
yytext_ptr	O
)	O
+	O
YY_MORE_ADJ	int
;	O
yy_act	int
=	O
YY_STATE_EOF	O
(	O
YY_START	O
)	O
;	O
goto	O
do_action	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
yy_did_buffer_switch_on_eof	int
)	O
)	O
YY_NEW_FILE	O
;	O
}	O
break	O
;	O
}	O
case	O
EOB_ACT_CONTINUE_SCAN	int
:	O
(	O
yy_c_buf_p	*(char)
)	O
=	O
(	O
yytext_ptr	O
)	O
+	O
yy_amount_of_matched_text	int
;	O
yy_current_state	int
=	O
yy_get_previous_state	()->(int)
(	O
)	O
;	O
yy_cp	*(char)
=	O
(	O
yy_c_buf_p	*(char)
)	O
;	O
yy_bp	*(char)
=	O
(	O
yytext_ptr	O
)	O
+	O
YY_MORE_ADJ	int
;	O
goto	O
yy_match	O
;	O
case	O
EOB_ACT_LAST_MATCH	int
:	O
(	O
yy_c_buf_p	*(char)
)	O
=	O
&	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_ch_buf	*(char)
[	O
(	O
yy_n_chars	long
)	O
]	O
;	O
yy_current_state	int
=	O
yy_get_previous_state	()->(int)
(	O
)	O
;	O
yy_cp	*(char)
=	O
(	O
yy_c_buf_p	*(char)
)	O
;	O
yy_bp	*(char)
=	O
(	O
yytext_ptr	O
)	O
+	O
YY_MORE_ADJ	int
;	O
goto	O
yy_find_action	O
;	O
}	O
break	O
;	O
}	O
default	O
:	O
YY_FATAL_ERROR	O
(	O
"fatal flex scanner internal error--no action found"	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
int	O
yy_get_next_buffer	()->(int)
(	O
void	O
)	O
{	O
register	O
char	O
*	O
dest	*(char)
=	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_ch_buf	*(char)
;	O
register	O
char	O
*	O
source	*(char)
=	O
(	O
yytext_ptr	O
)	O
;	O
register	O
int	O
number_to_move	int
,	O
i	int
;	O
int	O
ret_val	int
;	O
if	O
(	O
(	O
yy_c_buf_p	*(char)
)	O
>	O
&	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_ch_buf	*(char)
[	O
(	O
yy_n_chars	long
)	O
+	O
1	int
]	O
)	O
YY_FATAL_ERROR	O
(	O
"fatal flex scanner internal error--end of buffer missed"	*(char)
)	O
;	O
if	O
(	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_fill_buffer	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
yy_c_buf_p	*(char)
)	O
-	O
(	O
yytext_ptr	O
)	O
-	O
YY_MORE_ADJ	int
==	O
1	int
)	O
{	O
return	O
EOB_ACT_END_OF_FILE	int
;	O
}	O
else	O
{	O
return	O
EOB_ACT_LAST_MATCH	int
;	O
}	O
}	O
number_to_move	int
=	O
(	O
int	O
)	O
(	O
(	O
yy_c_buf_p	*(char)
)	O
-	O
(	O
yytext_ptr	O
)	O
)	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
number_to_move	int
;	O
++	O
i	int
)	O
*	O
(	O
dest	*(char)
++	O
)	O
=	O
*	O
(	O
source	*(char)
++	O
)	O
;	O
if	O
(	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_buffer_status	int
==	O
YY_BUFFER_EOF_PENDING	int
)	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_n_chars	long
=	O
(	O
yy_n_chars	long
)	O
=	O
0	int
;	O
else	O
{	O
yy_size_t	long
num_to_read	long
=	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_buf_size	long
-	O
number_to_move	int
-	O
1	int
;	O
while	O
(	O
num_to_read	long
<=	O
0	int
)	O
{	O
YY_BUFFER_STATE	*(struct)
b	*(struct)
=	O
YY_CURRENT_BUFFER_LVALUE	O
;	O
int	O
yy_c_buf_p_offset	int
=	O
(	O
int	O
)	O
(	O
(	O
yy_c_buf_p	*(char)
)	O
-	O
b	*(struct)
->	O
yy_ch_buf	*(char)
)	O
;	O
if	O
(	O
b	*(struct)
->	O
yy_is_our_buffer	int
)	O
{	O
yy_size_t	long
new_size	long
=	O
b	*(struct)
->	O
yy_buf_size	long
*	O
2	int
;	O
if	O
(	O
new_size	long
<=	O
0	int
)	O
b	*(struct)
->	O
yy_buf_size	long
+=	O
b	*(struct)
->	O
yy_buf_size	long
/	O
8	int
;	O
else	O
b	*(struct)
->	O
yy_buf_size	long
*=	O
2	int
;	O
b	*(struct)
->	O
yy_ch_buf	*(char)
=	O
(	O
char	O
*	O
)	O
yyrealloc	O
(	O
(	O
void	O
*	O
)	O
b	*(struct)
->	O
yy_ch_buf	*(char)
,	O
b	*(struct)
->	O
yy_buf_size	long
+	O
2	int
)	O
;	O
}	O
else	O
b	*(struct)
->	O
yy_ch_buf	*(char)
=	O
0	int
;	O
if	O
(	O
!	O
b	*(struct)
->	O
yy_ch_buf	*(char)
)	O
YY_FATAL_ERROR	O
(	O
"fatal error - scanner input buffer overflow"	*(char)
)	O
;	O
(	O
yy_c_buf_p	*(char)
)	O
=	O
&	O
b	*(struct)
->	O
yy_ch_buf	*(char)
[	O
yy_c_buf_p_offset	int
]	O
;	O
num_to_read	long
=	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_buf_size	long
-	O
number_to_move	int
-	O
1	int
;	O
}	O
if	O
(	O
num_to_read	long
>	O
YY_READ_BUF_SIZE	int
)	O
num_to_read	long
=	O
YY_READ_BUF_SIZE	int
;	O
YY_INPUT	O
(	O
(	O
&	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_ch_buf	*(char)
[	O
number_to_move	int
]	O
)	O
,	O
(	O
yy_n_chars	long
)	O
,	O
num_to_read	long
)	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_n_chars	long
=	O
(	O
yy_n_chars	long
)	O
;	O
}	O
if	O
(	O
(	O
yy_n_chars	long
)	O
==	O
0	int
)	O
{	O
if	O
(	O
number_to_move	int
==	O
YY_MORE_ADJ	int
)	O
{	O
ret_val	int
=	O
EOB_ACT_END_OF_FILE	int
;	O
yyrestart	O
(	O
yyin	O
)	O
;	O
}	O
else	O
{	O
ret_val	int
=	O
EOB_ACT_LAST_MATCH	int
;	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_buffer_status	int
=	O
YY_BUFFER_EOF_PENDING	int
;	O
}	O
}	O
else	O
ret_val	int
=	O
EOB_ACT_CONTINUE_SCAN	int
;	O
if	O
(	O
(	O
yy_size_t	long
)	O
(	O
(	O
yy_n_chars	long
)	O
+	O
number_to_move	int
)	O
>	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_buf_size	long
)	O
{	O
yy_size_t	long
new_size	long
=	O
(	O
yy_n_chars	long
)	O
+	O
number_to_move	int
+	O
(	O
(	O
yy_n_chars	long
)	O
>>	O
1	int
)	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_ch_buf	*(char)
=	O
(	O
char	O
*	O
)	O
yyrealloc	O
(	O
(	O
void	O
*	O
)	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_ch_buf	*(char)
,	O
new_size	long
)	O
;	O
if	O
(	O
!	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_ch_buf	*(char)
)	O
YY_FATAL_ERROR	O
(	O
"out of dynamic memory in yy_get_next_buffer()"	*(char)
)	O
;	O
}	O
(	O
yy_n_chars	long
)	O
+=	O
number_to_move	int
;	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_ch_buf	*(char)
[	O
(	O
yy_n_chars	long
)	O
]	O
=	O
YY_END_OF_BUFFER_CHAR	int
;	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_ch_buf	*(char)
[	O
(	O
yy_n_chars	long
)	O
+	O
1	int
]	O
=	O
YY_END_OF_BUFFER_CHAR	int
;	O
(	O
yytext_ptr	O
)	O
=	O
&	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_ch_buf	*(char)
[	O
0	int
]	O
;	O
return	O
ret_val	int
;	O
}	O
static	O
yy_state_type	int
yy_get_previous_state	()->(int)
(	O
void	O
)	O
{	O
register	O
yy_state_type	int
yy_current_state	int
;	O
register	O
char	O
*	O
yy_cp	*(char)
;	O
yy_current_state	int
=	O
(	O
yy_start	int
)	O
;	O
for	O
(	O
yy_cp	*(char)
=	O
(	O
yytext_ptr	O
)	O
+	O
YY_MORE_ADJ	int
;	O
yy_cp	*(char)
<	O
(	O
yy_c_buf_p	*(char)
)	O
;	O
++	O
yy_cp	*(char)
)	O
{	O
register	O
YY_CHAR	char
yy_c	char
=	O
(	O
*	O
yy_cp	*(char)
?	O
yy_ec	array(int)
[	O
YY_SC_TO_UI	O
(	O
*	O
yy_cp	*(char)
)	O
]	O
:	O
1	int
)	O
;	O
if	O
(	O
yy_accept	array(short)
[	O
yy_current_state	int
]	O
)	O
{	O
(	O
yy_last_accepting_state	int
)	O
=	O
yy_current_state	int
;	O
(	O
yy_last_accepting_cpos	*(char)
)	O
=	O
yy_cp	*(char)
;	O
}	O
while	O
(	O
yy_chk	array(short)
[	O
yy_base	array(short)
[	O
yy_current_state	int
]	O
+	O
yy_c	char
]	O
!=	O
yy_current_state	int
)	O
{	O
yy_current_state	int
=	O
(	O
int	O
)	O
yy_def	array(short)
[	O
yy_current_state	int
]	O
;	O
if	O
(	O
yy_current_state	int
>=	O
39	int
)	O
yy_c	char
=	O
yy_meta	array(int)
[	O
(	O
unsigned	O
int	O
)	O
yy_c	char
]	O
;	O
}	O
yy_current_state	int
=	O
yy_nxt	int
[	O
yy_base	array(short)
[	O
yy_current_state	int
]	O
+	O
(	O
unsigned	O
int	O
)	O
yy_c	char
]	O
;	O
}	O
return	O
yy_current_state	int
;	O
}	O
static	O
yy_state_type	int
yy_try_NUL_trans	(int)->(int)
(	O
yy_state_type	int
yy_current_state	int
)	O
{	O
register	O
int	O
yy_is_jam	int
;	O
register	O
char	O
*	O
yy_cp	*(char)
=	O
(	O
yy_c_buf_p	*(char)
)	O
;	O
register	O
YY_CHAR	char
yy_c	char
=	O
1	int
;	O
if	O
(	O
yy_accept	array(short)
[	O
yy_current_state	int
]	O
)	O
{	O
(	O
yy_last_accepting_state	int
)	O
=	O
yy_current_state	int
;	O
(	O
yy_last_accepting_cpos	*(char)
)	O
=	O
yy_cp	*(char)
;	O
}	O
while	O
(	O
yy_chk	array(short)
[	O
yy_base	array(short)
[	O
yy_current_state	int
]	O
+	O
yy_c	char
]	O
!=	O
yy_current_state	int
)	O
{	O
yy_current_state	int
=	O
(	O
int	O
)	O
yy_def	array(short)
[	O
yy_current_state	int
]	O
;	O
if	O
(	O
yy_current_state	int
>=	O
39	int
)	O
yy_c	char
=	O
yy_meta	array(int)
[	O
(	O
unsigned	O
int	O
)	O
yy_c	char
]	O
;	O
}	O
yy_current_state	int
=	O
yy_nxt	int
[	O
yy_base	array(short)
[	O
yy_current_state	int
]	O
+	O
(	O
unsigned	O
int	O
)	O
yy_c	char
]	O
;	O
yy_is_jam	int
=	O
(	O
yy_current_state	int
==	O
38	int
)	O
;	O
return	O
yy_is_jam	int
?	O
0	int
:	O
yy_current_state	int
;	O
}	O
void	O
yyrestart	O
(	O
FILE	struct
*	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
if	O
(	O
!	O
YY_CURRENT_BUFFER	O
)	O
{	O
yyensure_buffer_stack	()->(void)
(	O
)	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
=	O
yy_create_buffer	O
(	O
yyin	O
,	O
YY_BUF_SIZE	int
)	O
;	O
}	O
yy_init_buffer	O
(	O
YY_CURRENT_BUFFER	O
,	O
input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
yy_load_buffer_state	O
(	O
)	O
;	O
}	O
void	O
yy_switch_to_buffer	O
(	O
YY_BUFFER_STATE	*(struct)
new_buffer	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int))
)	O
{	O
yyensure_buffer_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
YY_CURRENT_BUFFER	O
==	O
new_buffer	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int))
)	O
return	O
;	O
if	O
(	O
YY_CURRENT_BUFFER	O
)	O
{	O
*	O
(	O
yy_c_buf_p	*(char)
)	O
=	O
(	O
yy_hold_char	char
)	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_buf_pos	*(char)
=	O
(	O
yy_c_buf_p	*(char)
)	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_n_chars	long
=	O
(	O
yy_n_chars	long
)	O
;	O
}	O
YY_CURRENT_BUFFER_LVALUE	O
=	O
new_buffer	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int))
;	O
yy_load_buffer_state	O
(	O
)	O
;	O
(	O
yy_did_buffer_switch_on_eof	int
)	O
=	O
1	int
;	O
}	O
static	O
void	O
yy_load_buffer_state	O
(	O
void	O
)	O
{	O
(	O
yy_n_chars	long
)	O
=	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_n_chars	long
;	O
(	O
yytext_ptr	O
)	O
=	O
(	O
yy_c_buf_p	*(char)
)	O
=	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_buf_pos	*(char)
;	O
yyin	O
=	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
(	O
yy_hold_char	char
)	O
=	O
*	O
(	O
yy_c_buf_p	*(char)
)	O
;	O
}	O
YY_BUFFER_STATE	*(struct)
yy_create_buffer	O
(	O
FILE	struct
*	O
file	*(char)
,	O
int	O
size	long
)	O
{	O
YY_BUFFER_STATE	*(struct)
b	*(struct)
;	O
b	*(struct)
=	O
(	O
YY_BUFFER_STATE	*(struct)
)	O
yyalloc	O
(	O
sizeof	O
(	O
struct	O
yy_buffer_state	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)
)	O
)	O
;	O
if	O
(	O
!	O
b	*(struct)
)	O
YY_FATAL_ERROR	O
(	O
"out of dynamic memory in yy_create_buffer()"	*(char)
)	O
;	O
b	*(struct)
->	O
yy_buf_size	long
=	O
size	long
;	O
b	*(struct)
->	O
yy_ch_buf	*(char)
=	O
(	O
char	O
*	O
)	O
yyalloc	O
(	O
b	*(struct)
->	O
yy_buf_size	long
+	O
2	int
)	O
;	O
if	O
(	O
!	O
b	*(struct)
->	O
yy_ch_buf	*(char)
)	O
YY_FATAL_ERROR	O
(	O
"out of dynamic memory in yy_create_buffer()"	*(char)
)	O
;	O
b	*(struct)
->	O
yy_is_our_buffer	int
=	O
1	int
;	O
yy_init_buffer	O
(	O
b	*(struct)
,	O
file	*(char)
)	O
;	O
return	O
b	*(struct)
;	O
}	O
void	O
yy_delete_buffer	O
(	O
YY_BUFFER_STATE	*(struct)
b	*(struct)
)	O
{	O
if	O
(	O
!	O
b	*(struct)
)	O
return	O
;	O
if	O
(	O
b	*(struct)
==	O
YY_CURRENT_BUFFER	O
)	O
YY_CURRENT_BUFFER_LVALUE	O
=	O
(	O
YY_BUFFER_STATE	*(struct)
)	O
0	int
;	O
if	O
(	O
b	*(struct)
->	O
yy_is_our_buffer	int
)	O
yyfree	O
(	O
(	O
void	O
*	O
)	O
b	*(struct)
->	O
yy_ch_buf	*(char)
)	O
;	O
yyfree	O
(	O
(	O
void	O
*	O
)	O
b	*(struct)
)	O
;	O
}	O
static	O
void	O
yy_init_buffer	O
(	O
YY_BUFFER_STATE	*(struct)
b	*(struct)
,	O
FILE	struct
*	O
file	*(char)
)	O
{	O
int	O
oerrno	int
=	O
errno	O
;	O
yy_flush_buffer	O
(	O
b	*(struct)
)	O
;	O
b	*(struct)
->	O
yy_input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
file	*(char)
;	O
b	*(struct)
->	O
yy_fill_buffer	int
=	O
1	int
;	O
if	O
(	O
b	*(struct)
!=	O
YY_CURRENT_BUFFER	O
)	O
{	O
b	*(struct)
->	O
yy_bs_lineno	int
=	O
1	int
;	O
b	*(struct)
->	O
yy_bs_column	int
=	O
0	int
;	O
}	O
b	*(struct)
->	O
yy_is_interactive	int
=	O
file	*(char)
?	O
(	O
isatty	(int)->(int)
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
)	O
>	O
0	int
)	O
:	O
0	int
;	O
errno	O
=	O
oerrno	int
;	O
}	O
void	O
yy_flush_buffer	O
(	O
YY_BUFFER_STATE	*(struct)
b	*(struct)
)	O
{	O
if	O
(	O
!	O
b	*(struct)
)	O
return	O
;	O
b	*(struct)
->	O
yy_n_chars	long
=	O
0	int
;	O
b	*(struct)
->	O
yy_ch_buf	*(char)
[	O
0	int
]	O
=	O
YY_END_OF_BUFFER_CHAR	int
;	O
b	*(struct)
->	O
yy_ch_buf	*(char)
[	O
1	int
]	O
=	O
YY_END_OF_BUFFER_CHAR	int
;	O
b	*(struct)
->	O
yy_buf_pos	*(char)
=	O
&	O
b	*(struct)
->	O
yy_ch_buf	*(char)
[	O
0	int
]	O
;	O
b	*(struct)
->	O
yy_at_bol	int
=	O
1	int
;	O
b	*(struct)
->	O
yy_buffer_status	int
=	O
YY_BUFFER_NEW	int
;	O
if	O
(	O
b	*(struct)
==	O
YY_CURRENT_BUFFER	O
)	O
yy_load_buffer_state	O
(	O
)	O
;	O
}	O
void	O
yypush_buffer_state	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))->(void)
(	O
YY_BUFFER_STATE	*(struct)
new_buffer	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int))
)	O
{	O
if	O
(	O
new_buffer	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int))
==	O
NULL	O
)	O
return	O
;	O
yyensure_buffer_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
YY_CURRENT_BUFFER	O
)	O
{	O
*	O
(	O
yy_c_buf_p	*(char)
)	O
=	O
(	O
yy_hold_char	char
)	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_buf_pos	*(char)
=	O
(	O
yy_c_buf_p	*(char)
)	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
->	O
yy_n_chars	long
=	O
(	O
yy_n_chars	long
)	O
;	O
}	O
if	O
(	O
YY_CURRENT_BUFFER	O
)	O
(	O
yy_buffer_stack_top	long
)	O
++	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
=	O
new_buffer	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int))
;	O
yy_load_buffer_state	O
(	O
)	O
;	O
(	O
yy_did_buffer_switch_on_eof	int
)	O
=	O
1	int
;	O
}	O
void	O
yypop_buffer_state	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
!	O
YY_CURRENT_BUFFER	O
)	O
return	O
;	O
yy_delete_buffer	O
(	O
YY_CURRENT_BUFFER	O
)	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
=	O
NULL	O
;	O
if	O
(	O
(	O
yy_buffer_stack_top	long
)	O
>	O
0	int
)	O
--	O
(	O
yy_buffer_stack_top	long
)	O
;	O
if	O
(	O
YY_CURRENT_BUFFER	O
)	O
{	O
yy_load_buffer_state	O
(	O
)	O
;	O
(	O
yy_did_buffer_switch_on_eof	int
)	O
=	O
1	int
;	O
}	O
}	O
static	O
void	O
yyensure_buffer_stack	()->(void)
(	O
void	O
)	O
{	O
yy_size_t	long
num_to_alloc	long
;	O
if	O
(	O
!	O
(	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
)	O
)	O
{	O
num_to_alloc	long
=	O
1	int
;	O
(	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
)	O
=	O
(	O
struct	O
yy_buffer_state	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)
*	O
*	O
)	O
yyalloc	O
(	O
num_to_alloc	long
*	O
sizeof	O
(	O
struct	O
yy_buffer_state	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)
*	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
)	O
)	O
YY_FATAL_ERROR	O
(	O
"out of dynamic memory in yyensure_buffer_stack()"	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
)	O
,	O
0	int
,	O
num_to_alloc	long
*	O
sizeof	O
(	O
struct	O
yy_buffer_state	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)
*	O
)	O
)	O
;	O
(	O
yy_buffer_stack_max	long
)	O
=	O
num_to_alloc	long
;	O
(	O
yy_buffer_stack_top	long
)	O
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
yy_buffer_stack_top	long
)	O
>=	O
(	O
(	O
yy_buffer_stack_max	long
)	O
)	O
-	O
1	int
)	O
{	O
int	O
grow_size	int
=	O
8	int
;	O
num_to_alloc	long
=	O
(	O
yy_buffer_stack_max	long
)	O
+	O
grow_size	int
;	O
(	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
)	O
=	O
(	O
struct	O
yy_buffer_state	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)
*	O
*	O
)	O
yyrealloc	O
(	O
(	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
)	O
,	O
num_to_alloc	long
*	O
sizeof	O
(	O
struct	O
yy_buffer_state	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)
*	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
)	O
)	O
YY_FATAL_ERROR	O
(	O
"out of dynamic memory in yyensure_buffer_stack()"	*(char)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
(	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
)	O
+	O
(	O
yy_buffer_stack_max	long
)	O
,	O
0	int
,	O
grow_size	int
*	O
sizeof	O
(	O
struct	O
yy_buffer_state	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)
*	O
)	O
)	O
;	O
(	O
yy_buffer_stack_max	long
)	O
=	O
num_to_alloc	long
;	O
}	O
}	O
YY_BUFFER_STATE	*(struct)
yy_scan_buffer	(*(char),long)->(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
(	O
char	O
*	O
base	*(void)
,	O
yy_size_t	long
size	long
)	O
{	O
YY_BUFFER_STATE	*(struct)
b	*(struct)
;	O
if	O
(	O
size	long
<	O
2	int
||	O
base	*(void)
[	O
size	long
-	O
2	int
]	O
!=	O
YY_END_OF_BUFFER_CHAR	int
||	O
base	*(void)
[	O
size	long
-	O
1	int
]	O
!=	O
YY_END_OF_BUFFER_CHAR	int
)	O
return	O
0	int
;	O
b	*(struct)
=	O
(	O
YY_BUFFER_STATE	*(struct)
)	O
yyalloc	O
(	O
sizeof	O
(	O
struct	O
yy_buffer_state	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)
)	O
)	O
;	O
if	O
(	O
!	O
b	*(struct)
)	O
YY_FATAL_ERROR	O
(	O
"out of dynamic memory in yy_scan_buffer()"	*(char)
)	O
;	O
b	*(struct)
->	O
yy_buf_size	long
=	O
size	long
-	O
2	int
;	O
b	*(struct)
->	O
yy_buf_pos	*(char)
=	O
b	*(struct)
->	O
yy_ch_buf	*(char)
=	O
base	*(void)
;	O
b	*(struct)
->	O
yy_is_our_buffer	int
=	O
0	int
;	O
b	*(struct)
->	O
yy_input_file	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
0	int
;	O
b	*(struct)
->	O
yy_n_chars	long
=	O
b	*(struct)
->	O
yy_buf_size	long
;	O
b	*(struct)
->	O
yy_is_interactive	int
=	O
0	int
;	O
b	*(struct)
->	O
yy_at_bol	int
=	O
1	int
;	O
b	*(struct)
->	O
yy_fill_buffer	int
=	O
0	int
;	O
b	*(struct)
->	O
yy_buffer_status	int
=	O
YY_BUFFER_NEW	int
;	O
yy_switch_to_buffer	O
(	O
b	*(struct)
)	O
;	O
return	O
b	*(struct)
;	O
}	O
YY_BUFFER_STATE	*(struct)
yy_scan_string	(*(char))->(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
(	O
yyconst	O
char	O
*	O
yystr	*(char)
)	O
{	O
return	O
yy_scan_bytes	(*(char),long)->(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
(	O
yystr	*(char)
,	O
strlen	(*(char))->(long)
(	O
yystr	*(char)
)	O
)	O
;	O
}	O
YY_BUFFER_STATE	*(struct)
yy_scan_bytes	(*(char),long)->(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
(	O
yyconst	O
char	O
*	O
yybytes	*(char)
,	O
yy_size_t	long
_yybytes_len	long
)	O
{	O
YY_BUFFER_STATE	*(struct)
b	*(struct)
;	O
char	O
*	O
buf	*(void)
;	O
yy_size_t	long
n	long
;	O
int	O
i	int
;	O
n	long
=	O
_yybytes_len	long
+	O
2	int
;	O
buf	*(void)
=	O
(	O
char	O
*	O
)	O
yyalloc	O
(	O
n	long
)	O
;	O
if	O
(	O
!	O
buf	*(void)
)	O
YY_FATAL_ERROR	O
(	O
"out of dynamic memory in yy_scan_bytes()"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_yybytes_len	long
;	O
++	O
i	int
)	O
buf	*(void)
[	O
i	int
]	O
=	O
yybytes	*(char)
[	O
i	int
]	O
;	O
buf	*(void)
[	O
_yybytes_len	long
]	O
=	O
buf	*(void)
[	O
_yybytes_len	long
+	O
1	int
]	O
=	O
YY_END_OF_BUFFER_CHAR	int
;	O
b	*(struct)
=	O
yy_scan_buffer	(*(char),long)->(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
(	O
buf	*(void)
,	O
n	long
)	O
;	O
if	O
(	O
!	O
b	*(struct)
)	O
YY_FATAL_ERROR	O
(	O
"bad buffer in yy_scan_bytes()"	*(char)
)	O
;	O
b	*(struct)
->	O
yy_is_our_buffer	int
=	O
1	int
;	O
return	O
b	*(struct)
;	O
}	O
static	O
void	O
yy_fatal_error	(array(char))->(void)
(	O
yyconst	O
char	O
*	O
msg	array(char)
)	O
{	O
(	O
void	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
msg	array(char)
)	O
;	O
exit	(int)->(void)
(	O
YY_EXIT_FAILURE	int
)	O
;	O
}	O
int	O
yyget_lineno	O
(	O
void	O
)	O
{	O
return	O
yylineno	O
;	O
}	O
FILE	struct
*	O
yyget_in	O
(	O
void	O
)	O
{	O
return	O
yyin	O
;	O
}	O
FILE	struct
*	O
yyget_out	O
(	O
void	O
)	O
{	O
return	O
yyout	O
;	O
}	O
yy_size_t	long
yyget_leng	O
(	O
void	O
)	O
{	O
return	O
yyleng	O
;	O
}	O
char	O
*	O
yyget_text	O
(	O
void	O
)	O
{	O
return	O
yytext	O
;	O
}	O
void	O
yyset_lineno	O
(	O
int	O
line_number	int
)	O
{	O
yylineno	O
=	O
line_number	int
;	O
}	O
void	O
yyset_in	O
(	O
FILE	struct
*	O
in_str	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
yyin	O
=	O
in_str	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
void	O
yyset_out	O
(	O
FILE	struct
*	O
out_str	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
yyout	O
=	O
out_str	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
int	O
yyget_debug	O
(	O
void	O
)	O
{	O
return	O
yy_flex_debug	O
;	O
}	O
void	O
yyset_debug	O
(	O
int	O
bdebug	int
)	O
{	O
yy_flex_debug	O
=	O
bdebug	int
;	O
}	O
static	O
int	O
yy_init_globals	()->(int)
(	O
void	O
)	O
{	O
(	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
)	O
=	O
0	int
;	O
(	O
yy_buffer_stack_top	long
)	O
=	O
0	int
;	O
(	O
yy_buffer_stack_max	long
)	O
=	O
0	int
;	O
(	O
yy_c_buf_p	*(char)
)	O
=	O
(	O
char	O
*	O
)	O
0	int
;	O
(	O
yy_init	int
)	O
=	O
0	int
;	O
(	O
yy_start	int
)	O
=	O
0	int
;	O
yyin	O
=	O
(	O
FILE	struct
*	O
)	O
0	int
;	O
yyout	O
=	O
(	O
FILE	struct
*	O
)	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
yylex_destroy	O
(	O
void	O
)	O
{	O
while	O
(	O
YY_CURRENT_BUFFER	O
)	O
{	O
yy_delete_buffer	O
(	O
YY_CURRENT_BUFFER	O
)	O
;	O
YY_CURRENT_BUFFER_LVALUE	O
=	O
NULL	O
;	O
yypop_buffer_state	()->(void)
(	O
)	O
;	O
}	O
yyfree	O
(	O
(	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
)	O
)	O
;	O
(	O
yy_buffer_stack	*(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char),long,long,int,int,int,int,int,int,int)))
)	O
=	O
NULL	O
;	O
yy_init_globals	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
*	O
yyalloc	O
(	O
yy_size_t	long
size	long
)	O
{	O
return	O
(	O
void	O
*	O
)	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
}	O
void	O
*	O
yyrealloc	O
(	O
void	O
*	O
ptr	*(void)
,	O
yy_size_t	long
size	long
)	O
{	O
return	O
(	O
void	O
*	O
)	O
realloc	(*(void),long)->(*(void))
(	O
(	O
char	O
*	O
)	O
ptr	*(void)
,	O
size	long
)	O
;	O
}	O
void	O
yyfree	O
(	O
void	O
*	O
ptr	*(void)
)	O
{	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
ptr	*(void)
)	O
;	O
}	O
int	O
yywrap	O
(	O
)	O
{	O
return	O
1	int
;	O
}	O
struct	O
walk_closure	struct(*((int,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),*(void))->(int)),*(void))
{	O
int	O
(	O
*	O
fun	*((*(struct(long,long,long,int,long,long,*(char))),*(void))->(int))
)	O
(	O
int	O
,	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
,	O
void	O
*	O
)	O
;	O
void	O
*	O
data	*(void)
;	O
}	O
;	O
static	O
int	O
inorder_helper	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
item	*(void)
;	O
struct	O
walk_closure	struct(*((int,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),*(void))->(int)),*(void))
*	O
cp	*(struct(*((int,*(struct`),*(void))->(int)),*(void)))
=	O
data	*(void)
;	O
if	O
(	O
cp	*(struct(*((int,*(struct`),*(void))->(int)),*(void)))
->	O
fun	*((*(struct(long,long,long,int,long,long,*(char))),*(void))->(int))
(	O
0	int
,	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
,	O
cp	*(struct(*((int,*(struct`),*(void))->(int)),*(void)))
->	O
data	*(void)
)	O
)	O
return	O
1	int
;	O
if	O
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_type	enum(int,int,int)
==	O
gcide_content_taglist	int
)	O
{	O
dico_list_iterate	(*(struct),*((*(void),*(void))->(int)),*(void))->(void)
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
taglist	*(struct)
,	O
inorder_helper	(*(void),*(void))->(int)
,	O
data	*(void)
)	O
;	O
if	O
(	O
cp	*(struct(*((int,*(struct`),*(void))->(int)),*(void)))
->	O
fun	*((*(struct(long,long,long,int,long,long,*(char))),*(void))->(int))
(	O
1	int
,	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
,	O
cp	*(struct(*((int,*(struct`),*(void))->(int)),*(void)))
->	O
data	*(void)
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
gcide_parse_tree_inorder	(*(struct(*(char),long,*(struct(long,*`,enum(int,int,int),*`,union`)))),*((int,*(struct(long,*`,enum(int,int,int),*`,union`)),*(void))->(int)),*(void))->(int)
(	O
struct	O
gcide_parse_tree	struct(*(char),long,*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))))
*	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
,	O
int	O
(	O
*	O
fun	*((*(struct(long,long,long,int,long,long,*(char))),*(void))->(int))
)	O
(	O
int	O
,	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
walk_closure	struct(*((int,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),*(void))->(int)),*(void))
clos	*(void)
;	O
clos	*(void)
.	O
fun	*((*(struct(long,long,long,int,long,long,*(char))),*(void))->(int))
=	O
fun	*((*(struct(long,long,long,int,long,long,*(char))),*(void))->(int))
;	O
clos	*(void)
.	O
data	*(void)
=	O
data	*(void)
;	O
return	O
inorder_helper	(*(void),*(void))->(int)
(	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
->	O
root	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
,	O
&	O
clos	*(void)
)	O
;	O
}	O
static	O
int	O
tag_fixup	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
item	*(void)
;	O
char	O
*	O
textspace	*(char)
=	O
data	*(void)
;	O
switch	O
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_type	enum(int,int,int)
)	O
{	O
case	O
gcide_content_unspecified	int
:	O
break	O
;	O
case	O
gcide_content_text	int
:	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
text	*(char)
=	O
textspace	*(char)
+	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
textpos	long
;	O
break	O
;	O
case	O
gcide_content_taglist	int
:	O
dico_list_iterate	(*(struct),*((*(void),*(void))->(int)),*(void))->(void)
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
taglist	*(struct)
,	O
tag_fixup	(*(void),*(void))->(int)
,	O
textspace	*(char)
)	O
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
size_t	long
greek_translit	(long)->(long)
(	O
size_t	long
n	long
)	O
{	O
while	O
(	O
textspace	*(char)
[	O
n	long
]	O
)	O
{	O
size_t	long
rd	long
;	O
const	O
char	O
*	O
greek	*(char)
=	O
gcide_grk_to_utf8	(*(char),*(long))->(*(char))
(	O
textspace	*(char)
+	O
n	long
,	O
&	O
rd	long
)	O
;	O
if	O
(	O
greek	*(char)
)	O
{	O
text_add_str	(*(char),long)->(void)
(	O
greek	*(char)
,	O
strlen	(*(char))->(long)
(	O
greek	*(char)
)	O
)	O
;	O
n	long
+=	O
rd	long
;	O
}	O
else	O
{	O
text_add_chr	(int)->(void)
(	O
textspace	*(char)
[	O
n	long
]	O
)	O
;	O
n	long
++	O
;	O
}	O
}	O
return	O
text_segment_finish	()->(long)
(	O
)	O
;	O
}	O
static	O
int	O
early_fixup	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
item	*(void)
;	O
int	O
translate	int
=	O
data	*(void)
?	O
*	O
(	O
int	O
*	O
)	O
data	*(void)
:	O
0	int
;	O
switch	O
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_type	enum(int,int,int)
)	O
{	O
case	O
gcide_content_unspecified	int
:	O
break	O
;	O
case	O
gcide_content_text	int
:	O
if	O
(	O
translate	int
)	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
textpos	long
=	O
greek_translit	(long)->(long)
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
textpos	long
)	O
;	O
break	O
;	O
case	O
gcide_content_taglist	int
:	O
translate	int
=	O
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_parmc	long
&&	O
strcmp	(*(char),*(char))->(int)
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_name	O
,	O
"grk"	*(char)
)	O
==	O
0	int
)	O
;	O
dico_list_iterate	(*(struct),*((*(void),*(void))->(int)),*(void))->(void)
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
taglist	*(struct)
,	O
early_fixup	(*(void),*(void))->(int)
,	O
&	O
translate	int
)	O
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
gcide_parse_tree	struct(*(char),long,*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))))
*	O
gcide_markup_parse	(*(char),long,int)->(*(struct(*(char),long,*(struct(long,*`,enum(int,int,int),*`,union`)))))
(	O
char	O
const	O
*	O
text	*(char)
,	O
size_t	long
len	int
,	O
int	O
dbg	int
)	O
{	O
struct	O
gcide_parse_tree	struct(*(char),long,*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))))
*	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
;	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
p	*(char)
;	O
input_buf	*(char)
=	O
text	*(char)
;	O
input_len	long
=	O
len	int
;	O
token_beg	int
=	O
token_end	int
=	O
0	int
;	O
if	O
(	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
errbuf	array(struct(array(long),int,struct(array(long))))
)	O
)	O
{	O
free	(*(void))->(void)
(	O
textspace	*(char)
)	O
;	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
tagstk	*(struct)
)	O
;	O
free_tag	(*(void),*(void))->(int)
(	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
,	O
NULL	O
)	O
;	O
}	O
textsize	long
=	O
2	int
*	O
len	int
;	O
textspace	*(char)
=	O
malloc	(long)->(*(void))
(	O
textsize	long
)	O
;	O
if	O
(	O
!	O
textspace	*(char)
)	O
memerr	(*(char))->(void)
(	O
"gcide_markup_parse"	*(char)
)	O
;	O
textpos	long
=	O
textstart	long
=	O
0	int
;	O
tagstk	*(struct)
=	O
dico_list_create	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
!	O
tagstk	*(struct)
)	O
memerr	(*(char))->(void)
(	O
"gcide_markup_parse"	*(char)
)	O
;	O
dico_list_set_free_item	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
tagstk	*(struct)
,	O
free_tag	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
)	O
;	O
if	O
(	O
!	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
memerr	(*(char))->(void)
(	O
"gcide_markup_parse"	*(char)
)	O
;	O
yy_flex_debug	O
=	O
dbg	int
;	O
BEGIN	O
(	O
INITIAL	int
)	O
;	O
while	O
(	O
yylex	O
(	O
)	O
)	O
;	O
if	O
(	O
text_segment_length	O
(	O
)	O
)	O
{	O
struct	O
gcide_tag	struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))),union(*(char),long,*(struct)))
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
)	O
;	O
if	O
(	O
!	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
memerr	(*(char))->(void)
(	O
"gcide lexer"	*(char)
)	O
;	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_type	enum(int,int,int)
=	O
gcide_content_text	int
;	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
->	O
tag_v	union(*(char),long,*(struct))
.	O
textpos	long
=	O
text_segment_finish	()->(long)
(	O
)	O
;	O
append_tag	(*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*`,enum(int,int,int),*`,union`)),union(*(char),long,*(struct`)))))->(void)
(	O
tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
;	O
}	O
while	O
(	O
(	O
p	*(char)
=	O
dico_list_pop	(*(struct))->(*(void))
(	O
tagstk	*(struct)
)	O
)	O
)	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
p	*(char)
;	O
dico_list_destroy	(*(*(struct)))->(void)
(	O
&	O
tagstk	*(struct)
)	O
;	O
if	O
(	O
!	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
)	O
{	O
free	(*(void))->(void)
(	O
textspace	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
early_fixup	(*(void),*(void))->(int)
(	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
,	O
NULL	O
)	O
;	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
)	O
)	O
;	O
if	O
(	O
!	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
)	O
memerr	(*(char))->(void)
(	O
"gcide_markup_parse"	*(char)
)	O
;	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
->	O
textspace	*(char)
=	O
textspace	*(char)
;	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
->	O
textsize	long
=	O
textsize	long
;	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
->	O
root	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
=	O
current_tag	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
;	O
tag_fixup	(*(void),*(void))->(int)
(	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
->	O
root	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
,	O
textspace	*(char)
)	O
;	O
return	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
;	O
}	O
void	O
gcide_parse_tree_free	(*(struct(*(char),long,*(struct(long,*`,enum(int,int,int),*`,union`)))))->(void)
(	O
struct	O
gcide_parse_tree	struct(*(char),long,*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct)))))
*	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
)	O
{	O
free	(*(void))->(void)
(	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
->	O
textspace	*(char)
)	O
;	O
free_tag	(*(void),*(void))->(int)
(	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
->	O
root	*(struct(long,*(*(char)),enum(int,int,int),*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`))),union(*(char),long,*(struct))))
,	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
tp	*(struct(*(char),long,*(struct(long,*(*`),enum(int,int,int),*(struct`),union(*`,long,*`)))))
)	O
;	O
}	O
