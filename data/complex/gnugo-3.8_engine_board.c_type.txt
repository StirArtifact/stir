struct	O
string_data	struct(int,int,int,int,int,int)
{	O
int	O
color	int
;	O
int	O
size	int
;	O
int	O
origin	int
;	O
int	O
liberties	int
;	O
int	O
neighbors	int
;	O
int	O
mark	char
;	O
}	O
;	O
struct	O
string_liberties_data	struct(array(int))
{	O
int	O
list	array(int)
[	O
MAX_LIBERTIES	int
]	O
;	O
}	O
;	O
struct	O
string_neighbors_data	struct(array(int))
{	O
int	O
list	array(int)
[	O
MAXCHAIN	int
]	O
;	O
}	O
;	O
struct	O
change_stack_entry	struct(*(int),int)
{	O
int	O
*	O
address	*(int)
;	O
int	O
value	*(char)
;	O
}	O
;	O
struct	O
vertex_stack_entry	struct(*(char),int)
{	O
Intersection	char
*	O
address	*(int)
;	O
int	O
value	*(char)
;	O
}	O
;	O
static	O
struct	O
string_data	struct(int,int,int,int,int,int)
string	int
[	O
MAX_STRINGS	O
]	O
;	O
static	O
struct	O
string_liberties_data	struct(array(int))
string_libs	array(struct(array(int)))
[	O
MAX_STRINGS	O
]	O
;	O
static	O
struct	O
string_neighbors_data	struct(array(int))
string_neighbors	array(struct(array(int)))
[	O
MAX_STRINGS	O
]	O
;	O
static	O
struct	O
change_stack_entry	struct(*(int),int)
change_stack	array(struct(*(int),int))
[	O
STACK_SIZE	O
]	O
;	O
static	O
struct	O
change_stack_entry	struct(*(int),int)
*	O
change_stack_pointer	*(struct(*(int),int))
;	O
static	O
struct	O
vertex_stack_entry	struct(*(char),int)
vertex_stack	array(struct(*(char),int))
[	O
STACK_SIZE	O
]	O
;	O
static	O
struct	O
vertex_stack_entry	struct(*(char),int)
*	O
vertex_stack_pointer	*(struct(*(char),int))
;	O
static	O
int	O
string_number	array(int)
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
next_stone	array(int)
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
next_string	int
;	O
static	O
int	O
ml	array(int)
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
liberty_mark	int
;	O
static	O
int	O
string_mark	int
;	O
static	O
void	O
really_do_trymove	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
;	O
static	O
int	O
do_trymove	(int,int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
ignore_ko	int
)	O
;	O
static	O
void	O
undo_trymove	()->(void)
(	O
void	O
)	O
;	O
static	O
int	O
do_approxlib	(int,int,int,*(int))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	*(int)
)	O
;	O
static	O
int	O
slow_approxlib	(int,int,int,*(int))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	*(int)
)	O
;	O
static	O
int	O
do_accuratelib	(int,int,int,*(int))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	*(int)
)	O
;	O
static	O
int	O
is_superko_violation	(int,int,enum(int,int,int,int))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
enum	O
ko_rules	enum(int,int,int,int)
type	enum(int,int,int,int)
)	O
;	O
static	O
void	O
new_position	()->(void)
(	O
void	O
)	O
;	O
static	O
int	O
propagate_string	(int,int)->(int)
(	O
int	O
stone	int
,	O
int	O
str	int
)	O
;	O
static	O
void	O
find_liberties_and_neighbors	(int)->(void)
(	O
int	O
s	int
)	O
;	O
static	O
int	O
do_remove_string	(int)->(int)
(	O
int	O
s	int
)	O
;	O
static	O
void	O
do_commit_suicide	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
;	O
static	O
void	O
do_play_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
;	O
static	O
int	O
komaster	int
,	O
kom_pos	int
;	O
static	O
int	O
trymove_counter	int
=	O
0	int
;	O
int	O
deltai	array(int)
[	O
8	int
]	O
=	O
{	O
1	int
,	O
0	int
,	O
-	O
1	int
,	O
0	int
,	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
}	O
;	O
int	O
deltaj	array(int)
[	O
8	int
]	O
=	O
{	O
0	int
,	O
-	O
1	int
,	O
0	int
,	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
,	O
1	int
}	O
;	O
int	O
delta	array(int)
[	O
8	int
]	O
=	O
{	O
NS	O
,	O
-	O
1	int
,	O
-	O
NS	O
,	O
1	int
,	O
NS	O
-	O
1	int
,	O
-	O
NS	O
-	O
1	int
,	O
-	O
NS	O
+	O
1	int
,	O
NS	O
+	O
1	int
}	O
;	O
void	O
store_board	(*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int)))->(void)
(	O
struct	O
board_state	struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int)
*	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
)	O
{	O
int	O
k	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
board_size	int
=	O
board_size	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
board	*(char)
,	O
board	*(char)
,	O
sizeof	O
(	O
board	*(char)
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
initial_board	array(char)
,	O
initial_board	array(char)
,	O
sizeof	O
(	O
initial_board	array(char)
)	O
)	O
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
board_ko_pos	int
=	O
board_ko_pos	int
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
white_captured	int
=	O
white_captured	int
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
black_captured	int
=	O
black_captured	int
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
initial_board_ko_pos	int
=	O
initial_board_ko_pos	int
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
initial_white_captured	int
=	O
initial_white_captured	int
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
initial_black_captured	int
=	O
initial_black_captured	int
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
move_history_pointer	int
=	O
move_history_pointer	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
move_history_pointer	int
;	O
k	int
++	O
)	O
{	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
move_history_color	array(int)
[	O
k	int
]	O
=	O
move_history_color	array(int)
[	O
k	int
]	O
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
move_history_pos	array(int)
[	O
k	int
]	O
=	O
move_history_pos	array(int)
[	O
k	int
]	O
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
move_history_hash	array(struct(array(long)))
[	O
k	int
]	O
=	O
move_history_hash	array(struct(array(long)))
[	O
k	int
]	O
;	O
}	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
komi	float
=	O
komi	float
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
handicap	int
=	O
handicap	int
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
move_number	int
=	O
movenum	int
;	O
}	O
void	O
restore_board	(*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int)))->(void)
(	O
struct	O
board_state	struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int)
*	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
)	O
{	O
int	O
k	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
board_size	int
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
board_size	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
board	*(char)
,	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
board	*(char)
,	O
sizeof	O
(	O
board	*(char)
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
initial_board	array(char)
,	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
initial_board	array(char)
,	O
sizeof	O
(	O
initial_board	array(char)
)	O
)	O
;	O
board_ko_pos	int
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
board_ko_pos	int
;	O
white_captured	int
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
white_captured	int
;	O
black_captured	int
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
black_captured	int
;	O
initial_board_ko_pos	int
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
initial_board_ko_pos	int
;	O
initial_white_captured	int
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
initial_white_captured	int
;	O
initial_black_captured	int
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
initial_black_captured	int
;	O
move_history_pointer	int
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
move_history_pointer	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
move_history_pointer	int
;	O
k	int
++	O
)	O
{	O
move_history_color	array(int)
[	O
k	int
]	O
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
move_history_color	array(int)
[	O
k	int
]	O
;	O
move_history_pos	array(int)
[	O
k	int
]	O
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
move_history_pos	array(int)
[	O
k	int
]	O
;	O
move_history_hash	array(struct(array(long)))
[	O
k	int
]	O
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
move_history_hash	array(struct(array(long)))
[	O
k	int
]	O
;	O
}	O
komi	float
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
komi	float
;	O
handicap	int
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
handicap	int
;	O
movenum	int
=	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
->	O
move_number	int
;	O
hashdata_recalc	(*(struct(array(long))),*(char),int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
board	*(char)
,	O
board_ko_pos	int
)	O
;	O
new_position	()->(void)
(	O
)	O
;	O
}	O
void	O
clear_board	()->(void)
(	O
void	O
)	O
{	O
int	O
k	int
;	O
gg_assert	O
(	O
board_size	int
>	O
0	int
&&	O
board_size	int
<=	O
MAX_BOARD	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
board	*(char)
,	O
EMPTY	int
,	O
sizeof	O
(	O
board	*(char)
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
initial_board	array(char)
,	O
EMPTY	int
,	O
sizeof	O
(	O
initial_board	array(char)
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
BOARDSIZE	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD2	O
(	O
I	O
(	O
k	int
)	O
,	O
J	O
(	O
k	int
)	O
)	O
)	O
{	O
board	*(char)
[	O
k	int
]	O
=	O
GRAY	int
;	O
initial_board	array(char)
[	O
k	int
]	O
=	O
GRAY	int
;	O
}	O
}	O
board_ko_pos	int
=	O
NO_MOVE	O
;	O
white_captured	int
=	O
0	int
;	O
black_captured	int
=	O
0	int
;	O
komaster	int
=	O
EMPTY	int
;	O
kom_pos	int
=	O
NO_MOVE	O
;	O
initial_board_ko_pos	int
=	O
NO_MOVE	O
;	O
initial_white_captured	int
=	O
0	int
;	O
initial_black_captured	int
=	O
0	int
;	O
move_history_pointer	int
=	O
0	int
;	O
movenum	int
=	O
0	int
;	O
handicap	int
=	O
0	int
;	O
hashdata_recalc	(*(struct(array(long))),*(char),int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
board	*(char)
,	O
board_ko_pos	int
)	O
;	O
new_position	()->(void)
(	O
)	O
;	O
}	O
int	O
test_gray_border	()->(int)
(	O
void	O
)	O
{	O
int	O
k	int
;	O
gg_assert	O
(	O
board_size	int
>	O
0	int
&&	O
board_size	int
<=	O
MAX_BOARD	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
BOARDSIZE	O
;	O
k	int
++	O
)	O
if	O
(	O
!	O
ON_BOARD2	O
(	O
I	O
(	O
k	int
)	O
,	O
J	O
(	O
k	int
)	O
)	O
)	O
if	O
(	O
board	*(char)
[	O
k	int
]	O
!=	O
GRAY	int
)	O
return	O
k	int
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
stack	array(int)
[	O
MAXSTACK	O
]	O
;	O
static	O
int	O
move_color	array(int)
[	O
MAXSTACK	O
]	O
;	O
static	O
Hash_data	struct(array(long))
board_hash_stack	array(struct(array(long)))
[	O
MAXSTACK	O
]	O
;	O
int	O
trymove	(int,int,*(char),int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
const	O
char	O
*	O
message	*(char)
,	O
int	O
str	int
)	O
{	O
UNUSED	O
(	O
str	int
)	O
;	O
if	O
(	O
!	O
do_trymove	(int,int,int)->(int)
(	O
pos	int
,	O
color	int
,	O
0	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
char	O
buf	*(char)
[	O
100	int
]	O
;	O
if	O
(	O
message	*(char)
==	O
NULL	O
)	O
message	*(char)
=	O
"UNKNOWN"	*(char)
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
if	O
(	O
komaster	int
!=	O
EMPTY	int
)	O
gg_snprintf	(*(char),long,*(char))->(void)
(	O
buf	*(char)
,	O
100	int
,	O
"%s (variation %d, hash %s, komaster %s:%s)"	*(char)
,	O
message	*(char)
,	O
count_variations	int
,	O
hashdata_to_string	(*(struct(array(long))))->(*(char))
(	O
&	O
board_hash	struct(array(long))
)	O
,	O
color_to_string	(int)->(*(char))
(	O
komaster	int
)	O
,	O
location_to_string	(int)->(*(char))
(	O
kom_pos	int
)	O
)	O
;	O
else	O
gg_snprintf	(*(char),long,*(char))->(void)
(	O
buf	*(char)
,	O
100	int
,	O
"%s (variation %d, hash %s)"	*(char)
,	O
message	*(char)
,	O
count_variations	int
,	O
hashdata_to_string	(*(struct(array(long))))->(*(char))
(	O
&	O
board_hash	struct(array(long))
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
komaster	int
!=	O
EMPTY	int
)	O
gg_snprintf	(*(char),long,*(char))->(void)
(	O
buf	*(char)
,	O
100	int
,	O
"%s at %s (variation %d, hash %s, komaster %s:%s)"	*(char)
,	O
message	*(char)
,	O
location_to_string	(int)->(*(char))
(	O
pos	int
)	O
,	O
count_variations	int
,	O
hashdata_to_string	(*(struct(array(long))))->(*(char))
(	O
&	O
board_hash	struct(array(long))
)	O
,	O
color_to_string	(int)->(*(char))
(	O
komaster	int
)	O
,	O
location_to_string	(int)->(*(char))
(	O
kom_pos	int
)	O
)	O
;	O
else	O
gg_snprintf	(*(char),long,*(char))->(void)
(	O
buf	*(char)
,	O
100	int
,	O
"%s at %s (variation %d, hash %s)"	*(char)
,	O
message	*(char)
,	O
location_to_string	(int)->(*(char))
(	O
pos	int
)	O
,	O
count_variations	int
,	O
hashdata_to_string	(*(struct(array(long))))->(*(char))
(	O
&	O
board_hash	struct(array(long))
)	O
)	O
;	O
}	O
sgftreeAddPlayLast	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),int,int,int)->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
color	int
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
buf	*(char)
)	O
;	O
}	O
if	O
(	O
count_variations	int
)	O
count_variations	int
++	O
;	O
stats	struct(int,int,int,int)
.	O
nodes	int
++	O
;	O
return	O
1	int
;	O
}	O
int	O
tryko	(int,int,*(char))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
const	O
char	O
*	O
message	*(char)
)	O
{	O
if	O
(	O
!	O
do_trymove	(int,int,int)->(int)
(	O
pos	int
,	O
color	int
,	O
1	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
char	O
buf	*(char)
[	O
100	int
]	O
;	O
if	O
(	O
message	*(char)
==	O
NULL	O
)	O
message	*(char)
=	O
"UNKNOWN"	*(char)
;	O
if	O
(	O
komaster	int
!=	O
EMPTY	int
)	O
gg_snprintf	(*(char),long,*(char))->(void)
(	O
buf	*(char)
,	O
100	int
,	O
"tryko: %s (variation %d, %s, komaster %s:%s)"	*(char)
,	O
message	*(char)
,	O
count_variations	int
,	O
hashdata_to_string	(*(struct(array(long))))->(*(char))
(	O
&	O
board_hash	struct(array(long))
)	O
,	O
color_to_string	(int)->(*(char))
(	O
komaster	int
)	O
,	O
location_to_string	(int)->(*(char))
(	O
kom_pos	int
)	O
)	O
;	O
else	O
gg_snprintf	(*(char),long,*(char))->(void)
(	O
buf	*(char)
,	O
100	int
,	O
"tryko: %s (variation %d, %s)"	*(char)
,	O
message	*(char)
,	O
count_variations	int
,	O
hashdata_to_string	(*(struct(array(long))))->(*(char))
(	O
&	O
board_hash	struct(array(long))
)	O
)	O
;	O
sgftreeAddPlayLast	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),int,int,int)->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
color	int
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
"tenuki (ko threat)"	*(char)
)	O
;	O
sgftreeAddPlayLast	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),int,int,int)->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
"tenuki (answers ko threat)"	*(char)
)	O
;	O
sgftreeAddPlayLast	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),int,int,int)->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
color	int
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
buf	*(char)
)	O
;	O
}	O
if	O
(	O
count_variations	int
)	O
count_variations	int
++	O
;	O
stats	struct(int,int,int,int)
.	O
nodes	int
++	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
really_do_trymove	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
BEGIN_CHANGE_RECORD	O
(	O
)	O
;	O
PUSH_VALUE	O
(	O
board_ko_pos	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
board_hash_stack	array(struct(array(long)))
[	O
stackp	int
]	O
,	O
&	O
board_hash	struct(array(long))
,	O
sizeof	O
(	O
board_hash	struct(array(long))
)	O
)	O
;	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	(*(struct(array(long))),int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
board_ko_pos	int
)	O
;	O
board_ko_pos	int
=	O
NO_MOVE	O
;	O
stackp	int
++	O
;	O
if	O
(	O
pos	int
!=	O
PASS_MOVE	int
)	O
{	O
PUSH_VALUE	O
(	O
black_captured	int
)	O
;	O
PUSH_VALUE	O
(	O
white_captured	int
)	O
;	O
do_play_move	(int,int)->(void)
(	O
pos	int
,	O
color	int
)	O
;	O
}	O
}	O
static	O
int	O
do_trymove	(int,int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
ignore_ko	int
)	O
{	O
gg_assert	O
(	O
color	int
==	O
BLACK	int
||	O
color	int
==	O
WHITE	int
)	O
;	O
if	O
(	O
pos	int
!=	O
PASS_MOVE	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
shadow	array(char)
[	O
pos	int
]	O
=	O
1	int
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
ignore_ko	int
&&	O
pos	int
==	O
board_ko_pos	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
||	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
is_suicide	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
return	O
0	int
;	O
}	O
if	O
(	O
stackp	int
>=	O
MAXSTACK	O
-	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: Truncating search. This is beyond my reading ability!\n"	*(char)
)	O
;	O
if	O
(	O
0	int
)	O
{	O
ASSERT1	O
(	O
0	int
&&	O
"trymove stack overflow"	*(char)
,	O
pos	int
)	O
;	O
}	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
0	int
;	O
}	O
trymove_counter	int
++	O
;	O
stack	array(int)
[	O
stackp	int
]	O
=	O
pos	int
;	O
move_color	array(int)
[	O
stackp	int
]	O
=	O
color	int
;	O
really_do_trymove	(int,int)->(void)
(	O
pos	int
,	O
color	int
)	O
;	O
return	O
1	int
;	O
}	O
void	O
popgo	()->(void)
(	O
)	O
{	O
undo_trymove	()->(void)
(	O
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
char	O
buf	*(char)
[	O
100	int
]	O
;	O
int	O
is_tryko	int
=	O
0	int
;	O
char	O
*	O
sgf_comment	*(char)
;	O
if	O
(	O
sgfGetCharProperty	(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char),*(*(char)))->(int)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
lastnode	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
"C "	*(char)
,	O
&	O
sgf_comment	*(char)
)	O
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
sgf_comment	*(char)
,	O
"tryko:"	*(char)
,	O
6	int
)	O
==	O
0	int
)	O
is_tryko	int
=	O
1	int
;	O
gg_snprintf	(*(char),long,*(char))->(void)
(	O
buf	*(char)
,	O
100	int
,	O
"(next variation: %d)"	*(char)
,	O
count_variations	int
)	O
;	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
buf	*(char)
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
lastnode	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
lastnode	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
if	O
(	O
is_tryko	int
)	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
lastnode	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
lastnode	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
->	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
}	O
static	O
void	O
undo_trymove	()->(void)
(	O
)	O
{	O
gg_assert	O
(	O
change_stack_pointer	*(struct(*(int),int))
-	O
change_stack	array(struct(*(int),int))
<=	O
STACK_SIZE	O
)	O
;	O
if	O
(	O
0	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"Change stack size = %d\n"	*(char)
,	O
change_stack_pointer	*(struct(*(int),int))
-	O
change_stack	array(struct(*(int),int))
)	O
;	O
gprintf	(*(char))->(int)
(	O
"Vertex stack size = %d\n"	*(char)
,	O
vertex_stack_pointer	*(struct(*(char),int))
-	O
vertex_stack	array(struct(*(char),int))
)	O
;	O
}	O
POP_MOVE	O
(	O
)	O
;	O
POP_VERTICES	O
(	O
)	O
;	O
stackp	int
--	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
board_hash	struct(array(long))
,	O
&	O
(	O
board_hash_stack	array(struct(array(long)))
[	O
stackp	int
]	O
)	O
,	O
sizeof	O
(	O
board_hash	struct(array(long))
)	O
)	O
;	O
}	O
void	O
dump_stack	()->(void)
(	O
void	O
)	O
{	O
do_dump_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
count_variations	int
)	O
gprintf	(*(char))->(int)
(	O
"%o (variation %d)"	*(char)
,	O
count_variations	int
-	O
1	int
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%o\n"	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
do_dump_stack	()->(void)
(	O
void	O
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
stackp	int
;	O
n	int
++	O
)	O
gprintf	(*(char))->(int)
(	O
"%o%s:%1m "	*(char)
,	O
move_color	array(int)
[	O
n	int
]	O
==	O
BLACK	int
?	O
"B"	*(char)
:	O
"W"	*(char)
,	O
stack	array(int)
[	O
n	int
]	O
)	O
;	O
}	O
static	O
void	O
reset_move_history	()->(void)
(	O
void	O
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
initial_board	array(char)
,	O
board	*(char)
,	O
sizeof	O
(	O
board	*(char)
)	O
)	O
;	O
initial_board_ko_pos	int
=	O
board_ko_pos	int
;	O
initial_white_captured	int
=	O
white_captured	int
;	O
initial_black_captured	int
=	O
black_captured	int
;	O
move_history_pointer	int
=	O
0	int
;	O
}	O
void	O
add_stone	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
ASSERT1	O
(	O
stackp	int
==	O
0	int
,	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
board	*(char)
[	O
pos	int
]	O
=	O
color	int
;	O
hashdata_invert_stone	(*(struct(array(long))),int,int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
pos	int
,	O
color	int
)	O
;	O
reset_move_history	()->(void)
(	O
)	O
;	O
new_position	()->(void)
(	O
)	O
;	O
}	O
void	O
remove_stone	(int)->(void)
(	O
int	O
pos	int
)	O
{	O
ASSERT1	O
(	O
stackp	int
==	O
0	int
,	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
,	O
pos	int
)	O
;	O
hashdata_invert_stone	(*(struct(array(long))),int,int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
pos	int
,	O
board	*(char)
[	O
pos	int
]	O
)	O
;	O
board	*(char)
[	O
pos	int
]	O
=	O
EMPTY	int
;	O
reset_move_history	()->(void)
(	O
)	O
;	O
new_position	()->(void)
(	O
)	O
;	O
}	O
static	O
void	O
play_move_no_history	(int,int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
update_internals	int
)	O
{	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	(*(struct(array(long))),int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
board_ko_pos	int
)	O
;	O
board_ko_pos	int
=	O
NO_MOVE	O
;	O
if	O
(	O
pos	int
!=	O
PASS_MOVE	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
if	O
(	O
!	O
is_suicide	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
do_play_move	(int,int)->(void)
(	O
pos	int
,	O
color	int
)	O
;	O
else	O
do_commit_suicide	(int,int)->(void)
(	O
pos	int
,	O
color	int
)	O
;	O
}	O
if	O
(	O
update_internals	int
||	O
next_string	int
==	O
MAX_STRINGS	O
)	O
new_position	()->(void)
(	O
)	O
;	O
else	O
CLEAR_STACKS	O
(	O
)	O
;	O
}	O
static	O
void	O
replay_move_history	(int)->(void)
(	O
int	O
n	int
)	O
{	O
int	O
k	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
board	*(char)
,	O
initial_board	array(char)
,	O
sizeof	O
(	O
board	*(char)
)	O
)	O
;	O
board_ko_pos	int
=	O
initial_board_ko_pos	int
;	O
white_captured	int
=	O
initial_white_captured	int
;	O
black_captured	int
=	O
initial_black_captured	int
;	O
new_position	()->(void)
(	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
play_move_no_history	(int,int,int)->(void)
(	O
move_history_pos	array(int)
[	O
k	int
]	O
,	O
move_history_color	array(int)
[	O
k	int
]	O
,	O
0	int
)	O
;	O
new_position	()->(void)
(	O
)	O
;	O
}	O
void	O
play_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
ASSERT1	O
(	O
stackp	int
==	O
0	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
WHITE	int
||	O
color	int
==	O
BLACK	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
pos	int
==	O
PASS_MOVE	int
||	O
ON_BOARD1	O
(	O
pos	int
)	O
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
pos	int
==	O
PASS_MOVE	int
||	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
komaster	int
==	O
EMPTY	int
&&	O
kom_pos	int
==	O
NO_MOVE	O
,	O
pos	int
)	O
;	O
if	O
(	O
move_history_pointer	int
>=	O
MAX_MOVE_HISTORY	int
)	O
{	O
int	O
number_collapsed_moves	int
=	O
1	int
+	O
MAX_MOVE_HISTORY	int
/	O
10	int
;	O
int	O
k	int
;	O
Intersection	char
saved_board	array(char)
[	O
BOARDSIZE	O
]	O
;	O
int	O
saved_board_ko_pos	int
=	O
board_ko_pos	int
;	O
int	O
saved_white_captured	int
=	O
white_captured	int
;	O
int	O
saved_black_captured	int
=	O
black_captured	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
saved_board	array(char)
,	O
board	*(char)
,	O
sizeof	O
(	O
board	*(char)
)	O
)	O
;	O
replay_move_history	(int)->(void)
(	O
number_collapsed_moves	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
initial_board	array(char)
,	O
board	*(char)
,	O
sizeof	O
(	O
board	*(char)
)	O
)	O
;	O
initial_board_ko_pos	int
=	O
board_ko_pos	int
;	O
initial_white_captured	int
=	O
white_captured	int
;	O
initial_black_captured	int
=	O
black_captured	int
;	O
for	O
(	O
k	int
=	O
number_collapsed_moves	int
;	O
k	int
<	O
move_history_pointer	int
;	O
k	int
++	O
)	O
{	O
move_history_color	array(int)
[	O
k	int
-	O
number_collapsed_moves	int
]	O
=	O
move_history_color	array(int)
[	O
k	int
]	O
;	O
move_history_pos	array(int)
[	O
k	int
-	O
number_collapsed_moves	int
]	O
=	O
move_history_pos	array(int)
[	O
k	int
]	O
;	O
move_history_hash	array(struct(array(long)))
[	O
k	int
-	O
number_collapsed_moves	int
]	O
=	O
move_history_hash	array(struct(array(long)))
[	O
k	int
]	O
;	O
}	O
move_history_pointer	int
-=	O
number_collapsed_moves	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
board	*(char)
,	O
saved_board	array(char)
,	O
sizeof	O
(	O
board	*(char)
)	O
)	O
;	O
board_ko_pos	int
=	O
saved_board_ko_pos	int
;	O
white_captured	int
=	O
saved_white_captured	int
;	O
black_captured	int
=	O
saved_black_captured	int
;	O
new_position	()->(void)
(	O
)	O
;	O
}	O
move_history_color	array(int)
[	O
move_history_pointer	int
]	O
=	O
color	int
;	O
move_history_pos	array(int)
[	O
move_history_pointer	int
]	O
=	O
pos	int
;	O
move_history_hash	array(struct(array(long)))
[	O
move_history_pointer	int
]	O
=	O
board_hash	struct(array(long))
;	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	(*(struct(array(long))),int)->(void)
(	O
&	O
move_history_hash	array(struct(array(long)))
[	O
move_history_pointer	int
]	O
,	O
board_ko_pos	int
)	O
;	O
move_history_pointer	int
++	O
;	O
play_move_no_history	(int,int,int)->(void)
(	O
pos	int
,	O
color	int
,	O
1	int
)	O
;	O
movenum	int
++	O
;	O
}	O
int	O
undo_move	(int)->(int)
(	O
int	O
n	int
)	O
{	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
move_history_pointer	int
<	O
n	int
)	O
return	O
0	int
;	O
replay_move_history	(int)->(void)
(	O
move_history_pointer	int
-	O
n	int
)	O
;	O
move_history_pointer	int
-=	O
n	int
;	O
movenum	int
-=	O
n	int
;	O
return	O
1	int
;	O
}	O
int	O
get_last_opponent_move	(int)->(int)
(	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
move_history_pointer	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
if	O
(	O
move_history_color	array(int)
[	O
k	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
return	O
move_history_pos	array(int)
[	O
k	int
]	O
;	O
return	O
PASS_MOVE	int
;	O
}	O
int	O
get_last_move	()->(int)
(	O
)	O
{	O
if	O
(	O
move_history_pointer	int
==	O
0	int
)	O
return	O
PASS_MOVE	int
;	O
return	O
move_history_pos	array(int)
[	O
move_history_pointer	int
-	O
1	int
]	O
;	O
}	O
int	O
get_last_player	()->(int)
(	O
)	O
{	O
if	O
(	O
move_history_pointer	int
==	O
0	int
)	O
return	O
EMPTY	int
;	O
return	O
move_history_color	array(int)
[	O
move_history_pointer	int
-	O
1	int
]	O
;	O
}	O
int	O
is_pass	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
return	O
pos	int
==	O
0	int
;	O
}	O
int	O
is_legal	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
if	O
(	O
pos	int
==	O
PASS_MOVE	int
)	O
return	O
1	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
pos	int
==	O
board_ko_pos	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
||	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
stackp	int
>=	O
MAXSTACK	O
-	O
2	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"gnugo: Truncating search. This is beyond my reading ability!\n"	*(char)
)	O
;	O
if	O
(	O
0	int
)	O
{	O
ASSERT1	O
(	O
0	int
&&	O
"is_legal stack overflow"	*(char)
,	O
pos	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
is_suicide	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
is_suicide	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
||	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
(	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
^	O
(	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
||	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
(	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
^	O
(	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
||	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
(	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
^	O
(	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
||	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
(	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
^	O
(	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
)	O
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
is_illegal_ko_capture	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
return	O
(	O
pos	int
==	O
board_ko_pos	int
&&	O
(	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
||	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
)	O
;	O
}	O
int	O
is_allowed_move	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
pos	int
==	O
PASS_MOVE	int
)	O
return	O
1	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
ko_rule	enum(int,int,int,int)
!=	O
NONE	int
&&	O
pos	int
==	O
board_ko_pos	int
&&	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
||	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
is_suicide	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
if	O
(	O
suicide_rule	enum(int,int,int)
==	O
FORBIDDEN	int
||	O
(	O
suicide_rule	enum(int,int,int)
==	O
ALLOWED	int
&&	O
!	O
has_neighbor	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
is_superko_violation	(int,int,enum(int,int,int,int))->(int)
(	O
pos	int
,	O
color	int
,	O
ko_rule	enum(int,int,int,int)
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
set_new_komaster	(int)->(void)
(	O
int	O
new_komaster	int
)	O
{	O
PUSH_VALUE	O
(	O
komaster	int
)	O
;	O
hashdata_invert_komaster	(*(struct(array(long))),int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
komaster	int
)	O
;	O
komaster	int
=	O
new_komaster	int
;	O
hashdata_invert_komaster	(*(struct(array(long))),int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
komaster	int
)	O
;	O
}	O
static	O
void	O
set_new_kom_pos	(int)->(void)
(	O
int	O
new_kom_pos	int
)	O
{	O
PUSH_VALUE	O
(	O
kom_pos	int
)	O
;	O
hashdata_invert_kom_pos	(*(struct(array(long))),int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
kom_pos	int
)	O
;	O
kom_pos	int
=	O
new_kom_pos	int
;	O
hashdata_invert_kom_pos	(*(struct(array(long))),int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
kom_pos	int
)	O
;	O
}	O
int	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
const	O
char	O
*	O
message	*(char)
,	O
int	O
str	int
,	O
int	O
*	O
is_conditional_ko	*(int)
,	O
int	O
consider_conditional_ko	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
ko_move	int
;	O
int	O
kpos	int
;	O
int	O
previous_board_ko_pos	int
=	O
board_ko_pos	int
;	O
*	O
is_conditional_ko	*(int)
=	O
0	int
;	O
ko_move	int
=	O
is_ko	(int,int,*(int))->(int)
(	O
pos	int
,	O
color	int
,	O
&	O
kpos	int
)	O
;	O
if	O
(	O
ko_move	int
)	O
{	O
if	O
(	O
komaster	int
==	O
other	int
&&	O
pos	int
==	O
kom_pos	int
)	O
return	O
0	int
;	O
if	O
(	O
komaster	int
==	O
GRAY_WHITE	int
||	O
komaster	int
==	O
GRAY_BLACK	int
)	O
return	O
0	int
;	O
if	O
(	O
komaster	int
==	O
color	int
&&	O
!	O
DIAGONAL_NEIGHBORS	O
(	O
kpos	int
,	O
kom_pos	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
komaster	int
==	O
WEAK_KO	int
)	O
{	O
if	O
(	O
pos	int
!=	O
board_ko_pos	int
&&	O
!	O
DIAGONAL_NEIGHBORS	O
(	O
kpos	int
,	O
kom_pos	int
)	O
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
message	*(char)
,	O
str	int
)	O
)	O
{	O
if	O
(	O
!	O
consider_conditional_ko	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
tryko	(int,int,*(char))->(int)
(	O
pos	int
,	O
color	int
,	O
message	*(char)
)	O
)	O
return	O
0	int
;	O
*	O
is_conditional_ko	*(int)
=	O
1	int
;	O
if	O
(	O
komaster	int
==	O
EMPTY	int
||	O
komaster	int
==	O
WEAK_KO	int
)	O
{	O
set_new_komaster	(int)->(void)
(	O
color	int
)	O
;	O
set_new_kom_pos	(int)->(void)
(	O
kpos	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
ko_move	int
)	O
{	O
if	O
(	O
(	O
(	O
komaster	int
==	O
color	int
||	O
(	O
komaster	int
==	O
GRAY_WHITE	int
&&	O
color	int
==	O
WHITE	int
)	O
||	O
(	O
komaster	int
==	O
GRAY_BLACK	int
&&	O
color	int
==	O
BLACK	int
)	O
)	O
&&	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
kom_pos	int
]	O
)	O
||	O
(	O
!	O
is_ko	(int,int,*(int))->(int)
(	O
kom_pos	int
,	O
other	int
,	O
NULL	O
)	O
&&	O
is_suicide	(int,int)->(int)
(	O
kom_pos	int
,	O
other	int
)	O
)	O
)	O
)	O
)	O
{	O
set_new_komaster	(int)->(void)
(	O
EMPTY	int
)	O
;	O
set_new_kom_pos	(int)->(void)
(	O
NO_MOVE	O
)	O
;	O
}	O
if	O
(	O
komaster	int
==	O
WEAK_KO	int
)	O
{	O
set_new_komaster	(int)->(void)
(	O
EMPTY	int
)	O
;	O
set_new_kom_pos	(int)->(void)
(	O
NO_MOVE	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
if	O
(	O
komaster	int
==	O
other	int
)	O
{	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
set_new_komaster	(int)->(void)
(	O
GRAY_BLACK	int
)	O
;	O
else	O
set_new_komaster	(int)->(void)
(	O
GRAY_WHITE	int
)	O
;	O
}	O
else	O
if	O
(	O
komaster	int
==	O
color	int
)	O
{	O
set_new_kom_pos	(int)->(void)
(	O
kpos	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
previous_board_ko_pos	int
!=	O
NO_MOVE	O
)	O
{	O
set_new_komaster	(int)->(void)
(	O
WEAK_KO	int
)	O
;	O
set_new_kom_pos	(int)->(void)
(	O
previous_board_ko_pos	int
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
int	O
get_komaster	()->(int)
(	O
)	O
{	O
return	O
komaster	int
;	O
}	O
int	O
get_kom_pos	()->(int)
(	O
)	O
{	O
return	O
kom_pos	int
;	O
}	O
int	O
is_edge_vertex	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
SW	O
(	O
pos	int
)	O
)	O
||	O
!	O
ON_BOARD	O
(	O
NE	O
(	O
pos	int
)	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
edge_distance	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
i	int
=	O
I	O
(	O
pos	int
)	O
;	O
int	O
j	int
=	O
J	O
(	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
return	O
gg_min	O
(	O
gg_min	O
(	O
i	int
,	O
board_size	int
-	O
1	int
-	O
i	int
)	O
,	O
gg_min	O
(	O
j	int
,	O
board_size	int
-	O
1	int
-	O
j	int
)	O
)	O
;	O
}	O
int	O
is_corner_vertex	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
(	O
!	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
||	O
!	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
&&	O
(	O
!	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
||	O
!	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
rotate1	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
rot	int
)	O
{	O
int	O
bs	int
=	O
board_size	int
-	O
1	int
;	O
int	O
i	int
=	O
I	O
(	O
pos	int
)	O
;	O
int	O
j	int
=	O
J	O
(	O
pos	int
)	O
;	O
gg_assert	O
(	O
rot	int
>=	O
0	int
&&	O
rot	int
<	O
8	int
)	O
;	O
if	O
(	O
pos	int
==	O
PASS_MOVE	int
)	O
return	O
PASS_MOVE	int
;	O
if	O
(	O
rot	int
==	O
0	int
)	O
return	O
pos	int
;	O
if	O
(	O
rot	int
==	O
1	int
)	O
return	O
POS	O
(	O
bs	int
-	O
j	int
,	O
i	int
)	O
;	O
if	O
(	O
rot	int
==	O
2	int
)	O
return	O
POS	O
(	O
bs	int
-	O
i	int
,	O
bs	int
-	O
j	int
)	O
;	O
if	O
(	O
rot	int
==	O
3	int
)	O
return	O
POS	O
(	O
j	int
,	O
bs	int
-	O
i	int
)	O
;	O
if	O
(	O
rot	int
==	O
4	int
)	O
return	O
POS	O
(	O
j	int
,	O
i	int
)	O
;	O
if	O
(	O
rot	int
==	O
5	int
)	O
return	O
POS	O
(	O
bs	int
-	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
rot	int
==	O
6	int
)	O
return	O
POS	O
(	O
bs	int
-	O
j	int
,	O
bs	int
-	O
i	int
)	O
;	O
if	O
(	O
rot	int
==	O
7	int
)	O
return	O
POS	O
(	O
i	int
,	O
bs	int
-	O
j	int
)	O
;	O
return	O
PASS_MOVE	int
;	O
}	O
int	O
are_neighbors	(int,int)->(int)
(	O
int	O
pos1	int
,	O
int	O
pos2	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos1	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
return	O
(	O
gg_abs	O
(	O
pos1	int
-	O
pos2	int
)	O
==	O
NS	O
||	O
gg_abs	O
(	O
pos1	int
-	O
pos2	int
)	O
==	O
WE	int
)	O
;	O
else	O
return	O
neighbor_of_string	(int,int)->(int)
(	O
pos1	int
,	O
pos2	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
return	O
neighbor_of_string	(int,int)->(int)
(	O
pos2	int
,	O
pos1	int
)	O
;	O
else	O
return	O
adjacent_strings	(int,int)->(int)
(	O
pos1	int
,	O
pos2	int
)	O
;	O
}	O
}	O
int	O
countlib	(int)->(int)
(	O
int	O
str	int
)	O
{	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
return	O
string	int
[	O
string_number	array(int)
[	O
str	int
]	O
]	O
.	O
liberties	int
;	O
}	O
int	O
findlib	(int,int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	*(int)
)	O
{	O
int	O
k	int
;	O
int	O
liberties	int
;	O
int	O
s	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
ASSERT1	O
(	O
libs	*(int)
!=	O
NULL	O
,	O
str	int
)	O
;	O
s	int
=	O
string_number	array(int)
[	O
str	int
]	O
;	O
liberties	int
=	O
string	int
[	O
s	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties	int
<=	O
MAX_LIBERTIES	int
||	O
maxlib	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
maxlib	int
&&	O
k	int
<	O
liberties	int
;	O
k	int
++	O
)	O
libs	*(int)
[	O
k	int
]	O
=	O
string_libs	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
;	O
}	O
else	O
{	O
int	O
pos	int
;	O
liberty_mark	int
++	O
;	O
for	O
(	O
k	int
=	O
0	int
,	O
pos	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
k	int
<	O
maxlib	int
&&	O
k	int
<	O
liberties	int
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
libs	*(int)
[	O
k	int
++	O
]	O
=	O
SOUTH	O
(	O
pos	int
)	O
;	O
MARK_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
if	O
(	O
k	int
>=	O
maxlib	int
)	O
break	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
libs	*(int)
[	O
k	int
++	O
]	O
=	O
WEST	O
(	O
pos	int
)	O
;	O
MARK_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
if	O
(	O
k	int
>=	O
maxlib	int
)	O
break	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
libs	*(int)
[	O
k	int
++	O
]	O
=	O
NORTH	O
(	O
pos	int
)	O
;	O
MARK_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
if	O
(	O
k	int
>=	O
maxlib	int
)	O
break	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
libs	*(int)
[	O
k	int
++	O
]	O
=	O
EAST	O
(	O
pos	int
)	O
;	O
MARK_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
if	O
(	O
k	int
>=	O
maxlib	int
)	O
break	O
;	O
}	O
}	O
}	O
return	O
liberties	int
;	O
}	O
int	O
fastlib	(int,int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
ignore_captures	int
)	O
{	O
int	O
ally1	int
=	O
-	O
1	int
;	O
int	O
ally2	int
=	O
-	O
1	int
;	O
int	O
fast_liberties	int
=	O
0	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
ally1	int
=	O
string_number	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
{	O
ally2	int
=	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
&&	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
!=	O
ally2	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
ally2	int
=	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
{	O
if	O
(	O
ally2	int
<	O
0	int
)	O
ally2	int
=	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
else	O
if	O
(	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally2	int
)	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
ally1	int
=	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
{	O
ally2	int
=	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
&&	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally2	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
ally2	int
=	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
ally1	int
=	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
&&	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
ally1	int
)	O
ally2	int
=	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
ally1	int
=	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
ignore_captures	int
)	O
{	O
if	O
(	O
ally1	int
<	O
0	int
)	O
{	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
fast_liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
ally2	int
<	O
0	int
)	O
{	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_SOUTH_NEIGHBOR_OF_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_WEST_NEIGHBOR_OF_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_NORTH_NEIGHBOR_OF_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_EAST_NEIGHBOR_OF_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
fast_liberties	int
+=	O
string	int
[	O
ally1	int
]	O
.	O
liberties	int
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_SOUTH_NEIGHBOR_OF_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
&&	O
!	O
NON_SOUTH_NEIGHBOR_OF_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
ally2	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_WEST_NEIGHBOR_OF_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
&&	O
!	O
NON_WEST_NEIGHBOR_OF_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
ally2	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_NORTH_NEIGHBOR_OF_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
&&	O
!	O
NON_NORTH_NEIGHBOR_OF_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
ally2	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
&&	O
!	O
NON_EAST_NEIGHBOR_OF_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
ally1	int
,	O
color	int
)	O
&&	O
!	O
NON_EAST_NEIGHBOR_OF_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
ally2	int
,	O
color	int
)	O
)	O
fast_liberties	int
++	O
;	O
fast_liberties	int
+=	O
string	int
[	O
ally1	int
]	O
.	O
liberties	int
+	O
string	int
[	O
ally2	int
]	O
.	O
liberties	int
-	O
count_common_libs	(int,int)->(int)
(	O
string	int
[	O
ally1	int
]	O
.	O
origin	int
,	O
string	int
[	O
ally2	int
]	O
.	O
origin	int
)	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
neighbor	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
LIBERTY	O
(	O
neighbor	int
)	O
&&	O
(	O
ally1	int
<	O
0	int
||	O
!	O
NEIGHBOR_OF_STRING	O
(	O
neighbor	int
,	O
ally1	int
,	O
color	int
)	O
)	O
&&	O
(	O
ally2	int
<	O
0	int
||	O
!	O
NEIGHBOR_OF_STRING	O
(	O
neighbor	int
,	O
ally2	int
,	O
color	int
)	O
)	O
)	O
fast_liberties	int
++	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
neighbor	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
LIBERTIES	O
(	O
neighbor	int
)	O
==	O
1	int
)	O
{	O
int	O
neighbor_size	int
=	O
COUNTSTONES	O
(	O
neighbor	int
)	O
;	O
if	O
(	O
neighbor_size	int
==	O
1	int
||	O
(	O
neighbor_size	int
==	O
2	int
&&	O
ally1	int
<	O
0	int
)	O
)	O
fast_liberties	int
++	O
;	O
else	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
ally1	int
>=	O
0	int
)	O
{	O
fast_liberties	int
+=	O
string	int
[	O
ally1	int
]	O
.	O
liberties	int
-	O
1	int
;	O
if	O
(	O
ally2	int
>=	O
0	int
)	O
fast_liberties	int
+=	O
string	int
[	O
ally2	int
]	O
.	O
liberties	int
-	O
count_common_libs	(int,int)->(int)
(	O
string	int
[	O
ally1	int
]	O
.	O
origin	int
,	O
string	int
[	O
ally2	int
]	O
.	O
origin	int
)	O
;	O
}	O
}	O
return	O
fast_liberties	int
;	O
}	O
struct	O
board_cache_entry	struct(int,int,struct(array(long)))
{	O
int	O
threshold	int
;	O
int	O
liberties	int
;	O
Hash_data	struct(array(long))
position_hash	struct(array(long))
;	O
}	O
;	O
static	O
struct	O
board_cache_entry	struct(int,int,struct(array(long)))
approxlib_cache	array(array(struct(int,int,struct(array(long)))))
[	O
BOARDMAX	O
]	O
[	O
2	int
]	O
;	O
void	O
clear_approxlib_cache	()->(void)
(	O
void	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
approxlib_cache	array(array(struct(int,int,struct(array(long)))))
[	O
pos	int
]	O
[	O
0	int
]	O
.	O
threshold	int
=	O
0	int
;	O
approxlib_cache	array(array(struct(int,int,struct(array(long)))))
[	O
pos	int
]	O
[	O
1	int
]	O
.	O
threshold	int
=	O
0	int
;	O
}	O
}	O
int	O
approxlib	(int,int,int,*(int))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	*(int)
)	O
{	O
int	O
liberties	int
;	O
struct	O
board_cache_entry	struct(int,int,struct(array(long)))
*	O
entry	*(struct(int,int,struct(array(long))))
=	O
&	O
approxlib_cache	array(array(struct(int,int,struct(array(long)))))
[	O
pos	int
]	O
[	O
color	int
-	O
1	int
]	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
!	O
libs	*(int)
)	O
{	O
if	O
(	O
hashdata_is_equal	O
(	O
board_hash	struct(array(long))
,	O
entry	*(struct(int,int,struct(array(long))))
->	O
position_hash	struct(array(long))
)	O
&&	O
maxlib	int
<=	O
entry	*(struct(int,int,struct(array(long))))
->	O
threshold	int
)	O
{	O
return	O
entry	*(struct(int,int,struct(array(long))))
->	O
liberties	int
;	O
}	O
liberties	int
=	O
fastlib	(int,int,int)->(int)
(	O
pos	int
,	O
color	int
,	O
1	int
)	O
;	O
if	O
(	O
liberties	int
>=	O
0	int
)	O
{	O
entry	*(struct(int,int,struct(array(long))))
->	O
threshold	int
=	O
MAXLIBS	O
;	O
entry	*(struct(int,int,struct(array(long))))
->	O
liberties	int
=	O
liberties	int
;	O
entry	*(struct(int,int,struct(array(long))))
->	O
position_hash	struct(array(long))
=	O
board_hash	struct(array(long))
;	O
return	O
liberties	int
;	O
}	O
}	O
entry	*(struct(int,int,struct(array(long))))
->	O
threshold	int
=	O
maxlib	int
;	O
if	O
(	O
maxlib	int
<=	O
MAX_LIBERTIES	int
)	O
liberties	int
=	O
do_approxlib	(int,int,int,*(int))->(int)
(	O
pos	int
,	O
color	int
,	O
maxlib	int
,	O
libs	*(int)
)	O
;	O
else	O
liberties	int
=	O
slow_approxlib	(int,int,int,*(int))->(int)
(	O
pos	int
,	O
color	int
,	O
maxlib	int
,	O
libs	*(int)
)	O
;	O
entry	*(struct(int,int,struct(array(long))))
->	O
liberties	int
=	O
liberties	int
;	O
entry	*(struct(int,int,struct(array(long))))
->	O
position_hash	struct(array(long))
=	O
board_hash	struct(array(long))
;	O
return	O
liberties	int
;	O
}	O
static	O
int	O
do_approxlib	(int,int,int,*(int))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	*(int)
)	O
{	O
int	O
k	int
;	O
int	O
liberties	int
=	O
0	int
;	O
liberty_mark	int
++	O
;	O
MARK_LIBERTY	O
(	O
pos	int
)	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	*(int)
!=	O
NULL	O
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
SOUTH	O
(	O
pos	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
int	O
s	int
=	O
string_number	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
lib	int
=	O
string_libs	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
lib	int
)	O
)	O
{	O
if	O
(	O
libs	*(int)
!=	O
NULL	O
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
lib	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	*(int)
!=	O
NULL	O
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
WEST	O
(	O
pos	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
int	O
s	int
=	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
lib	int
=	O
string_libs	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
lib	int
)	O
)	O
{	O
if	O
(	O
libs	*(int)
!=	O
NULL	O
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
lib	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	*(int)
!=	O
NULL	O
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
NORTH	O
(	O
pos	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
int	O
s	int
=	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
lib	int
=	O
string_libs	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
lib	int
)	O
)	O
{	O
if	O
(	O
libs	*(int)
!=	O
NULL	O
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
lib	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	*(int)
!=	O
NULL	O
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
EAST	O
(	O
pos	int
)	O
;	O
liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
int	O
s	int
=	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
lib	int
=	O
string_libs	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
lib	int
)	O
)	O
{	O
if	O
(	O
libs	*(int)
!=	O
NULL	O
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
lib	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
libs	*(int)
)	O
approxlib_cache	array(array(struct(int,int,struct(array(long)))))
[	O
pos	int
]	O
[	O
color	int
-	O
1	int
]	O
.	O
threshold	int
=	O
MAXLIBS	O
;	O
return	O
liberties	int
;	O
}	O
static	O
int	O
slow_approxlib	(int,int,int,*(int))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	*(int)
)	O
{	O
int	O
k	int
;	O
int	O
liberties	int
=	O
0	int
;	O
liberty_mark	int
++	O
;	O
MARK_LIBERTY	O
(	O
pos	int
)	O
;	O
string_mark	int
++	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
pos	int
+	O
d	int
)	O
)	O
{	O
if	O
(	O
libs	*(int)
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
pos	int
+	O
d	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
==	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
pos	int
+	O
d	int
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
d	int
]	O
==	O
color	int
&&	O
UNMARKED_STRING	O
(	O
pos	int
+	O
d	int
)	O
)	O
{	O
int	O
s	int
=	O
string_number	array(int)
[	O
pos	int
+	O
d	int
]	O
;	O
int	O
pos2	int
;	O
pos2	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
do	O
{	O
int	O
l	int
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
4	int
;	O
l	int
++	O
)	O
{	O
int	O
d2	int
=	O
delta	array(int)
[	O
l	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
pos2	int
+	O
d2	int
)	O
)	O
{	O
if	O
(	O
libs	*(int)
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
pos2	int
+	O
d2	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
==	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
pos2	int
+	O
d2	int
)	O
;	O
}	O
}	O
pos2	int
=	O
NEXT_STONE	O
(	O
pos2	int
)	O
;	O
}	O
while	O
(	O
!	O
BACK_TO_FIRST_STONE	O
(	O
s	int
,	O
pos2	int
)	O
)	O
;	O
MARK_STRING	O
(	O
pos	int
+	O
d	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
libs	*(int)
)	O
approxlib_cache	array(array(struct(int,int,struct(array(long)))))
[	O
pos	int
]	O
[	O
color	int
-	O
1	int
]	O
.	O
threshold	int
=	O
MAXLIBS	O
;	O
return	O
liberties	int
;	O
}	O
static	O
struct	O
board_cache_entry	struct(int,int,struct(array(long)))
accuratelib_cache	array(array(struct(int,int,struct(array(long)))))
[	O
BOARDMAX	O
]	O
[	O
2	int
]	O
;	O
void	O
clear_accuratelib_cache	()->(void)
(	O
void	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
accuratelib_cache	array(array(struct(int,int,struct(array(long)))))
[	O
pos	int
]	O
[	O
0	int
]	O
.	O
threshold	int
=	O
0	int
;	O
accuratelib_cache	array(array(struct(int,int,struct(array(long)))))
[	O
pos	int
]	O
[	O
1	int
]	O
.	O
threshold	int
=	O
0	int
;	O
}	O
}	O
int	O
accuratelib	(int,int,int,*(int))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	*(int)
)	O
{	O
int	O
liberties	int
;	O
struct	O
board_cache_entry	struct(int,int,struct(array(long)))
*	O
entry	*(struct(int,int,struct(array(long))))
=	O
&	O
accuratelib_cache	array(array(struct(int,int,struct(array(long)))))
[	O
pos	int
]	O
[	O
color	int
-	O
1	int
]	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
!	O
libs	*(int)
)	O
{	O
if	O
(	O
hashdata_is_equal	O
(	O
board_hash	struct(array(long))
,	O
entry	*(struct(int,int,struct(array(long))))
->	O
position_hash	struct(array(long))
)	O
&&	O
maxlib	int
<=	O
entry	*(struct(int,int,struct(array(long))))
->	O
threshold	int
)	O
{	O
return	O
entry	*(struct(int,int,struct(array(long))))
->	O
liberties	int
;	O
}	O
liberties	int
=	O
fastlib	(int,int,int)->(int)
(	O
pos	int
,	O
color	int
,	O
0	int
)	O
;	O
if	O
(	O
liberties	int
>=	O
0	int
)	O
{	O
entry	*(struct(int,int,struct(array(long))))
->	O
threshold	int
=	O
MAXLIBS	O
;	O
entry	*(struct(int,int,struct(array(long))))
->	O
liberties	int
=	O
liberties	int
;	O
entry	*(struct(int,int,struct(array(long))))
->	O
position_hash	struct(array(long))
=	O
board_hash	struct(array(long))
;	O
return	O
liberties	int
;	O
}	O
}	O
liberties	int
=	O
do_accuratelib	(int,int,int,*(int))->(int)
(	O
pos	int
,	O
color	int
,	O
maxlib	int
,	O
libs	*(int)
)	O
;	O
entry	*(struct(int,int,struct(array(long))))
->	O
threshold	int
=	O
liberties	int
<	O
maxlib	int
?	O
MAXLIBS	O
:	O
maxlib	int
;	O
entry	*(struct(int,int,struct(array(long))))
->	O
liberties	int
=	O
liberties	int
;	O
entry	*(struct(int,int,struct(array(long))))
->	O
position_hash	struct(array(long))
=	O
board_hash	struct(array(long))
;	O
return	O
liberties	int
;	O
}	O
static	O
int	O
do_accuratelib	(int,int,int,*(int))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	*(int)
)	O
{	O
int	O
k	int
,	O
l	int
;	O
int	O
liberties	int
=	O
0	int
;	O
int	O
lib	int
;	O
int	O
captured	array(int)
[	O
4	int
]	O
;	O
int	O
captures	int
=	O
0	int
;	O
string_mark	int
++	O
;	O
liberty_mark	int
++	O
;	O
MARK_LIBERTY	O
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
pos2	int
)	O
)	O
{	O
if	O
(	O
libs	*(int)
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
pos2	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
pos2	int
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
pos2	int
,	O
color	int
)	O
)	O
{	O
struct	O
string_data	struct(int,int,int,int,int,int)
*	O
s	int
=	O
&	O
string	int
[	O
string_number	array(int)
[	O
pos2	int
]	O
]	O
;	O
struct	O
string_liberties_data	struct(array(int))
*	O
sl	*(struct(array(int)))
=	O
&	O
string_libs	array(struct(array(int)))
[	O
string_number	array(int)
[	O
pos2	int
]	O
]	O
;	O
if	O
(	O
s	int
->	O
liberties	int
<=	O
MAX_LIBERTIES	int
||	O
maxlib	int
<=	O
MAX_LIBERTIES	int
-	O
1	int
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
s	int
->	O
liberties	int
;	O
l	int
++	O
)	O
{	O
lib	int
=	O
sl	*(struct(array(int)))
->	O
list	array(int)
[	O
l	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
lib	int
)	O
)	O
{	O
if	O
(	O
libs	*(int)
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
lib	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
int	O
stone	int
=	O
pos2	int
;	O
do	O
{	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
stone	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	*(int)
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
SOUTH	O
(	O
stone	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
SOUTH	O
(	O
stone	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
stone	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	*(int)
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
WEST	O
(	O
stone	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
WEST	O
(	O
stone	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
stone	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	*(int)
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
NORTH	O
(	O
stone	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
NORTH	O
(	O
stone	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
stone	int
)	O
)	O
)	O
{	O
if	O
(	O
libs	*(int)
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
EAST	O
(	O
stone	int
)	O
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
MARK_LIBERTY	O
(	O
EAST	O
(	O
stone	int
)	O
)	O
;	O
}	O
stone	int
=	O
NEXT_STONE	O
(	O
stone	int
)	O
;	O
}	O
while	O
(	O
stone	int
!=	O
pos2	int
)	O
;	O
}	O
MARK_STRING	O
(	O
pos2	int
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
string	int
[	O
string_number	array(int)
[	O
pos2	int
]	O
]	O
.	O
liberties	int
==	O
1	int
)	O
{	O
captured	array(int)
[	O
captures	int
++	O
]	O
=	O
pos2	int
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
captures	int
;	O
k	int
++	O
)	O
{	O
lib	int
=	O
captured	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
!	O
MARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
lib	int
)	O
,	O
color	int
)	O
&&	O
!	O
MARKED_COLOR_STRING	O
(	O
WEST	O
(	O
lib	int
)	O
,	O
color	int
)	O
&&	O
!	O
MARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
lib	int
)	O
,	O
color	int
)	O
&&	O
!	O
MARKED_COLOR_STRING	O
(	O
EAST	O
(	O
lib	int
)	O
,	O
color	int
)	O
)	O
{	O
if	O
(	O
libs	*(int)
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
}	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
k	int
;	O
l	int
++	O
)	O
if	O
(	O
string_number	array(int)
[	O
captured	array(int)
[	O
l	int
]	O
]	O
==	O
string_number	array(int)
[	O
lib	int
]	O
)	O
break	O
;	O
if	O
(	O
l	int
==	O
k	int
)	O
{	O
do	O
{	O
if	O
(	O
MARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
lib	int
)	O
,	O
color	int
)	O
||	O
MARKED_COLOR_STRING	O
(	O
WEST	O
(	O
lib	int
)	O
,	O
color	int
)	O
||	O
MARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
lib	int
)	O
,	O
color	int
)	O
||	O
MARKED_COLOR_STRING	O
(	O
EAST	O
(	O
lib	int
)	O
,	O
color	int
)	O
)	O
{	O
if	O
(	O
libs	*(int)
)	O
libs	*(int)
[	O
liberties	int
]	O
=	O
lib	int
;	O
liberties	int
++	O
;	O
if	O
(	O
liberties	int
>=	O
maxlib	int
)	O
return	O
liberties	int
;	O
}	O
lib	int
=	O
NEXT_STONE	O
(	O
lib	int
)	O
;	O
}	O
while	O
(	O
lib	int
!=	O
captured	array(int)
[	O
k	int
]	O
)	O
;	O
}	O
}	O
return	O
liberties	int
;	O
}	O
int	O
count_common_libs	(int,int)->(int)
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
all_libs1	array(int)
[	O
MAXLIBS	O
]	O
,	O
*	O
libs1	*(int)
;	O
int	O
liberties1	int
,	O
liberties2	int
;	O
int	O
commonlibs	int
=	O
0	int
;	O
int	O
k	int
,	O
n	int
,	O
tmp	int
;	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
n	int
=	O
string_number	array(int)
[	O
str1	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties1	int
>	O
string	int
[	O
string_number	array(int)
[	O
str2	int
]	O
]	O
.	O
liberties	int
)	O
{	O
n	int
=	O
string_number	array(int)
[	O
str2	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
tmp	int
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	int
;	O
}	O
if	O
(	O
liberties1	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
libs1	*(int)
=	O
string_libs	array(struct(array(int)))
[	O
n	int
]	O
.	O
list	array(int)
;	O
n	int
=	O
string_number	array(int)
[	O
str2	int
]	O
;	O
liberties2	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties2	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
liberty_mark	int
++	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties1	int
;	O
k	int
++	O
)	O
MARK_LIBERTY	O
(	O
libs1	*(int)
[	O
k	int
]	O
)	O
;	O
libs1	*(int)
=	O
string_libs	array(struct(array(int)))
[	O
n	int
]	O
.	O
list	array(int)
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties2	int
;	O
k	int
++	O
)	O
if	O
(	O
!	O
UNMARKED_LIBERTY	O
(	O
libs1	*(int)
[	O
k	int
]	O
)	O
)	O
commonlibs	int
++	O
;	O
return	O
commonlibs	int
;	O
}	O
}	O
else	O
{	O
findlib	(int,int,*(int))->(int)
(	O
str1	int
,	O
MAXLIBS	O
,	O
all_libs1	array(int)
)	O
;	O
libs1	*(int)
=	O
all_libs1	array(int)
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties1	int
;	O
k	int
++	O
)	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
libs1	*(int)
[	O
k	int
]	O
,	O
string_number	array(int)
[	O
str2	int
]	O
,	O
board	*(char)
[	O
str2	int
]	O
)	O
)	O
commonlibs	int
++	O
;	O
return	O
commonlibs	int
;	O
}	O
int	O
find_common_libs	(int,int,int,*(int))->(int)
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
maxlib	int
,	O
int	O
*	O
libs	*(int)
)	O
{	O
int	O
all_libs1	array(int)
[	O
MAXLIBS	O
]	O
,	O
*	O
libs1	*(int)
;	O
int	O
liberties1	int
,	O
liberties2	int
;	O
int	O
commonlibs	int
=	O
0	int
;	O
int	O
k	int
,	O
n	int
,	O
tmp	int
;	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
ASSERT1	O
(	O
libs	*(int)
!=	O
NULL	O
,	O
str1	int
)	O
;	O
n	int
=	O
string_number	array(int)
[	O
str1	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties1	int
>	O
string	int
[	O
string_number	array(int)
[	O
str2	int
]	O
]	O
.	O
liberties	int
)	O
{	O
n	int
=	O
string_number	array(int)
[	O
str2	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
tmp	int
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	int
;	O
}	O
if	O
(	O
liberties1	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
libs1	*(int)
=	O
string_libs	array(struct(array(int)))
[	O
n	int
]	O
.	O
list	array(int)
;	O
n	int
=	O
string_number	array(int)
[	O
str2	int
]	O
;	O
liberties2	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties2	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
liberty_mark	int
++	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties1	int
;	O
k	int
++	O
)	O
MARK_LIBERTY	O
(	O
libs1	*(int)
[	O
k	int
]	O
)	O
;	O
libs1	*(int)
=	O
string_libs	array(struct(array(int)))
[	O
n	int
]	O
.	O
list	array(int)
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties2	int
;	O
k	int
++	O
)	O
if	O
(	O
!	O
UNMARKED_LIBERTY	O
(	O
libs1	*(int)
[	O
k	int
]	O
)	O
)	O
{	O
if	O
(	O
commonlibs	int
<	O
maxlib	int
)	O
libs	*(int)
[	O
commonlibs	int
]	O
=	O
libs1	*(int)
[	O
k	int
]	O
;	O
commonlibs	int
++	O
;	O
}	O
return	O
commonlibs	int
;	O
}	O
}	O
else	O
{	O
findlib	(int,int,*(int))->(int)
(	O
str1	int
,	O
MAXLIBS	O
,	O
all_libs1	array(int)
)	O
;	O
libs1	*(int)
=	O
all_libs1	array(int)
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties1	int
;	O
k	int
++	O
)	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
libs1	*(int)
[	O
k	int
]	O
,	O
string_number	array(int)
[	O
str2	int
]	O
,	O
board	*(char)
[	O
str2	int
]	O
)	O
)	O
{	O
if	O
(	O
commonlibs	int
<	O
maxlib	int
)	O
libs	*(int)
[	O
commonlibs	int
]	O
=	O
libs1	*(int)
[	O
k	int
]	O
;	O
commonlibs	int
++	O
;	O
}	O
return	O
commonlibs	int
;	O
}	O
int	O
have_common_lib	(int,int,*(int))->(int)
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
*	O
lib	int
)	O
{	O
int	O
all_libs1	array(int)
[	O
MAXLIBS	O
]	O
,	O
*	O
libs1	*(int)
;	O
int	O
liberties1	int
;	O
int	O
k	int
,	O
n	int
,	O
tmp	int
;	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
n	int
=	O
string_number	array(int)
[	O
str1	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
if	O
(	O
liberties1	int
>	O
string	int
[	O
string_number	array(int)
[	O
str2	int
]	O
]	O
.	O
liberties	int
)	O
{	O
n	int
=	O
string_number	array(int)
[	O
str2	int
]	O
;	O
liberties1	int
=	O
string	int
[	O
n	int
]	O
.	O
liberties	int
;	O
tmp	int
=	O
str1	int
;	O
str1	int
=	O
str2	int
;	O
str2	int
=	O
tmp	int
;	O
}	O
if	O
(	O
liberties1	int
<=	O
MAX_LIBERTIES	int
)	O
libs1	*(int)
=	O
string_libs	array(struct(array(int)))
[	O
n	int
]	O
.	O
list	array(int)
;	O
else	O
{	O
findlib	(int,int,*(int))->(int)
(	O
str1	int
,	O
MAXLIBS	O
,	O
all_libs1	array(int)
)	O
;	O
libs1	*(int)
=	O
all_libs1	array(int)
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties1	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
libs1	*(int)
[	O
k	int
]	O
,	O
string_number	array(int)
[	O
str2	int
]	O
,	O
board	*(char)
[	O
str2	int
]	O
)	O
)	O
{	O
if	O
(	O
lib	int
)	O
*	O
lib	int
=	O
libs1	*(int)
[	O
k	int
]	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
countstones	(int)->(int)
(	O
int	O
str	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
return	O
COUNTSTONES	O
(	O
str	int
)	O
;	O
}	O
int	O
findstones	(int,int,*(int))->(int)
(	O
int	O
str	int
,	O
int	O
maxstones	int
,	O
int	O
*	O
stones	*(int)
)	O
{	O
int	O
s	int
;	O
int	O
size	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
s	int
=	O
string_number	array(int)
[	O
str	int
]	O
;	O
size	int
=	O
string	int
[	O
s	int
]	O
.	O
size	int
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
maxstones	int
&&	O
k	int
<	O
size	int
;	O
k	int
++	O
)	O
{	O
stones	*(int)
[	O
k	int
]	O
=	O
pos	int
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
return	O
size	int
;	O
}	O
int	O
count_adjacent_stones	(int,int,int)->(int)
(	O
int	O
str1	int
,	O
int	O
str2	int
,	O
int	O
maxstones	int
)	O
{	O
int	O
s1	int
,	O
s2	int
;	O
int	O
size	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
count	int
=	O
0	int
;	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
s1	int
=	O
string_number	array(int)
[	O
str1	int
]	O
;	O
s2	int
=	O
string_number	array(int)
[	O
str2	int
]	O
;	O
size	int
=	O
string	int
[	O
s1	int
]	O
.	O
size	int
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
size	int
&&	O
count	int
<	O
maxstones	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
pos	int
,	O
s2	int
,	O
board	*(char)
[	O
str2	int
]	O
)	O
)	O
count	int
++	O
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
return	O
count	int
;	O
}	O
int	O
chainlinks	(int,array(int))->(int)
(	O
int	O
str	int
,	O
int	O
adj	array(int)
[	O
MAXCHAIN	int
]	O
)	O
{	O
struct	O
string_data	struct(int,int,int,int,int,int)
*	O
s	int
;	O
struct	O
string_neighbors_data	struct(array(int))
*	O
sn	*(struct(array(int)))
;	O
int	O
k	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
s	int
=	O
&	O
string	int
[	O
string_number	array(int)
[	O
str	int
]	O
]	O
;	O
sn	*(struct(array(int)))
=	O
&	O
string_neighbors	array(struct(array(int)))
[	O
string_number	array(int)
[	O
str	int
]	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s	int
->	O
neighbors	int
;	O
k	int
++	O
)	O
adj	array(int)
[	O
k	int
]	O
=	O
string	int
[	O
sn	*(struct(array(int)))
->	O
list	array(int)
[	O
k	int
]	O
]	O
.	O
origin	int
;	O
return	O
s	int
->	O
neighbors	int
;	O
}	O
int	O
chainlinks2	(int,array(int),int)->(int)
(	O
int	O
str	int
,	O
int	O
adj	array(int)
[	O
MAXCHAIN	int
]	O
,	O
int	O
lib	int
)	O
{	O
struct	O
string_data	struct(int,int,int,int,int,int)
*	O
s	int
,	O
*	O
t	*(struct(int,int,int,int,int,int))
;	O
struct	O
string_neighbors_data	struct(array(int))
*	O
sn	*(struct(array(int)))
;	O
int	O
k	int
;	O
int	O
neighbors	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
neighbors	int
=	O
0	int
;	O
s	int
=	O
&	O
string	int
[	O
string_number	array(int)
[	O
str	int
]	O
]	O
;	O
sn	*(struct(array(int)))
=	O
&	O
string_neighbors	array(struct(array(int)))
[	O
string_number	array(int)
[	O
str	int
]	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s	int
->	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
t	*(struct(int,int,int,int,int,int))
=	O
&	O
string	int
[	O
sn	*(struct(array(int)))
->	O
list	array(int)
[	O
k	int
]	O
]	O
;	O
if	O
(	O
t	*(struct(int,int,int,int,int,int))
->	O
liberties	int
==	O
lib	int
)	O
adj	array(int)
[	O
neighbors	int
++	O
]	O
=	O
t	*(struct(int,int,int,int,int,int))
->	O
origin	int
;	O
}	O
return	O
neighbors	int
;	O
}	O
int	O
chainlinks3	(int,array(int),int)->(int)
(	O
int	O
str	int
,	O
int	O
adj	array(int)
[	O
MAXCHAIN	int
]	O
,	O
int	O
lib	int
)	O
{	O
struct	O
string_data	struct(int,int,int,int,int,int)
*	O
s	int
,	O
*	O
t	*(struct(int,int,int,int,int,int))
;	O
struct	O
string_neighbors_data	struct(array(int))
*	O
sn	*(struct(array(int)))
;	O
int	O
k	int
;	O
int	O
neighbors	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
neighbors	int
=	O
0	int
;	O
s	int
=	O
&	O
string	int
[	O
string_number	array(int)
[	O
str	int
]	O
]	O
;	O
sn	*(struct(array(int)))
=	O
&	O
string_neighbors	array(struct(array(int)))
[	O
string_number	array(int)
[	O
str	int
]	O
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s	int
->	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
t	*(struct(int,int,int,int,int,int))
=	O
&	O
string	int
[	O
sn	*(struct(array(int)))
->	O
list	array(int)
[	O
k	int
]	O
]	O
;	O
if	O
(	O
t	*(struct(int,int,int,int,int,int))
->	O
liberties	int
<=	O
lib	int
)	O
adj	array(int)
[	O
neighbors	int
++	O
]	O
=	O
t	*(struct(int,int,int,int,int,int))
->	O
origin	int
;	O
}	O
return	O
neighbors	int
;	O
}	O
int	O
extended_chainlinks	(int,array(int),int)->(int)
(	O
int	O
str	int
,	O
int	O
adj	array(int)
[	O
MAXCHAIN	int
]	O
,	O
int	O
both_colors	int
)	O
{	O
struct	O
string_data	struct(int,int,int,int,int,int)
*	O
s	int
;	O
struct	O
string_neighbors_data	struct(array(int))
*	O
sn	*(struct(array(int)))
;	O
int	O
n	int
;	O
int	O
k	int
;	O
int	O
r	int
;	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
s	int
=	O
&	O
string	int
[	O
string_number	array(int)
[	O
str	int
]	O
]	O
;	O
sn	*(struct(array(int)))
=	O
&	O
string_neighbors	array(struct(array(int)))
[	O
string_number	array(int)
[	O
str	int
]	O
]	O
;	O
string_mark	int
++	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
s	int
->	O
neighbors	int
;	O
n	int
++	O
)	O
{	O
adj	array(int)
[	O
n	int
]	O
=	O
string	int
[	O
sn	*(struct(array(int)))
->	O
list	array(int)
[	O
n	int
]	O
]	O
.	O
origin	int
;	O
MARK_STRING	O
(	O
adj	array(int)
[	O
n	int
]	O
)	O
;	O
}	O
liberties	int
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	int
;	O
r	int
++	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
(	O
board	*(char)
[	O
libs	*(int)
[	O
r	int
]	O
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
||	O
(	O
both_colors	int
&&	O
board	*(char)
[	O
libs	*(int)
[	O
r	int
]	O
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
board	*(char)
[	O
str	int
]	O
)	O
)	O
&&	O
UNMARKED_STRING	O
(	O
libs	*(int)
[	O
r	int
]	O
+	O
delta	array(int)
[	O
k	int
]	O
)	O
)	O
{	O
adj	array(int)
[	O
n	int
]	O
=	O
string	int
[	O
string_number	array(int)
[	O
libs	*(int)
[	O
r	int
]	O
+	O
delta	array(int)
[	O
k	int
]	O
]	O
]	O
.	O
origin	int
;	O
MARK_STRING	O
(	O
adj	array(int)
[	O
n	int
]	O
)	O
;	O
n	int
++	O
;	O
}	O
}	O
}	O
return	O
n	int
;	O
}	O
int	O
send_two_return_one	(int,int)->(int)
(	O
int	O
move	*(int)
,	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
lib	int
=	O
NO_MOVE	O
;	O
int	O
friendly_neighbor	int
=	O
NO_MOVE	O
;	O
int	O
k	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
move	*(int)
]	O
==	O
EMPTY	int
,	O
move	*(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
int	O
s	int
;	O
if	O
(	O
friendly_neighbor	int
!=	O
NO_MOVE	O
)	O
return	O
0	int
;	O
friendly_neighbor	int
=	O
pos	int
;	O
s	int
=	O
string_number	array(int)
[	O
pos	int
]	O
;	O
if	O
(	O
string	int
[	O
s	int
]	O
.	O
size	int
!=	O
1	int
||	O
string	int
[	O
s	int
]	O
.	O
liberties	int
!=	O
2	int
)	O
return	O
0	int
;	O
lib	int
=	O
string_libs	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
0	int
]	O
+	O
string_libs	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
1	int
]	O
-	O
move	*(int)
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
&&	O
string	int
[	O
string_number	array(int)
[	O
pos	int
]	O
]	O
.	O
liberties	int
==	O
1	int
)	O
return	O
0	int
;	O
}	O
if	O
(	O
friendly_neighbor	int
==	O
NO_MOVE	O
)	O
return	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
lib	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
pos	int
]	O
==	O
other	int
)	O
return	O
0	int
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
string	int
[	O
string_number	array(int)
[	O
pos	int
]	O
]	O
.	O
liberties	int
<	O
2	int
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
find_origin	(int)->(int)
(	O
int	O
str	int
)	O
{	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
return	O
string	int
[	O
string_number	array(int)
[	O
str	int
]	O
]	O
.	O
origin	int
;	O
}	O
int	O
is_self_atari	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
trivial_liberties	int
=	O
0	int
;	O
int	O
captures	int
=	O
0	int
;	O
int	O
far_liberties	int
=	O
0	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
string_mark	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
trivial_liberties	int
++	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
>	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
==	O
2	int
)	O
far_liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
&&	O
UNMARKED_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
captures	int
++	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
trivial_liberties	int
++	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
>	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
==	O
2	int
)	O
far_liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
==	O
1	int
&&	O
UNMARKED_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
captures	int
++	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
trivial_liberties	int
++	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
>	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
==	O
2	int
)	O
far_liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
&&	O
UNMARKED_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
captures	int
++	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
trivial_liberties	int
++	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
>	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
==	O
2	int
)	O
far_liberties	int
++	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
==	O
1	int
&&	O
UNMARKED_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
captures	int
++	O
;	O
}	O
if	O
(	O
trivial_liberties	int
+	O
captures	int
>=	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
(	O
far_liberties	int
>	O
0	int
)	O
+	O
captures	int
>=	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
captures	int
==	O
0	int
&&	O
far_liberties	int
+	O
trivial_liberties	int
<=	O
1	int
)	O
return	O
1	int
;	O
return	O
accuratelib	(int,int,int,*(int))->(int)
(	O
pos	int
,	O
color	int
,	O
2	int
,	O
NULL	O
)	O
<=	O
1	int
;	O
}	O
int	O
liberty_of_string	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
str	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str	int
)	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
)	O
return	O
0	int
;	O
return	O
NEIGHBOR_OF_STRING	O
(	O
pos	int
,	O
string_number	array(int)
[	O
str	int
]	O
,	O
board	*(char)
[	O
str	int
]	O
)	O
;	O
}	O
int	O
second_order_liberty_of_string	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
str	int
)	O
{	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
NEIGHBOR_OF_STRING	O
(	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
,	O
string_number	array(int)
[	O
str	int
]	O
,	O
board	*(char)
[	O
str	int
]	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
neighbor_of_string	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
str	int
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
str	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
return	O
NEIGHBOR_OF_STRING	O
(	O
pos	int
,	O
string_number	array(int)
[	O
str	int
]	O
,	O
color	int
)	O
;	O
}	O
int	O
has_neighbor	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
return	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
||	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
||	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
||	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
;	O
}	O
int	O
same_string	(int,int)->(int)
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
return	O
string_number	array(int)
[	O
str1	int
]	O
==	O
string_number	array(int)
[	O
str2	int
]	O
;	O
}	O
int	O
adjacent_strings	(int,int)->(int)
(	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
s1	int
,	O
s2	int
;	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
str1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
str2	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str1	int
]	O
)	O
,	O
str1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str2	int
]	O
)	O
,	O
str2	int
)	O
;	O
s1	int
=	O
string_number	array(int)
[	O
str1	int
]	O
;	O
s2	int
=	O
string_number	array(int)
[	O
str2	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s1	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
if	O
(	O
string_neighbors	array(struct(array(int)))
[	O
s1	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
==	O
s2	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
is_ko	(int,int,*(int))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
*	O
ko_pos	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
captures	int
=	O
0	int
;	O
int	O
kpos	int
=	O
0	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
color	int
==	O
WHITE	int
||	O
color	int
==	O
BLACK	int
,	O
pos	int
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
!=	O
other	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
{	O
kpos	int
=	O
SOUTH	O
(	O
pos	int
)	O
;	O
captures	int
+=	O
string	int
[	O
string_number	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
]	O
.	O
size	int
;	O
if	O
(	O
captures	int
>	O
1	int
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
!=	O
other	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
{	O
kpos	int
=	O
WEST	O
(	O
pos	int
)	O
;	O
captures	int
+=	O
string	int
[	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
]	O
.	O
size	int
;	O
if	O
(	O
captures	int
>	O
1	int
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
!=	O
other	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
{	O
kpos	int
=	O
NORTH	O
(	O
pos	int
)	O
;	O
captures	int
+=	O
string	int
[	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
]	O
.	O
size	int
;	O
if	O
(	O
captures	int
>	O
1	int
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
other	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
{	O
kpos	int
=	O
EAST	O
(	O
pos	int
)	O
;	O
captures	int
+=	O
string	int
[	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
]	O
.	O
size	int
;	O
if	O
(	O
captures	int
>	O
1	int
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
captures	int
==	O
1	int
)	O
{	O
if	O
(	O
ko_pos	int
)	O
*	O
ko_pos	int
=	O
kpos	int
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
is_ko_point	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
color	int
;	O
if	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
color	int
=	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
else	O
color	int
=	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
IS_STONE	O
(	O
color	int
)	O
&&	O
is_ko	(int,int,*(int))->(int)
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
}	O
else	O
{	O
struct	O
string_data	struct(int,int,int,int,int,int)
*	O
s	int
=	O
&	O
string	int
[	O
string_number	array(int)
[	O
pos	int
]	O
]	O
;	O
struct	O
string_liberties_data	struct(array(int))
*	O
sl	*(struct(array(int)))
=	O
&	O
string_libs	array(struct(array(int)))
[	O
string_number	array(int)
[	O
pos	int
]	O
]	O
;	O
if	O
(	O
s	int
->	O
liberties	int
==	O
1	int
&&	O
s	int
->	O
size	int
==	O
1	int
&&	O
is_ko	(int,int,*(int))->(int)
(	O
sl	*(struct(array(int)))
->	O
list	array(int)
[	O
0	int
]	O
,	O
OTHER_COLOR	O
(	O
s	int
->	O
color	int
)	O
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
is_superko_violation	(int,int,enum(int,int,int,int))->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
enum	O
ko_rules	enum(int,int,int,int)
type	enum(int,int,int,int)
)	O
{	O
Hash_data	struct(array(long))
this_board_hash	struct(array(long))
=	O
board_hash	struct(array(long))
;	O
Hash_data	struct(array(long))
new_board_hash	struct(array(long))
;	O
int	O
k	int
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
NONE	int
||	O
type	enum(int,int,int,int)
==	O
SIMPLE	int
)	O
return	O
0	int
;	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	(*(struct(array(long))),int)->(void)
(	O
&	O
this_board_hash	struct(array(long))
,	O
board_ko_pos	int
)	O
;	O
really_do_trymove	(int,int)->(void)
(	O
pos	int
,	O
color	int
)	O
;	O
new_board_hash	struct(array(long))
=	O
board_hash	struct(array(long))
;	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	(*(struct(array(long))),int)->(void)
(	O
&	O
new_board_hash	struct(array(long))
,	O
board_ko_pos	int
)	O
;	O
undo_trymove	()->(void)
(	O
)	O
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
PSK	int
&&	O
hashdata_is_equal	O
(	O
this_board_hash	struct(array(long))
,	O
new_board_hash	struct(array(long))
)	O
)	O
return	O
1	int
;	O
for	O
(	O
k	int
=	O
move_history_pointer	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
if	O
(	O
hashdata_is_equal	O
(	O
move_history_hash	array(struct(array(long)))
[	O
k	int
]	O
,	O
new_board_hash	struct(array(long))
)	O
&&	O
(	O
type	enum(int,int,int,int)
==	O
PSK	int
||	O
move_history_color	array(int)
[	O
k	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
does_capture_something	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
other	int
&&	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
==	O
1	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
mark_string	(int,array(char),char)->(void)
(	O
int	O
str	int
,	O
signed	O
char	O
mx	array(char)
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
mark	char
)	O
{	O
int	O
pos	int
=	O
str	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
,	O
str	int
)	O
;	O
do	O
{	O
mx	array(char)
[	O
pos	int
]	O
=	O
mark	char
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
while	O
(	O
pos	int
!=	O
str	int
)	O
;	O
}	O
int	O
move_in_stack	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
cutoff	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
cutoff	int
;	O
k	int
<	O
stackp	int
;	O
k	int
++	O
)	O
if	O
(	O
stack	array(int)
[	O
k	int
]	O
==	O
pos	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
get_move_from_stack	(int,*(int),*(int))->(void)
(	O
int	O
k	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
*	O
color	int
)	O
{	O
gg_assert	O
(	O
k	int
<	O
stackp	int
)	O
;	O
*	O
move	*(int)
=	O
stack	array(int)
[	O
k	int
]	O
;	O
*	O
color	int
=	O
move_color	array(int)
[	O
k	int
]	O
;	O
}	O
int	O
stones_on_board	(int)->(int)
(	O
int	O
color	int
)	O
{	O
static	O
int	O
stone_count_for_position	int
=	O
-	O
1	int
;	O
static	O
int	O
white_stones	int
=	O
0	int
;	O
static	O
int	O
black_stones	int
=	O
0	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
stone_count_for_position	int
!=	O
position_number	int
)	O
{	O
int	O
pos	int
;	O
white_stones	int
=	O
0	int
;	O
black_stones	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
WHITE	int
)	O
white_stones	int
++	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
BLACK	int
)	O
black_stones	int
++	O
;	O
}	O
stone_count_for_position	int
=	O
position_number	int
;	O
}	O
return	O
(	O
(	O
color	int
&	O
BLACK	int
?	O
black_stones	int
:	O
0	int
)	O
+	O
(	O
color	int
&	O
WHITE	int
?	O
white_stones	int
:	O
0	int
)	O
)	O
;	O
}	O
void	O
reset_trymove_counter	()->(void)
(	O
)	O
{	O
trymove_counter	int
=	O
0	int
;	O
}	O
int	O
get_trymove_counter	()->(int)
(	O
)	O
{	O
return	O
trymove_counter	int
;	O
}	O
static	O
void	O
new_position	()->(void)
(	O
void	O
)	O
{	O
int	O
pos	int
;	O
int	O
s	int
;	O
position_number	int
++	O
;	O
next_string	int
=	O
0	int
;	O
liberty_mark	int
=	O
0	int
;	O
string_mark	int
=	O
0	int
;	O
CLEAR_STACKS	O
(	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
string	int
,	O
0	int
,	O
sizeof	O
(	O
string	int
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
string_libs	array(struct(array(int)))
,	O
0	int
,	O
sizeof	O
(	O
string_libs	array(struct(array(int)))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
string_neighbors	array(struct(array(int)))
,	O
0	int
,	O
sizeof	O
(	O
string_neighbors	array(struct(array(int)))
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
ml	array(int)
,	O
0	int
,	O
sizeof	O
(	O
ml	array(int)
)	O
)	O
;	O
VALGRIND_MAKE_WRITABLE	O
(	O
next_stone	array(int)
,	O
sizeof	O
(	O
next_stone	array(int)
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
string_number	array(int)
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
string_number	array(int)
[	O
pos	int
]	O
==	O
-	O
1	int
)	O
{	O
string_number	array(int)
[	O
pos	int
]	O
=	O
next_string	int
;	O
string	int
[	O
next_string	int
]	O
.	O
size	int
=	O
propagate_string	(int,int)->(int)
(	O
pos	int
,	O
pos	int
)	O
;	O
string	int
[	O
next_string	int
]	O
.	O
color	int
=	O
board	*(char)
[	O
pos	int
]	O
;	O
string	int
[	O
next_string	int
]	O
.	O
origin	int
=	O
pos	int
;	O
string	int
[	O
next_string	int
]	O
.	O
mark	char
=	O
0	int
;	O
next_string	int
++	O
;	O
PARANOID1	O
(	O
next_string	int
<	O
MAX_STRINGS	O
,	O
pos	int
)	O
;	O
}	O
}	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
next_string	int
;	O
s	int
++	O
)	O
{	O
find_liberties_and_neighbors	(int)->(void)
(	O
s	int
)	O
;	O
}	O
}	O
static	O
int	O
propagate_string	(int,int)->(int)
(	O
int	O
stone	int
,	O
int	O
str	int
)	O
{	O
int	O
size	int
=	O
1	int
;	O
int	O
k	int
;	O
if	O
(	O
stone	int
==	O
str	int
)	O
{	O
next_stone	array(int)
[	O
stone	int
]	O
=	O
stone	int
;	O
}	O
else	O
{	O
string_number	array(int)
[	O
stone	int
]	O
=	O
string_number	array(int)
[	O
str	int
]	O
;	O
next_stone	array(int)
[	O
stone	int
]	O
=	O
next_stone	array(int)
[	O
str	int
]	O
;	O
next_stone	array(int)
[	O
str	int
]	O
=	O
stone	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
stone	int
+	O
d	int
)	O
&&	O
board	*(char)
[	O
stone	int
+	O
d	int
]	O
==	O
board	*(char)
[	O
stone	int
]	O
&&	O
string_number	array(int)
[	O
stone	int
+	O
d	int
]	O
==	O
-	O
1	int
)	O
size	int
+=	O
propagate_string	(int,int)->(int)
(	O
stone	int
+	O
d	int
,	O
str	int
)	O
;	O
}	O
return	O
size	int
;	O
}	O
static	O
void	O
find_liberties_and_neighbors	(int)->(void)
(	O
int	O
s	int
)	O
{	O
int	O
pos	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
string	int
[	O
s	int
]	O
.	O
color	int
)	O
;	O
liberty_mark	int
++	O
;	O
string_mark	int
++	O
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
do	O
{	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
MARK_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
while	O
(	O
!	O
BACK_TO_FIRST_STONE	O
(	O
s	int
,	O
pos	int
)	O
)	O
;	O
}	O
static	O
void	O
update_liberties	(int)->(void)
(	O
int	O
s	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
liberties	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
liberties	int
&&	O
k	int
<	O
MAX_LIBERTIES	int
;	O
k	int
++	O
)	O
{	O
PUSH_VALUE	O
(	O
string_libs	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
)	O
;	O
}	O
string	int
[	O
s	int
]	O
.	O
liberties	int
=	O
0	int
;	O
liberty_mark	int
++	O
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
do	O
{	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
while	O
(	O
!	O
BACK_TO_FIRST_STONE	O
(	O
s	int
,	O
pos	int
)	O
)	O
;	O
}	O
static	O
void	O
remove_neighbor	(int,int)->(void)
(	O
int	O
str_number	int
,	O
int	O
n	int
)	O
{	O
int	O
k	int
;	O
int	O
done	int
=	O
0	int
;	O
struct	O
string_data	struct(int,int,int,int,int,int)
*	O
s	int
=	O
&	O
string	int
[	O
str_number	int
]	O
;	O
struct	O
string_neighbors_data	struct(array(int))
*	O
sn	*(struct(array(int)))
=	O
&	O
string_neighbors	array(struct(array(int)))
[	O
str_number	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s	int
->	O
neighbors	int
;	O
k	int
++	O
)	O
if	O
(	O
sn	*(struct(array(int)))
->	O
list	array(int)
[	O
k	int
]	O
==	O
n	int
)	O
{	O
PUSH_VALUE	O
(	O
sn	*(struct(array(int)))
->	O
list	array(int)
[	O
s	int
->	O
neighbors	int
-	O
1	int
]	O
)	O
;	O
PUSH_VALUE	O
(	O
sn	*(struct(array(int)))
->	O
list	array(int)
[	O
k	int
]	O
)	O
;	O
PUSH_VALUE	O
(	O
s	int
->	O
neighbors	int
)	O
;	O
sn	*(struct(array(int)))
->	O
list	array(int)
[	O
k	int
]	O
=	O
sn	*(struct(array(int)))
->	O
list	array(int)
[	O
s	int
->	O
neighbors	int
-	O
1	int
]	O
;	O
s	int
->	O
neighbors	int
--	O
;	O
done	int
=	O
1	int
;	O
break	O
;	O
}	O
gg_assert	O
(	O
done	int
)	O
;	O
}	O
static	O
void	O
remove_liberty	(int,int)->(void)
(	O
int	O
str_number	int
,	O
int	O
pos	int
)	O
{	O
int	O
k	int
;	O
struct	O
string_data	struct(int,int,int,int,int,int)
*	O
s	int
=	O
&	O
string	int
[	O
str_number	int
]	O
;	O
struct	O
string_liberties_data	struct(array(int))
*	O
sl	*(struct(array(int)))
=	O
&	O
string_libs	array(struct(array(int)))
[	O
str_number	int
]	O
;	O
if	O
(	O
s	int
->	O
liberties	int
>	O
MAX_LIBERTIES	int
)	O
update_liberties	(int)->(void)
(	O
str_number	int
)	O
;	O
else	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s	int
->	O
liberties	int
;	O
k	int
++	O
)	O
if	O
(	O
sl	*(struct(array(int)))
->	O
list	array(int)
[	O
k	int
]	O
==	O
pos	int
)	O
{	O
PUSH_VALUE	O
(	O
sl	*(struct(array(int)))
->	O
list	array(int)
[	O
s	int
->	O
liberties	int
-	O
1	int
]	O
)	O
;	O
PUSH_VALUE	O
(	O
sl	*(struct(array(int)))
->	O
list	array(int)
[	O
k	int
]	O
)	O
;	O
PUSH_VALUE	O
(	O
s	int
->	O
liberties	int
)	O
;	O
sl	*(struct(array(int)))
->	O
list	array(int)
[	O
k	int
]	O
=	O
sl	*(struct(array(int)))
->	O
list	array(int)
[	O
s	int
->	O
liberties	int
-	O
1	int
]	O
;	O
s	int
->	O
liberties	int
--	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
int	O
do_remove_string	(int)->(int)
(	O
int	O
s	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
size	int
=	O
string	int
[	O
s	int
]	O
.	O
size	int
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s	int
)	O
;	O
do	O
{	O
PUSH_VALUE	O
(	O
string_number	array(int)
[	O
pos	int
]	O
)	O
;	O
PUSH_VALUE	O
(	O
next_stone	array(int)
[	O
pos	int
]	O
)	O
;	O
DO_REMOVE_STONE	O
(	O
pos	int
)	O
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
while	O
(	O
!	O
BACK_TO_FIRST_STONE	O
(	O
s	int
,	O
pos	int
)	O
)	O
;	O
if	O
(	O
size	int
==	O
1	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
neighbor	int
=	O
string_neighbors	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
;	O
remove_neighbor	(int,int)->(void)
(	O
neighbor	int
,	O
s	int
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
)	O
;	O
if	O
(	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
<	O
MAX_LIBERTIES	int
)	O
string_libs	array(struct(array(int)))
[	O
neighbor	int
]	O
.	O
list	array(int)
[	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
]	O
=	O
pos	int
;	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
size	int
==	O
2	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
string	int
[	O
s	int
]	O
.	O
color	int
)	O
;	O
int	O
pos2	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
neighbor	int
=	O
string_neighbors	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
;	O
remove_neighbor	(int,int)->(void)
(	O
neighbor	int
,	O
s	int
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
)	O
;	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
pos	int
,	O
neighbor	int
,	O
other	int
)	O
)	O
{	O
if	O
(	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
<	O
MAX_LIBERTIES	int
)	O
string_libs	array(struct(array(int)))
[	O
neighbor	int
]	O
.	O
list	array(int)
[	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
]	O
=	O
pos	int
;	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
++	O
;	O
}	O
if	O
(	O
NEIGHBOR_OF_STRING	O
(	O
pos2	int
,	O
neighbor	int
,	O
other	int
)	O
)	O
{	O
if	O
(	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
<	O
MAX_LIBERTIES	int
)	O
string_libs	array(struct(array(int)))
[	O
neighbor	int
]	O
.	O
list	array(int)
[	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
]	O
=	O
pos2	int
;	O
string	int
[	O
neighbor	int
]	O
.	O
liberties	int
++	O
;	O
}	O
}	O
}	O
else	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
remove_neighbor	(int,int)->(void)
(	O
string_neighbors	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
,	O
s	int
)	O
;	O
update_liberties	(int)->(void)
(	O
string_neighbors	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
string	int
[	O
s	int
]	O
.	O
color	int
==	O
WHITE	int
)	O
white_captured	int
+=	O
size	int
;	O
else	O
black_captured	int
+=	O
size	int
;	O
return	O
size	int
;	O
}	O
static	O
void	O
create_new_string	(int)->(void)
(	O
int	O
pos	int
)	O
{	O
int	O
s	int
;	O
int	O
color	int
=	O
board	*(char)
[	O
pos	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
PUSH_VALUE	O
(	O
next_string	int
)	O
;	O
s	int
=	O
next_string	int
++	O
;	O
PARANOID1	O
(	O
s	int
<	O
MAX_STRINGS	O
,	O
pos	int
)	O
;	O
string_number	array(int)
[	O
pos	int
]	O
=	O
s	int
;	O
next_stone	array(int)
[	O
pos	int
]	O
=	O
pos	int
;	O
string	int
[	O
s	int
]	O
.	O
color	int
=	O
color	int
;	O
string	int
[	O
s	int
]	O
.	O
size	int
=	O
1	int
;	O
string	int
[	O
s	int
]	O
.	O
origin	int
=	O
pos	int
;	O
string	int
[	O
s	int
]	O
.	O
liberties	int
=	O
0	int
;	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
=	O
0	int
;	O
string	int
[	O
s	int
]	O
.	O
mark	char
=	O
0	int
;	O
string_mark	int
++	O
;	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_LIBERTY	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_LIBERTY	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_LIBERTY	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_LIBERTY	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
}	O
}	O
static	O
void	O
extend_neighbor_string	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
s	int
)	O
{	O
int	O
k	int
;	O
int	O
liberties_updated	int
=	O
0	int
;	O
int	O
color	int
=	O
board	*(char)
[	O
pos	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
pos2	int
=	O
string	int
[	O
s	int
]	O
.	O
origin	int
;	O
next_stone	array(int)
[	O
pos	int
]	O
=	O
next_stone	array(int)
[	O
pos2	int
]	O
;	O
PUSH_VALUE	O
(	O
next_stone	array(int)
[	O
pos2	int
]	O
)	O
;	O
next_stone	array(int)
[	O
pos2	int
]	O
=	O
pos	int
;	O
if	O
(	O
pos	int
<	O
pos2	int
)	O
{	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
origin	int
)	O
;	O
string	int
[	O
s	int
]	O
.	O
origin	int
=	O
pos	int
;	O
}	O
string_number	array(int)
[	O
pos	int
]	O
=	O
s	int
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
size	int
)	O
;	O
string	int
[	O
s	int
]	O
.	O
size	int
++	O
;	O
if	O
(	O
string	int
[	O
s	int
]	O
.	O
liberties	int
>	O
MAX_LIBERTIES	int
)	O
{	O
update_liberties	(int)->(void)
(	O
s	int
)	O
;	O
liberties_updated	int
=	O
1	int
;	O
}	O
else	O
{	O
remove_liberty	(int,int)->(void)
(	O
s	int
,	O
pos	int
)	O
;	O
}	O
string_mark	int
++	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
string	int
[	O
string_neighbors	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
]	O
.	O
mark	char
=	O
string_mark	int
;	O
if	O
(	O
LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
liberties_updated	int
&&	O
!	O
NON_SOUTH_NEIGHBOR_OF_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
s	int
,	O
color	int
)	O
)	O
ADD_LIBERTY	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
liberties_updated	int
&&	O
!	O
NON_WEST_NEIGHBOR_OF_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
s	int
,	O
color	int
)	O
)	O
ADD_LIBERTY	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
liberties_updated	int
&&	O
!	O
NON_NORTH_NEIGHBOR_OF_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
s	int
,	O
color	int
)	O
)	O
ADD_LIBERTY	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
liberties_updated	int
&&	O
!	O
NON_EAST_NEIGHBOR_OF_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
s	int
,	O
color	int
)	O
)	O
ADD_LIBERTY	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
int	O
s2	int
=	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
s2	int
,	O
pos	int
)	O
;	O
}	O
}	O
static	O
void	O
assimilate_string	(int,int)->(void)
(	O
int	O
s	int
,	O
int	O
pos	int
)	O
{	O
int	O
k	int
;	O
int	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
int	O
s2	int
=	O
string_number	array(int)
[	O
pos	int
]	O
;	O
string	int
[	O
s	int
]	O
.	O
size	int
+=	O
string	int
[	O
s2	int
]	O
.	O
size	int
;	O
pos	int
=	O
FIRST_STONE	O
(	O
s2	int
)	O
;	O
do	O
{	O
PUSH_VALUE	O
(	O
string_number	array(int)
[	O
pos	int
]	O
)	O
;	O
string_number	array(int)
[	O
pos	int
]	O
=	O
s	int
;	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
=	O
pos	int
;	O
pos	int
=	O
NEXT_STONE	O
(	O
pos	int
)	O
;	O
}	O
while	O
(	O
!	O
BACK_TO_FIRST_STONE	O
(	O
s2	int
,	O
pos	int
)	O
)	O
;	O
{	O
int	O
pos2	int
=	O
string	int
[	O
s	int
]	O
.	O
origin	int
;	O
PUSH_VALUE	O
(	O
next_stone	array(int)
[	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
]	O
)	O
;	O
PUSH_VALUE	O
(	O
next_stone	array(int)
[	O
pos2	int
]	O
)	O
;	O
next_stone	array(int)
[	O
last	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
]	O
=	O
next_stone	array(int)
[	O
pos2	int
]	O
;	O
next_stone	array(int)
[	O
pos2	int
]	O
=	O
string	int
[	O
s2	int
]	O
.	O
origin	int
;	O
if	O
(	O
string	int
[	O
s2	int
]	O
.	O
origin	int
<	O
pos2	int
)	O
string	int
[	O
s	int
]	O
.	O
origin	int
=	O
string	int
[	O
s2	int
]	O
.	O
origin	int
;	O
}	O
if	O
(	O
string	int
[	O
s2	int
]	O
.	O
liberties	int
<=	O
MAX_LIBERTIES	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s2	int
]	O
.	O
liberties	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
string_libs	array(struct(array(int)))
[	O
s2	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
pos2	int
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
pos2	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
liberty_mark	int
++	O
;	O
string	int
[	O
s	int
]	O
.	O
liberties	int
=	O
0	int
;	O
update_liberties	(int)->(void)
(	O
s	int
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
string	int
[	O
s2	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
t	*(struct(int,int,int,int,int,int))
=	O
string_neighbors	array(struct(array(int)))
[	O
s2	int
]	O
.	O
list	array(int)
[	O
k	int
]	O
;	O
remove_neighbor	(int,int)->(void)
(	O
t	*(struct(int,int,int,int,int,int))
,	O
s2	int
)	O
;	O
if	O
(	O
string	int
[	O
t	*(struct(int,int,int,int,int,int))
]	O
.	O
mark	char
!=	O
string_mark	int
)	O
{	O
PUSH_VALUE	O
(	O
string	int
[	O
t	*(struct(int,int,int,int,int,int))
]	O
.	O
neighbors	int
)	O
;	O
string_neighbors	array(struct(array(int)))
[	O
t	*(struct(int,int,int,int,int,int))
]	O
.	O
list	array(int)
[	O
string	int
[	O
t	*(struct(int,int,int,int,int,int))
]	O
.	O
neighbors	int
++	O
]	O
=	O
s	int
;	O
string_neighbors	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
++	O
]	O
=	O
t	*(struct(int,int,int,int,int,int))
;	O
string	int
[	O
t	*(struct(int,int,int,int,int,int))
]	O
.	O
mark	char
=	O
string_mark	int
;	O
}	O
}	O
}	O
static	O
void	O
assimilate_neighbor_strings	(int)->(void)
(	O
int	O
pos	int
)	O
{	O
int	O
s	int
;	O
int	O
color	int
=	O
board	*(char)
[	O
pos	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
PUSH_VALUE	O
(	O
next_string	int
)	O
;	O
s	int
=	O
next_string	int
++	O
;	O
PARANOID1	O
(	O
s	int
<	O
MAX_STRINGS	O
,	O
pos	int
)	O
;	O
string_number	array(int)
[	O
pos	int
]	O
=	O
s	int
;	O
next_stone	array(int)
[	O
pos	int
]	O
=	O
pos	int
;	O
string	int
[	O
s	int
]	O
.	O
color	int
=	O
color	int
;	O
string	int
[	O
s	int
]	O
.	O
size	int
=	O
1	int
;	O
string	int
[	O
s	int
]	O
.	O
origin	int
=	O
pos	int
;	O
string	int
[	O
s	int
]	O
.	O
liberties	int
=	O
0	int
;	O
string	int
[	O
s	int
]	O
.	O
neighbors	int
=	O
0	int
;	O
liberty_mark	int
++	O
;	O
string_mark	int
++	O
;	O
string	int
[	O
s	int
]	O
.	O
mark	char
=	O
string_mark	int
;	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
string_number	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
string_number	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
assimilate_string	(int,int)->(void)
(	O
s	int
,	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
assimilate_string	(int,int)->(void)
(	O
s	int
,	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_AND_MARK_LIBERTY	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
assimilate_string	(int,int)->(void)
(	O
s	int
,	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_LIBERTY	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
ADD_LIBERTY	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
ADD_NEIGHBOR	O
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
PUSH_VALUE	O
(	O
string	int
[	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
]	O
.	O
neighbors	int
)	O
;	O
ADD_NEIGHBOR	O
(	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
assimilate_string	(int,int)->(void)
(	O
s	int
,	O
EAST	O
(	O
pos	int
)	O
)	O
;	O
}	O
}	O
static	O
void	O
do_commit_suicide	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
do_remove_string	(int)->(int)
(	O
string_number	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
)	O
;	O
if	O
(	O
board	*(char)
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
do_remove_string	(int)->(int)
(	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
)	O
;	O
if	O
(	O
board	*(char)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
do_remove_string	(int)->(int)
(	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
)	O
;	O
if	O
(	O
board	*(char)
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
do_remove_string	(int)->(int)
(	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
)	O
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
white_captured	int
++	O
;	O
else	O
black_captured	int
++	O
;	O
}	O
static	O
void	O
do_play_move	(int,int)->(void)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
captured_stones	*(int)
=	O
0	int
;	O
int	O
neighbor_allies	int
=	O
0	int
;	O
int	O
s	int
=	O
-	O
1	int
;	O
string_mark	int
++	O
;	O
DO_ADD_STONE	O
(	O
pos	int
,	O
color	int
)	O
;	O
string_number	array(int)
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
color	int
)	O
{	O
neighbor_allies	int
++	O
;	O
s	int
=	O
string_number	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
other	int
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
>	O
1	int
)	O
{	O
remove_liberty	(int,int)->(void)
(	O
string_number	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
SOUTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
captured_stones	*(int)
+=	O
do_remove_string	(int)->(int)
(	O
string_number	array(int)
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
neighbor_allies	int
++	O
;	O
s	int
=	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
>	O
1	int
)	O
{	O
remove_liberty	(int,int)->(void)
(	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
WEST	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
captured_stones	*(int)
+=	O
do_remove_string	(int)->(int)
(	O
string_number	array(int)
[	O
WEST	O
(	O
pos	int
)	O
]	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
neighbor_allies	int
++	O
;	O
s	int
=	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
>	O
1	int
)	O
{	O
remove_liberty	(int,int)->(void)
(	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
MARK_STRING	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
captured_stones	*(int)
+=	O
do_remove_string	(int)->(int)
(	O
string_number	array(int)
[	O
NORTH	O
(	O
pos	int
)	O
]	O
)	O
;	O
}	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
color	int
)	O
)	O
{	O
neighbor_allies	int
++	O
;	O
s	int
=	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
;	O
}	O
else	O
if	O
(	O
UNMARKED_COLOR_STRING	O
(	O
EAST	O
(	O
pos	int
)	O
,	O
other	int
)	O
)	O
{	O
if	O
(	O
LIBERTIES	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
>	O
1	int
)	O
{	O
remove_liberty	(int,int)->(void)
(	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
,	O
pos	int
)	O
;	O
}	O
else	O
captured_stones	*(int)
+=	O
do_remove_string	(int)->(int)
(	O
string_number	array(int)
[	O
EAST	O
(	O
pos	int
)	O
]	O
)	O
;	O
}	O
if	O
(	O
neighbor_allies	int
==	O
0	int
)	O
create_new_string	(int)->(void)
(	O
pos	int
)	O
;	O
else	O
if	O
(	O
neighbor_allies	int
==	O
1	int
)	O
{	O
gg_assert	O
(	O
s	int
>=	O
0	int
)	O
;	O
extend_neighbor_string	(int,int)->(void)
(	O
pos	int
,	O
s	int
)	O
;	O
return	O
;	O
}	O
else	O
{	O
assimilate_neighbor_strings	(int)->(void)
(	O
pos	int
)	O
;	O
return	O
;	O
}	O
s	int
=	O
string_number	array(int)
[	O
pos	int
]	O
;	O
if	O
(	O
string	int
[	O
s	int
]	O
.	O
liberties	int
==	O
1	int
&&	O
string	int
[	O
s	int
]	O
.	O
size	int
==	O
1	int
&&	O
captured_stones	*(int)
==	O
1	int
)	O
{	O
if	O
(	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	(*(struct(array(long))),int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
board_ko_pos	int
)	O
;	O
board_ko_pos	int
=	O
string_libs	array(struct(array(int)))
[	O
s	int
]	O
.	O
list	array(int)
[	O
0	int
]	O
;	O
hashdata_invert_ko	(*(struct(array(long))),int)->(void)
(	O
&	O
board_hash	struct(array(long))
,	O
board_ko_pos	int
)	O
;	O
}	O
}	O
void	O
incremental_order_moves	(int,int,int,*(int),*(int),*(int),*(int),*(int),*(int),*(int),*(int))->(void)
(	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
int	O
str	int
,	O
int	O
*	O
number_edges	*(int)
,	O
int	O
*	O
number_same_string	*(int)
,	O
int	O
*	O
number_own	*(int)
,	O
int	O
*	O
number_opponent	*(int)
,	O
int	O
*	O
captured_stones	*(int)
,	O
int	O
*	O
threatened_stones	*(int)
,	O
int	O
*	O
saved_stones	*(int)
,	O
int	O
*	O
number_open	*(int)
)	O
{	O
string_mark	int
++	O
;	O
code1	O
(	O
SOUTH	O
(	O
move	*(int)
)	O
)	O
;	O
code1	O
(	O
WEST	O
(	O
move	*(int)
)	O
)	O
;	O
code1	O
(	O
NORTH	O
(	O
move	*(int)
)	O
)	O
;	O
code1	O
(	O
EAST	O
(	O
move	*(int)
)	O
)	O
;	O
}	O
int	O
square_dist	(int,int)->(int)
(	O
int	O
pos1	int
,	O
int	O
pos2	int
)	O
{	O
int	O
idist	int
=	O
I	O
(	O
pos1	int
)	O
-	O
I	O
(	O
pos2	int
)	O
;	O
int	O
jdist	int
=	O
J	O
(	O
pos1	int
)	O
-	O
J	O
(	O
pos2	int
)	O
;	O
return	O
idist	int
*	O
idist	int
+	O
jdist	int
*	O
jdist	int
;	O
}	O
