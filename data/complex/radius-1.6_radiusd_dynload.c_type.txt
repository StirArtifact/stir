static	O
void	O
dynload_free_modules	()->(void)
(	O
)	O
{	O
}	O
void	O
*	O
radiusd_load_ext	(*(char),*(char),*(*(void)))->(*(void))
(	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
ident	*(char)
,	O
void	O
*	O
*	O
symbol	struct(*(struct(*(struct(*(struct`),*(char))),*(char))),*(char))
)	O
{	O
GRAD_DEBUG	O
(	O
1	int
,	O
"radiusd is compiled without dynamic loading support"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
int	O
radiusd_add_load_path	(*(char))->(int)
(	O
const	O
char	O
*	O
path	*(char)
)	O
{	O
GRAD_DEBUG	O
(	O
1	int
,	O
"radiusd is compiled without dynamic loading support"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
int	O
radiusd_set_load_path	(*(char))->(int)
(	O
const	O
char	O
*	O
path	*(char)
)	O
{	O
GRAD_DEBUG	O
(	O
1	int
,	O
"radiusd is compiled without dynamic loading support"	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
dynload_before_config_hook	(*(void),*(void))->(void)
(	O
void	O
*	O
a	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
,	O
void	O
*	O
b	*(struct(*(struct(*(struct`),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct`))),*(char),int,int,enum(int,int,int),int,enum(int,int,int,int,int,int,int),union(int,struct(long,*(char)))))
ARG_UNUSED	O
)	O
{	O
dynload_free_modules	()->(void)
(	O
)	O
;	O
}	O
void	O
dynload_init	()->(void)
(	O
)	O
{	O
radiusd_set_preconfig_hook	(*((*(void),*(void))->(void)),*(void),int)->(void)
(	O
dynload_before_config_hook	(*(void),*(void))->(void)
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
int	O
dynload_stmt_term	(int,*(void),*(void))->(int)
(	O
int	O
finish	int
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
!	O
finish	int
)	O
radiusd_set_load_path	(*(char))->(int)
(	O
RADIUS_LIBDIR	O
"/modules"	*(char)
)	O
;	O
}	O
static	O
int	O
dynload_cfg_add_load_path	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
(	O
int	O
argc	int
,	O
cfg_value_t	struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))
*	O
argv	*(*(char))
,	O
void	O
*	O
block_data	*(void)
,	O
void	O
*	O
handler_data	*(void)
)	O
{	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
cfg_argc_error	(int)->(void)
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
type	int
!=	O
CFG_STRING	int
)	O
{	O
cfg_type_error	(int)->(void)
(	O
CFG_STRING	int
)	O
;	O
return	O
0	int
;	O
}	O
radiusd_add_load_path	(*(char))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
.	O
v	union(*(char),int,long,int,struct(int,int),char,struct(int,int))
.	O
string	*(*(char))
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
cfg_stmt	struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union(*`,int,long,int,struct`,char,struct`))),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct`),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct`),*((*`,*`)->(int)))),*((*(void),*(void))->(int)))),*((*(void),*(void))->(int)))
dynload_stmt	array(struct(*(char),int,*((int,*(void),*(void))->(int)),*((int,*(struct(int,union`)),*(void),*(void))->(int)),*(void),*(struct(*(char),int,*((int,*`,*`)->(int)),*((int,*`,*`,*`)->(int)),*(void),*(struct(*`,int,*`,*`,*`,*`,*`)),*((*`,*`)->(int)))),*((*(void),*(void))->(int))))
[	O
]	O
=	O
{	O
{	O
"load-path"	*(char)
,	O
CS_STMT	int
,	O
NULL	O
,	O
dynload_cfg_add_load_path	(int,*(struct(int,union(*(char),int,long,int,struct(int,int),char,struct(int,int)))),*(void),*(void))->(int)
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
