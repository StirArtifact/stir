typedef	O
struct	O
elf_section_list	O
{	O
Elf_Internal_Shdr	O
*	O
hdr	O
;	O
struct	O
elf_section_list	O
*	O
next	*(char)
;	O
}	O
elf_section_list	O
;	O
typedef	O
unsigned	O
char	O
dump_type	O
;	O
struct	O
dump_list_entry	O
{	O
char	O
*	O
name	*(char)
;	O
dump_type	O
type	enum(int,int,int,int)
;	O
struct	O
dump_list_entry	O
*	O
next	*(char)
;	O
}	O
;	O
typedef	O
struct	O
filedata	O
{	O
const	O
char	O
*	O
file_name	O
;	O
FILE	struct
*	O
handle	O
;	O
bfd_size_type	long
file_size	O
;	O
Elf_Internal_Ehdr	O
file_header	O
;	O
Elf_Internal_Shdr	O
*	O
section_headers	O
;	O
Elf_Internal_Phdr	O
*	O
program_headers	O
;	O
char	O
*	O
string_table	O
;	O
unsigned	O
long	O
string_table_length	O
;	O
dump_type	O
*	O
dump_sects	O
;	O
unsigned	O
int	O
num_dump_sects	O
;	O
}	O
Filedata	O
;	O
char	O
*	O
program_name	O
=	O
"readelf"	*(char)
;	O
static	O
unsigned	O
long	O
archive_file_offset	O
;	O
static	O
unsigned	O
long	O
archive_file_size	O
;	O
static	O
unsigned	O
long	O
dynamic_addr	O
;	O
static	O
bfd_size_type	long
dynamic_size	O
;	O
static	O
size_t	long
dynamic_nent	O
;	O
static	O
char	O
*	O
dynamic_strings	O
;	O
static	O
unsigned	O
long	O
dynamic_strings_length	O
;	O
static	O
unsigned	O
long	O
num_dynamic_syms	O
;	O
static	O
Elf_Internal_Sym	O
*	O
dynamic_symbols	O
;	O
static	O
Elf_Internal_Syminfo	O
*	O
dynamic_syminfo	O
;	O
static	O
unsigned	O
long	O
dynamic_syminfo_offset	O
;	O
static	O
unsigned	O
int	O
dynamic_syminfo_nent	O
;	O
static	O
char	O
program_interpreter	O
[	O
PATH_MAX	O
]	O
;	O
static	O
bfd_vma	long
dynamic_info	O
[	O
DT_ENCODING	O
]	O
;	O
static	O
bfd_vma	long
dynamic_info_DT_GNU_HASH	O
;	O
static	O
bfd_vma	long
dynamic_info_DT_MIPS_XHASH	O
;	O
static	O
bfd_vma	long
version_info	O
[	O
16	int
]	O
;	O
static	O
Elf_Internal_Dyn	O
*	O
dynamic_section	O
;	O
static	O
elf_section_list	O
*	O
symtab_shndx_list	O
;	O
static	O
bfd_boolean	int
show_name	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_dynamic	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_syms	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_dyn_syms	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_reloc	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_sections	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_section_groups	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_section_details	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_segments	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_unwind	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_using_dynamic	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_header	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_dump	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_version	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_histogram	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_debugging	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_ctf	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_arch	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_notes	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
do_archive_index	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
is_32bit_elf	O
=	O
FALSE	O
;	O
static	O
bfd_boolean	int
decompress_dumps	O
=	O
FALSE	O
;	O
static	O
char	O
*	O
dump_ctf_parent_name	O
;	O
static	O
char	O
*	O
dump_ctf_symtab_name	O
;	O
static	O
char	O
*	O
dump_ctf_strtab_name	O
;	O
struct	O
group_list	O
{	O
struct	O
group_list	O
*	O
next	*(char)
;	O
unsigned	O
int	O
section_index	O
;	O
}	O
;	O
struct	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
{	O
struct	O
group_list	O
*	O
root	O
;	O
unsigned	O
int	O
group_index	O
;	O
}	O
;	O
static	O
size_t	long
group_count	O
;	O
static	O
struct	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
*	O
section_groups	O
;	O
static	O
struct	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
*	O
*	O
section_headers_groups	O
;	O
static	O
Filedata	O
cmdline	O
;	O
static	O
struct	O
dump_list_entry	O
*	O
dump_sects_byname	O
;	O
typedef	O
enum	O
print_mode	O
{	O
HEX	O
,	O
DEC	O
,	O
DEC_5	O
,	O
UNSIGNED	O
,	O
PREFIX_HEX	O
,	O
FULL_HEX	O
,	O
LONG_HEX	O
}	O
print_mode	O
;	O
enum	O
versioned_symbol_info	O
{	O
symbol_undefined	O
,	O
symbol_hidden	O
,	O
symbol_public	O
}	O
;	O
static	O
const	O
char	O
*	O
get_symbol_version_string	O
(	O
Filedata	O
*	O
,	O
bfd_boolean	int
,	O
const	O
char	O
*	O
,	O
unsigned	O
long	O
,	O
unsigned	O
,	O
Elf_Internal_Sym	O
*	O
,	O
enum	O
versioned_symbol_info	O
*	O
,	O
unsigned	O
short	O
*	O
)	O
;	O
static	O
const	O
char	O
*	O
bfd_vmatoa	O
(	O
char	O
*	O
fmtch	O
,	O
bfd_vma	long
value	int
)	O
{	O
static	O
int	O
buf_pos	O
=	O
0	int
;	O
static	O
struct	O
bfd_vmatoa_buf	O
{	O
char	O
place	O
[	O
64	int
]	O
;	O
}	O
buf	*(void)
[	O
4	int
]	O
;	O
char	O
*	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
char	O
fmt	*(char)
[	O
32	int
]	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
buf	*(void)
[	O
buf_pos	O
++	O
]	O
.	O
place	O
;	O
buf_pos	O
%=	O
ARRAY_SIZE	O
(	O
buf	*(void)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
fmt	*(char)
,	O
"%%%s%s"	*(char)
,	O
BFD_VMA_FMT	O
,	O
fmtch	O
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
,	O
sizeof	O
(	O
buf	*(void)
[	O
0	int
]	O
.	O
place	O
)	O
,	O
fmt	*(char)
,	O
value	int
)	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
static	O
void	O
*	O
get_data	O
(	O
void	O
*	O
var	O
,	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
long	O
offset	long
,	O
bfd_size_type	long
size	int
,	O
bfd_size_type	long
nmemb	O
,	O
const	O
char	O
*	O
reason	O
)	O
{	O
void	O
*	O
mvar	O
;	O
bfd_size_type	long
amt	O
=	O
size	int
*	O
nmemb	O
;	O
if	O
(	O
size	int
==	O
0	int
||	O
nmemb	O
==	O
0	int
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
size_t	long
)	O
size	int
!=	O
size	int
||	O
(	O
size_t	long
)	O
nmemb	O
!=	O
nmemb	O
||	O
(	O
size_t	long
)	O
amt	O
!=	O
amt	O
)	O
{	O
if	O
(	O
reason	O
)	O
error	O
(	O
_	O
(	O
"Size truncation prevents reading %s"	*(char)
" elements of size %s for %s\n"	*(char)
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
nmemb	O
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
size	int
)	O
,	O
reason	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
amt	O
/	O
size	int
!=	O
nmemb	O
||	O
(	O
size_t	long
)	O
amt	O
+	O
1	int
==	O
0	int
)	O
{	O
if	O
(	O
reason	O
)	O
error	O
(	O
_	O
(	O
"Size overflow prevents reading %s"	*(char)
" elements of size %s for %s\n"	*(char)
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
nmemb	O
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
size	int
)	O
,	O
reason	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
archive_file_offset	O
>	O
filedata	O
->	O
file_size	O
||	O
offset	long
>	O
filedata	O
->	O
file_size	O
-	O
archive_file_offset	O
||	O
amt	O
>	O
filedata	O
->	O
file_size	O
-	O
archive_file_offset	O
-	O
offset	long
)	O
{	O
if	O
(	O
reason	O
)	O
error	O
(	O
_	O
(	O
"Reading %s bytes extends past end of file for %s\n"	*(char)
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
amt	O
)	O
,	O
reason	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
filedata	O
->	O
handle	O
,	O
archive_file_offset	O
+	O
offset	long
,	O
SEEK_SET	O
)	O
)	O
{	O
if	O
(	O
reason	O
)	O
error	O
(	O
_	O
(	O
"Unable to seek to 0x%lx for %s\n"	*(char)
)	O
,	O
archive_file_offset	O
+	O
offset	long
,	O
reason	O
)	O
;	O
return	O
NULL	O
;	O
}	O
mvar	O
=	O
var	O
;	O
if	O
(	O
mvar	O
==	O
NULL	O
)	O
{	O
mvar	O
=	O
malloc	(long)->(*(void))
(	O
(	O
size_t	long
)	O
amt	O
+	O
1	int
)	O
;	O
if	O
(	O
mvar	O
==	O
NULL	O
)	O
{	O
if	O
(	O
reason	O
)	O
error	O
(	O
_	O
(	O
"Out of memory allocating %s bytes for %s\n"	*(char)
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
amt	O
)	O
,	O
reason	O
)	O
;	O
return	O
NULL	O
;	O
}	O
(	O
(	O
char	O
*	O
)	O
mvar	O
)	O
[	O
amt	O
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
mvar	O
,	O
(	O
size_t	long
)	O
size	int
,	O
(	O
size_t	long
)	O
nmemb	O
,	O
filedata	O
->	O
handle	O
)	O
!=	O
nmemb	O
)	O
{	O
if	O
(	O
reason	O
)	O
error	O
(	O
_	O
(	O
"Unable to read in %s bytes of %s\n"	*(char)
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
amt	O
)	O
,	O
reason	O
)	O
;	O
if	O
(	O
mvar	O
!=	O
var	O
)	O
free	(*(void))->(void)
(	O
mvar	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
mvar	O
;	O
}	O
static	O
unsigned	O
int	O
print_vma	O
(	O
bfd_vma	long
vma	long
,	O
print_mode	O
mode	*(char)
)	O
{	O
unsigned	O
int	O
nc	O
=	O
0	int
;	O
switch	O
(	O
mode	*(char)
)	O
{	O
case	O
FULL_HEX	O
:	O
nc	O
=	O
printf	(*(char))->(int)
(	O
"0x"	*(char)
)	O
;	O
case	O
LONG_HEX	O
:	O
if	O
(	O
is_32bit_elf	O
)	O
return	O
nc	O
+	O
printf	(*(char))->(int)
(	O
"%8.8"	*(char)
BFD_VMA_FMT	O
"x"	*(char)
,	O
vma	long
)	O
;	O
printf_vma	O
(	O
vma	long
)	O
;	O
return	O
nc	O
+	O
16	int
;	O
case	O
DEC_5	O
:	O
if	O
(	O
vma	long
<=	O
99999	int
)	O
return	O
printf	(*(char))->(int)
(	O
"%5"	*(char)
BFD_VMA_FMT	O
"d"	*(char)
,	O
vma	long
)	O
;	O
case	O
PREFIX_HEX	O
:	O
nc	O
=	O
printf	(*(char))->(int)
(	O
"0x"	*(char)
)	O
;	O
case	O
HEX	O
:	O
return	O
nc	O
+	O
printf	(*(char))->(int)
(	O
"%"	*(char)
BFD_VMA_FMT	O
"x"	*(char)
,	O
vma	long
)	O
;	O
case	O
DEC	O
:	O
return	O
printf	(*(char))->(int)
(	O
"%"	*(char)
BFD_VMA_FMT	O
"d"	*(char)
,	O
vma	long
)	O
;	O
case	O
UNSIGNED	O
:	O
return	O
printf	(*(char))->(int)
(	O
"%"	*(char)
BFD_VMA_FMT	O
"u"	*(char)
,	O
vma	long
)	O
;	O
default	O
:	O
return	O
0	int
;	O
}	O
}	O
static	O
unsigned	O
int	O
print_symbol	O
(	O
signed	O
int	O
width	O
,	O
const	O
char	O
*	O
symbol	*(struct)
)	O
{	O
bfd_boolean	int
extra_padding	O
=	O
FALSE	O
;	O
signed	O
int	O
num_printed	O
=	O
0	int
;	O
mbstate_t	struct(int,union(int,array(char)))
state	*(int)
;	O
unsigned	O
int	O
width_remaining	O
;	O
if	O
(	O
width	O
<	O
0	int
)	O
{	O
width	O
=	O
-	O
width	O
;	O
extra_padding	O
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
width	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
do_wide	O
)	O
width_remaining	O
=	O
INT_MAX	O
;	O
else	O
width_remaining	O
=	O
width	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
state	*(int)
,	O
0	int
,	O
sizeof	O
(	O
state	*(int)
)	O
)	O
;	O
while	O
(	O
width_remaining	O
)	O
{	O
size_t	long
n	O
;	O
const	O
char	O
c	int
=	O
*	O
symbol	*(struct)
++	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
ISCNTRL	O
(	O
c	int
)	O
)	O
{	O
if	O
(	O
width_remaining	O
<	O
2	int
)	O
break	O
;	O
printf	(*(char))->(int)
(	O
"^%c"	*(char)
,	O
c	int
+	O
0x40	int
)	O
;	O
width_remaining	O
-=	O
2	int
;	O
num_printed	O
+=	O
2	int
;	O
}	O
else	O
if	O
(	O
ISPRINT	O
(	O
c	int
)	O
)	O
{	O
putchar	(int)->(int)
(	O
c	int
)	O
;	O
width_remaining	O
--	O
;	O
num_printed	O
++	O
;	O
}	O
else	O
{	O
wchar_t	int
w	O
;	O
printf	(*(char))->(int)
(	O
"%.1s"	*(char)
,	O
symbol	*(struct)
-	O
1	int
)	O
;	O
width_remaining	O
--	O
;	O
num_printed	O
++	O
;	O
n	O
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
w	O
,	O
symbol	*(struct)
-	O
1	int
,	O
MB_CUR_MAX	O
,	O
&	O
state	*(int)
)	O
;	O
if	O
(	O
n	O
!=	O
(	O
size_t	long
)	O
-	O
1	int
&&	O
n	O
!=	O
(	O
size_t	long
)	O
-	O
2	int
&&	O
n	O
>	O
0	int
)	O
symbol	*(struct)
+=	O
(	O
n	O
-	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
extra_padding	O
&&	O
num_printed	O
<	O
width	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%-*s"	*(char)
,	O
width	O
-	O
num_printed	O
,	O
" "	*(char)
)	O
;	O
num_printed	O
=	O
width	O
;	O
}	O
return	O
num_printed	O
;	O
}	O
static	O
const	O
char	O
*	O
printable_section_name	O
(	O
Filedata	O
*	O
filedata	O
,	O
const	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
static	O
char	O
sec_name_buf	O
[	O
MAX_PRINT_SEC_NAME_LEN	O
+	O
1	int
]	O
;	O
const	O
char	O
*	O
name	*(char)
=	O
SECTION_NAME	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
char	O
*	O
buf	*(void)
=	O
sec_name_buf	O
;	O
char	O
c	int
;	O
unsigned	O
int	O
remaining	O
=	O
MAX_PRINT_SEC_NAME_LEN	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
name	*(char)
++	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
ISCNTRL	O
(	O
c	int
)	O
)	O
{	O
if	O
(	O
remaining	O
<	O
2	int
)	O
break	O
;	O
*	O
buf	*(void)
++	O
=	O
'^'	O
;	O
*	O
buf	*(void)
++	O
=	O
c	int
+	O
0x40	int
;	O
remaining	O
-=	O
2	int
;	O
}	O
else	O
if	O
(	O
ISPRINT	O
(	O
c	int
)	O
)	O
{	O
*	O
buf	*(void)
++	O
=	O
c	int
;	O
remaining	O
-=	O
1	int
;	O
}	O
else	O
{	O
static	O
char	O
hex	O
[	O
17	int
]	O
=	O
"0123456789ABCDEF"	*(char)
;	O
if	O
(	O
remaining	O
<	O
4	int
)	O
break	O
;	O
*	O
buf	*(void)
++	O
=	O
'<'	O
;	O
*	O
buf	*(void)
++	O
=	O
hex	O
[	O
(	O
c	int
&	O
0xf0	int
)	O
>>	O
4	int
]	O
;	O
*	O
buf	*(void)
++	O
=	O
hex	O
[	O
c	int
&	O
0x0f	int
]	O
;	O
*	O
buf	*(void)
++	O
=	O
'>'	O
;	O
remaining	O
-=	O
4	int
;	O
}	O
if	O
(	O
remaining	O
==	O
0	int
)	O
break	O
;	O
}	O
*	O
buf	*(void)
=	O
0	int
;	O
return	O
sec_name_buf	O
;	O
}	O
static	O
const	O
char	O
*	O
printable_section_name_from_index	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
long	O
ndx	O
)	O
{	O
if	O
(	O
ndx	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
return	O
_	O
(	O
"<corrupt>"	*(char)
)	O
;	O
return	O
printable_section_name	O
(	O
filedata	O
,	O
filedata	O
->	O
section_headers	O
+	O
ndx	O
)	O
;	O
}	O
static	O
Elf_Internal_Shdr	O
*	O
find_section	O
(	O
Filedata	O
*	O
filedata	O
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
)	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
filedata	O
->	O
section_headers	O
+	O
i	*(struct)
)	O
,	O
name	*(char)
)	O
)	O
return	O
filedata	O
->	O
section_headers	O
+	O
i	*(struct)
;	O
return	O
NULL	O
;	O
}	O
static	O
Elf_Internal_Shdr	O
*	O
find_section_by_address	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_vma	long
addr	*(void)
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
+	O
i	*(struct)
;	O
if	O
(	O
addr	*(void)
>=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
&&	O
addr	*(void)
<	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
+	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
return	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
Elf_Internal_Shdr	O
*	O
find_section_by_type	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
type	enum(int,int,int,int)
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
+	O
i	*(struct)
;	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
type	enum(int,int,int,int)
)	O
return	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
Elf_Internal_Shdr	O
*	O
find_section_in_set	O
(	O
Filedata	O
*	O
filedata	O
,	O
const	O
char	O
*	O
name	*(char)
,	O
unsigned	O
int	O
*	O
set	O
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
set	O
!=	O
NULL	O
)	O
{	O
while	O
(	O
(	O
i	*(struct)
=	O
*	O
set	O
++	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
i	*(struct)
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
continue	O
;	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
filedata	O
->	O
section_headers	O
+	O
i	*(struct)
)	O
,	O
name	*(char)
)	O
)	O
return	O
filedata	O
->	O
section_headers	O
+	O
i	*(struct)
;	O
}	O
}	O
return	O
find_section	O
(	O
filedata	O
,	O
name	*(char)
)	O
;	O
}	O
static	O
inline	O
bfd_boolean	int
is_ia64_vms	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
return	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_IA_64	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_OPENVMS	O
;	O
}	O
static	O
bfd_boolean	int
guess_is_rela	O
(	O
unsigned	O
int	O
e_machine	O
)	O
{	O
switch	O
(	O
e_machine	O
)	O
{	O
case	O
EM_386	O
:	O
case	O
EM_IAMCU	O
:	O
case	O
EM_960	O
:	O
case	O
EM_ARM	O
:	O
case	O
EM_D10V	O
:	O
case	O
EM_CYGNUS_D10V	O
:	O
case	O
EM_DLX	O
:	O
case	O
EM_MIPS	O
:	O
case	O
EM_MIPS_RS3_LE	O
:	O
case	O
EM_CYGNUS_M32R	O
:	O
case	O
EM_SCORE	O
:	O
case	O
EM_XGATE	O
:	O
case	O
EM_NFP	O
:	O
case	O
EM_BPF	O
:	O
return	O
FALSE	O
;	O
case	O
EM_68K	O
:	O
case	O
EM_860	O
:	O
case	O
EM_AARCH64	O
:	O
case	O
EM_ADAPTEVA_EPIPHANY	O
:	O
case	O
EM_ALPHA	O
:	O
case	O
EM_ALTERA_NIOS2	O
:	O
case	O
EM_ARC	O
:	O
case	O
EM_ARC_COMPACT	O
:	O
case	O
EM_ARC_COMPACT2	O
:	O
case	O
EM_AVR	O
:	O
case	O
EM_AVR_OLD	O
:	O
case	O
EM_BLACKFIN	O
:	O
case	O
EM_CR16	O
:	O
case	O
EM_CRIS	O
:	O
case	O
EM_CRX	O
:	O
case	O
EM_CSKY	O
:	O
case	O
EM_D30V	O
:	O
case	O
EM_CYGNUS_D30V	O
:	O
case	O
EM_FR30	O
:	O
case	O
EM_FT32	O
:	O
case	O
EM_CYGNUS_FR30	O
:	O
case	O
EM_CYGNUS_FRV	O
:	O
case	O
EM_H8S	O
:	O
case	O
EM_H8_300	O
:	O
case	O
EM_H8_300H	O
:	O
case	O
EM_IA_64	O
:	O
case	O
EM_IP2K	O
:	O
case	O
EM_IP2K_OLD	O
:	O
case	O
EM_IQ2000	O
:	O
case	O
EM_LATTICEMICO32	O
:	O
case	O
EM_M32C_OLD	O
:	O
case	O
EM_M32C	O
:	O
case	O
EM_M32R	O
:	O
case	O
EM_MCORE	O
:	O
case	O
EM_CYGNUS_MEP	O
:	O
case	O
EM_METAG	O
:	O
case	O
EM_MMIX	O
:	O
case	O
EM_MN10200	O
:	O
case	O
EM_CYGNUS_MN10200	O
:	O
case	O
EM_MN10300	O
:	O
case	O
EM_CYGNUS_MN10300	O
:	O
case	O
EM_MOXIE	O
:	O
case	O
EM_MSP430	O
:	O
case	O
EM_MSP430_OLD	O
:	O
case	O
EM_MT	O
:	O
case	O
EM_NDS32	O
:	O
case	O
EM_NIOS32	O
:	O
case	O
EM_OR1K	O
:	O
case	O
EM_PPC64	O
:	O
case	O
EM_PPC	O
:	O
case	O
EM_TI_PRU	O
:	O
case	O
EM_RISCV	O
:	O
case	O
EM_RL78	O
:	O
case	O
EM_RX	O
:	O
case	O
EM_S390	O
:	O
case	O
EM_S390_OLD	O
:	O
case	O
EM_SH	O
:	O
case	O
EM_SPARC	O
:	O
case	O
EM_SPARC32PLUS	O
:	O
case	O
EM_SPARCV9	O
:	O
case	O
EM_SPU	O
:	O
case	O
EM_TI_C6000	O
:	O
case	O
EM_TILEGX	O
:	O
case	O
EM_TILEPRO	O
:	O
case	O
EM_V800	O
:	O
case	O
EM_V850	O
:	O
case	O
EM_CYGNUS_V850	O
:	O
case	O
EM_VAX	O
:	O
case	O
EM_VISIUM	O
:	O
case	O
EM_X86_64	O
:	O
case	O
EM_L1OM	O
:	O
case	O
EM_K1OM	O
:	O
case	O
EM_XSTORMY16	O
:	O
case	O
EM_XTENSA	O
:	O
case	O
EM_XTENSA_OLD	O
:	O
case	O
EM_MICROBLAZE	O
:	O
case	O
EM_MICROBLAZE_OLD	O
:	O
case	O
EM_WEBASSEMBLY	O
:	O
return	O
TRUE	int
;	O
case	O
EM_68HC05	O
:	O
case	O
EM_68HC08	O
:	O
case	O
EM_68HC11	O
:	O
case	O
EM_68HC16	O
:	O
case	O
EM_FX66	O
:	O
case	O
EM_ME16	O
:	O
case	O
EM_MMA	O
:	O
case	O
EM_NCPU	O
:	O
case	O
EM_NDR1	O
:	O
case	O
EM_PCP	O
:	O
case	O
EM_ST100	O
:	O
case	O
EM_ST19	O
:	O
case	O
EM_ST7	O
:	O
case	O
EM_ST9PLUS	O
:	O
case	O
EM_STARCORE	O
:	O
case	O
EM_SVX	O
:	O
case	O
EM_TINYJ	O
:	O
default	O
:	O
warn	O
(	O
_	O
(	O
"Don't know about relocations on this machine architecture\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
slurp_rela_relocs	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
long	O
rel_offset	O
,	O
unsigned	O
long	O
rel_size	O
,	O
Elf_Internal_Rela	O
*	O
*	O
relasp	O
,	O
unsigned	O
long	O
*	O
nrelasp	O
)	O
{	O
Elf_Internal_Rela	O
*	O
relas	O
;	O
size_t	long
nrelas	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
Elf32_External_Rela	O
*	O
erelas	O
;	O
erelas	O
=	O
(	O
Elf32_External_Rela	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
rel_offset	O
,	O
1	int
,	O
rel_size	O
,	O
_	O
(	O
"32-bit relocation data"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
erelas	O
)	O
return	O
FALSE	O
;	O
nrelas	O
=	O
rel_size	O
/	O
sizeof	O
(	O
Elf32_External_Rela	O
)	O
;	O
relas	O
=	O
(	O
Elf_Internal_Rela	O
*	O
)	O
cmalloc	O
(	O
nrelas	O
,	O
sizeof	O
(	O
Elf_Internal_Rela	O
)	O
)	O
;	O
if	O
(	O
relas	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
erelas	O
)	O
;	O
error	O
(	O
_	O
(	O
"out of memory parsing relocs\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
nrelas	O
;	O
i	*(struct)
++	O
)	O
{	O
relas	O
[	O
i	*(struct)
]	O
.	O
r_offset	O
=	O
BYTE_GET	O
(	O
erelas	O
[	O
i	*(struct)
]	O
.	O
r_offset	O
)	O
;	O
relas	O
[	O
i	*(struct)
]	O
.	O
r_info	O
=	O
BYTE_GET	O
(	O
erelas	O
[	O
i	*(struct)
]	O
.	O
r_info	O
)	O
;	O
relas	O
[	O
i	*(struct)
]	O
.	O
r_addend	O
=	O
BYTE_GET_SIGNED	O
(	O
erelas	O
[	O
i	*(struct)
]	O
.	O
r_addend	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
erelas	O
)	O
;	O
}	O
else	O
{	O
Elf64_External_Rela	O
*	O
erelas	O
;	O
erelas	O
=	O
(	O
Elf64_External_Rela	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
rel_offset	O
,	O
1	int
,	O
rel_size	O
,	O
_	O
(	O
"64-bit relocation data"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
erelas	O
)	O
return	O
FALSE	O
;	O
nrelas	O
=	O
rel_size	O
/	O
sizeof	O
(	O
Elf64_External_Rela	O
)	O
;	O
relas	O
=	O
(	O
Elf_Internal_Rela	O
*	O
)	O
cmalloc	O
(	O
nrelas	O
,	O
sizeof	O
(	O
Elf_Internal_Rela	O
)	O
)	O
;	O
if	O
(	O
relas	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
erelas	O
)	O
;	O
error	O
(	O
_	O
(	O
"out of memory parsing relocs\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
nrelas	O
;	O
i	*(struct)
++	O
)	O
{	O
relas	O
[	O
i	*(struct)
]	O
.	O
r_offset	O
=	O
BYTE_GET	O
(	O
erelas	O
[	O
i	*(struct)
]	O
.	O
r_offset	O
)	O
;	O
relas	O
[	O
i	*(struct)
]	O
.	O
r_info	O
=	O
BYTE_GET	O
(	O
erelas	O
[	O
i	*(struct)
]	O
.	O
r_info	O
)	O
;	O
relas	O
[	O
i	*(struct)
]	O
.	O
r_addend	O
=	O
BYTE_GET_SIGNED	O
(	O
erelas	O
[	O
i	*(struct)
]	O
.	O
r_addend	O
)	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_MIPS	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_DATA	O
]	O
!=	O
ELFDATA2MSB	O
)	O
{	O
bfd_vma	long
inf	O
=	O
relas	O
[	O
i	*(struct)
]	O
.	O
r_info	O
;	O
inf	O
=	O
(	O
(	O
(	O
inf	O
&	O
0xffffffff	int
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
inf	O
>>	O
56	int
)	O
&	O
0xff	int
)	O
|	O
(	O
(	O
inf	O
>>	O
40	int
)	O
&	O
0xff00	int
)	O
|	O
(	O
(	O
inf	O
>>	O
24	int
)	O
&	O
0xff0000	int
)	O
|	O
(	O
(	O
inf	O
>>	O
8	int
)	O
&	O
0xff000000	int
)	O
)	O
;	O
relas	O
[	O
i	*(struct)
]	O
.	O
r_info	O
=	O
inf	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
erelas	O
)	O
;	O
}	O
*	O
relasp	O
=	O
relas	O
;	O
*	O
nrelasp	O
=	O
nrelas	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
slurp_rel_relocs	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
long	O
rel_offset	O
,	O
unsigned	O
long	O
rel_size	O
,	O
Elf_Internal_Rela	O
*	O
*	O
relsp	O
,	O
unsigned	O
long	O
*	O
nrelsp	O
)	O
{	O
Elf_Internal_Rela	O
*	O
rels	O
;	O
size_t	long
nrels	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
Elf32_External_Rel	O
*	O
erels	O
;	O
erels	O
=	O
(	O
Elf32_External_Rel	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
rel_offset	O
,	O
1	int
,	O
rel_size	O
,	O
_	O
(	O
"32-bit relocation data"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
erels	O
)	O
return	O
FALSE	O
;	O
nrels	O
=	O
rel_size	O
/	O
sizeof	O
(	O
Elf32_External_Rel	O
)	O
;	O
rels	O
=	O
(	O
Elf_Internal_Rela	O
*	O
)	O
cmalloc	O
(	O
nrels	O
,	O
sizeof	O
(	O
Elf_Internal_Rela	O
)	O
)	O
;	O
if	O
(	O
rels	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
erels	O
)	O
;	O
error	O
(	O
_	O
(	O
"out of memory parsing relocs\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
nrels	O
;	O
i	*(struct)
++	O
)	O
{	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_offset	O
=	O
BYTE_GET	O
(	O
erels	O
[	O
i	*(struct)
]	O
.	O
r_offset	O
)	O
;	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_info	O
=	O
BYTE_GET	O
(	O
erels	O
[	O
i	*(struct)
]	O
.	O
r_info	O
)	O
;	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_addend	O
=	O
0	int
;	O
}	O
free	(*(void))->(void)
(	O
erels	O
)	O
;	O
}	O
else	O
{	O
Elf64_External_Rel	O
*	O
erels	O
;	O
erels	O
=	O
(	O
Elf64_External_Rel	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
rel_offset	O
,	O
1	int
,	O
rel_size	O
,	O
_	O
(	O
"64-bit relocation data"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
erels	O
)	O
return	O
FALSE	O
;	O
nrels	O
=	O
rel_size	O
/	O
sizeof	O
(	O
Elf64_External_Rel	O
)	O
;	O
rels	O
=	O
(	O
Elf_Internal_Rela	O
*	O
)	O
cmalloc	O
(	O
nrels	O
,	O
sizeof	O
(	O
Elf_Internal_Rela	O
)	O
)	O
;	O
if	O
(	O
rels	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
erels	O
)	O
;	O
error	O
(	O
_	O
(	O
"out of memory parsing relocs\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
nrels	O
;	O
i	*(struct)
++	O
)	O
{	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_offset	O
=	O
BYTE_GET	O
(	O
erels	O
[	O
i	*(struct)
]	O
.	O
r_offset	O
)	O
;	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_info	O
=	O
BYTE_GET	O
(	O
erels	O
[	O
i	*(struct)
]	O
.	O
r_info	O
)	O
;	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_addend	O
=	O
0	int
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_MIPS	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_DATA	O
]	O
!=	O
ELFDATA2MSB	O
)	O
{	O
bfd_vma	long
inf	O
=	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_info	O
;	O
inf	O
=	O
(	O
(	O
(	O
inf	O
&	O
0xffffffff	int
)	O
<<	O
32	int
)	O
|	O
(	O
(	O
inf	O
>>	O
56	int
)	O
&	O
0xff	int
)	O
|	O
(	O
(	O
inf	O
>>	O
40	int
)	O
&	O
0xff00	int
)	O
|	O
(	O
(	O
inf	O
>>	O
24	int
)	O
&	O
0xff0000	int
)	O
|	O
(	O
(	O
inf	O
>>	O
8	int
)	O
&	O
0xff000000	int
)	O
)	O
;	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_info	O
=	O
inf	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
erels	O
)	O
;	O
}	O
*	O
relsp	O
=	O
rels	O
;	O
*	O
nrelsp	O
=	O
nrels	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
unsigned	O
int	O
get_reloc_type	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_vma	long
reloc_info	O
)	O
{	O
if	O
(	O
is_32bit_elf	O
)	O
return	O
ELF32_R_TYPE	O
(	O
reloc_info	O
)	O
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_MIPS	O
:	O
return	O
ELF64_MIPS_R_TYPE	O
(	O
reloc_info	O
)	O
;	O
case	O
EM_SPARCV9	O
:	O
return	O
ELF64_R_TYPE_ID	O
(	O
reloc_info	O
)	O
;	O
default	O
:	O
return	O
ELF64_R_TYPE	O
(	O
reloc_info	O
)	O
;	O
}	O
}	O
static	O
bfd_vma	long
get_reloc_symindex	O
(	O
bfd_vma	long
reloc_info	O
)	O
{	O
return	O
is_32bit_elf	O
?	O
ELF32_R_SYM	O
(	O
reloc_info	O
)	O
:	O
ELF64_R_SYM	O
(	O
reloc_info	O
)	O
;	O
}	O
static	O
inline	O
bfd_boolean	int
uses_msp430x_relocs	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
return	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_MSP430	O
&&	O
(	O
(	O
(	O
filedata	O
->	O
file_header	O
.	O
e_flags	O
&	O
EF_MSP430_MACH	O
)	O
==	O
E_MSP430_MACH_MSP430X	O
)	O
||	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_NONE	O
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
dump_relocations	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
long	O
rel_offset	O
,	O
unsigned	O
long	O
rel_size	O
,	O
Elf_Internal_Sym	O
*	O
symtab	O
,	O
unsigned	O
long	O
nsyms	O
,	O
char	O
*	O
strtab	O
,	O
unsigned	O
long	O
strtablen	O
,	O
int	O
is_rela	O
,	O
bfd_boolean	int
is_dynsym	O
)	O
{	O
unsigned	O
long	O
i	*(struct)
;	O
Elf_Internal_Rela	O
*	O
rels	O
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
if	O
(	O
is_rela	O
==	O
UNKNOWN	O
)	O
is_rela	O
=	O
guess_is_rela	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
;	O
if	O
(	O
is_rela	O
)	O
{	O
if	O
(	O
!	O
slurp_rela_relocs	O
(	O
filedata	O
,	O
rel_offset	O
,	O
rel_size	O
,	O
&	O
rels	O
,	O
&	O
rel_size	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
slurp_rel_relocs	O
(	O
filedata	O
,	O
rel_offset	O
,	O
rel_size	O
,	O
&	O
rels	O
,	O
&	O
rel_size	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
if	O
(	O
is_rela	O
)	O
{	O
if	O
(	O
do_wide	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\n"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
do_wide	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Offset     Info    Type                Sym. Value  Symbol's Name\n"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Offset     Info    Type            Sym.Value  Sym. Name\n"	*(char)
)	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
is_rela	O
)	O
{	O
if	O
(	O
do_wide	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
do_wide	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Offset             Info             Type               Symbol's Value  Symbol's Name\n"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Offset          Info           Type           Sym. Value    Sym. Name\n"	*(char)
)	O
)	O
;	O
}	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
rel_size	O
;	O
i	*(struct)
++	O
)	O
{	O
const	O
char	O
*	O
rtype	O
;	O
bfd_vma	long
offset	long
;	O
bfd_vma	long
inf	O
;	O
bfd_vma	long
symtab_index	O
;	O
bfd_vma	long
type	enum(int,int,int,int)
;	O
offset	long
=	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_offset	O
;	O
inf	O
=	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_info	O
;	O
type	enum(int,int,int,int)
=	O
get_reloc_type	O
(	O
filedata	O
,	O
inf	O
)	O
;	O
symtab_index	O
=	O
get_reloc_symindex	O
(	O
inf	O
)	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%8.8lx  %8.8lx "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
offset	long
&	O
0xffffffff	int
,	O
(	O
unsigned	O
long	O
)	O
inf	O
&	O
0xffffffff	int
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
do_wide	O
?	O
"%16.16lx  %16.16lx "	*(char)
:	O
"%12.12lx  %12.12lx "	*(char)
,	O
offset	long
,	O
inf	O
)	O
;	O
}	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
default	O
:	O
rtype	O
=	O
NULL	O
;	O
break	O
;	O
case	O
EM_AARCH64	O
:	O
rtype	O
=	O
elf_aarch64_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_M32R	O
:	O
case	O
EM_CYGNUS_M32R	O
:	O
rtype	O
=	O
elf_m32r_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_386	O
:	O
case	O
EM_IAMCU	O
:	O
rtype	O
=	O
elf_i386_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_68HC11	O
:	O
case	O
EM_68HC12	O
:	O
rtype	O
=	O
elf_m68hc11_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_S12Z	O
:	O
rtype	O
=	O
elf_s12z_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_68K	O
:	O
rtype	O
=	O
elf_m68k_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_960	O
:	O
rtype	O
=	O
elf_i960_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_AVR	O
:	O
case	O
EM_AVR_OLD	O
:	O
rtype	O
=	O
elf_avr_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_OLD_SPARCV9	O
:	O
case	O
EM_SPARC32PLUS	O
:	O
case	O
EM_SPARCV9	O
:	O
case	O
EM_SPARC	O
:	O
rtype	O
=	O
elf_sparc_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_SPU	O
:	O
rtype	O
=	O
elf_spu_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_V800	O
:	O
rtype	O
=	O
v800_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_V850	O
:	O
case	O
EM_CYGNUS_V850	O
:	O
rtype	O
=	O
v850_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_D10V	O
:	O
case	O
EM_CYGNUS_D10V	O
:	O
rtype	O
=	O
elf_d10v_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_D30V	O
:	O
case	O
EM_CYGNUS_D30V	O
:	O
rtype	O
=	O
elf_d30v_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_DLX	O
:	O
rtype	O
=	O
elf_dlx_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_SH	O
:	O
rtype	O
=	O
elf_sh_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_MN10300	O
:	O
case	O
EM_CYGNUS_MN10300	O
:	O
rtype	O
=	O
elf_mn10300_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_MN10200	O
:	O
case	O
EM_CYGNUS_MN10200	O
:	O
rtype	O
=	O
elf_mn10200_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_FR30	O
:	O
case	O
EM_CYGNUS_FR30	O
:	O
rtype	O
=	O
elf_fr30_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_CYGNUS_FRV	O
:	O
rtype	O
=	O
elf_frv_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_CSKY	O
:	O
rtype	O
=	O
elf_csky_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_FT32	O
:	O
rtype	O
=	O
elf_ft32_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_MCORE	O
:	O
rtype	O
=	O
elf_mcore_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_MMIX	O
:	O
rtype	O
=	O
elf_mmix_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_MOXIE	O
:	O
rtype	O
=	O
elf_moxie_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_MSP430	O
:	O
if	O
(	O
uses_msp430x_relocs	O
(	O
filedata	O
)	O
)	O
{	O
rtype	O
=	O
elf_msp430x_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
}	O
case	O
EM_MSP430_OLD	O
:	O
rtype	O
=	O
elf_msp430_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_NDS32	O
:	O
rtype	O
=	O
elf_nds32_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_PPC	O
:	O
rtype	O
=	O
elf_ppc_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_PPC64	O
:	O
rtype	O
=	O
elf_ppc64_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_MIPS	O
:	O
case	O
EM_MIPS_RS3_LE	O
:	O
rtype	O
=	O
elf_mips_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_RISCV	O
:	O
rtype	O
=	O
elf_riscv_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_ALPHA	O
:	O
rtype	O
=	O
elf_alpha_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_ARM	O
:	O
rtype	O
=	O
elf_arm_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_ARC	O
:	O
case	O
EM_ARC_COMPACT	O
:	O
case	O
EM_ARC_COMPACT2	O
:	O
rtype	O
=	O
elf_arc_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_PARISC	O
:	O
rtype	O
=	O
elf_hppa_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_H8_300	O
:	O
case	O
EM_H8_300H	O
:	O
case	O
EM_H8S	O
:	O
rtype	O
=	O
elf_h8_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_OR1K	O
:	O
rtype	O
=	O
elf_or1k_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_PJ	O
:	O
case	O
EM_PJ_OLD	O
:	O
rtype	O
=	O
elf_pj_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_IA_64	O
:	O
rtype	O
=	O
elf_ia64_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_CRIS	O
:	O
rtype	O
=	O
elf_cris_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_860	O
:	O
rtype	O
=	O
elf_i860_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_X86_64	O
:	O
case	O
EM_L1OM	O
:	O
case	O
EM_K1OM	O
:	O
rtype	O
=	O
elf_x86_64_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_S370	O
:	O
rtype	O
=	O
i370_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_S390_OLD	O
:	O
case	O
EM_S390	O
:	O
rtype	O
=	O
elf_s390_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_SCORE	O
:	O
rtype	O
=	O
elf_score_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_XSTORMY16	O
:	O
rtype	O
=	O
elf_xstormy16_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_CRX	O
:	O
rtype	O
=	O
elf_crx_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_VAX	O
:	O
rtype	O
=	O
elf_vax_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_VISIUM	O
:	O
rtype	O
=	O
elf_visium_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_BPF	O
:	O
rtype	O
=	O
elf_bpf_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_ADAPTEVA_EPIPHANY	O
:	O
rtype	O
=	O
elf_epiphany_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_IP2K	O
:	O
case	O
EM_IP2K_OLD	O
:	O
rtype	O
=	O
elf_ip2k_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_IQ2000	O
:	O
rtype	O
=	O
elf_iq2000_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_XTENSA_OLD	O
:	O
case	O
EM_XTENSA	O
:	O
rtype	O
=	O
elf_xtensa_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_LATTICEMICO32	O
:	O
rtype	O
=	O
elf_lm32_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_M32C_OLD	O
:	O
case	O
EM_M32C	O
:	O
rtype	O
=	O
elf_m32c_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_MT	O
:	O
rtype	O
=	O
elf_mt_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_BLACKFIN	O
:	O
rtype	O
=	O
elf_bfin_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_CYGNUS_MEP	O
:	O
rtype	O
=	O
elf_mep_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_CR16	O
:	O
rtype	O
=	O
elf_cr16_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_MICROBLAZE	O
:	O
case	O
EM_MICROBLAZE_OLD	O
:	O
rtype	O
=	O
elf_microblaze_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_RL78	O
:	O
rtype	O
=	O
elf_rl78_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_RX	O
:	O
rtype	O
=	O
elf_rx_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_METAG	O
:	O
rtype	O
=	O
elf_metag_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_XC16X	O
:	O
case	O
EM_C166	O
:	O
rtype	O
=	O
elf_xc16x_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_TI_C6000	O
:	O
rtype	O
=	O
elf_tic6x_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_TILEGX	O
:	O
rtype	O
=	O
elf_tilegx_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_TILEPRO	O
:	O
rtype	O
=	O
elf_tilepro_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_WEBASSEMBLY	O
:	O
rtype	O
=	O
elf_wasm32_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_XGATE	O
:	O
rtype	O
=	O
elf_xgate_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_ALTERA_NIOS2	O
:	O
rtype	O
=	O
elf_nios2_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_TI_PRU	O
:	O
rtype	O
=	O
elf_pru_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_NFP	O
:	O
if	O
(	O
EF_NFP_MACH	O
(	O
filedata	O
->	O
file_header	O
.	O
e_flags	O
)	O
==	O
E_NFP_MACH_3200	O
)	O
rtype	O
=	O
elf_nfp3200_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
else	O
rtype	O
=	O
elf_nfp_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_Z80	O
:	O
rtype	O
=	O
elf_z80_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
rtype	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"unrecognized: %-7lx"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
type	enum(int,int,int,int)
&	O
0xffffffff	int
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
do_wide	O
?	O
"%-22s"	*(char)
:	O
"%-17.17s"	*(char)
,	O
rtype	O
)	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_ALPHA	O
&&	O
rtype	O
!=	O
NULL	O
&&	O
streq	O
(	O
rtype	O
,	O
"R_ALPHA_LITUSE"	*(char)
)	O
&&	O
is_rela	O
)	O
{	O
switch	O
(	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_addend	O
)	O
{	O
case	O
LITUSE_ALPHA_ADDR	O
:	O
rtype	O
=	O
"ADDR"	*(char)
;	O
break	O
;	O
case	O
LITUSE_ALPHA_BASE	O
:	O
rtype	O
=	O
"BASE"	*(char)
;	O
break	O
;	O
case	O
LITUSE_ALPHA_BYTOFF	O
:	O
rtype	O
=	O
"BYTOFF"	*(char)
;	O
break	O
;	O
case	O
LITUSE_ALPHA_JSR	O
:	O
rtype	O
=	O
"JSR"	*(char)
;	O
break	O
;	O
case	O
LITUSE_ALPHA_TLSGD	O
:	O
rtype	O
=	O
"TLSGD"	*(char)
;	O
break	O
;	O
case	O
LITUSE_ALPHA_TLSLDM	O
:	O
rtype	O
=	O
"TLSLDM"	*(char)
;	O
break	O
;	O
case	O
LITUSE_ALPHA_JSRDIRECT	O
:	O
rtype	O
=	O
"JSRDIRECT"	*(char)
;	O
break	O
;	O
default	O
:	O
rtype	O
=	O
NULL	O
;	O
}	O
if	O
(	O
rtype	O
)	O
printf	(*(char))->(int)
(	O
" (%s)"	*(char)
,	O
rtype	O
)	O
;	O
else	O
{	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<unknown addend: %lx>"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_addend	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
}	O
else	O
if	O
(	O
symtab_index	O
)	O
{	O
if	O
(	O
symtab	O
==	O
NULL	O
||	O
symtab_index	O
>=	O
nsyms	O
)	O
{	O
error	O
(	O
_	O
(	O
" bad symbol index: %08lx in reloc"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
symtab_index	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
else	O
{	O
Elf_Internal_Sym	O
*	O
psym	O
;	O
const	O
char	O
*	O
version_string	O
;	O
enum	O
versioned_symbol_info	O
sym_info	O
;	O
unsigned	O
short	O
vna_other	O
;	O
psym	O
=	O
symtab	O
+	O
symtab_index	O
;	O
version_string	O
=	O
get_symbol_version_string	O
(	O
filedata	O
,	O
is_dynsym	O
,	O
strtab	O
,	O
strtablen	O
,	O
symtab_index	O
,	O
psym	O
,	O
&	O
sym_info	O
,	O
&	O
vna_other	O
)	O
;	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
psym	O
->	O
st_info	O
)	O
==	O
STT_GNU_IFUNC	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
unsigned	O
int	O
len	int
;	O
unsigned	O
int	O
width	O
=	O
is_32bit_elf	O
?	O
8	int
:	O
14	int
;	O
if	O
(	O
strtab	O
==	O
NULL	O
||	O
psym	O
->	O
st_name	O
==	O
0	int
||	O
psym	O
->	O
st_name	O
>=	O
strtablen	O
)	O
name	*(char)
=	O
"??"	*(char)
;	O
else	O
name	*(char)
=	O
strtab	O
+	O
psym	O
->	O
st_name	O
;	O
len	int
=	O
print_symbol	O
(	O
width	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
version_string	O
)	O
printf	(*(char))->(int)
(	O
sym_info	O
==	O
symbol_public	O
?	O
"@@%s"	*(char)
:	O
"@%s"	*(char)
,	O
version_string	O
)	O
;	O
printf	(*(char))->(int)
(	O
"()%-*s"	*(char)
,	O
len	int
<=	O
width	O
?	O
(	O
width	O
+	O
1	int
)	O
-	O
len	int
:	O
1	int
,	O
" "	*(char)
)	O
;	O
}	O
else	O
{	O
print_vma	O
(	O
psym	O
->	O
st_value	O
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
is_32bit_elf	O
?	O
"   "	*(char)
:	O
" "	*(char)
)	O
;	O
}	O
if	O
(	O
psym	O
->	O
st_name	O
==	O
0	int
)	O
{	O
const	O
char	O
*	O
sec_name	O
=	O
"<null>"	*(char)
;	O
char	O
name_buf	O
[	O
40	int
]	O
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
psym	O
->	O
st_info	O
)	O
==	O
STT_SECTION	O
)	O
{	O
if	O
(	O
psym	O
->	O
st_shndx	O
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
sec_name	O
=	O
SECTION_NAME	O
(	O
filedata	O
->	O
section_headers	O
+	O
psym	O
->	O
st_shndx	O
)	O
;	O
else	O
if	O
(	O
psym	O
->	O
st_shndx	O
==	O
SHN_ABS	O
)	O
sec_name	O
=	O
"ABS"	*(char)
;	O
else	O
if	O
(	O
psym	O
->	O
st_shndx	O
==	O
SHN_COMMON	O
)	O
sec_name	O
=	O
"COMMON"	*(char)
;	O
else	O
if	O
(	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_MIPS	O
&&	O
psym	O
->	O
st_shndx	O
==	O
SHN_MIPS_SCOMMON	O
)	O
||	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_TI_C6000	O
&&	O
psym	O
->	O
st_shndx	O
==	O
SHN_TIC6X_SCOMMON	O
)	O
)	O
sec_name	O
=	O
"SCOMMON"	*(char)
;	O
else	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_MIPS	O
&&	O
psym	O
->	O
st_shndx	O
==	O
SHN_MIPS_SUNDEFINED	O
)	O
sec_name	O
=	O
"SUNDEF"	*(char)
;	O
else	O
if	O
(	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_X86_64	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_L1OM	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_K1OM	O
)	O
&&	O
psym	O
->	O
st_shndx	O
==	O
SHN_X86_64_LCOMMON	O
)	O
sec_name	O
=	O
"LARGE_COMMON"	*(char)
;	O
else	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_IA_64	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_HPUX	O
&&	O
psym	O
->	O
st_shndx	O
==	O
SHN_IA_64_ANSI_COMMON	O
)	O
sec_name	O
=	O
"ANSI_COM"	*(char)
;	O
else	O
if	O
(	O
is_ia64_vms	O
(	O
filedata	O
)	O
&&	O
psym	O
->	O
st_shndx	O
==	O
SHN_IA_64_VMS_SYMVEC	O
)	O
sec_name	O
=	O
"VMS_SYMVEC"	*(char)
;	O
else	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
name_buf	O
,	O
"<section 0x%x>"	*(char)
,	O
(	O
unsigned	O
int	O
)	O
psym	O
->	O
st_shndx	O
)	O
;	O
sec_name	O
=	O
name_buf	O
;	O
}	O
}	O
print_symbol	O
(	O
22	int
,	O
sec_name	O
)	O
;	O
}	O
else	O
if	O
(	O
strtab	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<string table index: %3ld>"	*(char)
)	O
,	O
psym	O
->	O
st_name	O
)	O
;	O
else	O
if	O
(	O
psym	O
->	O
st_name	O
>=	O
strtablen	O
)	O
{	O
error	O
(	O
_	O
(	O
"<corrupt string table index: %3ld>"	*(char)
)	O
,	O
psym	O
->	O
st_name	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
else	O
{	O
print_symbol	O
(	O
22	int
,	O
strtab	O
+	O
psym	O
->	O
st_name	O
)	O
;	O
if	O
(	O
version_string	O
)	O
printf	(*(char))->(int)
(	O
sym_info	O
==	O
symbol_public	O
?	O
"@@%s"	*(char)
:	O
"@%s"	*(char)
,	O
version_string	O
)	O
;	O
}	O
if	O
(	O
is_rela	O
)	O
{	O
bfd_vma	long
off	O
=	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_addend	O
;	O
if	O
(	O
(	O
bfd_signed_vma	long
)	O
off	O
<	O
0	int
)	O
printf	(*(char))->(int)
(	O
" - %"	*(char)
BFD_VMA_FMT	O
"x"	*(char)
,	O
-	O
off	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
" + %"	*(char)
BFD_VMA_FMT	O
"x"	*(char)
,	O
off	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
is_rela	O
)	O
{	O
bfd_vma	long
off	O
=	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_addend	O
;	O
printf	(*(char))->(int)
(	O
"%*c"	*(char)
,	O
is_32bit_elf	O
?	O
12	int
:	O
20	int
,	O
' '	O
)	O
;	O
if	O
(	O
(	O
bfd_signed_vma	long
)	O
off	O
<	O
0	int
)	O
printf	(*(char))->(int)
(	O
"-%"	*(char)
BFD_VMA_FMT	O
"x"	*(char)
,	O
-	O
off	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%"	*(char)
BFD_VMA_FMT	O
"x"	*(char)
,	O
off	O
)	O
;	O
}	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_SPARCV9	O
&&	O
rtype	O
!=	O
NULL	O
&&	O
streq	O
(	O
rtype	O
,	O
"R_SPARC_OLO10"	*(char)
)	O
)	O
printf	(*(char))->(int)
(	O
" + %lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
ELF64_R_TYPE_DATA	O
(	O
inf	O
)	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
is_32bit_elf	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_MIPS	O
)	O
{	O
bfd_vma	long
type2	O
=	O
ELF64_MIPS_R_TYPE2	O
(	O
inf	O
)	O
;	O
bfd_vma	long
type3	O
=	O
ELF64_MIPS_R_TYPE3	O
(	O
inf	O
)	O
;	O
const	O
char	O
*	O
rtype2	O
=	O
elf_mips_reloc_type	O
(	O
type2	O
)	O
;	O
const	O
char	O
*	O
rtype3	O
=	O
elf_mips_reloc_type	O
(	O
type3	O
)	O
;	O
printf	(*(char))->(int)
(	O
"                    Type2: "	*(char)
)	O
;	O
if	O
(	O
rtype2	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"unrecognized: %-7lx"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
type2	O
&	O
0xffffffff	int
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%-17.17s"	*(char)
,	O
rtype2	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n                    Type3: "	*(char)
)	O
;	O
if	O
(	O
rtype3	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"unrecognized: %-7lx"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
type3	O
&	O
0xffffffff	int
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%-17.17s"	*(char)
,	O
rtype3	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
rels	O
)	O
;	O
return	O
res	O
;	O
}	O
static	O
const	O
char	O
*	O
get_aarch64_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_AARCH64_BTI_PLT	O
:	O
return	O
"AARCH64_BTI_PLT"	*(char)
;	O
case	O
DT_AARCH64_PAC_PLT	O
:	O
return	O
"AARCH64_PAC_PLT"	*(char)
;	O
case	O
DT_AARCH64_VARIANT_PCS	O
:	O
return	O
"AARCH64_VARIANT_PCS"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_mips_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_MIPS_RLD_VERSION	O
:	O
return	O
"MIPS_RLD_VERSION"	*(char)
;	O
case	O
DT_MIPS_TIME_STAMP	O
:	O
return	O
"MIPS_TIME_STAMP"	*(char)
;	O
case	O
DT_MIPS_ICHECKSUM	O
:	O
return	O
"MIPS_ICHECKSUM"	*(char)
;	O
case	O
DT_MIPS_IVERSION	O
:	O
return	O
"MIPS_IVERSION"	*(char)
;	O
case	O
DT_MIPS_FLAGS	O
:	O
return	O
"MIPS_FLAGS"	*(char)
;	O
case	O
DT_MIPS_BASE_ADDRESS	O
:	O
return	O
"MIPS_BASE_ADDRESS"	*(char)
;	O
case	O
DT_MIPS_MSYM	O
:	O
return	O
"MIPS_MSYM"	*(char)
;	O
case	O
DT_MIPS_CONFLICT	O
:	O
return	O
"MIPS_CONFLICT"	*(char)
;	O
case	O
DT_MIPS_LIBLIST	O
:	O
return	O
"MIPS_LIBLIST"	*(char)
;	O
case	O
DT_MIPS_LOCAL_GOTNO	O
:	O
return	O
"MIPS_LOCAL_GOTNO"	*(char)
;	O
case	O
DT_MIPS_CONFLICTNO	O
:	O
return	O
"MIPS_CONFLICTNO"	*(char)
;	O
case	O
DT_MIPS_LIBLISTNO	O
:	O
return	O
"MIPS_LIBLISTNO"	*(char)
;	O
case	O
DT_MIPS_SYMTABNO	O
:	O
return	O
"MIPS_SYMTABNO"	*(char)
;	O
case	O
DT_MIPS_UNREFEXTNO	O
:	O
return	O
"MIPS_UNREFEXTNO"	*(char)
;	O
case	O
DT_MIPS_GOTSYM	O
:	O
return	O
"MIPS_GOTSYM"	*(char)
;	O
case	O
DT_MIPS_HIPAGENO	O
:	O
return	O
"MIPS_HIPAGENO"	*(char)
;	O
case	O
DT_MIPS_RLD_MAP	O
:	O
return	O
"MIPS_RLD_MAP"	*(char)
;	O
case	O
DT_MIPS_RLD_MAP_REL	O
:	O
return	O
"MIPS_RLD_MAP_REL"	*(char)
;	O
case	O
DT_MIPS_DELTA_CLASS	O
:	O
return	O
"MIPS_DELTA_CLASS"	*(char)
;	O
case	O
DT_MIPS_DELTA_CLASS_NO	O
:	O
return	O
"MIPS_DELTA_CLASS_NO"	*(char)
;	O
case	O
DT_MIPS_DELTA_INSTANCE	O
:	O
return	O
"MIPS_DELTA_INSTANCE"	*(char)
;	O
case	O
DT_MIPS_DELTA_INSTANCE_NO	O
:	O
return	O
"MIPS_DELTA_INSTANCE_NO"	*(char)
;	O
case	O
DT_MIPS_DELTA_RELOC	O
:	O
return	O
"MIPS_DELTA_RELOC"	*(char)
;	O
case	O
DT_MIPS_DELTA_RELOC_NO	O
:	O
return	O
"MIPS_DELTA_RELOC_NO"	*(char)
;	O
case	O
DT_MIPS_DELTA_SYM	O
:	O
return	O
"MIPS_DELTA_SYM"	*(char)
;	O
case	O
DT_MIPS_DELTA_SYM_NO	O
:	O
return	O
"MIPS_DELTA_SYM_NO"	*(char)
;	O
case	O
DT_MIPS_DELTA_CLASSSYM	O
:	O
return	O
"MIPS_DELTA_CLASSSYM"	*(char)
;	O
case	O
DT_MIPS_DELTA_CLASSSYM_NO	O
:	O
return	O
"MIPS_DELTA_CLASSSYM_NO"	*(char)
;	O
case	O
DT_MIPS_CXX_FLAGS	O
:	O
return	O
"MIPS_CXX_FLAGS"	*(char)
;	O
case	O
DT_MIPS_PIXIE_INIT	O
:	O
return	O
"MIPS_PIXIE_INIT"	*(char)
;	O
case	O
DT_MIPS_SYMBOL_LIB	O
:	O
return	O
"MIPS_SYMBOL_LIB"	*(char)
;	O
case	O
DT_MIPS_LOCALPAGE_GOTIDX	O
:	O
return	O
"MIPS_LOCALPAGE_GOTIDX"	*(char)
;	O
case	O
DT_MIPS_LOCAL_GOTIDX	O
:	O
return	O
"MIPS_LOCAL_GOTIDX"	*(char)
;	O
case	O
DT_MIPS_HIDDEN_GOTIDX	O
:	O
return	O
"MIPS_HIDDEN_GOTIDX"	*(char)
;	O
case	O
DT_MIPS_PROTECTED_GOTIDX	O
:	O
return	O
"MIPS_PROTECTED_GOTIDX"	*(char)
;	O
case	O
DT_MIPS_OPTIONS	O
:	O
return	O
"MIPS_OPTIONS"	*(char)
;	O
case	O
DT_MIPS_INTERFACE	O
:	O
return	O
"MIPS_INTERFACE"	*(char)
;	O
case	O
DT_MIPS_DYNSTR_ALIGN	O
:	O
return	O
"MIPS_DYNSTR_ALIGN"	*(char)
;	O
case	O
DT_MIPS_INTERFACE_SIZE	O
:	O
return	O
"MIPS_INTERFACE_SIZE"	*(char)
;	O
case	O
DT_MIPS_RLD_TEXT_RESOLVE_ADDR	O
:	O
return	O
"MIPS_RLD_TEXT_RESOLVE_ADDR"	*(char)
;	O
case	O
DT_MIPS_PERF_SUFFIX	O
:	O
return	O
"MIPS_PERF_SUFFIX"	*(char)
;	O
case	O
DT_MIPS_COMPACT_SIZE	O
:	O
return	O
"MIPS_COMPACT_SIZE"	*(char)
;	O
case	O
DT_MIPS_GP_VALUE	O
:	O
return	O
"MIPS_GP_VALUE"	*(char)
;	O
case	O
DT_MIPS_AUX_DYNAMIC	O
:	O
return	O
"MIPS_AUX_DYNAMIC"	*(char)
;	O
case	O
DT_MIPS_PLTGOT	O
:	O
return	O
"MIPS_PLTGOT"	*(char)
;	O
case	O
DT_MIPS_RWPLT	O
:	O
return	O
"MIPS_RWPLT"	*(char)
;	O
case	O
DT_MIPS_XHASH	O
:	O
return	O
"MIPS_XHASH"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_sparc64_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_SPARC_REGISTER	O
:	O
return	O
"SPARC_REGISTER"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ppc_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_PPC_GOT	O
:	O
return	O
"PPC_GOT"	*(char)
;	O
case	O
DT_PPC_OPT	O
:	O
return	O
"PPC_OPT"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ppc64_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_PPC64_GLINK	O
:	O
return	O
"PPC64_GLINK"	*(char)
;	O
case	O
DT_PPC64_OPD	O
:	O
return	O
"PPC64_OPD"	*(char)
;	O
case	O
DT_PPC64_OPDSZ	O
:	O
return	O
"PPC64_OPDSZ"	*(char)
;	O
case	O
DT_PPC64_OPT	O
:	O
return	O
"PPC64_OPT"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_parisc_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_HP_LOAD_MAP	O
:	O
return	O
"HP_LOAD_MAP"	*(char)
;	O
case	O
DT_HP_DLD_FLAGS	O
:	O
return	O
"HP_DLD_FLAGS"	*(char)
;	O
case	O
DT_HP_DLD_HOOK	O
:	O
return	O
"HP_DLD_HOOK"	*(char)
;	O
case	O
DT_HP_UX10_INIT	O
:	O
return	O
"HP_UX10_INIT"	*(char)
;	O
case	O
DT_HP_UX10_INITSZ	O
:	O
return	O
"HP_UX10_INITSZ"	*(char)
;	O
case	O
DT_HP_PREINIT	O
:	O
return	O
"HP_PREINIT"	*(char)
;	O
case	O
DT_HP_PREINITSZ	O
:	O
return	O
"HP_PREINITSZ"	*(char)
;	O
case	O
DT_HP_NEEDED	O
:	O
return	O
"HP_NEEDED"	*(char)
;	O
case	O
DT_HP_TIME_STAMP	O
:	O
return	O
"HP_TIME_STAMP"	*(char)
;	O
case	O
DT_HP_CHECKSUM	O
:	O
return	O
"HP_CHECKSUM"	*(char)
;	O
case	O
DT_HP_GST_SIZE	O
:	O
return	O
"HP_GST_SIZE"	*(char)
;	O
case	O
DT_HP_GST_VERSION	O
:	O
return	O
"HP_GST_VERSION"	*(char)
;	O
case	O
DT_HP_GST_HASHVAL	O
:	O
return	O
"HP_GST_HASHVAL"	*(char)
;	O
case	O
DT_HP_EPLTREL	O
:	O
return	O
"HP_GST_EPLTREL"	*(char)
;	O
case	O
DT_HP_EPLTRELSZ	O
:	O
return	O
"HP_GST_EPLTRELSZ"	*(char)
;	O
case	O
DT_HP_FILTERED	O
:	O
return	O
"HP_FILTERED"	*(char)
;	O
case	O
DT_HP_FILTER_TLS	O
:	O
return	O
"HP_FILTER_TLS"	*(char)
;	O
case	O
DT_HP_COMPAT_FILTERED	O
:	O
return	O
"HP_COMPAT_FILTERED"	*(char)
;	O
case	O
DT_HP_LAZYLOAD	O
:	O
return	O
"HP_LAZYLOAD"	*(char)
;	O
case	O
DT_HP_BIND_NOW_COUNT	O
:	O
return	O
"HP_BIND_NOW_COUNT"	*(char)
;	O
case	O
DT_PLT	O
:	O
return	O
"PLT"	*(char)
;	O
case	O
DT_PLT_SIZE	O
:	O
return	O
"PLT_SIZE"	*(char)
;	O
case	O
DT_DLT	O
:	O
return	O
"DLT"	*(char)
;	O
case	O
DT_DLT_SIZE	O
:	O
return	O
"DLT_SIZE"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ia64_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_IA_64_PLT_RESERVE	O
:	O
return	O
"IA_64_PLT_RESERVE"	*(char)
;	O
case	O
DT_IA_64_VMS_SUBTYPE	O
:	O
return	O
"VMS_SUBTYPE"	*(char)
;	O
case	O
DT_IA_64_VMS_IMGIOCNT	O
:	O
return	O
"VMS_IMGIOCNT"	*(char)
;	O
case	O
DT_IA_64_VMS_LNKFLAGS	O
:	O
return	O
"VMS_LNKFLAGS"	*(char)
;	O
case	O
DT_IA_64_VMS_VIR_MEM_BLK_SIZ	O
:	O
return	O
"VMS_VIR_MEM_BLK_SIZ"	*(char)
;	O
case	O
DT_IA_64_VMS_IDENT	O
:	O
return	O
"VMS_IDENT"	*(char)
;	O
case	O
DT_IA_64_VMS_NEEDED_IDENT	O
:	O
return	O
"VMS_NEEDED_IDENT"	*(char)
;	O
case	O
DT_IA_64_VMS_IMG_RELA_CNT	O
:	O
return	O
"VMS_IMG_RELA_CNT"	*(char)
;	O
case	O
DT_IA_64_VMS_SEG_RELA_CNT	O
:	O
return	O
"VMS_SEG_RELA_CNT"	*(char)
;	O
case	O
DT_IA_64_VMS_FIXUP_RELA_CNT	O
:	O
return	O
"VMS_FIXUP_RELA_CNT"	*(char)
;	O
case	O
DT_IA_64_VMS_FIXUP_NEEDED	O
:	O
return	O
"VMS_FIXUP_NEEDED"	*(char)
;	O
case	O
DT_IA_64_VMS_SYMVEC_CNT	O
:	O
return	O
"VMS_SYMVEC_CNT"	*(char)
;	O
case	O
DT_IA_64_VMS_XLATED	O
:	O
return	O
"VMS_XLATED"	*(char)
;	O
case	O
DT_IA_64_VMS_STACKSIZE	O
:	O
return	O
"VMS_STACKSIZE"	*(char)
;	O
case	O
DT_IA_64_VMS_UNWINDSZ	O
:	O
return	O
"VMS_UNWINDSZ"	*(char)
;	O
case	O
DT_IA_64_VMS_UNWIND_CODSEG	O
:	O
return	O
"VMS_UNWIND_CODSEG"	*(char)
;	O
case	O
DT_IA_64_VMS_UNWIND_INFOSEG	O
:	O
return	O
"VMS_UNWIND_INFOSEG"	*(char)
;	O
case	O
DT_IA_64_VMS_LINKTIME	O
:	O
return	O
"VMS_LINKTIME"	*(char)
;	O
case	O
DT_IA_64_VMS_SEG_NO	O
:	O
return	O
"VMS_SEG_NO"	*(char)
;	O
case	O
DT_IA_64_VMS_SYMVEC_OFFSET	O
:	O
return	O
"VMS_SYMVEC_OFFSET"	*(char)
;	O
case	O
DT_IA_64_VMS_SYMVEC_SEG	O
:	O
return	O
"VMS_SYMVEC_SEG"	*(char)
;	O
case	O
DT_IA_64_VMS_UNWIND_OFFSET	O
:	O
return	O
"VMS_UNWIND_OFFSET"	*(char)
;	O
case	O
DT_IA_64_VMS_UNWIND_SEG	O
:	O
return	O
"VMS_UNWIND_SEG"	*(char)
;	O
case	O
DT_IA_64_VMS_STRTAB_OFFSET	O
:	O
return	O
"VMS_STRTAB_OFFSET"	*(char)
;	O
case	O
DT_IA_64_VMS_SYSVER_OFFSET	O
:	O
return	O
"VMS_SYSVER_OFFSET"	*(char)
;	O
case	O
DT_IA_64_VMS_IMG_RELA_OFF	O
:	O
return	O
"VMS_IMG_RELA_OFF"	*(char)
;	O
case	O
DT_IA_64_VMS_SEG_RELA_OFF	O
:	O
return	O
"VMS_SEG_RELA_OFF"	*(char)
;	O
case	O
DT_IA_64_VMS_FIXUP_RELA_OFF	O
:	O
return	O
"VMS_FIXUP_RELA_OFF"	*(char)
;	O
case	O
DT_IA_64_VMS_PLTGOT_OFFSET	O
:	O
return	O
"VMS_PLTGOT_OFFSET"	*(char)
;	O
case	O
DT_IA_64_VMS_PLTGOT_SEG	O
:	O
return	O
"VMS_PLTGOT_SEG"	*(char)
;	O
case	O
DT_IA_64_VMS_FPMODE	O
:	O
return	O
"VMS_FPMODE"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_solaris_section_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
0x6fffffee	int
:	O
return	O
"SUNW_ancillary"	*(char)
;	O
case	O
0x6fffffef	int
:	O
return	O
"SUNW_capchain"	*(char)
;	O
case	O
0x6ffffff0	int
:	O
return	O
"SUNW_capinfo"	*(char)
;	O
case	O
0x6ffffff1	int
:	O
return	O
"SUNW_symsort"	*(char)
;	O
case	O
0x6ffffff2	int
:	O
return	O
"SUNW_tlssort"	*(char)
;	O
case	O
0x6ffffff3	int
:	O
return	O
"SUNW_LDYNSYM"	*(char)
;	O
case	O
0x6ffffff4	int
:	O
return	O
"SUNW_dof"	*(char)
;	O
case	O
0x6ffffff5	int
:	O
return	O
"SUNW_cap"	*(char)
;	O
case	O
0x6ffffff6	int
:	O
return	O
"SUNW_SIGNATURE"	*(char)
;	O
case	O
0x6ffffff7	int
:	O
return	O
"SUNW_ANNOTATE"	*(char)
;	O
case	O
0x6ffffff8	int
:	O
return	O
"SUNW_DEBUGSTR"	*(char)
;	O
case	O
0x6ffffff9	int
:	O
return	O
"SUNW_DEBUG"	*(char)
;	O
case	O
0x6ffffffa	int
:	O
return	O
"SUNW_move"	*(char)
;	O
case	O
0x6ffffffb	int
:	O
return	O
"SUNW_COMDAT"	*(char)
;	O
case	O
0x6ffffffc	int
:	O
return	O
"SUNW_syminfo"	*(char)
;	O
case	O
0x6ffffffd	int
:	O
return	O
"SUNW_verdef"	*(char)
;	O
case	O
0x6ffffffe	int
:	O
return	O
"SUNW_verneed"	*(char)
;	O
case	O
0x6fffffff	int
:	O
return	O
"SUNW_versym"	*(char)
;	O
case	O
0x70000000	int
:	O
return	O
"SPARC_GOTDATA"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_alpha_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_ALPHA_PLTRO	O
:	O
return	O
"ALPHA_PLTRO"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_score_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_SCORE_BASE_ADDRESS	O
:	O
return	O
"SCORE_BASE_ADDRESS"	*(char)
;	O
case	O
DT_SCORE_LOCAL_GOTNO	O
:	O
return	O
"SCORE_LOCAL_GOTNO"	*(char)
;	O
case	O
DT_SCORE_SYMTABNO	O
:	O
return	O
"SCORE_SYMTABNO"	*(char)
;	O
case	O
DT_SCORE_GOTSYM	O
:	O
return	O
"SCORE_GOTSYM"	*(char)
;	O
case	O
DT_SCORE_UNREFEXTNO	O
:	O
return	O
"SCORE_UNREFEXTNO"	*(char)
;	O
case	O
DT_SCORE_HIPAGENO	O
:	O
return	O
"SCORE_HIPAGENO"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_tic6x_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_C6000_GSYM_OFFSET	O
:	O
return	O
"C6000_GSYM_OFFSET"	*(char)
;	O
case	O
DT_C6000_GSTR_OFFSET	O
:	O
return	O
"C6000_GSTR_OFFSET"	*(char)
;	O
case	O
DT_C6000_DSBT_BASE	O
:	O
return	O
"C6000_DSBT_BASE"	*(char)
;	O
case	O
DT_C6000_DSBT_SIZE	O
:	O
return	O
"C6000_DSBT_SIZE"	*(char)
;	O
case	O
DT_C6000_PREEMPTMAP	O
:	O
return	O
"C6000_PREEMPTMAP"	*(char)
;	O
case	O
DT_C6000_DSBT_INDEX	O
:	O
return	O
"C6000_DSBT_INDEX"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_nios2_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_NIOS2_GP	O
:	O
return	O
"NIOS2_GP"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_solaris_dynamic_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
0x6000000d	int
:	O
return	O
"SUNW_AUXILIARY"	*(char)
;	O
case	O
0x6000000e	int
:	O
return	O
"SUNW_RTLDINF"	*(char)
;	O
case	O
0x6000000f	int
:	O
return	O
"SUNW_FILTER"	*(char)
;	O
case	O
0x60000010	int
:	O
return	O
"SUNW_CAP"	*(char)
;	O
case	O
0x60000011	int
:	O
return	O
"SUNW_SYMTAB"	*(char)
;	O
case	O
0x60000012	int
:	O
return	O
"SUNW_SYMSZ"	*(char)
;	O
case	O
0x60000013	int
:	O
return	O
"SUNW_SORTENT"	*(char)
;	O
case	O
0x60000014	int
:	O
return	O
"SUNW_SYMSORT"	*(char)
;	O
case	O
0x60000015	int
:	O
return	O
"SUNW_SYMSORTSZ"	*(char)
;	O
case	O
0x60000016	int
:	O
return	O
"SUNW_TLSSORT"	*(char)
;	O
case	O
0x60000017	int
:	O
return	O
"SUNW_TLSSORTSZ"	*(char)
;	O
case	O
0x60000018	int
:	O
return	O
"SUNW_CAPINFO"	*(char)
;	O
case	O
0x60000019	int
:	O
return	O
"SUNW_STRPAD"	*(char)
;	O
case	O
0x6000001a	int
:	O
return	O
"SUNW_CAPCHAIN"	*(char)
;	O
case	O
0x6000001b	int
:	O
return	O
"SUNW_LDMACH"	*(char)
;	O
case	O
0x6000001d	int
:	O
return	O
"SUNW_CAPCHAINENT"	*(char)
;	O
case	O
0x6000001f	int
:	O
return	O
"SUNW_CAPCHAINSZ"	*(char)
;	O
case	O
0x60000021	int
:	O
return	O
"SUNW_PARENT"	*(char)
;	O
case	O
0x60000023	int
:	O
return	O
"SUNW_ASLR"	*(char)
;	O
case	O
0x60000025	int
:	O
return	O
"SUNW_RELAX"	*(char)
;	O
case	O
0x60000029	int
:	O
return	O
"SUNW_NXHEAP"	*(char)
;	O
case	O
0x6000002b	int
:	O
return	O
"SUNW_NXSTACK"	*(char)
;	O
case	O
0x70000001	int
:	O
return	O
"SPARC_REGISTER"	*(char)
;	O
case	O
0x7ffffffd	int
:	O
return	O
"AUXILIARY"	*(char)
;	O
case	O
0x7ffffffe	int
:	O
return	O
"USED"	*(char)
;	O
case	O
0x7fffffff	int
:	O
return	O
"FILTER"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_dynamic_type	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
static	O
char	O
buff	O
[	O
64	int
]	O
;	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
DT_NULL	O
:	O
return	O
"NULL"	*(char)
;	O
case	O
DT_NEEDED	O
:	O
return	O
"NEEDED"	*(char)
;	O
case	O
DT_PLTRELSZ	O
:	O
return	O
"PLTRELSZ"	*(char)
;	O
case	O
DT_PLTGOT	O
:	O
return	O
"PLTGOT"	*(char)
;	O
case	O
DT_HASH	O
:	O
return	O
"HASH"	*(char)
;	O
case	O
DT_STRTAB	O
:	O
return	O
"STRTAB"	*(char)
;	O
case	O
DT_SYMTAB	O
:	O
return	O
"SYMTAB"	*(char)
;	O
case	O
DT_RELA	O
:	O
return	O
"RELA"	*(char)
;	O
case	O
DT_RELASZ	O
:	O
return	O
"RELASZ"	*(char)
;	O
case	O
DT_RELAENT	O
:	O
return	O
"RELAENT"	*(char)
;	O
case	O
DT_STRSZ	O
:	O
return	O
"STRSZ"	*(char)
;	O
case	O
DT_SYMENT	O
:	O
return	O
"SYMENT"	*(char)
;	O
case	O
DT_INIT	O
:	O
return	O
"INIT"	*(char)
;	O
case	O
DT_FINI	O
:	O
return	O
"FINI"	*(char)
;	O
case	O
DT_SONAME	O
:	O
return	O
"SONAME"	*(char)
;	O
case	O
DT_RPATH	O
:	O
return	O
"RPATH"	*(char)
;	O
case	O
DT_SYMBOLIC	O
:	O
return	O
"SYMBOLIC"	*(char)
;	O
case	O
DT_REL	O
:	O
return	O
"REL"	*(char)
;	O
case	O
DT_RELSZ	O
:	O
return	O
"RELSZ"	*(char)
;	O
case	O
DT_RELENT	O
:	O
return	O
"RELENT"	*(char)
;	O
case	O
DT_PLTREL	O
:	O
return	O
"PLTREL"	*(char)
;	O
case	O
DT_DEBUG	O
:	O
return	O
"DEBUG"	*(char)
;	O
case	O
DT_TEXTREL	O
:	O
return	O
"TEXTREL"	*(char)
;	O
case	O
DT_JMPREL	O
:	O
return	O
"JMPREL"	*(char)
;	O
case	O
DT_BIND_NOW	O
:	O
return	O
"BIND_NOW"	*(char)
;	O
case	O
DT_INIT_ARRAY	O
:	O
return	O
"INIT_ARRAY"	*(char)
;	O
case	O
DT_FINI_ARRAY	O
:	O
return	O
"FINI_ARRAY"	*(char)
;	O
case	O
DT_INIT_ARRAYSZ	O
:	O
return	O
"INIT_ARRAYSZ"	*(char)
;	O
case	O
DT_FINI_ARRAYSZ	O
:	O
return	O
"FINI_ARRAYSZ"	*(char)
;	O
case	O
DT_RUNPATH	O
:	O
return	O
"RUNPATH"	*(char)
;	O
case	O
DT_FLAGS	O
:	O
return	O
"FLAGS"	*(char)
;	O
case	O
DT_PREINIT_ARRAY	O
:	O
return	O
"PREINIT_ARRAY"	*(char)
;	O
case	O
DT_PREINIT_ARRAYSZ	O
:	O
return	O
"PREINIT_ARRAYSZ"	*(char)
;	O
case	O
DT_SYMTAB_SHNDX	O
:	O
return	O
"SYMTAB_SHNDX"	*(char)
;	O
case	O
DT_CHECKSUM	O
:	O
return	O
"CHECKSUM"	*(char)
;	O
case	O
DT_PLTPADSZ	O
:	O
return	O
"PLTPADSZ"	*(char)
;	O
case	O
DT_MOVEENT	O
:	O
return	O
"MOVEENT"	*(char)
;	O
case	O
DT_MOVESZ	O
:	O
return	O
"MOVESZ"	*(char)
;	O
case	O
DT_FEATURE	O
:	O
return	O
"FEATURE"	*(char)
;	O
case	O
DT_POSFLAG_1	O
:	O
return	O
"POSFLAG_1"	*(char)
;	O
case	O
DT_SYMINSZ	O
:	O
return	O
"SYMINSZ"	*(char)
;	O
case	O
DT_SYMINENT	O
:	O
return	O
"SYMINENT"	*(char)
;	O
case	O
DT_ADDRRNGLO	O
:	O
return	O
"ADDRRNGLO"	*(char)
;	O
case	O
DT_CONFIG	O
:	O
return	O
"CONFIG"	*(char)
;	O
case	O
DT_DEPAUDIT	O
:	O
return	O
"DEPAUDIT"	*(char)
;	O
case	O
DT_AUDIT	O
:	O
return	O
"AUDIT"	*(char)
;	O
case	O
DT_PLTPAD	O
:	O
return	O
"PLTPAD"	*(char)
;	O
case	O
DT_MOVETAB	O
:	O
return	O
"MOVETAB"	*(char)
;	O
case	O
DT_SYMINFO	O
:	O
return	O
"SYMINFO"	*(char)
;	O
case	O
DT_VERSYM	O
:	O
return	O
"VERSYM"	*(char)
;	O
case	O
DT_TLSDESC_GOT	O
:	O
return	O
"TLSDESC_GOT"	*(char)
;	O
case	O
DT_TLSDESC_PLT	O
:	O
return	O
"TLSDESC_PLT"	*(char)
;	O
case	O
DT_RELACOUNT	O
:	O
return	O
"RELACOUNT"	*(char)
;	O
case	O
DT_RELCOUNT	O
:	O
return	O
"RELCOUNT"	*(char)
;	O
case	O
DT_FLAGS_1	O
:	O
return	O
"FLAGS_1"	*(char)
;	O
case	O
DT_VERDEF	O
:	O
return	O
"VERDEF"	*(char)
;	O
case	O
DT_VERDEFNUM	O
:	O
return	O
"VERDEFNUM"	*(char)
;	O
case	O
DT_VERNEED	O
:	O
return	O
"VERNEED"	*(char)
;	O
case	O
DT_VERNEEDNUM	O
:	O
return	O
"VERNEEDNUM"	*(char)
;	O
case	O
DT_AUXILIARY	O
:	O
return	O
"AUXILIARY"	*(char)
;	O
case	O
DT_USED	O
:	O
return	O
"USED"	*(char)
;	O
case	O
DT_FILTER	O
:	O
return	O
"FILTER"	*(char)
;	O
case	O
DT_GNU_PRELINKED	O
:	O
return	O
"GNU_PRELINKED"	*(char)
;	O
case	O
DT_GNU_CONFLICT	O
:	O
return	O
"GNU_CONFLICT"	*(char)
;	O
case	O
DT_GNU_CONFLICTSZ	O
:	O
return	O
"GNU_CONFLICTSZ"	*(char)
;	O
case	O
DT_GNU_LIBLIST	O
:	O
return	O
"GNU_LIBLIST"	*(char)
;	O
case	O
DT_GNU_LIBLISTSZ	O
:	O
return	O
"GNU_LIBLISTSZ"	*(char)
;	O
case	O
DT_GNU_HASH	O
:	O
return	O
"GNU_HASH"	*(char)
;	O
default	O
:	O
if	O
(	O
(	O
type	enum(int,int,int,int)
>=	O
DT_LOPROC	O
)	O
&&	O
(	O
type	enum(int,int,int,int)
<=	O
DT_HIPROC	O
)	O
)	O
{	O
const	O
char	O
*	O
result	O
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_AARCH64	O
:	O
result	O
=	O
get_aarch64_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_MIPS	O
:	O
case	O
EM_MIPS_RS3_LE	O
:	O
result	O
=	O
get_mips_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_SPARCV9	O
:	O
result	O
=	O
get_sparc64_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_PPC	O
:	O
result	O
=	O
get_ppc_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_PPC64	O
:	O
result	O
=	O
get_ppc64_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_IA_64	O
:	O
result	O
=	O
get_ia64_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_ALPHA	O
:	O
result	O
=	O
get_alpha_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_SCORE	O
:	O
result	O
=	O
get_score_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_TI_C6000	O
:	O
result	O
=	O
get_tic6x_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_ALTERA_NIOS2	O
:	O
result	O
=	O
get_nios2_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_SOLARIS	O
)	O
result	O
=	O
get_solaris_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
else	O
result	O
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	O
!=	O
NULL	O
)	O
return	O
result	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"Processor Specific: %lx"	*(char)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
}	O
else	O
if	O
(	O
(	O
(	O
type	enum(int,int,int,int)
>=	O
DT_LOOS	O
)	O
&&	O
(	O
type	enum(int,int,int,int)
<=	O
DT_HIOS	O
)	O
)	O
||	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_PARISC	O
&&	O
(	O
type	enum(int,int,int,int)
>=	O
OLD_DT_LOOS	O
)	O
&&	O
(	O
type	enum(int,int,int,int)
<=	O
OLD_DT_HIOS	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
result	O
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_PARISC	O
:	O
result	O
=	O
get_parisc_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
case	O
EM_IA_64	O
:	O
result	O
=	O
get_ia64_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_SOLARIS	O
)	O
result	O
=	O
get_solaris_dynamic_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
else	O
result	O
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	O
!=	O
NULL	O
)	O
return	O
result	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"Operating System specific: %lx"	*(char)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
}	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<unknown>: %lx"	*(char)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
char	O
*	O
get_file_type	O
(	O
unsigned	O
e_type	O
)	O
{	O
static	O
char	O
buff	O
[	O
32	int
]	O
;	O
switch	O
(	O
e_type	O
)	O
{	O
case	O
ET_NONE	O
:	O
return	O
_	O
(	O
"NONE (None)"	*(char)
)	O
;	O
case	O
ET_REL	O
:	O
return	O
_	O
(	O
"REL (Relocatable file)"	*(char)
)	O
;	O
case	O
ET_EXEC	O
:	O
return	O
_	O
(	O
"EXEC (Executable file)"	*(char)
)	O
;	O
case	O
ET_DYN	O
:	O
return	O
_	O
(	O
"DYN (Shared object file)"	*(char)
)	O
;	O
case	O
ET_CORE	O
:	O
return	O
_	O
(	O
"CORE (Core file)"	*(char)
)	O
;	O
default	O
:	O
if	O
(	O
(	O
e_type	O
>=	O
ET_LOPROC	O
)	O
&&	O
(	O
e_type	O
<=	O
ET_HIPROC	O
)	O
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"Processor Specific: (%x)"	*(char)
)	O
,	O
e_type	O
)	O
;	O
else	O
if	O
(	O
(	O
e_type	O
>=	O
ET_LOOS	O
)	O
&&	O
(	O
e_type	O
<=	O
ET_HIOS	O
)	O
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"OS Specific: (%x)"	*(char)
)	O
,	O
e_type	O
)	O
;	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<unknown>: %x"	*(char)
)	O
,	O
e_type	O
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
char	O
*	O
get_machine_name	O
(	O
unsigned	O
e_machine	O
)	O
{	O
static	O
char	O
buff	O
[	O
64	int
]	O
;	O
switch	O
(	O
e_machine	O
)	O
{	O
case	O
EM_NONE	O
:	O
return	O
_	O
(	O
"None"	*(char)
)	O
;	O
case	O
EM_M32	O
:	O
return	O
"WE32100"	*(char)
;	O
case	O
EM_SPARC	O
:	O
return	O
"Sparc"	*(char)
;	O
case	O
EM_386	O
:	O
return	O
"Intel 80386"	*(char)
;	O
case	O
EM_68K	O
:	O
return	O
"MC68000"	*(char)
;	O
case	O
EM_88K	O
:	O
return	O
"MC88000"	*(char)
;	O
case	O
EM_IAMCU	O
:	O
return	O
"Intel MCU"	*(char)
;	O
case	O
EM_860	O
:	O
return	O
"Intel 80860"	*(char)
;	O
case	O
EM_MIPS	O
:	O
return	O
"MIPS R3000"	*(char)
;	O
case	O
EM_S370	O
:	O
return	O
"IBM System/370"	*(char)
;	O
case	O
EM_MIPS_RS3_LE	O
:	O
return	O
"MIPS R4000 big-endian"	*(char)
;	O
case	O
EM_OLD_SPARCV9	O
:	O
return	O
"Sparc v9 (old)"	*(char)
;	O
case	O
EM_PARISC	O
:	O
return	O
"HPPA"	*(char)
;	O
case	O
EM_VPP550	O
:	O
return	O
"Fujitsu VPP500"	*(char)
;	O
case	O
EM_SPARC32PLUS	O
:	O
return	O
"Sparc v8+"	*(char)
;	O
case	O
EM_960	O
:	O
return	O
"Intel 80960"	*(char)
;	O
case	O
EM_PPC	O
:	O
return	O
"PowerPC"	*(char)
;	O
case	O
EM_PPC64	O
:	O
return	O
"PowerPC64"	*(char)
;	O
case	O
EM_S390_OLD	O
:	O
case	O
EM_S390	O
:	O
return	O
"IBM S/390"	*(char)
;	O
case	O
EM_SPU	O
:	O
return	O
"SPU"	*(char)
;	O
case	O
EM_V800	O
:	O
return	O
"Renesas V850 (using RH850 ABI)"	*(char)
;	O
case	O
EM_FR20	O
:	O
return	O
"Fujitsu FR20"	*(char)
;	O
case	O
EM_RH32	O
:	O
return	O
"TRW RH32"	*(char)
;	O
case	O
EM_MCORE	O
:	O
return	O
"MCORE"	*(char)
;	O
case	O
EM_ARM	O
:	O
return	O
"ARM"	*(char)
;	O
case	O
EM_OLD_ALPHA	O
:	O
return	O
"Digital Alpha (old)"	*(char)
;	O
case	O
EM_SH	O
:	O
return	O
"Renesas / SuperH SH"	*(char)
;	O
case	O
EM_SPARCV9	O
:	O
return	O
"Sparc v9"	*(char)
;	O
case	O
EM_TRICORE	O
:	O
return	O
"Siemens Tricore"	*(char)
;	O
case	O
EM_ARC	O
:	O
return	O
"ARC"	*(char)
;	O
case	O
EM_H8_300	O
:	O
return	O
"Renesas H8/300"	*(char)
;	O
case	O
EM_H8_300H	O
:	O
return	O
"Renesas H8/300H"	*(char)
;	O
case	O
EM_H8S	O
:	O
return	O
"Renesas H8S"	*(char)
;	O
case	O
EM_H8_500	O
:	O
return	O
"Renesas H8/500"	*(char)
;	O
case	O
EM_IA_64	O
:	O
return	O
"Intel IA-64"	*(char)
;	O
case	O
EM_MIPS_X	O
:	O
return	O
"Stanford MIPS-X"	*(char)
;	O
case	O
EM_COLDFIRE	O
:	O
return	O
"Motorola Coldfire"	*(char)
;	O
case	O
EM_68HC12	O
:	O
return	O
"Motorola MC68HC12 Microcontroller"	*(char)
;	O
case	O
EM_MMA	O
:	O
return	O
"Fujitsu Multimedia Accelerator"	*(char)
;	O
case	O
EM_PCP	O
:	O
return	O
"Siemens PCP"	*(char)
;	O
case	O
EM_NCPU	O
:	O
return	O
"Sony nCPU embedded RISC processor"	*(char)
;	O
case	O
EM_NDR1	O
:	O
return	O
"Denso NDR1 microprocesspr"	*(char)
;	O
case	O
EM_STARCORE	O
:	O
return	O
"Motorola Star*Core processor"	*(char)
;	O
case	O
EM_ME16	O
:	O
return	O
"Toyota ME16 processor"	*(char)
;	O
case	O
EM_ST100	O
:	O
return	O
"STMicroelectronics ST100 processor"	*(char)
;	O
case	O
EM_TINYJ	O
:	O
return	O
"Advanced Logic Corp. TinyJ embedded processor"	*(char)
;	O
case	O
EM_X86_64	O
:	O
return	O
"Advanced Micro Devices X86-64"	*(char)
;	O
case	O
EM_PDSP	O
:	O
return	O
"Sony DSP processor"	*(char)
;	O
case	O
EM_PDP10	O
:	O
return	O
"Digital Equipment Corp. PDP-10"	*(char)
;	O
case	O
EM_PDP11	O
:	O
return	O
"Digital Equipment Corp. PDP-11"	*(char)
;	O
case	O
EM_FX66	O
:	O
return	O
"Siemens FX66 microcontroller"	*(char)
;	O
case	O
EM_ST9PLUS	O
:	O
return	O
"STMicroelectronics ST9+ 8/16 bit microcontroller"	*(char)
;	O
case	O
EM_ST7	O
:	O
return	O
"STMicroelectronics ST7 8-bit microcontroller"	*(char)
;	O
case	O
EM_68HC16	O
:	O
return	O
"Motorola MC68HC16 Microcontroller"	*(char)
;	O
case	O
EM_68HC11	O
:	O
return	O
"Motorola MC68HC11 Microcontroller"	*(char)
;	O
case	O
EM_68HC08	O
:	O
return	O
"Motorola MC68HC08 Microcontroller"	*(char)
;	O
case	O
EM_68HC05	O
:	O
return	O
"Motorola MC68HC05 Microcontroller"	*(char)
;	O
case	O
EM_SVX	O
:	O
return	O
"Silicon Graphics SVx"	*(char)
;	O
case	O
EM_ST19	O
:	O
return	O
"STMicroelectronics ST19 8-bit microcontroller"	*(char)
;	O
case	O
EM_VAX	O
:	O
return	O
"Digital VAX"	*(char)
;	O
case	O
EM_CRIS	O
:	O
return	O
"Axis Communications 32-bit embedded processor"	*(char)
;	O
case	O
EM_JAVELIN	O
:	O
return	O
"Infineon Technologies 32-bit embedded cpu"	*(char)
;	O
case	O
EM_FIREPATH	O
:	O
return	O
"Element 14 64-bit DSP processor"	*(char)
;	O
case	O
EM_ZSP	O
:	O
return	O
"LSI Logic's 16-bit DSP processor"	*(char)
;	O
case	O
EM_MMIX	O
:	O
return	O
"Donald Knuth's educational 64-bit processor"	*(char)
;	O
case	O
EM_HUANY	O
:	O
return	O
"Harvard Universitys's machine-independent object format"	*(char)
;	O
case	O
EM_PRISM	O
:	O
return	O
"Vitesse Prism"	*(char)
;	O
case	O
EM_AVR_OLD	O
:	O
case	O
EM_AVR	O
:	O
return	O
"Atmel AVR 8-bit microcontroller"	*(char)
;	O
case	O
EM_CYGNUS_FR30	O
:	O
case	O
EM_FR30	O
:	O
return	O
"Fujitsu FR30"	*(char)
;	O
case	O
EM_CYGNUS_D10V	O
:	O
case	O
EM_D10V	O
:	O
return	O
"d10v"	*(char)
;	O
case	O
EM_CYGNUS_D30V	O
:	O
case	O
EM_D30V	O
:	O
return	O
"d30v"	*(char)
;	O
case	O
EM_CYGNUS_V850	O
:	O
case	O
EM_V850	O
:	O
return	O
"Renesas V850"	*(char)
;	O
case	O
EM_CYGNUS_M32R	O
:	O
case	O
EM_M32R	O
:	O
return	O
"Renesas M32R (formerly Mitsubishi M32r)"	*(char)
;	O
case	O
EM_CYGNUS_MN10300	O
:	O
case	O
EM_MN10300	O
:	O
return	O
"mn10300"	*(char)
;	O
case	O
EM_CYGNUS_MN10200	O
:	O
case	O
EM_MN10200	O
:	O
return	O
"mn10200"	*(char)
;	O
case	O
EM_PJ	O
:	O
return	O
"picoJava"	*(char)
;	O
case	O
EM_OR1K	O
:	O
return	O
"OpenRISC 1000"	*(char)
;	O
case	O
EM_ARC_COMPACT	O
:	O
return	O
"ARCompact"	*(char)
;	O
case	O
EM_XTENSA_OLD	O
:	O
case	O
EM_XTENSA	O
:	O
return	O
"Tensilica Xtensa Processor"	*(char)
;	O
case	O
EM_VIDEOCORE	O
:	O
return	O
"Alphamosaic VideoCore processor"	*(char)
;	O
case	O
EM_TMM_GPP	O
:	O
return	O
"Thompson Multimedia General Purpose Processor"	*(char)
;	O
case	O
EM_NS32K	O
:	O
return	O
"National Semiconductor 32000 series"	*(char)
;	O
case	O
EM_TPC	O
:	O
return	O
"Tenor Network TPC processor"	*(char)
;	O
case	O
EM_SNP1K	O
:	O
return	O
"Trebia SNP 1000 processor"	*(char)
;	O
case	O
EM_ST200	O
:	O
return	O
"STMicroelectronics ST200 microcontroller"	*(char)
;	O
case	O
EM_IP2K_OLD	O
:	O
case	O
EM_IP2K	O
:	O
return	O
"Ubicom IP2xxx 8-bit microcontrollers"	*(char)
;	O
case	O
EM_MAX	O
:	O
return	O
"MAX Processor"	*(char)
;	O
case	O
EM_CR	O
:	O
return	O
"National Semiconductor CompactRISC"	*(char)
;	O
case	O
EM_F2MC16	O
:	O
return	O
"Fujitsu F2MC16"	*(char)
;	O
case	O
EM_MSP430	O
:	O
return	O
"Texas Instruments msp430 microcontroller"	*(char)
;	O
case	O
EM_BLACKFIN	O
:	O
return	O
"Analog Devices Blackfin"	*(char)
;	O
case	O
EM_SE_C33	O
:	O
return	O
"S1C33 Family of Seiko Epson processors"	*(char)
;	O
case	O
EM_SEP	O
:	O
return	O
"Sharp embedded microprocessor"	*(char)
;	O
case	O
EM_ARCA	O
:	O
return	O
"Arca RISC microprocessor"	*(char)
;	O
case	O
EM_UNICORE	O
:	O
return	O
"Unicore"	*(char)
;	O
case	O
EM_EXCESS	O
:	O
return	O
"eXcess 16/32/64-bit configurable embedded CPU"	*(char)
;	O
case	O
EM_DXP	O
:	O
return	O
"Icera Semiconductor Inc. Deep Execution Processor"	*(char)
;	O
case	O
EM_ALTERA_NIOS2	O
:	O
return	O
"Altera Nios II"	*(char)
;	O
case	O
EM_CRX	O
:	O
return	O
"National Semiconductor CRX microprocessor"	*(char)
;	O
case	O
EM_XGATE	O
:	O
return	O
"Motorola XGATE embedded processor"	*(char)
;	O
case	O
EM_C166	O
:	O
case	O
EM_XC16X	O
:	O
return	O
"Infineon Technologies xc16x"	*(char)
;	O
case	O
EM_M16C	O
:	O
return	O
"Renesas M16C series microprocessors"	*(char)
;	O
case	O
EM_DSPIC30F	O
:	O
return	O
"Microchip Technology dsPIC30F Digital Signal Controller"	*(char)
;	O
case	O
EM_CE	O
:	O
return	O
"Freescale Communication Engine RISC core"	*(char)
;	O
case	O
EM_M32C	O
:	O
return	O
"Renesas M32c"	*(char)
;	O
case	O
EM_TSK3000	O
:	O
return	O
"Altium TSK3000 core"	*(char)
;	O
case	O
EM_RS08	O
:	O
return	O
"Freescale RS08 embedded processor"	*(char)
;	O
case	O
EM_ECOG2	O
:	O
return	O
"Cyan Technology eCOG2 microprocessor"	*(char)
;	O
case	O
EM_SCORE	O
:	O
return	O
"SUNPLUS S+Core"	*(char)
;	O
case	O
EM_DSP24	O
:	O
return	O
"New Japan Radio (NJR) 24-bit DSP Processor"	*(char)
;	O
case	O
EM_VIDEOCORE3	O
:	O
return	O
"Broadcom VideoCore III processor"	*(char)
;	O
case	O
EM_LATTICEMICO32	O
:	O
return	O
"Lattice Mico32"	*(char)
;	O
case	O
EM_SE_C17	O
:	O
return	O
"Seiko Epson C17 family"	*(char)
;	O
case	O
EM_TI_C6000	O
:	O
return	O
"Texas Instruments TMS320C6000 DSP family"	*(char)
;	O
case	O
EM_TI_C2000	O
:	O
return	O
"Texas Instruments TMS320C2000 DSP family"	*(char)
;	O
case	O
EM_TI_C5500	O
:	O
return	O
"Texas Instruments TMS320C55x DSP family"	*(char)
;	O
case	O
EM_TI_PRU	O
:	O
return	O
"TI PRU I/O processor"	*(char)
;	O
case	O
EM_MMDSP_PLUS	O
:	O
return	O
"STMicroelectronics 64bit VLIW Data Signal Processor"	*(char)
;	O
case	O
EM_CYPRESS_M8C	O
:	O
return	O
"Cypress M8C microprocessor"	*(char)
;	O
case	O
EM_R32C	O
:	O
return	O
"Renesas R32C series microprocessors"	*(char)
;	O
case	O
EM_TRIMEDIA	O
:	O
return	O
"NXP Semiconductors TriMedia architecture family"	*(char)
;	O
case	O
EM_QDSP6	O
:	O
return	O
"QUALCOMM DSP6 Processor"	*(char)
;	O
case	O
EM_8051	O
:	O
return	O
"Intel 8051 and variants"	*(char)
;	O
case	O
EM_STXP7X	O
:	O
return	O
"STMicroelectronics STxP7x family"	*(char)
;	O
case	O
EM_NDS32	O
:	O
return	O
"Andes Technology compact code size embedded RISC processor family"	*(char)
;	O
case	O
EM_ECOG1X	O
:	O
return	O
"Cyan Technology eCOG1X family"	*(char)
;	O
case	O
EM_MAXQ30	O
:	O
return	O
"Dallas Semiconductor MAXQ30 Core microcontrollers"	*(char)
;	O
case	O
EM_XIMO16	O
:	O
return	O
"New Japan Radio (NJR) 16-bit DSP Processor"	*(char)
;	O
case	O
EM_MANIK	O
:	O
return	O
"M2000 Reconfigurable RISC Microprocessor"	*(char)
;	O
case	O
EM_CRAYNV2	O
:	O
return	O
"Cray Inc. NV2 vector architecture"	*(char)
;	O
case	O
EM_RX	O
:	O
return	O
"Renesas RX"	*(char)
;	O
case	O
EM_METAG	O
:	O
return	O
"Imagination Technologies Meta processor architecture"	*(char)
;	O
case	O
EM_MCST_ELBRUS	O
:	O
return	O
"MCST Elbrus general purpose hardware architecture"	*(char)
;	O
case	O
EM_ECOG16	O
:	O
return	O
"Cyan Technology eCOG16 family"	*(char)
;	O
case	O
EM_CR16	O
:	O
case	O
EM_MICROBLAZE	O
:	O
case	O
EM_MICROBLAZE_OLD	O
:	O
return	O
"Xilinx MicroBlaze"	*(char)
;	O
case	O
EM_ETPU	O
:	O
return	O
"Freescale Extended Time Processing Unit"	*(char)
;	O
case	O
EM_SLE9X	O
:	O
return	O
"Infineon Technologies SLE9X core"	*(char)
;	O
case	O
EM_L1OM	O
:	O
return	O
"Intel L1OM"	*(char)
;	O
case	O
EM_K1OM	O
:	O
return	O
"Intel K1OM"	*(char)
;	O
case	O
EM_INTEL182	O
:	O
return	O
"Intel (reserved)"	*(char)
;	O
case	O
EM_AARCH64	O
:	O
return	O
"AArch64"	*(char)
;	O
case	O
EM_ARM184	O
:	O
return	O
"ARM (reserved)"	*(char)
;	O
case	O
EM_AVR32	O
:	O
return	O
"Atmel Corporation 32-bit microprocessor"	*(char)
;	O
case	O
EM_STM8	O
:	O
return	O
"STMicroeletronics STM8 8-bit microcontroller"	*(char)
;	O
case	O
EM_TILE64	O
:	O
return	O
"Tilera TILE64 multicore architecture family"	*(char)
;	O
case	O
EM_TILEPRO	O
:	O
return	O
"Tilera TILEPro multicore architecture family"	*(char)
;	O
case	O
EM_CUDA	O
:	O
return	O
"NVIDIA CUDA architecture"	*(char)
;	O
case	O
EM_TILEGX	O
:	O
return	O
"Tilera TILE-Gx multicore architecture family"	*(char)
;	O
case	O
EM_CLOUDSHIELD	O
:	O
return	O
"CloudShield architecture family"	*(char)
;	O
case	O
EM_COREA_1ST	O
:	O
return	O
"KIPO-KAIST Core-A 1st generation processor family"	*(char)
;	O
case	O
EM_COREA_2ND	O
:	O
return	O
"KIPO-KAIST Core-A 2nd generation processor family"	*(char)
;	O
case	O
EM_ARC_COMPACT2	O
:	O
return	O
"ARCv2"	*(char)
;	O
case	O
EM_OPEN8	O
:	O
return	O
"Open8 8-bit RISC soft processor core"	*(char)
;	O
case	O
EM_RL78	O
:	O
return	O
"Renesas RL78"	*(char)
;	O
case	O
EM_VIDEOCORE5	O
:	O
return	O
"Broadcom VideoCore V processor"	*(char)
;	O
case	O
EM_78K0R	O
:	O
return	O
"Renesas 78K0R"	*(char)
;	O
case	O
EM_56800EX	O
:	O
return	O
"Freescale 56800EX Digital Signal Controller (DSC)"	*(char)
;	O
case	O
EM_BA1	O
:	O
return	O
"Beyond BA1 CPU architecture"	*(char)
;	O
case	O
EM_BA2	O
:	O
return	O
"Beyond BA2 CPU architecture"	*(char)
;	O
case	O
EM_XCORE	O
:	O
return	O
"XMOS xCORE processor family"	*(char)
;	O
case	O
EM_MCHP_PIC	O
:	O
return	O
"Microchip 8-bit PIC(r) family"	*(char)
;	O
case	O
EM_KM32	O
:	O
return	O
"KM211 KM32 32-bit processor"	*(char)
;	O
case	O
EM_KMX32	O
:	O
return	O
"KM211 KMX32 32-bit processor"	*(char)
;	O
case	O
EM_KMX16	O
:	O
return	O
"KM211 KMX16 16-bit processor"	*(char)
;	O
case	O
EM_KMX8	O
:	O
return	O
"KM211 KMX8 8-bit processor"	*(char)
;	O
case	O
EM_KVARC	O
:	O
return	O
"KM211 KVARC processor"	*(char)
;	O
case	O
EM_CDP	O
:	O
return	O
"Paneve CDP architecture family"	*(char)
;	O
case	O
EM_COGE	O
:	O
return	O
"Cognitive Smart Memory Processor"	*(char)
;	O
case	O
EM_COOL	O
:	O
return	O
"Bluechip Systems CoolEngine"	*(char)
;	O
case	O
EM_NORC	O
:	O
return	O
"Nanoradio Optimized RISC"	*(char)
;	O
case	O
EM_CSR_KALIMBA	O
:	O
return	O
"CSR Kalimba architecture family"	*(char)
;	O
case	O
EM_Z80	O
:	O
return	O
"Zilog Z80"	*(char)
;	O
case	O
EM_VISIUM	O
:	O
return	O
"CDS VISIUMcore processor"	*(char)
;	O
case	O
EM_FT32	O
:	O
return	O
"FTDI Chip FT32"	*(char)
;	O
case	O
EM_MOXIE	O
:	O
return	O
"Moxie"	*(char)
;	O
case	O
EM_AMDGPU	O
:	O
return	O
"AMD GPU"	*(char)
;	O
case	O
EM_RISCV	O
:	O
return	O
"RISC-V"	*(char)
;	O
case	O
EM_LANAI	O
:	O
return	O
"Lanai 32-bit processor"	*(char)
;	O
case	O
EM_BPF	O
:	O
return	O
"Linux BPF"	*(char)
;	O
case	O
EM_NFP	O
:	O
return	O
"Netronome Flow Processor"	*(char)
;	O
case	O
EM_MT	O
:	O
return	O
"Morpho Techologies MT processor"	*(char)
;	O
case	O
EM_ALPHA	O
:	O
return	O
"Alpha"	*(char)
;	O
case	O
EM_WEBASSEMBLY	O
:	O
return	O
"Web Assembly"	*(char)
;	O
case	O
EM_DLX	O
:	O
return	O
"OpenDLX"	*(char)
;	O
case	O
EM_XSTORMY16	O
:	O
return	O
"Sanyo XStormy16 CPU core"	*(char)
;	O
case	O
EM_IQ2000	O
:	O
return	O
"Vitesse IQ2000"	*(char)
;	O
case	O
EM_M32C_OLD	O
:	O
case	O
EM_NIOS32	O
:	O
return	O
"Altera Nios"	*(char)
;	O
case	O
EM_CYGNUS_MEP	O
:	O
return	O
"Toshiba MeP Media Engine"	*(char)
;	O
case	O
EM_ADAPTEVA_EPIPHANY	O
:	O
return	O
"Adapteva EPIPHANY"	*(char)
;	O
case	O
EM_CYGNUS_FRV	O
:	O
return	O
"Fujitsu FR-V"	*(char)
;	O
case	O
EM_S12Z	O
:	O
return	O
"Freescale S12Z"	*(char)
;	O
case	O
EM_CSKY	O
:	O
return	O
"C-SKY"	*(char)
;	O
default	O
:	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<unknown>: 0x%x"	*(char)
)	O
,	O
e_machine	O
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
void	O
decode_ARC_machine_flags	O
(	O
unsigned	O
e_flags	O
,	O
unsigned	O
e_machine	O
,	O
char	O
buf	*(void)
[	O
]	O
)	O
{	O
switch	O
(	O
e_flags	O
&	O
EF_ARC_MACH_MSK	O
)	O
{	O
case	O
EF_ARC_CPU_ARCV2EM	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", ARC EM"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARC_CPU_ARCV2HS	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", ARC HS"	*(char)
)	O
;	O
break	O
;	O
case	O
E_ARC_MACH_ARC600	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", ARC600"	*(char)
)	O
;	O
break	O
;	O
case	O
E_ARC_MACH_ARC601	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", ARC601"	*(char)
)	O
;	O
break	O
;	O
case	O
E_ARC_MACH_ARC700	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", ARC700"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
e_machine	O
==	O
EM_ARC_COMPACT	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", Unknown ARCompact"	*(char)
)	O
;	O
else	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", Unknown ARC"	*(char)
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
e_flags	O
&	O
EF_ARC_OSABI_MSK	O
)	O
{	O
case	O
E_ARC_OSABI_ORIG	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", (ABI:legacy)"	*(char)
)	O
;	O
break	O
;	O
case	O
E_ARC_OSABI_V2	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", (ABI:v2)"	*(char)
)	O
;	O
break	O
;	O
case	O
E_ARC_OSABI_V3	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", v3 no-legacy-syscalls ABI"	*(char)
)	O
;	O
break	O
;	O
case	O
E_ARC_OSABI_V4	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", v4 ABI"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", unrecognised ARC OSABI flag"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
decode_ARM_machine_flags	O
(	O
unsigned	O
e_flags	O
,	O
char	O
buf	*(void)
[	O
]	O
)	O
{	O
unsigned	O
eabi	O
;	O
bfd_boolean	int
unknown	O
=	O
FALSE	O
;	O
eabi	O
=	O
EF_ARM_EABI_VERSION	O
(	O
e_flags	O
)	O
;	O
e_flags	O
&=	O
~	O
EF_ARM_EABIMASK	O
;	O
if	O
(	O
e_flags	O
&	O
EF_ARM_RELEXEC	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", relocatable executable"	*(char)
)	O
;	O
e_flags	O
&=	O
~	O
EF_ARM_RELEXEC	O
;	O
}	O
if	O
(	O
e_flags	O
&	O
EF_ARM_PIC	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", position independent"	*(char)
)	O
;	O
e_flags	O
&=	O
~	O
EF_ARM_PIC	O
;	O
}	O
switch	O
(	O
eabi	O
)	O
{	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", <unrecognized EABI>"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
)	O
unknown	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
EF_ARM_EABI_VER1	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", Version1 EABI"	*(char)
)	O
;	O
while	O
(	O
e_flags	O
)	O
{	O
unsigned	O
flag	O
;	O
flag	O
=	O
e_flags	O
&	O
-	O
e_flags	O
;	O
e_flags	O
&=	O
~	O
flag	O
;	O
switch	O
(	O
flag	O
)	O
{	O
case	O
EF_ARM_SYMSARESORTED	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sorted symbol tables"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
unknown	O
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
EF_ARM_EABI_VER2	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", Version2 EABI"	*(char)
)	O
;	O
while	O
(	O
e_flags	O
)	O
{	O
unsigned	O
flag	O
;	O
flag	O
=	O
e_flags	O
&	O
-	O
e_flags	O
;	O
e_flags	O
&=	O
~	O
flag	O
;	O
switch	O
(	O
flag	O
)	O
{	O
case	O
EF_ARM_SYMSARESORTED	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sorted symbol tables"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_DYNSYMSUSESEGIDX	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", dynamic symbols use segment index"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_MAPSYMSFIRST	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mapping symbols precede others"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
unknown	O
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
EF_ARM_EABI_VER3	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", Version3 EABI"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_EABI_VER4	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", Version4 EABI"	*(char)
)	O
;	O
while	O
(	O
e_flags	O
)	O
{	O
unsigned	O
flag	O
;	O
flag	O
=	O
e_flags	O
&	O
-	O
e_flags	O
;	O
e_flags	O
&=	O
~	O
flag	O
;	O
switch	O
(	O
flag	O
)	O
{	O
case	O
EF_ARM_BE8	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", BE8"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_LE8	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", LE8"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
unknown	O
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
EF_ARM_EABI_VER5	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", Version5 EABI"	*(char)
)	O
;	O
while	O
(	O
e_flags	O
)	O
{	O
unsigned	O
flag	O
;	O
flag	O
=	O
e_flags	O
&	O
-	O
e_flags	O
;	O
e_flags	O
&=	O
~	O
flag	O
;	O
switch	O
(	O
flag	O
)	O
{	O
case	O
EF_ARM_BE8	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", BE8"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_LE8	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", LE8"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_ABI_FLOAT_SOFT	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", soft-float ABI"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_ABI_FLOAT_HARD	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", hard-float ABI"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
unknown	O
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
EF_ARM_EABI_UNKNOWN	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", GNU EABI"	*(char)
)	O
;	O
while	O
(	O
e_flags	O
)	O
{	O
unsigned	O
flag	O
;	O
flag	O
=	O
e_flags	O
&	O
-	O
e_flags	O
;	O
e_flags	O
&=	O
~	O
flag	O
;	O
switch	O
(	O
flag	O
)	O
{	O
case	O
EF_ARM_INTERWORK	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", interworking enabled"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_APCS_26	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", uses APCS/26"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_APCS_FLOAT	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", uses APCS/float"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_PIC	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", position independent"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_ALIGN8	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 8 bit structure alignment"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_NEW_ABI	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", uses new ABI"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_OLD_ABI	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", uses old ABI"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_SOFT_FLOAT	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", software FP"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_VFP_FLOAT	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", VFP"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_ARM_MAVERICK_FLOAT	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", Maverick FP"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
unknown	O
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
unknown	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
", <unknown>"	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
decode_AVR_machine_flags	O
(	O
unsigned	O
e_flags	O
,	O
char	O
buf	*(void)
[	O
]	O
,	O
size_t	long
size	int
)	O
{	O
--	O
size	int
;	O
switch	O
(	O
e_flags	O
&	O
EF_AVR_MACH	O
)	O
{	O
case	O
E_AVR_MACH_AVR1	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:1"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR2	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:2"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR25	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:25"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR3	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:3"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR31	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:31"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR35	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:35"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR4	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:4"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR5	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:5"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR51	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:51"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVR6	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:6"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_AVRTINY	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:100"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA1	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:101"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA2	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:102"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA3	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:103"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA4	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:104"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA5	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:105"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA6	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:106"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
case	O
E_AVR_MACH_XMEGA7	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:107"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
default	O
:	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", avr:<unknown>"	*(char)
,	O
size	int
)	O
;	O
break	O
;	O
}	O
size	int
-=	O
strlen	(*(char))->(long)
(	O
buf	*(void)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_AVR_LINKRELAX_PREPARED	O
)	O
strncat	(*(char),*(char),long)->(*(char))
(	O
buf	*(void)
,	O
", link-relax"	*(char)
,	O
size	int
)	O
;	O
}	O
static	O
void	O
decode_NDS32_machine_flags	O
(	O
unsigned	O
e_flags	O
,	O
char	O
buf	*(void)
[	O
]	O
,	O
size_t	long
size	int
)	O
{	O
unsigned	O
abi	O
;	O
unsigned	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
unsigned	O
config	O
;	O
unsigned	O
version	*(char)
;	O
bfd_boolean	int
has_fpu	O
=	O
FALSE	O
;	O
unsigned	O
int	O
r	O
=	O
0	int
;	O
static	O
const	O
char	O
*	O
ABI_STRINGS	O
[	O
]	O
=	O
{	O
"ABI v0"	*(char)
,	O
"ABI v1"	*(char)
,	O
"ABI v2"	*(char)
,	O
"ABI v2fp"	*(char)
,	O
"AABI"	*(char)
,	O
"ABI2 FP+"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
VER_STRINGS	O
[	O
]	O
=	O
{	O
"Andes ELF V1.3 or older"	*(char)
,	O
"Andes ELF V1.3.1"	*(char)
,	O
"Andes ELF V1.4"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
ARCH_STRINGS	O
[	O
]	O
=	O
{	O
""	*(char)
,	O
"Andes Star v1.0"	*(char)
,	O
"Andes Star v2.0"	*(char)
,	O
"Andes Star v3.0"	*(char)
,	O
"Andes Star v3.0m"	*(char)
}	O
;	O
abi	O
=	O
EF_NDS_ABI	O
&	O
e_flags	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
=	O
EF_NDS_ARCH	O
&	O
e_flags	O
;	O
config	O
=	O
EF_NDS_INST	O
&	O
e_flags	O
;	O
version	*(char)
=	O
EF_NDS32_ELF_VERSION	O
&	O
e_flags	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
buf	*(void)
,	O
0	int
,	O
size	int
)	O
;	O
switch	O
(	O
abi	O
)	O
{	O
case	O
E_NDS_ABI_V0	O
:	O
case	O
E_NDS_ABI_V1	O
:	O
case	O
E_NDS_ABI_V2	O
:	O
case	O
E_NDS_ABI_V2FP	O
:	O
case	O
E_NDS_ABI_AABI	O
:	O
case	O
E_NDS_ABI_V2FP_PLUS	O
:	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", %s"	*(char)
,	O
ABI_STRINGS	O
[	O
abi	O
>>	O
EF_NDS_ABI_SHIFT	O
]	O
)	O
;	O
break	O
;	O
default	O
:	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", <unrecognized ABI>"	*(char)
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
version	*(char)
)	O
{	O
case	O
E_NDS32_ELF_VER_1_2	O
:	O
case	O
E_NDS32_ELF_VER_1_3	O
:	O
case	O
E_NDS32_ELF_VER_1_4	O
:	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", %s"	*(char)
,	O
VER_STRINGS	O
[	O
version	*(char)
>>	O
EF_NDS32_ELF_VERSION_SHIFT	O
]	O
)	O
;	O
break	O
;	O
default	O
:	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", <unrecognized ELF version number>"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
E_NDS_ABI_V0	O
==	O
abi	O
)	O
{	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", Andes Star v1.0, N1213HC, MAC, PERF1"	*(char)
)	O
;	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
E_NDS_ARCH_STAR_V1_0	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", 16b"	*(char)
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
{	O
case	O
E_NDS_ARCH_STAR_V1_0	O
:	O
case	O
E_NDS_ARCH_STAR_V2_0	O
:	O
case	O
E_NDS_ARCH_STAR_V3_0	O
:	O
case	O
E_NDS_ARCH_STAR_V3_M	O
:	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", %s"	*(char)
,	O
ARCH_STRINGS	O
[	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
>>	O
EF_NDS_ARCH_SHIFT	O
]	O
)	O
;	O
break	O
;	O
default	O
:	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", <unrecognized architecture>"	*(char)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
E_NDS_ARCH_STAR_V1_0	O
)	O
{	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_MFUSR_PC_INST	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", MFUSR_PC"	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
config	O
&	O
E_NDS32_HAS_NO_MAC_INST	O
)	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", MAC"	*(char)
)	O
;	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_DIV_INST	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", DIV"	*(char)
)	O
;	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_16BIT_INST	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", 16b"	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_MFUSR_PC_INST	O
)	O
{	O
if	O
(	O
version	*(char)
<=	O
E_NDS32_ELF_VER_1_3	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", [B8]"	*(char)
)	O
;	O
else	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", EX9"	*(char)
)	O
;	O
}	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_MAC_DX_INST	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", MAC_DX"	*(char)
)	O
;	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_DIV_DX_INST	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", DIV_DX"	*(char)
)	O
;	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_16BIT_INST	O
)	O
{	O
if	O
(	O
version	*(char)
<=	O
E_NDS32_ELF_VER_1_3	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", 16b"	*(char)
)	O
;	O
else	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", IFC"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_EXT_INST	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", PERF1"	*(char)
)	O
;	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_EXT2_INST	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", PERF2"	*(char)
)	O
;	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_FPU_INST	O
)	O
{	O
has_fpu	O
=	O
TRUE	int
;	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", FPU_SP"	*(char)
)	O
;	O
}	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_FPU_DP_INST	O
)	O
{	O
has_fpu	O
=	O
TRUE	int
;	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", FPU_DP"	*(char)
)	O
;	O
}	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_FPU_MAC_INST	O
)	O
{	O
has_fpu	O
=	O
TRUE	int
;	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", FPU_MAC"	*(char)
)	O
;	O
}	O
if	O
(	O
has_fpu	O
)	O
{	O
switch	O
(	O
(	O
config	O
&	O
E_NDS32_FPU_REG_CONF	O
)	O
>>	O
E_NDS32_FPU_REG_CONF_SHIFT	O
)	O
{	O
case	O
E_NDS32_FPU_REG_8SP_4DP	O
:	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", FPU_REG:8/4"	*(char)
)	O
;	O
break	O
;	O
case	O
E_NDS32_FPU_REG_16SP_8DP	O
:	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", FPU_REG:16/8"	*(char)
)	O
;	O
break	O
;	O
case	O
E_NDS32_FPU_REG_32SP_16DP	O
:	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", FPU_REG:32/16"	*(char)
)	O
;	O
break	O
;	O
case	O
E_NDS32_FPU_REG_32SP_32DP	O
:	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", FPU_REG:32/32"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_AUDIO_INST	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", AUDIO"	*(char)
)	O
;	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_STRING_INST	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", STR"	*(char)
)	O
;	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_REDUCED_REGS	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", 16REG"	*(char)
)	O
;	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_VIDEO_INST	O
)	O
{	O
if	O
(	O
version	*(char)
<=	O
E_NDS32_ELF_VER_1_3	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", VIDEO"	*(char)
)	O
;	O
else	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", SATURATION"	*(char)
)	O
;	O
}	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_ENCRIPT_INST	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", ENCRP"	*(char)
)	O
;	O
if	O
(	O
config	O
&	O
E_NDS32_HAS_L2C_INST	O
)	O
r	O
+=	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
+	O
r	O
,	O
size	int
-	O
r	O
,	O
", L2C"	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
get_machine_flags	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
e_flags	O
,	O
unsigned	O
e_machine	O
)	O
{	O
static	O
char	O
buf	*(void)
[	O
1024	int
]	O
;	O
buf	*(void)
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
e_flags	O
)	O
{	O
switch	O
(	O
e_machine	O
)	O
{	O
default	O
:	O
break	O
;	O
case	O
EM_ARC_COMPACT2	O
:	O
case	O
EM_ARC_COMPACT	O
:	O
decode_ARC_machine_flags	O
(	O
e_flags	O
,	O
e_machine	O
,	O
buf	*(void)
)	O
;	O
break	O
;	O
case	O
EM_ARM	O
:	O
decode_ARM_machine_flags	O
(	O
e_flags	O
,	O
buf	*(void)
)	O
;	O
break	O
;	O
case	O
EM_AVR	O
:	O
decode_AVR_machine_flags	O
(	O
e_flags	O
,	O
buf	*(void)
,	O
sizeof	O
buf	*(void)
)	O
;	O
break	O
;	O
case	O
EM_BLACKFIN	O
:	O
if	O
(	O
e_flags	O
&	O
EF_BFIN_PIC	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", PIC"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_BFIN_FDPIC	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", FDPIC"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_BFIN_CODE_IN_L1	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", code in L1"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_BFIN_DATA_IN_L1	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", data in L1"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_CYGNUS_FRV	O
:	O
switch	O
(	O
e_flags	O
&	O
EF_FRV_CPU_MASK	O
)	O
{	O
case	O
EF_FRV_CPU_GENERIC	O
:	O
break	O
;	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", fr???"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR300	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", fr300"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR400	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", fr400"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR405	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", fr405"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR450	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", fr450"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR500	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", fr500"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_FR550	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", fr550"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_SIMPLE	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", simple"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_FRV_CPU_TOMCAT	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", tomcat"	*(char)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_68K	O
:	O
if	O
(	O
(	O
e_flags	O
&	O
EF_M68K_ARCH_MASK	O
)	O
==	O
EF_M68K_M68000	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", m68000"	*(char)
)	O
;	O
else	O
if	O
(	O
(	O
e_flags	O
&	O
EF_M68K_ARCH_MASK	O
)	O
==	O
EF_M68K_CPU32	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", cpu32"	*(char)
)	O
;	O
else	O
if	O
(	O
(	O
e_flags	O
&	O
EF_M68K_ARCH_MASK	O
)	O
==	O
EF_M68K_FIDO	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", fido_a"	*(char)
)	O
;	O
else	O
{	O
char	O
const	O
*	O
isa	O
=	O
_	O
(	O
"unknown"	*(char)
)	O
;	O
char	O
const	O
*	O
mac	O
=	O
_	O
(	O
"unknown mac"	*(char)
)	O
;	O
char	O
const	O
*	O
additional	O
=	O
NULL	O
;	O
switch	O
(	O
e_flags	O
&	O
EF_M68K_CF_ISA_MASK	O
)	O
{	O
case	O
EF_M68K_CF_ISA_A_NODIV	O
:	O
isa	O
=	O
"A"	*(char)
;	O
additional	O
=	O
", nodiv"	*(char)
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_A	O
:	O
isa	O
=	O
"A"	*(char)
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_A_PLUS	O
:	O
isa	O
=	O
"A+"	*(char)
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_B_NOUSP	O
:	O
isa	O
=	O
"B"	*(char)
;	O
additional	O
=	O
", nousp"	*(char)
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_B	O
:	O
isa	O
=	O
"B"	*(char)
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_C	O
:	O
isa	O
=	O
"C"	*(char)
;	O
break	O
;	O
case	O
EF_M68K_CF_ISA_C_NODIV	O
:	O
isa	O
=	O
"C"	*(char)
;	O
additional	O
=	O
", nodiv"	*(char)
;	O
break	O
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", cf, isa "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
isa	O
)	O
;	O
if	O
(	O
additional	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
additional	O
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_M68K_CF_FLOAT	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", float"	*(char)
)	O
;	O
switch	O
(	O
e_flags	O
&	O
EF_M68K_CF_MAC_MASK	O
)	O
{	O
case	O
0	int
:	O
mac	O
=	O
NULL	O
;	O
break	O
;	O
case	O
EF_M68K_CF_MAC	O
:	O
mac	O
=	O
"mac"	*(char)
;	O
break	O
;	O
case	O
EF_M68K_CF_EMAC	O
:	O
mac	O
=	O
"emac"	*(char)
;	O
break	O
;	O
case	O
EF_M68K_CF_EMAC_B	O
:	O
mac	O
=	O
"emac_b"	*(char)
;	O
break	O
;	O
}	O
if	O
(	O
mac	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
mac	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
EM_CYGNUS_MEP	O
:	O
switch	O
(	O
e_flags	O
&	O
EF_MEP_CPU_MASK	O
)	O
{	O
case	O
EF_MEP_CPU_MEP	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", generic MeP"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_MEP_CPU_C2	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", MeP C2"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_MEP_CPU_C3	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", MeP C3"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_MEP_CPU_C4	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", MeP C4"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_MEP_CPU_C5	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", MeP C5"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_MEP_CPU_H1	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", MeP H1"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
", <unknown MeP cpu type>"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
e_flags	O
&	O
EF_MEP_COP_MASK	O
)	O
{	O
case	O
EF_MEP_COP_NONE	O
:	O
break	O
;	O
case	O
EF_MEP_COP_AVC	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", AVC coprocessor"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_MEP_COP_AVC2	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", AVC2 coprocessor"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_MEP_COP_FMAX	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", FMAX coprocessor"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_MEP_COP_IVC2	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", IVC2 coprocessor"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
"<unknown MeP copro type>"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
e_flags	O
&	O
EF_MEP_LIBRARY	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", Built for Library"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_MEP_INDEX_MASK	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
+	O
strlen	(*(char))->(long)
(	O
buf	*(void)
)	O
,	O
", Configuration Index: %#x"	*(char)
,	O
e_flags	O
&	O
EF_MEP_INDEX_MASK	O
)	O
;	O
if	O
(	O
e_flags	O
&	O
~	O
EF_MEP_ALL_FLAGS	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(void)
+	O
strlen	(*(char))->(long)
(	O
buf	*(void)
)	O
,	O
_	O
(	O
", unknown flags bits: %#x"	*(char)
)	O
,	O
e_flags	O
&	O
~	O
EF_MEP_ALL_FLAGS	O
)	O
;	O
break	O
;	O
case	O
EM_PPC	O
:	O
if	O
(	O
e_flags	O
&	O
EF_PPC_EMB	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", emb"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_PPC_RELOCATABLE	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
", relocatable"	*(char)
)	O
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_PPC_RELOCATABLE_LIB	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
", relocatable-lib"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
EM_PPC64	O
:	O
if	O
(	O
e_flags	O
&	O
EF_PPC64_ABI	O
)	O
{	O
char	O
abi	O
[	O
]	O
=	O
", abiv0"	*(char)
;	O
abi	O
[	O
6	int
]	O
+=	O
e_flags	O
&	O
EF_PPC64_ABI	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
abi	O
)	O
;	O
}	O
break	O
;	O
case	O
EM_V800	O
:	O
if	O
(	O
(	O
e_flags	O
&	O
EF_RH850_ABI	O
)	O
==	O
EF_RH850_ABI	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", RH850 ABI"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_V800_850E3	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", V3 architecture"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
(	O
EF_RH850_FPU_DOUBLE	O
|	O
EF_RH850_FPU_SINGLE	O
)	O
)	O
==	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", FPU not used"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
(	O
EF_RH850_REGMODE22	O
|	O
EF_RH850_REGMODE32	O
)	O
)	O
==	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", regmode: COMMON"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
(	O
EF_RH850_GP_FIX	O
|	O
EF_RH850_GP_NOFIX	O
)	O
)	O
==	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r4 not used"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
(	O
EF_RH850_EP_FIX	O
|	O
EF_RH850_EP_NOFIX	O
)	O
)	O
==	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r30 not used"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
(	O
EF_RH850_TP_FIX	O
|	O
EF_RH850_TP_NOFIX	O
)	O
)	O
==	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r5 not used"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
(	O
EF_RH850_REG2_RESERVE	O
|	O
EF_RH850_REG2_NORESERVE	O
)	O
)	O
==	O
0	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r2 not used"	*(char)
)	O
;	O
for	O
(	O
e_flags	O
&=	O
0xFFFF	int
;	O
e_flags	O
;	O
e_flags	O
&=	O
~	O
(	O
e_flags	O
&	O
-	O
e_flags	O
)	O
)	O
{	O
switch	O
(	O
e_flags	O
&	O
-	O
e_flags	O
)	O
{	O
case	O
EF_RH850_FPU_DOUBLE	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", double precision FPU"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RH850_FPU_SINGLE	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", single precision FPU"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RH850_REGMODE22	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", regmode:22"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RH850_REGMODE32	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", regmode:23"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RH850_GP_FIX	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r4 fixed"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RH850_GP_NOFIX	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r4 free"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RH850_EP_FIX	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r30 fixed"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RH850_EP_NOFIX	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r30 free"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RH850_TP_FIX	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r5 fixed"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RH850_TP_NOFIX	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r5 free"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RH850_REG2_RESERVE	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r2 fixed"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RH850_REG2_NORESERVE	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", r2 free"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
EM_V850	O
:	O
case	O
EM_CYGNUS_V850	O
:	O
switch	O
(	O
e_flags	O
&	O
EF_V850_ARCH	O
)	O
{	O
case	O
E_V850E3V5_ARCH	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", v850e3v5"	*(char)
)	O
;	O
break	O
;	O
case	O
E_V850E2V3_ARCH	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", v850e2v3"	*(char)
)	O
;	O
break	O
;	O
case	O
E_V850E2_ARCH	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", v850e2"	*(char)
)	O
;	O
break	O
;	O
case	O
E_V850E1_ARCH	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", v850e1"	*(char)
)	O
;	O
break	O
;	O
case	O
E_V850E_ARCH	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", v850e"	*(char)
)	O
;	O
break	O
;	O
case	O
E_V850_ARCH	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", v850"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
", unknown v850 architecture variant"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_M32R	O
:	O
case	O
EM_CYGNUS_M32R	O
:	O
if	O
(	O
(	O
e_flags	O
&	O
EF_M32R_ARCH	O
)	O
==	O
E_M32R_ARCH	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", m32r"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_MIPS	O
:	O
case	O
EM_MIPS_RS3_LE	O
:	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_NOREORDER	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", noreorder"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_PIC	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", pic"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_CPIC	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", cpic"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_UCODE	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", ugen_reserved"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_ABI2	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", abi2"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_OPTIONS_FIRST	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", odk first"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_32BITMODE	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 32bitmode"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_NAN2008	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", nan2008"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_FP64	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", fp64"	*(char)
)	O
;	O
switch	O
(	O
(	O
e_flags	O
&	O
EF_MIPS_MACH	O
)	O
)	O
{	O
case	O
E_MIPS_MACH_3900	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 3900"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_4010	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 4010"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_4100	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 4100"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_4111	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 4111"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_4120	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 4120"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_4650	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 4650"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_5400	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 5400"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_5500	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 5500"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_5900	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 5900"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_SB1	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sb1"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_9000	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 9000"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_LS2E	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", loongson-2e"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_LS2F	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", loongson-2f"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_GS464	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", gs464"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_GS464E	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", gs464e"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_GS264E	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", gs264e"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_OCTEON	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", octeon"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_OCTEON2	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", octeon2"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_OCTEON3	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", octeon3"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_XLR	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", xlr"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_MACH_IAMR2	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", interaptiv-mr2"	*(char)
)	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
", unknown CPU"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
(	O
e_flags	O
&	O
EF_MIPS_ABI	O
)	O
)	O
{	O
case	O
E_MIPS_ABI_O32	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", o32"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ABI_O64	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", o64"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ABI_EABI32	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", eabi32"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ABI_EABI64	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", eabi64"	*(char)
)	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
", unknown ABI"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_ARCH_ASE_MDMX	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mdmx"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_ARCH_ASE_M16	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips16"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_MIPS_ARCH_ASE_MICROMIPS	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", micromips"	*(char)
)	O
;	O
switch	O
(	O
(	O
e_flags	O
&	O
EF_MIPS_ARCH	O
)	O
)	O
{	O
case	O
E_MIPS_ARCH_1	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips1"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_2	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips2"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_3	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips3"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_4	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips4"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_5	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips5"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_32	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips32"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_32R2	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips32r2"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_32R6	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips32r6"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_64	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips64"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_64R2	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips64r2"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MIPS_ARCH_64R6	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mips64r6"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
", unknown ISA"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_NDS32	O
:	O
decode_NDS32_machine_flags	O
(	O
e_flags	O
,	O
buf	*(void)
,	O
sizeof	O
buf	*(void)
)	O
;	O
break	O
;	O
case	O
EM_NFP	O
:	O
switch	O
(	O
EF_NFP_MACH	O
(	O
e_flags	O
)	O
)	O
{	O
case	O
E_NFP_MACH_3200	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", NFP-32xx"	*(char)
)	O
;	O
break	O
;	O
case	O
E_NFP_MACH_6000	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", NFP-6xxx"	*(char)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_RISCV	O
:	O
if	O
(	O
e_flags	O
&	O
EF_RISCV_RVC	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", RVC"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_RISCV_RVE	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", RVE"	*(char)
)	O
;	O
switch	O
(	O
e_flags	O
&	O
EF_RISCV_FLOAT_ABI	O
)	O
{	O
case	O
EF_RISCV_FLOAT_ABI_SOFT	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", soft-float ABI"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RISCV_FLOAT_ABI_SINGLE	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", single-float ABI"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RISCV_FLOAT_ABI_DOUBLE	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", double-float ABI"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_RISCV_FLOAT_ABI_QUAD	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", quad-float ABI"	*(char)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_SH	O
:	O
switch	O
(	O
(	O
e_flags	O
&	O
EF_SH_MACH_MASK	O
)	O
)	O
{	O
case	O
EF_SH1	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh1"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH2	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh2"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH3	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh3"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH_DSP	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh-dsp"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH3_DSP	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh3-dsp"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH4AL_DSP	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh4al-dsp"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH3E	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh3e"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH4	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh4"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH5	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh5"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH2E	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh2e"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH4A	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh4a"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH2A	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh2a"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH4_NOFPU	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh4-nofpu"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH4A_NOFPU	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh4a-nofpu"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH2A_NOFPU	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh2a-nofpu"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH3_NOMMU	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh3-nommu"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH4_NOMMU_NOFPU	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh4-nommu-nofpu"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH2A_SH4_NOFPU	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh2a-nofpu-or-sh4-nommu-nofpu"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH2A_SH3_NOFPU	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh2a-nofpu-or-sh3-nommu"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH2A_SH4	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh2a-or-sh4"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_SH2A_SH3E	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", sh2a-or-sh3e"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
", unknown ISA"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
e_flags	O
&	O
EF_SH_PIC	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", pic"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_SH_FDPIC	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", fdpic"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_OR1K	O
:	O
if	O
(	O
e_flags	O
&	O
EF_OR1K_NODELAY	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", no delay"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_SPARCV9	O
:	O
if	O
(	O
e_flags	O
&	O
EF_SPARC_32PLUS	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", v8+"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_SPARC_SUN_US1	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", ultrasparcI"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_SPARC_SUN_US3	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", ultrasparcIII"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_SPARC_HAL_R1	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", halr1"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_SPARC_LEDATA	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", ledata"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
EF_SPARCV9_MM	O
)	O
==	O
EF_SPARCV9_TSO	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", tso"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
EF_SPARCV9_MM	O
)	O
==	O
EF_SPARCV9_PSO	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", pso"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
EF_SPARCV9_MM	O
)	O
==	O
EF_SPARCV9_RMO	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", rmo"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_PARISC	O
:	O
switch	O
(	O
e_flags	O
&	O
EF_PARISC_ARCH	O
)	O
{	O
case	O
EFA_PARISC_1_0	O
:	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", PA-RISC 1.0"	*(char)
)	O
;	O
break	O
;	O
case	O
EFA_PARISC_1_1	O
:	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", PA-RISC 1.1"	*(char)
)	O
;	O
break	O
;	O
case	O
EFA_PARISC_2_0	O
:	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", PA-RISC 2.0"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
e_flags	O
&	O
EF_PARISC_TRAPNIL	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", trapnil"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_PARISC_EXT	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", ext"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_PARISC_LSB	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", lsb"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_PARISC_WIDE	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", wide"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_PARISC_NO_KABP	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", no kabp"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_PARISC_LAZYSWAP	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", lazyswap"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_PJ	O
:	O
case	O
EM_PJ_OLD	O
:	O
if	O
(	O
(	O
e_flags	O
&	O
EF_PICOJAVA_NEWCALLS	O
)	O
==	O
EF_PICOJAVA_NEWCALLS	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", new calling convention"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
EF_PICOJAVA_GNUCALLS	O
)	O
==	O
EF_PICOJAVA_GNUCALLS	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", gnu calling convention"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_IA_64	O
:	O
if	O
(	O
(	O
e_flags	O
&	O
EF_IA_64_ABI64	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 64-bit"	*(char)
)	O
;	O
else	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 32-bit"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
EF_IA_64_REDUCEDFP	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", reduced fp model"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
EF_IA_64_NOFUNCDESC_CONS_GP	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", no function descriptors, constant gp"	*(char)
)	O
;	O
else	O
if	O
(	O
(	O
e_flags	O
&	O
EF_IA_64_CONS_GP	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", constant gp"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
EF_IA_64_ABSOLUTE	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", absolute"	*(char)
)	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_OPENVMS	O
)	O
{	O
if	O
(	O
(	O
e_flags	O
&	O
EF_IA_64_VMS_LINKAGES	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", vms_linkages"	*(char)
)	O
;	O
switch	O
(	O
(	O
e_flags	O
&	O
EF_IA_64_VMS_COMCOD	O
)	O
)	O
{	O
case	O
EF_IA_64_VMS_COMCOD_SUCCESS	O
:	O
break	O
;	O
case	O
EF_IA_64_VMS_COMCOD_WARNING	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", warning"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_IA_64_VMS_COMCOD_ERROR	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", error"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_IA_64_VMS_COMCOD_ABORT	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", abort"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
warn	O
(	O
_	O
(	O
"Unrecognised IA64 VMS Command Code: %x\n"	*(char)
)	O
,	O
e_flags	O
&	O
EF_IA_64_VMS_COMCOD	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", <unknown>"	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
EM_VAX	O
:	O
if	O
(	O
(	O
e_flags	O
&	O
EF_VAX_NONPIC	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", non-PIC"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
EF_VAX_DFLOAT	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", D-Float"	*(char)
)	O
;	O
if	O
(	O
(	O
e_flags	O
&	O
EF_VAX_GFLOAT	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", G-Float"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_VISIUM	O
:	O
if	O
(	O
e_flags	O
&	O
EF_VISIUM_ARCH_MCM	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mcm"	*(char)
)	O
;	O
else	O
if	O
(	O
e_flags	O
&	O
EF_VISIUM_ARCH_MCM24	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", mcm24"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
EF_VISIUM_ARCH_GR6	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", gr6"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_RL78	O
:	O
switch	O
(	O
e_flags	O
&	O
E_FLAG_RL78_CPU_MASK	O
)	O
{	O
case	O
E_FLAG_RL78_ANY_CPU	O
:	O
break	O
;	O
case	O
E_FLAG_RL78_G10	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", G10"	*(char)
)	O
;	O
break	O
;	O
case	O
E_FLAG_RL78_G13	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", G13"	*(char)
)	O
;	O
break	O
;	O
case	O
E_FLAG_RL78_G14	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", G14"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
e_flags	O
&	O
E_FLAG_RL78_64BIT_DOUBLES	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 64-bit doubles"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_RX	O
:	O
if	O
(	O
e_flags	O
&	O
E_FLAG_RX_64BIT_DOUBLES	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", 64-bit doubles"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
E_FLAG_RX_DSP	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", dsp"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
E_FLAG_RX_PID	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", pid"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
E_FLAG_RX_ABI	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", RX ABI"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
E_FLAG_RX_SINSNS_SET	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
e_flags	O
&	O
E_FLAG_RX_SINSNS_YES	O
?	O
", uses String instructions"	*(char)
:	O
", bans String instructions"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
E_FLAG_RX_V2	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", V2"	*(char)
)	O
;	O
if	O
(	O
e_flags	O
&	O
E_FLAG_RX_V3	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", V3"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_S390	O
:	O
if	O
(	O
e_flags	O
&	O
EF_S390_HIGH_GPRS	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", highgprs"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_TI_C6000	O
:	O
if	O
(	O
(	O
e_flags	O
&	O
EF_C6000_REL	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", relocatable module"	*(char)
)	O
;	O
break	O
;	O
case	O
EM_MSP430	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
": architecture variant: "	*(char)
)	O
)	O
;	O
switch	O
(	O
e_flags	O
&	O
EF_MSP430_MACH	O
)	O
{	O
case	O
E_MSP430_MACH_MSP430x11	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x11"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x11x1	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x11x1 "	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x12	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x12"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x13	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x13"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x14	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x14"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x15	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x15"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x16	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x16"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x31	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x31"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x32	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x32"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x33	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x33"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x41	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x41"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x42	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x42"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x43	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x43"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430x44	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430x44"	*(char)
)	O
;	O
break	O
;	O
case	O
E_MSP430_MACH_MSP430X	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
"MSP430X"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
": unknown"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
e_flags	O
&	O
~	O
EF_MSP430_MACH	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
": unknown extra flag bits also present"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
EM_Z80	O
:	O
switch	O
(	O
e_flags	O
&	O
EF_Z80_MACH_MSK	O
)	O
{	O
case	O
EF_Z80_MACH_Z80	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", Z80"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_Z80_MACH_Z180	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", Z180"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_Z80_MACH_R800	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", R800"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_Z80_MACH_EZ80_Z80	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", EZ80"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_Z80_MACH_EZ80_ADL	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", EZ80, ADL"	*(char)
)	O
;	O
break	O
;	O
case	O
EF_Z80_MACH_GBZ80	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
", GBZ80"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(void)
,	O
_	O
(	O
", unknown"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
}	O
return	O
buf	*(void)
;	O
}	O
static	O
const	O
char	O
*	O
get_osabi_name	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
osabi	O
)	O
{	O
static	O
char	O
buff	O
[	O
32	int
]	O
;	O
switch	O
(	O
osabi	O
)	O
{	O
case	O
ELFOSABI_NONE	O
:	O
return	O
"UNIX - System V"	*(char)
;	O
case	O
ELFOSABI_HPUX	O
:	O
return	O
"UNIX - HP-UX"	*(char)
;	O
case	O
ELFOSABI_NETBSD	O
:	O
return	O
"UNIX - NetBSD"	*(char)
;	O
case	O
ELFOSABI_GNU	O
:	O
return	O
"UNIX - GNU"	*(char)
;	O
case	O
ELFOSABI_SOLARIS	O
:	O
return	O
"UNIX - Solaris"	*(char)
;	O
case	O
ELFOSABI_AIX	O
:	O
return	O
"UNIX - AIX"	*(char)
;	O
case	O
ELFOSABI_IRIX	O
:	O
return	O
"UNIX - IRIX"	*(char)
;	O
case	O
ELFOSABI_FREEBSD	O
:	O
return	O
"UNIX - FreeBSD"	*(char)
;	O
case	O
ELFOSABI_TRU64	O
:	O
return	O
"UNIX - TRU64"	*(char)
;	O
case	O
ELFOSABI_MODESTO	O
:	O
return	O
"Novell - Modesto"	*(char)
;	O
case	O
ELFOSABI_OPENBSD	O
:	O
return	O
"UNIX - OpenBSD"	*(char)
;	O
case	O
ELFOSABI_OPENVMS	O
:	O
return	O
"VMS - OpenVMS"	*(char)
;	O
case	O
ELFOSABI_NSK	O
:	O
return	O
"HP - Non-Stop Kernel"	*(char)
;	O
case	O
ELFOSABI_AROS	O
:	O
return	O
"AROS"	*(char)
;	O
case	O
ELFOSABI_FENIXOS	O
:	O
return	O
"FenixOS"	*(char)
;	O
case	O
ELFOSABI_CLOUDABI	O
:	O
return	O
"Nuxi CloudABI"	*(char)
;	O
case	O
ELFOSABI_OPENVOS	O
:	O
return	O
"Stratus Technologies OpenVOS"	*(char)
;	O
default	O
:	O
if	O
(	O
osabi	O
>=	O
64	int
)	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_ARM	O
:	O
switch	O
(	O
osabi	O
)	O
{	O
case	O
ELFOSABI_ARM	O
:	O
return	O
"ARM"	*(char)
;	O
case	O
ELFOSABI_ARM_FDPIC	O
:	O
return	O
"ARM FDPIC"	*(char)
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_MSP430	O
:	O
case	O
EM_MSP430_OLD	O
:	O
case	O
EM_VISIUM	O
:	O
switch	O
(	O
osabi	O
)	O
{	O
case	O
ELFOSABI_STANDALONE	O
:	O
return	O
_	O
(	O
"Standalone App"	*(char)
)	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_TI_C6000	O
:	O
switch	O
(	O
osabi	O
)	O
{	O
case	O
ELFOSABI_C6000_ELFABI	O
:	O
return	O
_	O
(	O
"Bare-metal C6000"	*(char)
)	O
;	O
case	O
ELFOSABI_C6000_LINUX	O
:	O
return	O
"Linux C6000"	*(char)
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<unknown: %x>"	*(char)
)	O
,	O
osabi	O
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_aarch64_segment_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
PT_AARCH64_ARCHEXT	O
:	O
return	O
"AARCH64_ARCHEXT"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_arm_segment_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
PT_ARM_EXIDX	O
:	O
return	O
"EXIDX"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_s390_segment_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
PT_S390_PGSTE	O
:	O
return	O
"S390_PGSTE"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_mips_segment_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
PT_MIPS_REGINFO	O
:	O
return	O
"REGINFO"	*(char)
;	O
case	O
PT_MIPS_RTPROC	O
:	O
return	O
"RTPROC"	*(char)
;	O
case	O
PT_MIPS_OPTIONS	O
:	O
return	O
"OPTIONS"	*(char)
;	O
case	O
PT_MIPS_ABIFLAGS	O
:	O
return	O
"ABIFLAGS"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_parisc_segment_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
PT_PARISC_ARCHEXT	O
:	O
return	O
"PARISC_ARCHEXT"	*(char)
;	O
case	O
PT_PARISC_UNWIND	O
:	O
return	O
"PARISC_UNWIND"	*(char)
;	O
case	O
PT_PARISC_WEAKORDER	O
:	O
return	O
"PARISC_WEAKORDER"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ia64_segment_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
PT_IA_64_ARCHEXT	O
:	O
return	O
"IA_64_ARCHEXT"	*(char)
;	O
case	O
PT_IA_64_UNWIND	O
:	O
return	O
"IA_64_UNWIND"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_tic6x_segment_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
PT_C6000_PHATTR	O
:	O
return	O
"C6000_PHATTR"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_hpux_segment_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
,	O
unsigned	O
e_machine	O
)	O
{	O
if	O
(	O
e_machine	O
==	O
EM_PARISC	O
)	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
PT_HP_TLS	O
:	O
return	O
"HP_TLS"	*(char)
;	O
case	O
PT_HP_CORE_NONE	O
:	O
return	O
"HP_CORE_NONE"	*(char)
;	O
case	O
PT_HP_CORE_VERSION	O
:	O
return	O
"HP_CORE_VERSION"	*(char)
;	O
case	O
PT_HP_CORE_KERNEL	O
:	O
return	O
"HP_CORE_KERNEL"	*(char)
;	O
case	O
PT_HP_CORE_COMM	O
:	O
return	O
"HP_CORE_COMM"	*(char)
;	O
case	O
PT_HP_CORE_PROC	O
:	O
return	O
"HP_CORE_PROC"	*(char)
;	O
case	O
PT_HP_CORE_LOADABLE	O
:	O
return	O
"HP_CORE_LOADABLE"	*(char)
;	O
case	O
PT_HP_CORE_STACK	O
:	O
return	O
"HP_CORE_STACK"	*(char)
;	O
case	O
PT_HP_CORE_SHM	O
:	O
return	O
"HP_CORE_SHM"	*(char)
;	O
case	O
PT_HP_CORE_MMF	O
:	O
return	O
"HP_CORE_MMF"	*(char)
;	O
case	O
PT_HP_PARALLEL	O
:	O
return	O
"HP_PARALLEL"	*(char)
;	O
case	O
PT_HP_FASTBIND	O
:	O
return	O
"HP_FASTBIND"	*(char)
;	O
case	O
PT_HP_OPT_ANNOT	O
:	O
return	O
"HP_OPT_ANNOT"	*(char)
;	O
case	O
PT_HP_HSL_ANNOT	O
:	O
return	O
"HP_HSL_ANNOT"	*(char)
;	O
case	O
PT_HP_STACK	O
:	O
return	O
"HP_STACK"	*(char)
;	O
case	O
PT_HP_CORE_UTSNAME	O
:	O
return	O
"HP_CORE_UTSNAME"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
if	O
(	O
e_machine	O
==	O
EM_IA_64	O
)	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
PT_HP_TLS	O
:	O
return	O
"HP_TLS"	*(char)
;	O
case	O
PT_IA_64_HP_OPT_ANOT	O
:	O
return	O
"HP_OPT_ANNOT"	*(char)
;	O
case	O
PT_IA_64_HP_HSL_ANOT	O
:	O
return	O
"HP_HSL_ANNOT"	*(char)
;	O
case	O
PT_IA_64_HP_STACK	O
:	O
return	O
"HP_STACK"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_solaris_segment_type	O
(	O
unsigned	O
long	O
type	enum(int,int,int,int)
)	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
0x6464e550	int
:	O
return	O
"PT_SUNW_UNWIND"	*(char)
;	O
case	O
0x6474e550	int
:	O
return	O
"PT_SUNW_EH_FRAME"	*(char)
;	O
case	O
0x6ffffff7	int
:	O
return	O
"PT_LOSUNW"	*(char)
;	O
case	O
0x6ffffffa	int
:	O
return	O
"PT_SUNWBSS"	*(char)
;	O
case	O
0x6ffffffb	int
:	O
return	O
"PT_SUNWSTACK"	*(char)
;	O
case	O
0x6ffffffc	int
:	O
return	O
"PT_SUNWDTRACE"	*(char)
;	O
case	O
0x6ffffffd	int
:	O
return	O
"PT_SUNWCAP"	*(char)
;	O
case	O
0x6fffffff	int
:	O
return	O
"PT_HISUNW"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_segment_type	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
long	O
p_type	O
)	O
{	O
static	O
char	O
buff	O
[	O
32	int
]	O
;	O
switch	O
(	O
p_type	O
)	O
{	O
case	O
PT_NULL	O
:	O
return	O
"NULL"	*(char)
;	O
case	O
PT_LOAD	O
:	O
return	O
"LOAD"	*(char)
;	O
case	O
PT_DYNAMIC	O
:	O
return	O
"DYNAMIC"	*(char)
;	O
case	O
PT_INTERP	O
:	O
return	O
"INTERP"	*(char)
;	O
case	O
PT_NOTE	O
:	O
return	O
"NOTE"	*(char)
;	O
case	O
PT_SHLIB	O
:	O
return	O
"SHLIB"	*(char)
;	O
case	O
PT_PHDR	O
:	O
return	O
"PHDR"	*(char)
;	O
case	O
PT_TLS	O
:	O
return	O
"TLS"	*(char)
;	O
case	O
PT_GNU_EH_FRAME	O
:	O
return	O
"GNU_EH_FRAME"	*(char)
;	O
case	O
PT_GNU_STACK	O
:	O
return	O
"GNU_STACK"	*(char)
;	O
case	O
PT_GNU_RELRO	O
:	O
return	O
"GNU_RELRO"	*(char)
;	O
case	O
PT_GNU_PROPERTY	O
:	O
return	O
"GNU_PROPERTY"	*(char)
;	O
default	O
:	O
if	O
(	O
(	O
p_type	O
>=	O
PT_LOPROC	O
)	O
&&	O
(	O
p_type	O
<=	O
PT_HIPROC	O
)	O
)	O
{	O
const	O
char	O
*	O
result	O
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_AARCH64	O
:	O
result	O
=	O
get_aarch64_segment_type	O
(	O
p_type	O
)	O
;	O
break	O
;	O
case	O
EM_ARM	O
:	O
result	O
=	O
get_arm_segment_type	O
(	O
p_type	O
)	O
;	O
break	O
;	O
case	O
EM_MIPS	O
:	O
case	O
EM_MIPS_RS3_LE	O
:	O
result	O
=	O
get_mips_segment_type	O
(	O
p_type	O
)	O
;	O
break	O
;	O
case	O
EM_PARISC	O
:	O
result	O
=	O
get_parisc_segment_type	O
(	O
p_type	O
)	O
;	O
break	O
;	O
case	O
EM_IA_64	O
:	O
result	O
=	O
get_ia64_segment_type	O
(	O
p_type	O
)	O
;	O
break	O
;	O
case	O
EM_TI_C6000	O
:	O
result	O
=	O
get_tic6x_segment_type	O
(	O
p_type	O
)	O
;	O
break	O
;	O
case	O
EM_S390	O
:	O
case	O
EM_S390_OLD	O
:	O
result	O
=	O
get_s390_segment_type	O
(	O
p_type	O
)	O
;	O
break	O
;	O
default	O
:	O
result	O
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	O
!=	O
NULL	O
)	O
return	O
result	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
"LOPROC+%#lx"	*(char)
,	O
p_type	O
-	O
PT_LOPROC	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
p_type	O
>=	O
PT_LOOS	O
)	O
&&	O
(	O
p_type	O
<=	O
PT_HIOS	O
)	O
)	O
{	O
const	O
char	O
*	O
result	O
=	O
NULL	O
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
)	O
{	O
case	O
ELFOSABI_GNU	O
:	O
case	O
ELFOSABI_FREEBSD	O
:	O
if	O
(	O
p_type	O
>=	O
PT_GNU_MBIND_LO	O
&&	O
p_type	O
<=	O
PT_GNU_MBIND_HI	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
"GNU_MBIND+%#lx"	*(char)
,	O
p_type	O
-	O
PT_GNU_MBIND_LO	O
)	O
;	O
result	O
=	O
buff	O
;	O
}	O
break	O
;	O
case	O
ELFOSABI_HPUX	O
:	O
result	O
=	O
get_hpux_segment_type	O
(	O
p_type	O
,	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
;	O
break	O
;	O
case	O
ELFOSABI_SOLARIS	O
:	O
result	O
=	O
get_solaris_segment_type	O
(	O
p_type	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
result	O
!=	O
NULL	O
)	O
return	O
result	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
"LOOS+%#lx"	*(char)
,	O
p_type	O
-	O
PT_LOOS	O
)	O
;	O
}	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<unknown>: %lx"	*(char)
)	O
,	O
p_type	O
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_arc_section_type_name	O
(	O
unsigned	O
int	O
sh_type	O
)	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_ARC_ATTRIBUTES	O
:	O
return	O
"ARC_ATTRIBUTES"	*(char)
;	O
default	O
:	O
break	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_mips_section_type_name	O
(	O
unsigned	O
int	O
sh_type	O
)	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_MIPS_LIBLIST	O
:	O
return	O
"MIPS_LIBLIST"	*(char)
;	O
case	O
SHT_MIPS_MSYM	O
:	O
return	O
"MIPS_MSYM"	*(char)
;	O
case	O
SHT_MIPS_CONFLICT	O
:	O
return	O
"MIPS_CONFLICT"	*(char)
;	O
case	O
SHT_MIPS_GPTAB	O
:	O
return	O
"MIPS_GPTAB"	*(char)
;	O
case	O
SHT_MIPS_UCODE	O
:	O
return	O
"MIPS_UCODE"	*(char)
;	O
case	O
SHT_MIPS_DEBUG	O
:	O
return	O
"MIPS_DEBUG"	*(char)
;	O
case	O
SHT_MIPS_REGINFO	O
:	O
return	O
"MIPS_REGINFO"	*(char)
;	O
case	O
SHT_MIPS_PACKAGE	O
:	O
return	O
"MIPS_PACKAGE"	*(char)
;	O
case	O
SHT_MIPS_PACKSYM	O
:	O
return	O
"MIPS_PACKSYM"	*(char)
;	O
case	O
SHT_MIPS_RELD	O
:	O
return	O
"MIPS_RELD"	*(char)
;	O
case	O
SHT_MIPS_IFACE	O
:	O
return	O
"MIPS_IFACE"	*(char)
;	O
case	O
SHT_MIPS_CONTENT	O
:	O
return	O
"MIPS_CONTENT"	*(char)
;	O
case	O
SHT_MIPS_OPTIONS	O
:	O
return	O
"MIPS_OPTIONS"	*(char)
;	O
case	O
SHT_MIPS_SHDR	O
:	O
return	O
"MIPS_SHDR"	*(char)
;	O
case	O
SHT_MIPS_FDESC	O
:	O
return	O
"MIPS_FDESC"	*(char)
;	O
case	O
SHT_MIPS_EXTSYM	O
:	O
return	O
"MIPS_EXTSYM"	*(char)
;	O
case	O
SHT_MIPS_DENSE	O
:	O
return	O
"MIPS_DENSE"	*(char)
;	O
case	O
SHT_MIPS_PDESC	O
:	O
return	O
"MIPS_PDESC"	*(char)
;	O
case	O
SHT_MIPS_LOCSYM	O
:	O
return	O
"MIPS_LOCSYM"	*(char)
;	O
case	O
SHT_MIPS_AUXSYM	O
:	O
return	O
"MIPS_AUXSYM"	*(char)
;	O
case	O
SHT_MIPS_OPTSYM	O
:	O
return	O
"MIPS_OPTSYM"	*(char)
;	O
case	O
SHT_MIPS_LOCSTR	O
:	O
return	O
"MIPS_LOCSTR"	*(char)
;	O
case	O
SHT_MIPS_LINE	O
:	O
return	O
"MIPS_LINE"	*(char)
;	O
case	O
SHT_MIPS_RFDESC	O
:	O
return	O
"MIPS_RFDESC"	*(char)
;	O
case	O
SHT_MIPS_DELTASYM	O
:	O
return	O
"MIPS_DELTASYM"	*(char)
;	O
case	O
SHT_MIPS_DELTAINST	O
:	O
return	O
"MIPS_DELTAINST"	*(char)
;	O
case	O
SHT_MIPS_DELTACLASS	O
:	O
return	O
"MIPS_DELTACLASS"	*(char)
;	O
case	O
SHT_MIPS_DWARF	O
:	O
return	O
"MIPS_DWARF"	*(char)
;	O
case	O
SHT_MIPS_DELTADECL	O
:	O
return	O
"MIPS_DELTADECL"	*(char)
;	O
case	O
SHT_MIPS_SYMBOL_LIB	O
:	O
return	O
"MIPS_SYMBOL_LIB"	*(char)
;	O
case	O
SHT_MIPS_EVENTS	O
:	O
return	O
"MIPS_EVENTS"	*(char)
;	O
case	O
SHT_MIPS_TRANSLATE	O
:	O
return	O
"MIPS_TRANSLATE"	*(char)
;	O
case	O
SHT_MIPS_PIXIE	O
:	O
return	O
"MIPS_PIXIE"	*(char)
;	O
case	O
SHT_MIPS_XLATE	O
:	O
return	O
"MIPS_XLATE"	*(char)
;	O
case	O
SHT_MIPS_XLATE_DEBUG	O
:	O
return	O
"MIPS_XLATE_DEBUG"	*(char)
;	O
case	O
SHT_MIPS_WHIRL	O
:	O
return	O
"MIPS_WHIRL"	*(char)
;	O
case	O
SHT_MIPS_EH_REGION	O
:	O
return	O
"MIPS_EH_REGION"	*(char)
;	O
case	O
SHT_MIPS_XLATE_OLD	O
:	O
return	O
"MIPS_XLATE_OLD"	*(char)
;	O
case	O
SHT_MIPS_PDR_EXCEPTION	O
:	O
return	O
"MIPS_PDR_EXCEPTION"	*(char)
;	O
case	O
SHT_MIPS_ABIFLAGS	O
:	O
return	O
"MIPS_ABIFLAGS"	*(char)
;	O
case	O
SHT_MIPS_XHASH	O
:	O
return	O
"MIPS_XHASH"	*(char)
;	O
default	O
:	O
break	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_parisc_section_type_name	O
(	O
unsigned	O
int	O
sh_type	O
)	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_PARISC_EXT	O
:	O
return	O
"PARISC_EXT"	*(char)
;	O
case	O
SHT_PARISC_UNWIND	O
:	O
return	O
"PARISC_UNWIND"	*(char)
;	O
case	O
SHT_PARISC_DOC	O
:	O
return	O
"PARISC_DOC"	*(char)
;	O
case	O
SHT_PARISC_ANNOT	O
:	O
return	O
"PARISC_ANNOT"	*(char)
;	O
case	O
SHT_PARISC_SYMEXTN	O
:	O
return	O
"PARISC_SYMEXTN"	*(char)
;	O
case	O
SHT_PARISC_STUBS	O
:	O
return	O
"PARISC_STUBS"	*(char)
;	O
case	O
SHT_PARISC_DLKM	O
:	O
return	O
"PARISC_DLKM"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ia64_section_type_name	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
sh_type	O
)	O
{	O
if	O
(	O
(	O
sh_type	O
&	O
0xFF000000	int
)	O
==	O
SHT_IA_64_LOPSREG	O
)	O
return	O
get_osabi_name	O
(	O
filedata	O
,	O
(	O
sh_type	O
&	O
0x00FF0000	int
)	O
>>	O
16	int
)	O
;	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_IA_64_EXT	O
:	O
return	O
"IA_64_EXT"	*(char)
;	O
case	O
SHT_IA_64_UNWIND	O
:	O
return	O
"IA_64_UNWIND"	*(char)
;	O
case	O
SHT_IA_64_PRIORITY_INIT	O
:	O
return	O
"IA_64_PRIORITY_INIT"	*(char)
;	O
case	O
SHT_IA_64_VMS_TRACE	O
:	O
return	O
"VMS_TRACE"	*(char)
;	O
case	O
SHT_IA_64_VMS_TIE_SIGNATURES	O
:	O
return	O
"VMS_TIE_SIGNATURES"	*(char)
;	O
case	O
SHT_IA_64_VMS_DEBUG	O
:	O
return	O
"VMS_DEBUG"	*(char)
;	O
case	O
SHT_IA_64_VMS_DEBUG_STR	O
:	O
return	O
"VMS_DEBUG_STR"	*(char)
;	O
case	O
SHT_IA_64_VMS_LINKAGES	O
:	O
return	O
"VMS_LINKAGES"	*(char)
;	O
case	O
SHT_IA_64_VMS_SYMBOL_VECTOR	O
:	O
return	O
"VMS_SYMBOL_VECTOR"	*(char)
;	O
case	O
SHT_IA_64_VMS_FIXUP	O
:	O
return	O
"VMS_FIXUP"	*(char)
;	O
default	O
:	O
break	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_x86_64_section_type_name	O
(	O
unsigned	O
int	O
sh_type	O
)	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_X86_64_UNWIND	O
:	O
return	O
"X86_64_UNWIND"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_aarch64_section_type_name	O
(	O
unsigned	O
int	O
sh_type	O
)	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_AARCH64_ATTRIBUTES	O
:	O
return	O
"AARCH64_ATTRIBUTES"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_arm_section_type_name	O
(	O
unsigned	O
int	O
sh_type	O
)	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_ARM_EXIDX	O
:	O
return	O
"ARM_EXIDX"	*(char)
;	O
case	O
SHT_ARM_PREEMPTMAP	O
:	O
return	O
"ARM_PREEMPTMAP"	*(char)
;	O
case	O
SHT_ARM_ATTRIBUTES	O
:	O
return	O
"ARM_ATTRIBUTES"	*(char)
;	O
case	O
SHT_ARM_DEBUGOVERLAY	O
:	O
return	O
"ARM_DEBUGOVERLAY"	*(char)
;	O
case	O
SHT_ARM_OVERLAYSECTION	O
:	O
return	O
"ARM_OVERLAYSECTION"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_tic6x_section_type_name	O
(	O
unsigned	O
int	O
sh_type	O
)	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_C6000_UNWIND	O
:	O
return	O
"C6000_UNWIND"	*(char)
;	O
case	O
SHT_C6000_PREEMPTMAP	O
:	O
return	O
"C6000_PREEMPTMAP"	*(char)
;	O
case	O
SHT_C6000_ATTRIBUTES	O
:	O
return	O
"C6000_ATTRIBUTES"	*(char)
;	O
case	O
SHT_TI_ICODE	O
:	O
return	O
"TI_ICODE"	*(char)
;	O
case	O
SHT_TI_XREF	O
:	O
return	O
"TI_XREF"	*(char)
;	O
case	O
SHT_TI_HANDLER	O
:	O
return	O
"TI_HANDLER"	*(char)
;	O
case	O
SHT_TI_INITINFO	O
:	O
return	O
"TI_INITINFO"	*(char)
;	O
case	O
SHT_TI_PHATTRS	O
:	O
return	O
"TI_PHATTRS"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_msp430x_section_type_name	O
(	O
unsigned	O
int	O
sh_type	O
)	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_MSP430_SEC_FLAGS	O
:	O
return	O
"MSP430_SEC_FLAGS"	*(char)
;	O
case	O
SHT_MSP430_SYM_ALIASES	O
:	O
return	O
"MSP430_SYM_ALIASES"	*(char)
;	O
case	O
SHT_MSP430_ATTRIBUTES	O
:	O
return	O
"MSP430_ATTRIBUTES"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_nfp_section_type_name	O
(	O
unsigned	O
int	O
sh_type	O
)	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_NFP_MECONFIG	O
:	O
return	O
"NFP_MECONFIG"	*(char)
;	O
case	O
SHT_NFP_INITREG	O
:	O
return	O
"NFP_INITREG"	*(char)
;	O
case	O
SHT_NFP_UDEBUG	O
:	O
return	O
"NFP_UDEBUG"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_v850_section_type_name	O
(	O
unsigned	O
int	O
sh_type	O
)	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_V850_SCOMMON	O
:	O
return	O
"V850 Small Common"	*(char)
;	O
case	O
SHT_V850_TCOMMON	O
:	O
return	O
"V850 Tiny Common"	*(char)
;	O
case	O
SHT_V850_ZCOMMON	O
:	O
return	O
"V850 Zero Common"	*(char)
;	O
case	O
SHT_RENESAS_IOP	O
:	O
return	O
"RENESAS IOP"	*(char)
;	O
case	O
SHT_RENESAS_INFO	O
:	O
return	O
"RENESAS INFO"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_riscv_section_type_name	O
(	O
unsigned	O
int	O
sh_type	O
)	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_RISCV_ATTRIBUTES	O
:	O
return	O
"RISCV_ATTRIBUTES"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_section_type_name	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
sh_type	O
)	O
{	O
static	O
char	O
buff	O
[	O
32	int
]	O
;	O
const	O
char	O
*	O
result	O
;	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_NULL	O
:	O
return	O
"NULL"	*(char)
;	O
case	O
SHT_PROGBITS	O
:	O
return	O
"PROGBITS"	*(char)
;	O
case	O
SHT_SYMTAB	O
:	O
return	O
"SYMTAB"	*(char)
;	O
case	O
SHT_STRTAB	O
:	O
return	O
"STRTAB"	*(char)
;	O
case	O
SHT_RELA	O
:	O
return	O
"RELA"	*(char)
;	O
case	O
SHT_HASH	O
:	O
return	O
"HASH"	*(char)
;	O
case	O
SHT_DYNAMIC	O
:	O
return	O
"DYNAMIC"	*(char)
;	O
case	O
SHT_NOTE	O
:	O
return	O
"NOTE"	*(char)
;	O
case	O
SHT_NOBITS	O
:	O
return	O
"NOBITS"	*(char)
;	O
case	O
SHT_REL	O
:	O
return	O
"REL"	*(char)
;	O
case	O
SHT_SHLIB	O
:	O
return	O
"SHLIB"	*(char)
;	O
case	O
SHT_DYNSYM	O
:	O
return	O
"DYNSYM"	*(char)
;	O
case	O
SHT_INIT_ARRAY	O
:	O
return	O
"INIT_ARRAY"	*(char)
;	O
case	O
SHT_FINI_ARRAY	O
:	O
return	O
"FINI_ARRAY"	*(char)
;	O
case	O
SHT_PREINIT_ARRAY	O
:	O
return	O
"PREINIT_ARRAY"	*(char)
;	O
case	O
SHT_GNU_HASH	O
:	O
return	O
"GNU_HASH"	*(char)
;	O
case	O
SHT_GROUP	O
:	O
return	O
"GROUP"	*(char)
;	O
case	O
SHT_SYMTAB_SHNDX	O
:	O
return	O
"SYMTAB SECTION INDICES"	*(char)
;	O
case	O
SHT_GNU_verdef	O
:	O
return	O
"VERDEF"	*(char)
;	O
case	O
SHT_GNU_verneed	O
:	O
return	O
"VERNEED"	*(char)
;	O
case	O
SHT_GNU_versym	O
:	O
return	O
"VERSYM"	*(char)
;	O
case	O
0x6ffffff0	int
:	O
return	O
"VERSYM"	*(char)
;	O
case	O
0x6ffffffc	int
:	O
return	O
"VERDEF"	*(char)
;	O
case	O
0x7ffffffd	int
:	O
return	O
"AUXILIARY"	*(char)
;	O
case	O
0x7fffffff	int
:	O
return	O
"FILTER"	*(char)
;	O
case	O
SHT_GNU_LIBLIST	O
:	O
return	O
"GNU_LIBLIST"	*(char)
;	O
default	O
:	O
if	O
(	O
(	O
sh_type	O
>=	O
SHT_LOPROC	O
)	O
&&	O
(	O
sh_type	O
<=	O
SHT_HIPROC	O
)	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_ARC	O
:	O
case	O
EM_ARC_COMPACT	O
:	O
case	O
EM_ARC_COMPACT2	O
:	O
result	O
=	O
get_arc_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
case	O
EM_MIPS	O
:	O
case	O
EM_MIPS_RS3_LE	O
:	O
result	O
=	O
get_mips_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
case	O
EM_PARISC	O
:	O
result	O
=	O
get_parisc_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
case	O
EM_IA_64	O
:	O
result	O
=	O
get_ia64_section_type_name	O
(	O
filedata	O
,	O
sh_type	O
)	O
;	O
break	O
;	O
case	O
EM_X86_64	O
:	O
case	O
EM_L1OM	O
:	O
case	O
EM_K1OM	O
:	O
result	O
=	O
get_x86_64_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
case	O
EM_AARCH64	O
:	O
result	O
=	O
get_aarch64_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
case	O
EM_ARM	O
:	O
result	O
=	O
get_arm_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
case	O
EM_TI_C6000	O
:	O
result	O
=	O
get_tic6x_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
case	O
EM_MSP430	O
:	O
result	O
=	O
get_msp430x_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
case	O
EM_NFP	O
:	O
result	O
=	O
get_nfp_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
case	O
EM_V800	O
:	O
case	O
EM_V850	O
:	O
case	O
EM_CYGNUS_V850	O
:	O
result	O
=	O
get_v850_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
case	O
EM_RISCV	O
:	O
result	O
=	O
get_riscv_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
default	O
:	O
result	O
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	O
!=	O
NULL	O
)	O
return	O
result	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
"LOPROC+%#x"	*(char)
,	O
sh_type	O
-	O
SHT_LOPROC	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
sh_type	O
>=	O
SHT_LOOS	O
)	O
&&	O
(	O
sh_type	O
<=	O
SHT_HIOS	O
)	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_IA_64	O
:	O
result	O
=	O
get_ia64_section_type_name	O
(	O
filedata	O
,	O
sh_type	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_SOLARIS	O
)	O
result	O
=	O
get_solaris_section_type	O
(	O
sh_type	O
)	O
;	O
else	O
{	O
switch	O
(	O
sh_type	O
)	O
{	O
case	O
SHT_GNU_INCREMENTAL_INPUTS	O
:	O
result	O
=	O
"GNU_INCREMENTAL_INPUTS"	*(char)
;	O
break	O
;	O
case	O
SHT_GNU_ATTRIBUTES	O
:	O
result	O
=	O
"GNU_ATTRIBUTES"	*(char)
;	O
break	O
;	O
case	O
SHT_GNU_HASH	O
:	O
result	O
=	O
"GNU_HASH"	*(char)
;	O
break	O
;	O
case	O
SHT_GNU_LIBLIST	O
:	O
result	O
=	O
"GNU_LIBLIST"	*(char)
;	O
break	O
;	O
default	O
:	O
result	O
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
break	O
;	O
}	O
if	O
(	O
result	O
!=	O
NULL	O
)	O
return	O
result	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
"LOOS+%#x"	*(char)
,	O
sh_type	O
-	O
SHT_LOOS	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
sh_type	O
>=	O
SHT_LOUSER	O
)	O
&&	O
(	O
sh_type	O
<=	O
SHT_HIUSER	O
)	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_V800	O
:	O
case	O
EM_V850	O
:	O
case	O
EM_CYGNUS_V850	O
:	O
result	O
=	O
get_v850_section_type_name	O
(	O
sh_type	O
)	O
;	O
break	O
;	O
default	O
:	O
result	O
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	O
!=	O
NULL	O
)	O
return	O
result	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
"LOUSER+%#x"	*(char)
,	O
sh_type	O
-	O
SHT_LOUSER	O
)	O
;	O
}	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"%08x: <unknown>"	*(char)
)	O
,	O
sh_type	O
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
struct	O
option	O
options	O
[	O
]	O
=	O
{	O
{	O
"all"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"file-header"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"program-headers"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"headers"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'e'	O
}	O
,	O
{	O
"histogram"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'I'	O
}	O
,	O
{	O
"segments"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"sections"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"section-headers"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"section-groups"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'g'	O
}	O
,	O
{	O
"section-details"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"full-section-name"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'N'	O
}	O
,	O
{	O
"symbols"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"syms"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"dyn-syms"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
OPTION_DYN_SYMS	O
}	O
,	O
{	O
"relocs"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"notes"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"dynamic"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"arch-specific"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'A'	O
}	O
,	O
{	O
"version-info"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
"use-dynamic"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"unwind"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
"archive-index"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"hex-dump"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"relocated-dump"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'R'	O
}	O
,	O
{	O
"string-dump"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"decompress"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'z'	O
}	O
,	O
{	O
"debug-dump"	*(char)
,	O
optional_argument	O
,	O
0	int
,	O
OPTION_DEBUG_DUMP	O
}	O
,	O
{	O
"dwarf-depth"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_DWARF_DEPTH	O
}	O
,	O
{	O
"dwarf-start"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_DWARF_START	O
}	O
,	O
{	O
"dwarf-check"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
OPTION_DWARF_CHECK	O
}	O
,	O
{	O
"ctf"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_CTF_DUMP	O
}	O
,	O
{	O
"ctf-symbols"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_CTF_SYMBOLS	O
}	O
,	O
{	O
"ctf-strings"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_CTF_STRINGS	O
}	O
,	O
{	O
"ctf-parent"	*(char)
,	O
required_argument	O
,	O
0	int
,	O
OPTION_CTF_PARENT	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"wide"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'W'	O
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	O
,	O
0	int
,	O
'H'	O
}	O
,	O
{	O
0	int
,	O
no_argument	O
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	O
(	O
FILE	struct
*	O
stream	*(void)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
"Usage: readelf <option(s)> elf-file(s)\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
" Display information about the contents of ELF format files\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
" Options are:\n  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n  -h --file-header       Display the ELF file header\n  -l --program-headers   Display the program headers\n     --segments          An alias for --program-headers\n  -S --section-headers   Display the sections' header\n     --sections          An alias for --section-headers\n  -g --section-groups    Display the section groups\n  -t --section-details   Display the section details\n  -e --headers           Equivalent to: -h -l -S\n  -s --syms              Display the symbol table\n     --symbols           An alias for --syms\n  --dyn-syms             Display the dynamic symbol table\n  -n --notes             Display the core notes (if present)\n  -r --relocs            Display the relocations (if present)\n  -u --unwind            Display the unwind info (if present)\n  -d --dynamic           Display the dynamic section (if present)\n  -V --version-info      Display the version sections (if present)\n  -A --arch-specific     Display architecture specific information (if any)\n  -c --archive-index     Display the symbol/file index in an archive\n  -D --use-dynamic       Use the dynamic section info when displaying symbols\n  -x --hex-dump=<number|name>\n                         Dump the contents of section <number|name> as bytes\n  -p --string-dump=<number|name>\n                         Dump the contents of section <number|name> as strings\n  -R --relocated-dump=<number|name>\n                         Dump the contents of section <number|name> as relocated bytes\n  -z --decompress        Decompress section before dumping it\n  -w[lLiaprmfFsoRtUuTgAckK] or\n  --debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,\n               =frames-interp,=str,=loc,=Ranges,=pubtypes,\n               =gdb_index,=trace_info,=trace_abbrev,=trace_aranges,\n               =addr,=cu_index,=links,=follow-links]\n                         Display the contents of DWARF debug sections\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
"  --dwarf-depth=N        Do not display DIEs at depth N or greater\n  --dwarf-start=N        Display DIEs starting with N, at the same depth\n                         or deeper\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
"  --ctf=<number|name>    Display CTF info from section <number|name>\n  --ctf-parent=<number|name>\n                         Use section <number|name> as the CTF parent\n\n  --ctf-symbols=<number|name>\n                         Use section <number|name> as the CTF external symtab\n\n  --ctf-strings=<number|name>\n                         Use section <number|name> as the CTF external strtab\n\n"	*(char)
)	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(void)
,	O
_	O
(	O
"  -I --histogram         Display histogram of bucket list lengths\n  -W --wide              Allow output width to exceed 80 characters\n  @<file>                Read options from <file>\n  -H --help              Display this information\n  -v --version           Display the version number of readelf\n"	*(char)
)	O
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	O
[	O
0	int
]	O
&&	O
stream	*(void)
==	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Report bugs to %s\n"	*(char)
)	O
,	O
REPORT_BUGS_TO	O
)	O
;	O
exit	(int)->(void)
(	O
stream	*(void)
==	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
?	O
0	int
:	O
1	int
)	O
;	O
}	O
static	O
void	O
request_dump_bynumber	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
dump_type	O
type	enum(int,int,int,int)
)	O
{	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
>=	O
filedata	O
->	O
num_dump_sects	O
)	O
{	O
dump_type	O
*	O
new_dump_sects	O
;	O
new_dump_sects	O
=	O
(	O
dump_type	O
*	O
)	O
calloc	(long,long)->(*(void))
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
+	O
1	int
,	O
sizeof	O
(	O
*	O
new_dump_sects	O
)	O
)	O
;	O
if	O
(	O
new_dump_sects	O
==	O
NULL	O
)	O
error	O
(	O
_	O
(	O
"Out of memory allocating dump request table.\n"	*(char)
)	O
)	O
;	O
else	O
{	O
if	O
(	O
filedata	O
->	O
dump_sects	O
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_dump_sects	O
,	O
filedata	O
->	O
dump_sects	O
,	O
filedata	O
->	O
num_dump_sects	O
*	O
sizeof	O
(	O
*	O
new_dump_sects	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
filedata	O
->	O
dump_sects	O
)	O
;	O
}	O
filedata	O
->	O
dump_sects	O
=	O
new_dump_sects	O
;	O
filedata	O
->	O
num_dump_sects	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
+	O
1	int
;	O
}	O
}	O
if	O
(	O
filedata	O
->	O
dump_sects	O
)	O
filedata	O
->	O
dump_sects	O
[	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
]	O
|=	O
type	enum(int,int,int,int)
;	O
}	O
static	O
void	O
request_dump_byname	O
(	O
const	O
char	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
dump_type	O
type	enum(int,int,int,int)
)	O
{	O
struct	O
dump_list_entry	O
*	O
new_request	O
;	O
new_request	O
=	O
(	O
struct	O
dump_list_entry	O
*	O
)	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
dump_list_entry	O
)	O
)	O
;	O
if	O
(	O
!	O
new_request	O
)	O
error	O
(	O
_	O
(	O
"Out of memory allocating dump request table.\n"	*(char)
)	O
)	O
;	O
new_request	O
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
if	O
(	O
!	O
new_request	O
->	O
name	*(char)
)	O
error	O
(	O
_	O
(	O
"Out of memory allocating dump request table.\n"	*(char)
)	O
)	O
;	O
new_request	O
->	O
type	enum(int,int,int,int)
=	O
type	enum(int,int,int,int)
;	O
new_request	O
->	O
next	*(char)
=	O
dump_sects_byname	O
;	O
dump_sects_byname	O
=	O
new_request	O
;	O
}	O
static	O
inline	O
void	O
request_dump	O
(	O
Filedata	O
*	O
filedata	O
,	O
dump_type	O
type	enum(int,int,int,int)
)	O
{	O
int	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
char	O
*	O
cp	O
;	O
do_dump	O
++	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
&	O
cp	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
*	O
cp	O
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
>=	O
0	int
)	O
request_dump_bynumber	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
type	enum(int,int,int,int)
)	O
;	O
else	O
request_dump_byname	O
(	O
optarg	*(char)
,	O
type	enum(int,int,int,int)
)	O
;	O
}	O
static	O
void	O
parse_args	O
(	O
Filedata	O
*	O
filedata	O
,	O
int	O
argc	O
,	O
char	O
*	O
*	O
argv	O
)	O
{	O
int	O
c	int
;	O
if	O
(	O
argc	O
<	O
2	int
)	O
usage	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	O
(	O
argc	O
,	O
argv	O
,	O
"ADHINR:SVWacdeghi:lnp:rstuvw::x:z"	*(char)
,	O
options	O
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'H'	O
:	O
usage	O
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
do_syms	O
=	O
TRUE	int
;	O
do_reloc	O
=	O
TRUE	int
;	O
do_unwind	O
=	O
TRUE	int
;	O
do_dynamic	O
=	O
TRUE	int
;	O
do_header	O
=	O
TRUE	int
;	O
do_sections	O
=	O
TRUE	int
;	O
do_section_groups	O
=	O
TRUE	int
;	O
do_segments	O
=	O
TRUE	int
;	O
do_version	O
=	O
TRUE	int
;	O
do_histogram	O
=	O
TRUE	int
;	O
do_arch	O
=	O
TRUE	int
;	O
do_notes	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'g'	O
:	O
do_section_groups	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
't'	O
:	O
case	O
'N'	O
:	O
do_sections	O
=	O
TRUE	int
;	O
do_section_details	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'e'	O
:	O
do_header	O
=	O
TRUE	int
;	O
do_sections	O
=	O
TRUE	int
;	O
do_segments	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'A'	O
:	O
do_arch	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'D'	O
:	O
do_using_dynamic	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'r'	O
:	O
do_reloc	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'u'	O
:	O
do_unwind	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'h'	O
:	O
do_header	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'l'	O
:	O
do_segments	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
's'	O
:	O
do_syms	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'S'	O
:	O
do_sections	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'd'	O
:	O
do_dynamic	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'I'	O
:	O
do_histogram	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'n'	O
:	O
do_notes	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'c'	O
:	O
do_archive_index	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'x'	O
:	O
request_dump	O
(	O
filedata	O
,	O
HEX_DUMP	O
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
request_dump	O
(	O
filedata	O
,	O
STRING_DUMP	O
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
request_dump	O
(	O
filedata	O
,	O
RELOC_DUMP	O
)	O
;	O
break	O
;	O
case	O
'z'	O
:	O
decompress_dumps	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'w'	O
:	O
do_dump	O
=	O
TRUE	int
;	O
if	O
(	O
optarg	*(char)
==	O
0	int
)	O
{	O
do_debugging	O
=	O
TRUE	int
;	O
dwarf_select_sections_all	O
(	O
)	O
;	O
}	O
else	O
{	O
do_debugging	O
=	O
FALSE	O
;	O
dwarf_select_sections_by_letters	O
(	O
optarg	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_DEBUG_DUMP	O
:	O
do_dump	O
=	O
TRUE	int
;	O
if	O
(	O
optarg	*(char)
==	O
0	int
)	O
do_debugging	O
=	O
TRUE	int
;	O
else	O
{	O
do_debugging	O
=	O
FALSE	O
;	O
dwarf_select_sections_by_names	O
(	O
optarg	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_DWARF_DEPTH	O
:	O
{	O
char	O
*	O
cp	O
;	O
dwarf_cutoff_level	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
&	O
cp	O
,	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_DWARF_START	O
:	O
{	O
char	O
*	O
cp	O
;	O
dwarf_start_die	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
&	O
cp	O
,	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_DWARF_CHECK	O
:	O
dwarf_check	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_CTF_DUMP	O
:	O
do_ctf	O
=	O
TRUE	int
;	O
request_dump	O
(	O
filedata	O
,	O
CTF_DUMP	O
)	O
;	O
break	O
;	O
case	O
OPTION_CTF_SYMBOLS	O
:	O
dump_ctf_symtab_name	O
=	O
strdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_CTF_STRINGS	O
:	O
dump_ctf_strtab_name	O
=	O
strdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_CTF_PARENT	O
:	O
dump_ctf_parent_name	O
=	O
strdup	(*(char))->(*(char))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
OPTION_DYN_SYMS	O
:	O
do_dyn_syms	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'v'	O
:	O
print_version	O
(	O
program_name	O
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	O
=	O
TRUE	int
;	O
break	O
;	O
case	O
'W'	O
:	O
do_wide	O
=	O
TRUE	int
;	O
break	O
;	O
default	O
:	O
error	O
(	O
_	O
(	O
"Invalid option '-%c'\n"	*(char)
)	O
,	O
c	int
)	O
;	O
case	O
'?'	O
:	O
usage	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
if	O
(	O
!	O
do_dynamic	O
&&	O
!	O
do_syms	O
&&	O
!	O
do_reloc	O
&&	O
!	O
do_unwind	O
&&	O
!	O
do_sections	O
&&	O
!	O
do_segments	O
&&	O
!	O
do_header	O
&&	O
!	O
do_dump	O
&&	O
!	O
do_version	O
&&	O
!	O
do_histogram	O
&&	O
!	O
do_debugging	O
&&	O
!	O
do_arch	O
&&	O
!	O
do_notes	O
&&	O
!	O
do_section_groups	O
&&	O
!	O
do_archive_index	O
&&	O
!	O
do_dyn_syms	O
)	O
usage	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
const	O
char	O
*	O
get_elf_class	O
(	O
unsigned	O
int	O
elf_class	O
)	O
{	O
static	O
char	O
buff	O
[	O
32	int
]	O
;	O
switch	O
(	O
elf_class	O
)	O
{	O
case	O
ELFCLASSNONE	O
:	O
return	O
_	O
(	O
"none"	*(char)
)	O
;	O
case	O
ELFCLASS32	O
:	O
return	O
"ELF32"	*(char)
;	O
case	O
ELFCLASS64	O
:	O
return	O
"ELF64"	*(char)
;	O
default	O
:	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<unknown: %x>"	*(char)
)	O
,	O
elf_class	O
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_data_encoding	O
(	O
unsigned	O
int	O
encoding	O
)	O
{	O
static	O
char	O
buff	O
[	O
32	int
]	O
;	O
switch	O
(	O
encoding	O
)	O
{	O
case	O
ELFDATANONE	O
:	O
return	O
_	O
(	O
"none"	*(char)
)	O
;	O
case	O
ELFDATA2LSB	O
:	O
return	O
_	O
(	O
"2's complement, little endian"	*(char)
)	O
;	O
case	O
ELFDATA2MSB	O
:	O
return	O
_	O
(	O
"2's complement, big endian"	*(char)
)	O
;	O
default	O
:	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<unknown: %x>"	*(char)
)	O
,	O
encoding	O
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
bfd_boolean	int
process_file_header	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Ehdr	O
*	O
header	O
=	O
&	O
filedata	O
->	O
file_header	O
;	O
if	O
(	O
header	O
->	O
e_ident	O
[	O
EI_MAG0	O
]	O
!=	O
ELFMAG0	O
||	O
header	O
->	O
e_ident	O
[	O
EI_MAG1	O
]	O
!=	O
ELFMAG1	O
||	O
header	O
->	O
e_ident	O
[	O
EI_MAG2	O
]	O
!=	O
ELFMAG2	O
||	O
header	O
->	O
e_ident	O
[	O
EI_MAG3	O
]	O
!=	O
ELFMAG3	O
)	O
{	O
error	O
(	O
_	O
(	O
"Not an ELF file - it has the wrong magic bytes at the start\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
init_dwarf_regnames_by_elf_machine_code	O
(	O
header	O
->	O
e_machine	O
)	O
;	O
if	O
(	O
do_header	O
)	O
{	O
unsigned	O
i	*(struct)
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"ELF Header:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Magic:   "	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
EI_NIDENT	O
;	O
i	*(struct)
++	O
)	O
printf	(*(char))->(int)
(	O
"%2.2x "	*(char)
,	O
header	O
->	O
e_ident	O
[	O
i	*(struct)
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Class:                             %s\n"	*(char)
)	O
,	O
get_elf_class	O
(	O
header	O
->	O
e_ident	O
[	O
EI_CLASS	O
]	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Data:                              %s\n"	*(char)
)	O
,	O
get_data_encoding	O
(	O
header	O
->	O
e_ident	O
[	O
EI_DATA	O
]	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Version:                           %d%s\n"	*(char)
)	O
,	O
header	O
->	O
e_ident	O
[	O
EI_VERSION	O
]	O
,	O
(	O
header	O
->	O
e_ident	O
[	O
EI_VERSION	O
]	O
==	O
EV_CURRENT	O
?	O
_	O
(	O
" (current)"	*(char)
)	O
:	O
(	O
header	O
->	O
e_ident	O
[	O
EI_VERSION	O
]	O
!=	O
EV_NONE	O
?	O
_	O
(	O
" <unknown>"	*(char)
)	O
:	O
""	*(char)
)	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  OS/ABI:                            %s\n"	*(char)
)	O
,	O
get_osabi_name	O
(	O
filedata	O
,	O
header	O
->	O
e_ident	O
[	O
EI_OSABI	O
]	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  ABI Version:                       %d\n"	*(char)
)	O
,	O
header	O
->	O
e_ident	O
[	O
EI_ABIVERSION	O
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Type:                              %s\n"	*(char)
)	O
,	O
get_file_type	O
(	O
header	O
->	O
e_type	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Machine:                           %s\n"	*(char)
)	O
,	O
get_machine_name	O
(	O
header	O
->	O
e_machine	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Version:                           0x%lx\n"	*(char)
)	O
,	O
header	O
->	O
e_version	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Entry point address:               "	*(char)
)	O
)	O
;	O
print_vma	O
(	O
header	O
->	O
e_entry	O
,	O
PREFIX_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\n  Start of program headers:          "	*(char)
)	O
)	O
;	O
print_vma	O
(	O
header	O
->	O
e_phoff	O
,	O
DEC	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" (bytes into file)\n  Start of section headers:          "	*(char)
)	O
)	O
;	O
print_vma	O
(	O
header	O
->	O
e_shoff	O
,	O
DEC	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" (bytes into file)\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Flags:                             0x%lx%s\n"	*(char)
)	O
,	O
header	O
->	O
e_flags	O
,	O
get_machine_flags	O
(	O
filedata	O
,	O
header	O
->	O
e_flags	O
,	O
header	O
->	O
e_machine	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Size of this header:               %u (bytes)\n"	*(char)
)	O
,	O
header	O
->	O
e_ehsize	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Size of program headers:           %u (bytes)\n"	*(char)
)	O
,	O
header	O
->	O
e_phentsize	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Number of program headers:         %u"	*(char)
)	O
,	O
header	O
->	O
e_phnum	O
)	O
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
!=	O
NULL	O
&&	O
header	O
->	O
e_phnum	O
==	O
PN_XNUM	O
&&	O
filedata	O
->	O
section_headers	O
[	O
0	int
]	O
.	O
sh_info	O
!=	O
0	int
)	O
{	O
header	O
->	O
e_phnum	O
=	O
filedata	O
->	O
section_headers	O
[	O
0	int
]	O
.	O
sh_info	O
;	O
printf	(*(char))->(int)
(	O
" (%u)"	*(char)
,	O
header	O
->	O
e_phnum	O
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Size of section headers:           %u (bytes)\n"	*(char)
)	O
,	O
header	O
->	O
e_shentsize	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Number of section headers:         %u"	*(char)
)	O
,	O
header	O
->	O
e_shnum	O
)	O
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
!=	O
NULL	O
&&	O
header	O
->	O
e_shnum	O
==	O
SHN_UNDEF	O
)	O
{	O
header	O
->	O
e_shnum	O
=	O
filedata	O
->	O
section_headers	O
[	O
0	int
]	O
.	O
sh_size	O
;	O
printf	(*(char))->(int)
(	O
" (%u)"	*(char)
,	O
header	O
->	O
e_shnum	O
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Section header string table index: %u"	*(char)
)	O
,	O
header	O
->	O
e_shstrndx	O
)	O
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
!=	O
NULL	O
&&	O
header	O
->	O
e_shstrndx	O
==	O
(	O
SHN_XINDEX	O
&	O
0xffff	int
)	O
)	O
{	O
header	O
->	O
e_shstrndx	O
=	O
filedata	O
->	O
section_headers	O
[	O
0	int
]	O
.	O
sh_link	O
;	O
printf	(*(char))->(int)
(	O
" (%u)"	*(char)
,	O
header	O
->	O
e_shstrndx	O
)	O
;	O
}	O
if	O
(	O
header	O
->	O
e_shstrndx	O
!=	O
SHN_UNDEF	O
&&	O
header	O
->	O
e_shstrndx	O
>=	O
header	O
->	O
e_shnum	O
)	O
{	O
header	O
->	O
e_shstrndx	O
=	O
SHN_UNDEF	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" <corrupt: out of range>"	*(char)
)	O
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
filedata	O
->	O
section_headers	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
header	O
->	O
e_phnum	O
==	O
PN_XNUM	O
&&	O
filedata	O
->	O
section_headers	O
[	O
0	int
]	O
.	O
sh_info	O
!=	O
0	int
)	O
header	O
->	O
e_phnum	O
=	O
filedata	O
->	O
section_headers	O
[	O
0	int
]	O
.	O
sh_info	O
;	O
if	O
(	O
header	O
->	O
e_shnum	O
==	O
SHN_UNDEF	O
)	O
header	O
->	O
e_shnum	O
=	O
filedata	O
->	O
section_headers	O
[	O
0	int
]	O
.	O
sh_size	O
;	O
if	O
(	O
header	O
->	O
e_shstrndx	O
==	O
(	O
SHN_XINDEX	O
&	O
0xffff	int
)	O
)	O
header	O
->	O
e_shstrndx	O
=	O
filedata	O
->	O
section_headers	O
[	O
0	int
]	O
.	O
sh_link	O
;	O
if	O
(	O
header	O
->	O
e_shstrndx	O
>=	O
header	O
->	O
e_shnum	O
)	O
header	O
->	O
e_shstrndx	O
=	O
SHN_UNDEF	O
;	O
free	(*(void))->(void)
(	O
filedata	O
->	O
section_headers	O
)	O
;	O
filedata	O
->	O
section_headers	O
=	O
NULL	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
get_32bit_program_headers	O
(	O
Filedata	O
*	O
filedata	O
,	O
Elf_Internal_Phdr	O
*	O
pheaders	O
)	O
{	O
Elf32_External_Phdr	O
*	O
phdrs	O
;	O
Elf32_External_Phdr	O
*	O
external	O
;	O
Elf_Internal_Phdr	O
*	O
internal	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
unsigned	O
int	O
size	int
=	O
filedata	O
->	O
file_header	O
.	O
e_phentsize	O
;	O
unsigned	O
int	O
num	O
=	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
;	O
if	O
(	O
size	int
==	O
0	int
||	O
num	O
==	O
0	int
)	O
return	O
FALSE	O
;	O
if	O
(	O
size	int
<	O
sizeof	O
*	O
phdrs	O
)	O
{	O
error	O
(	O
_	O
(	O
"The e_phentsize field in the ELF header is less than the size of an ELF program header\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
size	int
>	O
sizeof	O
*	O
phdrs	O
)	O
warn	O
(	O
_	O
(	O
"The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"	*(char)
)	O
)	O
;	O
phdrs	O
=	O
(	O
Elf32_External_Phdr	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
filedata	O
->	O
file_header	O
.	O
e_phoff	O
,	O
size	int
,	O
num	O
,	O
_	O
(	O
"program headers"	*(char)
)	O
)	O
;	O
if	O
(	O
phdrs	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
internal	O
=	O
pheaders	O
,	O
external	O
=	O
phdrs	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
;	O
i	*(struct)
++	O
,	O
internal	O
++	O
,	O
external	O
++	O
)	O
{	O
internal	O
->	O
p_type	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_type	O
)	O
;	O
internal	O
->	O
p_offset	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_offset	O
)	O
;	O
internal	O
->	O
p_vaddr	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_vaddr	O
)	O
;	O
internal	O
->	O
p_paddr	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_paddr	O
)	O
;	O
internal	O
->	O
p_filesz	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_filesz	O
)	O
;	O
internal	O
->	O
p_memsz	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_memsz	O
)	O
;	O
internal	O
->	O
p_flags	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_flags	O
)	O
;	O
internal	O
->	O
p_align	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_align	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
phdrs	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
get_64bit_program_headers	O
(	O
Filedata	O
*	O
filedata	O
,	O
Elf_Internal_Phdr	O
*	O
pheaders	O
)	O
{	O
Elf64_External_Phdr	O
*	O
phdrs	O
;	O
Elf64_External_Phdr	O
*	O
external	O
;	O
Elf_Internal_Phdr	O
*	O
internal	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
unsigned	O
int	O
size	int
=	O
filedata	O
->	O
file_header	O
.	O
e_phentsize	O
;	O
unsigned	O
int	O
num	O
=	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
;	O
if	O
(	O
size	int
==	O
0	int
||	O
num	O
==	O
0	int
)	O
return	O
FALSE	O
;	O
if	O
(	O
size	int
<	O
sizeof	O
*	O
phdrs	O
)	O
{	O
error	O
(	O
_	O
(	O
"The e_phentsize field in the ELF header is less than the size of an ELF program header\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
size	int
>	O
sizeof	O
*	O
phdrs	O
)	O
warn	O
(	O
_	O
(	O
"The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"	*(char)
)	O
)	O
;	O
phdrs	O
=	O
(	O
Elf64_External_Phdr	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
filedata	O
->	O
file_header	O
.	O
e_phoff	O
,	O
size	int
,	O
num	O
,	O
_	O
(	O
"program headers"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
phdrs	O
)	O
return	O
FALSE	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
internal	O
=	O
pheaders	O
,	O
external	O
=	O
phdrs	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
;	O
i	*(struct)
++	O
,	O
internal	O
++	O
,	O
external	O
++	O
)	O
{	O
internal	O
->	O
p_type	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_type	O
)	O
;	O
internal	O
->	O
p_flags	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_flags	O
)	O
;	O
internal	O
->	O
p_offset	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_offset	O
)	O
;	O
internal	O
->	O
p_vaddr	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_vaddr	O
)	O
;	O
internal	O
->	O
p_paddr	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_paddr	O
)	O
;	O
internal	O
->	O
p_filesz	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_filesz	O
)	O
;	O
internal	O
->	O
p_memsz	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_memsz	O
)	O
;	O
internal	O
->	O
p_align	O
=	O
BYTE_GET	O
(	O
external	O
->	O
p_align	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
phdrs	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
get_program_headers	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Phdr	O
*	O
phdrs	O
;	O
if	O
(	O
filedata	O
->	O
program_headers	O
!=	O
NULL	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
*	O
(	O
is_32bit_elf	O
?	O
sizeof	O
(	O
Elf32_External_Phdr	O
)	O
:	O
sizeof	O
(	O
Elf64_External_Phdr	O
)	O
)	O
>=	O
filedata	O
->	O
file_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Too many program headers - %#x - the file is not that big\n"	*(char)
)	O
,	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
phdrs	O
=	O
(	O
Elf_Internal_Phdr	O
*	O
)	O
cmalloc	O
(	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
,	O
sizeof	O
(	O
Elf_Internal_Phdr	O
)	O
)	O
;	O
if	O
(	O
phdrs	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory reading %u program headers\n"	*(char)
)	O
,	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
is_32bit_elf	O
?	O
get_32bit_program_headers	O
(	O
filedata	O
,	O
phdrs	O
)	O
:	O
get_64bit_program_headers	O
(	O
filedata	O
,	O
phdrs	O
)	O
)	O
{	O
filedata	O
->	O
program_headers	O
=	O
phdrs	O
;	O
return	O
TRUE	int
;	O
}	O
free	(*(void))->(void)
(	O
phdrs	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
static	O
bfd_boolean	int
process_program_headers	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Phdr	O
*	O
segment	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
Elf_Internal_Phdr	O
*	O
previous_load	O
=	O
NULL	O
;	O
dynamic_addr	O
=	O
0	int
;	O
dynamic_size	O
=	O
0	int
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
==	O
0	int
)	O
{	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_phoff	O
!=	O
0	int
)	O
{	O
warn	O
(	O
_	O
(	O
"possibly corrupt ELF header - it has a non-zero program"	*(char)
" header offset, but no program headers\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
do_segments	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThere are no program headers in this file.\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
do_segments	O
&&	O
!	O
do_header	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nElf file type is %s\n"	*(char)
)	O
,	O
get_file_type	O
(	O
filedata	O
->	O
file_header	O
.	O
e_type	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Entry point 0x%s\n"	*(char)
)	O
,	O
bfd_vmatoa	O
(	O
"x"	*(char)
,	O
filedata	O
->	O
file_header	O
.	O
e_entry	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"There is %d program header, starting at offset %s\n"	*(char)
,	O
"There are %d program headers, starting at offset %s\n"	*(char)
,	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
)	O
,	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
filedata	O
->	O
file_header	O
.	O
e_phoff	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
get_program_headers	O
(	O
filedata	O
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
do_segments	O
)	O
{	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
>	O
1	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nProgram Headers:\n"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nProgram Headers:\n"	*(char)
)	O
)	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
do_wide	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n"	*(char)
)	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Type           Offset             VirtAddr           PhysAddr\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"                 FileSiz            MemSiz              Flags  Align\n"	*(char)
)	O
)	O
;	O
}	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
segment	O
=	O
filedata	O
->	O
program_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
;	O
i	*(struct)
++	O
,	O
segment	O
++	O
)	O
{	O
if	O
(	O
do_segments	O
)	O
{	O
printf	(*(char))->(int)
(	O
"  %-14.14s "	*(char)
,	O
get_segment_type	O
(	O
filedata	O
,	O
segment	O
->	O
p_type	O
)	O
)	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
printf	(*(char))->(int)
(	O
"0x%6.6lx "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_offset	O
)	O
;	O
printf	(*(char))->(int)
(	O
"0x%8.8lx "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_vaddr	O
)	O
;	O
printf	(*(char))->(int)
(	O
"0x%8.8lx "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_paddr	O
)	O
;	O
printf	(*(char))->(int)
(	O
"0x%5.5lx "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_filesz	O
)	O
;	O
printf	(*(char))->(int)
(	O
"0x%5.5lx "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_memsz	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%c%c%c "	*(char)
,	O
(	O
segment	O
->	O
p_flags	O
&	O
PF_R	O
?	O
'R'	O
:	O
' '	O
)	O
,	O
(	O
segment	O
->	O
p_flags	O
&	O
PF_W	O
?	O
'W'	O
:	O
' '	O
)	O
,	O
(	O
segment	O
->	O
p_flags	O
&	O
PF_X	O
?	O
'E'	O
:	O
' '	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%#lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_align	O
)	O
;	O
}	O
else	O
if	O
(	O
do_wide	O
)	O
{	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_offset	O
==	O
segment	O
->	O
p_offset	O
)	O
printf	(*(char))->(int)
(	O
"0x%6.6lx "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_offset	O
)	O
;	O
else	O
{	O
print_vma	O
(	O
segment	O
->	O
p_offset	O
,	O
FULL_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
}	O
print_vma	O
(	O
segment	O
->	O
p_vaddr	O
,	O
FULL_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
segment	O
->	O
p_paddr	O
,	O
FULL_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_filesz	O
==	O
segment	O
->	O
p_filesz	O
)	O
printf	(*(char))->(int)
(	O
"0x%6.6lx "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_filesz	O
)	O
;	O
else	O
{	O
print_vma	O
(	O
segment	O
->	O
p_filesz	O
,	O
FULL_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
}	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_memsz	O
==	O
segment	O
->	O
p_memsz	O
)	O
printf	(*(char))->(int)
(	O
"0x%6.6lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_memsz	O
)	O
;	O
else	O
{	O
print_vma	O
(	O
segment	O
->	O
p_memsz	O
,	O
FULL_HEX	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
" %c%c%c "	*(char)
,	O
(	O
segment	O
->	O
p_flags	O
&	O
PF_R	O
?	O
'R'	O
:	O
' '	O
)	O
,	O
(	O
segment	O
->	O
p_flags	O
&	O
PF_W	O
?	O
'W'	O
:	O
' '	O
)	O
,	O
(	O
segment	O
->	O
p_flags	O
&	O
PF_X	O
?	O
'E'	O
:	O
' '	O
)	O
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_align	O
==	O
segment	O
->	O
p_align	O
)	O
printf	(*(char))->(int)
(	O
"%#lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
segment	O
->	O
p_align	O
)	O
;	O
else	O
{	O
print_vma	O
(	O
segment	O
->	O
p_align	O
,	O
PREFIX_HEX	O
)	O
;	O
}	O
}	O
else	O
{	O
print_vma	O
(	O
segment	O
->	O
p_offset	O
,	O
FULL_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
segment	O
->	O
p_vaddr	O
,	O
FULL_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
segment	O
->	O
p_paddr	O
,	O
FULL_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n                 "	*(char)
)	O
;	O
print_vma	O
(	O
segment	O
->	O
p_filesz	O
,	O
FULL_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
segment	O
->	O
p_memsz	O
,	O
FULL_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  %c%c%c    "	*(char)
,	O
(	O
segment	O
->	O
p_flags	O
&	O
PF_R	O
?	O
'R'	O
:	O
' '	O
)	O
,	O
(	O
segment	O
->	O
p_flags	O
&	O
PF_W	O
?	O
'W'	O
:	O
' '	O
)	O
,	O
(	O
segment	O
->	O
p_flags	O
&	O
PF_X	O
?	O
'E'	O
:	O
' '	O
)	O
)	O
;	O
print_vma	O
(	O
segment	O
->	O
p_align	O
,	O
PREFIX_HEX	O
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
switch	O
(	O
segment	O
->	O
p_type	O
)	O
{	O
case	O
PT_LOAD	O
:	O
if	O
(	O
segment	O
->	O
p_memsz	O
<	O
segment	O
->	O
p_filesz	O
)	O
error	O
(	O
_	O
(	O
"the segment's file size is larger than its memory size\n"	*(char)
)	O
)	O
;	O
previous_load	O
=	O
segment	O
;	O
break	O
;	O
case	O
PT_PHDR	O
:	O
if	O
(	O
i	*(struct)
>	O
0	int
&&	O
previous_load	O
!=	O
NULL	O
)	O
error	O
(	O
_	O
(	O
"the PHDR segment must occur before any LOAD segment\n"	*(char)
)	O
)	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
!=	O
EM_PARISC	O
)	O
{	O
unsigned	O
int	O
j	O
;	O
for	O
(	O
j	O
=	O
1	int
;	O
j	O
<	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
;	O
j	O
++	O
)	O
{	O
Elf_Internal_Phdr	O
*	O
load	O
=	O
filedata	O
->	O
program_headers	O
+	O
j	O
;	O
if	O
(	O
load	O
->	O
p_type	O
==	O
PT_LOAD	O
&&	O
load	O
->	O
p_offset	O
<=	O
segment	O
->	O
p_offset	O
&&	O
(	O
load	O
->	O
p_offset	O
+	O
load	O
->	O
p_filesz	O
>=	O
segment	O
->	O
p_offset	O
+	O
segment	O
->	O
p_filesz	O
)	O
&&	O
load	O
->	O
p_vaddr	O
<=	O
segment	O
->	O
p_vaddr	O
&&	O
(	O
load	O
->	O
p_vaddr	O
+	O
load	O
->	O
p_filesz	O
>=	O
segment	O
->	O
p_vaddr	O
+	O
segment	O
->	O
p_filesz	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
j	O
==	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
)	O
error	O
(	O
_	O
(	O
"the PHDR segment is not covered by a LOAD segment\n"	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
PT_DYNAMIC	O
:	O
if	O
(	O
dynamic_addr	O
)	O
error	O
(	O
_	O
(	O
"more than one dynamic segment\n"	*(char)
)	O
)	O
;	O
dynamic_addr	O
=	O
segment	O
->	O
p_offset	O
;	O
dynamic_size	O
=	O
segment	O
->	O
p_filesz	O
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
!=	O
NULL	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
find_section	O
(	O
filedata	O
,	O
".dynamic"	*(char)
)	O
;	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
==	O
NULL	O
||	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
is_ia64_vms	O
(	O
filedata	O
)	O
)	O
error	O
(	O
_	O
(	O
"no .dynamic section in the dynamic segment\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_NOBITS	O
)	O
{	O
dynamic_size	O
=	O
0	int
;	O
break	O
;	O
}	O
dynamic_addr	O
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
;	O
dynamic_size	O
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
if	O
(	O
dynamic_addr	O
<	O
segment	O
->	O
p_offset	O
||	O
dynamic_addr	O
>	O
segment	O
->	O
p_offset	O
+	O
segment	O
->	O
p_filesz	O
)	O
warn	O
(	O
_	O
(	O
"the .dynamic section is not contained"	*(char)
" within the dynamic segment\n"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
dynamic_addr	O
>	O
segment	O
->	O
p_offset	O
)	O
warn	O
(	O
_	O
(	O
"the .dynamic section is not the first section"	*(char)
" in the dynamic segment.\n"	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
dynamic_addr	O
>	O
filedata	O
->	O
file_size	O
||	O
dynamic_size	O
>	O
filedata	O
->	O
file_size	O
-	O
dynamic_addr	O
)	O
{	O
error	O
(	O
_	O
(	O
"the dynamic segment offset + size exceeds the size of the file\n"	*(char)
)	O
)	O
;	O
dynamic_addr	O
=	O
dynamic_size	O
=	O
0	int
;	O
}	O
break	O
;	O
case	O
PT_INTERP	O
:	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
filedata	O
->	O
handle	O
,	O
archive_file_offset	O
+	O
(	O
long	O
)	O
segment	O
->	O
p_offset	O
,	O
SEEK_SET	O
)	O
)	O
error	O
(	O
_	O
(	O
"Unable to find program interpreter name\n"	*(char)
)	O
)	O
;	O
else	O
{	O
char	O
fmt	*(char)
[	O
32	int
]	O
;	O
int	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
snprintf	(*(char),long,*(char))->(int)
(	O
fmt	*(char)
,	O
sizeof	O
(	O
fmt	*(char)
)	O
,	O
"%%%ds"	*(char)
,	O
PATH_MAX	O
-	O
1	int
)	O
;	O
if	O
(	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
>=	O
(	O
int	O
)	O
sizeof	O
(	O
fmt	*(char)
)	O
||	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
<	O
0	int
)	O
error	O
(	O
_	O
(	O
"Internal error: failed to create format string to display program interpreter\n"	*(char)
)	O
)	O
;	O
program_interpreter	O
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
fscanf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
filedata	O
->	O
handle	O
,	O
fmt	*(char)
,	O
program_interpreter	O
)	O
<=	O
0	int
)	O
error	O
(	O
_	O
(	O
"Unable to read program interpreter name\n"	*(char)
)	O
)	O
;	O
if	O
(	O
do_segments	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      [Requesting program interpreter: %s]\n"	*(char)
)	O
,	O
program_interpreter	O
)	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
do_segments	O
&&	O
filedata	O
->	O
section_headers	O
!=	O
NULL	O
&&	O
filedata	O
->	O
string_table	O
!=	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\n Section to Segment mapping:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Segment Sections...\n"	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
;	O
i	*(struct)
++	O
)	O
{	O
unsigned	O
int	O
j	O
;	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
segment	O
=	O
filedata	O
->	O
program_headers	O
+	O
i	*(struct)
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
+	O
1	int
;	O
printf	(*(char))->(int)
(	O
"   %2.2d     "	*(char)
,	O
i	*(struct)
)	O
;	O
for	O
(	O
j	O
=	O
1	int
;	O
j	O
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
j	O
++	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
)	O
{	O
if	O
(	O
!	O
ELF_TBSS_SPECIAL	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
segment	O
)	O
&&	O
ELF_SECTION_IN_SEGMENT_STRICT	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
segment	O
)	O
)	O
printf	(*(char))->(int)
(	O
"%s "	*(char)
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
long	O
offset_from_vma	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_vma	long
vma	long
,	O
bfd_size_type	long
size	int
)	O
{	O
Elf_Internal_Phdr	O
*	O
seg	O
;	O
if	O
(	O
!	O
get_program_headers	O
(	O
filedata	O
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Cannot interpret virtual addresses without program headers.\n"	*(char)
)	O
)	O
;	O
return	O
(	O
long	O
)	O
vma	long
;	O
}	O
for	O
(	O
seg	O
=	O
filedata	O
->	O
program_headers	O
;	O
seg	O
<	O
filedata	O
->	O
program_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
;	O
++	O
seg	O
)	O
{	O
if	O
(	O
seg	O
->	O
p_type	O
!=	O
PT_LOAD	O
)	O
continue	O
;	O
if	O
(	O
vma	long
>=	O
(	O
seg	O
->	O
p_vaddr	O
&	O
-	O
seg	O
->	O
p_align	O
)	O
&&	O
vma	long
+	O
size	int
<=	O
seg	O
->	O
p_vaddr	O
+	O
seg	O
->	O
p_filesz	O
)	O
return	O
vma	long
-	O
seg	O
->	O
p_vaddr	O
+	O
seg	O
->	O
p_offset	O
;	O
}	O
warn	O
(	O
_	O
(	O
"Virtual address 0x%lx not located in any PT_LOAD segment.\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
vma	long
)	O
;	O
return	O
(	O
long	O
)	O
vma	long
;	O
}	O
static	O
bfd_boolean	int
get_32bit_section_headers	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_boolean	int
probe	O
)	O
{	O
Elf32_External_Shdr	O
*	O
shdrs	O
;	O
Elf_Internal_Shdr	O
*	O
internal	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
unsigned	O
int	O
size	int
=	O
filedata	O
->	O
file_header	O
.	O
e_shentsize	O
;	O
unsigned	O
int	O
num	O
=	O
probe	O
?	O
1	int
:	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
if	O
(	O
size	int
==	O
0	int
||	O
num	O
==	O
0	int
)	O
return	O
FALSE	O
;	O
if	O
(	O
size	int
<	O
sizeof	O
*	O
shdrs	O
)	O
{	O
if	O
(	O
!	O
probe	O
)	O
error	O
(	O
_	O
(	O
"The e_shentsize field in the ELF header is less than the size of an ELF section header\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
probe	O
&&	O
size	int
>	O
sizeof	O
*	O
shdrs	O
)	O
warn	O
(	O
_	O
(	O
"The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"	*(char)
)	O
)	O
;	O
shdrs	O
=	O
(	O
Elf32_External_Shdr	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
filedata	O
->	O
file_header	O
.	O
e_shoff	O
,	O
size	int
,	O
num	O
,	O
probe	O
?	O
NULL	O
:	O
_	O
(	O
"section headers"	*(char)
)	O
)	O
;	O
if	O
(	O
shdrs	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
free	(*(void))->(void)
(	O
filedata	O
->	O
section_headers	O
)	O
;	O
filedata	O
->	O
section_headers	O
=	O
(	O
Elf_Internal_Shdr	O
*	O
)	O
cmalloc	O
(	O
num	O
,	O
sizeof	O
(	O
Elf_Internal_Shdr	O
)	O
)	O
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
probe	O
)	O
error	O
(	O
_	O
(	O
"Out of memory reading %u section headers\n"	*(char)
)	O
,	O
num	O
)	O
;	O
free	(*(void))->(void)
(	O
shdrs	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
internal	O
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
num	O
;	O
i	*(struct)
++	O
,	O
internal	O
++	O
)	O
{	O
internal	O
->	O
sh_name	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_name	O
)	O
;	O
internal	O
->	O
sh_type	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_type	O
)	O
;	O
internal	O
->	O
sh_flags	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_flags	O
)	O
;	O
internal	O
->	O
sh_addr	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_addr	O
)	O
;	O
internal	O
->	O
sh_offset	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_offset	O
)	O
;	O
internal	O
->	O
sh_size	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_size	O
)	O
;	O
internal	O
->	O
sh_link	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_link	O
)	O
;	O
internal	O
->	O
sh_info	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_info	O
)	O
;	O
internal	O
->	O
sh_addralign	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_addralign	O
)	O
;	O
internal	O
->	O
sh_entsize	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_entsize	O
)	O
;	O
if	O
(	O
!	O
probe	O
&&	O
internal	O
->	O
sh_link	O
>	O
num	O
)	O
warn	O
(	O
_	O
(	O
"Section %u has an out of range sh_link value of %u\n"	*(char)
)	O
,	O
i	*(struct)
,	O
internal	O
->	O
sh_link	O
)	O
;	O
if	O
(	O
!	O
probe	O
&&	O
internal	O
->	O
sh_flags	O
&	O
SHF_INFO_LINK	O
&&	O
internal	O
->	O
sh_info	O
>	O
num	O
)	O
warn	O
(	O
_	O
(	O
"Section %u has an out of range sh_info value of %u\n"	*(char)
)	O
,	O
i	*(struct)
,	O
internal	O
->	O
sh_info	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
shdrs	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
get_64bit_section_headers	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_boolean	int
probe	O
)	O
{	O
Elf64_External_Shdr	O
*	O
shdrs	O
;	O
Elf_Internal_Shdr	O
*	O
internal	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
unsigned	O
int	O
size	int
=	O
filedata	O
->	O
file_header	O
.	O
e_shentsize	O
;	O
unsigned	O
int	O
num	O
=	O
probe	O
?	O
1	int
:	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
if	O
(	O
size	int
==	O
0	int
||	O
num	O
==	O
0	int
)	O
return	O
FALSE	O
;	O
if	O
(	O
size	int
<	O
sizeof	O
*	O
shdrs	O
)	O
{	O
if	O
(	O
!	O
probe	O
)	O
error	O
(	O
_	O
(	O
"The e_shentsize field in the ELF header is less than the size of an ELF section header\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
probe	O
&&	O
size	int
>	O
sizeof	O
*	O
shdrs	O
)	O
warn	O
(	O
_	O
(	O
"The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"	*(char)
)	O
)	O
;	O
shdrs	O
=	O
(	O
Elf64_External_Shdr	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
filedata	O
->	O
file_header	O
.	O
e_shoff	O
,	O
size	int
,	O
num	O
,	O
probe	O
?	O
NULL	O
:	O
_	O
(	O
"section headers"	*(char)
)	O
)	O
;	O
if	O
(	O
shdrs	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
free	(*(void))->(void)
(	O
filedata	O
->	O
section_headers	O
)	O
;	O
filedata	O
->	O
section_headers	O
=	O
(	O
Elf_Internal_Shdr	O
*	O
)	O
cmalloc	O
(	O
num	O
,	O
sizeof	O
(	O
Elf_Internal_Shdr	O
)	O
)	O
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
probe	O
)	O
error	O
(	O
_	O
(	O
"Out of memory reading %u section headers\n"	*(char)
)	O
,	O
num	O
)	O
;	O
free	(*(void))->(void)
(	O
shdrs	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
internal	O
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
num	O
;	O
i	*(struct)
++	O
,	O
internal	O
++	O
)	O
{	O
internal	O
->	O
sh_name	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_name	O
)	O
;	O
internal	O
->	O
sh_type	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_type	O
)	O
;	O
internal	O
->	O
sh_flags	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_flags	O
)	O
;	O
internal	O
->	O
sh_addr	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_addr	O
)	O
;	O
internal	O
->	O
sh_size	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_size	O
)	O
;	O
internal	O
->	O
sh_entsize	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_entsize	O
)	O
;	O
internal	O
->	O
sh_link	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_link	O
)	O
;	O
internal	O
->	O
sh_info	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_info	O
)	O
;	O
internal	O
->	O
sh_offset	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_offset	O
)	O
;	O
internal	O
->	O
sh_addralign	O
=	O
BYTE_GET	O
(	O
shdrs	O
[	O
i	*(struct)
]	O
.	O
sh_addralign	O
)	O
;	O
if	O
(	O
!	O
probe	O
&&	O
internal	O
->	O
sh_link	O
>	O
num	O
)	O
warn	O
(	O
_	O
(	O
"Section %u has an out of range sh_link value of %u\n"	*(char)
)	O
,	O
i	*(struct)
,	O
internal	O
->	O
sh_link	O
)	O
;	O
if	O
(	O
!	O
probe	O
&&	O
internal	O
->	O
sh_flags	O
&	O
SHF_INFO_LINK	O
&&	O
internal	O
->	O
sh_info	O
>	O
num	O
)	O
warn	O
(	O
_	O
(	O
"Section %u has an out of range sh_info value of %u\n"	*(char)
)	O
,	O
i	*(struct)
,	O
internal	O
->	O
sh_info	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
shdrs	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
Elf_Internal_Sym	O
*	O
get_32bit_elf_symbols	O
(	O
Filedata	O
*	O
filedata	O
,	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
unsigned	O
long	O
*	O
num_syms_return	O
)	O
{	O
unsigned	O
long	O
number	O
=	O
0	int
;	O
Elf32_External_Sym	O
*	O
esyms	O
=	O
NULL	O
;	O
Elf_External_Sym_Shndx	O
*	O
shndx	O
=	O
NULL	O
;	O
Elf_Internal_Sym	O
*	O
isyms	O
=	O
NULL	O
;	O
Elf_Internal_Sym	O
*	O
psym	O
;	O
unsigned	O
int	O
j	O
;	O
elf_section_list	O
*	O
entry	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
==	O
0	int
)	O
{	O
if	O
(	O
num_syms_return	O
!=	O
NULL	O
)	O
*	O
num_syms_return	O
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
==	O
0	int
||	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
>	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Section %s has an invalid sh_entsize of 0x%lx\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
)	O
;	O
goto	O
exit_point	O
;	O
}	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
>	O
filedata	O
->	O
file_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Section %s has an invalid sh_size of 0x%lx\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
;	O
goto	O
exit_point	O
;	O
}	O
number	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
/	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
;	O
if	O
(	O
number	O
*	O
sizeof	O
(	O
Elf32_External_Sym	O
)	O
>	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
+	O
1	int
)	O
{	O
error	O
(	O
_	O
(	O
"Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
)	O
;	O
goto	O
exit_point	O
;	O
}	O
esyms	O
=	O
(	O
Elf32_External_Sym	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
_	O
(	O
"symbols"	*(char)
)	O
)	O
;	O
if	O
(	O
esyms	O
==	O
NULL	O
)	O
goto	O
exit_point	O
;	O
shndx	O
=	O
NULL	O
;	O
for	O
(	O
entry	O
=	O
symtab_shndx_list	O
;	O
entry	O
!=	O
NULL	O
;	O
entry	O
=	O
entry	O
->	O
next	*(char)
)	O
{	O
if	O
(	O
entry	O
->	O
hdr	O
->	O
sh_link	O
!=	O
(	O
unsigned	O
long	O
)	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
-	O
filedata	O
->	O
section_headers	O
)	O
)	O
continue	O
;	O
if	O
(	O
shndx	O
!=	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Multiple symbol table index sections associated with the same symbol section\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
shndx	O
)	O
;	O
}	O
shndx	O
=	O
(	O
Elf_External_Sym_Shndx	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
entry	O
->	O
hdr	O
->	O
sh_offset	O
,	O
1	int
,	O
entry	O
->	O
hdr	O
->	O
sh_size	O
,	O
_	O
(	O
"symbol table section indices"	*(char)
)	O
)	O
;	O
if	O
(	O
shndx	O
==	O
NULL	O
)	O
goto	O
exit_point	O
;	O
if	O
(	O
entry	O
->	O
hdr	O
->	O
sh_size	O
/	O
sizeof	O
(	O
Elf_External_Sym_Shndx	O
)	O
<	O
number	O
)	O
{	O
error	O
(	O
_	O
(	O
"Index section %s has an sh_size of 0x%lx - expected 0x%lx\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
entry	O
->	O
hdr	O
)	O
,	O
(	O
unsigned	O
long	O
)	O
entry	O
->	O
hdr	O
->	O
sh_size	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
;	O
goto	O
exit_point	O
;	O
}	O
}	O
isyms	O
=	O
(	O
Elf_Internal_Sym	O
*	O
)	O
cmalloc	O
(	O
number	O
,	O
sizeof	O
(	O
Elf_Internal_Sym	O
)	O
)	O
;	O
if	O
(	O
isyms	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory reading %lu symbols\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
number	O
)	O
;	O
goto	O
exit_point	O
;	O
}	O
for	O
(	O
j	O
=	O
0	int
,	O
psym	O
=	O
isyms	O
;	O
j	O
<	O
number	O
;	O
j	O
++	O
,	O
psym	O
++	O
)	O
{	O
psym	O
->	O
st_name	O
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_name	O
)	O
;	O
psym	O
->	O
st_value	O
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_value	O
)	O
;	O
psym	O
->	O
st_size	long
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_size	long
)	O
;	O
psym	O
->	O
st_shndx	O
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_shndx	O
)	O
;	O
if	O
(	O
psym	O
->	O
st_shndx	O
==	O
(	O
SHN_XINDEX	O
&	O
0xffff	int
)	O
&&	O
shndx	O
!=	O
NULL	O
)	O
psym	O
->	O
st_shndx	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
shndx	O
[	O
j	O
]	O
,	O
sizeof	O
(	O
shndx	O
[	O
j	O
]	O
)	O
)	O
;	O
else	O
if	O
(	O
psym	O
->	O
st_shndx	O
>=	O
(	O
SHN_LORESERVE	O
&	O
0xffff	int
)	O
)	O
psym	O
->	O
st_shndx	O
+=	O
SHN_LORESERVE	O
-	O
(	O
SHN_LORESERVE	O
&	O
0xffff	int
)	O
;	O
psym	O
->	O
st_info	O
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_info	O
)	O
;	O
psym	O
->	O
st_other	O
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_other	O
)	O
;	O
}	O
exit_point	O
:	O
free	(*(void))->(void)
(	O
shndx	O
)	O
;	O
free	(*(void))->(void)
(	O
esyms	O
)	O
;	O
if	O
(	O
num_syms_return	O
!=	O
NULL	O
)	O
*	O
num_syms_return	O
=	O
isyms	O
==	O
NULL	O
?	O
0	int
:	O
number	O
;	O
return	O
isyms	O
;	O
}	O
static	O
Elf_Internal_Sym	O
*	O
get_64bit_elf_symbols	O
(	O
Filedata	O
*	O
filedata	O
,	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
unsigned	O
long	O
*	O
num_syms_return	O
)	O
{	O
unsigned	O
long	O
number	O
=	O
0	int
;	O
Elf64_External_Sym	O
*	O
esyms	O
=	O
NULL	O
;	O
Elf_External_Sym_Shndx	O
*	O
shndx	O
=	O
NULL	O
;	O
Elf_Internal_Sym	O
*	O
isyms	O
=	O
NULL	O
;	O
Elf_Internal_Sym	O
*	O
psym	O
;	O
unsigned	O
int	O
j	O
;	O
elf_section_list	O
*	O
entry	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
==	O
0	int
)	O
{	O
if	O
(	O
num_syms_return	O
!=	O
NULL	O
)	O
*	O
num_syms_return	O
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
==	O
0	int
||	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
>	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Section %s has an invalid sh_entsize of 0x%lx\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
)	O
;	O
goto	O
exit_point	O
;	O
}	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
>	O
filedata	O
->	O
file_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Section %s has an invalid sh_size of 0x%lx\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
;	O
goto	O
exit_point	O
;	O
}	O
number	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
/	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
;	O
if	O
(	O
number	O
*	O
sizeof	O
(	O
Elf64_External_Sym	O
)	O
>	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
+	O
1	int
)	O
{	O
error	O
(	O
_	O
(	O
"Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
)	O
;	O
goto	O
exit_point	O
;	O
}	O
esyms	O
=	O
(	O
Elf64_External_Sym	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
_	O
(	O
"symbols"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
esyms	O
)	O
goto	O
exit_point	O
;	O
shndx	O
=	O
NULL	O
;	O
for	O
(	O
entry	O
=	O
symtab_shndx_list	O
;	O
entry	O
!=	O
NULL	O
;	O
entry	O
=	O
entry	O
->	O
next	*(char)
)	O
{	O
if	O
(	O
entry	O
->	O
hdr	O
->	O
sh_link	O
!=	O
(	O
unsigned	O
long	O
)	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
-	O
filedata	O
->	O
section_headers	O
)	O
)	O
continue	O
;	O
if	O
(	O
shndx	O
!=	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Multiple symbol table index sections associated with the same symbol section\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
shndx	O
)	O
;	O
}	O
shndx	O
=	O
(	O
Elf_External_Sym_Shndx	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
entry	O
->	O
hdr	O
->	O
sh_offset	O
,	O
1	int
,	O
entry	O
->	O
hdr	O
->	O
sh_size	O
,	O
_	O
(	O
"symbol table section indices"	*(char)
)	O
)	O
;	O
if	O
(	O
shndx	O
==	O
NULL	O
)	O
goto	O
exit_point	O
;	O
if	O
(	O
entry	O
->	O
hdr	O
->	O
sh_size	O
/	O
sizeof	O
(	O
Elf_External_Sym_Shndx	O
)	O
<	O
number	O
)	O
{	O
error	O
(	O
_	O
(	O
"Index section %s has an sh_size of 0x%lx - expected 0x%lx\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
entry	O
->	O
hdr	O
)	O
,	O
(	O
unsigned	O
long	O
)	O
entry	O
->	O
hdr	O
->	O
sh_size	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
;	O
goto	O
exit_point	O
;	O
}	O
}	O
isyms	O
=	O
(	O
Elf_Internal_Sym	O
*	O
)	O
cmalloc	O
(	O
number	O
,	O
sizeof	O
(	O
Elf_Internal_Sym	O
)	O
)	O
;	O
if	O
(	O
isyms	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory reading %lu symbols\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
number	O
)	O
;	O
goto	O
exit_point	O
;	O
}	O
for	O
(	O
j	O
=	O
0	int
,	O
psym	O
=	O
isyms	O
;	O
j	O
<	O
number	O
;	O
j	O
++	O
,	O
psym	O
++	O
)	O
{	O
psym	O
->	O
st_name	O
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_name	O
)	O
;	O
psym	O
->	O
st_info	O
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_info	O
)	O
;	O
psym	O
->	O
st_other	O
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_other	O
)	O
;	O
psym	O
->	O
st_shndx	O
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_shndx	O
)	O
;	O
if	O
(	O
psym	O
->	O
st_shndx	O
==	O
(	O
SHN_XINDEX	O
&	O
0xffff	int
)	O
&&	O
shndx	O
!=	O
NULL	O
)	O
psym	O
->	O
st_shndx	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
shndx	O
[	O
j	O
]	O
,	O
sizeof	O
(	O
shndx	O
[	O
j	O
]	O
)	O
)	O
;	O
else	O
if	O
(	O
psym	O
->	O
st_shndx	O
>=	O
(	O
SHN_LORESERVE	O
&	O
0xffff	int
)	O
)	O
psym	O
->	O
st_shndx	O
+=	O
SHN_LORESERVE	O
-	O
(	O
SHN_LORESERVE	O
&	O
0xffff	int
)	O
;	O
psym	O
->	O
st_value	O
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_value	O
)	O
;	O
psym	O
->	O
st_size	long
=	O
BYTE_GET	O
(	O
esyms	O
[	O
j	O
]	O
.	O
st_size	long
)	O
;	O
}	O
exit_point	O
:	O
free	(*(void))->(void)
(	O
shndx	O
)	O
;	O
free	(*(void))->(void)
(	O
esyms	O
)	O
;	O
if	O
(	O
num_syms_return	O
!=	O
NULL	O
)	O
*	O
num_syms_return	O
=	O
isyms	O
==	O
NULL	O
?	O
0	int
:	O
number	O
;	O
return	O
isyms	O
;	O
}	O
static	O
const	O
char	O
*	O
get_elf_section_flags	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_vma	long
sh_flags	O
)	O
{	O
static	O
char	O
buff	O
[	O
1024	int
]	O
;	O
char	O
*	O
p	*(void)
=	O
buff	O
;	O
unsigned	O
int	O
field_size	O
=	O
is_32bit_elf	O
?	O
8	int
:	O
16	int
;	O
signed	O
int	O
sindex	O
;	O
unsigned	O
int	O
size	int
=	O
sizeof	O
(	O
buff	O
)	O
-	O
(	O
field_size	O
+	O
4	int
+	O
1	int
)	O
;	O
bfd_vma	long
os_flags	O
=	O
0	int
;	O
bfd_vma	long
proc_flags	O
=	O
0	int
;	O
bfd_vma	long
unknown_flags	O
=	O
0	int
;	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
str	O
;	O
unsigned	O
int	O
len	int
;	O
}	O
flags	int
[	O
]	O
=	O
{	O
{	O
STRING_COMMA_LEN	O
(	O
"WRITE"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"ALLOC"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"EXEC"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"MERGE"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"STRINGS"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"INFO LINK"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"LINK ORDER"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"OS NONCONF"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"GROUP"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"TLS"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"SHORT"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"NORECOV"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_GLOBAL"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_OVERLAID"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_SHARED"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_VECTOR"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_ALLOC_64BIT"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VMS_PROTECTED"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"EXCLUDE"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"ORDERED"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"COMPRESSED"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"ENTRYSECT"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"ARM_PURECODE"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"COMDEF"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"GNU_MBIND"	*(char)
)	O
}	O
,	O
{	O
STRING_COMMA_LEN	O
(	O
"VLE"	*(char)
)	O
}	O
,	O
}	O
;	O
if	O
(	O
do_section_details	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
"[%*.*lx]: "	*(char)
,	O
field_size	O
,	O
field_size	O
,	O
(	O
unsigned	O
long	O
)	O
sh_flags	O
)	O
;	O
p	*(void)
+=	O
field_size	O
+	O
4	int
;	O
}	O
while	O
(	O
sh_flags	O
)	O
{	O
bfd_vma	long
flag	O
;	O
flag	O
=	O
sh_flags	O
&	O
-	O
sh_flags	O
;	O
sh_flags	O
&=	O
~	O
flag	O
;	O
if	O
(	O
do_section_details	O
)	O
{	O
switch	O
(	O
flag	O
)	O
{	O
case	O
SHF_WRITE	O
:	O
sindex	O
=	O
0	int
;	O
break	O
;	O
case	O
SHF_ALLOC	O
:	O
sindex	O
=	O
1	int
;	O
break	O
;	O
case	O
SHF_EXECINSTR	O
:	O
sindex	O
=	O
2	int
;	O
break	O
;	O
case	O
SHF_MERGE	O
:	O
sindex	O
=	O
3	int
;	O
break	O
;	O
case	O
SHF_STRINGS	O
:	O
sindex	O
=	O
4	int
;	O
break	O
;	O
case	O
SHF_INFO_LINK	O
:	O
sindex	O
=	O
5	int
;	O
break	O
;	O
case	O
SHF_LINK_ORDER	O
:	O
sindex	O
=	O
6	int
;	O
break	O
;	O
case	O
SHF_OS_NONCONFORMING	O
:	O
sindex	O
=	O
7	int
;	O
break	O
;	O
case	O
SHF_GROUP	O
:	O
sindex	O
=	O
8	int
;	O
break	O
;	O
case	O
SHF_TLS	O
:	O
sindex	O
=	O
9	int
;	O
break	O
;	O
case	O
SHF_EXCLUDE	O
:	O
sindex	O
=	O
18	int
;	O
break	O
;	O
case	O
SHF_COMPRESSED	O
:	O
sindex	O
=	O
20	int
;	O
break	O
;	O
case	O
SHF_GNU_MBIND	O
:	O
sindex	O
=	O
24	int
;	O
break	O
;	O
default	O
:	O
sindex	O
=	O
-	O
1	int
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_IA_64	O
:	O
if	O
(	O
flag	O
==	O
SHF_IA_64_SHORT	O
)	O
sindex	O
=	O
10	int
;	O
else	O
if	O
(	O
flag	O
==	O
SHF_IA_64_NORECOV	O
)	O
sindex	O
=	O
11	int
;	O
else	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_OPENVMS	O
)	O
switch	O
(	O
flag	O
)	O
{	O
case	O
SHF_IA_64_VMS_GLOBAL	O
:	O
sindex	O
=	O
12	int
;	O
break	O
;	O
case	O
SHF_IA_64_VMS_OVERLAID	O
:	O
sindex	O
=	O
13	int
;	O
break	O
;	O
case	O
SHF_IA_64_VMS_SHARED	O
:	O
sindex	O
=	O
14	int
;	O
break	O
;	O
case	O
SHF_IA_64_VMS_VECTOR	O
:	O
sindex	O
=	O
15	int
;	O
break	O
;	O
case	O
SHF_IA_64_VMS_ALLOC_64BIT	O
:	O
sindex	O
=	O
16	int
;	O
break	O
;	O
case	O
SHF_IA_64_VMS_PROTECTED	O
:	O
sindex	O
=	O
17	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_386	O
:	O
case	O
EM_IAMCU	O
:	O
case	O
EM_X86_64	O
:	O
case	O
EM_L1OM	O
:	O
case	O
EM_K1OM	O
:	O
case	O
EM_OLD_SPARCV9	O
:	O
case	O
EM_SPARC32PLUS	O
:	O
case	O
EM_SPARCV9	O
:	O
case	O
EM_SPARC	O
:	O
if	O
(	O
flag	O
==	O
SHF_ORDERED	O
)	O
sindex	O
=	O
19	int
;	O
break	O
;	O
case	O
EM_ARM	O
:	O
switch	O
(	O
flag	O
)	O
{	O
case	O
SHF_ENTRYSECT	O
:	O
sindex	O
=	O
21	int
;	O
break	O
;	O
case	O
SHF_ARM_PURECODE	O
:	O
sindex	O
=	O
22	int
;	O
break	O
;	O
case	O
SHF_COMDEF	O
:	O
sindex	O
=	O
23	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_PPC	O
:	O
if	O
(	O
flag	O
==	O
SHF_PPC_VLE	O
)	O
sindex	O
=	O
25	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
sindex	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
p	*(void)
!=	O
buff	O
+	O
field_size	O
+	O
4	int
)	O
{	O
if	O
(	O
size	int
<	O
(	O
10	int
+	O
2	int
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Internal error: not enough buffer room for section flag info"	*(char)
)	O
)	O
;	O
return	O
_	O
(	O
"<unknown>"	*(char)
)	O
;	O
}	O
size	int
-=	O
2	int
;	O
*	O
p	*(void)
++	O
=	O
','	O
;	O
*	O
p	*(void)
++	O
=	O
' '	O
;	O
}	O
size	int
-=	O
flags	int
[	O
sindex	O
]	O
.	O
len	int
;	O
p	*(void)
=	O
stpcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
flags	int
[	O
sindex	O
]	O
.	O
str	O
)	O
;	O
}	O
else	O
if	O
(	O
flag	O
&	O
SHF_MASKOS	O
)	O
os_flags	O
|=	O
flag	O
;	O
else	O
if	O
(	O
flag	O
&	O
SHF_MASKPROC	O
)	O
proc_flags	O
|=	O
flag	O
;	O
else	O
unknown_flags	O
|=	O
flag	O
;	O
}	O
else	O
{	O
switch	O
(	O
flag	O
)	O
{	O
case	O
SHF_WRITE	O
:	O
*	O
p	*(void)
=	O
'W'	O
;	O
break	O
;	O
case	O
SHF_ALLOC	O
:	O
*	O
p	*(void)
=	O
'A'	O
;	O
break	O
;	O
case	O
SHF_EXECINSTR	O
:	O
*	O
p	*(void)
=	O
'X'	O
;	O
break	O
;	O
case	O
SHF_MERGE	O
:	O
*	O
p	*(void)
=	O
'M'	O
;	O
break	O
;	O
case	O
SHF_STRINGS	O
:	O
*	O
p	*(void)
=	O
'S'	O
;	O
break	O
;	O
case	O
SHF_INFO_LINK	O
:	O
*	O
p	*(void)
=	O
'I'	O
;	O
break	O
;	O
case	O
SHF_LINK_ORDER	O
:	O
*	O
p	*(void)
=	O
'L'	O
;	O
break	O
;	O
case	O
SHF_OS_NONCONFORMING	O
:	O
*	O
p	*(void)
=	O
'O'	O
;	O
break	O
;	O
case	O
SHF_GROUP	O
:	O
*	O
p	*(void)
=	O
'G'	O
;	O
break	O
;	O
case	O
SHF_TLS	O
:	O
*	O
p	*(void)
=	O
'T'	O
;	O
break	O
;	O
case	O
SHF_EXCLUDE	O
:	O
*	O
p	*(void)
=	O
'E'	O
;	O
break	O
;	O
case	O
SHF_COMPRESSED	O
:	O
*	O
p	*(void)
=	O
'C'	O
;	O
break	O
;	O
case	O
SHF_GNU_MBIND	O
:	O
*	O
p	*(void)
=	O
'D'	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_X86_64	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_L1OM	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_K1OM	O
)	O
&&	O
flag	O
==	O
SHF_X86_64_LARGE	O
)	O
*	O
p	*(void)
=	O
'l'	O
;	O
else	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_ARM	O
&&	O
flag	O
==	O
SHF_ARM_PURECODE	O
)	O
*	O
p	*(void)
=	O
'y'	O
;	O
else	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_PPC	O
&&	O
flag	O
==	O
SHF_PPC_VLE	O
)	O
*	O
p	*(void)
=	O
'v'	O
;	O
else	O
if	O
(	O
flag	O
&	O
SHF_MASKOS	O
)	O
{	O
*	O
p	*(void)
=	O
'o'	O
;	O
sh_flags	O
&=	O
~	O
SHF_MASKOS	O
;	O
}	O
else	O
if	O
(	O
flag	O
&	O
SHF_MASKPROC	O
)	O
{	O
*	O
p	*(void)
=	O
'p'	O
;	O
sh_flags	O
&=	O
~	O
SHF_MASKPROC	O
;	O
}	O
else	O
*	O
p	*(void)
=	O
'x'	O
;	O
break	O
;	O
}	O
p	*(void)
++	O
;	O
}	O
}	O
if	O
(	O
do_section_details	O
)	O
{	O
if	O
(	O
os_flags	O
)	O
{	O
size	int
-=	O
5	int
+	O
field_size	O
;	O
if	O
(	O
p	*(void)
!=	O
buff	O
+	O
field_size	O
+	O
4	int
)	O
{	O
if	O
(	O
size	int
<	O
(	O
2	int
+	O
1	int
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Internal error: not enough buffer room for section flag info"	*(char)
)	O
)	O
;	O
return	O
_	O
(	O
"<unknown>"	*(char)
)	O
;	O
}	O
size	int
-=	O
2	int
;	O
*	O
p	*(void)
++	O
=	O
','	O
;	O
*	O
p	*(void)
++	O
=	O
' '	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"OS (%*.*lx)"	*(char)
,	O
field_size	O
,	O
field_size	O
,	O
(	O
unsigned	O
long	O
)	O
os_flags	O
)	O
;	O
p	*(void)
+=	O
5	int
+	O
field_size	O
;	O
}	O
if	O
(	O
proc_flags	O
)	O
{	O
size	int
-=	O
7	int
+	O
field_size	O
;	O
if	O
(	O
p	*(void)
!=	O
buff	O
+	O
field_size	O
+	O
4	int
)	O
{	O
if	O
(	O
size	int
<	O
(	O
2	int
+	O
1	int
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Internal error: not enough buffer room for section flag info"	*(char)
)	O
)	O
;	O
return	O
_	O
(	O
"<unknown>"	*(char)
)	O
;	O
}	O
size	int
-=	O
2	int
;	O
*	O
p	*(void)
++	O
=	O
','	O
;	O
*	O
p	*(void)
++	O
=	O
' '	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
"PROC (%*.*lx)"	*(char)
,	O
field_size	O
,	O
field_size	O
,	O
(	O
unsigned	O
long	O
)	O
proc_flags	O
)	O
;	O
p	*(void)
+=	O
7	int
+	O
field_size	O
;	O
}	O
if	O
(	O
unknown_flags	O
)	O
{	O
size	int
-=	O
10	int
+	O
field_size	O
;	O
if	O
(	O
p	*(void)
!=	O
buff	O
+	O
field_size	O
+	O
4	int
)	O
{	O
if	O
(	O
size	int
<	O
(	O
2	int
+	O
1	int
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Internal error: not enough buffer room for section flag info"	*(char)
)	O
)	O
;	O
return	O
_	O
(	O
"<unknown>"	*(char)
)	O
;	O
}	O
size	int
-=	O
2	int
;	O
*	O
p	*(void)
++	O
=	O
','	O
;	O
*	O
p	*(void)
++	O
=	O
' '	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
p	*(void)
,	O
_	O
(	O
"UNKNOWN (%*.*lx)"	*(char)
)	O
,	O
field_size	O
,	O
field_size	O
,	O
(	O
unsigned	O
long	O
)	O
unknown_flags	O
)	O
;	O
p	*(void)
+=	O
10	int
+	O
field_size	O
;	O
}	O
}	O
*	O
p	*(void)
=	O
'\0'	O
;	O
return	O
buff	O
;	O
}	O
static	O
unsigned	O
int	O
get_compression_header	O
(	O
Elf_Internal_Chdr	O
*	O
chdr	O
,	O
unsigned	O
char	O
*	O
buf	*(void)
,	O
bfd_size_type	long
size	int
)	O
{	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
Elf32_External_Chdr	O
*	O
echdr	O
=	O
(	O
Elf32_External_Chdr	O
*	O
)	O
buf	*(void)
;	O
if	O
(	O
size	int
<	O
sizeof	O
(	O
*	O
echdr	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"Compressed section is too small even for a compression header\n"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
chdr	O
->	O
ch_type	O
=	O
BYTE_GET	O
(	O
echdr	O
->	O
ch_type	O
)	O
;	O
chdr	O
->	O
ch_size	O
=	O
BYTE_GET	O
(	O
echdr	O
->	O
ch_size	O
)	O
;	O
chdr	O
->	O
ch_addralign	O
=	O
BYTE_GET	O
(	O
echdr	O
->	O
ch_addralign	O
)	O
;	O
return	O
sizeof	O
(	O
*	O
echdr	O
)	O
;	O
}	O
else	O
{	O
Elf64_External_Chdr	O
*	O
echdr	O
=	O
(	O
Elf64_External_Chdr	O
*	O
)	O
buf	*(void)
;	O
if	O
(	O
size	int
<	O
sizeof	O
(	O
*	O
echdr	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"Compressed section is too small even for a compression header\n"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
chdr	O
->	O
ch_type	O
=	O
BYTE_GET	O
(	O
echdr	O
->	O
ch_type	O
)	O
;	O
chdr	O
->	O
ch_size	O
=	O
BYTE_GET	O
(	O
echdr	O
->	O
ch_size	O
)	O
;	O
chdr	O
->	O
ch_addralign	O
=	O
BYTE_GET	O
(	O
echdr	O
->	O
ch_addralign	O
)	O
;	O
return	O
sizeof	O
(	O
*	O
echdr	O
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
process_section_headers	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
unsigned	O
int	O
i	*(struct)
;	O
filedata	O
->	O
section_headers	O
=	O
NULL	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
==	O
0	int
)	O
{	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_shoff	O
!=	O
0	int
)	O
{	O
warn	O
(	O
_	O
(	O
"possibly corrupt ELF file header - it has a non-zero"	*(char)
" section header offset, but no section headers\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
do_sections	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThere are no sections in this file.\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
do_sections	O
&&	O
!	O
do_header	O
)	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"There is %d section header, "	*(char)
"starting at offset 0x%lx:\n"	*(char)
,	O
"There are %d section headers, "	*(char)
"starting at offset 0x%lx:\n"	*(char)
,	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
,	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
,	O
(	O
unsigned	O
long	O
)	O
filedata	O
->	O
file_header	O
.	O
e_shoff	O
)	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
if	O
(	O
!	O
get_32bit_section_headers	O
(	O
filedata	O
,	O
FALSE	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
get_64bit_section_headers	O
(	O
filedata	O
,	O
FALSE	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_shstrndx	O
!=	O
SHN_UNDEF	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_shstrndx	O
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_shstrndx	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
!=	O
0	int
)	O
{	O
filedata	O
->	O
string_table	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
_	O
(	O
"string table"	*(char)
)	O
)	O
;	O
filedata	O
->	O
string_table_length	O
=	O
filedata	O
->	O
string_table	O
!=	O
NULL	O
?	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
:	O
0	int
;	O
}	O
}	O
dynamic_symbols	O
=	O
NULL	O
;	O
dynamic_strings	O
=	O
NULL	O
;	O
dynamic_syminfo	O
=	O
NULL	O
;	O
symtab_shndx_list	O
=	O
NULL	O
;	O
eh_addr_size	O
=	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_MIPS	O
:	O
case	O
EM_MIPS_RS3_LE	O
:	O
if	O
(	O
(	O
filedata	O
->	O
file_header	O
.	O
e_flags	O
&	O
EF_MIPS_ABI	O
)	O
==	O
E_MIPS_ABI_EABI64	O
&&	O
find_section	O
(	O
filedata	O
,	O
".gcc_compiled_long32"	*(char)
)	O
==	O
NULL	O
)	O
eh_addr_size	O
=	O
8	int
;	O
break	O
;	O
case	O
EM_H8_300	O
:	O
case	O
EM_H8_300H	O
:	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_flags	O
&	O
EF_H8_MACH	O
)	O
{	O
case	O
E_H8_MACH_H8300	O
:	O
case	O
E_H8_MACH_H8300HN	O
:	O
case	O
E_H8_MACH_H8300SN	O
:	O
case	O
E_H8_MACH_H8300SXN	O
:	O
eh_addr_size	O
=	O
2	int
;	O
break	O
;	O
case	O
E_H8_MACH_H8300H	O
:	O
case	O
E_H8_MACH_H8300S	O
:	O
case	O
E_H8_MACH_H8300SX	O
:	O
eh_addr_size	O
=	O
4	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_M32C_OLD	O
:	O
case	O
EM_M32C	O
:	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_flags	O
&	O
EF_M32C_CPU_MASK	O
)	O
{	O
case	O
EF_M32C_CPU_M16C	O
:	O
eh_addr_size	O
=	O
2	int
;	O
break	O
;	O
}	O
break	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
)	O
{	O
char	O
*	O
name	*(char)
=	O
SECTION_NAME	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_DYNSYM	O
)	O
{	O
if	O
(	O
dynamic_symbols	O
!=	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"File contains multiple dynamic symbol tables\n"	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
CHECK_ENTSIZE	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
i	*(struct)
,	O
Sym	O
)	O
;	O
dynamic_symbols	O
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
&	O
num_dynamic_syms	O
)	O
;	O
}	O
else	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_STRTAB	O
&&	O
streq	O
(	O
name	*(char)
,	O
".dynstr"	*(char)
)	O
)	O
{	O
if	O
(	O
dynamic_strings	O
!=	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"File contains multiple dynamic string tables\n"	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
dynamic_strings	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
_	O
(	O
"dynamic strings"	*(char)
)	O
)	O
;	O
dynamic_strings_length	O
=	O
dynamic_strings	O
==	O
NULL	O
?	O
0	int
:	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
}	O
else	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_SYMTAB_SHNDX	O
)	O
{	O
elf_section_list	O
*	O
entry	O
=	O
xmalloc	O
(	O
sizeof	O
*	O
entry	O
)	O
;	O
entry	O
->	O
hdr	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
entry	O
->	O
next	*(char)
=	O
symtab_shndx_list	O
;	O
symtab_shndx_list	O
=	O
entry	O
;	O
}	O
else	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_SYMTAB	O
)	O
CHECK_ENTSIZE	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
i	*(struct)
,	O
Sym	O
)	O
;	O
else	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_GROUP	O
)	O
CHECK_ENTSIZE_VALUES	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
i	*(struct)
,	O
GRP_ENTRY_SIZE	O
,	O
GRP_ENTRY_SIZE	O
)	O
;	O
else	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_REL	O
)	O
CHECK_ENTSIZE	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
i	*(struct)
,	O
Rel	O
)	O
;	O
else	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_RELA	O
)	O
CHECK_ENTSIZE	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
i	*(struct)
,	O
Rela	O
)	O
;	O
else	O
if	O
(	O
(	O
do_debugging	O
||	O
do_debug_info	O
||	O
do_debug_abbrevs	O
||	O
do_debug_lines	O
||	O
do_debug_pubnames	O
||	O
do_debug_pubtypes	O
||	O
do_debug_aranges	O
||	O
do_debug_frames	O
||	O
do_debug_macinfo	O
||	O
do_debug_str	O
||	O
do_debug_loc	O
||	O
do_debug_ranges	O
||	O
do_debug_addr	O
||	O
do_debug_cu_index	O
||	O
do_debug_links	O
)	O
&&	O
(	O
const_strneq	O
(	O
name	*(char)
,	O
".debug_"	*(char)
)	O
||	O
const_strneq	O
(	O
name	*(char)
,	O
".zdebug_"	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
name	*(char)
[	O
1	int
]	O
==	O
'z'	O
)	O
name	*(char)
+=	O
sizeof	O
(	O
".zdebug_"	*(char)
)	O
-	O
1	int
;	O
else	O
name	*(char)
+=	O
sizeof	O
(	O
".debug_"	*(char)
)	O
-	O
1	int
;	O
if	O
(	O
do_debugging	O
||	O
(	O
do_debug_info	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"info"	*(char)
)	O
)	O
||	O
(	O
do_debug_info	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"types"	*(char)
)	O
)	O
||	O
(	O
do_debug_abbrevs	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"abbrev"	*(char)
)	O
)	O
||	O
(	O
do_debug_lines	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"line"	*(char)
)	O
==	O
0	int
)	O
||	O
(	O
do_debug_lines	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"line."	*(char)
)	O
)	O
||	O
(	O
do_debug_pubnames	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"pubnames"	*(char)
)	O
)	O
||	O
(	O
do_debug_pubtypes	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"pubtypes"	*(char)
)	O
)	O
||	O
(	O
do_debug_pubnames	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"gnu_pubnames"	*(char)
)	O
)	O
||	O
(	O
do_debug_pubtypes	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"gnu_pubtypes"	*(char)
)	O
)	O
||	O
(	O
do_debug_aranges	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"aranges"	*(char)
)	O
)	O
||	O
(	O
do_debug_ranges	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"ranges"	*(char)
)	O
)	O
||	O
(	O
do_debug_ranges	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"rnglists"	*(char)
)	O
)	O
||	O
(	O
do_debug_frames	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"frame"	*(char)
)	O
)	O
||	O
(	O
do_debug_macinfo	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"macinfo"	*(char)
)	O
)	O
||	O
(	O
do_debug_macinfo	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"macro"	*(char)
)	O
)	O
||	O
(	O
do_debug_str	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"str"	*(char)
)	O
)	O
||	O
(	O
do_debug_loc	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"loc"	*(char)
)	O
)	O
||	O
(	O
do_debug_loc	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"loclists"	*(char)
)	O
)	O
||	O
(	O
do_debug_addr	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"addr"	*(char)
)	O
)	O
||	O
(	O
do_debug_cu_index	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"cu_index"	*(char)
)	O
)	O
||	O
(	O
do_debug_cu_index	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
"tu_index"	*(char)
)	O
)	O
)	O
request_dump_bynumber	O
(	O
filedata	O
,	O
i	*(struct)
,	O
DEBUG_DUMP	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
do_debugging	O
||	O
do_debug_info	O
)	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
".gnu.linkonce.wi."	*(char)
)	O
)	O
request_dump_bynumber	O
(	O
filedata	O
,	O
i	*(struct)
,	O
DEBUG_DUMP	O
)	O
;	O
else	O
if	O
(	O
do_debug_frames	O
&&	O
streq	O
(	O
name	*(char)
,	O
".eh_frame"	*(char)
)	O
)	O
request_dump_bynumber	O
(	O
filedata	O
,	O
i	*(struct)
,	O
DEBUG_DUMP	O
)	O
;	O
else	O
if	O
(	O
do_gdb_index	O
&&	O
(	O
streq	O
(	O
name	*(char)
,	O
".gdb_index"	*(char)
)	O
||	O
streq	O
(	O
name	*(char)
,	O
".debug_names"	*(char)
)	O
)	O
)	O
request_dump_bynumber	O
(	O
filedata	O
,	O
i	*(struct)
,	O
DEBUG_DUMP	O
)	O
;	O
else	O
if	O
(	O
(	O
do_debugging	O
||	O
do_trace_info	O
||	O
do_trace_abbrevs	O
||	O
do_trace_aranges	O
)	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
".trace_"	*(char)
)	O
)	O
{	O
name	*(char)
+=	O
sizeof	O
(	O
".trace_"	*(char)
)	O
-	O
1	int
;	O
if	O
(	O
do_debugging	O
||	O
(	O
do_trace_info	O
&&	O
streq	O
(	O
name	*(char)
,	O
"info"	*(char)
)	O
)	O
||	O
(	O
do_trace_abbrevs	O
&&	O
streq	O
(	O
name	*(char)
,	O
"abbrev"	*(char)
)	O
)	O
||	O
(	O
do_trace_aranges	O
&&	O
streq	O
(	O
name	*(char)
,	O
"aranges"	*(char)
)	O
)	O
)	O
request_dump_bynumber	O
(	O
filedata	O
,	O
i	*(struct)
,	O
DEBUG_DUMP	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
do_debugging	O
||	O
do_debug_links	O
)	O
&&	O
(	O
const_strneq	O
(	O
name	*(char)
,	O
".gnu_debuglink"	*(char)
)	O
||	O
const_strneq	O
(	O
name	*(char)
,	O
".gnu_debugaltlink"	*(char)
)	O
)	O
)	O
request_dump_bynumber	O
(	O
filedata	O
,	O
i	*(struct)
,	O
DEBUG_DUMP	O
)	O
;	O
}	O
if	O
(	O
!	O
do_sections	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
>	O
1	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nSection Headers:\n"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nSection Header:\n"	*(char)
)	O
)	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
if	O
(	O
do_section_details	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  [Nr] Name\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"       Type            Addr     Off    Size   ES   Lk Inf Al\n"	*(char)
)	O
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
do_wide	O
)	O
{	O
if	O
(	O
do_section_details	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  [Nr] Name\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"       Type            Address          Off    Size   ES   Lk Inf Al\n"	*(char)
)	O
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
do_section_details	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  [Nr] Name\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"       Type              Address          Offset            Link\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"       Size              EntSize          Info              Align\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  [Nr] Name              Type             Address           Offset\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"       Size              EntSize          Flags  Link  Info  Align\n"	*(char)
)	O
)	O
;	O
}	O
}	O
if	O
(	O
do_section_details	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"       Flags\n"	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
)	O
{	O
switch	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
)	O
{	O
case	O
SHT_REL	O
:	O
case	O
SHT_RELA	O
:	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
==	O
0	int
&&	O
(	O
filedata	O
->	O
file_header	O
.	O
e_type	O
==	O
ET_EXEC	O
||	O
filedata	O
->	O
file_header	O
.	O
e_type	O
==	O
ET_DYN	O
)	O
)	O
break	O
;	O
case	O
SHT_SYMTAB_SHNDX	O
:	O
case	O
SHT_GROUP	O
:	O
case	O
SHT_HASH	O
:	O
case	O
SHT_GNU_HASH	O
:	O
case	O
SHT_GNU_versym	O
:	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
==	O
0	int
||	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
||	O
(	O
filedata	O
->	O
section_headers	O
[	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
]	O
.	O
sh_type	O
!=	O
SHT_SYMTAB	O
&&	O
filedata	O
->	O
section_headers	O
[	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
]	O
.	O
sh_type	O
!=	O
SHT_DYNSYM	O
)	O
)	O
warn	O
(	O
_	O
(	O
"[%2u]: Link field (%u) should index a symtab section.\n"	*(char)
)	O
,	O
i	*(struct)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
)	O
;	O
break	O
;	O
case	O
SHT_DYNAMIC	O
:	O
case	O
SHT_SYMTAB	O
:	O
case	O
SHT_DYNSYM	O
:	O
case	O
SHT_GNU_verneed	O
:	O
case	O
SHT_GNU_verdef	O
:	O
case	O
SHT_GNU_LIBLIST	O
:	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
==	O
0	int
||	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
||	O
filedata	O
->	O
section_headers	O
[	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
]	O
.	O
sh_type	O
!=	O
SHT_STRTAB	O
)	O
warn	O
(	O
_	O
(	O
"[%2u]: Link field (%u) should index a string section.\n"	*(char)
)	O
,	O
i	*(struct)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
)	O
;	O
break	O
;	O
case	O
SHT_INIT_ARRAY	O
:	O
case	O
SHT_FINI_ARRAY	O
:	O
case	O
SHT_PREINIT_ARRAY	O
:	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
<	O
SHT_LOOS	O
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
!=	O
0	int
)	O
warn	O
(	O
_	O
(	O
"[%2u]: Unexpected value (%u) in link field.\n"	*(char)
)	O
,	O
i	*(struct)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
)	O
{	O
case	O
SHT_REL	O
:	O
case	O
SHT_RELA	O
:	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
==	O
0	int
&&	O
(	O
filedata	O
->	O
file_header	O
.	O
e_type	O
==	O
ET_EXEC	O
||	O
filedata	O
->	O
file_header	O
.	O
e_type	O
==	O
ET_DYN	O
)	O
)	O
break	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
==	O
0	int
||	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
||	O
(	O
filedata	O
->	O
section_headers	O
[	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
]	O
.	O
sh_type	O
!=	O
SHT_PROGBITS	O
&&	O
filedata	O
->	O
section_headers	O
[	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
]	O
.	O
sh_type	O
!=	O
SHT_NOBITS	O
&&	O
filedata	O
->	O
section_headers	O
[	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
]	O
.	O
sh_type	O
!=	O
SHT_NOTE	O
&&	O
filedata	O
->	O
section_headers	O
[	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
]	O
.	O
sh_type	O
!=	O
SHT_INIT_ARRAY	O
&&	O
filedata	O
->	O
section_headers	O
[	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
]	O
.	O
sh_type	O
!=	O
SHT_FINI_ARRAY	O
&&	O
filedata	O
->	O
section_headers	O
[	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
]	O
.	O
sh_type	O
!=	O
SHT_PREINIT_ARRAY	O
&&	O
filedata	O
->	O
section_headers	O
[	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
]	O
.	O
sh_type	O
<	O
SHT_LOOS	O
)	O
)	O
warn	O
(	O
_	O
(	O
"[%2u]: Info field (%u) should index a relocatable section.\n"	*(char)
)	O
,	O
i	*(struct)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
)	O
;	O
break	O
;	O
case	O
SHT_DYNAMIC	O
:	O
case	O
SHT_HASH	O
:	O
case	O
SHT_SYMTAB_SHNDX	O
:	O
case	O
SHT_INIT_ARRAY	O
:	O
case	O
SHT_FINI_ARRAY	O
:	O
case	O
SHT_PREINIT_ARRAY	O
:	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
!=	O
0	int
)	O
warn	O
(	O
_	O
(	O
"[%2u]: Unexpected value (%u) in info field.\n"	*(char)
)	O
,	O
i	*(struct)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
)	O
;	O
break	O
;	O
case	O
SHT_GROUP	O
:	O
case	O
SHT_SYMTAB	O
:	O
case	O
SHT_DYNSYM	O
:	O
break	O
;	O
default	O
:	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_NOBITS	O
)	O
;	O
else	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_flags	O
&	O
SHF_INFO_LINK	O
)	O
{	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
<	O
1	int
||	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
warn	O
(	O
_	O
(	O
"[%2u]: Expected link to another section in info field"	*(char)
)	O
,	O
i	*(struct)
)	O
;	O
}	O
else	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
<	O
SHT_LOOS	O
&&	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_flags	O
&	O
SHF_GNU_MBIND	O
)	O
==	O
0	int
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
!=	O
0	int
)	O
warn	O
(	O
_	O
(	O
"[%2u]: Unexpected value (%u) in info field.\n"	*(char)
)	O
,	O
i	*(struct)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
>	O
filedata	O
->	O
file_size	O
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
!=	O
SHT_NOBITS	O
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
!=	O
SHT_NULL	O
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
<	O
SHT_LOOS	O
)	O
warn	O
(	O
_	O
(	O
"Size of section %u is larger than the entire file!\n"	*(char)
)	O
,	O
i	*(struct)
)	O
;	O
printf	(*(char))->(int)
(	O
"  [%2u] "	*(char)
,	O
i	*(struct)
)	O
;	O
if	O
(	O
do_section_details	O
)	O
printf	(*(char))->(int)
(	O
"%s\n      "	*(char)
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
else	O
print_symbol	O
(	O
-	O
17	int
,	O
SECTION_NAME	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
do_wide	O
?	O
" %-15s "	*(char)
:	O
" %-15.15s "	*(char)
,	O
get_section_type_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
)	O
)	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
const	O
char	O
*	O
link_too_big	O
=	O
NULL	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %6.6lx %6.6lx %2.2lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
)	O
;	O
if	O
(	O
do_section_details	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"  "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
" %3s "	*(char)
,	O
get_elf_section_flags	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_flags	O
)	O
)	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
link_too_big	O
=	O
""	*(char)
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_386	O
:	O
case	O
EM_IAMCU	O
:	O
case	O
EM_X86_64	O
:	O
case	O
EM_L1OM	O
:	O
case	O
EM_K1OM	O
:	O
case	O
EM_OLD_SPARCV9	O
:	O
case	O
EM_SPARC32PLUS	O
:	O
case	O
EM_SPARCV9	O
:	O
case	O
EM_SPARC	O
:	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
==	O
(	O
SHN_BEFORE	O
&	O
0xffff	int
)	O
)	O
link_too_big	O
=	O
"BEFORE"	*(char)
;	O
else	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
==	O
(	O
SHN_AFTER	O
&	O
0xffff	int
)	O
)	O
link_too_big	O
=	O
"AFTER"	*(char)
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
do_section_details	O
)	O
{	O
if	O
(	O
link_too_big	O
!=	O
NULL	O
&&	O
*	O
link_too_big	O
)	O
printf	(*(char))->(int)
(	O
"<%s> "	*(char)
,	O
link_too_big	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%2u "	*(char)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%3u %2lu\n"	*(char)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addralign	O
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"%2u %3u %2lu\n"	*(char)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addralign	O
)	O
;	O
if	O
(	O
link_too_big	O
&&	O
!	O
*	O
link_too_big	O
)	O
warn	O
(	O
_	O
(	O
"section %u: sh_link value of %u is larger than the number of sections\n"	*(char)
)	O
,	O
i	*(struct)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
)	O
;	O
}	O
else	O
if	O
(	O
do_wide	O
)	O
{	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
,	O
LONG_HEX	O
)	O
;	O
if	O
(	O
(	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
==	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
)	O
printf	(*(char))->(int)
(	O
" %6.6lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
)	O
;	O
else	O
{	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
LONG_HEX	O
)	O
;	O
}	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
==	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
printf	(*(char))->(int)
(	O
" %6.6lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
;	O
else	O
{	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
LONG_HEX	O
)	O
;	O
}	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
==	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
)	O
printf	(*(char))->(int)
(	O
" %2.2lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
)	O
;	O
else	O
{	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
,	O
LONG_HEX	O
)	O
;	O
}	O
if	O
(	O
do_section_details	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"  "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
" %3s "	*(char)
,	O
get_elf_section_flags	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_flags	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%2u %3u "	*(char)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addralign	O
==	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addralign	O
)	O
printf	(*(char))->(int)
(	O
"%2lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addralign	O
)	O
;	O
else	O
{	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addralign	O
,	O
DEC	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
do_section_details	O
)	O
{	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
,	O
LONG_HEX	O
)	O
;	O
if	O
(	O
(	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
==	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
)	O
printf	(*(char))->(int)
(	O
"  %16.16lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"  "	*(char)
)	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
LONG_HEX	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"  %u\n       "	*(char)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
)	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
LONG_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  %-16u  %lu\n"	*(char)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addralign	O
)	O
;	O
}	O
else	O
{	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
,	O
LONG_HEX	O
)	O
;	O
if	O
(	O
(	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
==	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
)	O
printf	(*(char))->(int)
(	O
"  %8.8lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"  "	*(char)
)	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
LONG_HEX	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n       "	*(char)
)	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  "	*(char)
)	O
;	O
print_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %3s "	*(char)
,	O
get_elf_section_flags	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_flags	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"     %2u   %3u     %lu\n"	*(char)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addralign	O
)	O
;	O
}	O
if	O
(	O
do_section_details	O
)	O
{	O
printf	(*(char))->(int)
(	O
"       %s\n"	*(char)
,	O
get_elf_section_flags	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_flags	O
)	O
)	O
;	O
if	O
(	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_flags	O
&	O
SHF_COMPRESSED	O
)	O
!=	O
0	int
)	O
{	O
unsigned	O
char	O
buf	*(void)
[	O
24	int
]	O
;	O
assert	O
(	O
sizeof	O
(	O
buf	*(void)
)	O
>=	O
sizeof	O
(	O
Elf64_External_Chdr	O
)	O
)	O
;	O
if	O
(	O
get_data	O
(	O
&	O
buf	*(void)
,	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
sizeof	O
(	O
buf	*(void)
)	O
,	O
_	O
(	O
"compression header"	*(char)
)	O
)	O
)	O
{	O
Elf_Internal_Chdr	O
chdr	O
;	O
(	O
void	O
)	O
get_compression_header	O
(	O
&	O
chdr	O
,	O
buf	*(void)
,	O
sizeof	O
(	O
buf	*(void)
)	O
)	O
;	O
if	O
(	O
chdr	O
.	O
ch_type	O
==	O
ELFCOMPRESS_ZLIB	O
)	O
printf	(*(char))->(int)
(	O
"       ZLIB, "	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"       [<unknown>: 0x%x], "	*(char)
)	O
,	O
chdr	O
.	O
ch_type	O
)	O
;	O
print_vma	O
(	O
chdr	O
.	O
ch_size	O
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
", %lu\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
chdr	O
.	O
ch_addralign	O
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
do_section_details	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  "	*(char)
)	O
)	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_X86_64	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_L1OM	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_K1OM	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"l (large), "	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_ARM	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"y (purecode), "	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_PPC	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"v (VLE), "	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"p (processor specific)\n"	*(char)
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
get_group_flags	O
(	O
unsigned	O
int	O
flags	int
)	O
{	O
static	O
char	O
buff	O
[	O
128	int
]	O
;	O
if	O
(	O
flags	int
==	O
0	int
)	O
return	O
""	*(char)
;	O
else	O
if	O
(	O
flags	int
==	O
GRP_COMDAT	O
)	O
return	O
"COMDAT "	*(char)
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
14	int
,	O
_	O
(	O
"[0x%x: "	*(char)
)	O
,	O
flags	int
)	O
;	O
flags	int
&=	O
~	O
GRP_COMDAT	O
;	O
if	O
(	O
flags	int
&	O
GRP_MASKOS	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
buff	O
,	O
"<OS specific>"	*(char)
)	O
;	O
flags	int
&=	O
~	O
GRP_MASKOS	O
;	O
}	O
if	O
(	O
flags	int
&	O
GRP_MASKPROC	O
)	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
buff	O
,	O
"<PROC specific>"	*(char)
)	O
;	O
flags	int
&=	O
~	O
GRP_MASKPROC	O
;	O
}	O
if	O
(	O
flags	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buff	O
,	O
"<unknown>"	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buff	O
,	O
"]"	*(char)
)	O
;	O
return	O
buff	O
;	O
}	O
static	O
bfd_boolean	int
process_section_groups	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
unsigned	O
int	O
i	*(struct)
;	O
struct	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
*	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
Elf_Internal_Shdr	O
*	O
symtab_sec	O
;	O
Elf_Internal_Shdr	O
*	O
strtab_sec	O
;	O
Elf_Internal_Sym	O
*	O
symtab	O
;	O
unsigned	O
long	O
num_syms	O
;	O
char	O
*	O
strtab	O
;	O
size_t	long
strtab_size	O
;	O
if	O
(	O
!	O
do_unwind	O
&&	O
!	O
do_section_groups	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
==	O
0	int
)	O
{	O
if	O
(	O
do_section_groups	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThere are no sections to group in this file.\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
filedata	O
->	O
section_headers	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Section headers are not available!\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
section_headers_groups	O
=	O
(	O
struct	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
*	O
*	O
)	O
calloc	(long,long)->(*(void))
(	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
,	O
sizeof	O
(	O
struct	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
*	O
)	O
)	O
;	O
if	O
(	O
section_headers_groups	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory reading %u section group headers\n"	*(char)
)	O
,	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
group_count	O
=	O
0	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
)	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_GROUP	O
)	O
group_count	O
++	O
;	O
if	O
(	O
group_count	O
==	O
0	int
)	O
{	O
if	O
(	O
do_section_groups	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThere are no section groups in this file.\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
section_groups	O
=	O
(	O
struct	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
*	O
)	O
calloc	(long,long)->(*(void))
(	O
group_count	O
,	O
sizeof	O
(	O
struct	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
if	O
(	O
section_groups	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory reading %lu groups\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
group_count	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
symtab_sec	O
=	O
NULL	O
;	O
strtab_sec	O
=	O
NULL	O
;	O
symtab	O
=	O
NULL	O
;	O
num_syms	O
=	O
0	int
;	O
strtab	O
=	O
NULL	O
;	O
strtab_size	O
=	O
0	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
,	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
section_groups	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
)	O
{	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_GROUP	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
=	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
const	O
char	O
*	O
group_name	O
;	O
unsigned	O
char	O
*	O
start	O
;	O
unsigned	O
char	O
*	O
indices	O
;	O
unsigned	O
int	O
entry	O
,	O
j	O
,	O
size	int
;	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
Elf_Internal_Sym	O
*	O
sym	*(struct)
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
||	O
(	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
+	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
)	O
->	O
sh_type	O
!=	O
SHT_SYMTAB	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"Bad sh_link in group section `%s'\n"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
symtab_sec	O
!=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
symtab_sec	O
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
if	O
(	O
symtab	O
)	O
free	(*(void))->(void)
(	O
symtab	O
)	O
;	O
symtab	O
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	O
,	O
symtab_sec	O
,	O
&	O
num_syms	O
)	O
;	O
}	O
if	O
(	O
symtab	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Corrupt header in group section `%s'\n"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
>=	O
num_syms	O
)	O
{	O
error	O
(	O
_	O
(	O
"Bad sh_info in group section `%s'\n"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
continue	O
;	O
}	O
sym	*(struct)
=	O
symtab	O
+	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
sym	*(struct)
->	O
st_info	O
)	O
==	O
STT_SECTION	O
)	O
{	O
if	O
(	O
sym	*(struct)
->	O
st_shndx	O
==	O
0	int
||	O
sym	*(struct)
->	O
st_shndx	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
error	O
(	O
_	O
(	O
"Bad sh_info in group section `%s'\n"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
continue	O
;	O
}	O
group_name	O
=	O
SECTION_NAME	O
(	O
filedata	O
->	O
section_headers	O
+	O
sym	*(struct)
->	O
st_shndx	O
)	O
;	O
strtab_sec	O
=	O
NULL	O
;	O
if	O
(	O
strtab	O
)	O
free	(*(void))->(void)
(	O
strtab	O
)	O
;	O
strtab	O
=	O
NULL	O
;	O
strtab_size	O
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
symtab_sec	O
->	O
sh_link	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
strtab_sec	O
=	O
NULL	O
;	O
if	O
(	O
strtab	O
)	O
free	(*(void))->(void)
(	O
strtab	O
)	O
;	O
strtab	O
=	O
NULL	O
;	O
strtab_size	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strtab_sec	O
!=	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
+	O
symtab_sec	O
->	O
sh_link	O
)	O
)	O
{	O
strtab_sec	O
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
if	O
(	O
strtab	O
)	O
free	(*(void))->(void)
(	O
strtab	O
)	O
;	O
strtab	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
strtab_sec	O
->	O
sh_offset	O
,	O
1	int
,	O
strtab_sec	O
->	O
sh_size	O
,	O
_	O
(	O
"string table"	*(char)
)	O
)	O
;	O
strtab_size	O
=	O
strtab	O
!=	O
NULL	O
?	O
strtab_sec	O
->	O
sh_size	O
:	O
0	int
;	O
}	O
group_name	O
=	O
sym	*(struct)
->	O
st_name	O
<	O
strtab_size	O
?	O
strtab	O
+	O
sym	*(struct)
->	O
st_name	O
:	O
_	O
(	O
"<corrupt>"	*(char)
)	O
;	O
}	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
>	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Section %s has sh_entsize (0x%lx) which is larger than its size (0x%lx)\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
;	O
continue	O
;	O
}	O
start	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
_	O
(	O
"section data"	*(char)
)	O
)	O
;	O
if	O
(	O
start	O
==	O
NULL	O
)	O
continue	O
;	O
indices	O
=	O
start	O
;	O
size	int
=	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
/	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
)	O
-	O
1	int
;	O
entry	O
=	O
byte_get	O
(	O
indices	O
,	O
4	int
)	O
;	O
indices	O
+=	O
4	int
;	O
if	O
(	O
do_section_groups	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\n%sgroup section [%5u] `%s' [%s] contains %u sections:\n"	*(char)
)	O
,	O
get_group_flags	O
(	O
entry	O
)	O
,	O
i	*(struct)
,	O
name	*(char)
,	O
group_name	O
,	O
size	int
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   [Index]    Name\n"	*(char)
)	O
)	O
;	O
}	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
group_index	O
=	O
i	*(struct)
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
size	int
;	O
j	O
++	O
)	O
{	O
struct	O
group_list	O
*	O
g	O
;	O
entry	O
=	O
byte_get	O
(	O
indices	O
,	O
4	int
)	O
;	O
indices	O
+=	O
4	int
;	O
if	O
(	O
entry	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
static	O
unsigned	O
num_group_errors	O
=	O
0	int
;	O
if	O
(	O
num_group_errors	O
++	O
<	O
10	int
)	O
{	O
error	O
(	O
_	O
(	O
"section [%5u] in group section [%5u] > maximum section [%5u]\n"	*(char)
)	O
,	O
entry	O
,	O
i	*(struct)
,	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
-	O
1	int
)	O
;	O
if	O
(	O
num_group_errors	O
==	O
10	int
)	O
warn	O
(	O
_	O
(	O
"Further error messages about overlarge group section indices suppressed\n"	*(char)
)	O
)	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
section_headers_groups	O
[	O
entry	O
]	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
entry	O
)	O
{	O
static	O
unsigned	O
num_errs	O
=	O
0	int
;	O
if	O
(	O
num_errs	O
++	O
<	O
10	int
)	O
{	O
error	O
(	O
_	O
(	O
"section [%5u] in group section [%5u] already in group section [%5u]\n"	*(char)
)	O
,	O
entry	O
,	O
i	*(struct)
,	O
section_headers_groups	O
[	O
entry	O
]	O
->	O
group_index	O
)	O
;	O
if	O
(	O
num_errs	O
==	O
10	int
)	O
warn	O
(	O
_	O
(	O
"Further error messages about already contained group sections suppressed\n"	*(char)
)	O
)	O
;	O
}	O
continue	O
;	O
}	O
else	O
{	O
static	O
bfd_boolean	int
warned	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
warned	O
)	O
{	O
error	O
(	O
_	O
(	O
"section 0 in group section [%5u]\n"	*(char)
)	O
,	O
section_headers_groups	O
[	O
entry	O
]	O
->	O
group_index	O
)	O
;	O
warned	O
=	O
TRUE	int
;	O
}	O
}	O
}	O
section_headers_groups	O
[	O
entry	O
]	O
=	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
if	O
(	O
do_section_groups	O
)	O
{	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
+	O
entry	O
;	O
printf	(*(char))->(int)
(	O
"   [%5u]   %s\n"	*(char)
,	O
entry	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
}	O
g	O
=	O
(	O
struct	O
group_list	O
*	O
)	O
xmalloc	O
(	O
sizeof	O
(	O
struct	O
group_list	O
)	O
)	O
;	O
g	O
->	O
section_index	O
=	O
entry	O
;	O
g	O
->	O
next	*(char)
=	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
root	O
;	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
root	O
=	O
g	O
;	O
}	O
if	O
(	O
start	O
)	O
free	(*(void))->(void)
(	O
start	O
)	O
;	O
group	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
;	O
}	O
}	O
if	O
(	O
symtab	O
)	O
free	(*(void))->(void)
(	O
symtab	O
)	O
;	O
if	O
(	O
strtab	O
)	O
free	(*(void))->(void)
(	O
strtab	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
struct	O
ia64_vms_dynfixup	O
{	O
bfd_vma	long
needed_ident	O
;	O
bfd_vma	long
needed	O
;	O
bfd_vma	long
fixup_needed	O
;	O
bfd_vma	long
fixup_rela_cnt	O
;	O
bfd_vma	long
fixup_rela_off	O
;	O
}	O
;	O
struct	O
ia64_vms_dynimgrela	O
{	O
bfd_vma	long
img_rela_cnt	O
;	O
bfd_vma	long
img_rela_off	O
;	O
}	O
;	O
static	O
bfd_boolean	int
dump_ia64_vms_dynamic_fixups	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
ia64_vms_dynfixup	O
*	O
fixup	O
,	O
const	O
char	O
*	O
strtab	O
,	O
unsigned	O
int	O
strtab_sz	O
)	O
{	O
Elf64_External_VMS_IMAGE_FIXUP	O
*	O
imfs	O
;	O
long	O
i	*(struct)
;	O
const	O
char	O
*	O
lib_name	O
;	O
imfs	O
=	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
dynamic_addr	O
+	O
fixup	O
->	O
fixup_rela_off	O
,	O
1	int
,	O
fixup	O
->	O
fixup_rela_cnt	O
*	O
sizeof	O
(	O
*	O
imfs	O
)	O
,	O
_	O
(	O
"dynamic section image fixups"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
imfs	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
fixup	O
->	O
needed	O
<	O
strtab_sz	O
)	O
lib_name	O
=	O
strtab	O
+	O
fixup	O
->	O
needed	O
;	O
else	O
{	O
warn	O
(	O
_	O
(	O
"corrupt library name index of 0x%lx found in dynamic entry"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
fixup	O
->	O
needed	O
)	O
;	O
lib_name	O
=	O
"???"	*(char)
;	O
}	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nImage fixups for needed library #%d: %s - ident: %lx\n"	*(char)
)	O
,	O
(	O
int	O
)	O
fixup	O
->	O
fixup_needed	O
,	O
lib_name	O
,	O
(	O
long	O
)	O
fixup	O
->	O
needed_ident	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Seg Offset           Type                             SymVec DataType\n"	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
(	O
long	O
)	O
fixup	O
->	O
fixup_rela_cnt	O
;	O
i	*(struct)
++	O
)	O
{	O
unsigned	O
int	O
type	enum(int,int,int,int)
;	O
const	O
char	O
*	O
rtype	O
;	O
printf	(*(char))->(int)
(	O
"%3u "	*(char)
,	O
(	O
unsigned	O
)	O
BYTE_GET	O
(	O
imfs	O
[	O
i	*(struct)
]	O
.	O
fixup_seg	O
)	O
)	O
;	O
printf_vma	O
(	O
(	O
bfd_vma	long
)	O
BYTE_GET	O
(	O
imfs	O
[	O
i	*(struct)
]	O
.	O
fixup_offset	O
)	O
)	O
;	O
type	enum(int,int,int,int)
=	O
BYTE_GET	O
(	O
imfs	O
[	O
i	*(struct)
]	O
.	O
type	enum(int,int,int,int)
)	O
;	O
rtype	O
=	O
elf_ia64_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
rtype	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
" 0x%08x                       "	*(char)
,	O
type	enum(int,int,int,int)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
" %-32s "	*(char)
,	O
rtype	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%6u "	*(char)
,	O
(	O
unsigned	O
)	O
BYTE_GET	O
(	O
imfs	O
[	O
i	*(struct)
]	O
.	O
symvec_index	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"0x%08x\n"	*(char)
,	O
(	O
unsigned	O
)	O
BYTE_GET	O
(	O
imfs	O
[	O
i	*(struct)
]	O
.	O
data_type	int
)	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
imfs	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
dump_ia64_vms_dynamic_relocs	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
ia64_vms_dynimgrela	O
*	O
imgrela	O
)	O
{	O
Elf64_External_VMS_IMAGE_RELA	O
*	O
imrs	O
;	O
long	O
i	*(struct)
;	O
imrs	O
=	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
dynamic_addr	O
+	O
imgrela	O
->	O
img_rela_off	O
,	O
1	int
,	O
imgrela	O
->	O
img_rela_cnt	O
*	O
sizeof	O
(	O
*	O
imrs	O
)	O
,	O
_	O
(	O
"dynamic section image relocations"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
imrs	O
)	O
return	O
FALSE	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nImage relocs\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Seg Offset   Type                            Addend            Seg Sym Off\n"	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
(	O
long	O
)	O
imgrela	O
->	O
img_rela_cnt	O
;	O
i	*(struct)
++	O
)	O
{	O
unsigned	O
int	O
type	enum(int,int,int,int)
;	O
const	O
char	O
*	O
rtype	O
;	O
printf	(*(char))->(int)
(	O
"%3u "	*(char)
,	O
(	O
unsigned	O
)	O
BYTE_GET	O
(	O
imrs	O
[	O
i	*(struct)
]	O
.	O
rela_seg	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%08"	*(char)
BFD_VMA_FMT	O
"x "	*(char)
,	O
(	O
bfd_vma	long
)	O
BYTE_GET	O
(	O
imrs	O
[	O
i	*(struct)
]	O
.	O
rela_offset	O
)	O
)	O
;	O
type	enum(int,int,int,int)
=	O
BYTE_GET	O
(	O
imrs	O
[	O
i	*(struct)
]	O
.	O
type	enum(int,int,int,int)
)	O
;	O
rtype	O
=	O
elf_ia64_reloc_type	O
(	O
type	enum(int,int,int,int)
)	O
;	O
if	O
(	O
rtype	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
"0x%08x                      "	*(char)
,	O
type	enum(int,int,int,int)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%-31s "	*(char)
,	O
rtype	O
)	O
;	O
print_vma	O
(	O
BYTE_GET	O
(	O
imrs	O
[	O
i	*(struct)
]	O
.	O
addend	long
)	O
,	O
FULL_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%3u "	*(char)
,	O
(	O
unsigned	O
)	O
BYTE_GET	O
(	O
imrs	O
[	O
i	*(struct)
]	O
.	O
sym_seg	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%08"	*(char)
BFD_VMA_FMT	O
"x\n"	*(char)
,	O
(	O
bfd_vma	long
)	O
BYTE_GET	O
(	O
imrs	O
[	O
i	*(struct)
]	O
.	O
sym_offset	O
)	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
imrs	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
process_ia64_vms_dynamic_relocs	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
struct	O
ia64_vms_dynfixup	O
fixup	O
;	O
struct	O
ia64_vms_dynimgrela	O
imgrela	O
;	O
Elf_Internal_Dyn	O
*	O
entry	O
;	O
bfd_vma	long
strtab_off	O
=	O
0	int
;	O
bfd_vma	long
strtab_sz	O
=	O
0	int
;	O
char	O
*	O
strtab	O
=	O
NULL	O
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
fixup	O
,	O
0	int
,	O
sizeof	O
(	O
fixup	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
imgrela	O
,	O
0	int
,	O
sizeof	O
(	O
imgrela	O
)	O
)	O
;	O
for	O
(	O
entry	O
=	O
dynamic_section	O
;	O
entry	O
<	O
dynamic_section	O
+	O
dynamic_nent	O
;	O
entry	O
++	O
)	O
{	O
switch	O
(	O
entry	O
->	O
d_tag	O
)	O
{	O
case	O
DT_IA_64_VMS_STRTAB_OFFSET	O
:	O
strtab_off	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_STRSZ	O
:	O
strtab_sz	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
if	O
(	O
strtab	O
==	O
NULL	O
)	O
strtab	O
=	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
dynamic_addr	O
+	O
strtab_off	O
,	O
1	int
,	O
strtab_sz	O
,	O
_	O
(	O
"dynamic string section"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
DT_IA_64_VMS_NEEDED_IDENT	O
:	O
fixup	O
.	O
needed_ident	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_NEEDED	O
:	O
fixup	O
.	O
needed	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_IA_64_VMS_FIXUP_NEEDED	O
:	O
fixup	O
.	O
fixup_needed	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_IA_64_VMS_FIXUP_RELA_CNT	O
:	O
fixup	O
.	O
fixup_rela_cnt	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_IA_64_VMS_FIXUP_RELA_OFF	O
:	O
fixup	O
.	O
fixup_rela_off	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
if	O
(	O
!	O
dump_ia64_vms_dynamic_fixups	O
(	O
filedata	O
,	O
&	O
fixup	O
,	O
strtab	O
,	O
strtab_sz	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
DT_IA_64_VMS_IMG_RELA_CNT	O
:	O
imgrela	O
.	O
img_rela_cnt	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_IA_64_VMS_IMG_RELA_OFF	O
:	O
imgrela	O
.	O
img_rela_off	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
if	O
(	O
!	O
dump_ia64_vms_dynamic_relocs	O
(	O
filedata	O
,	O
&	O
imgrela	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
strtab	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
strtab	O
)	O
;	O
return	O
res	O
;	O
}	O
static	O
struct	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
int	O
reloc	O
;	O
int	O
size	int
;	O
int	O
rela	O
;	O
}	O
dynamic_relocations	O
[	O
]	O
=	O
{	O
{	O
"REL"	*(char)
,	O
DT_REL	O
,	O
DT_RELSZ	O
,	O
FALSE	O
}	O
,	O
{	O
"RELA"	*(char)
,	O
DT_RELA	O
,	O
DT_RELASZ	O
,	O
TRUE	int
}	O
,	O
{	O
"PLT"	*(char)
,	O
DT_JMPREL	O
,	O
DT_PLTRELSZ	O
,	O
UNKNOWN	O
}	O
}	O
;	O
static	O
bfd_boolean	int
process_relocs	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
unsigned	O
long	O
rel_size	O
;	O
unsigned	O
long	O
rel_offset	O
;	O
if	O
(	O
!	O
do_reloc	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
do_using_dynamic	O
)	O
{	O
int	O
is_rela	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
bfd_boolean	int
has_dynamic_reloc	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
has_dynamic_reloc	O
=	O
FALSE	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
ARRAY_SIZE	O
(	O
dynamic_relocations	O
)	O
;	O
i	*(struct)
++	O
)	O
{	O
is_rela	O
=	O
dynamic_relocations	O
[	O
i	*(struct)
]	O
.	O
rela	O
;	O
name	*(char)
=	O
dynamic_relocations	O
[	O
i	*(struct)
]	O
.	O
name	*(char)
;	O
rel_size	O
=	O
dynamic_info	O
[	O
dynamic_relocations	O
[	O
i	*(struct)
]	O
.	O
size	int
]	O
;	O
rel_offset	O
=	O
dynamic_info	O
[	O
dynamic_relocations	O
[	O
i	*(struct)
]	O
.	O
reloc	O
]	O
;	O
if	O
(	O
rel_size	O
)	O
has_dynamic_reloc	O
=	O
TRUE	int
;	O
if	O
(	O
is_rela	O
==	O
UNKNOWN	O
)	O
{	O
if	O
(	O
dynamic_relocations	O
[	O
i	*(struct)
]	O
.	O
reloc	O
==	O
DT_JMPREL	O
)	O
switch	O
(	O
dynamic_info	O
[	O
DT_PLTREL	O
]	O
)	O
{	O
case	O
DT_REL	O
:	O
is_rela	O
=	O
FALSE	O
;	O
break	O
;	O
case	O
DT_RELA	O
:	O
is_rela	O
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
rel_size	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\n'%s' relocation section at offset 0x%lx contains %ld bytes:\n"	*(char)
)	O
,	O
name	*(char)
,	O
rel_offset	O
,	O
rel_size	O
)	O
;	O
dump_relocations	O
(	O
filedata	O
,	O
offset_from_vma	O
(	O
filedata	O
,	O
rel_offset	O
,	O
rel_size	O
)	O
,	O
rel_size	O
,	O
dynamic_symbols	O
,	O
num_dynamic_syms	O
,	O
dynamic_strings	O
,	O
dynamic_strings_length	O
,	O
is_rela	O
,	O
TRUE	int
)	O
;	O
}	O
}	O
if	O
(	O
is_ia64_vms	O
(	O
filedata	O
)	O
)	O
if	O
(	O
process_ia64_vms_dynamic_relocs	O
(	O
filedata	O
)	O
)	O
has_dynamic_reloc	O
=	O
TRUE	int
;	O
if	O
(	O
!	O
has_dynamic_reloc	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThere are no dynamic relocations in this file.\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
unsigned	O
long	O
i	*(struct)
;	O
bfd_boolean	int
found	O
=	O
FALSE	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
)	O
{	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
!=	O
SHT_RELA	O
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
!=	O
SHT_REL	O
)	O
continue	O
;	O
rel_offset	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
;	O
rel_size	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
if	O
(	O
rel_size	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
strsec	O
;	O
int	O
is_rela	O
;	O
unsigned	O
long	O
num_rela	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nRelocation section "	*(char)
)	O
)	O
;	O
if	O
(	O
filedata	O
->	O
string_table	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
"%d"	*(char)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_name	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"'%s'"	*(char)
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
num_rela	O
=	O
rel_size	O
/	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
;	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
" at offset 0x%lx contains %lu entry:\n"	*(char)
,	O
" at offset 0x%lx contains %lu entries:\n"	*(char)
,	O
num_rela	O
)	O
,	O
rel_offset	O
,	O
num_rela	O
)	O
;	O
is_rela	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_RELA	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
!=	O
0	int
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
symsec	O
;	O
Elf_Internal_Sym	O
*	O
symtab	O
;	O
unsigned	O
long	O
nsyms	O
;	O
unsigned	O
long	O
strtablen	O
=	O
0	int
;	O
char	O
*	O
strtab	O
=	O
NULL	O
;	O
symsec	O
=	O
filedata	O
->	O
section_headers	O
+	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
;	O
if	O
(	O
symsec	O
->	O
sh_type	O
!=	O
SHT_SYMTAB	O
&&	O
symsec	O
->	O
sh_type	O
!=	O
SHT_DYNSYM	O
)	O
continue	O
;	O
symtab	O
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	O
,	O
symsec	O
,	O
&	O
nsyms	O
)	O
;	O
if	O
(	O
symtab	O
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
symsec	O
->	O
sh_link	O
!=	O
0	int
&&	O
symsec	O
->	O
sh_link	O
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
strsec	O
=	O
filedata	O
->	O
section_headers	O
+	O
symsec	O
->	O
sh_link	O
;	O
strtab	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
strsec	O
->	O
sh_offset	O
,	O
1	int
,	O
strsec	O
->	O
sh_size	O
,	O
_	O
(	O
"string table"	*(char)
)	O
)	O
;	O
strtablen	O
=	O
strtab	O
==	O
NULL	O
?	O
0	int
:	O
strsec	O
->	O
sh_size	O
;	O
}	O
dump_relocations	O
(	O
filedata	O
,	O
rel_offset	O
,	O
rel_size	O
,	O
symtab	O
,	O
nsyms	O
,	O
strtab	O
,	O
strtablen	O
,	O
is_rela	O
,	O
symsec	O
->	O
sh_type	O
==	O
SHT_DYNSYM	O
)	O
;	O
if	O
(	O
strtab	O
)	O
free	(*(void))->(void)
(	O
strtab	O
)	O
;	O
free	(*(void))->(void)
(	O
symtab	O
)	O
;	O
}	O
else	O
dump_relocations	O
(	O
filedata	O
,	O
rel_offset	O
,	O
rel_size	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
is_rela	O
,	O
FALSE	O
)	O
;	O
found	O
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
!	O
found	O
)	O
{	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
ARRAY_SIZE	O
(	O
dynamic_relocations	O
)	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
dynamic_info	O
[	O
dynamic_relocations	O
[	O
i	*(struct)
]	O
.	O
size	int
]	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThere are no static relocations in this file."	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nTo see the dynamic relocations add --use-dynamic to the command line.\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
i	*(struct)
==	O
ARRAY_SIZE	O
(	O
dynamic_relocations	O
)	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThere are no relocations in this file.\n"	*(char)
)	O
)	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
struct	O
absaddr	O
{	O
unsigned	O
short	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
bfd_vma	long
offset	long
;	O
}	O
;	O
static	O
void	O
find_symbol_for_address	O
(	O
Filedata	O
*	O
filedata	O
,	O
Elf_Internal_Sym	O
*	O
symtab	O
,	O
unsigned	O
long	O
nsyms	O
,	O
const	O
char	O
*	O
strtab	O
,	O
unsigned	O
long	O
strtab_size	O
,	O
struct	O
absaddr	O
addr	*(void)
,	O
const	O
char	O
*	O
*	O
symname	O
,	O
bfd_vma	long
*	O
offset	long
)	O
{	O
bfd_vma	long
dist	O
=	O
0x100000	int
;	O
Elf_Internal_Sym	O
*	O
sym	*(struct)
;	O
Elf_Internal_Sym	O
*	O
beg	O
;	O
Elf_Internal_Sym	O
*	O
end	*(*(char))
;	O
Elf_Internal_Sym	O
*	O
best	O
=	O
NULL	O
;	O
REMOVE_ARCH_BITS	O
(	O
addr	*(void)
.	O
offset	long
)	O
;	O
beg	O
=	O
symtab	O
;	O
end	*(*(char))
=	O
symtab	O
+	O
nsyms	O
;	O
while	O
(	O
beg	O
<	O
end	*(*(char))
)	O
{	O
bfd_vma	long
value	int
;	O
sym	*(struct)
=	O
beg	O
+	O
(	O
end	*(*(char))
-	O
beg	O
)	O
/	O
2	int
;	O
value	int
=	O
sym	*(struct)
->	O
st_value	O
;	O
REMOVE_ARCH_BITS	O
(	O
value	int
)	O
;	O
if	O
(	O
sym	*(struct)
->	O
st_name	O
!=	O
0	int
&&	O
(	O
addr	*(void)
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
==	O
SHN_UNDEF	O
||	O
addr	*(void)
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
==	O
sym	*(struct)
->	O
st_shndx	O
)	O
&&	O
addr	*(void)
.	O
offset	long
>=	O
value	int
&&	O
addr	*(void)
.	O
offset	long
-	O
value	int
<	O
dist	O
)	O
{	O
best	O
=	O
sym	*(struct)
;	O
dist	O
=	O
addr	*(void)
.	O
offset	long
-	O
value	int
;	O
if	O
(	O
!	O
dist	O
)	O
break	O
;	O
}	O
if	O
(	O
addr	*(void)
.	O
offset	long
<	O
value	int
)	O
end	*(*(char))
=	O
sym	*(struct)
;	O
else	O
beg	O
=	O
sym	*(struct)
+	O
1	int
;	O
}	O
if	O
(	O
best	O
)	O
{	O
*	O
symname	O
=	O
(	O
best	O
->	O
st_name	O
>=	O
strtab_size	O
?	O
_	O
(	O
"<corrupt>"	*(char)
)	O
:	O
strtab	O
+	O
best	O
->	O
st_name	O
)	O
;	O
*	O
offset	long
=	O
dist	O
;	O
return	O
;	O
}	O
*	O
symname	O
=	O
NULL	O
;	O
*	O
offset	long
=	O
addr	*(void)
.	O
offset	long
;	O
}	O
static	O
int	O
symcmp	O
(	O
const	O
void	O
*	O
p	*(void)
,	O
const	O
void	O
*	O
q	O
)	O
{	O
Elf_Internal_Sym	O
*	O
sp	O
=	O
(	O
Elf_Internal_Sym	O
*	O
)	O
p	*(void)
;	O
Elf_Internal_Sym	O
*	O
sq	O
=	O
(	O
Elf_Internal_Sym	O
*	O
)	O
q	O
;	O
return	O
sp	O
->	O
st_value	O
>	O
sq	O
->	O
st_value	O
?	O
1	int
:	O
(	O
sp	O
->	O
st_value	O
<	O
sq	O
->	O
st_value	O
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
struct	O
ia64_unw_table_entry	O
{	O
struct	O
absaddr	O
start	O
;	O
struct	O
absaddr	O
end	*(*(char))
;	O
struct	O
absaddr	O
info	*(void)
;	O
}	O
;	O
struct	O
ia64_unw_aux_info	O
{	O
struct	O
ia64_unw_table_entry	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
unsigned	O
long	O
table_len	O
;	O
unsigned	O
char	O
*	O
info	*(void)
;	O
unsigned	O
long	O
info_size	O
;	O
bfd_vma	long
info_addr	O
;	O
bfd_vma	long
seg_base	O
;	O
Elf_Internal_Sym	O
*	O
symtab	O
;	O
unsigned	O
long	O
nsyms	O
;	O
Elf_Internal_Sym	O
*	O
funtab	O
;	O
unsigned	O
long	O
nfuns	O
;	O
char	O
*	O
strtab	O
;	O
unsigned	O
long	O
strtab_size	O
;	O
}	O
;	O
static	O
bfd_boolean	int
dump_ia64_unwind	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
ia64_unw_aux_info	O
*	O
aux	O
)	O
{	O
struct	O
ia64_unw_table_entry	O
*	O
tp	O
;	O
unsigned	O
long	O
j	O
,	O
nfuns	O
;	O
int	O
in_body	O
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
aux	O
->	O
funtab	O
=	O
xmalloc	O
(	O
aux	O
->	O
nsyms	O
*	O
sizeof	O
(	O
Elf_Internal_Sym	O
)	O
)	O
;	O
for	O
(	O
nfuns	O
=	O
0	int
,	O
j	O
=	O
0	int
;	O
j	O
<	O
aux	O
->	O
nsyms	O
;	O
j	O
++	O
)	O
if	O
(	O
aux	O
->	O
symtab	O
[	O
j	O
]	O
.	O
st_value	O
&&	O
ELF_ST_TYPE	O
(	O
aux	O
->	O
symtab	O
[	O
j	O
]	O
.	O
st_info	O
)	O
==	O
STT_FUNC	O
)	O
aux	O
->	O
funtab	O
[	O
nfuns	O
++	O
]	O
=	O
aux	O
->	O
symtab	O
[	O
j	O
]	O
;	O
aux	O
->	O
nfuns	O
=	O
nfuns	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
aux	O
->	O
funtab	O
,	O
aux	O
->	O
nfuns	O
,	O
sizeof	O
(	O
Elf_Internal_Sym	O
)	O
,	O
symcmp	O
)	O
;	O
for	O
(	O
tp	O
=	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
tp	O
<	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
+	O
aux	O
->	O
table_len	O
;	O
++	O
tp	O
)	O
{	O
bfd_vma	long
stamp	O
;	O
bfd_vma	long
offset	long
;	O
const	O
unsigned	O
char	O
*	O
dp	O
;	O
const	O
unsigned	O
char	O
*	O
head	*(struct(int,long,int,int,*(char),int,int,*(char),int,*(char),int,int,int))
;	O
const	O
unsigned	O
char	O
*	O
end	*(*(char))
;	O
const	O
char	O
*	O
procname	O
;	O
find_symbol_for_address	O
(	O
filedata	O
,	O
aux	O
->	O
funtab	O
,	O
aux	O
->	O
nfuns	O
,	O
aux	O
->	O
strtab	O
,	O
aux	O
->	O
strtab_size	O
,	O
tp	O
->	O
start	O
,	O
&	O
procname	O
,	O
&	O
offset	long
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n<"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
procname	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
procname	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
offset	long
)	O
printf	(*(char))->(int)
(	O
"+%lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
">: ["	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_vma	O
(	O
tp	O
->	O
start	O
.	O
offset	long
,	O
PREFIX_HEX	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'-'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_vma	O
(	O
tp	O
->	O
end	*(*(char))
.	O
offset	long
,	O
PREFIX_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"], info at +0x%lx\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
(	O
tp	O
->	O
info	*(void)
.	O
offset	long
-	O
aux	O
->	O
seg_base	O
)	O
)	O
;	O
if	O
(	O
aux	O
->	O
info	*(void)
==	O
NULL	O
)	O
continue	O
;	O
offset	long
=	O
tp	O
->	O
info	*(void)
.	O
offset	long
;	O
if	O
(	O
tp	O
->	O
info	*(void)
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
if	O
(	O
tp	O
->	O
info	*(void)
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Invalid section %u in table entry %ld\n"	*(char)
)	O
,	O
tp	O
->	O
info	*(void)
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
(	O
long	O
)	O
(	O
tp	O
-	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
continue	O
;	O
}	O
offset	long
+=	O
filedata	O
->	O
section_headers	O
[	O
tp	O
->	O
info	*(void)
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
]	O
.	O
sh_addr	O
;	O
}	O
offset	long
-=	O
aux	O
->	O
info_addr	O
;	O
if	O
(	O
offset	long
>=	O
aux	O
->	O
info_size	O
||	O
aux	O
->	O
info_size	O
-	O
offset	long
<	O
8	int
)	O
{	O
warn	O
(	O
_	O
(	O
"Invalid offset %lx in table entry %ld\n"	*(char)
)	O
,	O
(	O
long	O
)	O
tp	O
->	O
info	*(void)
.	O
offset	long
,	O
(	O
long	O
)	O
(	O
tp	O
-	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
continue	O
;	O
}	O
head	*(struct(int,long,int,int,*(char),int,int,*(char),int,*(char),int,int,int))
=	O
aux	O
->	O
info	*(void)
+	O
offset	long
;	O
stamp	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
head	*(struct(int,long,int,int,*(char),int,int,*(char),int,*(char),int,int,int))
,	O
sizeof	O
(	O
stamp	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  v%u, flags=0x%lx (%s%s), len=%lu bytes\n"	*(char)
,	O
(	O
unsigned	O
)	O
UNW_VER	O
(	O
stamp	O
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
(	O
stamp	O
&	O
UNW_FLAG_MASK	O
)	O
>>	O
32	int
)	O
,	O
UNW_FLAG_EHANDLER	O
(	O
stamp	O
)	O
?	O
" ehandler"	*(char)
:	O
""	*(char)
,	O
UNW_FLAG_UHANDLER	O
(	O
stamp	O
)	O
?	O
" uhandler"	*(char)
:	O
""	*(char)
,	O
(	O
unsigned	O
long	O
)	O
(	O
eh_addr_size	O
*	O
UNW_LENGTH	O
(	O
stamp	O
)	O
)	O
)	O
;	O
if	O
(	O
UNW_VER	O
(	O
stamp	O
)	O
!=	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\tUnknown version.\n"	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
in_body	O
=	O
0	int
;	O
end	*(*(char))
=	O
head	*(struct(int,long,int,int,*(char),int,int,*(char),int,*(char),int,int,int))
+	O
8	int
+	O
eh_addr_size	O
*	O
UNW_LENGTH	O
(	O
stamp	O
)	O
;	O
if	O
(	O
end	*(*(char))
>	O
aux	O
->	O
info	*(void)
+	O
aux	O
->	O
info_size	O
)	O
end	*(*(char))
=	O
aux	O
->	O
info	*(void)
+	O
aux	O
->	O
info_size	O
;	O
for	O
(	O
dp	O
=	O
head	*(struct(int,long,int,int,*(char),int,int,*(char),int,*(char),int,int,int))
+	O
8	int
;	O
dp	O
<	O
end	*(*(char))
;	O
)	O
dp	O
=	O
unw_decode	O
(	O
dp	O
,	O
in_body	O
,	O
&	O
in_body	O
,	O
end	*(*(char))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
aux	O
->	O
funtab	O
)	O
;	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
slurp_ia64_unwind_table	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
ia64_unw_aux_info	O
*	O
aux	O
,	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
unsigned	O
long	O
size	int
,	O
nrelas	O
,	O
i	*(struct)
;	O
Elf_Internal_Phdr	O
*	O
seg	O
;	O
struct	O
ia64_unw_table_entry	O
*	O
tep	O
;	O
Elf_Internal_Shdr	O
*	O
relsec	O
;	O
Elf_Internal_Rela	O
*	O
rela	O
;	O
Elf_Internal_Rela	O
*	O
rp	O
;	O
unsigned	O
char	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
unsigned	O
char	O
*	O
tp	O
;	O
Elf_Internal_Sym	O
*	O
sym	*(struct)
;	O
const	O
char	O
*	O
relname	O
;	O
aux	O
->	O
table_len	O
=	O
0	int
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
)	O
{	O
if	O
(	O
!	O
get_program_headers	O
(	O
filedata	O
)	O
)	O
return	O
FALSE	O
;	O
for	O
(	O
seg	O
=	O
filedata	O
->	O
program_headers	O
;	O
seg	O
<	O
filedata	O
->	O
program_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
;	O
++	O
seg	O
)	O
{	O
if	O
(	O
seg	O
->	O
p_type	O
!=	O
PT_LOAD	O
)	O
continue	O
;	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
>=	O
seg	O
->	O
p_vaddr	O
&&	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
+	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
<=	O
seg	O
->	O
p_vaddr	O
+	O
seg	O
->	O
p_memsz	O
)	O
)	O
{	O
aux	O
->	O
seg_base	O
=	O
seg	O
->	O
p_vaddr	O
;	O
break	O
;	O
}	O
}	O
}	O
size	int
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
size	int
,	O
_	O
(	O
"unwind table"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
return	O
FALSE	O
;	O
aux	O
->	O
table_len	O
=	O
size	int
/	O
(	O
3	int
*	O
eh_addr_size	O
)	O
;	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
=	O
(	O
struct	O
ia64_unw_table_entry	O
*	O
)	O
xcmalloc	O
(	O
aux	O
->	O
table_len	O
,	O
sizeof	O
(	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
0	int
]	O
)	O
)	O
;	O
tep	O
=	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
for	O
(	O
tp	O
=	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
tp	O
<=	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
+	O
size	int
-	O
(	O
3	int
*	O
eh_addr_size	O
)	O
;	O
++	O
tep	O
)	O
{	O
tep	O
->	O
start	O
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
SHN_UNDEF	O
;	O
tep	O
->	O
end	*(*(char))
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
SHN_UNDEF	O
;	O
tep	O
->	O
info	*(void)
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
SHN_UNDEF	O
;	O
tep	O
->	O
start	O
.	O
offset	long
=	O
byte_get	O
(	O
tp	O
,	O
eh_addr_size	O
)	O
;	O
tp	O
+=	O
eh_addr_size	O
;	O
tep	O
->	O
end	*(*(char))
.	O
offset	long
=	O
byte_get	O
(	O
tp	O
,	O
eh_addr_size	O
)	O
;	O
tp	O
+=	O
eh_addr_size	O
;	O
tep	O
->	O
info	*(void)
.	O
offset	long
=	O
byte_get	O
(	O
tp	O
,	O
eh_addr_size	O
)	O
;	O
tp	O
+=	O
eh_addr_size	O
;	O
tep	O
->	O
start	O
.	O
offset	long
+=	O
aux	O
->	O
seg_base	O
;	O
tep	O
->	O
end	*(*(char))
.	O
offset	long
+=	O
aux	O
->	O
seg_base	O
;	O
tep	O
->	O
info	*(void)
.	O
offset	long
+=	O
aux	O
->	O
seg_base	O
;	O
}	O
free	(*(void))->(void)
(	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
;	O
for	O
(	O
relsec	O
=	O
filedata	O
->	O
section_headers	O
;	O
relsec	O
<	O
filedata	O
->	O
section_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
relsec	O
)	O
{	O
if	O
(	O
relsec	O
->	O
sh_type	O
!=	O
SHT_RELA	O
||	O
relsec	O
->	O
sh_info	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
||	O
filedata	O
->	O
section_headers	O
+	O
relsec	O
->	O
sh_info	O
!=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
continue	O
;	O
if	O
(	O
!	O
slurp_rela_relocs	O
(	O
filedata	O
,	O
relsec	O
->	O
sh_offset	O
,	O
relsec	O
->	O
sh_size	O
,	O
&	O
rela	O
,	O
&	O
nrelas	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
;	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
=	O
NULL	O
;	O
aux	O
->	O
table_len	O
=	O
0	int
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
rp	O
=	O
rela	O
;	O
rp	O
<	O
rela	O
+	O
nrelas	O
;	O
++	O
rp	O
)	O
{	O
unsigned	O
int	O
sym_ndx	O
;	O
unsigned	O
int	O
r_type	O
=	O
get_reloc_type	O
(	O
filedata	O
,	O
rp	O
->	O
r_info	O
)	O
;	O
relname	O
=	O
elf_ia64_reloc_type	O
(	O
r_type	O
)	O
;	O
if	O
(	O
relname	O
==	O
NULL	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping unknown relocation type: %u\n"	*(char)
)	O
,	O
r_type	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
const_strneq	O
(	O
relname	O
,	O
"R_IA64_SEGREL"	*(char)
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping unexpected relocation type: %s\n"	*(char)
)	O
,	O
relname	O
)	O
;	O
continue	O
;	O
}	O
i	*(struct)
=	O
rp	O
->	O
r_offset	O
/	O
(	O
3	int
*	O
eh_addr_size	O
)	O
;	O
if	O
(	O
i	*(struct)
>=	O
aux	O
->	O
table_len	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping reloc with overlarge offset: %lx\n"	*(char)
)	O
,	O
i	*(struct)
)	O
;	O
continue	O
;	O
}	O
sym_ndx	O
=	O
get_reloc_symindex	O
(	O
rp	O
->	O
r_info	O
)	O
;	O
if	O
(	O
sym_ndx	O
>=	O
aux	O
->	O
nsyms	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping reloc with invalid symbol index: %u\n"	*(char)
)	O
,	O
sym_ndx	O
)	O
;	O
continue	O
;	O
}	O
sym	*(struct)
=	O
aux	O
->	O
symtab	O
+	O
sym_ndx	O
;	O
switch	O
(	O
rp	O
->	O
r_offset	O
/	O
eh_addr_size	O
%	O
3	int
)	O
{	O
case	O
0	int
:	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
i	*(struct)
]	O
.	O
start	O
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
sym	*(struct)
->	O
st_shndx	O
;	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
i	*(struct)
]	O
.	O
start	O
.	O
offset	long
=	O
rp	O
->	O
r_addend	O
+	O
sym	*(struct)
->	O
st_value	O
;	O
break	O
;	O
case	O
1	int
:	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
i	*(struct)
]	O
.	O
end	*(*(char))
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
sym	*(struct)
->	O
st_shndx	O
;	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
i	*(struct)
]	O
.	O
end	*(*(char))
.	O
offset	long
=	O
rp	O
->	O
r_addend	O
+	O
sym	*(struct)
->	O
st_value	O
;	O
break	O
;	O
case	O
2	int
:	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
i	*(struct)
]	O
.	O
info	*(void)
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
sym	*(struct)
->	O
st_shndx	O
;	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
i	*(struct)
]	O
.	O
info	*(void)
.	O
offset	long
=	O
rp	O
->	O
r_addend	O
+	O
sym	*(struct)
->	O
st_value	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
rela	O
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
ia64_process_unwind	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
Elf_Internal_Shdr	O
*	O
unwsec	O
=	O
NULL	O
;	O
Elf_Internal_Shdr	O
*	O
strsec	O
;	O
unsigned	O
long	O
i	*(struct)
,	O
unwcount	O
=	O
0	int
,	O
unwstart	O
=	O
0	int
;	O
struct	O
ia64_unw_aux_info	O
aux	O
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
aux	O
,	O
0	int
,	O
sizeof	O
(	O
aux	O
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
i	*(struct)
,	O
++	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_SYMTAB	O
&&	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
aux	O
.	O
symtab	O
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
&	O
aux	O
.	O
nsyms	O
)	O
;	O
strsec	O
=	O
filedata	O
->	O
section_headers	O
+	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
;	O
if	O
(	O
aux	O
.	O
strtab	O
!=	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Multiple auxillary string tables encountered\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
aux	O
.	O
strtab	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
aux	O
.	O
strtab	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
strsec	O
->	O
sh_offset	O
,	O
1	int
,	O
strsec	O
->	O
sh_size	O
,	O
_	O
(	O
"string table"	*(char)
)	O
)	O
;	O
aux	O
.	O
strtab_size	O
=	O
aux	O
.	O
strtab	O
!=	O
NULL	O
?	O
strsec	O
->	O
sh_size	O
:	O
0	int
;	O
}	O
else	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_IA_64_UNWIND	O
)	O
unwcount	O
++	O
;	O
}	O
if	O
(	O
!	O
unwcount	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThere are no unwind sections in this file.\n"	*(char)
)	O
)	O
;	O
while	O
(	O
unwcount	O
--	O
>	O
0	int
)	O
{	O
char	O
*	O
suffix	O
;	O
size_t	long
len	int
,	O
len2	O
;	O
for	O
(	O
i	*(struct)
=	O
unwstart	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
+	O
unwstart	O
,	O
unwsec	O
=	O
NULL	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
i	*(struct)
,	O
++	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_IA_64_UNWIND	O
)	O
{	O
unwsec	O
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
break	O
;	O
}	O
assert	O
(	O
unwsec	O
!=	O
NULL	O
)	O
;	O
unwstart	O
=	O
i	*(struct)
+	O
1	int
;	O
len	int
=	O
sizeof	O
(	O
ELF_STRING_ia64_unwind_once	O
)	O
-	O
1	int
;	O
if	O
(	O
(	O
unwsec	O
->	O
sh_flags	O
&	O
SHF_GROUP	O
)	O
!=	O
0	int
)	O
{	O
struct	O
group_list	O
*	O
g	O
;	O
if	O
(	O
section_headers_groups	O
==	O
NULL	O
||	O
section_headers_groups	O
[	O
i	*(struct)
]	O
==	O
NULL	O
)	O
i	*(struct)
=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
else	O
{	O
g	O
=	O
section_headers_groups	O
[	O
i	*(struct)
]	O
->	O
root	O
;	O
for	O
(	O
;	O
g	O
!=	O
NULL	O
;	O
g	O
=	O
g	O
->	O
next	*(char)
)	O
{	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
+	O
g	O
->	O
section_index	O
;	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
ELF_STRING_ia64_unwind_info	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
g	O
==	O
NULL	O
)	O
i	*(struct)
=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
}	O
}	O
else	O
if	O
(	O
strneq	O
(	O
SECTION_NAME	O
(	O
unwsec	O
)	O
,	O
ELF_STRING_ia64_unwind_once	O
,	O
len	int
)	O
)	O
{	O
len2	O
=	O
sizeof	O
(	O
ELF_STRING_ia64_unwind_info_once	O
)	O
-	O
1	int
;	O
suffix	O
=	O
SECTION_NAME	O
(	O
unwsec	O
)	O
+	O
len	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
i	*(struct)
,	O
++	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
if	O
(	O
strneq	O
(	O
SECTION_NAME	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
ELF_STRING_ia64_unwind_info_once	O
,	O
len2	O
)	O
&&	O
streq	O
(	O
SECTION_NAME	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
+	O
len2	O
,	O
suffix	O
)	O
)	O
break	O
;	O
}	O
else	O
{	O
len	int
=	O
sizeof	O
(	O
ELF_STRING_ia64_unwind	O
)	O
-	O
1	int
;	O
len2	O
=	O
sizeof	O
(	O
ELF_STRING_ia64_unwind_info	O
)	O
-	O
1	int
;	O
suffix	O
=	O
""	*(char)
;	O
if	O
(	O
strneq	O
(	O
SECTION_NAME	O
(	O
unwsec	O
)	O
,	O
ELF_STRING_ia64_unwind	O
,	O
len	int
)	O
)	O
suffix	O
=	O
SECTION_NAME	O
(	O
unwsec	O
)	O
+	O
len	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
i	*(struct)
,	O
++	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
if	O
(	O
strneq	O
(	O
SECTION_NAME	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
ELF_STRING_ia64_unwind_info	O
,	O
len2	O
)	O
&&	O
streq	O
(	O
SECTION_NAME	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
+	O
len2	O
,	O
suffix	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
i	*(struct)
==	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nCould not find unwind info section for "	*(char)
)	O
)	O
;	O
if	O
(	O
filedata	O
->	O
string_table	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
"%d"	*(char)
,	O
unwsec	O
->	O
sh_name	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"'%s'"	*(char)
,	O
printable_section_name	O
(	O
filedata	O
,	O
unwsec	O
)	O
)	O
;	O
}	O
else	O
{	O
aux	O
.	O
info_addr	O
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
;	O
aux	O
.	O
info	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
_	O
(	O
"unwind info"	*(char)
)	O
)	O
;	O
aux	O
.	O
info_size	O
=	O
aux	O
.	O
info	*(void)
==	O
NULL	O
?	O
0	int
:	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nUnwind section "	*(char)
)	O
)	O
;	O
if	O
(	O
filedata	O
->	O
string_table	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
"%d"	*(char)
,	O
unwsec	O
->	O
sh_name	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"'%s'"	*(char)
,	O
printable_section_name	O
(	O
filedata	O
,	O
unwsec	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" at offset 0x%lx contains %lu entries:\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
unwsec	O
->	O
sh_offset	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
unwsec	O
->	O
sh_size	O
/	O
(	O
3	int
*	O
eh_addr_size	O
)	O
)	O
)	O
;	O
if	O
(	O
slurp_ia64_unwind_table	O
(	O
filedata	O
,	O
&	O
aux	O
,	O
unwsec	O
)	O
&&	O
aux	O
.	O
table_len	O
>	O
0	int
)	O
dump_ia64_unwind	O
(	O
filedata	O
,	O
&	O
aux	O
)	O
;	O
if	O
(	O
aux	O
.	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
aux	O
.	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
;	O
if	O
(	O
aux	O
.	O
info	*(void)
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
aux	O
.	O
info	*(void)
)	O
;	O
aux	O
.	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
=	O
NULL	O
;	O
aux	O
.	O
info	*(void)
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
aux	O
.	O
symtab	O
)	O
free	(*(void))->(void)
(	O
aux	O
.	O
symtab	O
)	O
;	O
if	O
(	O
aux	O
.	O
strtab	O
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
aux	O
.	O
strtab	O
)	O
;	O
return	O
res	O
;	O
}	O
struct	O
hppa_unw_table_entry	O
{	O
struct	O
absaddr	O
start	O
;	O
struct	O
absaddr	O
end	*(*(char))
;	O
unsigned	O
int	O
Cannot_unwind	O
:	O
1	int
;	O
unsigned	O
int	O
Millicode	O
:	O
1	int
;	O
unsigned	O
int	O
Millicode_save_sr0	O
:	O
1	int
;	O
unsigned	O
int	O
Region_description	O
:	O
2	int
;	O
unsigned	O
int	O
reserved1	O
:	O
1	int
;	O
unsigned	O
int	O
Entry_SR	O
:	O
1	int
;	O
unsigned	O
int	O
Entry_FR	O
:	O
4	int
;	O
unsigned	O
int	O
Entry_GR	O
:	O
5	int
;	O
unsigned	O
int	O
Args_stored	O
:	O
1	int
;	O
unsigned	O
int	O
Variable_Frame	O
:	O
1	int
;	O
unsigned	O
int	O
Separate_Package_Body	O
:	O
1	int
;	O
unsigned	O
int	O
Frame_Extension_Millicode	O
:	O
1	int
;	O
unsigned	O
int	O
Stack_Overflow_Check	O
:	O
1	int
;	O
unsigned	O
int	O
Two_Instruction_SP_Increment	O
:	O
1	int
;	O
unsigned	O
int	O
Ada_Region	O
:	O
1	int
;	O
unsigned	O
int	O
cxx_info	O
:	O
1	int
;	O
unsigned	O
int	O
cxx_try_catch	O
:	O
1	int
;	O
unsigned	O
int	O
sched_entry_seq	O
:	O
1	int
;	O
unsigned	O
int	O
reserved2	O
:	O
1	int
;	O
unsigned	O
int	O
Save_SP	O
:	O
1	int
;	O
unsigned	O
int	O
Save_RP	O
:	O
1	int
;	O
unsigned	O
int	O
Save_MRP_in_frame	O
:	O
1	int
;	O
unsigned	O
int	O
extn_ptr_defined	O
:	O
1	int
;	O
unsigned	O
int	O
Cleanup_defined	O
:	O
1	int
;	O
unsigned	O
int	O
MPE_XL_interrupt_marker	O
:	O
1	int
;	O
unsigned	O
int	O
HP_UX_interrupt_marker	O
:	O
1	int
;	O
unsigned	O
int	O
Large_frame	O
:	O
1	int
;	O
unsigned	O
int	O
Pseudo_SP_Set	O
:	O
1	int
;	O
unsigned	O
int	O
reserved4	O
:	O
1	int
;	O
unsigned	O
int	O
Total_frame_size	O
:	O
27	int
;	O
}	O
;	O
struct	O
hppa_unw_aux_info	O
{	O
struct	O
hppa_unw_table_entry	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
unsigned	O
long	O
table_len	O
;	O
bfd_vma	long
seg_base	O
;	O
Elf_Internal_Sym	O
*	O
symtab	O
;	O
unsigned	O
long	O
nsyms	O
;	O
Elf_Internal_Sym	O
*	O
funtab	O
;	O
unsigned	O
long	O
nfuns	O
;	O
char	O
*	O
strtab	O
;	O
unsigned	O
long	O
strtab_size	O
;	O
}	O
;	O
static	O
bfd_boolean	int
dump_hppa_unwind	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
hppa_unw_aux_info	O
*	O
aux	O
)	O
{	O
struct	O
hppa_unw_table_entry	O
*	O
tp	O
;	O
unsigned	O
long	O
j	O
,	O
nfuns	O
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
aux	O
->	O
funtab	O
=	O
xmalloc	O
(	O
aux	O
->	O
nsyms	O
*	O
sizeof	O
(	O
Elf_Internal_Sym	O
)	O
)	O
;	O
for	O
(	O
nfuns	O
=	O
0	int
,	O
j	O
=	O
0	int
;	O
j	O
<	O
aux	O
->	O
nsyms	O
;	O
j	O
++	O
)	O
if	O
(	O
aux	O
->	O
symtab	O
[	O
j	O
]	O
.	O
st_value	O
&&	O
ELF_ST_TYPE	O
(	O
aux	O
->	O
symtab	O
[	O
j	O
]	O
.	O
st_info	O
)	O
==	O
STT_FUNC	O
)	O
aux	O
->	O
funtab	O
[	O
nfuns	O
++	O
]	O
=	O
aux	O
->	O
symtab	O
[	O
j	O
]	O
;	O
aux	O
->	O
nfuns	O
=	O
nfuns	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
aux	O
->	O
funtab	O
,	O
aux	O
->	O
nfuns	O
,	O
sizeof	O
(	O
Elf_Internal_Sym	O
)	O
,	O
symcmp	O
)	O
;	O
for	O
(	O
tp	O
=	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
tp	O
<	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
+	O
aux	O
->	O
table_len	O
;	O
++	O
tp	O
)	O
{	O
bfd_vma	long
offset	long
;	O
const	O
char	O
*	O
procname	O
;	O
find_symbol_for_address	O
(	O
filedata	O
,	O
aux	O
->	O
funtab	O
,	O
aux	O
->	O
nfuns	O
,	O
aux	O
->	O
strtab	O
,	O
aux	O
->	O
strtab_size	O
,	O
tp	O
->	O
start	O
,	O
&	O
procname	O
,	O
&	O
offset	long
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n<"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
procname	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
procname	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
offset	long
)	O
printf	(*(char))->(int)
(	O
"+%lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
offset	long
)	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
">: ["	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_vma	O
(	O
tp	O
->	O
start	O
.	O
offset	long
,	O
PREFIX_HEX	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'-'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_vma	O
(	O
tp	O
->	O
end	*(*(char))
.	O
offset	long
,	O
PREFIX_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"]\n\t"	*(char)
)	O
;	O
PF	O
(	O
Cannot_unwind	O
)	O
;	O
PF	O
(	O
Millicode	O
)	O
;	O
PF	O
(	O
Millicode_save_sr0	O
)	O
;	O
PF	O
(	O
Entry_SR	O
)	O
;	O
PV	O
(	O
Entry_FR	O
)	O
;	O
PV	O
(	O
Entry_GR	O
)	O
;	O
PF	O
(	O
Args_stored	O
)	O
;	O
PF	O
(	O
Variable_Frame	O
)	O
;	O
PF	O
(	O
Separate_Package_Body	O
)	O
;	O
PF	O
(	O
Frame_Extension_Millicode	O
)	O
;	O
PF	O
(	O
Stack_Overflow_Check	O
)	O
;	O
PF	O
(	O
Two_Instruction_SP_Increment	O
)	O
;	O
PF	O
(	O
Ada_Region	O
)	O
;	O
PF	O
(	O
cxx_info	O
)	O
;	O
PF	O
(	O
cxx_try_catch	O
)	O
;	O
PF	O
(	O
sched_entry_seq	O
)	O
;	O
PF	O
(	O
Save_SP	O
)	O
;	O
PF	O
(	O
Save_RP	O
)	O
;	O
PF	O
(	O
Save_MRP_in_frame	O
)	O
;	O
PF	O
(	O
extn_ptr_defined	O
)	O
;	O
PF	O
(	O
Cleanup_defined	O
)	O
;	O
PF	O
(	O
MPE_XL_interrupt_marker	O
)	O
;	O
PF	O
(	O
HP_UX_interrupt_marker	O
)	O
;	O
PF	O
(	O
Large_frame	O
)	O
;	O
PF	O
(	O
Pseudo_SP_Set	O
)	O
;	O
PV	O
(	O
Total_frame_size	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
aux	O
->	O
funtab	O
)	O
;	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
slurp_hppa_unwind_table	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
hppa_unw_aux_info	O
*	O
aux	O
,	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
unsigned	O
long	O
size	int
,	O
unw_ent_size	O
,	O
nentries	O
,	O
nrelas	O
,	O
i	*(struct)
;	O
Elf_Internal_Phdr	O
*	O
seg	O
;	O
struct	O
hppa_unw_table_entry	O
*	O
tep	O
;	O
Elf_Internal_Shdr	O
*	O
relsec	O
;	O
Elf_Internal_Rela	O
*	O
rela	O
;	O
Elf_Internal_Rela	O
*	O
rp	O
;	O
unsigned	O
char	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
unsigned	O
char	O
*	O
tp	O
;	O
Elf_Internal_Sym	O
*	O
sym	*(struct)
;	O
const	O
char	O
*	O
relname	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
)	O
{	O
if	O
(	O
!	O
get_program_headers	O
(	O
filedata	O
)	O
)	O
return	O
FALSE	O
;	O
for	O
(	O
seg	O
=	O
filedata	O
->	O
program_headers	O
;	O
seg	O
<	O
filedata	O
->	O
program_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
;	O
++	O
seg	O
)	O
{	O
if	O
(	O
seg	O
->	O
p_type	O
!=	O
PT_LOAD	O
)	O
continue	O
;	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
>=	O
seg	O
->	O
p_vaddr	O
&&	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
+	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
<=	O
seg	O
->	O
p_vaddr	O
+	O
seg	O
->	O
p_memsz	O
)	O
)	O
{	O
aux	O
->	O
seg_base	O
=	O
seg	O
->	O
p_vaddr	O
;	O
break	O
;	O
}	O
}	O
}	O
size	int
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
size	int
,	O
_	O
(	O
"unwind table"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
return	O
FALSE	O
;	O
unw_ent_size	O
=	O
16	int
;	O
nentries	O
=	O
size	int
/	O
unw_ent_size	O
;	O
size	int
=	O
unw_ent_size	O
*	O
nentries	O
;	O
tep	O
=	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
=	O
(	O
struct	O
hppa_unw_table_entry	O
*	O
)	O
xcmalloc	O
(	O
nentries	O
,	O
sizeof	O
(	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
tp	O
=	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
tp	O
<	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
+	O
size	int
;	O
tp	O
+=	O
unw_ent_size	O
,	O
++	O
tep	O
)	O
{	O
unsigned	O
int	O
tmp1	O
,	O
tmp2	O
;	O
tep	O
->	O
start	O
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
SHN_UNDEF	O
;	O
tep	O
->	O
end	*(*(char))
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
SHN_UNDEF	O
;	O
tep	O
->	O
start	O
.	O
offset	long
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
tp	O
+	O
0	int
,	O
4	int
)	O
;	O
tep	O
->	O
end	*(*(char))
.	O
offset	long
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
tp	O
+	O
4	int
,	O
4	int
)	O
;	O
tmp1	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
tp	O
+	O
8	int
,	O
4	int
)	O
;	O
tmp2	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
tp	O
+	O
12	int
,	O
4	int
)	O
;	O
tep	O
->	O
start	O
.	O
offset	long
+=	O
aux	O
->	O
seg_base	O
;	O
tep	O
->	O
end	*(*(char))
.	O
offset	long
+=	O
aux	O
->	O
seg_base	O
;	O
tep	O
->	O
Cannot_unwind	O
=	O
(	O
tmp1	O
>>	O
31	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Millicode	O
=	O
(	O
tmp1	O
>>	O
30	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Millicode_save_sr0	O
=	O
(	O
tmp1	O
>>	O
29	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Region_description	O
=	O
(	O
tmp1	O
>>	O
27	int
)	O
&	O
0x3	int
;	O
tep	O
->	O
reserved1	O
=	O
(	O
tmp1	O
>>	O
26	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Entry_SR	O
=	O
(	O
tmp1	O
>>	O
25	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Entry_FR	O
=	O
(	O
tmp1	O
>>	O
21	int
)	O
&	O
0xf	int
;	O
tep	O
->	O
Entry_GR	O
=	O
(	O
tmp1	O
>>	O
16	int
)	O
&	O
0x1f	int
;	O
tep	O
->	O
Args_stored	O
=	O
(	O
tmp1	O
>>	O
15	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Variable_Frame	O
=	O
(	O
tmp1	O
>>	O
14	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Separate_Package_Body	O
=	O
(	O
tmp1	O
>>	O
13	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Frame_Extension_Millicode	O
=	O
(	O
tmp1	O
>>	O
12	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Stack_Overflow_Check	O
=	O
(	O
tmp1	O
>>	O
11	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Two_Instruction_SP_Increment	O
=	O
(	O
tmp1	O
>>	O
10	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Ada_Region	O
=	O
(	O
tmp1	O
>>	O
9	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
cxx_info	O
=	O
(	O
tmp1	O
>>	O
8	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
cxx_try_catch	O
=	O
(	O
tmp1	O
>>	O
7	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
sched_entry_seq	O
=	O
(	O
tmp1	O
>>	O
6	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
reserved2	O
=	O
(	O
tmp1	O
>>	O
5	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Save_SP	O
=	O
(	O
tmp1	O
>>	O
4	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Save_RP	O
=	O
(	O
tmp1	O
>>	O
3	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Save_MRP_in_frame	O
=	O
(	O
tmp1	O
>>	O
2	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
extn_ptr_defined	O
=	O
(	O
tmp1	O
>>	O
1	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Cleanup_defined	O
=	O
tmp1	O
&	O
0x1	int
;	O
tep	O
->	O
MPE_XL_interrupt_marker	O
=	O
(	O
tmp2	O
>>	O
31	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
HP_UX_interrupt_marker	O
=	O
(	O
tmp2	O
>>	O
30	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Large_frame	O
=	O
(	O
tmp2	O
>>	O
29	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Pseudo_SP_Set	O
=	O
(	O
tmp2	O
>>	O
28	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
reserved4	O
=	O
(	O
tmp2	O
>>	O
27	int
)	O
&	O
0x1	int
;	O
tep	O
->	O
Total_frame_size	O
=	O
tmp2	O
&	O
0x7ffffff	int
;	O
}	O
free	(*(void))->(void)
(	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
;	O
for	O
(	O
relsec	O
=	O
filedata	O
->	O
section_headers	O
;	O
relsec	O
<	O
filedata	O
->	O
section_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
relsec	O
)	O
{	O
if	O
(	O
relsec	O
->	O
sh_type	O
!=	O
SHT_RELA	O
||	O
relsec	O
->	O
sh_info	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
||	O
filedata	O
->	O
section_headers	O
+	O
relsec	O
->	O
sh_info	O
!=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
continue	O
;	O
if	O
(	O
!	O
slurp_rela_relocs	O
(	O
filedata	O
,	O
relsec	O
->	O
sh_offset	O
,	O
relsec	O
->	O
sh_size	O
,	O
&	O
rela	O
,	O
&	O
nrelas	O
)	O
)	O
return	O
FALSE	O
;	O
for	O
(	O
rp	O
=	O
rela	O
;	O
rp	O
<	O
rela	O
+	O
nrelas	O
;	O
++	O
rp	O
)	O
{	O
unsigned	O
int	O
sym_ndx	O
;	O
unsigned	O
int	O
r_type	O
=	O
get_reloc_type	O
(	O
filedata	O
,	O
rp	O
->	O
r_info	O
)	O
;	O
relname	O
=	O
elf_hppa_reloc_type	O
(	O
r_type	O
)	O
;	O
if	O
(	O
relname	O
==	O
NULL	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping unknown relocation type: %u\n"	*(char)
)	O
,	O
r_type	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
const_strneq	O
(	O
relname	O
,	O
"R_PARISC_SEGREL"	*(char)
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping unexpected relocation type: %s\n"	*(char)
)	O
,	O
relname	O
)	O
;	O
continue	O
;	O
}	O
i	*(struct)
=	O
rp	O
->	O
r_offset	O
/	O
unw_ent_size	O
;	O
if	O
(	O
i	*(struct)
>=	O
aux	O
->	O
table_len	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping reloc with overlarge offset: %lx\n"	*(char)
)	O
,	O
i	*(struct)
)	O
;	O
continue	O
;	O
}	O
sym_ndx	O
=	O
get_reloc_symindex	O
(	O
rp	O
->	O
r_info	O
)	O
;	O
if	O
(	O
sym_ndx	O
>=	O
aux	O
->	O
nsyms	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping reloc with invalid symbol index: %u\n"	*(char)
)	O
,	O
sym_ndx	O
)	O
;	O
continue	O
;	O
}	O
sym	*(struct)
=	O
aux	O
->	O
symtab	O
+	O
sym_ndx	O
;	O
switch	O
(	O
(	O
rp	O
->	O
r_offset	O
%	O
unw_ent_size	O
)	O
/	O
4	int
)	O
{	O
case	O
0	int
:	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
i	*(struct)
]	O
.	O
start	O
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
sym	*(struct)
->	O
st_shndx	O
;	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
i	*(struct)
]	O
.	O
start	O
.	O
offset	long
=	O
sym	*(struct)
->	O
st_value	O
+	O
rp	O
->	O
r_addend	O
;	O
break	O
;	O
case	O
1	int
:	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
i	*(struct)
]	O
.	O
end	*(*(char))
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
sym	*(struct)
->	O
st_shndx	O
;	O
aux	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
i	*(struct)
]	O
.	O
end	*(*(char))
.	O
offset	long
=	O
sym	*(struct)
->	O
st_value	O
+	O
rp	O
->	O
r_addend	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
rela	O
)	O
;	O
}	O
aux	O
->	O
table_len	O
=	O
nentries	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
hppa_process_unwind	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
struct	O
hppa_unw_aux_info	O
aux	O
;	O
Elf_Internal_Shdr	O
*	O
unwsec	O
=	O
NULL	O
;	O
Elf_Internal_Shdr	O
*	O
strsec	O
;	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
unsigned	O
long	O
i	*(struct)
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
if	O
(	O
filedata	O
->	O
string_table	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
aux	O
,	O
0	int
,	O
sizeof	O
(	O
aux	O
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
i	*(struct)
,	O
++	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_SYMTAB	O
&&	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
aux	O
.	O
symtab	O
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
&	O
aux	O
.	O
nsyms	O
)	O
;	O
strsec	O
=	O
filedata	O
->	O
section_headers	O
+	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
;	O
if	O
(	O
aux	O
.	O
strtab	O
!=	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Multiple auxillary string tables encountered\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
aux	O
.	O
strtab	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
aux	O
.	O
strtab	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
strsec	O
->	O
sh_offset	O
,	O
1	int
,	O
strsec	O
->	O
sh_size	O
,	O
_	O
(	O
"string table"	*(char)
)	O
)	O
;	O
aux	O
.	O
strtab_size	O
=	O
aux	O
.	O
strtab	O
!=	O
NULL	O
?	O
strsec	O
->	O
sh_size	O
:	O
0	int
;	O
}	O
else	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
".PARISC.unwind"	*(char)
)	O
)	O
unwsec	O
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
}	O
if	O
(	O
!	O
unwsec	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThere are no unwind sections in this file.\n"	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
i	*(struct)
,	O
++	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
".PARISC.unwind"	*(char)
)	O
)	O
{	O
unsigned	O
long	O
num_unwind	O
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
/	O
16	int
;	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nUnwind section '%s' at offset 0x%lx "	*(char)
"contains %lu entry:\n"	*(char)
,	O
"\nUnwind section '%s' at offset 0x%lx "	*(char)
"contains %lu entries:\n"	*(char)
,	O
num_unwind	O
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
(	O
unsigned	O
long	O
)	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
num_unwind	O
)	O
;	O
if	O
(	O
!	O
slurp_hppa_unwind_table	O
(	O
filedata	O
,	O
&	O
aux	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
res	O
=	O
FALSE	O
;	O
if	O
(	O
res	O
&&	O
aux	O
.	O
table_len	O
>	O
0	int
)	O
{	O
if	O
(	O
!	O
dump_hppa_unwind	O
(	O
filedata	O
,	O
&	O
aux	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
if	O
(	O
aux	O
.	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
aux	O
.	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
;	O
aux	O
.	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
aux	O
.	O
symtab	O
)	O
free	(*(void))->(void)
(	O
aux	O
.	O
symtab	O
)	O
;	O
if	O
(	O
aux	O
.	O
strtab	O
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
aux	O
.	O
strtab	O
)	O
;	O
return	O
res	O
;	O
}	O
struct	O
arm_section	O
{	O
unsigned	O
char	O
*	O
data	*(void)
;	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
Elf_Internal_Rela	O
*	O
rela	O
;	O
unsigned	O
long	O
nrelas	O
;	O
unsigned	O
int	O
rel_type	O
;	O
Elf_Internal_Rela	O
*	O
next_rela	O
;	O
}	O
;	O
struct	O
arm_unw_aux_info	O
{	O
Filedata	O
*	O
filedata	O
;	O
Elf_Internal_Sym	O
*	O
symtab	O
;	O
unsigned	O
long	O
nsyms	O
;	O
Elf_Internal_Sym	O
*	O
funtab	O
;	O
unsigned	O
long	O
nfuns	O
;	O
char	O
*	O
strtab	O
;	O
unsigned	O
long	O
strtab_size	O
;	O
}	O
;	O
static	O
const	O
char	O
*	O
arm_print_vma_and_name	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
arm_unw_aux_info	O
*	O
aux	O
,	O
bfd_vma	long
fn	O
,	O
struct	O
absaddr	O
addr	*(void)
)	O
{	O
const	O
char	O
*	O
procname	O
;	O
bfd_vma	long
sym_offset	O
;	O
if	O
(	O
addr	*(void)
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
==	O
SHN_UNDEF	O
)	O
addr	*(void)
.	O
offset	long
=	O
fn	O
;	O
find_symbol_for_address	O
(	O
filedata	O
,	O
aux	O
->	O
funtab	O
,	O
aux	O
->	O
nfuns	O
,	O
aux	O
->	O
strtab	O
,	O
aux	O
->	O
strtab_size	O
,	O
addr	*(void)
,	O
&	O
procname	O
,	O
&	O
sym_offset	O
)	O
;	O
print_vma	O
(	O
fn	O
,	O
PREFIX_HEX	O
)	O
;	O
if	O
(	O
procname	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" <"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
procname	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
sym_offset	O
)	O
printf	(*(char))->(int)
(	O
"+0x%lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
sym_offset	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'>'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
return	O
procname	O
;	O
}	O
static	O
void	O
arm_free_section	O
(	O
struct	O
arm_section	O
*	O
arm_sec	O
)	O
{	O
if	O
(	O
arm_sec	O
->	O
data	*(void)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
arm_sec	O
->	O
data	*(void)
)	O
;	O
if	O
(	O
arm_sec	O
->	O
rela	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
arm_sec	O
->	O
rela	O
)	O
;	O
}	O
static	O
bfd_boolean	int
get_unwind_section_word	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
arm_unw_aux_info	O
*	O
aux	O
,	O
struct	O
arm_section	O
*	O
arm_sec	O
,	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
bfd_vma	long
word_offset	O
,	O
unsigned	O
int	O
*	O
wordp	O
,	O
struct	O
absaddr	O
*	O
addr	*(void)
,	O
bfd_vma	long
*	O
sym_name	O
)	O
{	O
Elf_Internal_Rela	O
*	O
rp	O
;	O
Elf_Internal_Sym	O
*	O
sym	*(struct)
;	O
const	O
char	O
*	O
relname	O
;	O
unsigned	O
int	O
word	O
;	O
bfd_boolean	int
wrapped	O
;	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
==	O
NULL	O
||	O
arm_sec	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
addr	*(void)
->	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
SHN_UNDEF	O
;	O
addr	*(void)
->	O
offset	long
=	O
0	int
;	O
if	O
(	O
sym_name	O
!=	O
NULL	O
)	O
*	O
sym_name	O
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
!=	O
arm_sec	O
->	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
Elf_Internal_Shdr	O
*	O
relsec	O
;	O
arm_free_section	O
(	O
arm_sec	O
)	O
;	O
arm_sec	O
->	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
arm_sec	O
->	O
data	*(void)
=	O
get_data	O
(	O
NULL	O
,	O
aux	O
->	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
_	O
(	O
"unwind data"	*(char)
)	O
)	O
;	O
arm_sec	O
->	O
rela	O
=	O
NULL	O
;	O
arm_sec	O
->	O
nrelas	O
=	O
0	int
;	O
for	O
(	O
relsec	O
=	O
filedata	O
->	O
section_headers	O
;	O
relsec	O
<	O
filedata	O
->	O
section_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
relsec	O
)	O
{	O
if	O
(	O
relsec	O
->	O
sh_info	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
||	O
filedata	O
->	O
section_headers	O
+	O
relsec	O
->	O
sh_info	O
!=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
||	O
(	O
relsec	O
->	O
sh_type	O
!=	O
SHT_REL	O
&&	O
relsec	O
->	O
sh_type	O
!=	O
SHT_RELA	O
)	O
)	O
continue	O
;	O
arm_sec	O
->	O
rel_type	O
=	O
relsec	O
->	O
sh_type	O
;	O
if	O
(	O
relsec	O
->	O
sh_type	O
==	O
SHT_REL	O
)	O
{	O
if	O
(	O
!	O
slurp_rel_relocs	O
(	O
aux	O
->	O
filedata	O
,	O
relsec	O
->	O
sh_offset	O
,	O
relsec	O
->	O
sh_size	O
,	O
&	O
arm_sec	O
->	O
rela	O
,	O
&	O
arm_sec	O
->	O
nrelas	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
slurp_rela_relocs	O
(	O
aux	O
->	O
filedata	O
,	O
relsec	O
->	O
sh_offset	O
,	O
relsec	O
->	O
sh_size	O
,	O
&	O
arm_sec	O
->	O
rela	O
,	O
&	O
arm_sec	O
->	O
nrelas	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
break	O
;	O
}	O
arm_sec	O
->	O
next_rela	O
=	O
arm_sec	O
->	O
rela	O
;	O
}	O
if	O
(	O
arm_sec	O
->	O
data	*(void)
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
<	O
4	int
||	O
word_offset	O
>	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
-	O
4	int
)	O
||	O
(	O
(	O
bfd_signed_vma	long
)	O
word_offset	O
)	O
<	O
0	int
)	O
return	O
FALSE	O
;	O
word	O
=	O
byte_get	O
(	O
arm_sec	O
->	O
data	*(void)
+	O
word_offset	O
,	O
4	int
)	O
;	O
if	O
(	O
arm_sec	O
->	O
rela	O
==	O
NULL	O
)	O
{	O
*	O
wordp	O
=	O
word	O
;	O
return	O
TRUE	int
;	O
}	O
wrapped	O
=	O
FALSE	O
;	O
for	O
(	O
rp	O
=	O
arm_sec	O
->	O
next_rela	O
;	O
rp	O
!=	O
arm_sec	O
->	O
rela	O
+	O
arm_sec	O
->	O
nrelas	O
;	O
rp	O
++	O
)	O
{	O
bfd_vma	long
prelval	O
,	O
offset	long
;	O
if	O
(	O
rp	O
->	O
r_offset	O
>	O
word_offset	O
&&	O
!	O
wrapped	O
)	O
{	O
rp	O
=	O
arm_sec	O
->	O
rela	O
;	O
wrapped	O
=	O
TRUE	int
;	O
}	O
if	O
(	O
rp	O
->	O
r_offset	O
>	O
word_offset	O
)	O
break	O
;	O
if	O
(	O
rp	O
->	O
r_offset	O
&	O
3	int
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping unexpected relocation at offset 0x%lx\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
rp	O
->	O
r_offset	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
rp	O
->	O
r_offset	O
<	O
word_offset	O
)	O
continue	O
;	O
if	O
(	O
aux	O
->	O
symtab	O
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
arm_sec	O
->	O
rel_type	O
==	O
SHT_REL	O
)	O
{	O
offset	long
=	O
word	O
&	O
0x7fffffff	int
;	O
if	O
(	O
offset	long
&	O
0x40000000	int
)	O
offset	long
|=	O
~	O
(	O
bfd_vma	long
)	O
0x7fffffff	int
;	O
}	O
else	O
if	O
(	O
arm_sec	O
->	O
rel_type	O
==	O
SHT_RELA	O
)	O
offset	long
=	O
rp	O
->	O
r_addend	O
;	O
else	O
{	O
error	O
(	O
_	O
(	O
"Unknown section relocation type %d encountered\n"	*(char)
)	O
,	O
arm_sec	O
->	O
rel_type	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ELF32_R_SYM	O
(	O
rp	O
->	O
r_info	O
)	O
>=	O
aux	O
->	O
nsyms	O
)	O
{	O
error	O
(	O
_	O
(	O
"Bad symbol index in unwind relocation (%lu > %lu)\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
ELF32_R_SYM	O
(	O
rp	O
->	O
r_info	O
)	O
,	O
aux	O
->	O
nsyms	O
)	O
;	O
break	O
;	O
}	O
sym	*(struct)
=	O
aux	O
->	O
symtab	O
+	O
ELF32_R_SYM	O
(	O
rp	O
->	O
r_info	O
)	O
;	O
offset	long
+=	O
sym	*(struct)
->	O
st_value	O
;	O
prelval	O
=	O
offset	long
-	O
(	O
arm_sec	O
->	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
+	O
rp	O
->	O
r_offset	O
)	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_ARM	O
)	O
{	O
relname	O
=	O
elf_arm_reloc_type	O
(	O
ELF32_R_TYPE	O
(	O
rp	O
->	O
r_info	O
)	O
)	O
;	O
if	O
(	O
relname	O
==	O
NULL	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping unknown ARM relocation type: %d\n"	*(char)
)	O
,	O
(	O
int	O
)	O
ELF32_R_TYPE	O
(	O
rp	O
->	O
r_info	O
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
streq	O
(	O
relname	O
,	O
"R_ARM_NONE"	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
streq	O
(	O
relname	O
,	O
"R_ARM_PREL31"	*(char)
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping unexpected ARM relocation type %s\n"	*(char)
)	O
,	O
relname	O
)	O
;	O
continue	O
;	O
}	O
}	O
else	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_TI_C6000	O
)	O
{	O
relname	O
=	O
elf_tic6x_reloc_type	O
(	O
ELF32_R_TYPE	O
(	O
rp	O
->	O
r_info	O
)	O
)	O
;	O
if	O
(	O
relname	O
==	O
NULL	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping unknown C6000 relocation type: %d\n"	*(char)
)	O
,	O
(	O
int	O
)	O
ELF32_R_TYPE	O
(	O
rp	O
->	O
r_info	O
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
streq	O
(	O
relname	O
,	O
"R_C6000_NONE"	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
streq	O
(	O
relname	O
,	O
"R_C6000_PREL31"	*(char)
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Skipping unexpected C6000 relocation type %s\n"	*(char)
)	O
,	O
relname	O
)	O
;	O
continue	O
;	O
}	O
prelval	O
>>=	O
1	int
;	O
}	O
else	O
{	O
warn	O
(	O
_	O
(	O
"Only TI and ARM unwinders are currently supported\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
word	O
=	O
(	O
word	O
&	O
~	O
(	O
bfd_vma	long
)	O
0x7fffffff	int
)	O
|	O
(	O
prelval	O
&	O
0x7fffffff	int
)	O
;	O
addr	*(void)
->	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
sym	*(struct)
->	O
st_shndx	O
;	O
addr	*(void)
->	O
offset	long
=	O
offset	long
;	O
if	O
(	O
sym_name	O
)	O
*	O
sym_name	O
=	O
sym	*(struct)
->	O
st_name	O
;	O
break	O
;	O
}	O
*	O
wordp	O
=	O
word	O
;	O
arm_sec	O
->	O
next_rela	O
=	O
rp	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
tic6x_unwind_regnames	O
[	O
16	int
]	O
=	O
{	O
"A15"	*(char)
,	O
"B15"	*(char)
,	O
"B14"	*(char)
,	O
"B13"	*(char)
,	O
"B12"	*(char)
,	O
"B11"	*(char)
,	O
"B10"	*(char)
,	O
"B3"	*(char)
,	O
"A14"	*(char)
,	O
"A13"	*(char)
,	O
"A12"	*(char)
,	O
"A11"	*(char)
,	O
"A10"	*(char)
,	O
"[invalid reg 13]"	*(char)
,	O
"[invalid reg 14]"	*(char)
,	O
"[invalid reg 15]"	*(char)
}	O
;	O
static	O
void	O
decode_tic6x_unwind_regmask	O
(	O
unsigned	O
int	O
mask	O
)	O
{	O
int	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
12	int
;	O
mask	O
;	O
mask	O
>>=	O
1	int
,	O
i	*(struct)
--	O
)	O
{	O
if	O
(	O
mask	O
&	O
1	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tic6x_unwind_regnames	O
[	O
i	*(struct)
]	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
>	O
1	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
", "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
}	O
static	O
bfd_boolean	int
decode_arm_unwind_bytecode	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
arm_unw_aux_info	O
*	O
aux	O
,	O
unsigned	O
int	O
word	O
,	O
unsigned	O
int	O
remaining	O
,	O
unsigned	O
int	O
more_words	O
,	O
bfd_vma	long
data_offset	O
,	O
Elf_Internal_Shdr	O
*	O
data_sec	O
,	O
struct	O
arm_section	O
*	O
data_arm_sec	O
)	O
{	O
struct	O
absaddr	O
addr	*(void)
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
int	O
op	O
,	O
op2	O
;	O
ADVANCE	O
;	O
if	O
(	O
remaining	O
==	O
0	int
)	O
break	O
;	O
remaining	O
--	O
;	O
op	O
=	O
word	O
>>	O
24	int
;	O
word	O
<<=	O
8	int
;	O
printf	(*(char))->(int)
(	O
"  0x%02x "	*(char)
,	O
op	O
)	O
;	O
if	O
(	O
(	O
op	O
&	O
0xc0	int
)	O
==	O
0x00	int
)	O
{	O
int	O
offset	long
=	O
(	O
(	O
op	O
&	O
0x3f	int
)	O
<<	O
2	int
)	O
+	O
4	int
;	O
printf	(*(char))->(int)
(	O
"     vsp = vsp + %d"	*(char)
,	O
offset	long
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	O
&	O
0xc0	int
)	O
==	O
0x40	int
)	O
{	O
int	O
offset	long
=	O
(	O
(	O
op	O
&	O
0x3f	int
)	O
<<	O
2	int
)	O
+	O
4	int
;	O
printf	(*(char))->(int)
(	O
"     vsp = vsp - %d"	*(char)
,	O
offset	long
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	O
&	O
0xf0	int
)	O
==	O
0x80	int
)	O
{	O
GET_OP	O
(	O
op2	O
)	O
;	O
if	O
(	O
op	O
==	O
0x80	int
&&	O
op2	O
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Refuse to unwind"	*(char)
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
mask	O
=	O
(	O
(	O
op	O
&	O
0x0f	int
)	O
<<	O
8	int
)	O
|	O
op2	O
;	O
bfd_boolean	int
first	O
=	O
TRUE	int
;	O
int	O
i	*(struct)
;	O
printf	(*(char))->(int)
(	O
"pop {"	*(char)
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
12	int
;	O
i	*(struct)
++	O
)	O
if	O
(	O
mask	O
&	O
(	O
1	int
<<	O
i	*(struct)
)	O
)	O
{	O
if	O
(	O
first	O
)	O
first	O
=	O
FALSE	O
;	O
else	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"r%d"	*(char)
,	O
4	int
+	O
i	*(struct)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"}"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
op	O
&	O
0xf0	int
)	O
==	O
0x90	int
)	O
{	O
if	O
(	O
op	O
==	O
0x9d	int
||	O
op	O
==	O
0x9f	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"     [Reserved]"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"     vsp = r%d"	*(char)
,	O
op	O
&	O
0x0f	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	O
&	O
0xf0	int
)	O
==	O
0xa0	int
)	O
{	O
int	O
end	*(*(char))
=	O
4	int
+	O
(	O
op	O
&	O
0x07	int
)	O
;	O
bfd_boolean	int
first	O
=	O
TRUE	int
;	O
int	O
i	*(struct)
;	O
printf	(*(char))->(int)
(	O
"     pop {"	*(char)
)	O
;	O
for	O
(	O
i	*(struct)
=	O
4	int
;	O
i	*(struct)
<=	O
end	*(*(char))
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
first	O
)	O
first	O
=	O
FALSE	O
;	O
else	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"r%d"	*(char)
,	O
i	*(struct)
)	O
;	O
}	O
if	O
(	O
op	O
&	O
0x08	int
)	O
{	O
if	O
(	O
!	O
first	O
)	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"r14"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"}"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
0xb0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"     finish"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
op	O
==	O
0xb1	int
)	O
{	O
GET_OP	O
(	O
op2	O
)	O
;	O
if	O
(	O
op2	O
==	O
0	int
||	O
(	O
op2	O
&	O
0xf0	int
)	O
!=	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"[Spare]"	*(char)
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
mask	O
=	O
op2	O
&	O
0x0f	int
;	O
bfd_boolean	int
first	O
=	O
TRUE	int
;	O
int	O
i	*(struct)
;	O
printf	(*(char))->(int)
(	O
"pop {"	*(char)
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
12	int
;	O
i	*(struct)
++	O
)	O
if	O
(	O
mask	O
&	O
(	O
1	int
<<	O
i	*(struct)
)	O
)	O
{	O
if	O
(	O
first	O
)	O
first	O
=	O
FALSE	O
;	O
else	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"r%d"	*(char)
,	O
i	*(struct)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"}"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
op	O
==	O
0xb2	int
)	O
{	O
unsigned	O
char	O
buf	*(void)
[	O
9	int
]	O
;	O
unsigned	O
int	O
i	*(struct)
,	O
len	int
;	O
unsigned	O
long	O
offset	long
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
sizeof	O
(	O
buf	*(void)
)	O
;	O
i	*(struct)
++	O
)	O
{	O
GET_OP	O
(	O
buf	*(void)
[	O
i	*(struct)
]	O
)	O
;	O
if	O
(	O
(	O
buf	*(void)
[	O
i	*(struct)
]	O
&	O
0x80	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
i	*(struct)
==	O
sizeof	O
(	O
buf	*(void)
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"corrupt change to vsp"	*(char)
)	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
else	O
{	O
offset	long
=	O
read_leb128	O
(	O
buf	*(void)
,	O
buf	*(void)
+	O
i	*(struct)
+	O
1	int
,	O
FALSE	O
,	O
&	O
len	int
,	O
NULL	O
)	O
;	O
assert	O
(	O
len	int
==	O
i	*(struct)
+	O
1	int
)	O
;	O
offset	long
=	O
offset	long
*	O
4	int
+	O
0x204	int
;	O
printf	(*(char))->(int)
(	O
"vsp = vsp + %ld"	*(char)
,	O
offset	long
)	O
;	O
}	O
}	O
else	O
if	O
(	O
op	O
==	O
0xb3	int
||	O
op	O
==	O
0xc8	int
||	O
op	O
==	O
0xc9	int
)	O
{	O
unsigned	O
int	O
first	O
,	O
last	O
;	O
GET_OP	O
(	O
op2	O
)	O
;	O
first	O
=	O
op2	O
>>	O
4	int
;	O
last	O
=	O
op2	O
&	O
0x0f	int
;	O
if	O
(	O
op	O
==	O
0xc8	int
)	O
first	O
=	O
first	O
+	O
16	int
;	O
printf	(*(char))->(int)
(	O
"pop {D%d"	*(char)
,	O
first	O
)	O
;	O
if	O
(	O
last	O
)	O
printf	(*(char))->(int)
(	O
"-D%d"	*(char)
,	O
first	O
+	O
last	O
)	O
;	O
printf	(*(char))->(int)
(	O
"}"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	O
&	O
0xf8	int
)	O
==	O
0xb8	int
||	O
(	O
op	O
&	O
0xf8	int
)	O
==	O
0xd0	int
)	O
{	O
unsigned	O
int	O
count	int
=	O
op	O
&	O
0x07	int
;	O
printf	(*(char))->(int)
(	O
"pop {D8"	*(char)
)	O
;	O
if	O
(	O
count	int
)	O
printf	(*(char))->(int)
(	O
"-D%d"	*(char)
,	O
8	int
+	O
count	int
)	O
;	O
printf	(*(char))->(int)
(	O
"}"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
op	O
>=	O
0xc0	int
&&	O
op	O
<=	O
0xc5	int
)	O
{	O
unsigned	O
int	O
count	int
=	O
op	O
&	O
0x07	int
;	O
printf	(*(char))->(int)
(	O
"     pop {wR10"	*(char)
)	O
;	O
if	O
(	O
count	int
)	O
printf	(*(char))->(int)
(	O
"-wR%d"	*(char)
,	O
10	int
+	O
count	int
)	O
;	O
printf	(*(char))->(int)
(	O
"}"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
0xc6	int
)	O
{	O
unsigned	O
int	O
first	O
,	O
last	O
;	O
GET_OP	O
(	O
op2	O
)	O
;	O
first	O
=	O
op2	O
>>	O
4	int
;	O
last	O
=	O
op2	O
&	O
0x0f	int
;	O
printf	(*(char))->(int)
(	O
"pop {wR%d"	*(char)
,	O
first	O
)	O
;	O
if	O
(	O
last	O
)	O
printf	(*(char))->(int)
(	O
"-wR%d"	*(char)
,	O
first	O
+	O
last	O
)	O
;	O
printf	(*(char))->(int)
(	O
"}"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
0xc7	int
)	O
{	O
GET_OP	O
(	O
op2	O
)	O
;	O
if	O
(	O
op2	O
==	O
0	int
||	O
(	O
op2	O
&	O
0xf0	int
)	O
!=	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"[Spare]"	*(char)
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
mask	O
=	O
op2	O
&	O
0x0f	int
;	O
bfd_boolean	int
first	O
=	O
TRUE	int
;	O
int	O
i	*(struct)
;	O
printf	(*(char))->(int)
(	O
"pop {"	*(char)
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
4	int
;	O
i	*(struct)
++	O
)	O
if	O
(	O
mask	O
&	O
(	O
1	int
<<	O
i	*(struct)
)	O
)	O
{	O
if	O
(	O
first	O
)	O
first	O
=	O
FALSE	O
;	O
else	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"wCGR%d"	*(char)
,	O
i	*(struct)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"}"	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"     [unsupported opcode]"	*(char)
)	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
decode_tic6x_unwind_bytecode	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
arm_unw_aux_info	O
*	O
aux	O
,	O
unsigned	O
int	O
word	O
,	O
unsigned	O
int	O
remaining	O
,	O
unsigned	O
int	O
more_words	O
,	O
bfd_vma	long
data_offset	O
,	O
Elf_Internal_Shdr	O
*	O
data_sec	O
,	O
struct	O
arm_section	O
*	O
data_arm_sec	O
)	O
{	O
struct	O
absaddr	O
addr	*(void)
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
int	O
op	O
,	O
op2	O
;	O
ADVANCE	O
;	O
if	O
(	O
remaining	O
==	O
0	int
)	O
break	O
;	O
remaining	O
--	O
;	O
op	O
=	O
word	O
>>	O
24	int
;	O
word	O
<<=	O
8	int
;	O
printf	(*(char))->(int)
(	O
"  0x%02x "	*(char)
,	O
op	O
)	O
;	O
if	O
(	O
(	O
op	O
&	O
0xc0	int
)	O
==	O
0x00	int
)	O
{	O
int	O
offset	long
=	O
(	O
(	O
op	O
&	O
0x3f	int
)	O
<<	O
3	int
)	O
+	O
8	int
;	O
printf	(*(char))->(int)
(	O
"     sp = sp + %d"	*(char)
,	O
offset	long
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	O
&	O
0xc0	int
)	O
==	O
0x80	int
)	O
{	O
GET_OP	O
(	O
op2	O
)	O
;	O
if	O
(	O
op	O
==	O
0x80	int
&&	O
op2	O
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Refuse to unwind"	*(char)
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
mask	O
=	O
(	O
(	O
op	O
&	O
0x1f	int
)	O
<<	O
8	int
)	O
|	O
op2	O
;	O
if	O
(	O
op	O
&	O
0x20	int
)	O
printf	(*(char))->(int)
(	O
"pop compact {"	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"pop {"	*(char)
)	O
;	O
decode_tic6x_unwind_regmask	O
(	O
mask	O
)	O
;	O
printf	(*(char))->(int)
(	O
"}"	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
op	O
&	O
0xf0	int
)	O
==	O
0xc0	int
)	O
{	O
unsigned	O
int	O
reg	O
;	O
unsigned	O
int	O
nregs	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
const	O
char	O
*	O
name	*(char)
;	O
struct	O
{	O
unsigned	O
int	O
offset	long
;	O
unsigned	O
int	O
reg	O
;	O
}	O
regpos	O
[	O
16	int
]	O
;	O
nregs	O
=	O
0	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
nregs	O
<	O
(	O
op	O
&	O
0xf	int
)	O
;	O
i	*(struct)
++	O
)	O
{	O
GET_OP	O
(	O
op2	O
)	O
;	O
reg	O
=	O
op2	O
>>	O
4	int
;	O
if	O
(	O
reg	O
!=	O
0xf	int
)	O
{	O
regpos	O
[	O
nregs	O
]	O
.	O
offset	long
=	O
i	*(struct)
*	O
2	int
;	O
regpos	O
[	O
nregs	O
]	O
.	O
reg	O
=	O
reg	O
;	O
nregs	O
++	O
;	O
}	O
reg	O
=	O
op2	O
&	O
0xf	int
;	O
if	O
(	O
reg	O
!=	O
0xf	int
)	O
{	O
regpos	O
[	O
nregs	O
]	O
.	O
offset	long
=	O
i	*(struct)
*	O
2	int
+	O
1	int
;	O
regpos	O
[	O
nregs	O
]	O
.	O
reg	O
=	O
reg	O
;	O
nregs	O
++	O
;	O
}	O
}	O
printf	(*(char))->(int)
(	O
_	O
(	O
"pop frame {"	*(char)
)	O
)	O
;	O
if	O
(	O
nregs	O
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"*corrupt* - no registers specified"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
reg	O
=	O
nregs	O
-	O
1	int
;	O
for	O
(	O
i	*(struct)
=	O
i	*(struct)
*	O
2	int
;	O
i	*(struct)
>	O
0	int
;	O
i	*(struct)
--	O
)	O
{	O
if	O
(	O
regpos	O
[	O
reg	O
]	O
.	O
offset	long
==	O
i	*(struct)
-	O
1	int
)	O
{	O
name	*(char)
=	O
tic6x_unwind_regnames	O
[	O
regpos	O
[	O
reg	O
]	O
.	O
reg	O
]	O
;	O
if	O
(	O
reg	O
>	O
0	int
)	O
reg	O
--	O
;	O
}	O
else	O
name	*(char)
=	O
_	O
(	O
"[pad]"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
name	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
i	*(struct)
>	O
1	int
)	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
}	O
}	O
printf	(*(char))->(int)
(	O
"}"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
op	O
==	O
0xd0	int
)	O
printf	(*(char))->(int)
(	O
"     MOV FP, SP"	*(char)
)	O
;	O
else	O
if	O
(	O
op	O
==	O
0xd1	int
)	O
printf	(*(char))->(int)
(	O
"     __c6xabi_pop_rts"	*(char)
)	O
;	O
else	O
if	O
(	O
op	O
==	O
0xd2	int
)	O
{	O
unsigned	O
char	O
buf	*(void)
[	O
9	int
]	O
;	O
unsigned	O
int	O
i	*(struct)
,	O
len	int
;	O
unsigned	O
long	O
offset	long
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
sizeof	O
(	O
buf	*(void)
)	O
;	O
i	*(struct)
++	O
)	O
{	O
GET_OP	O
(	O
buf	*(void)
[	O
i	*(struct)
]	O
)	O
;	O
if	O
(	O
(	O
buf	*(void)
[	O
i	*(struct)
]	O
&	O
0x80	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
i	*(struct)
==	O
sizeof	O
(	O
buf	*(void)
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Corrupt stack pointer adjustment detected\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
offset	long
=	O
read_leb128	O
(	O
buf	*(void)
,	O
buf	*(void)
+	O
i	*(struct)
+	O
1	int
,	O
FALSE	O
,	O
&	O
len	int
,	O
NULL	O
)	O
;	O
assert	O
(	O
len	int
==	O
i	*(struct)
+	O
1	int
)	O
;	O
offset	long
=	O
offset	long
*	O
8	int
+	O
0x408	int
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"sp = sp + %ld"	*(char)
)	O
,	O
offset	long
)	O
;	O
}	O
else	O
if	O
(	O
(	O
op	O
&	O
0xf0	int
)	O
==	O
0xe0	int
)	O
{	O
if	O
(	O
(	O
op	O
&	O
0x0f	int
)	O
==	O
7	int
)	O
printf	(*(char))->(int)
(	O
"     RETURN"	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"     MV %s, B3"	*(char)
,	O
tic6x_unwind_regnames	O
[	O
op	O
&	O
0x0f	int
]	O
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"     [unsupported opcode]"	*(char)
)	O
)	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_vma	long
arm_expand_prel31	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_vma	long
word	O
,	O
bfd_vma	long
where	long
)	O
{	O
bfd_vma	long
offset	long
;	O
offset	long
=	O
word	O
&	O
0x7fffffff	int
;	O
if	O
(	O
offset	long
&	O
0x40000000	int
)	O
offset	long
|=	O
~	O
(	O
bfd_vma	long
)	O
0x7fffffff	int
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_TI_C6000	O
)	O
offset	long
<<=	O
1	int
;	O
return	O
offset	long
+	O
where	long
;	O
}	O
static	O
bfd_boolean	int
decode_arm_unwind	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
arm_unw_aux_info	O
*	O
aux	O
,	O
unsigned	O
int	O
word	O
,	O
unsigned	O
int	O
remaining	O
,	O
bfd_vma	long
data_offset	O
,	O
Elf_Internal_Shdr	O
*	O
data_sec	O
,	O
struct	O
arm_section	O
*	O
data_arm_sec	O
)	O
{	O
int	O
per_index	O
;	O
unsigned	O
int	O
more_words	O
=	O
0	int
;	O
struct	O
absaddr	O
addr	*(void)
;	O
bfd_vma	long
sym_name	O
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
if	O
(	O
remaining	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
get_unwind_section_word	O
(	O
filedata	O
,	O
aux	O
,	O
data_arm_sec	O
,	O
data_sec	O
,	O
data_offset	O
,	O
&	O
word	O
,	O
&	O
addr	*(void)
,	O
&	O
sym_name	O
)	O
)	O
return	O
FALSE	O
;	O
remaining	O
=	O
4	int
;	O
}	O
else	O
{	O
addr	*(void)
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
SHN_UNDEF	O
;	O
addr	*(void)
.	O
offset	long
=	O
0	int
;	O
}	O
if	O
(	O
(	O
word	O
&	O
0x80000000	int
)	O
==	O
0	int
)	O
{	O
bfd_vma	long
fn	O
;	O
const	O
char	O
*	O
procname	O
;	O
fn	O
=	O
arm_expand_prel31	O
(	O
filedata	O
,	O
word	O
,	O
data_sec	O
->	O
sh_addr	O
+	O
data_offset	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Personality routine: "	*(char)
)	O
)	O
;	O
if	O
(	O
fn	O
==	O
0	int
&&	O
addr	*(void)
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
==	O
SHN_UNDEF	O
&&	O
addr	*(void)
.	O
offset	long
==	O
0	int
&&	O
sym_name	O
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
sym_name	O
<	O
aux	O
->	O
strtab_size	O
)	O
{	O
procname	O
=	O
aux	O
->	O
strtab	O
+	O
sym_name	O
;	O
print_vma	O
(	O
fn	O
,	O
PREFIX_HEX	O
)	O
;	O
if	O
(	O
procname	O
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" <"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
procname	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'>'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
else	O
procname	O
=	O
arm_print_vma_and_name	O
(	O
filedata	O
,	O
aux	O
,	O
fn	O
,	O
addr	*(void)
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
procname	O
!=	O
NULL	O
&&	O
(	O
const_strneq	O
(	O
procname	O
,	O
"__gcc_personality_v0"	*(char)
)	O
||	O
const_strneq	O
(	O
procname	O
,	O
"__gxx_personality_v0"	*(char)
)	O
||	O
const_strneq	O
(	O
procname	O
,	O
"__gcj_personality_v0"	*(char)
)	O
||	O
const_strneq	O
(	O
procname	O
,	O
"__gnu_objc_personality_v0"	*(char)
)	O
)	O
)	O
{	O
remaining	O
=	O
0	int
;	O
more_words	O
=	O
1	int
;	O
ADVANCE	O
;	O
if	O
(	O
!	O
remaining	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  [Truncated data]\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
more_words	O
=	O
word	O
>>	O
24	int
;	O
word	O
<<=	O
8	int
;	O
remaining	O
--	O
;	O
per_index	O
=	O
-	O
1	int
;	O
}	O
else	O
return	O
TRUE	int
;	O
}	O
else	O
{	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_ARM	O
&&	O
(	O
word	O
&	O
0x70000000	int
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Corrupt ARM compact model table entry: %x \n"	*(char)
)	O
,	O
word	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
per_index	O
=	O
(	O
word	O
>>	O
24	int
)	O
&	O
0x7f	int
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Compact model index: %d\n"	*(char)
)	O
,	O
per_index	O
)	O
;	O
if	O
(	O
per_index	O
==	O
0	int
)	O
{	O
more_words	O
=	O
0	int
;	O
word	O
<<=	O
8	int
;	O
remaining	O
--	O
;	O
}	O
else	O
if	O
(	O
per_index	O
<	O
3	int
)	O
{	O
more_words	O
=	O
(	O
word	O
>>	O
16	int
)	O
&	O
0xff	int
;	O
word	O
<<=	O
16	int
;	O
remaining	O
-=	O
2	int
;	O
}	O
}	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_ARM	O
:	O
if	O
(	O
per_index	O
<	O
3	int
)	O
{	O
if	O
(	O
!	O
decode_arm_unwind_bytecode	O
(	O
filedata	O
,	O
aux	O
,	O
word	O
,	O
remaining	O
,	O
more_words	O
,	O
data_offset	O
,	O
data_sec	O
,	O
data_arm_sec	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
else	O
{	O
warn	O
(	O
_	O
(	O
"Unknown ARM compact model index encountered\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  [reserved]\n"	*(char)
)	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
break	O
;	O
case	O
EM_TI_C6000	O
:	O
if	O
(	O
per_index	O
<	O
3	int
)	O
{	O
if	O
(	O
!	O
decode_tic6x_unwind_bytecode	O
(	O
filedata	O
,	O
aux	O
,	O
word	O
,	O
remaining	O
,	O
more_words	O
,	O
data_offset	O
,	O
data_sec	O
,	O
data_arm_sec	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
per_index	O
<	O
5	int
)	O
{	O
if	O
(	O
(	O
(	O
word	O
>>	O
17	int
)	O
&	O
0x7f	int
)	O
==	O
0x7f	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Restore stack from frame pointer\n"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Stack increment %d\n"	*(char)
)	O
,	O
(	O
word	O
>>	O
14	int
)	O
&	O
0x1fc	int
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Registers restored: "	*(char)
)	O
)	O
;	O
if	O
(	O
per_index	O
==	O
4	int
)	O
printf	(*(char))->(int)
(	O
" (compact) "	*(char)
)	O
;	O
decode_tic6x_unwind_regmask	O
(	O
(	O
word	O
>>	O
4	int
)	O
&	O
0x1fff	int
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Return register: %s\n"	*(char)
)	O
,	O
tic6x_unwind_regnames	O
[	O
word	O
&	O
0xf	int
]	O
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  [reserved (%d)]\n"	*(char)
)	O
,	O
per_index	O
)	O
;	O
break	O
;	O
default	O
:	O
error	O
(	O
_	O
(	O
"Unsupported architecture type %d encountered when decoding unwind table\n"	*(char)
)	O
,	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
dump_arm_unwind	O
(	O
Filedata	O
*	O
filedata	O
,	O
struct	O
arm_unw_aux_info	O
*	O
aux	O
,	O
Elf_Internal_Shdr	O
*	O
exidx_sec	O
)	O
{	O
struct	O
arm_section	O
exidx_arm_sec	O
,	O
extab_arm_sec	O
;	O
unsigned	O
int	O
i	*(struct)
,	O
exidx_len	O
;	O
unsigned	O
long	O
j	O
,	O
nfuns	O
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
exidx_arm_sec	O
,	O
0	int
,	O
sizeof	O
(	O
exidx_arm_sec	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
extab_arm_sec	O
,	O
0	int
,	O
sizeof	O
(	O
extab_arm_sec	O
)	O
)	O
;	O
exidx_len	O
=	O
exidx_sec	O
->	O
sh_size	O
/	O
8	int
;	O
aux	O
->	O
funtab	O
=	O
xmalloc	O
(	O
aux	O
->	O
nsyms	O
*	O
sizeof	O
(	O
Elf_Internal_Sym	O
)	O
)	O
;	O
for	O
(	O
nfuns	O
=	O
0	int
,	O
j	O
=	O
0	int
;	O
j	O
<	O
aux	O
->	O
nsyms	O
;	O
j	O
++	O
)	O
if	O
(	O
aux	O
->	O
symtab	O
[	O
j	O
]	O
.	O
st_value	O
&&	O
ELF_ST_TYPE	O
(	O
aux	O
->	O
symtab	O
[	O
j	O
]	O
.	O
st_info	O
)	O
==	O
STT_FUNC	O
)	O
aux	O
->	O
funtab	O
[	O
nfuns	O
++	O
]	O
=	O
aux	O
->	O
symtab	O
[	O
j	O
]	O
;	O
aux	O
->	O
nfuns	O
=	O
nfuns	O
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
aux	O
->	O
funtab	O
,	O
aux	O
->	O
nfuns	O
,	O
sizeof	O
(	O
Elf_Internal_Sym	O
)	O
,	O
symcmp	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
exidx_len	O
;	O
i	*(struct)
++	O
)	O
{	O
unsigned	O
int	O
exidx_fn	O
,	O
exidx_entry	O
;	O
struct	O
absaddr	O
fn_addr	O
,	O
entry_addr	O
;	O
bfd_vma	long
fn	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
!	O
get_unwind_section_word	O
(	O
filedata	O
,	O
aux	O
,	O
&	O
exidx_arm_sec	O
,	O
exidx_sec	O
,	O
8	int
*	O
i	*(struct)
,	O
&	O
exidx_fn	O
,	O
&	O
fn_addr	O
,	O
NULL	O
)	O
||	O
!	O
get_unwind_section_word	O
(	O
filedata	O
,	O
aux	O
,	O
&	O
exidx_arm_sec	O
,	O
exidx_sec	O
,	O
8	int
*	O
i	*(struct)
+	O
4	int
,	O
&	O
exidx_entry	O
,	O
&	O
entry_addr	O
,	O
NULL	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
aux	O
->	O
funtab	O
)	O
;	O
arm_free_section	O
(	O
&	O
exidx_arm_sec	O
)	O
;	O
arm_free_section	O
(	O
&	O
extab_arm_sec	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
exidx_fn	O
&	O
0x80000000	int
)	O
{	O
warn	O
(	O
_	O
(	O
"corrupt index table entry: %x\n"	*(char)
)	O
,	O
exidx_fn	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
fn	O
=	O
arm_expand_prel31	O
(	O
filedata	O
,	O
exidx_fn	O
,	O
exidx_sec	O
->	O
sh_addr	O
+	O
8	int
*	O
i	*(struct)
)	O
;	O
arm_print_vma_and_name	O
(	O
filedata	O
,	O
aux	O
,	O
fn	O
,	O
fn_addr	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
": "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
exidx_entry	O
==	O
1	int
)	O
{	O
print_vma	O
(	O
exidx_entry	O
,	O
PREFIX_HEX	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" [cantunwind]\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
if	O
(	O
exidx_entry	O
&	O
0x80000000	int
)	O
{	O
print_vma	O
(	O
exidx_entry	O
,	O
PREFIX_HEX	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
decode_arm_unwind	O
(	O
filedata	O
,	O
aux	O
,	O
exidx_entry	O
,	O
4	int
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
bfd_vma	long
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
table_offset	O
=	O
0	int
;	O
Elf_Internal_Shdr	O
*	O
table_sec	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"@"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
=	O
arm_expand_prel31	O
(	O
filedata	O
,	O
exidx_entry	O
,	O
exidx_sec	O
->	O
sh_addr	O
+	O
8	int
*	O
i	*(struct)
+	O
4	int
)	O
;	O
print_vma	O
(	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
,	O
PREFIX_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
if	O
(	O
entry_addr	O
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
!=	O
SHN_UNDEF	O
&&	O
entry_addr	O
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
table_sec	O
=	O
filedata	O
->	O
section_headers	O
+	O
entry_addr	O
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
table_offset	O
=	O
entry_addr	O
.	O
offset	long
;	O
if	O
(	O
table_offset	O
>	O
table_sec	O
->	O
sh_size	O
||	O
(	O
(	O
bfd_signed_vma	long
)	O
table_offset	O
)	O
<	O
0	int
)	O
{	O
warn	O
(	O
_	O
(	O
"Unwind entry contains corrupt offset (0x%lx) into section %s\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
table_offset	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
table_sec	O
)	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
table_sec	O
=	O
find_section_by_address	O
(	O
filedata	O
,	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
;	O
if	O
(	O
table_sec	O
!=	O
NULL	O
)	O
table_offset	O
=	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
-	O
table_sec	O
->	O
sh_addr	O
;	O
}	O
if	O
(	O
table_sec	O
==	O
NULL	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Could not locate .ARM.extab section containing 0x%lx.\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
)	O
;	O
res	O
=	O
FALSE	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
decode_arm_unwind	O
(	O
filedata	O
,	O
aux	O
,	O
0	int
,	O
0	int
,	O
table_offset	O
,	O
table_sec	O
,	O
&	O
extab_arm_sec	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
aux	O
->	O
funtab	O
)	O
;	O
arm_free_section	O
(	O
&	O
exidx_arm_sec	O
)	O
;	O
arm_free_section	O
(	O
&	O
extab_arm_sec	O
)	O
;	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
arm_process_unwind	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
struct	O
arm_unw_aux_info	O
aux	O
;	O
Elf_Internal_Shdr	O
*	O
unwsec	O
=	O
NULL	O
;	O
Elf_Internal_Shdr	O
*	O
strsec	O
;	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
unsigned	O
long	O
i	*(struct)
;	O
unsigned	O
int	O
sec_type	O
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_ARM	O
:	O
sec_type	O
=	O
SHT_ARM_EXIDX	O
;	O
break	O
;	O
case	O
EM_TI_C6000	O
:	O
sec_type	O
=	O
SHT_C6000_UNWIND	O
;	O
break	O
;	O
default	O
:	O
error	O
(	O
_	O
(	O
"Unsupported architecture type %d encountered when processing unwind table\n"	*(char)
)	O
,	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
filedata	O
->	O
string_table	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
aux	O
,	O
0	int
,	O
sizeof	O
(	O
aux	O
)	O
)	O
;	O
aux	O
.	O
filedata	O
=	O
filedata	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
i	*(struct)
,	O
++	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_SYMTAB	O
&&	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
aux	O
.	O
symtab	O
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
&	O
aux	O
.	O
nsyms	O
)	O
;	O
strsec	O
=	O
filedata	O
->	O
section_headers	O
+	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
;	O
if	O
(	O
aux	O
.	O
strtab	O
!=	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Multiple string tables found in file.\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
aux	O
.	O
strtab	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
aux	O
.	O
strtab	O
=	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
strsec	O
->	O
sh_offset	O
,	O
1	int
,	O
strsec	O
->	O
sh_size	O
,	O
_	O
(	O
"string table"	*(char)
)	O
)	O
;	O
aux	O
.	O
strtab_size	O
=	O
aux	O
.	O
strtab	O
!=	O
NULL	O
?	O
strsec	O
->	O
sh_size	O
:	O
0	int
;	O
}	O
else	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
sec_type	O
)	O
unwsec	O
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
}	O
if	O
(	O
unwsec	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThere are no unwind sections in this file.\n"	*(char)
)	O
)	O
;	O
else	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
i	*(struct)
,	O
++	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
sec_type	O
)	O
{	O
unsigned	O
long	O
num_unwind	O
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
/	O
(	O
2	int
*	O
eh_addr_size	O
)	O
;	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nUnwind section '%s' at offset 0x%lx "	*(char)
"contains %lu entry:\n"	*(char)
,	O
"\nUnwind section '%s' at offset 0x%lx "	*(char)
"contains %lu entries:\n"	*(char)
,	O
num_unwind	O
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
(	O
unsigned	O
long	O
)	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
num_unwind	O
)	O
;	O
if	O
(	O
!	O
dump_arm_unwind	O
(	O
filedata	O
,	O
&	O
aux	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
aux	O
.	O
symtab	O
)	O
free	(*(void))->(void)
(	O
aux	O
.	O
symtab	O
)	O
;	O
if	O
(	O
aux	O
.	O
strtab	O
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
aux	O
.	O
strtab	O
)	O
;	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
process_unwind	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
struct	O
unwind_handler	O
{	O
unsigned	O
int	O
machtype	O
;	O
bfd_boolean	int
(	O
*	O
handler	O
)	O
(	O
Filedata	O
*	O
)	O
;	O
}	O
handlers	O
[	O
]	O
=	O
{	O
{	O
EM_ARM	O
,	O
arm_process_unwind	O
}	O
,	O
{	O
EM_IA_64	O
,	O
ia64_process_unwind	O
}	O
,	O
{	O
EM_PARISC	O
,	O
hppa_process_unwind	O
}	O
,	O
{	O
EM_TI_C6000	O
,	O
arm_process_unwind	O
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
}	O
;	O
int	O
i	*(struct)
;	O
if	O
(	O
!	O
do_unwind	O
)	O
return	O
TRUE	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
handlers	O
[	O
i	*(struct)
]	O
.	O
handler	O
!=	O
NULL	O
;	O
i	*(struct)
++	O
)	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
handlers	O
[	O
i	*(struct)
]	O
.	O
machtype	O
)	O
return	O
handlers	O
[	O
i	*(struct)
]	O
.	O
handler	O
(	O
filedata	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThe decoding of unwind sections for machine type %s is not currently supported.\n"	*(char)
)	O
,	O
get_machine_name	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
dynamic_section_aarch64_val	O
(	O
Elf_Internal_Dyn	O
*	O
entry	O
)	O
{	O
switch	O
(	O
entry	O
->	O
d_tag	O
)	O
{	O
case	O
DT_AARCH64_BTI_PLT	O
:	O
case	O
DT_AARCH64_PAC_PLT	O
:	O
break	O
;	O
default	O
:	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_ptr	O
,	O
PREFIX_HEX	O
)	O
;	O
break	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
dynamic_section_mips_val	O
(	O
Elf_Internal_Dyn	O
*	O
entry	O
)	O
{	O
switch	O
(	O
entry	O
->	O
d_tag	O
)	O
{	O
case	O
DT_MIPS_FLAGS	O
:	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"NONE"	*(char)
)	O
)	O
;	O
else	O
{	O
static	O
const	O
char	O
*	O
opts	O
[	O
]	O
=	O
{	O
"QUICKSTART"	*(char)
,	O
"NOTPOT"	*(char)
,	O
"NO_LIBRARY_REPLACEMENT"	*(char)
,	O
"NO_MOVE"	*(char)
,	O
"SGI_ONLY"	*(char)
,	O
"GUARANTEE_INIT"	*(char)
,	O
"DELTA_C_PLUS_PLUS"	*(char)
,	O
"GUARANTEE_START_INIT"	*(char)
,	O
"PIXIE"	*(char)
,	O
"DEFAULT_DELAY_LOAD"	*(char)
,	O
"REQUICKSTART"	*(char)
,	O
"REQUICKSTARTED"	*(char)
,	O
"CORD"	*(char)
,	O
"NO_UNRES_UNDEF"	*(char)
,	O
"RLD_ORDER_SAFE"	*(char)
}	O
;	O
unsigned	O
int	O
cnt	O
;	O
bfd_boolean	int
first	O
=	O
TRUE	int
;	O
for	O
(	O
cnt	O
=	O
0	int
;	O
cnt	O
<	O
ARRAY_SIZE	O
(	O
opts	O
)	O
;	O
++	O
cnt	O
)	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
(	O
1	int
<<	O
cnt	O
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s%s"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
" "	*(char)
,	O
opts	O
[	O
cnt	O
]	O
)	O
;	O
first	O
=	O
FALSE	O
;	O
}	O
}	O
break	O
;	O
case	O
DT_MIPS_IVERSION	O
:	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Interface Version: %s"	*(char)
)	O
,	O
GET_DYNAMIC_NAME	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
)	O
;	O
else	O
{	O
char	O
buf	*(void)
[	O
40	int
]	O
;	O
sprintf_vma	O
(	O
buf	*(void)
,	O
entry	O
->	O
d_un	O
.	O
d_ptr	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt: %s>"	*(char)
)	O
,	O
buf	*(void)
)	O
;	O
}	O
break	O
;	O
case	O
DT_MIPS_TIME_STAMP	O
:	O
{	O
char	O
timebuf	O
[	O
128	int
]	O
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tmp	O
;	O
time_t	long
atime	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
tmp	O
=	O
gmtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
atime	O
)	O
;	O
if	O
(	O
tmp	O
==	O
NULL	O
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
timebuf	O
,	O
sizeof	O
(	O
timebuf	O
)	O
,	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
timebuf	O
,	O
sizeof	O
(	O
timebuf	O
)	O
,	O
"%04u-%02u-%02uT%02u:%02u:%02u"	*(char)
,	O
tmp	O
->	O
tm_year	int
+	O
1900	int
,	O
tmp	O
->	O
tm_mon	int
+	O
1	int
,	O
tmp	O
->	O
tm_mday	int
,	O
tmp	O
->	O
tm_hour	int
,	O
tmp	O
->	O
tm_min	int
,	O
tmp	O
->	O
tm_sec	int
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Time Stamp: %s"	*(char)
)	O
,	O
timebuf	O
)	O
;	O
}	O
break	O
;	O
case	O
DT_MIPS_RLD_VERSION	O
:	O
case	O
DT_MIPS_LOCAL_GOTNO	O
:	O
case	O
DT_MIPS_CONFLICTNO	O
:	O
case	O
DT_MIPS_LIBLISTNO	O
:	O
case	O
DT_MIPS_SYMTABNO	O
:	O
case	O
DT_MIPS_UNREFEXTNO	O
:	O
case	O
DT_MIPS_HIPAGENO	O
:	O
case	O
DT_MIPS_DELTA_CLASS_NO	O
:	O
case	O
DT_MIPS_DELTA_INSTANCE_NO	O
:	O
case	O
DT_MIPS_DELTA_RELOC_NO	O
:	O
case	O
DT_MIPS_DELTA_SYM_NO	O
:	O
case	O
DT_MIPS_DELTA_CLASSSYM_NO	O
:	O
case	O
DT_MIPS_COMPACT_SIZE	O
:	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
DEC	O
)	O
;	O
break	O
;	O
case	O
DT_MIPS_XHASH	O
:	O
dynamic_info_DT_MIPS_XHASH	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
dynamic_info_DT_GNU_HASH	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
default	O
:	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_ptr	O
,	O
PREFIX_HEX	O
)	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
dynamic_section_parisc_val	O
(	O
Elf_Internal_Dyn	O
*	O
entry	O
)	O
{	O
switch	O
(	O
entry	O
->	O
d_tag	O
)	O
{	O
case	O
DT_HP_DLD_FLAGS	O
:	O
{	O
static	O
struct	O
{	O
long	O
int	O
bit	O
;	O
const	O
char	O
*	O
str	O
;	O
}	O
flags	int
[	O
]	O
=	O
{	O
{	O
DT_HP_DEBUG_PRIVATE	O
,	O
"HP_DEBUG_PRIVATE"	*(char)
}	O
,	O
{	O
DT_HP_DEBUG_CALLBACK	O
,	O
"HP_DEBUG_CALLBACK"	*(char)
}	O
,	O
{	O
DT_HP_DEBUG_CALLBACK_BOR	O
,	O
"HP_DEBUG_CALLBACK_BOR"	*(char)
}	O
,	O
{	O
DT_HP_NO_ENVVAR	O
,	O
"HP_NO_ENVVAR"	*(char)
}	O
,	O
{	O
DT_HP_BIND_NOW	O
,	O
"HP_BIND_NOW"	*(char)
}	O
,	O
{	O
DT_HP_BIND_NONFATAL	O
,	O
"HP_BIND_NONFATAL"	*(char)
}	O
,	O
{	O
DT_HP_BIND_VERBOSE	O
,	O
"HP_BIND_VERBOSE"	*(char)
}	O
,	O
{	O
DT_HP_BIND_RESTRICTED	O
,	O
"HP_BIND_RESTRICTED"	*(char)
}	O
,	O
{	O
DT_HP_BIND_SYMBOLIC	O
,	O
"HP_BIND_SYMBOLIC"	*(char)
}	O
,	O
{	O
DT_HP_RPATH_FIRST	O
,	O
"HP_RPATH_FIRST"	*(char)
}	O
,	O
{	O
DT_HP_BIND_DEPTH_FIRST	O
,	O
"HP_BIND_DEPTH_FIRST"	*(char)
}	O
,	O
{	O
DT_HP_GST	O
,	O
"HP_GST"	*(char)
}	O
,	O
{	O
DT_HP_SHLIB_FIXED	O
,	O
"HP_SHLIB_FIXED"	*(char)
}	O
,	O
{	O
DT_HP_MERGE_SHLIB_SEG	O
,	O
"HP_MERGE_SHLIB_SEG"	*(char)
}	O
,	O
{	O
DT_HP_NODELETE	O
,	O
"HP_NODELETE"	*(char)
}	O
,	O
{	O
DT_HP_GROUP	O
,	O
"HP_GROUP"	*(char)
}	O
,	O
{	O
DT_HP_PROTECT_LINKAGE_TABLE	O
,	O
"HP_PROTECT_LINKAGE_TABLE"	*(char)
}	O
}	O
;	O
bfd_boolean	int
first	O
=	O
TRUE	int
;	O
size_t	long
cnt	O
;	O
bfd_vma	long
val	array(int)
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
for	O
(	O
cnt	O
=	O
0	int
;	O
cnt	O
<	O
ARRAY_SIZE	O
(	O
flags	int
)	O
;	O
++	O
cnt	O
)	O
if	O
(	O
val	array(int)
&	O
flags	int
[	O
cnt	O
]	O
.	O
bit	O
)	O
{	O
if	O
(	O
!	O
first	O
)	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
flags	int
[	O
cnt	O
]	O
.	O
str	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
first	O
=	O
FALSE	O
;	O
val	array(int)
^=	O
flags	int
[	O
cnt	O
]	O
.	O
bit	O
;	O
}	O
if	O
(	O
val	array(int)
!=	O
0	int
||	O
first	O
)	O
{	O
if	O
(	O
!	O
first	O
)	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
val	array(int)
,	O
HEX	O
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_ptr	O
,	O
PREFIX_HEX	O
)	O
;	O
break	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
print_vms_time	O
(	O
bfd_int64_t	long
vmstime	O
)	O
{	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
;	O
time_t	long
unxtime	O
;	O
unxtime	O
=	O
(	O
vmstime	O
-	O
VMS_EPOCH_OFFSET	O
)	O
/	O
VMS_GRANULARITY_FACTOR	O
;	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
=	O
gmtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
unxtime	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%04u-%02u-%02uT%02u:%02u:%02u"	*(char)
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_year	int
+	O
1900	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_mon	int
+	O
1	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_mday	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_hour	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_min	int
,	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
->	O
tm_sec	int
)	O
;	O
}	O
static	O
void	O
dynamic_section_ia64_val	O
(	O
Elf_Internal_Dyn	O
*	O
entry	O
)	O
{	O
switch	O
(	O
entry	O
->	O
d_tag	O
)	O
{	O
case	O
DT_IA_64_PLT_RESERVE	O
:	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_ptr	O
,	O
PREFIX_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
" -- "	*(char)
)	O
;	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_ptr	O
+	O
(	O
3	int
*	O
8	int
)	O
,	O
PREFIX_HEX	O
)	O
;	O
break	O
;	O
case	O
DT_IA_64_VMS_LINKTIME	O
:	O
print_vms_time	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
;	O
break	O
;	O
case	O
DT_IA_64_VMS_LNKFLAGS	O
:	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_ptr	O
,	O
PREFIX_HEX	O
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_CALL_DEBUG	O
)	O
printf	(*(char))->(int)
(	O
" CALL_DEBUG"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_NOP0BUFS	O
)	O
printf	(*(char))->(int)
(	O
" NOP0BUFS"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_P0IMAGE	O
)	O
printf	(*(char))->(int)
(	O
" P0IMAGE"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_MKTHREADS	O
)	O
printf	(*(char))->(int)
(	O
" MKTHREADS"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_UPCALLS	O
)	O
printf	(*(char))->(int)
(	O
" UPCALLS"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_IMGSTA	O
)	O
printf	(*(char))->(int)
(	O
" IMGSTA"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_INITIALIZE	O
)	O
printf	(*(char))->(int)
(	O
" INITIALIZE"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_MAIN	O
)	O
printf	(*(char))->(int)
(	O
" MAIN"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_EXE_INIT	O
)	O
printf	(*(char))->(int)
(	O
" EXE_INIT"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_TBK_IN_IMG	O
)	O
printf	(*(char))->(int)
(	O
" TBK_IN_IMG"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_DBG_IN_IMG	O
)	O
printf	(*(char))->(int)
(	O
" DBG_IN_IMG"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_TBK_IN_DSF	O
)	O
printf	(*(char))->(int)
(	O
" TBK_IN_DSF"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_DBG_IN_DSF	O
)	O
printf	(*(char))->(int)
(	O
" DBG_IN_DSF"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_SIGNATURES	O
)	O
printf	(*(char))->(int)
(	O
" SIGNATURES"	*(char)
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
&	O
VMS_LF_REL_SEG_OFF	O
)	O
printf	(*(char))->(int)
(	O
" REL_SEG_OFF"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_ptr	O
,	O
PREFIX_HEX	O
)	O
;	O
break	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
static	O
bfd_boolean	int
get_32bit_dynamic_section	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf32_External_Dyn	O
*	O
edyn	O
;	O
Elf32_External_Dyn	O
*	O
ext	O
;	O
Elf_Internal_Dyn	O
*	O
entry	O
;	O
edyn	O
=	O
(	O
Elf32_External_Dyn	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
dynamic_addr	O
,	O
1	int
,	O
dynamic_size	O
,	O
_	O
(	O
"dynamic section"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
edyn	O
)	O
return	O
FALSE	O
;	O
for	O
(	O
ext	O
=	O
edyn	O
,	O
dynamic_nent	O
=	O
0	int
;	O
(	O
char	O
*	O
)	O
(	O
ext	O
+	O
1	int
)	O
<=	O
(	O
char	O
*	O
)	O
edyn	O
+	O
dynamic_size	O
;	O
ext	O
++	O
)	O
{	O
dynamic_nent	O
++	O
;	O
if	O
(	O
BYTE_GET	O
(	O
ext	O
->	O
d_tag	O
)	O
==	O
DT_NULL	O
)	O
break	O
;	O
}	O
dynamic_section	O
=	O
(	O
Elf_Internal_Dyn	O
*	O
)	O
cmalloc	O
(	O
dynamic_nent	O
,	O
sizeof	O
(	O
*	O
entry	O
)	O
)	O
;	O
if	O
(	O
dynamic_section	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory allocating space for %lu dynamic entries\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
dynamic_nent	O
)	O
;	O
free	(*(void))->(void)
(	O
edyn	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
ext	O
=	O
edyn	O
,	O
entry	O
=	O
dynamic_section	O
;	O
entry	O
<	O
dynamic_section	O
+	O
dynamic_nent	O
;	O
ext	O
++	O
,	O
entry	O
++	O
)	O
{	O
entry	O
->	O
d_tag	O
=	O
BYTE_GET	O
(	O
ext	O
->	O
d_tag	O
)	O
;	O
entry	O
->	O
d_un	O
.	O
d_val	O
=	O
BYTE_GET	O
(	O
ext	O
->	O
d_un	O
.	O
d_val	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
edyn	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
get_64bit_dynamic_section	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf64_External_Dyn	O
*	O
edyn	O
;	O
Elf64_External_Dyn	O
*	O
ext	O
;	O
Elf_Internal_Dyn	O
*	O
entry	O
;	O
edyn	O
=	O
(	O
Elf64_External_Dyn	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
dynamic_addr	O
,	O
1	int
,	O
dynamic_size	O
,	O
_	O
(	O
"dynamic section"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
edyn	O
)	O
return	O
FALSE	O
;	O
for	O
(	O
ext	O
=	O
edyn	O
,	O
dynamic_nent	O
=	O
0	int
;	O
(	O
char	O
*	O
)	O
(	O
ext	O
+	O
1	int
)	O
<=	O
(	O
char	O
*	O
)	O
edyn	O
+	O
dynamic_size	O
;	O
ext	O
++	O
)	O
{	O
dynamic_nent	O
++	O
;	O
if	O
(	O
BYTE_GET	O
(	O
ext	O
->	O
d_tag	O
)	O
==	O
DT_NULL	O
)	O
break	O
;	O
}	O
dynamic_section	O
=	O
(	O
Elf_Internal_Dyn	O
*	O
)	O
cmalloc	O
(	O
dynamic_nent	O
,	O
sizeof	O
(	O
*	O
entry	O
)	O
)	O
;	O
if	O
(	O
dynamic_section	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory allocating space for %lu dynamic entries\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
dynamic_nent	O
)	O
;	O
free	(*(void))->(void)
(	O
edyn	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
ext	O
=	O
edyn	O
,	O
entry	O
=	O
dynamic_section	O
;	O
entry	O
<	O
dynamic_section	O
+	O
dynamic_nent	O
;	O
ext	O
++	O
,	O
entry	O
++	O
)	O
{	O
entry	O
->	O
d_tag	O
=	O
BYTE_GET	O
(	O
ext	O
->	O
d_tag	O
)	O
;	O
entry	O
->	O
d_un	O
.	O
d_val	O
=	O
BYTE_GET	O
(	O
ext	O
->	O
d_un	O
.	O
d_val	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
edyn	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
print_dynamic_flags	O
(	O
bfd_vma	long
flags	int
)	O
{	O
bfd_boolean	int
first	O
=	O
TRUE	int
;	O
while	O
(	O
flags	int
)	O
{	O
bfd_vma	long
flag	O
;	O
flag	O
=	O
flags	int
&	O
-	O
flags	int
;	O
flags	int
&=	O
~	O
flag	O
;	O
if	O
(	O
first	O
)	O
first	O
=	O
FALSE	O
;	O
else	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
switch	O
(	O
flag	O
)	O
{	O
case	O
DF_ORIGIN	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"ORIGIN"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
DF_SYMBOLIC	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"SYMBOLIC"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
DF_TEXTREL	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"TEXTREL"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
DF_BIND_NOW	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"BIND_NOW"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
DF_STATIC_TLS	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"STATIC_TLS"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
default	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"unknown"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
}	O
}	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
static	O
bfd_boolean	int
process_dynamic_section	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Dyn	O
*	O
entry	O
;	O
if	O
(	O
dynamic_size	O
==	O
0	int
)	O
{	O
if	O
(	O
do_dynamic	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nThere is no dynamic section in this file.\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
if	O
(	O
!	O
get_32bit_dynamic_section	O
(	O
filedata	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
get_64bit_dynamic_section	O
(	O
filedata	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
dynamic_symbols	O
==	O
NULL	O
)	O
{	O
for	O
(	O
entry	O
=	O
dynamic_section	O
;	O
entry	O
<	O
dynamic_section	O
+	O
dynamic_nent	O
;	O
++	O
entry	O
)	O
{	O
Elf_Internal_Shdr	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
if	O
(	O
entry	O
->	O
d_tag	O
!=	O
DT_SYMTAB	O
)	O
continue	O
;	O
dynamic_info	O
[	O
DT_SYMTAB	O
]	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sh_offset	O
=	O
offset_from_vma	O
(	O
filedata	O
,	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
0	int
)	O
;	O
if	O
(	O
(	O
bfd_size_type	long
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sh_offset	O
>	O
filedata	O
->	O
file_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Invalid DT_SYMTAB entry: %lx"	*(char)
)	O
,	O
(	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sh_offset	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
archive_file_offset	O
!=	O
0	int
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sh_size	O
=	O
archive_file_size	O
-	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sh_offset	O
;	O
else	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sh_size	O
=	O
filedata	O
->	O
file_size	O
-	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sh_offset	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sh_entsize	O
=	O
sizeof	O
(	O
Elf32_External_Sym	O
)	O
;	O
else	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sh_entsize	O
=	O
sizeof	O
(	O
Elf64_External_Sym	O
)	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
.	O
sh_name	O
=	O
filedata	O
->	O
string_table_length	O
;	O
if	O
(	O
dynamic_symbols	O
!=	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Multiple dynamic symbol table sections found\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
dynamic_symbols	O
)	O
;	O
}	O
dynamic_symbols	O
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	O
,	O
&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
&	O
num_dynamic_syms	O
)	O
;	O
if	O
(	O
num_dynamic_syms	O
<	O
1	int
)	O
{	O
error	O
(	O
_	O
(	O
"Unable to determine the number of symbols to load\n"	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
}	O
}	O
if	O
(	O
dynamic_strings	O
==	O
NULL	O
)	O
{	O
for	O
(	O
entry	O
=	O
dynamic_section	O
;	O
entry	O
<	O
dynamic_section	O
+	O
dynamic_nent	O
;	O
++	O
entry	O
)	O
{	O
unsigned	O
long	O
offset	long
;	O
long	O
str_tab_len	O
;	O
if	O
(	O
entry	O
->	O
d_tag	O
!=	O
DT_STRTAB	O
)	O
continue	O
;	O
dynamic_info	O
[	O
DT_STRTAB	O
]	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
offset	long
=	O
offset_from_vma	O
(	O
filedata	O
,	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
0	int
)	O
;	O
if	O
(	O
archive_file_offset	O
!=	O
0	int
)	O
str_tab_len	O
=	O
archive_file_size	O
-	O
offset	long
;	O
else	O
str_tab_len	O
=	O
filedata	O
->	O
file_size	O
-	O
offset	long
;	O
if	O
(	O
str_tab_len	O
<	O
1	int
)	O
{	O
error	O
(	O
_	O
(	O
"Unable to determine the length of the dynamic string table\n"	*(char)
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
dynamic_strings	O
!=	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Multiple dynamic string tables found\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
dynamic_strings	O
)	O
;	O
}	O
dynamic_strings	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
offset	long
,	O
1	int
,	O
str_tab_len	O
,	O
_	O
(	O
"dynamic string table"	*(char)
)	O
)	O
;	O
dynamic_strings_length	O
=	O
dynamic_strings	O
==	O
NULL	O
?	O
0	int
:	O
str_tab_len	O
;	O
}	O
}	O
if	O
(	O
dynamic_syminfo	O
==	O
NULL	O
)	O
{	O
unsigned	O
long	O
syminsz	O
=	O
0	int
;	O
for	O
(	O
entry	O
=	O
dynamic_section	O
;	O
entry	O
<	O
dynamic_section	O
+	O
dynamic_nent	O
;	O
++	O
entry	O
)	O
{	O
if	O
(	O
entry	O
->	O
d_tag	O
==	O
DT_SYMINENT	O
)	O
{	O
if	O
(	O
sizeof	O
(	O
Elf_External_Syminfo	O
)	O
!=	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
error	O
(	O
_	O
(	O
"Bad value (%d) for SYMINENT entry\n"	*(char)
)	O
,	O
(	O
int	O
)	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
;	O
}	O
else	O
if	O
(	O
entry	O
->	O
d_tag	O
==	O
DT_SYMINSZ	O
)	O
syminsz	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
else	O
if	O
(	O
entry	O
->	O
d_tag	O
==	O
DT_SYMINFO	O
)	O
dynamic_syminfo_offset	O
=	O
offset_from_vma	O
(	O
filedata	O
,	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
syminsz	O
)	O
;	O
}	O
if	O
(	O
dynamic_syminfo_offset	O
!=	O
0	int
&&	O
syminsz	O
!=	O
0	int
)	O
{	O
Elf_External_Syminfo	O
*	O
extsyminfo	O
;	O
Elf_External_Syminfo	O
*	O
extsym	O
;	O
Elf_Internal_Syminfo	O
*	O
syminfo	O
;	O
extsyminfo	O
=	O
(	O
Elf_External_Syminfo	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
dynamic_syminfo_offset	O
,	O
1	int
,	O
syminsz	O
,	O
_	O
(	O
"symbol information"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
extsyminfo	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
dynamic_syminfo	O
!=	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Multiple dynamic symbol information sections found\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
dynamic_syminfo	O
)	O
;	O
}	O
dynamic_syminfo	O
=	O
(	O
Elf_Internal_Syminfo	O
*	O
)	O
malloc	(long)->(*(void))
(	O
syminsz	O
)	O
;	O
if	O
(	O
dynamic_syminfo	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory allocating %lu byte for dynamic symbol info\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
syminsz	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
dynamic_syminfo_nent	O
=	O
syminsz	O
/	O
sizeof	O
(	O
Elf_External_Syminfo	O
)	O
;	O
for	O
(	O
syminfo	O
=	O
dynamic_syminfo	O
,	O
extsym	O
=	O
extsyminfo	O
;	O
syminfo	O
<	O
dynamic_syminfo	O
+	O
dynamic_syminfo_nent	O
;	O
++	O
syminfo	O
,	O
++	O
extsym	O
)	O
{	O
syminfo	O
->	O
si_boundto	O
=	O
BYTE_GET	O
(	O
extsym	O
->	O
si_boundto	O
)	O
;	O
syminfo	O
->	O
si_flags	O
=	O
BYTE_GET	O
(	O
extsym	O
->	O
si_flags	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
extsyminfo	O
)	O
;	O
}	O
}	O
if	O
(	O
do_dynamic	O
&&	O
dynamic_addr	O
)	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nDynamic section at offset 0x%lx "	*(char)
"contains %lu entry:\n"	*(char)
,	O
"\nDynamic section at offset 0x%lx "	*(char)
"contains %lu entries:\n"	*(char)
,	O
dynamic_nent	O
)	O
,	O
dynamic_addr	O
,	O
(	O
unsigned	O
long	O
)	O
dynamic_nent	O
)	O
;	O
if	O
(	O
do_dynamic	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Tag        Type                         Name/Value\n"	*(char)
)	O
)	O
;	O
for	O
(	O
entry	O
=	O
dynamic_section	O
;	O
entry	O
<	O
dynamic_section	O
+	O
dynamic_nent	O
;	O
entry	O
++	O
)	O
{	O
if	O
(	O
do_dynamic	O
)	O
{	O
const	O
char	O
*	O
dtype	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
entry	O
->	O
d_tag	O
,	O
FULL_HEX	O
)	O
;	O
dtype	O
=	O
get_dynamic_type	O
(	O
filedata	O
,	O
entry	O
->	O
d_tag	O
)	O
;	O
printf	(*(char))->(int)
(	O
" (%s)%*s"	*(char)
,	O
dtype	O
,	O
(	O
(	O
is_32bit_elf	O
?	O
27	int
:	O
19	int
)	O
-	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
dtype	O
)	O
)	O
,	O
" "	*(char)
)	O
;	O
}	O
switch	O
(	O
entry	O
->	O
d_tag	O
)	O
{	O
case	O
DT_FLAGS	O
:	O
if	O
(	O
do_dynamic	O
)	O
print_dynamic_flags	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
;	O
break	O
;	O
case	O
DT_AUXILIARY	O
:	O
case	O
DT_FILTER	O
:	O
case	O
DT_CONFIG	O
:	O
case	O
DT_DEPAUDIT	O
:	O
case	O
DT_AUDIT	O
:	O
if	O
(	O
do_dynamic	O
)	O
{	O
switch	O
(	O
entry	O
->	O
d_tag	O
)	O
{	O
case	O
DT_AUXILIARY	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Auxiliary library"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
DT_FILTER	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Filter library"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
DT_CONFIG	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Configuration file"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
DT_DEPAUDIT	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Dependency audit library"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
DT_AUDIT	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Audit library"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
)	O
printf	(*(char))->(int)
(	O
": [%s]\n"	*(char)
,	O
GET_DYNAMIC_NAME	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
": "	*(char)
)	O
;	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
PREFIX_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DT_FEATURE	O
:	O
if	O
(	O
do_dynamic	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Flags:"	*(char)
)	O
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
" None\n"	*(char)
)	O
)	O
;	O
else	O
{	O
unsigned	O
long	O
int	O
val	array(int)
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
if	O
(	O
val	array(int)
&	O
DTF_1_PARINIT	O
)	O
{	O
printf	(*(char))->(int)
(	O
" PARINIT"	*(char)
)	O
;	O
val	array(int)
^=	O
DTF_1_PARINIT	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DTF_1_CONFEXP	O
)	O
{	O
printf	(*(char))->(int)
(	O
" CONFEXP"	*(char)
)	O
;	O
val	array(int)
^=	O
DTF_1_CONFEXP	O
;	O
}	O
if	O
(	O
val	array(int)
!=	O
0	int
)	O
printf	(*(char))->(int)
(	O
" %lx"	*(char)
,	O
val	array(int)
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DT_POSFLAG_1	O
:	O
if	O
(	O
do_dynamic	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Flags:"	*(char)
)	O
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
" None\n"	*(char)
)	O
)	O
;	O
else	O
{	O
unsigned	O
long	O
int	O
val	array(int)
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
if	O
(	O
val	array(int)
&	O
DF_P1_LAZYLOAD	O
)	O
{	O
printf	(*(char))->(int)
(	O
" LAZYLOAD"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_P1_LAZYLOAD	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_P1_GROUPPERM	O
)	O
{	O
printf	(*(char))->(int)
(	O
" GROUPPERM"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_P1_GROUPPERM	O
;	O
}	O
if	O
(	O
val	array(int)
!=	O
0	int
)	O
printf	(*(char))->(int)
(	O
" %lx"	*(char)
,	O
val	array(int)
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DT_FLAGS_1	O
:	O
if	O
(	O
do_dynamic	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Flags:"	*(char)
)	O
)	O
;	O
if	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
==	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
" None\n"	*(char)
)	O
)	O
;	O
else	O
{	O
unsigned	O
long	O
int	O
val	array(int)
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
if	O
(	O
val	array(int)
&	O
DF_1_NOW	O
)	O
{	O
printf	(*(char))->(int)
(	O
" NOW"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_NOW	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_GLOBAL	O
)	O
{	O
printf	(*(char))->(int)
(	O
" GLOBAL"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_GLOBAL	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_GROUP	O
)	O
{	O
printf	(*(char))->(int)
(	O
" GROUP"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_GROUP	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_NODELETE	O
)	O
{	O
printf	(*(char))->(int)
(	O
" NODELETE"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_NODELETE	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_LOADFLTR	O
)	O
{	O
printf	(*(char))->(int)
(	O
" LOADFLTR"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_LOADFLTR	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_INITFIRST	O
)	O
{	O
printf	(*(char))->(int)
(	O
" INITFIRST"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_INITFIRST	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_NOOPEN	O
)	O
{	O
printf	(*(char))->(int)
(	O
" NOOPEN"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_NOOPEN	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_ORIGIN	O
)	O
{	O
printf	(*(char))->(int)
(	O
" ORIGIN"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_ORIGIN	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_DIRECT	O
)	O
{	O
printf	(*(char))->(int)
(	O
" DIRECT"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_DIRECT	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_TRANS	O
)	O
{	O
printf	(*(char))->(int)
(	O
" TRANS"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_TRANS	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_INTERPOSE	O
)	O
{	O
printf	(*(char))->(int)
(	O
" INTERPOSE"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_INTERPOSE	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_NODEFLIB	O
)	O
{	O
printf	(*(char))->(int)
(	O
" NODEFLIB"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_NODEFLIB	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_NODUMP	O
)	O
{	O
printf	(*(char))->(int)
(	O
" NODUMP"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_NODUMP	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_CONFALT	O
)	O
{	O
printf	(*(char))->(int)
(	O
" CONFALT"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_CONFALT	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_ENDFILTEE	O
)	O
{	O
printf	(*(char))->(int)
(	O
" ENDFILTEE"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_ENDFILTEE	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_DISPRELDNE	O
)	O
{	O
printf	(*(char))->(int)
(	O
" DISPRELDNE"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_DISPRELDNE	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_DISPRELPND	O
)	O
{	O
printf	(*(char))->(int)
(	O
" DISPRELPND"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_DISPRELPND	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_NODIRECT	O
)	O
{	O
printf	(*(char))->(int)
(	O
" NODIRECT"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_NODIRECT	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_IGNMULDEF	O
)	O
{	O
printf	(*(char))->(int)
(	O
" IGNMULDEF"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_IGNMULDEF	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_NOKSYMS	O
)	O
{	O
printf	(*(char))->(int)
(	O
" NOKSYMS"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_NOKSYMS	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_NOHDR	O
)	O
{	O
printf	(*(char))->(int)
(	O
" NOHDR"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_NOHDR	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_EDITED	O
)	O
{	O
printf	(*(char))->(int)
(	O
" EDITED"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_EDITED	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_NORELOC	O
)	O
{	O
printf	(*(char))->(int)
(	O
" NORELOC"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_NORELOC	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_SYMINTPOSE	O
)	O
{	O
printf	(*(char))->(int)
(	O
" SYMINTPOSE"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_SYMINTPOSE	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_GLOBAUDIT	O
)	O
{	O
printf	(*(char))->(int)
(	O
" GLOBAUDIT"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_GLOBAUDIT	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_SINGLETON	O
)	O
{	O
printf	(*(char))->(int)
(	O
" SINGLETON"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_SINGLETON	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_STUB	O
)	O
{	O
printf	(*(char))->(int)
(	O
" STUB"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_STUB	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_PIE	O
)	O
{	O
printf	(*(char))->(int)
(	O
" PIE"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_PIE	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_KMOD	O
)	O
{	O
printf	(*(char))->(int)
(	O
" KMOD"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_KMOD	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_WEAKFILTER	O
)	O
{	O
printf	(*(char))->(int)
(	O
" WEAKFILTER"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_WEAKFILTER	O
;	O
}	O
if	O
(	O
val	array(int)
&	O
DF_1_NOCOMMON	O
)	O
{	O
printf	(*(char))->(int)
(	O
" NOCOMMON"	*(char)
)	O
;	O
val	array(int)
^=	O
DF_1_NOCOMMON	O
;	O
}	O
if	O
(	O
val	array(int)
!=	O
0	int
)	O
printf	(*(char))->(int)
(	O
" %lx"	*(char)
,	O
val	array(int)
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DT_PLTREL	O
:	O
dynamic_info	O
[	O
entry	O
->	O
d_tag	O
]	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
if	O
(	O
do_dynamic	O
)	O
puts	(*(char))->(int)
(	O
get_dynamic_type	O
(	O
filedata	O
,	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
)	O
;	O
break	O
;	O
case	O
DT_NULL	O
:	O
case	O
DT_NEEDED	O
:	O
case	O
DT_PLTGOT	O
:	O
case	O
DT_HASH	O
:	O
case	O
DT_STRTAB	O
:	O
case	O
DT_SYMTAB	O
:	O
case	O
DT_RELA	O
:	O
case	O
DT_INIT	O
:	O
case	O
DT_FINI	O
:	O
case	O
DT_SONAME	O
:	O
case	O
DT_RPATH	O
:	O
case	O
DT_SYMBOLIC	O
:	O
case	O
DT_REL	O
:	O
case	O
DT_DEBUG	O
:	O
case	O
DT_TEXTREL	O
:	O
case	O
DT_JMPREL	O
:	O
case	O
DT_RUNPATH	O
:	O
dynamic_info	O
[	O
entry	O
->	O
d_tag	O
]	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
if	O
(	O
do_dynamic	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
)	O
name	*(char)
=	O
GET_DYNAMIC_NAME	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
;	O
else	O
name	*(char)
=	O
NULL	O
;	O
if	O
(	O
name	*(char)
)	O
{	O
switch	O
(	O
entry	O
->	O
d_tag	O
)	O
{	O
case	O
DT_NEEDED	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Shared library: [%s]"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
streq	O
(	O
name	*(char)
,	O
program_interpreter	O
)	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
" program interpreter"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
DT_SONAME	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Library soname: [%s]"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
break	O
;	O
case	O
DT_RPATH	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Library rpath: [%s]"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
break	O
;	O
case	O
DT_RUNPATH	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Library runpath: [%s]"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
PREFIX_HEX	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
PREFIX_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
break	O
;	O
case	O
DT_PLTRELSZ	O
:	O
case	O
DT_RELASZ	O
:	O
case	O
DT_STRSZ	O
:	O
case	O
DT_RELSZ	O
:	O
case	O
DT_RELAENT	O
:	O
case	O
DT_SYMENT	O
:	O
case	O
DT_RELENT	O
:	O
dynamic_info	O
[	O
entry	O
->	O
d_tag	O
]	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
case	O
DT_PLTPADSZ	O
:	O
case	O
DT_MOVEENT	O
:	O
case	O
DT_MOVESZ	O
:	O
case	O
DT_INIT_ARRAYSZ	O
:	O
case	O
DT_FINI_ARRAYSZ	O
:	O
case	O
DT_GNU_CONFLICTSZ	O
:	O
case	O
DT_GNU_LIBLISTSZ	O
:	O
if	O
(	O
do_dynamic	O
)	O
{	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
UNSIGNED	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" (bytes)\n"	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
DT_VERDEFNUM	O
:	O
case	O
DT_VERNEEDNUM	O
:	O
case	O
DT_RELACOUNT	O
:	O
case	O
DT_RELCOUNT	O
:	O
if	O
(	O
do_dynamic	O
)	O
{	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
UNSIGNED	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
break	O
;	O
case	O
DT_SYMINSZ	O
:	O
case	O
DT_SYMINENT	O
:	O
case	O
DT_SYMINFO	O
:	O
case	O
DT_USED	O
:	O
case	O
DT_INIT_ARRAY	O
:	O
case	O
DT_FINI_ARRAY	O
:	O
if	O
(	O
do_dynamic	O
)	O
{	O
if	O
(	O
entry	O
->	O
d_tag	O
==	O
DT_USED	O
&&	O
VALID_DYNAMIC_NAME	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
)	O
{	O
char	O
*	O
name	*(char)
=	O
GET_DYNAMIC_NAME	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
)	O
;	O
if	O
(	O
*	O
name	*(char)
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Not needed object: [%s]\n"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
PREFIX_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
break	O
;	O
case	O
DT_BIND_NOW	O
:	O
if	O
(	O
do_dynamic	O
)	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
break	O
;	O
case	O
DT_GNU_PRELINKED	O
:	O
if	O
(	O
do_dynamic	O
)	O
{	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tmp	O
;	O
time_t	long
atime	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
tmp	O
=	O
gmtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
atime	O
)	O
;	O
if	O
(	O
tmp	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt time val: %lx"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
atime	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%04u-%02u-%02uT%02u:%02u:%02u\n"	*(char)
,	O
tmp	O
->	O
tm_year	int
+	O
1900	int
,	O
tmp	O
->	O
tm_mon	int
+	O
1	int
,	O
tmp	O
->	O
tm_mday	int
,	O
tmp	O
->	O
tm_hour	int
,	O
tmp	O
->	O
tm_min	int
,	O
tmp	O
->	O
tm_sec	int
)	O
;	O
}	O
break	O
;	O
case	O
DT_GNU_HASH	O
:	O
dynamic_info_DT_GNU_HASH	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
if	O
(	O
do_dynamic	O
)	O
{	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
PREFIX_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
entry	O
->	O
d_tag	O
>=	O
DT_VERSYM	O
)	O
&&	O
(	O
entry	O
->	O
d_tag	O
<=	O
DT_VERNEEDNUM	O
)	O
)	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
entry	O
->	O
d_tag	O
)	O
]	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
if	O
(	O
do_dynamic	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_AARCH64	O
:	O
dynamic_section_aarch64_val	O
(	O
entry	O
)	O
;	O
break	O
;	O
case	O
EM_MIPS	O
:	O
case	O
EM_MIPS_RS3_LE	O
:	O
dynamic_section_mips_val	O
(	O
entry	O
)	O
;	O
break	O
;	O
case	O
EM_PARISC	O
:	O
dynamic_section_parisc_val	O
(	O
entry	O
)	O
;	O
break	O
;	O
case	O
EM_IA_64	O
:	O
dynamic_section_ia64_val	O
(	O
entry	O
)	O
;	O
break	O
;	O
default	O
:	O
print_vma	O
(	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
PREFIX_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
char	O
*	O
get_ver_flags	O
(	O
unsigned	O
int	O
flags	int
)	O
{	O
static	O
char	O
buff	O
[	O
128	int
]	O
;	O
buff	O
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
flags	int
==	O
0	int
)	O
return	O
_	O
(	O
"none"	*(char)
)	O
;	O
if	O
(	O
flags	int
&	O
VER_FLG_BASE	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buff	O
,	O
"BASE"	*(char)
)	O
;	O
if	O
(	O
flags	int
&	O
VER_FLG_WEAK	O
)	O
{	O
if	O
(	O
flags	int
&	O
VER_FLG_BASE	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buff	O
,	O
" | "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buff	O
,	O
"WEAK"	*(char)
)	O
;	O
}	O
if	O
(	O
flags	int
&	O
VER_FLG_INFO	O
)	O
{	O
if	O
(	O
flags	int
&	O
(	O
VER_FLG_BASE	O
|	O
VER_FLG_WEAK	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buff	O
,	O
" | "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buff	O
,	O
"INFO"	*(char)
)	O
;	O
}	O
if	O
(	O
flags	int
&	O
~	O
(	O
VER_FLG_BASE	O
|	O
VER_FLG_WEAK	O
|	O
VER_FLG_INFO	O
)	O
)	O
{	O
if	O
(	O
flags	int
&	O
(	O
VER_FLG_BASE	O
|	O
VER_FLG_WEAK	O
|	O
VER_FLG_INFO	O
)	O
)	O
strcat	(*(char),*(char))->(*(char))
(	O
buff	O
,	O
" | "	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buff	O
,	O
_	O
(	O
"<unknown>"	*(char)
)	O
)	O
;	O
}	O
return	O
buff	O
;	O
}	O
static	O
bfd_boolean	int
process_version_sections	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
unsigned	O
i	*(struct)
;	O
bfd_boolean	int
found	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
do_version	O
)	O
return	O
TRUE	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
)	O
{	O
switch	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
)	O
{	O
case	O
SHT_GNU_verdef	O
:	O
{	O
Elf_External_Verdef	O
*	O
edefs	O
;	O
unsigned	O
long	O
idx	O
;	O
unsigned	O
long	O
cnt	O
;	O
char	O
*	O
endbuf	O
;	O
found	O
=	O
TRUE	int
;	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nVersion definition section '%s' "	*(char)
"contains %u entry:\n"	*(char)
,	O
"\nVersion definition section '%s' "	*(char)
"contains %u entries:\n"	*(char)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Addr: 0x"	*(char)
)	O
)	O
;	O
printf_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Offset: %#08lx  Link: %u (%s)\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
,	O
printable_section_name_from_index	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
)	O
)	O
;	O
edefs	O
=	O
(	O
Elf_External_Verdef	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
_	O
(	O
"version definition section"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
edefs	O
)	O
break	O
;	O
endbuf	O
=	O
(	O
char	O
*	O
)	O
edefs	O
+	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
for	O
(	O
idx	O
=	O
cnt	O
=	O
0	int
;	O
cnt	O
<	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
;	O
++	O
cnt	O
)	O
{	O
char	O
*	O
vstart	O
;	O
Elf_External_Verdef	O
*	O
edef	O
;	O
Elf_Internal_Verdef	O
ent	O
;	O
Elf_External_Verdaux	O
*	O
eaux	O
;	O
Elf_Internal_Verdaux	O
aux	O
;	O
unsigned	O
long	O
isum	O
;	O
int	O
j	O
;	O
vstart	O
=	O
(	O
(	O
char	O
*	O
)	O
edefs	O
)	O
+	O
idx	O
;	O
if	O
(	O
vstart	O
+	O
sizeof	O
(	O
*	O
edef	O
)	O
>	O
endbuf	O
)	O
break	O
;	O
edef	O
=	O
(	O
Elf_External_Verdef	O
*	O
)	O
vstart	O
;	O
ent	O
.	O
vd_version	O
=	O
BYTE_GET	O
(	O
edef	O
->	O
vd_version	O
)	O
;	O
ent	O
.	O
vd_flags	O
=	O
BYTE_GET	O
(	O
edef	O
->	O
vd_flags	O
)	O
;	O
ent	O
.	O
vd_ndx	O
=	O
BYTE_GET	O
(	O
edef	O
->	O
vd_ndx	O
)	O
;	O
ent	O
.	O
vd_cnt	O
=	O
BYTE_GET	O
(	O
edef	O
->	O
vd_cnt	O
)	O
;	O
ent	O
.	O
vd_hash	O
=	O
BYTE_GET	O
(	O
edef	O
->	O
vd_hash	O
)	O
;	O
ent	O
.	O
vd_aux	O
=	O
BYTE_GET	O
(	O
edef	O
->	O
vd_aux	O
)	O
;	O
ent	O
.	O
vd_next	O
=	O
BYTE_GET	O
(	O
edef	O
->	O
vd_next	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  %#06lx: Rev: %d  Flags: %s"	*(char)
)	O
,	O
idx	O
,	O
ent	O
.	O
vd_version	O
,	O
get_ver_flags	O
(	O
ent	O
.	O
vd_flags	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Index: %d  Cnt: %d  "	*(char)
)	O
,	O
ent	O
.	O
vd_ndx	O
,	O
ent	O
.	O
vd_cnt	O
)	O
;	O
if	O
(	O
ent	O
.	O
vd_aux	O
>	O
(	O
size_t	long
)	O
(	O
endbuf	O
-	O
vstart	O
)	O
)	O
break	O
;	O
vstart	O
+=	O
ent	O
.	O
vd_aux	O
;	O
if	O
(	O
vstart	O
+	O
sizeof	O
(	O
*	O
eaux	O
)	O
>	O
endbuf	O
)	O
break	O
;	O
eaux	O
=	O
(	O
Elf_External_Verdaux	O
*	O
)	O
vstart	O
;	O
aux	O
.	O
vda_name	O
=	O
BYTE_GET	O
(	O
eaux	O
->	O
vda_name	O
)	O
;	O
aux	O
.	O
vda_next	O
=	O
BYTE_GET	O
(	O
eaux	O
->	O
vda_next	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
aux	O
.	O
vda_name	O
)	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Name: %s\n"	*(char)
)	O
,	O
GET_DYNAMIC_NAME	O
(	O
aux	O
.	O
vda_name	O
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Name index: %ld\n"	*(char)
)	O
,	O
aux	O
.	O
vda_name	O
)	O
;	O
isum	O
=	O
idx	O
+	O
ent	O
.	O
vd_aux	O
;	O
for	O
(	O
j	O
=	O
1	int
;	O
j	O
<	O
ent	O
.	O
vd_cnt	O
;	O
j	O
++	O
)	O
{	O
if	O
(	O
aux	O
.	O
vda_next	O
<	O
sizeof	O
(	O
*	O
eaux	O
)	O
&&	O
!	O
(	O
j	O
==	O
ent	O
.	O
vd_cnt	O
-	O
1	int
&&	O
aux	O
.	O
vda_next	O
==	O
0	int
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Invalid vda_next field of %lx\n"	*(char)
)	O
,	O
aux	O
.	O
vda_next	O
)	O
;	O
j	O
=	O
ent	O
.	O
vd_cnt	O
;	O
break	O
;	O
}	O
if	O
(	O
aux	O
.	O
vda_next	O
>	O
(	O
size_t	long
)	O
(	O
endbuf	O
-	O
vstart	O
)	O
)	O
break	O
;	O
isum	O
+=	O
aux	O
.	O
vda_next	O
;	O
vstart	O
+=	O
aux	O
.	O
vda_next	O
;	O
if	O
(	O
vstart	O
+	O
sizeof	O
(	O
*	O
eaux	O
)	O
>	O
endbuf	O
)	O
break	O
;	O
eaux	O
=	O
(	O
Elf_External_Verdaux	O
*	O
)	O
vstart	O
;	O
aux	O
.	O
vda_name	O
=	O
BYTE_GET	O
(	O
eaux	O
->	O
vda_name	O
)	O
;	O
aux	O
.	O
vda_next	O
=	O
BYTE_GET	O
(	O
eaux	O
->	O
vda_next	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
aux	O
.	O
vda_name	O
)	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  %#06lx: Parent %d: %s\n"	*(char)
)	O
,	O
isum	O
,	O
j	O
,	O
GET_DYNAMIC_NAME	O
(	O
aux	O
.	O
vda_name	O
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  %#06lx: Parent %d, name index: %ld\n"	*(char)
)	O
,	O
isum	O
,	O
j	O
,	O
aux	O
.	O
vda_name	O
)	O
;	O
}	O
if	O
(	O
j	O
<	O
ent	O
.	O
vd_cnt	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Version def aux past end of section\n"	*(char)
)	O
)	O
;	O
if	O
(	O
ent	O
.	O
vd_next	O
<	O
sizeof	O
(	O
*	O
edef	O
)	O
&&	O
!	O
(	O
cnt	O
==	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
-	O
1	int
&&	O
ent	O
.	O
vd_next	O
==	O
0	int
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Invalid vd_next field of %lx\n"	*(char)
)	O
,	O
ent	O
.	O
vd_next	O
)	O
;	O
cnt	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
;	O
break	O
;	O
}	O
if	O
(	O
ent	O
.	O
vd_next	O
>	O
(	O
size_t	long
)	O
(	O
endbuf	O
-	O
(	O
(	O
char	O
*	O
)	O
edefs	O
+	O
idx	O
)	O
)	O
)	O
break	O
;	O
idx	O
+=	O
ent	O
.	O
vd_next	O
;	O
}	O
if	O
(	O
cnt	O
<	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Version definition past end of section\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
edefs	O
)	O
;	O
}	O
break	O
;	O
case	O
SHT_GNU_verneed	O
:	O
{	O
Elf_External_Verneed	O
*	O
eneed	O
;	O
unsigned	O
long	O
idx	O
;	O
unsigned	O
long	O
cnt	O
;	O
char	O
*	O
endbuf	O
;	O
found	O
=	O
TRUE	int
;	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nVersion needs section '%s' "	*(char)
"contains %u entry:\n"	*(char)
,	O
"\nVersion needs section '%s' "	*(char)
"contains %u entries:\n"	*(char)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Addr: 0x"	*(char)
)	O
)	O
;	O
printf_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Offset: %#08lx  Link: %u (%s)\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
,	O
printable_section_name_from_index	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
)	O
)	O
;	O
eneed	O
=	O
(	O
Elf_External_Verneed	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
_	O
(	O
"Version Needs section"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
eneed	O
)	O
break	O
;	O
endbuf	O
=	O
(	O
char	O
*	O
)	O
eneed	O
+	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
for	O
(	O
idx	O
=	O
cnt	O
=	O
0	int
;	O
cnt	O
<	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
;	O
++	O
cnt	O
)	O
{	O
Elf_External_Verneed	O
*	O
entry	O
;	O
Elf_Internal_Verneed	O
ent	O
;	O
unsigned	O
long	O
isum	O
;	O
int	O
j	O
;	O
char	O
*	O
vstart	O
;	O
vstart	O
=	O
(	O
(	O
char	O
*	O
)	O
eneed	O
)	O
+	O
idx	O
;	O
if	O
(	O
vstart	O
+	O
sizeof	O
(	O
*	O
entry	O
)	O
>	O
endbuf	O
)	O
break	O
;	O
entry	O
=	O
(	O
Elf_External_Verneed	O
*	O
)	O
vstart	O
;	O
ent	O
.	O
vn_version	O
=	O
BYTE_GET	O
(	O
entry	O
->	O
vn_version	O
)	O
;	O
ent	O
.	O
vn_cnt	O
=	O
BYTE_GET	O
(	O
entry	O
->	O
vn_cnt	O
)	O
;	O
ent	O
.	O
vn_file	O
=	O
BYTE_GET	O
(	O
entry	O
->	O
vn_file	O
)	O
;	O
ent	O
.	O
vn_aux	O
=	O
BYTE_GET	O
(	O
entry	O
->	O
vn_aux	O
)	O
;	O
ent	O
.	O
vn_next	O
=	O
BYTE_GET	O
(	O
entry	O
->	O
vn_next	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  %#06lx: Version: %d"	*(char)
)	O
,	O
idx	O
,	O
ent	O
.	O
vn_version	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
ent	O
.	O
vn_file	O
)	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  File: %s"	*(char)
)	O
,	O
GET_DYNAMIC_NAME	O
(	O
ent	O
.	O
vn_file	O
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  File: %lx"	*(char)
)	O
,	O
ent	O
.	O
vn_file	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Cnt: %d\n"	*(char)
)	O
,	O
ent	O
.	O
vn_cnt	O
)	O
;	O
if	O
(	O
ent	O
.	O
vn_aux	O
>	O
(	O
size_t	long
)	O
(	O
endbuf	O
-	O
vstart	O
)	O
)	O
break	O
;	O
vstart	O
+=	O
ent	O
.	O
vn_aux	O
;	O
for	O
(	O
j	O
=	O
0	int
,	O
isum	O
=	O
idx	O
+	O
ent	O
.	O
vn_aux	O
;	O
j	O
<	O
ent	O
.	O
vn_cnt	O
;	O
++	O
j	O
)	O
{	O
Elf_External_Vernaux	O
*	O
eaux	O
;	O
Elf_Internal_Vernaux	O
aux	O
;	O
if	O
(	O
vstart	O
+	O
sizeof	O
(	O
*	O
eaux	O
)	O
>	O
endbuf	O
)	O
break	O
;	O
eaux	O
=	O
(	O
Elf_External_Vernaux	O
*	O
)	O
vstart	O
;	O
aux	O
.	O
vna_hash	O
=	O
BYTE_GET	O
(	O
eaux	O
->	O
vna_hash	O
)	O
;	O
aux	O
.	O
vna_flags	O
=	O
BYTE_GET	O
(	O
eaux	O
->	O
vna_flags	O
)	O
;	O
aux	O
.	O
vna_other	O
=	O
BYTE_GET	O
(	O
eaux	O
->	O
vna_other	O
)	O
;	O
aux	O
.	O
vna_name	O
=	O
BYTE_GET	O
(	O
eaux	O
->	O
vna_name	O
)	O
;	O
aux	O
.	O
vna_next	O
=	O
BYTE_GET	O
(	O
eaux	O
->	O
vna_next	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
aux	O
.	O
vna_name	O
)	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  %#06lx:   Name: %s"	*(char)
)	O
,	O
isum	O
,	O
GET_DYNAMIC_NAME	O
(	O
aux	O
.	O
vna_name	O
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  %#06lx:   Name index: %lx"	*(char)
)	O
,	O
isum	O
,	O
aux	O
.	O
vna_name	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Flags: %s  Version: %d\n"	*(char)
)	O
,	O
get_ver_flags	O
(	O
aux	O
.	O
vna_flags	O
)	O
,	O
aux	O
.	O
vna_other	O
)	O
;	O
if	O
(	O
aux	O
.	O
vna_next	O
<	O
sizeof	O
(	O
*	O
eaux	O
)	O
&&	O
!	O
(	O
j	O
==	O
ent	O
.	O
vn_cnt	O
-	O
1	int
&&	O
aux	O
.	O
vna_next	O
==	O
0	int
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Invalid vna_next field of %lx\n"	*(char)
)	O
,	O
aux	O
.	O
vna_next	O
)	O
;	O
j	O
=	O
ent	O
.	O
vn_cnt	O
;	O
break	O
;	O
}	O
if	O
(	O
aux	O
.	O
vna_next	O
>	O
(	O
size_t	long
)	O
(	O
endbuf	O
-	O
vstart	O
)	O
)	O
break	O
;	O
isum	O
+=	O
aux	O
.	O
vna_next	O
;	O
vstart	O
+=	O
aux	O
.	O
vna_next	O
;	O
}	O
if	O
(	O
j	O
<	O
ent	O
.	O
vn_cnt	O
)	O
warn	O
(	O
_	O
(	O
"Missing Version Needs auxillary information\n"	*(char)
)	O
)	O
;	O
if	O
(	O
ent	O
.	O
vn_next	O
<	O
sizeof	O
(	O
*	O
entry	O
)	O
&&	O
!	O
(	O
cnt	O
==	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
-	O
1	int
&&	O
ent	O
.	O
vn_next	O
==	O
0	int
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Invalid vn_next field of %lx\n"	*(char)
)	O
,	O
ent	O
.	O
vn_next	O
)	O
;	O
cnt	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
;	O
break	O
;	O
}	O
if	O
(	O
ent	O
.	O
vn_next	O
>	O
(	O
size_t	long
)	O
(	O
endbuf	O
-	O
(	O
(	O
char	O
*	O
)	O
eneed	O
+	O
idx	O
)	O
)	O
)	O
break	O
;	O
idx	O
+=	O
ent	O
.	O
vn_next	O
;	O
}	O
if	O
(	O
cnt	O
<	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
)	O
warn	O
(	O
_	O
(	O
"Missing Version Needs information\n"	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
eneed	O
)	O
;	O
}	O
break	O
;	O
case	O
SHT_GNU_versym	O
:	O
{	O
Elf_Internal_Shdr	O
*	O
link_section	O
;	O
size_t	long
total	O
;	O
unsigned	O
int	O
cnt	O
;	O
unsigned	O
char	O
*	O
edata	O
;	O
unsigned	O
short	O
*	O
data	*(void)
;	O
char	O
*	O
strtab	O
;	O
Elf_Internal_Sym	O
*	O
symbols	O
;	O
Elf_Internal_Shdr	O
*	O
string_sec	O
;	O
unsigned	O
long	O
num_syms	O
;	O
long	O
off	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
break	O
;	O
link_section	O
=	O
filedata	O
->	O
section_headers	O
+	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
;	O
total	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
/	O
sizeof	O
(	O
Elf_External_Versym	O
)	O
;	O
if	O
(	O
link_section	O
->	O
sh_link	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
break	O
;	O
found	O
=	O
TRUE	int
;	O
symbols	O
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	O
,	O
link_section	O
,	O
&	O
num_syms	O
)	O
;	O
if	O
(	O
symbols	O
==	O
NULL	O
)	O
break	O
;	O
string_sec	O
=	O
filedata	O
->	O
section_headers	O
+	O
link_section	O
->	O
sh_link	O
;	O
strtab	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
string_sec	O
->	O
sh_offset	O
,	O
1	int
,	O
string_sec	O
->	O
sh_size	O
,	O
_	O
(	O
"version string table"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
strtab	O
)	O
{	O
free	(*(void))->(void)
(	O
symbols	O
)	O
;	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nVersion symbols section '%s' "	*(char)
"contains %lu entry:\n"	*(char)
,	O
"\nVersion symbols section '%s' "	*(char)
"contains %lu entries:\n"	*(char)
,	O
total	O
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
(	O
unsigned	O
long	O
)	O
total	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Addr: 0x"	*(char)
)	O
)	O
;	O
printf_vma	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Offset: %#08lx  Link: %u (%s)\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
link_section	O
)	O
)	O
;	O
off	O
=	O
offset_from_vma	O
(	O
filedata	O
,	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERSYM	O
)	O
]	O
,	O
total	O
*	O
sizeof	O
(	O
short	O
)	O
)	O
;	O
edata	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
off	O
,	O
total	O
,	O
sizeof	O
(	O
short	O
)	O
,	O
_	O
(	O
"version symbol data"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
edata	O
)	O
{	O
free	(*(void))->(void)
(	O
strtab	O
)	O
;	O
free	(*(void))->(void)
(	O
symbols	O
)	O
;	O
break	O
;	O
}	O
data	*(void)
=	O
(	O
short	O
unsigned	O
int	O
*	O
)	O
cmalloc	O
(	O
total	O
,	O
sizeof	O
(	O
short	O
)	O
)	O
;	O
for	O
(	O
cnt	O
=	O
total	O
;	O
cnt	O
--	O
;	O
)	O
data	*(void)
[	O
cnt	O
]	O
=	O
byte_get	O
(	O
edata	O
+	O
cnt	O
*	O
sizeof	O
(	O
short	O
)	O
,	O
sizeof	O
(	O
short	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
edata	O
)	O
;	O
for	O
(	O
cnt	O
=	O
0	int
;	O
cnt	O
<	O
total	O
;	O
cnt	O
+=	O
4	int
)	O
{	O
int	O
j	O
,	O
nn	O
;	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
invalid	O
=	O
_	O
(	O
"*invalid*"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"  %03x:"	*(char)
,	O
cnt	O
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
(	O
j	O
<	O
4	int
)	O
&&	O
(	O
cnt	O
+	O
j	O
)	O
<	O
total	O
;	O
++	O
j	O
)	O
switch	O
(	O
data	*(void)
[	O
cnt	O
+	O
j	O
]	O
)	O
{	O
case	O
0	int
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"   0 (*local*)    "	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
1	int
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"   1 (*global*)   "	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
default	O
:	O
nn	O
=	O
printf	(*(char))->(int)
(	O
"%4x%c"	*(char)
,	O
data	*(void)
[	O
cnt	O
+	O
j	O
]	O
&	O
VERSYM_VERSION	O
,	O
data	*(void)
[	O
cnt	O
+	O
j	O
]	O
&	O
VERSYM_HIDDEN	O
?	O
'h'	O
:	O
' '	O
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
cnt	O
+	O
j	O
)	O
>=	O
num_syms	O
)	O
{	O
warn	O
(	O
_	O
(	O
"invalid index into symbol array\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
name	*(char)
=	O
NULL	O
;	O
if	O
(	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERNEED	O
)	O
]	O
)	O
{	O
Elf_Internal_Verneed	O
ivn	O
;	O
unsigned	O
long	O
offset	long
;	O
offset	long
=	O
offset_from_vma	O
(	O
filedata	O
,	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERNEED	O
)	O
]	O
,	O
sizeof	O
(	O
Elf_External_Verneed	O
)	O
)	O
;	O
do	O
{	O
Elf_Internal_Vernaux	O
ivna	O
;	O
Elf_External_Verneed	O
evn	O
;	O
Elf_External_Vernaux	O
evna	O
;	O
unsigned	O
long	O
a_off	O
;	O
if	O
(	O
get_data	O
(	O
&	O
evn	O
,	O
filedata	O
,	O
offset	long
,	O
sizeof	O
(	O
evn	O
)	O
,	O
1	int
,	O
_	O
(	O
"version need"	*(char)
)	O
)	O
==	O
NULL	O
)	O
break	O
;	O
ivn	O
.	O
vn_aux	O
=	O
BYTE_GET	O
(	O
evn	O
.	O
vn_aux	O
)	O
;	O
ivn	O
.	O
vn_next	O
=	O
BYTE_GET	O
(	O
evn	O
.	O
vn_next	O
)	O
;	O
a_off	O
=	O
offset	long
+	O
ivn	O
.	O
vn_aux	O
;	O
do	O
{	O
if	O
(	O
get_data	O
(	O
&	O
evna	O
,	O
filedata	O
,	O
a_off	O
,	O
sizeof	O
(	O
evna	O
)	O
,	O
1	int
,	O
_	O
(	O
"version need aux (2)"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
ivna	O
.	O
vna_next	O
=	O
0	int
;	O
ivna	O
.	O
vna_other	O
=	O
0	int
;	O
}	O
else	O
{	O
ivna	O
.	O
vna_next	O
=	O
BYTE_GET	O
(	O
evna	O
.	O
vna_next	O
)	O
;	O
ivna	O
.	O
vna_other	O
=	O
BYTE_GET	O
(	O
evna	O
.	O
vna_other	O
)	O
;	O
}	O
a_off	O
+=	O
ivna	O
.	O
vna_next	O
;	O
}	O
while	O
(	O
ivna	O
.	O
vna_other	O
!=	O
data	*(void)
[	O
cnt	O
+	O
j	O
]	O
&&	O
ivna	O
.	O
vna_next	O
!=	O
0	int
)	O
;	O
if	O
(	O
ivna	O
.	O
vna_other	O
==	O
data	*(void)
[	O
cnt	O
+	O
j	O
]	O
)	O
{	O
ivna	O
.	O
vna_name	O
=	O
BYTE_GET	O
(	O
evna	O
.	O
vna_name	O
)	O
;	O
if	O
(	O
ivna	O
.	O
vna_name	O
>=	O
string_sec	O
->	O
sh_size	O
)	O
name	*(char)
=	O
invalid	O
;	O
else	O
name	*(char)
=	O
strtab	O
+	O
ivna	O
.	O
vna_name	O
;	O
break	O
;	O
}	O
offset	long
+=	O
ivn	O
.	O
vn_next	O
;	O
}	O
while	O
(	O
ivn	O
.	O
vn_next	O
)	O
;	O
}	O
if	O
(	O
data	*(void)
[	O
cnt	O
+	O
j	O
]	O
!=	O
0x8001	int
&&	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERDEF	O
)	O
]	O
)	O
{	O
Elf_Internal_Verdef	O
ivd	O
;	O
Elf_External_Verdef	O
evd	O
;	O
unsigned	O
long	O
offset	long
;	O
offset	long
=	O
offset_from_vma	O
(	O
filedata	O
,	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERDEF	O
)	O
]	O
,	O
sizeof	O
evd	O
)	O
;	O
do	O
{	O
if	O
(	O
get_data	O
(	O
&	O
evd	O
,	O
filedata	O
,	O
offset	long
,	O
sizeof	O
(	O
evd	O
)	O
,	O
1	int
,	O
_	O
(	O
"version def"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
ivd	O
.	O
vd_next	O
=	O
0	int
;	O
ivd	O
.	O
vd_ndx	O
=	O
(	O
data	*(void)
[	O
cnt	O
+	O
j	O
]	O
&	O
VERSYM_VERSION	O
)	O
+	O
1	int
;	O
break	O
;	O
}	O
else	O
{	O
ivd	O
.	O
vd_next	O
=	O
BYTE_GET	O
(	O
evd	O
.	O
vd_next	O
)	O
;	O
ivd	O
.	O
vd_ndx	O
=	O
BYTE_GET	O
(	O
evd	O
.	O
vd_ndx	O
)	O
;	O
}	O
offset	long
+=	O
ivd	O
.	O
vd_next	O
;	O
}	O
while	O
(	O
ivd	O
.	O
vd_ndx	O
!=	O
(	O
data	*(void)
[	O
cnt	O
+	O
j	O
]	O
&	O
VERSYM_VERSION	O
)	O
&&	O
ivd	O
.	O
vd_next	O
!=	O
0	int
)	O
;	O
if	O
(	O
ivd	O
.	O
vd_ndx	O
==	O
(	O
data	*(void)
[	O
cnt	O
+	O
j	O
]	O
&	O
VERSYM_VERSION	O
)	O
)	O
{	O
Elf_External_Verdaux	O
evda	O
;	O
Elf_Internal_Verdaux	O
ivda	O
;	O
ivd	O
.	O
vd_aux	O
=	O
BYTE_GET	O
(	O
evd	O
.	O
vd_aux	O
)	O
;	O
if	O
(	O
get_data	O
(	O
&	O
evda	O
,	O
filedata	O
,	O
offset	long
-	O
ivd	O
.	O
vd_next	O
+	O
ivd	O
.	O
vd_aux	O
,	O
sizeof	O
(	O
evda	O
)	O
,	O
1	int
,	O
_	O
(	O
"version def aux"	*(char)
)	O
)	O
==	O
NULL	O
)	O
break	O
;	O
ivda	O
.	O
vda_name	O
=	O
BYTE_GET	O
(	O
evda	O
.	O
vda_name	O
)	O
;	O
if	O
(	O
ivda	O
.	O
vda_name	O
>=	O
string_sec	O
->	O
sh_size	O
)	O
name	*(char)
=	O
invalid	O
;	O
else	O
if	O
(	O
name	*(char)
!=	O
NULL	O
&&	O
name	*(char)
!=	O
invalid	O
)	O
name	*(char)
=	O
_	O
(	O
"*both*"	*(char)
)	O
;	O
else	O
name	*(char)
=	O
strtab	O
+	O
ivda	O
.	O
vda_name	O
;	O
}	O
}	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
nn	O
+=	O
printf	(*(char))->(int)
(	O
"(%s%-*s"	*(char)
,	O
name	*(char)
,	O
12	int
-	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
,	O
")"	*(char)
)	O
;	O
if	O
(	O
nn	O
<	O
18	int
)	O
printf	(*(char))->(int)
(	O
"%*c"	*(char)
,	O
18	int
-	O
nn	O
,	O
' '	O
)	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
strtab	O
)	O
;	O
free	(*(void))->(void)
(	O
symbols	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
found	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nNo version information found in this file.\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
get_symbol_binding	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
binding	O
)	O
{	O
static	O
char	O
buff	O
[	O
32	int
]	O
;	O
switch	O
(	O
binding	O
)	O
{	O
case	O
STB_LOCAL	O
:	O
return	O
"LOCAL"	*(char)
;	O
case	O
STB_GLOBAL	O
:	O
return	O
"GLOBAL"	*(char)
;	O
case	O
STB_WEAK	O
:	O
return	O
"WEAK"	*(char)
;	O
default	O
:	O
if	O
(	O
binding	O
>=	O
STB_LOPROC	O
&&	O
binding	O
<=	O
STB_HIPROC	O
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<processor specific>: %d"	*(char)
)	O
,	O
binding	O
)	O
;	O
else	O
if	O
(	O
binding	O
>=	O
STB_LOOS	O
&&	O
binding	O
<=	O
STB_HIOS	O
)	O
{	O
if	O
(	O
binding	O
==	O
STB_GNU_UNIQUE	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_GNU	O
)	O
return	O
"UNIQUE"	*(char)
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<OS specific>: %d"	*(char)
)	O
,	O
binding	O
)	O
;	O
}	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<unknown>: %d"	*(char)
)	O
,	O
binding	O
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_symbol_type	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
type	enum(int,int,int,int)
)	O
{	O
static	O
char	O
buff	O
[	O
32	int
]	O
;	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
STT_NOTYPE	O
:	O
return	O
"NOTYPE"	*(char)
;	O
case	O
STT_OBJECT	O
:	O
return	O
"OBJECT"	*(char)
;	O
case	O
STT_FUNC	O
:	O
return	O
"FUNC"	*(char)
;	O
case	O
STT_SECTION	O
:	O
return	O
"SECTION"	*(char)
;	O
case	O
STT_FILE	O
:	O
return	O
"FILE"	*(char)
;	O
case	O
STT_COMMON	O
:	O
return	O
"COMMON"	*(char)
;	O
case	O
STT_TLS	O
:	O
return	O
"TLS"	*(char)
;	O
case	O
STT_RELC	O
:	O
return	O
"RELC"	*(char)
;	O
case	O
STT_SRELC	O
:	O
return	O
"SRELC"	*(char)
;	O
default	O
:	O
if	O
(	O
type	enum(int,int,int,int)
>=	O
STT_LOPROC	O
&&	O
type	enum(int,int,int,int)
<=	O
STT_HIPROC	O
)	O
{	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_ARM	O
&&	O
type	enum(int,int,int,int)
==	O
STT_ARM_TFUNC	O
)	O
return	O
"THUMB_FUNC"	*(char)
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_SPARCV9	O
&&	O
type	enum(int,int,int,int)
==	O
STT_REGISTER	O
)	O
return	O
"REGISTER"	*(char)
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_PARISC	O
&&	O
type	enum(int,int,int,int)
==	O
STT_PARISC_MILLI	O
)	O
return	O
"PARISC_MILLI"	*(char)
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<processor specific>: %d"	*(char)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
}	O
else	O
if	O
(	O
type	enum(int,int,int,int)
>=	O
STT_LOOS	O
&&	O
type	enum(int,int,int,int)
<=	O
STT_HIOS	O
)	O
{	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_PARISC	O
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
STT_HP_OPAQUE	O
)	O
return	O
"HP_OPAQUE"	*(char)
;	O
if	O
(	O
type	enum(int,int,int,int)
==	O
STT_HP_STUB	O
)	O
return	O
"HP_STUB"	*(char)
;	O
}	O
if	O
(	O
type	enum(int,int,int,int)
==	O
STT_GNU_IFUNC	O
&&	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_GNU	O
||	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_FREEBSD	O
)	O
)	O
return	O
"IFUNC"	*(char)
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<OS specific>: %d"	*(char)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
}	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"<unknown>: %d"	*(char)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_symbol_visibility	O
(	O
unsigned	O
int	O
visibility	O
)	O
{	O
switch	O
(	O
visibility	O
)	O
{	O
case	O
STV_DEFAULT	O
:	O
return	O
"DEFAULT"	*(char)
;	O
case	O
STV_INTERNAL	O
:	O
return	O
"INTERNAL"	*(char)
;	O
case	O
STV_HIDDEN	O
:	O
return	O
"HIDDEN"	*(char)
;	O
case	O
STV_PROTECTED	O
:	O
return	O
"PROTECTED"	*(char)
;	O
default	O
:	O
error	O
(	O
_	O
(	O
"Unrecognized visibility value: %u"	*(char)
)	O
,	O
visibility	O
)	O
;	O
return	O
_	O
(	O
"<unknown>"	*(char)
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_alpha_symbol_other	O
(	O
unsigned	O
int	O
other	O
)	O
{	O
switch	O
(	O
other	O
)	O
{	O
case	O
STO_ALPHA_NOPV	O
:	O
return	O
"NOPV"	*(char)
;	O
case	O
STO_ALPHA_STD_GPLOAD	O
:	O
return	O
"STD GPLOAD"	*(char)
;	O
default	O
:	O
error	O
(	O
_	O
(	O
"Unrecognized alpah specific other value: %u"	*(char)
)	O
,	O
other	O
)	O
;	O
return	O
_	O
(	O
"<unknown>"	*(char)
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_solaris_symbol_visibility	O
(	O
unsigned	O
int	O
visibility	O
)	O
{	O
switch	O
(	O
visibility	O
)	O
{	O
case	O
4	int
:	O
return	O
"EXPORTED"	*(char)
;	O
case	O
5	int
:	O
return	O
"SINGLETON"	*(char)
;	O
case	O
6	int
:	O
return	O
"ELIMINATE"	*(char)
;	O
default	O
:	O
return	O
get_symbol_visibility	O
(	O
visibility	O
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_aarch64_symbol_other	O
(	O
unsigned	O
int	O
other	O
)	O
{	O
static	O
char	O
buf	*(void)
[	O
32	int
]	O
;	O
if	O
(	O
other	O
&	O
STO_AARCH64_VARIANT_PCS	O
)	O
{	O
other	O
&=	O
~	O
STO_AARCH64_VARIANT_PCS	O
;	O
if	O
(	O
other	O
==	O
0	int
)	O
return	O
"VARIANT_PCS"	*(char)
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
,	O
sizeof	O
buf	*(void)
,	O
"VARIANT_PCS | %x"	*(char)
,	O
other	O
)	O
;	O
return	O
buf	*(void)
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_mips_symbol_other	O
(	O
unsigned	O
int	O
other	O
)	O
{	O
switch	O
(	O
other	O
)	O
{	O
case	O
STO_OPTIONAL	O
:	O
return	O
"OPTIONAL"	*(char)
;	O
case	O
STO_MIPS_PLT	O
:	O
return	O
"MIPS PLT"	*(char)
;	O
case	O
STO_MIPS_PIC	O
:	O
return	O
"MIPS PIC"	*(char)
;	O
case	O
STO_MICROMIPS	O
:	O
return	O
"MICROMIPS"	*(char)
;	O
case	O
STO_MICROMIPS	O
|	O
STO_MIPS_PIC	O
:	O
return	O
"MICROMIPS, MIPS PIC"	*(char)
;	O
case	O
STO_MIPS16	O
:	O
return	O
"MIPS16"	*(char)
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_ia64_symbol_other	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
other	O
)	O
{	O
if	O
(	O
is_ia64_vms	O
(	O
filedata	O
)	O
)	O
{	O
static	O
char	O
res	O
[	O
32	int
]	O
;	O
res	O
[	O
0	int
]	O
=	O
0	int
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_type	O
)	O
{	O
case	O
ET_DYN	O
:	O
case	O
ET_EXEC	O
:	O
switch	O
(	O
VMS_ST_FUNC_TYPE	O
(	O
other	O
)	O
)	O
{	O
case	O
VMS_SFT_CODE_ADDR	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
res	O
,	O
" CA"	*(char)
)	O
;	O
break	O
;	O
case	O
VMS_SFT_SYMV_IDX	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
res	O
,	O
" VEC"	*(char)
)	O
;	O
break	O
;	O
case	O
VMS_SFT_FD	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
res	O
,	O
" FD"	*(char)
)	O
;	O
break	O
;	O
case	O
VMS_SFT_RESERVE	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
res	O
,	O
" RSV"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
warn	O
(	O
_	O
(	O
"Unrecognized IA64 VMS ST Function type: %d\n"	*(char)
)	O
,	O
VMS_ST_FUNC_TYPE	O
(	O
other	O
)	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
res	O
,	O
" <unknown>"	*(char)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
VMS_ST_LINKAGE	O
(	O
other	O
)	O
)	O
{	O
case	O
VMS_STL_IGNORE	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
res	O
,	O
" IGN"	*(char)
)	O
;	O
break	O
;	O
case	O
VMS_STL_RESERVE	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
res	O
,	O
" RSV"	*(char)
)	O
;	O
break	O
;	O
case	O
VMS_STL_STD	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
res	O
,	O
" STD"	*(char)
)	O
;	O
break	O
;	O
case	O
VMS_STL_LNK	O
:	O
strcat	(*(char),*(char))->(*(char))
(	O
res	O
,	O
" LNK"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
warn	O
(	O
_	O
(	O
"Unrecognized IA64 VMS ST Linkage: %d\n"	*(char)
)	O
,	O
VMS_ST_LINKAGE	O
(	O
other	O
)	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
res	O
,	O
" <unknown>"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
res	O
[	O
0	int
]	O
!=	O
0	int
)	O
return	O
res	O
+	O
1	int
;	O
else	O
return	O
res	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_ppc64_symbol_other	O
(	O
unsigned	O
int	O
other	O
)	O
{	O
if	O
(	O
(	O
other	O
&	O
~	O
STO_PPC64_LOCAL_MASK	O
)	O
!=	O
0	int
)	O
return	O
NULL	O
;	O
other	O
>>=	O
STO_PPC64_LOCAL_BIT	O
;	O
if	O
(	O
other	O
<=	O
6	int
)	O
{	O
static	O
char	O
buf	*(void)
[	O
32	int
]	O
;	O
if	O
(	O
other	O
>=	O
2	int
)	O
other	O
=	O
ppc64_decode_local_entry	O
(	O
other	O
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
,	O
sizeof	O
buf	*(void)
,	O
_	O
(	O
"<localentry>: %d"	*(char)
)	O
,	O
other	O
)	O
;	O
return	O
buf	*(void)
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
get_symbol_other	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
other	O
)	O
{	O
const	O
char	O
*	O
result	O
=	O
NULL	O
;	O
static	O
char	O
buff	O
[	O
32	int
]	O
;	O
if	O
(	O
other	O
==	O
0	int
)	O
return	O
""	*(char)
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_ALPHA	O
:	O
result	O
=	O
get_alpha_symbol_other	O
(	O
other	O
)	O
;	O
break	O
;	O
case	O
EM_AARCH64	O
:	O
result	O
=	O
get_aarch64_symbol_other	O
(	O
other	O
)	O
;	O
break	O
;	O
case	O
EM_MIPS	O
:	O
result	O
=	O
get_mips_symbol_other	O
(	O
other	O
)	O
;	O
break	O
;	O
case	O
EM_IA_64	O
:	O
result	O
=	O
get_ia64_symbol_other	O
(	O
filedata	O
,	O
other	O
)	O
;	O
break	O
;	O
case	O
EM_PPC64	O
:	O
result	O
=	O
get_ppc64_symbol_other	O
(	O
other	O
)	O
;	O
break	O
;	O
default	O
:	O
result	O
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
result	O
)	O
return	O
result	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
buff	O
,	O
_	O
(	O
"<other>: %x"	*(char)
)	O
,	O
other	O
)	O
;	O
return	O
buff	O
;	O
}	O
static	O
const	O
char	O
*	O
get_symbol_index_type	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
type	enum(int,int,int,int)
)	O
{	O
static	O
char	O
buff	O
[	O
32	int
]	O
;	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
SHN_UNDEF	O
:	O
return	O
"UND"	*(char)
;	O
case	O
SHN_ABS	O
:	O
return	O
"ABS"	*(char)
;	O
case	O
SHN_COMMON	O
:	O
return	O
"COM"	*(char)
;	O
default	O
:	O
if	O
(	O
type	enum(int,int,int,int)
==	O
SHN_IA_64_ANSI_COMMON	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_IA_64	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_HPUX	O
)	O
return	O
"ANSI_COM"	*(char)
;	O
else	O
if	O
(	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_X86_64	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_L1OM	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_K1OM	O
)	O
&&	O
type	enum(int,int,int,int)
==	O
SHN_X86_64_LCOMMON	O
)	O
return	O
"LARGE_COM"	*(char)
;	O
else	O
if	O
(	O
(	O
type	enum(int,int,int,int)
==	O
SHN_MIPS_SCOMMON	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_MIPS	O
)	O
||	O
(	O
type	enum(int,int,int,int)
==	O
SHN_TIC6X_SCOMMON	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_TI_C6000	O
)	O
)	O
return	O
"SCOM"	*(char)
;	O
else	O
if	O
(	O
type	enum(int,int,int,int)
==	O
SHN_MIPS_SUNDEFINED	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_MIPS	O
)	O
return	O
"SUND"	*(char)
;	O
else	O
if	O
(	O
type	enum(int,int,int,int)
>=	O
SHN_LOPROC	O
&&	O
type	enum(int,int,int,int)
<=	O
SHN_HIPROC	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
"PRC[0x%04x]"	*(char)
,	O
type	enum(int,int,int,int)
&	O
0xffff	int
)	O
;	O
else	O
if	O
(	O
type	enum(int,int,int,int)
>=	O
SHN_LOOS	O
&&	O
type	enum(int,int,int,int)
<=	O
SHN_HIOS	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
"OS [0x%04x]"	*(char)
,	O
type	enum(int,int,int,int)
&	O
0xffff	int
)	O
;	O
else	O
if	O
(	O
type	enum(int,int,int,int)
>=	O
SHN_LORESERVE	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
"RSV[0x%04x]"	*(char)
,	O
type	enum(int,int,int,int)
&	O
0xffff	int
)	O
;	O
else	O
if	O
(	O
type	enum(int,int,int,int)
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
_	O
(	O
"bad section index[%3d]"	*(char)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
buff	O
,	O
"%3d"	*(char)
,	O
type	enum(int,int,int,int)
)	O
;	O
break	O
;	O
}	O
return	O
buff	O
;	O
}	O
static	O
bfd_vma	long
*	O
get_dynamic_data	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_size_type	long
number	O
,	O
unsigned	O
int	O
ent_size	O
)	O
{	O
unsigned	O
char	O
*	O
e_data	O
;	O
bfd_vma	long
*	O
i_data	O
;	O
if	O
(	O
sizeof	O
(	O
size_t	long
)	O
<	O
sizeof	O
(	O
bfd_size_type	long
)	O
&&	O
(	O
bfd_size_type	long
)	O
(	O
(	O
size_t	long
)	O
number	O
)	O
!=	O
number	O
)	O
{	O
error	O
(	O
_	O
(	O
"Size truncation prevents reading %s elements of size %u\n"	*(char)
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
number	O
)	O
,	O
ent_size	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
ent_size	O
*	O
number	O
>	O
filedata	O
->	O
file_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Invalid number of dynamic entries: %s\n"	*(char)
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
number	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
e_data	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
cmalloc	O
(	O
(	O
size_t	long
)	O
number	O
,	O
ent_size	O
)	O
;	O
if	O
(	O
e_data	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory reading %s dynamic entries\n"	*(char)
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
number	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
e_data	O
,	O
ent_size	O
,	O
(	O
size_t	long
)	O
number	O
,	O
filedata	O
->	O
handle	O
)	O
!=	O
number	O
)	O
{	O
error	O
(	O
_	O
(	O
"Unable to read in %s bytes of dynamic data\n"	*(char)
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
number	O
*	O
ent_size	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
e_data	O
)	O
;	O
return	O
NULL	O
;	O
}	O
i_data	O
=	O
(	O
bfd_vma	long
*	O
)	O
cmalloc	O
(	O
(	O
size_t	long
)	O
number	O
,	O
sizeof	O
(	O
*	O
i_data	O
)	O
)	O
;	O
if	O
(	O
i_data	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory allocating space for %s dynamic entries\n"	*(char)
)	O
,	O
bfd_vmatoa	O
(	O
"u"	*(char)
,	O
number	O
)	O
)	O
;	O
free	(*(void))->(void)
(	O
e_data	O
)	O
;	O
return	O
NULL	O
;	O
}	O
while	O
(	O
number	O
--	O
)	O
i_data	O
[	O
number	O
]	O
=	O
byte_get	O
(	O
e_data	O
+	O
number	O
*	O
ent_size	O
,	O
ent_size	O
)	O
;	O
free	(*(void))->(void)
(	O
e_data	O
)	O
;	O
return	O
i_data	O
;	O
}	O
static	O
void	O
print_dynamic_symbol	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_vma	long
si	O
,	O
unsigned	O
long	O
hn	O
)	O
{	O
Elf_Internal_Sym	O
*	O
psym	O
;	O
int	O
n	O
;	O
n	O
=	O
print_vma	O
(	O
si	O
,	O
DEC_5	O
)	O
;	O
if	O
(	O
n	O
<	O
5	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
&	O
"     "	*(char)
[	O
n	O
]	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
printf	(*(char))->(int)
(	O
" %3lu: "	*(char)
,	O
hn	O
)	O
;	O
if	O
(	O
dynamic_symbols	O
==	O
NULL	O
||	O
si	O
>=	O
num_dynamic_syms	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<No info available for dynamic symbol number %lu>\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
si	O
)	O
;	O
return	O
;	O
}	O
psym	O
=	O
dynamic_symbols	O
+	O
si	O
;	O
print_vma	O
(	O
psym	O
->	O
st_value	O
,	O
LONG_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
psym	O
->	O
st_size	long
,	O
DEC_5	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %-7s"	*(char)
,	O
get_symbol_type	O
(	O
filedata	O
,	O
ELF_ST_TYPE	O
(	O
psym	O
->	O
st_info	O
)	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %-6s"	*(char)
,	O
get_symbol_binding	O
(	O
filedata	O
,	O
ELF_ST_BIND	O
(	O
psym	O
->	O
st_info	O
)	O
)	O
)	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_SOLARIS	O
)	O
printf	(*(char))->(int)
(	O
" %-7s"	*(char)
,	O
get_solaris_symbol_visibility	O
(	O
psym	O
->	O
st_other	O
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
vis	O
=	O
ELF_ST_VISIBILITY	O
(	O
psym	O
->	O
st_other	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %-7s"	*(char)
,	O
get_symbol_visibility	O
(	O
vis	O
)	O
)	O
;	O
if	O
(	O
psym	O
->	O
st_other	O
^	O
vis	O
)	O
printf	(*(char))->(int)
(	O
" [%s] "	*(char)
,	O
get_symbol_other	O
(	O
filedata	O
,	O
psym	O
->	O
st_other	O
^	O
vis	O
)	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
" %3.3s "	*(char)
,	O
get_symbol_index_type	O
(	O
filedata	O
,	O
psym	O
->	O
st_shndx	O
)	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
psym	O
->	O
st_name	O
)	O
)	O
print_symbol	O
(	O
25	int
,	O
GET_DYNAMIC_NAME	O
(	O
psym	O
->	O
st_name	O
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
" <corrupt: %14ld>"	*(char)
)	O
,	O
psym	O
->	O
st_name	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
get_symbol_version_string	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_boolean	int
is_dynsym	O
,	O
const	O
char	O
*	O
strtab	O
,	O
unsigned	O
long	O
int	O
strtab_size	O
,	O
unsigned	O
int	O
si	O
,	O
Elf_Internal_Sym	O
*	O
psym	O
,	O
enum	O
versioned_symbol_info	O
*	O
sym_info	O
,	O
unsigned	O
short	O
*	O
vna_other	O
)	O
{	O
unsigned	O
char	O
data	*(void)
[	O
2	int
]	O
;	O
unsigned	O
short	O
vers_data	O
;	O
unsigned	O
long	O
offset	long
;	O
unsigned	O
short	O
max_vd_ndx	O
;	O
if	O
(	O
!	O
is_dynsym	O
||	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERSYM	O
)	O
]	O
==	O
0	int
)	O
return	O
NULL	O
;	O
offset	long
=	O
offset_from_vma	O
(	O
filedata	O
,	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERSYM	O
)	O
]	O
,	O
sizeof	O
data	*(void)
+	O
si	O
*	O
sizeof	O
(	O
vers_data	O
)	O
)	O
;	O
if	O
(	O
get_data	O
(	O
&	O
data	*(void)
,	O
filedata	O
,	O
offset	long
+	O
si	O
*	O
sizeof	O
(	O
vers_data	O
)	O
,	O
sizeof	O
(	O
data	*(void)
)	O
,	O
1	int
,	O
_	O
(	O
"version data"	*(char)
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
vers_data	O
=	O
byte_get	O
(	O
data	*(void)
,	O
2	int
)	O
;	O
if	O
(	O
(	O
vers_data	O
&	O
VERSYM_HIDDEN	O
)	O
==	O
0	int
&&	O
vers_data	O
==	O
0	int
)	O
return	O
NULL	O
;	O
*	O
sym_info	O
=	O
(	O
vers_data	O
&	O
VERSYM_HIDDEN	O
)	O
!=	O
0	int
?	O
symbol_hidden	O
:	O
symbol_public	O
;	O
max_vd_ndx	O
=	O
0	int
;	O
if	O
(	O
psym	O
->	O
st_shndx	O
!=	O
SHN_UNDEF	O
&&	O
vers_data	O
!=	O
0x8001	int
&&	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERDEF	O
)	O
]	O
)	O
{	O
Elf_Internal_Verdef	O
ivd	O
;	O
Elf_Internal_Verdaux	O
ivda	O
;	O
Elf_External_Verdaux	O
evda	O
;	O
unsigned	O
long	O
off	O
;	O
off	O
=	O
offset_from_vma	O
(	O
filedata	O
,	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERDEF	O
)	O
]	O
,	O
sizeof	O
(	O
Elf_External_Verdef	O
)	O
)	O
;	O
do	O
{	O
Elf_External_Verdef	O
evd	O
;	O
if	O
(	O
get_data	O
(	O
&	O
evd	O
,	O
filedata	O
,	O
off	O
,	O
sizeof	O
(	O
evd	O
)	O
,	O
1	int
,	O
_	O
(	O
"version def"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
ivd	O
.	O
vd_ndx	O
=	O
0	int
;	O
ivd	O
.	O
vd_aux	O
=	O
0	int
;	O
ivd	O
.	O
vd_next	O
=	O
0	int
;	O
ivd	O
.	O
vd_flags	O
=	O
0	int
;	O
}	O
else	O
{	O
ivd	O
.	O
vd_ndx	O
=	O
BYTE_GET	O
(	O
evd	O
.	O
vd_ndx	O
)	O
;	O
ivd	O
.	O
vd_aux	O
=	O
BYTE_GET	O
(	O
evd	O
.	O
vd_aux	O
)	O
;	O
ivd	O
.	O
vd_next	O
=	O
BYTE_GET	O
(	O
evd	O
.	O
vd_next	O
)	O
;	O
ivd	O
.	O
vd_flags	O
=	O
BYTE_GET	O
(	O
evd	O
.	O
vd_flags	O
)	O
;	O
}	O
if	O
(	O
(	O
ivd	O
.	O
vd_ndx	O
&	O
VERSYM_VERSION	O
)	O
>	O
max_vd_ndx	O
)	O
max_vd_ndx	O
=	O
ivd	O
.	O
vd_ndx	O
&	O
VERSYM_VERSION	O
;	O
off	O
+=	O
ivd	O
.	O
vd_next	O
;	O
}	O
while	O
(	O
ivd	O
.	O
vd_ndx	O
!=	O
(	O
vers_data	O
&	O
VERSYM_VERSION	O
)	O
&&	O
ivd	O
.	O
vd_next	O
!=	O
0	int
)	O
;	O
if	O
(	O
ivd	O
.	O
vd_ndx	O
==	O
(	O
vers_data	O
&	O
VERSYM_VERSION	O
)	O
)	O
{	O
if	O
(	O
ivd	O
.	O
vd_ndx	O
==	O
1	int
&&	O
ivd	O
.	O
vd_flags	O
==	O
VER_FLG_BASE	O
)	O
return	O
NULL	O
;	O
off	O
-=	O
ivd	O
.	O
vd_next	O
;	O
off	O
+=	O
ivd	O
.	O
vd_aux	O
;	O
if	O
(	O
get_data	O
(	O
&	O
evda	O
,	O
filedata	O
,	O
off	O
,	O
sizeof	O
(	O
evda	O
)	O
,	O
1	int
,	O
_	O
(	O
"version def aux"	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
ivda	O
.	O
vda_name	O
=	O
BYTE_GET	O
(	O
evda	O
.	O
vda_name	O
)	O
;	O
if	O
(	O
psym	O
->	O
st_name	O
!=	O
ivda	O
.	O
vda_name	O
)	O
return	O
(	O
ivda	O
.	O
vda_name	O
<	O
strtab_size	O
?	O
strtab	O
+	O
ivda	O
.	O
vda_name	O
:	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERNEED	O
)	O
]	O
)	O
{	O
Elf_External_Verneed	O
evn	O
;	O
Elf_Internal_Verneed	O
ivn	O
;	O
Elf_Internal_Vernaux	O
ivna	O
;	O
offset	long
=	O
offset_from_vma	O
(	O
filedata	O
,	O
version_info	O
[	O
DT_VERSIONTAGIDX	O
(	O
DT_VERNEED	O
)	O
]	O
,	O
sizeof	O
evn	O
)	O
;	O
do	O
{	O
unsigned	O
long	O
vna_off	O
;	O
if	O
(	O
get_data	O
(	O
&	O
evn	O
,	O
filedata	O
,	O
offset	long
,	O
sizeof	O
(	O
evn	O
)	O
,	O
1	int
,	O
_	O
(	O
"version need"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
ivna	O
.	O
vna_next	O
=	O
0	int
;	O
ivna	O
.	O
vna_other	O
=	O
0	int
;	O
ivna	O
.	O
vna_name	O
=	O
0	int
;	O
break	O
;	O
}	O
ivn	O
.	O
vn_aux	O
=	O
BYTE_GET	O
(	O
evn	O
.	O
vn_aux	O
)	O
;	O
ivn	O
.	O
vn_next	O
=	O
BYTE_GET	O
(	O
evn	O
.	O
vn_next	O
)	O
;	O
vna_off	O
=	O
offset	long
+	O
ivn	O
.	O
vn_aux	O
;	O
do	O
{	O
Elf_External_Vernaux	O
evna	O
;	O
if	O
(	O
get_data	O
(	O
&	O
evna	O
,	O
filedata	O
,	O
vna_off	O
,	O
sizeof	O
(	O
evna	O
)	O
,	O
1	int
,	O
_	O
(	O
"version need aux (3)"	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
ivna	O
.	O
vna_next	O
=	O
0	int
;	O
ivna	O
.	O
vna_other	O
=	O
0	int
;	O
ivna	O
.	O
vna_name	O
=	O
0	int
;	O
}	O
else	O
{	O
ivna	O
.	O
vna_other	O
=	O
BYTE_GET	O
(	O
evna	O
.	O
vna_other	O
)	O
;	O
ivna	O
.	O
vna_next	O
=	O
BYTE_GET	O
(	O
evna	O
.	O
vna_next	O
)	O
;	O
ivna	O
.	O
vna_name	O
=	O
BYTE_GET	O
(	O
evna	O
.	O
vna_name	O
)	O
;	O
}	O
vna_off	O
+=	O
ivna	O
.	O
vna_next	O
;	O
}	O
while	O
(	O
ivna	O
.	O
vna_other	O
!=	O
vers_data	O
&&	O
ivna	O
.	O
vna_next	O
!=	O
0	int
)	O
;	O
if	O
(	O
ivna	O
.	O
vna_other	O
==	O
vers_data	O
)	O
break	O
;	O
offset	long
+=	O
ivn	O
.	O
vn_next	O
;	O
}	O
while	O
(	O
ivn	O
.	O
vn_next	O
!=	O
0	int
)	O
;	O
if	O
(	O
ivna	O
.	O
vna_other	O
==	O
vers_data	O
)	O
{	O
*	O
sym_info	O
=	O
symbol_undefined	O
;	O
*	O
vna_other	O
=	O
ivna	O
.	O
vna_other	O
;	O
return	O
(	O
ivna	O
.	O
vna_name	O
<	O
strtab_size	O
?	O
strtab	O
+	O
ivna	O
.	O
vna_name	O
:	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
max_vd_ndx	O
||	O
(	O
vers_data	O
&	O
VERSYM_VERSION	O
)	O
!=	O
1	int
)	O
&&	O
(	O
vers_data	O
&	O
VERSYM_VERSION	O
)	O
>	O
max_vd_ndx	O
)	O
return	O
_	O
(	O
"<corrupt>"	*(char)
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
bfd_boolean	int
process_symbol_table	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
bfd_size_type	long
nbuckets	O
=	O
0	int
;	O
bfd_size_type	long
nchains	O
=	O
0	int
;	O
bfd_vma	long
*	O
buckets	O
=	O
NULL	O
;	O
bfd_vma	long
*	O
chains	O
=	O
NULL	O
;	O
bfd_vma	long
ngnubuckets	O
=	O
0	int
;	O
bfd_vma	long
*	O
gnubuckets	O
=	O
NULL	O
;	O
bfd_vma	long
*	O
gnuchains	O
=	O
NULL	O
;	O
bfd_vma	long
*	O
mipsxlat	O
=	O
NULL	O
;	O
bfd_vma	long
gnusymidx	O
=	O
0	int
;	O
bfd_size_type	long
ngnuchains	O
=	O
0	int
;	O
if	O
(	O
!	O
do_syms	O
&&	O
!	O
do_dyn_syms	O
&&	O
!	O
do_histogram	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
dynamic_info	O
[	O
DT_HASH	O
]	O
&&	O
(	O
do_histogram	O
||	O
(	O
do_using_dynamic	O
&&	O
!	O
do_dyn_syms	O
&&	O
dynamic_strings	O
!=	O
NULL	O
)	O
)	O
)	O
{	O
unsigned	O
char	O
nb	O
[	O
8	int
]	O
;	O
unsigned	O
char	O
nc	O
[	O
8	int
]	O
;	O
unsigned	O
int	O
hash_ent_size	O
=	O
4	int
;	O
if	O
(	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_ALPHA	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_S390	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_S390_OLD	O
)	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_CLASS	O
]	O
==	O
ELFCLASS64	O
)	O
hash_ent_size	O
=	O
8	int
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
filedata	O
->	O
handle	O
,	O
(	O
archive_file_offset	O
+	O
offset_from_vma	O
(	O
filedata	O
,	O
dynamic_info	O
[	O
DT_HASH	O
]	O
,	O
sizeof	O
nb	O
+	O
sizeof	O
nc	O
)	O
)	O
,	O
SEEK_SET	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	*(char)
)	O
)	O
;	O
goto	O
no_hash	O
;	O
}	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
nb	O
,	O
hash_ent_size	O
,	O
1	int
,	O
filedata	O
->	O
handle	O
)	O
!=	O
1	int
)	O
{	O
error	O
(	O
_	O
(	O
"Failed to read in number of buckets\n"	*(char)
)	O
)	O
;	O
goto	O
no_hash	O
;	O
}	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
nc	O
,	O
hash_ent_size	O
,	O
1	int
,	O
filedata	O
->	O
handle	O
)	O
!=	O
1	int
)	O
{	O
error	O
(	O
_	O
(	O
"Failed to read in number of chains\n"	*(char)
)	O
)	O
;	O
goto	O
no_hash	O
;	O
}	O
nbuckets	O
=	O
byte_get	O
(	O
nb	O
,	O
hash_ent_size	O
)	O
;	O
nchains	O
=	O
byte_get	O
(	O
nc	O
,	O
hash_ent_size	O
)	O
;	O
buckets	O
=	O
get_dynamic_data	O
(	O
filedata	O
,	O
nbuckets	O
,	O
hash_ent_size	O
)	O
;	O
chains	O
=	O
get_dynamic_data	O
(	O
filedata	O
,	O
nchains	O
,	O
hash_ent_size	O
)	O
;	O
no_hash	O
:	O
if	O
(	O
buckets	O
==	O
NULL	O
||	O
chains	O
==	O
NULL	O
)	O
{	O
if	O
(	O
do_using_dynamic	O
)	O
return	O
FALSE	O
;	O
free	(*(void))->(void)
(	O
buckets	O
)	O
;	O
free	(*(void))->(void)
(	O
chains	O
)	O
;	O
buckets	O
=	O
NULL	O
;	O
chains	O
=	O
NULL	O
;	O
nbuckets	O
=	O
0	int
;	O
nchains	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
dynamic_info_DT_GNU_HASH	O
&&	O
(	O
do_histogram	O
||	O
(	O
do_using_dynamic	O
&&	O
!	O
do_dyn_syms	O
&&	O
dynamic_strings	O
!=	O
NULL	O
)	O
)	O
)	O
{	O
unsigned	O
char	O
nb	O
[	O
16	int
]	O
;	O
bfd_vma	long
i	*(struct)
,	O
maxchain	O
=	O
0xffffffff	int
,	O
bitmaskwords	O
;	O
bfd_vma	long
buckets_vma	O
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
filedata	O
->	O
handle	O
,	O
(	O
archive_file_offset	O
+	O
offset_from_vma	O
(	O
filedata	O
,	O
dynamic_info_DT_GNU_HASH	O
,	O
sizeof	O
nb	O
)	O
)	O
,	O
SEEK_SET	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	*(char)
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
nb	O
,	O
16	int
,	O
1	int
,	O
filedata	O
->	O
handle	O
)	O
!=	O
1	int
)	O
{	O
error	O
(	O
_	O
(	O
"Failed to read in number of buckets\n"	*(char)
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
ngnubuckets	O
=	O
byte_get	O
(	O
nb	O
,	O
4	int
)	O
;	O
gnusymidx	O
=	O
byte_get	O
(	O
nb	O
+	O
4	int
,	O
4	int
)	O
;	O
bitmaskwords	O
=	O
byte_get	O
(	O
nb	O
+	O
8	int
,	O
4	int
)	O
;	O
buckets_vma	O
=	O
dynamic_info_DT_GNU_HASH	O
+	O
16	int
;	O
if	O
(	O
is_32bit_elf	O
)	O
buckets_vma	O
+=	O
bitmaskwords	O
*	O
4	int
;	O
else	O
buckets_vma	O
+=	O
bitmaskwords	O
*	O
8	int
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
filedata	O
->	O
handle	O
,	O
(	O
archive_file_offset	O
+	O
offset_from_vma	O
(	O
filedata	O
,	O
buckets_vma	O
,	O
4	int
)	O
)	O
,	O
SEEK_SET	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	*(char)
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
gnubuckets	O
=	O
get_dynamic_data	O
(	O
filedata	O
,	O
ngnubuckets	O
,	O
4	int
)	O
;	O
if	O
(	O
gnubuckets	O
==	O
NULL	O
)	O
goto	O
no_gnu_hash	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
ngnubuckets	O
;	O
i	*(struct)
++	O
)	O
if	O
(	O
gnubuckets	O
[	O
i	*(struct)
]	O
!=	O
0	int
)	O
{	O
if	O
(	O
gnubuckets	O
[	O
i	*(struct)
]	O
<	O
gnusymidx	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
maxchain	O
==	O
0xffffffff	int
||	O
gnubuckets	O
[	O
i	*(struct)
]	O
>	O
maxchain	O
)	O
maxchain	O
=	O
gnubuckets	O
[	O
i	*(struct)
]	O
;	O
}	O
if	O
(	O
maxchain	O
==	O
0xffffffff	int
)	O
goto	O
no_gnu_hash	O
;	O
maxchain	O
-=	O
gnusymidx	O
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
filedata	O
->	O
handle	O
,	O
(	O
archive_file_offset	O
+	O
offset_from_vma	O
(	O
filedata	O
,	O
buckets_vma	O
+	O
4	int
*	O
(	O
ngnubuckets	O
+	O
maxchain	O
)	O
,	O
4	int
)	O
)	O
,	O
SEEK_SET	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	*(char)
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
do	O
{	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
nb	O
,	O
4	int
,	O
1	int
,	O
filedata	O
->	O
handle	O
)	O
!=	O
1	int
)	O
{	O
error	O
(	O
_	O
(	O
"Failed to determine last chain length\n"	*(char)
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
if	O
(	O
maxchain	O
+	O
1	int
==	O
0	int
)	O
goto	O
no_gnu_hash	O
;	O
++	O
maxchain	O
;	O
}	O
while	O
(	O
(	O
byte_get	O
(	O
nb	O
,	O
4	int
)	O
&	O
1	int
)	O
==	O
0	int
)	O
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
filedata	O
->	O
handle	O
,	O
(	O
archive_file_offset	O
+	O
offset_from_vma	O
(	O
filedata	O
,	O
buckets_vma	O
+	O
4	int
*	O
ngnubuckets	O
,	O
4	int
)	O
)	O
,	O
SEEK_SET	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	*(char)
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
gnuchains	O
=	O
get_dynamic_data	O
(	O
filedata	O
,	O
maxchain	O
,	O
4	int
)	O
;	O
ngnuchains	O
=	O
maxchain	O
;	O
if	O
(	O
gnuchains	O
==	O
NULL	O
)	O
goto	O
no_gnu_hash	O
;	O
if	O
(	O
dynamic_info_DT_MIPS_XHASH	O
)	O
{	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
filedata	O
->	O
handle	O
,	O
(	O
archive_file_offset	O
+	O
offset_from_vma	O
(	O
filedata	O
,	O
(	O
buckets_vma	O
+	O
4	int
*	O
(	O
ngnubuckets	O
+	O
maxchain	O
)	O
)	O
,	O
4	int
)	O
)	O
,	O
SEEK_SET	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"Unable to seek to start of dynamic information\n"	*(char)
)	O
)	O
;	O
goto	O
no_gnu_hash	O
;	O
}	O
mipsxlat	O
=	O
get_dynamic_data	O
(	O
filedata	O
,	O
maxchain	O
,	O
4	int
)	O
;	O
}	O
no_gnu_hash	O
:	O
if	O
(	O
dynamic_info_DT_MIPS_XHASH	O
&&	O
mipsxlat	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
gnuchains	O
)	O
;	O
gnuchains	O
=	O
NULL	O
;	O
}	O
if	O
(	O
gnuchains	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
gnubuckets	O
)	O
;	O
gnubuckets	O
=	O
NULL	O
;	O
ngnubuckets	O
=	O
0	int
;	O
if	O
(	O
do_using_dynamic	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
(	O
dynamic_info	O
[	O
DT_HASH	O
]	O
||	O
dynamic_info_DT_GNU_HASH	O
)	O
&&	O
do_syms	O
&&	O
do_using_dynamic	O
&&	O
dynamic_strings	O
!=	O
NULL	O
&&	O
dynamic_symbols	O
!=	O
NULL	O
)	O
{	O
unsigned	O
long	O
hn	O
;	O
if	O
(	O
dynamic_info	O
[	O
DT_HASH	O
]	O
)	O
{	O
bfd_vma	long
si	O
;	O
char	O
*	O
visited	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nSymbol table for image:\n"	*(char)
)	O
)	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"	*(char)
)	O
)	O
;	O
visited	O
=	O
xcmalloc	O
(	O
nchains	O
,	O
1	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
visited	O
,	O
0	int
,	O
nchains	O
)	O
;	O
for	O
(	O
hn	O
=	O
0	int
;	O
hn	O
<	O
nbuckets	O
;	O
hn	O
++	O
)	O
{	O
for	O
(	O
si	O
=	O
buckets	O
[	O
hn	O
]	O
;	O
si	O
>	O
0	int
;	O
si	O
=	O
chains	O
[	O
si	O
]	O
)	O
{	O
print_dynamic_symbol	O
(	O
filedata	O
,	O
si	O
,	O
hn	O
)	O
;	O
if	O
(	O
si	O
>=	O
nchains	O
||	O
visited	O
[	O
si	O
]	O
)	O
{	O
error	O
(	O
_	O
(	O
"histogram chain is corrupt\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
visited	O
[	O
si	O
]	O
=	O
1	int
;	O
}	O
}	O
free	(*(void))->(void)
(	O
visited	O
)	O
;	O
}	O
if	O
(	O
dynamic_info_DT_GNU_HASH	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nSymbol table of `%s' for image:\n"	*(char)
)	O
,	O
GNU_HASH_SECTION_NAME	O
)	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"	*(char)
)	O
)	O
;	O
for	O
(	O
hn	O
=	O
0	int
;	O
hn	O
<	O
ngnubuckets	O
;	O
++	O
hn	O
)	O
if	O
(	O
gnubuckets	O
[	O
hn	O
]	O
!=	O
0	int
)	O
{	O
bfd_vma	long
si	O
=	O
gnubuckets	O
[	O
hn	O
]	O
;	O
bfd_vma	long
off	O
=	O
si	O
-	O
gnusymidx	O
;	O
do	O
{	O
if	O
(	O
dynamic_info_DT_MIPS_XHASH	O
)	O
print_dynamic_symbol	O
(	O
filedata	O
,	O
mipsxlat	O
[	O
off	O
]	O
,	O
hn	O
)	O
;	O
else	O
print_dynamic_symbol	O
(	O
filedata	O
,	O
si	O
,	O
hn	O
)	O
;	O
si	O
++	O
;	O
}	O
while	O
(	O
off	O
<	O
ngnuchains	O
&&	O
(	O
gnuchains	O
[	O
off	O
++	O
]	O
&	O
1	int
)	O
==	O
0	int
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
do_dyn_syms	O
||	O
(	O
do_syms	O
&&	O
!	O
do_using_dynamic	O
)	O
)	O
&&	O
filedata	O
->	O
section_headers	O
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
)	O
{	O
unsigned	O
int	O
si	O
;	O
char	O
*	O
strtab	O
=	O
NULL	O
;	O
unsigned	O
long	O
int	O
strtab_size	O
=	O
0	int
;	O
Elf_Internal_Sym	O
*	O
symtab	O
;	O
Elf_Internal_Sym	O
*	O
psym	O
;	O
unsigned	O
long	O
num_syms	O
;	O
if	O
(	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
!=	O
SHT_SYMTAB	O
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
!=	O
SHT_DYNSYM	O
)	O
||	O
(	O
!	O
do_syms	O
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_SYMTAB	O
)	O
)	O
continue	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nSymbol table '%s' has a sh_entsize of zero!\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
continue	O
;	O
}	O
num_syms	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
/	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
;	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nSymbol table '%s' contains %lu entry:\n"	*(char)
,	O
"\nSymbol table '%s' contains %lu entries:\n"	*(char)
,	O
num_syms	O
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
num_syms	O
)	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"	*(char)
)	O
)	O
;	O
symtab	O
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
&	O
num_syms	O
)	O
;	O
if	O
(	O
symtab	O
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
==	O
filedata	O
->	O
file_header	O
.	O
e_shstrndx	O
)	O
{	O
strtab	O
=	O
filedata	O
->	O
string_table	O
;	O
strtab_size	O
=	O
filedata	O
->	O
string_table_length	O
;	O
}	O
else	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
string_sec	O
;	O
string_sec	O
=	O
filedata	O
->	O
section_headers	O
+	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
;	O
strtab	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
string_sec	O
->	O
sh_offset	O
,	O
1	int
,	O
string_sec	O
->	O
sh_size	O
,	O
_	O
(	O
"string table"	*(char)
)	O
)	O
;	O
strtab_size	O
=	O
strtab	O
!=	O
NULL	O
?	O
string_sec	O
->	O
sh_size	O
:	O
0	int
;	O
}	O
for	O
(	O
si	O
=	O
0	int
,	O
psym	O
=	O
symtab	O
;	O
si	O
<	O
num_syms	O
;	O
si	O
++	O
,	O
psym	O
++	O
)	O
{	O
const	O
char	O
*	O
version_string	O
;	O
enum	O
versioned_symbol_info	O
sym_info	O
;	O
unsigned	O
short	O
vna_other	O
;	O
printf	(*(char))->(int)
(	O
"%6d: "	*(char)
,	O
si	O
)	O
;	O
print_vma	O
(	O
psym	O
->	O
st_value	O
,	O
LONG_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
print_vma	O
(	O
psym	O
->	O
st_size	long
,	O
DEC_5	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %-7s"	*(char)
,	O
get_symbol_type	O
(	O
filedata	O
,	O
ELF_ST_TYPE	O
(	O
psym	O
->	O
st_info	O
)	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %-6s"	*(char)
,	O
get_symbol_binding	O
(	O
filedata	O
,	O
ELF_ST_BIND	O
(	O
psym	O
->	O
st_info	O
)	O
)	O
)	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
==	O
ELFOSABI_SOLARIS	O
)	O
printf	(*(char))->(int)
(	O
" %-7s"	*(char)
,	O
get_solaris_symbol_visibility	O
(	O
psym	O
->	O
st_other	O
)	O
)	O
;	O
else	O
{	O
unsigned	O
int	O
vis	O
=	O
ELF_ST_VISIBILITY	O
(	O
psym	O
->	O
st_other	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %-7s"	*(char)
,	O
get_symbol_visibility	O
(	O
vis	O
)	O
)	O
;	O
if	O
(	O
psym	O
->	O
st_other	O
^	O
vis	O
)	O
printf	(*(char))->(int)
(	O
" [%s] "	*(char)
,	O
get_symbol_other	O
(	O
filedata	O
,	O
psym	O
->	O
st_other	O
^	O
vis	O
)	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
" %4s "	*(char)
,	O
get_symbol_index_type	O
(	O
filedata	O
,	O
psym	O
->	O
st_shndx	O
)	O
)	O
;	O
print_symbol	O
(	O
25	int
,	O
psym	O
->	O
st_name	O
<	O
strtab_size	O
?	O
strtab	O
+	O
psym	O
->	O
st_name	O
:	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
version_string	O
=	O
get_symbol_version_string	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_DYNSYM	O
,	O
strtab	O
,	O
strtab_size	O
,	O
si	O
,	O
psym	O
,	O
&	O
sym_info	O
,	O
&	O
vna_other	O
)	O
;	O
if	O
(	O
version_string	O
)	O
{	O
if	O
(	O
sym_info	O
==	O
symbol_undefined	O
)	O
printf	(*(char))->(int)
(	O
"@%s (%d)"	*(char)
,	O
version_string	O
,	O
vna_other	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
sym_info	O
==	O
symbol_hidden	O
?	O
"@%s"	*(char)
:	O
"@@%s"	*(char)
,	O
version_string	O
)	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
if	O
(	O
ELF_ST_BIND	O
(	O
psym	O
->	O
st_info	O
)	O
==	O
STB_LOCAL	O
&&	O
si	O
>=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
!=	O
EM_MIPS	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_OSABI	O
]	O
!=	O
ELFOSABI_SOLARIS	O
)	O
warn	O
(	O
_	O
(	O
"local symbol %u found at index >= %s's sh_info value of %u\n"	*(char)
)	O
,	O
si	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_info	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
symtab	O
)	O
;	O
if	O
(	O
strtab	O
!=	O
filedata	O
->	O
string_table	O
)	O
free	(*(void))->(void)
(	O
strtab	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
do_syms	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nDynamic symbol information is not available for displaying symbols.\n"	*(char)
)	O
)	O
;	O
if	O
(	O
do_histogram	O
&&	O
buckets	O
!=	O
NULL	O
)	O
{	O
unsigned	O
long	O
*	O
lengths	O
;	O
unsigned	O
long	O
*	O
counts	O
;	O
unsigned	O
long	O
hn	O
;	O
bfd_vma	long
si	O
;	O
unsigned	O
long	O
maxlength	O
=	O
0	int
;	O
unsigned	O
long	O
nzero_counts	O
=	O
0	int
;	O
unsigned	O
long	O
nsyms	O
=	O
0	int
;	O
char	O
*	O
visited	O
;	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nHistogram for bucket list length "	*(char)
"(total of %lu bucket):\n"	*(char)
,	O
"\nHistogram for bucket list length "	*(char)
"(total of %lu buckets):\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
nbuckets	O
)	O
,	O
(	O
unsigned	O
long	O
)	O
nbuckets	O
)	O
;	O
lengths	O
=	O
(	O
unsigned	O
long	O
*	O
)	O
calloc	(long,long)->(*(void))
(	O
nbuckets	O
,	O
sizeof	O
(	O
*	O
lengths	O
)	O
)	O
;	O
if	O
(	O
lengths	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory allocating space for histogram buckets\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
visited	O
=	O
xcmalloc	O
(	O
nchains	O
,	O
1	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
visited	O
,	O
0	int
,	O
nchains	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Length  Number     %% of total  Coverage\n"	*(char)
)	O
)	O
;	O
for	O
(	O
hn	O
=	O
0	int
;	O
hn	O
<	O
nbuckets	O
;	O
++	O
hn	O
)	O
{	O
for	O
(	O
si	O
=	O
buckets	O
[	O
hn	O
]	O
;	O
si	O
>	O
0	int
;	O
si	O
=	O
chains	O
[	O
si	O
]	O
)	O
{	O
++	O
nsyms	O
;	O
if	O
(	O
maxlength	O
<	O
++	O
lengths	O
[	O
hn	O
]	O
)	O
++	O
maxlength	O
;	O
if	O
(	O
si	O
>=	O
nchains	O
||	O
visited	O
[	O
si	O
]	O
)	O
{	O
error	O
(	O
_	O
(	O
"histogram chain is corrupt\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
visited	O
[	O
si	O
]	O
=	O
1	int
;	O
}	O
}	O
free	(*(void))->(void)
(	O
visited	O
)	O
;	O
counts	O
=	O
(	O
unsigned	O
long	O
*	O
)	O
calloc	(long,long)->(*(void))
(	O
maxlength	O
+	O
1	int
,	O
sizeof	O
(	O
*	O
counts	O
)	O
)	O
;	O
if	O
(	O
counts	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
lengths	O
)	O
;	O
error	O
(	O
_	O
(	O
"Out of memory allocating space for histogram counts\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
hn	O
=	O
0	int
;	O
hn	O
<	O
nbuckets	O
;	O
++	O
hn	O
)	O
++	O
counts	O
[	O
lengths	O
[	O
hn	O
]	O
]	O
;	O
if	O
(	O
nbuckets	O
>	O
0	int
)	O
{	O
unsigned	O
long	O
i	*(struct)
;	O
printf	(*(char))->(int)
(	O
"      0  %-10lu (%5.1f%%)\n"	*(char)
,	O
counts	O
[	O
0	int
]	O
,	O
(	O
counts	O
[	O
0	int
]	O
*	O
100.0	int
)	O
/	O
nbuckets	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
1	int
;	O
i	*(struct)
<=	O
maxlength	O
;	O
++	O
i	*(struct)
)	O
{	O
nzero_counts	O
+=	O
counts	O
[	O
i	*(struct)
]	O
*	O
i	*(struct)
;	O
printf	(*(char))->(int)
(	O
"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n"	*(char)
,	O
i	*(struct)
,	O
counts	O
[	O
i	*(struct)
]	O
,	O
(	O
counts	O
[	O
i	*(struct)
]	O
*	O
100.0	int
)	O
/	O
nbuckets	O
,	O
(	O
nzero_counts	O
*	O
100.0	int
)	O
/	O
nsyms	O
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
counts	O
)	O
;	O
free	(*(void))->(void)
(	O
lengths	O
)	O
;	O
}	O
if	O
(	O
buckets	O
!=	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
buckets	O
)	O
;	O
free	(*(void))->(void)
(	O
chains	O
)	O
;	O
}	O
if	O
(	O
do_histogram	O
&&	O
gnubuckets	O
!=	O
NULL	O
)	O
{	O
unsigned	O
long	O
*	O
lengths	O
;	O
unsigned	O
long	O
*	O
counts	O
;	O
unsigned	O
long	O
hn	O
;	O
unsigned	O
long	O
maxlength	O
=	O
0	int
;	O
unsigned	O
long	O
nzero_counts	O
=	O
0	int
;	O
unsigned	O
long	O
nsyms	O
=	O
0	int
;	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nHistogram for `%s' bucket list length "	*(char)
"(total of %lu bucket):\n"	*(char)
,	O
"\nHistogram for `%s' bucket list length "	*(char)
"(total of %lu buckets):\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
ngnubuckets	O
)	O
,	O
GNU_HASH_SECTION_NAME	O
,	O
(	O
unsigned	O
long	O
)	O
ngnubuckets	O
)	O
;	O
lengths	O
=	O
(	O
unsigned	O
long	O
*	O
)	O
calloc	(long,long)->(*(void))
(	O
ngnubuckets	O
,	O
sizeof	O
(	O
*	O
lengths	O
)	O
)	O
;	O
if	O
(	O
lengths	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory allocating space for gnu histogram buckets\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Length  Number     %% of total  Coverage\n"	*(char)
)	O
)	O
;	O
for	O
(	O
hn	O
=	O
0	int
;	O
hn	O
<	O
ngnubuckets	O
;	O
++	O
hn	O
)	O
if	O
(	O
gnubuckets	O
[	O
hn	O
]	O
!=	O
0	int
)	O
{	O
bfd_vma	long
off	O
,	O
length	O
=	O
1	int
;	O
for	O
(	O
off	O
=	O
gnubuckets	O
[	O
hn	O
]	O
-	O
gnusymidx	O
;	O
off	O
<	O
ngnuchains	O
&&	O
(	O
gnuchains	O
[	O
off	O
]	O
&	O
1	int
)	O
==	O
0	int
;	O
++	O
off	O
)	O
++	O
length	O
;	O
lengths	O
[	O
hn	O
]	O
=	O
length	O
;	O
if	O
(	O
length	O
>	O
maxlength	O
)	O
maxlength	O
=	O
length	O
;	O
nsyms	O
+=	O
length	O
;	O
}	O
counts	O
=	O
(	O
unsigned	O
long	O
*	O
)	O
calloc	(long,long)->(*(void))
(	O
maxlength	O
+	O
1	int
,	O
sizeof	O
(	O
*	O
counts	O
)	O
)	O
;	O
if	O
(	O
counts	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
lengths	O
)	O
;	O
error	O
(	O
_	O
(	O
"Out of memory allocating space for gnu histogram counts\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
hn	O
=	O
0	int
;	O
hn	O
<	O
ngnubuckets	O
;	O
++	O
hn	O
)	O
++	O
counts	O
[	O
lengths	O
[	O
hn	O
]	O
]	O
;	O
if	O
(	O
ngnubuckets	O
>	O
0	int
)	O
{	O
unsigned	O
long	O
j	O
;	O
printf	(*(char))->(int)
(	O
"      0  %-10lu (%5.1f%%)\n"	*(char)
,	O
counts	O
[	O
0	int
]	O
,	O
(	O
counts	O
[	O
0	int
]	O
*	O
100.0	int
)	O
/	O
ngnubuckets	O
)	O
;	O
for	O
(	O
j	O
=	O
1	int
;	O
j	O
<=	O
maxlength	O
;	O
++	O
j	O
)	O
{	O
nzero_counts	O
+=	O
counts	O
[	O
j	O
]	O
*	O
j	O
;	O
printf	(*(char))->(int)
(	O
"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n"	*(char)
,	O
j	O
,	O
counts	O
[	O
j	O
]	O
,	O
(	O
counts	O
[	O
j	O
]	O
*	O
100.0	int
)	O
/	O
ngnubuckets	O
,	O
(	O
nzero_counts	O
*	O
100.0	int
)	O
/	O
nsyms	O
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
counts	O
)	O
;	O
free	(*(void))->(void)
(	O
lengths	O
)	O
;	O
free	(*(void))->(void)
(	O
gnubuckets	O
)	O
;	O
free	(*(void))->(void)
(	O
gnuchains	O
)	O
;	O
free	(*(void))->(void)
(	O
mipsxlat	O
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
process_syminfo	O
(	O
Filedata	O
*	O
filedata	O
ATTRIBUTE_UNUSED	O
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
if	O
(	O
dynamic_syminfo	O
==	O
NULL	O
||	O
!	O
do_dynamic	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
dynamic_symbols	O
==	O
NULL	O
||	O
dynamic_strings	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
dynamic_addr	O
)	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nDynamic info segment at offset 0x%lx "	*(char)
"contains %d entry:\n"	*(char)
,	O
"\nDynamic info segment at offset 0x%lx "	*(char)
"contains %d entries:\n"	*(char)
,	O
dynamic_syminfo_nent	O
)	O
,	O
dynamic_syminfo_offset	O
,	O
dynamic_syminfo_nent	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Num: Name                           BoundTo     Flags\n"	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
dynamic_syminfo_nent	O
;	O
++	O
i	*(struct)
)	O
{	O
unsigned	O
short	O
int	O
flags	int
=	O
dynamic_syminfo	O
[	O
i	*(struct)
]	O
.	O
si_flags	O
;	O
printf	(*(char))->(int)
(	O
"%4d: "	*(char)
,	O
i	*(struct)
)	O
;	O
if	O
(	O
i	*(struct)
>=	O
num_dynamic_syms	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt index>"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
dynamic_symbols	O
[	O
i	*(struct)
]	O
.	O
st_name	O
)	O
)	O
print_symbol	O
(	O
30	int
,	O
GET_DYNAMIC_NAME	O
(	O
dynamic_symbols	O
[	O
i	*(struct)
]	O
.	O
st_name	O
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt: %19ld>"	*(char)
)	O
,	O
dynamic_symbols	O
[	O
i	*(struct)
]	O
.	O
st_name	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
switch	O
(	O
dynamic_syminfo	O
[	O
i	*(struct)
]	O
.	O
si_boundto	O
)	O
{	O
case	O
SYMINFO_BT_SELF	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"SELF       "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
SYMINFO_BT_PARENT	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"PARENT     "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
dynamic_syminfo	O
[	O
i	*(struct)
]	O
.	O
si_boundto	O
>	O
0	int
&&	O
dynamic_syminfo	O
[	O
i	*(struct)
]	O
.	O
si_boundto	O
<	O
dynamic_nent	O
&&	O
VALID_DYNAMIC_NAME	O
(	O
dynamic_section	O
[	O
dynamic_syminfo	O
[	O
i	*(struct)
]	O
.	O
si_boundto	O
]	O
.	O
d_un	O
.	O
d_val	O
)	O
)	O
{	O
print_symbol	O
(	O
10	int
,	O
GET_DYNAMIC_NAME	O
(	O
dynamic_section	O
[	O
dynamic_syminfo	O
[	O
i	*(struct)
]	O
.	O
si_boundto	O
]	O
.	O
d_un	O
.	O
d_val	O
)	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"%-10d "	*(char)
,	O
dynamic_syminfo	O
[	O
i	*(struct)
]	O
.	O
si_boundto	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
flags	int
&	O
SYMINFO_FLG_DIRECT	O
)	O
printf	(*(char))->(int)
(	O
" DIRECT"	*(char)
)	O
;	O
if	O
(	O
flags	int
&	O
SYMINFO_FLG_PASSTHRU	O
)	O
printf	(*(char))->(int)
(	O
" PASSTHRU"	*(char)
)	O
;	O
if	O
(	O
flags	int
&	O
SYMINFO_FLG_COPY	O
)	O
printf	(*(char))->(int)
(	O
" COPY"	*(char)
)	O
;	O
if	O
(	O
flags	int
&	O
SYMINFO_FLG_LAZYLOAD	O
)	O
printf	(*(char))->(int)
(	O
" LAZYLOAD"	*(char)
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
target_specific_reloc_handling	O
(	O
Filedata	O
*	O
filedata	O
,	O
Elf_Internal_Rela	O
*	O
reloc	O
,	O
unsigned	O
char	O
*	O
start	O
,	O
unsigned	O
char	O
*	O
end	*(*(char))
,	O
Elf_Internal_Sym	O
*	O
symtab	O
,	O
unsigned	O
long	O
num_syms	O
)	O
{	O
unsigned	O
int	O
reloc_type	O
=	O
0	int
;	O
unsigned	O
long	O
sym_index	O
=	O
0	int
;	O
if	O
(	O
reloc	O
)	O
{	O
reloc_type	O
=	O
get_reloc_type	O
(	O
filedata	O
,	O
reloc	O
->	O
r_info	O
)	O
;	O
sym_index	O
=	O
get_reloc_symindex	O
(	O
reloc	O
->	O
r_info	O
)	O
;	O
}	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_MSP430	O
:	O
case	O
EM_MSP430_OLD	O
:	O
{	O
static	O
Elf_Internal_Sym	O
*	O
saved_sym	O
=	O
NULL	O
;	O
if	O
(	O
reloc	O
==	O
NULL	O
)	O
{	O
saved_sym	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
switch	O
(	O
reloc_type	O
)	O
{	O
case	O
10	int
:	O
if	O
(	O
uses_msp430x_relocs	O
(	O
filedata	O
)	O
)	O
break	O
;	O
case	O
21	int
:	O
if	O
(	O
sym_index	O
>=	O
num_syms	O
)	O
error	O
(	O
_	O
(	O
"MSP430 SYM_DIFF reloc contains invalid symbol index %lu\n"	*(char)
)	O
,	O
sym_index	O
)	O
;	O
else	O
saved_sym	O
=	O
symtab	O
+	O
sym_index	O
;	O
return	O
TRUE	int
;	O
case	O
1	int
:	O
case	O
3	int
:	O
goto	O
handle_sym_diff	O
;	O
case	O
5	int
:	O
case	O
9	int
:	O
if	O
(	O
uses_msp430x_relocs	O
(	O
filedata	O
)	O
)	O
break	O
;	O
goto	O
handle_sym_diff	O
;	O
case	O
2	int
:	O
case	O
15	int
:	O
if	O
(	O
!	O
uses_msp430x_relocs	O
(	O
filedata	O
)	O
)	O
break	O
;	O
goto	O
handle_sym_diff	O
;	O
handle_sym_diff	O
:	O
if	O
(	O
saved_sym	O
!=	O
NULL	O
)	O
{	O
int	O
reloc_size	O
=	O
reloc_type	O
==	O
1	int
?	O
4	int
:	O
2	int
;	O
bfd_vma	long
value	int
;	O
if	O
(	O
sym_index	O
>=	O
num_syms	O
)	O
error	O
(	O
_	O
(	O
"MSP430 reloc contains invalid symbol index %lu\n"	*(char)
)	O
,	O
sym_index	O
)	O
;	O
else	O
{	O
value	int
=	O
reloc	O
->	O
r_addend	O
+	O
(	O
symtab	O
[	O
sym_index	O
]	O
.	O
st_value	O
-	O
saved_sym	O
->	O
st_value	O
)	O
;	O
if	O
(	O
IN_RANGE	O
(	O
start	O
,	O
end	*(*(char))
,	O
start	O
+	O
reloc	O
->	O
r_offset	O
,	O
reloc_size	O
)	O
)	O
byte_put	O
(	O
start	O
+	O
reloc	O
->	O
r_offset	O
,	O
value	int
,	O
reloc_size	O
)	O
;	O
else	O
error	O
(	O
_	O
(	O
"MSP430 sym diff reloc contains invalid offset: 0x%lx\n"	*(char)
)	O
,	O
(	O
long	O
)	O
reloc	O
->	O
r_offset	O
)	O
;	O
}	O
saved_sym	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
saved_sym	O
!=	O
NULL	O
)	O
error	O
(	O
_	O
(	O
"Unhandled MSP430 reloc type found after SYM_DIFF reloc\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
case	O
EM_MN10300	O
:	O
case	O
EM_CYGNUS_MN10300	O
:	O
{	O
static	O
Elf_Internal_Sym	O
*	O
saved_sym	O
=	O
NULL	O
;	O
if	O
(	O
reloc	O
==	O
NULL	O
)	O
{	O
saved_sym	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
switch	O
(	O
reloc_type	O
)	O
{	O
case	O
34	int
:	O
return	O
TRUE	int
;	O
case	O
33	int
:	O
if	O
(	O
sym_index	O
>=	O
num_syms	O
)	O
error	O
(	O
_	O
(	O
"MN10300_SYM_DIFF reloc contains invalid symbol index %lu\n"	*(char)
)	O
,	O
sym_index	O
)	O
;	O
else	O
saved_sym	O
=	O
symtab	O
+	O
sym_index	O
;	O
return	O
TRUE	int
;	O
case	O
1	int
:	O
case	O
2	int
:	O
if	O
(	O
saved_sym	O
!=	O
NULL	O
)	O
{	O
int	O
reloc_size	O
=	O
reloc_type	O
==	O
1	int
?	O
4	int
:	O
2	int
;	O
bfd_vma	long
value	int
;	O
if	O
(	O
sym_index	O
>=	O
num_syms	O
)	O
error	O
(	O
_	O
(	O
"MN10300 reloc contains invalid symbol index %lu\n"	*(char)
)	O
,	O
sym_index	O
)	O
;	O
else	O
{	O
value	int
=	O
reloc	O
->	O
r_addend	O
+	O
(	O
symtab	O
[	O
sym_index	O
]	O
.	O
st_value	O
-	O
saved_sym	O
->	O
st_value	O
)	O
;	O
if	O
(	O
IN_RANGE	O
(	O
start	O
,	O
end	*(*(char))
,	O
start	O
+	O
reloc	O
->	O
r_offset	O
,	O
reloc_size	O
)	O
)	O
byte_put	O
(	O
start	O
+	O
reloc	O
->	O
r_offset	O
,	O
value	int
,	O
reloc_size	O
)	O
;	O
else	O
error	O
(	O
_	O
(	O
"MN10300 sym diff reloc contains invalid offset: 0x%lx\n"	*(char)
)	O
,	O
(	O
long	O
)	O
reloc	O
->	O
r_offset	O
)	O
;	O
}	O
saved_sym	O
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
saved_sym	O
!=	O
NULL	O
)	O
error	O
(	O
_	O
(	O
"Unhandled MN10300 reloc type found after SYM_DIFF reloc\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
case	O
EM_RL78	O
:	O
{	O
static	O
bfd_vma	long
saved_sym1	O
=	O
0	int
;	O
static	O
bfd_vma	long
saved_sym2	O
=	O
0	int
;	O
static	O
bfd_vma	long
value	int
;	O
if	O
(	O
reloc	O
==	O
NULL	O
)	O
{	O
saved_sym1	O
=	O
saved_sym2	O
=	O
0	int
;	O
return	O
TRUE	int
;	O
}	O
switch	O
(	O
reloc_type	O
)	O
{	O
case	O
0x80	int
:	O
saved_sym1	O
=	O
saved_sym2	O
;	O
if	O
(	O
sym_index	O
>=	O
num_syms	O
)	O
error	O
(	O
_	O
(	O
"RL78_SYM reloc contains invalid symbol index %lu\n"	*(char)
)	O
,	O
sym_index	O
)	O
;	O
else	O
{	O
saved_sym2	O
=	O
symtab	O
[	O
sym_index	O
]	O
.	O
st_value	O
;	O
saved_sym2	O
+=	O
reloc	O
->	O
r_addend	O
;	O
}	O
return	O
TRUE	int
;	O
case	O
0x83	int
:	O
value	int
=	O
saved_sym1	O
-	O
saved_sym2	O
;	O
saved_sym2	O
=	O
saved_sym1	O
=	O
0	int
;	O
return	O
TRUE	int
;	O
break	O
;	O
case	O
0x41	int
:	O
if	O
(	O
IN_RANGE	O
(	O
start	O
,	O
end	*(*(char))
,	O
start	O
+	O
reloc	O
->	O
r_offset	O
,	O
4	int
)	O
)	O
byte_put	O
(	O
start	O
+	O
reloc	O
->	O
r_offset	O
,	O
value	int
,	O
4	int
)	O
;	O
else	O
error	O
(	O
_	O
(	O
"RL78 sym diff reloc contains invalid offset: 0x%lx\n"	*(char)
)	O
,	O
(	O
long	O
)	O
reloc	O
->	O
r_offset	O
)	O
;	O
value	int
=	O
0	int
;	O
return	O
TRUE	int
;	O
case	O
0x43	int
:	O
if	O
(	O
IN_RANGE	O
(	O
start	O
,	O
end	*(*(char))
,	O
start	O
+	O
reloc	O
->	O
r_offset	O
,	O
2	int
)	O
)	O
byte_put	O
(	O
start	O
+	O
reloc	O
->	O
r_offset	O
,	O
value	int
,	O
2	int
)	O
;	O
else	O
error	O
(	O
_	O
(	O
"RL78 sym diff reloc contains invalid offset: 0x%lx\n"	*(char)
)	O
,	O
(	O
long	O
)	O
reloc	O
->	O
r_offset	O
)	O
;	O
value	int
=	O
0	int
;	O
return	O
TRUE	int
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
}	O
return	O
FALSE	O
;	O
}	O
static	O
bfd_boolean	int
is_32bit_abs_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_386	O
:	O
case	O
EM_IAMCU	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_68K	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_860	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_960	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_AARCH64	O
:	O
return	O
(	O
reloc_type	O
==	O
258	int
||	O
reloc_type	O
==	O
1	int
)	O
;	O
case	O
EM_BPF	O
:	O
return	O
reloc_type	O
==	O
11	int
;	O
case	O
EM_ADAPTEVA_EPIPHANY	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_ALPHA	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_ARC	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_ARC_COMPACT	O
:	O
case	O
EM_ARC_COMPACT2	O
:	O
return	O
reloc_type	O
==	O
4	int
;	O
case	O
EM_ARM	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_AVR_OLD	O
:	O
case	O
EM_AVR	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_BLACKFIN	O
:	O
return	O
reloc_type	O
==	O
0x12	int
;	O
case	O
EM_CRIS	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_CR16	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_CRX	O
:	O
return	O
reloc_type	O
==	O
15	int
;	O
case	O
EM_CSKY	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_CYGNUS_FRV	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_CYGNUS_D10V	O
:	O
case	O
EM_D10V	O
:	O
return	O
reloc_type	O
==	O
6	int
;	O
case	O
EM_CYGNUS_D30V	O
:	O
case	O
EM_D30V	O
:	O
return	O
reloc_type	O
==	O
12	int
;	O
case	O
EM_DLX	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_CYGNUS_FR30	O
:	O
case	O
EM_FR30	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_FT32	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_H8S	O
:	O
case	O
EM_H8_300	O
:	O
case	O
EM_H8_300H	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_IA_64	O
:	O
return	O
(	O
reloc_type	O
==	O
0x64	int
||	O
reloc_type	O
==	O
0x65	int
||	O
reloc_type	O
==	O
0x24	int
||	O
reloc_type	O
==	O
0x25	int
)	O
;	O
case	O
EM_IP2K_OLD	O
:	O
case	O
EM_IP2K	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_IQ2000	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_LATTICEMICO32	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_M32C_OLD	O
:	O
case	O
EM_M32C	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_M32R	O
:	O
return	O
reloc_type	O
==	O
34	int
;	O
case	O
EM_68HC11	O
:	O
case	O
EM_68HC12	O
:	O
return	O
reloc_type	O
==	O
6	int
;	O
case	O
EM_S12Z	O
:	O
return	O
reloc_type	O
==	O
7	int
||	O
reloc_type	O
==	O
6	int
;	O
case	O
EM_MCORE	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_CYGNUS_MEP	O
:	O
return	O
reloc_type	O
==	O
4	int
;	O
case	O
EM_METAG	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_MICROBLAZE	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_MIPS	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_MMIX	O
:	O
return	O
reloc_type	O
==	O
4	int
;	O
case	O
EM_CYGNUS_MN10200	O
:	O
case	O
EM_MN10200	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_CYGNUS_MN10300	O
:	O
case	O
EM_MN10300	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_MOXIE	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_MSP430_OLD	O
:	O
case	O
EM_MSP430	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_MT	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_NDS32	O
:	O
return	O
reloc_type	O
==	O
20	int
;	O
case	O
EM_ALTERA_NIOS2	O
:	O
return	O
reloc_type	O
==	O
12	int
;	O
case	O
EM_NIOS32	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_OR1K	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_PARISC	O
:	O
return	O
(	O
reloc_type	O
==	O
1	int
||	O
reloc_type	O
==	O
2	int
||	O
reloc_type	O
==	O
41	int
)	O
;	O
case	O
EM_PJ	O
:	O
case	O
EM_PJ_OLD	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_PPC64	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_PPC	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_TI_PRU	O
:	O
return	O
reloc_type	O
==	O
11	int
;	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_RL78	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_RX	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_S370	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_S390_OLD	O
:	O
case	O
EM_S390	O
:	O
return	O
reloc_type	O
==	O
4	int
;	O
case	O
EM_SCORE	O
:	O
return	O
reloc_type	O
==	O
8	int
;	O
case	O
EM_SH	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_SPARC32PLUS	O
:	O
case	O
EM_SPARCV9	O
:	O
case	O
EM_SPARC	O
:	O
return	O
reloc_type	O
==	O
3	int
||	O
reloc_type	O
==	O
23	int
;	O
case	O
EM_SPU	O
:	O
return	O
reloc_type	O
==	O
6	int
;	O
case	O
EM_TI_C6000	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_TILEGX	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_TILEPRO	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_CYGNUS_V850	O
:	O
case	O
EM_V850	O
:	O
return	O
reloc_type	O
==	O
6	int
;	O
case	O
EM_V800	O
:	O
return	O
reloc_type	O
==	O
0x33	int
;	O
case	O
EM_VAX	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_VISIUM	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_WEBASSEMBLY	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_X86_64	O
:	O
case	O
EM_L1OM	O
:	O
case	O
EM_K1OM	O
:	O
return	O
reloc_type	O
==	O
10	int
;	O
case	O
EM_XC16X	O
:	O
case	O
EM_C166	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_XGATE	O
:	O
return	O
reloc_type	O
==	O
4	int
;	O
case	O
EM_XSTORMY16	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_XTENSA_OLD	O
:	O
case	O
EM_XTENSA	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_Z80	O
:	O
return	O
reloc_type	O
==	O
6	int
;	O
default	O
:	O
{	O
static	O
unsigned	O
int	O
prev_warn	O
=	O
0	int
;	O
if	O
(	O
prev_warn	O
!=	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
error	O
(	O
_	O
(	O
"Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n"	*(char)
)	O
,	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
;	O
prev_warn	O
=	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
}	O
static	O
bfd_boolean	int
is_32bit_pcrel_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_386	O
:	O
case	O
EM_IAMCU	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_68K	O
:	O
return	O
reloc_type	O
==	O
4	int
;	O
case	O
EM_AARCH64	O
:	O
return	O
reloc_type	O
==	O
261	int
;	O
case	O
EM_ADAPTEVA_EPIPHANY	O
:	O
return	O
reloc_type	O
==	O
6	int
;	O
case	O
EM_ALPHA	O
:	O
return	O
reloc_type	O
==	O
10	int
;	O
case	O
EM_ARC_COMPACT	O
:	O
case	O
EM_ARC_COMPACT2	O
:	O
return	O
reloc_type	O
==	O
49	int
;	O
case	O
EM_ARM	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_AVR_OLD	O
:	O
case	O
EM_AVR	O
:	O
return	O
reloc_type	O
==	O
36	int
;	O
case	O
EM_MICROBLAZE	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_OR1K	O
:	O
return	O
reloc_type	O
==	O
9	int
;	O
case	O
EM_PARISC	O
:	O
return	O
reloc_type	O
==	O
9	int
;	O
case	O
EM_PPC	O
:	O
return	O
reloc_type	O
==	O
26	int
;	O
case	O
EM_PPC64	O
:	O
return	O
reloc_type	O
==	O
26	int
;	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
57	int
;	O
case	O
EM_S390_OLD	O
:	O
case	O
EM_S390	O
:	O
return	O
reloc_type	O
==	O
5	int
;	O
case	O
EM_SH	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_SPARC32PLUS	O
:	O
case	O
EM_SPARCV9	O
:	O
case	O
EM_SPARC	O
:	O
return	O
reloc_type	O
==	O
6	int
;	O
case	O
EM_SPU	O
:	O
return	O
reloc_type	O
==	O
13	int
;	O
case	O
EM_TILEGX	O
:	O
return	O
reloc_type	O
==	O
6	int
;	O
case	O
EM_TILEPRO	O
:	O
return	O
reloc_type	O
==	O
4	int
;	O
case	O
EM_VISIUM	O
:	O
return	O
reloc_type	O
==	O
6	int
;	O
case	O
EM_X86_64	O
:	O
case	O
EM_L1OM	O
:	O
case	O
EM_K1OM	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_VAX	O
:	O
return	O
reloc_type	O
==	O
4	int
;	O
case	O
EM_XTENSA_OLD	O
:	O
case	O
EM_XTENSA	O
:	O
return	O
reloc_type	O
==	O
14	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_64bit_abs_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_AARCH64	O
:	O
return	O
reloc_type	O
==	O
257	int
;	O
case	O
EM_ALPHA	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_IA_64	O
:	O
return	O
(	O
reloc_type	O
==	O
0x26	int
||	O
reloc_type	O
==	O
0x27	int
)	O
;	O
case	O
EM_PARISC	O
:	O
return	O
reloc_type	O
==	O
80	int
;	O
case	O
EM_PPC64	O
:	O
return	O
reloc_type	O
==	O
38	int
;	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_SPARC32PLUS	O
:	O
case	O
EM_SPARCV9	O
:	O
case	O
EM_SPARC	O
:	O
return	O
reloc_type	O
==	O
32	int
||	O
reloc_type	O
==	O
54	int
;	O
case	O
EM_X86_64	O
:	O
case	O
EM_L1OM	O
:	O
case	O
EM_K1OM	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_S390_OLD	O
:	O
case	O
EM_S390	O
:	O
return	O
reloc_type	O
==	O
22	int
;	O
case	O
EM_TILEGX	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_MIPS	O
:	O
return	O
reloc_type	O
==	O
18	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_64bit_pcrel_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_AARCH64	O
:	O
return	O
reloc_type	O
==	O
260	int
;	O
case	O
EM_ALPHA	O
:	O
return	O
reloc_type	O
==	O
11	int
;	O
case	O
EM_IA_64	O
:	O
return	O
(	O
reloc_type	O
==	O
0x4e	int
||	O
reloc_type	O
==	O
0x4f	int
)	O
;	O
case	O
EM_PARISC	O
:	O
return	O
reloc_type	O
==	O
72	int
;	O
case	O
EM_PPC64	O
:	O
return	O
reloc_type	O
==	O
44	int
;	O
case	O
EM_SPARC32PLUS	O
:	O
case	O
EM_SPARCV9	O
:	O
case	O
EM_SPARC	O
:	O
return	O
reloc_type	O
==	O
46	int
;	O
case	O
EM_X86_64	O
:	O
case	O
EM_L1OM	O
:	O
case	O
EM_K1OM	O
:	O
return	O
reloc_type	O
==	O
24	int
;	O
case	O
EM_S390_OLD	O
:	O
case	O
EM_S390	O
:	O
return	O
reloc_type	O
==	O
23	int
;	O
case	O
EM_TILEGX	O
:	O
return	O
reloc_type	O
==	O
5	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_24bit_abs_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_CYGNUS_MN10200	O
:	O
case	O
EM_MN10200	O
:	O
return	O
reloc_type	O
==	O
4	int
;	O
case	O
EM_FT32	O
:	O
return	O
reloc_type	O
==	O
5	int
;	O
case	O
EM_Z80	O
:	O
return	O
reloc_type	O
==	O
5	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_16bit_abs_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_ARC	O
:	O
case	O
EM_ARC_COMPACT	O
:	O
case	O
EM_ARC_COMPACT2	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_ADAPTEVA_EPIPHANY	O
:	O
return	O
reloc_type	O
==	O
5	int
;	O
case	O
EM_AVR_OLD	O
:	O
case	O
EM_AVR	O
:	O
return	O
reloc_type	O
==	O
4	int
;	O
case	O
EM_CYGNUS_D10V	O
:	O
case	O
EM_D10V	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_FT32	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_H8S	O
:	O
case	O
EM_H8_300	O
:	O
case	O
EM_H8_300H	O
:	O
return	O
reloc_type	O
==	O
R_H8_DIR16	O
;	O
case	O
EM_IP2K_OLD	O
:	O
case	O
EM_IP2K	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_M32C_OLD	O
:	O
case	O
EM_M32C	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
case	O
EM_CYGNUS_MN10200	O
:	O
case	O
EM_MN10200	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_CYGNUS_MN10300	O
:	O
case	O
EM_MN10300	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_MSP430	O
:	O
if	O
(	O
uses_msp430x_relocs	O
(	O
filedata	O
)	O
)	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_MSP430_OLD	O
:	O
return	O
reloc_type	O
==	O
5	int
;	O
case	O
EM_NDS32	O
:	O
return	O
reloc_type	O
==	O
19	int
;	O
case	O
EM_ALTERA_NIOS2	O
:	O
return	O
reloc_type	O
==	O
13	int
;	O
case	O
EM_NIOS32	O
:	O
return	O
reloc_type	O
==	O
9	int
;	O
case	O
EM_OR1K	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
55	int
;	O
case	O
EM_TI_PRU	O
:	O
return	O
reloc_type	O
==	O
8	int
;	O
case	O
EM_TI_C6000	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_VISIUM	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_XC16X	O
:	O
case	O
EM_C166	O
:	O
return	O
reloc_type	O
==	O
2	int
;	O
case	O
EM_XGATE	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_Z80	O
:	O
return	O
reloc_type	O
==	O
4	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_8bit_abs_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
54	int
;	O
case	O
EM_Z80	O
:	O
return	O
reloc_type	O
==	O
1	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_6bit_abs_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
53	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_32bit_inplace_add_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
35	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_32bit_inplace_sub_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
39	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_64bit_inplace_add_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
36	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_64bit_inplace_sub_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
40	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_16bit_inplace_add_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
34	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_16bit_inplace_sub_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
38	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_8bit_inplace_add_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
33	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_8bit_inplace_sub_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
37	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_6bit_inplace_sub_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_RISCV	O
:	O
return	O
reloc_type	O
==	O
52	int
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
bfd_boolean	int
is_none_reloc	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
int	O
reloc_type	O
)	O
{	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_386	O
:	O
case	O
EM_68K	O
:	O
case	O
EM_ADAPTEVA_EPIPHANY	O
:	O
case	O
EM_ALPHA	O
:	O
case	O
EM_ALTERA_NIOS2	O
:	O
case	O
EM_ARC	O
:	O
case	O
EM_ARC_COMPACT2	O
:	O
case	O
EM_ARC_COMPACT	O
:	O
case	O
EM_ARM	O
:	O
case	O
EM_C166	O
:	O
case	O
EM_CRIS	O
:	O
case	O
EM_FT32	O
:	O
case	O
EM_IA_64	O
:	O
case	O
EM_K1OM	O
:	O
case	O
EM_L1OM	O
:	O
case	O
EM_M32R	O
:	O
case	O
EM_MIPS	O
:	O
case	O
EM_MN10300	O
:	O
case	O
EM_MOXIE	O
:	O
case	O
EM_NIOS32	O
:	O
case	O
EM_OR1K	O
:	O
case	O
EM_PARISC	O
:	O
case	O
EM_PPC64	O
:	O
case	O
EM_PPC	O
:	O
case	O
EM_RISCV	O
:	O
case	O
EM_S390	O
:	O
case	O
EM_S390_OLD	O
:	O
case	O
EM_SH	O
:	O
case	O
EM_SPARC32PLUS	O
:	O
case	O
EM_SPARC	O
:	O
case	O
EM_SPARCV9	O
:	O
case	O
EM_TILEGX	O
:	O
case	O
EM_TILEPRO	O
:	O
case	O
EM_TI_C6000	O
:	O
case	O
EM_X86_64	O
:	O
case	O
EM_XC16X	O
:	O
case	O
EM_Z80	O
:	O
case	O
EM_WEBASSEMBLY	O
:	O
return	O
reloc_type	O
==	O
0	int
;	O
case	O
EM_AARCH64	O
:	O
return	O
reloc_type	O
==	O
0	int
||	O
reloc_type	O
==	O
256	int
;	O
case	O
EM_AVR_OLD	O
:	O
case	O
EM_AVR	O
:	O
return	O
(	O
reloc_type	O
==	O
0	int
||	O
reloc_type	O
==	O
30	int
||	O
reloc_type	O
==	O
31	int
||	O
reloc_type	O
==	O
32	int
)	O
;	O
case	O
EM_METAG	O
:	O
return	O
reloc_type	O
==	O
3	int
;	O
case	O
EM_NDS32	O
:	O
return	O
(	O
reloc_type	O
==	O
0	int
||	O
reloc_type	O
==	O
204	int
||	O
reloc_type	O
==	O
205	int
||	O
reloc_type	O
==	O
206	int
||	O
reloc_type	O
==	O
207	int
)	O
;	O
case	O
EM_TI_PRU	O
:	O
return	O
(	O
reloc_type	O
==	O
0	int
||	O
reloc_type	O
==	O
65	int
||	O
reloc_type	O
==	O
66	int
||	O
reloc_type	O
==	O
67	int
)	O
;	O
case	O
EM_XTENSA_OLD	O
:	O
case	O
EM_XTENSA	O
:	O
return	O
(	O
reloc_type	O
==	O
0	int
||	O
reloc_type	O
==	O
17	int
||	O
reloc_type	O
==	O
18	int
||	O
reloc_type	O
==	O
19	int
)	O
;	O
}	O
return	O
FALSE	O
;	O
}	O
bfd_boolean	int
reloc_at	O
(	O
struct	O
dwarf_section	O
*	O
dsec	O
,	O
dwarf_vma	O
offset	long
)	O
{	O
Elf_Internal_Rela	O
*	O
relocs	O
;	O
Elf_Internal_Rela	O
*	O
rp	O
;	O
if	O
(	O
dsec	O
==	O
NULL	O
||	O
dsec	O
->	O
reloc_info	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
relocs	O
=	O
(	O
Elf_Internal_Rela	O
*	O
)	O
dsec	O
->	O
reloc_info	O
;	O
for	O
(	O
rp	O
=	O
relocs	O
;	O
rp	O
<	O
relocs	O
+	O
dsec	O
->	O
num_relocs	O
;	O
++	O
rp	O
)	O
if	O
(	O
rp	O
->	O
r_offset	O
==	O
offset	long
)	O
return	O
TRUE	int
;	O
return	O
FALSE	O
;	O
}	O
static	O
bfd_boolean	int
apply_relocations	O
(	O
Filedata	O
*	O
filedata	O
,	O
const	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
unsigned	O
char	O
*	O
start	O
,	O
bfd_size_type	long
size	int
,	O
void	O
*	O
*	O
relocs_return	O
,	O
unsigned	O
long	O
*	O
num_relocs_return	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
relsec	O
;	O
unsigned	O
char	O
*	O
end	*(*(char))
=	O
start	O
+	O
size	int
;	O
if	O
(	O
relocs_return	O
!=	O
NULL	O
)	O
{	O
*	O
(	O
Elf_Internal_Rela	O
*	O
*	O
)	O
relocs_return	O
=	O
NULL	O
;	O
*	O
num_relocs_return	O
=	O
0	int
;	O
}	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_type	O
!=	O
ET_REL	O
)	O
return	O
TRUE	int
;	O
for	O
(	O
relsec	O
=	O
filedata	O
->	O
section_headers	O
;	O
relsec	O
<	O
filedata	O
->	O
section_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
relsec	O
)	O
{	O
bfd_boolean	int
is_rela	O
;	O
unsigned	O
long	O
num_relocs	O
;	O
Elf_Internal_Rela	O
*	O
relocs	O
;	O
Elf_Internal_Rela	O
*	O
rp	O
;	O
Elf_Internal_Shdr	O
*	O
symsec	O
;	O
Elf_Internal_Sym	O
*	O
symtab	O
;	O
unsigned	O
long	O
num_syms	O
;	O
Elf_Internal_Sym	O
*	O
sym	*(struct)
;	O
if	O
(	O
(	O
relsec	O
->	O
sh_type	O
!=	O
SHT_RELA	O
&&	O
relsec	O
->	O
sh_type	O
!=	O
SHT_REL	O
)	O
||	O
relsec	O
->	O
sh_info	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
||	O
filedata	O
->	O
section_headers	O
+	O
relsec	O
->	O
sh_info	O
!=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
||	O
relsec	O
->	O
sh_size	O
==	O
0	int
||	O
relsec	O
->	O
sh_link	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
continue	O
;	O
symsec	O
=	O
filedata	O
->	O
section_headers	O
+	O
relsec	O
->	O
sh_link	O
;	O
if	O
(	O
symsec	O
->	O
sh_type	O
!=	O
SHT_SYMTAB	O
&&	O
symsec	O
->	O
sh_type	O
!=	O
SHT_DYNSYM	O
)	O
return	O
FALSE	O
;	O
is_rela	O
=	O
relsec	O
->	O
sh_type	O
==	O
SHT_RELA	O
;	O
if	O
(	O
is_rela	O
)	O
{	O
if	O
(	O
!	O
slurp_rela_relocs	O
(	O
filedata	O
,	O
relsec	O
->	O
sh_offset	O
,	O
relsec	O
->	O
sh_size	O
,	O
&	O
relocs	O
,	O
&	O
num_relocs	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
slurp_rel_relocs	O
(	O
filedata	O
,	O
relsec	O
->	O
sh_offset	O
,	O
relsec	O
->	O
sh_size	O
,	O
&	O
relocs	O
,	O
&	O
num_relocs	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_SH	O
)	O
is_rela	O
=	O
FALSE	O
;	O
symtab	O
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	O
,	O
symsec	O
,	O
&	O
num_syms	O
)	O
;	O
for	O
(	O
rp	O
=	O
relocs	O
;	O
rp	O
<	O
relocs	O
+	O
num_relocs	O
;	O
++	O
rp	O
)	O
{	O
bfd_vma	long
addend	long
;	O
unsigned	O
int	O
reloc_type	O
;	O
unsigned	O
int	O
reloc_size	O
;	O
bfd_boolean	int
reloc_inplace	O
=	O
FALSE	O
;	O
bfd_boolean	int
reloc_subtract	O
=	O
FALSE	O
;	O
unsigned	O
char	O
*	O
rloc	O
;	O
unsigned	O
long	O
sym_index	O
;	O
reloc_type	O
=	O
get_reloc_type	O
(	O
filedata	O
,	O
rp	O
->	O
r_info	O
)	O
;	O
if	O
(	O
target_specific_reloc_handling	O
(	O
filedata	O
,	O
rp	O
,	O
start	O
,	O
end	*(*(char))
,	O
symtab	O
,	O
num_syms	O
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
is_none_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
is_32bit_abs_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
||	O
is_32bit_pcrel_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
reloc_size	O
=	O
4	int
;	O
else	O
if	O
(	O
is_64bit_abs_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
||	O
is_64bit_pcrel_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
reloc_size	O
=	O
8	int
;	O
else	O
if	O
(	O
is_24bit_abs_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
reloc_size	O
=	O
3	int
;	O
else	O
if	O
(	O
is_16bit_abs_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
reloc_size	O
=	O
2	int
;	O
else	O
if	O
(	O
is_8bit_abs_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
||	O
is_6bit_abs_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
reloc_size	O
=	O
1	int
;	O
else	O
if	O
(	O
(	O
reloc_subtract	O
=	O
is_32bit_inplace_sub_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
||	O
is_32bit_inplace_add_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
{	O
reloc_size	O
=	O
4	int
;	O
reloc_inplace	O
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
reloc_subtract	O
=	O
is_64bit_inplace_sub_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
||	O
is_64bit_inplace_add_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
{	O
reloc_size	O
=	O
8	int
;	O
reloc_inplace	O
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
reloc_subtract	O
=	O
is_16bit_inplace_sub_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
||	O
is_16bit_inplace_add_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
{	O
reloc_size	O
=	O
2	int
;	O
reloc_inplace	O
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
reloc_subtract	O
=	O
is_8bit_inplace_sub_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
||	O
is_8bit_inplace_add_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
{	O
reloc_size	O
=	O
1	int
;	O
reloc_inplace	O
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
(	O
reloc_subtract	O
=	O
is_6bit_inplace_sub_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
)	O
{	O
reloc_size	O
=	O
1	int
;	O
reloc_inplace	O
=	O
TRUE	int
;	O
}	O
else	O
{	O
static	O
unsigned	O
int	O
prev_reloc	O
=	O
0	int
;	O
if	O
(	O
reloc_type	O
!=	O
prev_reloc	O
)	O
warn	O
(	O
_	O
(	O
"unable to apply unsupported reloc type %d to section %s\n"	*(char)
)	O
,	O
reloc_type	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
prev_reloc	O
=	O
reloc_type	O
;	O
continue	O
;	O
}	O
rloc	O
=	O
start	O
+	O
rp	O
->	O
r_offset	O
;	O
if	O
(	O
!	O
IN_RANGE	O
(	O
start	O
,	O
end	*(*(char))
,	O
rloc	O
,	O
reloc_size	O
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"skipping invalid relocation offset 0x%lx in section %s\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
rp	O
->	O
r_offset	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
continue	O
;	O
}	O
sym_index	O
=	O
(	O
unsigned	O
long	O
)	O
get_reloc_symindex	O
(	O
rp	O
->	O
r_info	O
)	O
;	O
if	O
(	O
sym_index	O
>=	O
num_syms	O
)	O
{	O
warn	O
(	O
_	O
(	O
"skipping invalid relocation symbol index 0x%lx in section %s\n"	*(char)
)	O
,	O
sym_index	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
continue	O
;	O
}	O
sym	*(struct)
=	O
symtab	O
+	O
sym_index	O
;	O
if	O
(	O
sym	*(struct)
!=	O
symtab	O
&&	O
ELF_ST_TYPE	O
(	O
sym	*(struct)
->	O
st_info	O
)	O
!=	O
STT_COMMON	O
&&	O
ELF_ST_TYPE	O
(	O
sym	*(struct)
->	O
st_info	O
)	O
>	O
STT_SECTION	O
)	O
{	O
warn	O
(	O
_	O
(	O
"skipping unexpected symbol type %s in section %s relocation %ld\n"	*(char)
)	O
,	O
get_symbol_type	O
(	O
filedata	O
,	O
ELF_ST_TYPE	O
(	O
sym	*(struct)
->	O
st_info	O
)	O
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
relsec	O
)	O
,	O
(	O
long	O
int	O
)	O
(	O
rp	O
-	O
relocs	O
)	O
)	O
;	O
continue	O
;	O
}	O
addend	long
=	O
0	int
;	O
if	O
(	O
is_rela	O
)	O
addend	long
+=	O
rp	O
->	O
r_addend	O
;	O
if	O
(	O
!	O
is_rela	O
||	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_XTENSA	O
&&	O
reloc_type	O
==	O
1	int
)	O
||	O
(	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_PJ	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_PJ_OLD	O
)	O
&&	O
reloc_type	O
==	O
1	int
)	O
||	O
(	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_D30V	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_CYGNUS_D30V	O
)	O
&&	O
reloc_type	O
==	O
12	int
)	O
||	O
reloc_inplace	O
)	O
{	O
if	O
(	O
is_6bit_inplace_sub_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
addend	long
+=	O
byte_get	O
(	O
rloc	O
,	O
reloc_size	O
)	O
&	O
0x3f	int
;	O
else	O
addend	long
+=	O
byte_get	O
(	O
rloc	O
,	O
reloc_size	O
)	O
;	O
}	O
if	O
(	O
is_32bit_pcrel_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
||	O
is_64bit_pcrel_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
{	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_PARISC	O
)	O
addend	long
-=	O
8	int
;	O
byte_put	O
(	O
rloc	O
,	O
(	O
addend	long
+	O
sym	*(struct)
->	O
st_value	O
)	O
-	O
rp	O
->	O
r_offset	O
,	O
reloc_size	O
)	O
;	O
}	O
else	O
if	O
(	O
is_6bit_abs_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
||	O
is_6bit_inplace_sub_reloc	O
(	O
filedata	O
,	O
reloc_type	O
)	O
)	O
{	O
if	O
(	O
reloc_subtract	O
)	O
addend	long
-=	O
sym	*(struct)
->	O
st_value	O
;	O
else	O
addend	long
+=	O
sym	*(struct)
->	O
st_value	O
;	O
addend	long
=	O
(	O
addend	long
&	O
0x3f	int
)	O
|	O
(	O
byte_get	O
(	O
rloc	O
,	O
reloc_size	O
)	O
&	O
0xc0	int
)	O
;	O
byte_put	O
(	O
rloc	O
,	O
addend	long
,	O
reloc_size	O
)	O
;	O
}	O
else	O
if	O
(	O
reloc_subtract	O
)	O
byte_put	O
(	O
rloc	O
,	O
addend	long
-	O
sym	*(struct)
->	O
st_value	O
,	O
reloc_size	O
)	O
;	O
else	O
byte_put	O
(	O
rloc	O
,	O
addend	long
+	O
sym	*(struct)
->	O
st_value	O
,	O
reloc_size	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
symtab	O
)	O
;	O
target_specific_reloc_handling	O
(	O
filedata	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
relocs_return	O
)	O
{	O
*	O
(	O
Elf_Internal_Rela	O
*	O
*	O
)	O
relocs_return	O
=	O
relocs	O
;	O
*	O
num_relocs_return	O
=	O
num_relocs	O
;	O
}	O
else	O
free	(*(void))->(void)
(	O
relocs	O
)	O
;	O
break	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
char	O
*	O
get_section_contents	O
(	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
Filedata	O
*	O
filedata	O
)	O
{	O
bfd_size_type	long
num_bytes	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
if	O
(	O
num_bytes	O
==	O
0	int
||	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_NOBITS	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Section '%s' has no data to dump.\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
num_bytes	O
,	O
_	O
(	O
"section contents"	*(char)
)	O
)	O
;	O
}	O
static	O
bfd_boolean	int
uncompress_section_contents	O
(	O
unsigned	O
char	O
*	O
*	O
buffer	O
,	O
dwarf_size_type	O
uncompressed_size	*(long)
,	O
dwarf_size_type	O
*	O
size	int
)	O
{	O
dwarf_size_type	O
compressed_size	long
=	O
*	O
size	int
;	O
unsigned	O
char	O
*	O
compressed_buffer	O
=	O
*	O
buffer	O
;	O
unsigned	O
char	O
*	O
uncompressed_buffer	O
;	O
z_stream	struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long)
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
;	O
int	O
rc	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
0	int
,	O
sizeof	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
.	O
avail_in	int
=	O
compressed_size	long
;	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
.	O
next_in	*(char)
=	O
(	O
Bytef	char
*	O
)	O
compressed_buffer	O
;	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
.	O
avail_out	int
=	O
uncompressed_size	*(long)
;	O
uncompressed_buffer	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
xmalloc	O
(	O
uncompressed_size	*(long)
)	O
;	O
rc	O
=	O
inflateInit	O
(	O
&	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
while	O
(	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
.	O
avail_in	int
>	O
0	int
)	O
{	O
if	O
(	O
rc	O
!=	O
Z_OK	O
)	O
goto	O
fail	O
;	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
.	O
next_out	*(char)
=	O
(	O
(	O
Bytef	char
*	O
)	O
uncompressed_buffer	O
+	O
(	O
uncompressed_size	*(long)
-	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
.	O
avail_out	int
)	O
)	O
;	O
rc	O
=	O
inflate	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)),int)->(int)
(	O
&	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
,	O
Z_FINISH	O
)	O
;	O
if	O
(	O
rc	O
!=	O
Z_STREAM_END	O
)	O
goto	O
fail	O
;	O
rc	O
=	O
inflateReset	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
&	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
}	O
rc	O
=	O
inflateEnd	(*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*`,int,int)->(*`)),*((*`,*`)->(void)),*(void),int,long,long)))->(int)
(	O
&	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
)	O
;	O
if	O
(	O
rc	O
!=	O
Z_OK	O
||	O
strm	*(struct(*(char),int,long,*(char),int,long,*(char),*(struct),*((*(void),int,int)->(*(void))),*((*(void),*(void))->(void)),*(void),int,long,long))
.	O
avail_out	int
!=	O
0	int
)	O
goto	O
fail	O
;	O
*	O
buffer	O
=	O
uncompressed_buffer	O
;	O
*	O
size	int
=	O
uncompressed_size	*(long)
;	O
return	O
TRUE	int
;	O
fail	O
:	O
free	(*(void))->(void)
(	O
uncompressed_buffer	O
)	O
;	O
*	O
buffer	O
=	O
NULL	O
;	O
return	O
FALSE	O
;	O
}	O
static	O
bfd_boolean	int
dump_section_as_strings	O
(	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
relsec	O
;	O
bfd_size_type	long
num_bytes	O
;	O
unsigned	O
char	O
*	O
data	*(void)
;	O
unsigned	O
char	O
*	O
end	*(*(char))
;	O
unsigned	O
char	O
*	O
real_start	O
;	O
unsigned	O
char	O
*	O
start	O
;	O
bfd_boolean	int
some_strings_shown	O
;	O
real_start	O
=	O
start	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_section_contents	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
)	O
;	O
if	O
(	O
start	O
==	O
NULL	O
)	O
return	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
==	O
0	int
||	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_NOBITS	O
)	O
?	O
TRUE	int
:	O
FALSE	O
;	O
num_bytes	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nString dump of section '%s':\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
if	O
(	O
decompress_dumps	O
)	O
{	O
dwarf_size_type	O
new_size	O
=	O
num_bytes	O
;	O
dwarf_size_type	O
uncompressed_size	*(long)
=	O
0	int
;	O
if	O
(	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_flags	O
&	O
SHF_COMPRESSED	O
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Chdr	O
chdr	O
;	O
unsigned	O
int	O
compression_header_size	O
=	O
get_compression_header	O
(	O
&	O
chdr	O
,	O
(	O
unsigned	O
char	O
*	O
)	O
start	O
,	O
num_bytes	O
)	O
;	O
if	O
(	O
chdr	O
.	O
ch_type	O
!=	O
ELFCOMPRESS_ZLIB	O
)	O
{	O
warn	O
(	O
_	O
(	O
"section '%s' has unsupported compress type: %d\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
chdr	O
.	O
ch_type	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
uncompressed_size	*(long)
=	O
chdr	O
.	O
ch_size	O
;	O
start	O
+=	O
compression_header_size	O
;	O
new_size	O
-=	O
compression_header_size	O
;	O
}	O
else	O
if	O
(	O
new_size	O
>	O
12	int
&&	O
streq	O
(	O
(	O
char	O
*	O
)	O
start	O
,	O
"ZLIB"	*(char)
)	O
)	O
{	O
uncompressed_size	*(long)
=	O
start	O
[	O
4	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
5	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
6	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
7	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
8	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
9	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
10	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
11	int
]	O
;	O
start	O
+=	O
12	int
;	O
new_size	O
-=	O
12	int
;	O
}	O
if	O
(	O
uncompressed_size	*(long)
)	O
{	O
if	O
(	O
uncompress_section_contents	O
(	O
&	O
start	O
,	O
uncompressed_size	*(long)
,	O
&	O
new_size	O
)	O
)	O
num_bytes	O
=	O
new_size	O
;	O
else	O
{	O
error	O
(	O
_	O
(	O
"Unable to decompress section %s\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
else	O
start	O
=	O
real_start	O
;	O
}	O
for	O
(	O
relsec	O
=	O
filedata	O
->	O
section_headers	O
;	O
relsec	O
<	O
filedata	O
->	O
section_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
relsec	O
)	O
{	O
if	O
(	O
(	O
relsec	O
->	O
sh_type	O
!=	O
SHT_RELA	O
&&	O
relsec	O
->	O
sh_type	O
!=	O
SHT_REL	O
)	O
||	O
relsec	O
->	O
sh_info	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
||	O
filedata	O
->	O
section_headers	O
+	O
relsec	O
->	O
sh_info	O
!=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
||	O
relsec	O
->	O
sh_size	O
==	O
0	int
||	O
relsec	O
->	O
sh_link	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
continue	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Note: This section has relocations against it, but these have NOT been applied to this dump.\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
data	*(void)
=	O
start	O
;	O
end	*(*(char))
=	O
start	O
+	O
num_bytes	O
;	O
some_strings_shown	O
=	O
FALSE	O
;	O
while	O
(	O
data	*(void)
<	O
end	*(*(char))
)	O
{	O
while	O
(	O
!	O
ISPRINT	O
(	O
*	O
data	*(void)
)	O
)	O
if	O
(	O
++	O
data	*(void)
>=	O
end	*(*(char))
)	O
break	O
;	O
if	O
(	O
data	*(void)
<	O
end	*(*(char))
)	O
{	O
size_t	long
maxlen	O
=	O
end	*(*(char))
-	O
data	*(void)
;	O
printf	(*(char))->(int)
(	O
"  [%6tx]  "	*(char)
,	O
data	*(void)
-	O
start	O
)	O
;	O
if	O
(	O
maxlen	O
>	O
0	int
)	O
{	O
print_symbol	O
(	O
(	O
int	O
)	O
maxlen	O
,	O
(	O
const	O
char	O
*	O
)	O
data	*(void)
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
data	*(void)
+=	O
strnlen	(*(char),long)->(long)
(	O
(	O
const	O
char	O
*	O
)	O
data	*(void)
,	O
maxlen	O
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>\n"	*(char)
)	O
)	O
;	O
data	*(void)
=	O
end	*(*(char))
;	O
}	O
some_strings_shown	O
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
!	O
some_strings_shown	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  No strings found in this section."	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
real_start	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
dump_section_as_bytes	O
(	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
Filedata	O
*	O
filedata	O
,	O
bfd_boolean	int
relocate	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
relsec	O
;	O
bfd_size_type	long
bytes	O
;	O
bfd_size_type	long
section_size	O
;	O
bfd_vma	long
addr	*(void)
;	O
unsigned	O
char	O
*	O
data	*(void)
;	O
unsigned	O
char	O
*	O
real_start	O
;	O
unsigned	O
char	O
*	O
start	O
;	O
real_start	O
=	O
start	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_section_contents	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
)	O
;	O
if	O
(	O
start	O
==	O
NULL	O
)	O
return	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
==	O
0	int
||	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_NOBITS	O
)	O
?	O
TRUE	int
:	O
FALSE	O
;	O
section_size	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nHex dump of section '%s':\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
if	O
(	O
decompress_dumps	O
)	O
{	O
dwarf_size_type	O
new_size	O
=	O
section_size	O
;	O
dwarf_size_type	O
uncompressed_size	*(long)
=	O
0	int
;	O
if	O
(	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_flags	O
&	O
SHF_COMPRESSED	O
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Chdr	O
chdr	O
;	O
unsigned	O
int	O
compression_header_size	O
=	O
get_compression_header	O
(	O
&	O
chdr	O
,	O
start	O
,	O
section_size	O
)	O
;	O
if	O
(	O
chdr	O
.	O
ch_type	O
!=	O
ELFCOMPRESS_ZLIB	O
)	O
{	O
warn	O
(	O
_	O
(	O
"section '%s' has unsupported compress type: %d\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
chdr	O
.	O
ch_type	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
uncompressed_size	*(long)
=	O
chdr	O
.	O
ch_size	O
;	O
start	O
+=	O
compression_header_size	O
;	O
new_size	O
-=	O
compression_header_size	O
;	O
}	O
else	O
if	O
(	O
new_size	O
>	O
12	int
&&	O
streq	O
(	O
(	O
char	O
*	O
)	O
start	O
,	O
"ZLIB"	*(char)
)	O
)	O
{	O
uncompressed_size	*(long)
=	O
start	O
[	O
4	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
5	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
6	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
7	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
8	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
9	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
10	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
11	int
]	O
;	O
start	O
+=	O
12	int
;	O
new_size	O
-=	O
12	int
;	O
}	O
if	O
(	O
uncompressed_size	*(long)
)	O
{	O
if	O
(	O
uncompress_section_contents	O
(	O
&	O
start	O
,	O
uncompressed_size	*(long)
,	O
&	O
new_size	O
)	O
)	O
{	O
section_size	O
=	O
new_size	O
;	O
}	O
else	O
{	O
error	O
(	O
_	O
(	O
"Unable to decompress section %s\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
else	O
start	O
=	O
real_start	O
;	O
}	O
if	O
(	O
relocate	O
)	O
{	O
if	O
(	O
!	O
apply_relocations	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
start	O
,	O
section_size	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
for	O
(	O
relsec	O
=	O
filedata	O
->	O
section_headers	O
;	O
relsec	O
<	O
filedata	O
->	O
section_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
++	O
relsec	O
)	O
{	O
if	O
(	O
(	O
relsec	O
->	O
sh_type	O
!=	O
SHT_RELA	O
&&	O
relsec	O
->	O
sh_type	O
!=	O
SHT_REL	O
)	O
||	O
relsec	O
->	O
sh_info	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
||	O
filedata	O
->	O
section_headers	O
+	O
relsec	O
->	O
sh_info	O
!=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
||	O
relsec	O
->	O
sh_size	O
==	O
0	int
||	O
relsec	O
->	O
sh_link	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
continue	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
}	O
addr	*(void)
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
;	O
bytes	O
=	O
section_size	O
;	O
data	*(void)
=	O
start	O
;	O
while	O
(	O
bytes	O
)	O
{	O
int	O
j	O
;	O
int	O
k	O
;	O
int	O
lbytes	O
;	O
lbytes	O
=	O
(	O
bytes	O
>	O
16	int
?	O
16	int
:	O
bytes	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  0x%8.8lx "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
addr	*(void)
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
16	int
;	O
j	O
++	O
)	O
{	O
if	O
(	O
j	O
<	O
lbytes	O
)	O
printf	(*(char))->(int)
(	O
"%2.2x"	*(char)
,	O
data	*(void)
[	O
j	O
]	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"  "	*(char)
)	O
;	O
if	O
(	O
(	O
j	O
&	O
3	int
)	O
==	O
3	int
)	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
}	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
lbytes	O
;	O
j	O
++	O
)	O
{	O
k	O
=	O
data	*(void)
[	O
j	O
]	O
;	O
if	O
(	O
k	O
>=	O
' '	O
&&	O
k	O
<	O
0x7f	int
)	O
printf	(*(char))->(int)
(	O
"%c"	*(char)
,	O
k	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"."	*(char)
)	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
data	*(void)
+=	O
lbytes	O
;	O
addr	*(void)
+=	O
lbytes	O
;	O
bytes	O
-=	O
lbytes	O
;	O
}	O
free	(*(void))->(void)
(	O
real_start	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
ctf_sect_t	O
*	O
shdr_to_ctf_sect	O
(	O
ctf_sect_t	O
*	O
buf	*(void)
,	O
Elf_Internal_Shdr	O
*	O
shdr	O
,	O
Filedata	O
*	O
filedata	O
)	O
{	O
buf	*(void)
->	O
cts_name	O
=	O
SECTION_NAME	O
(	O
shdr	O
)	O
;	O
buf	*(void)
->	O
cts_size	O
=	O
shdr	O
->	O
sh_size	O
;	O
buf	*(void)
->	O
cts_entsize	O
=	O
shdr	O
->	O
sh_entsize	O
;	O
return	O
buf	*(void)
;	O
}	O
static	O
char	O
*	O
dump_ctf_indent_lines	O
(	O
ctf_sect_names_t	O
sect	*(struct)
ATTRIBUTE_UNUSED	O
,	O
char	O
*	O
s	*(char)
,	O
void	O
*	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
)	O
{	O
const	O
char	O
*	O
blanks	O
=	O
arg	*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*(struct`),*(struct`))->(*(struct`))),*((*(struct`),*(char))->(int)),*((long,int,int)->(*(void))),*(struct(int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),long,*(char),*(char),int,int,*((*`,*`)->(*`)),*((*`,*`)->(int)),*((long,int,int)->(*`)),*(struct`),int)),int))
;	O
char	O
*	O
new_s	O
;	O
if	O
(	O
asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
new_s	O
,	O
"%s%s"	*(char)
,	O
blanks	O
,	O
s	*(char)
)	O
<	O
0	int
)	O
return	O
s	*(char)
;	O
return	O
new_s	O
;	O
}	O
static	O
bfd_boolean	int
dump_section_as_ctf	O
(	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
parent_sec	O
=	O
NULL	O
;	O
Elf_Internal_Shdr	O
*	O
symtab_sec	O
=	O
NULL	O
;	O
Elf_Internal_Shdr	O
*	O
strtab_sec	O
=	O
NULL	O
;	O
void	O
*	O
data	*(void)
=	O
NULL	O
;	O
void	O
*	O
symdata	O
=	O
NULL	O
;	O
void	O
*	O
strdata	O
=	O
NULL	O
;	O
void	O
*	O
parentdata	O
=	O
NULL	O
;	O
ctf_sect_t	O
ctfsect	O
,	O
symsect	O
,	O
strsect	O
,	O
parentsect	O
;	O
ctf_sect_t	O
*	O
symsectp	O
=	O
NULL	O
;	O
ctf_sect_t	O
*	O
strsectp	O
=	O
NULL	O
;	O
ctf_file_t	O
*	O
ctf	O
=	O
NULL	O
;	O
ctf_file_t	O
*	O
parent	O
=	O
NULL	O
;	O
const	O
char	O
*	O
things	O
[	O
]	O
=	O
{	O
"Header"	*(char)
,	O
"Labels"	*(char)
,	O
"Data objects"	*(char)
,	O
"Function objects"	*(char)
,	O
"Variables"	*(char)
,	O
"Types"	*(char)
,	O
"Strings"	*(char)
,	O
""	*(char)
}	O
;	O
const	O
char	O
*	O
*	O
thing	O
;	O
int	O
err	O
;	O
bfd_boolean	int
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
size_t	long
i	*(struct)
;	O
shdr_to_ctf_sect	O
(	O
&	O
ctfsect	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
)	O
;	O
data	*(void)
=	O
get_section_contents	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
)	O
;	O
ctfsect	O
.	O
cts_data	O
=	O
data	*(void)
;	O
if	O
(	O
!	O
dump_ctf_symtab_name	O
)	O
dump_ctf_symtab_name	O
=	O
strdup	(*(char))->(*(char))
(	O
".symtab"	*(char)
)	O
;	O
if	O
(	O
!	O
dump_ctf_strtab_name	O
)	O
dump_ctf_strtab_name	O
=	O
strdup	(*(char))->(*(char))
(	O
".strtab"	*(char)
)	O
;	O
if	O
(	O
dump_ctf_symtab_name	O
&&	O
dump_ctf_symtab_name	O
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
symtab_sec	O
=	O
find_section	O
(	O
filedata	O
,	O
dump_ctf_symtab_name	O
)	O
)	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"No symbol section named %s\n"	*(char)
)	O
,	O
dump_ctf_symtab_name	O
)	O
;	O
goto	O
fail	O
;	O
}	O
if	O
(	O
(	O
symdata	O
=	O
(	O
void	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
symtab_sec	O
->	O
sh_offset	O
,	O
1	int
,	O
symtab_sec	O
->	O
sh_size	O
,	O
_	O
(	O
"symbols"	*(char)
)	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
fail	O
;	O
symsectp	O
=	O
shdr_to_ctf_sect	O
(	O
&	O
symsect	O
,	O
symtab_sec	O
,	O
filedata	O
)	O
;	O
symsect	O
.	O
cts_data	O
=	O
symdata	O
;	O
}	O
if	O
(	O
dump_ctf_strtab_name	O
&&	O
dump_ctf_symtab_name	O
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
strtab_sec	O
=	O
find_section	O
(	O
filedata	O
,	O
dump_ctf_strtab_name	O
)	O
)	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"No string table section named %s\n"	*(char)
)	O
,	O
dump_ctf_strtab_name	O
)	O
;	O
goto	O
fail	O
;	O
}	O
if	O
(	O
(	O
strdata	O
=	O
(	O
void	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
strtab_sec	O
->	O
sh_offset	O
,	O
1	int
,	O
strtab_sec	O
->	O
sh_size	O
,	O
_	O
(	O
"strings"	*(char)
)	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
fail	O
;	O
strsectp	O
=	O
shdr_to_ctf_sect	O
(	O
&	O
strsect	O
,	O
strtab_sec	O
,	O
filedata	O
)	O
;	O
strsect	O
.	O
cts_data	O
=	O
strdata	O
;	O
}	O
if	O
(	O
dump_ctf_parent_name	O
)	O
{	O
if	O
(	O
(	O
parent_sec	O
=	O
find_section	O
(	O
filedata	O
,	O
dump_ctf_parent_name	O
)	O
)	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"No CTF parent section named %s\n"	*(char)
)	O
,	O
dump_ctf_parent_name	O
)	O
;	O
goto	O
fail	O
;	O
}	O
if	O
(	O
(	O
parentdata	O
=	O
(	O
void	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
parent_sec	O
->	O
sh_offset	O
,	O
1	int
,	O
parent_sec	O
->	O
sh_size	O
,	O
_	O
(	O
"CTF parent"	*(char)
)	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
fail	O
;	O
shdr_to_ctf_sect	O
(	O
&	O
parentsect	O
,	O
parent_sec	O
,	O
filedata	O
)	O
;	O
parentsect	O
.	O
cts_data	O
=	O
parentdata	O
;	O
}	O
if	O
(	O
(	O
ctf	O
=	O
ctf_bufopen	O
(	O
&	O
ctfsect	O
,	O
symsectp	O
,	O
strsectp	O
,	O
&	O
err	O
)	O
)	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"CTF open failure: %s\n"	*(char)
)	O
,	O
ctf_errmsg	O
(	O
err	O
)	O
)	O
;	O
goto	O
fail	O
;	O
}	O
if	O
(	O
parentdata	O
)	O
{	O
if	O
(	O
(	O
parent	O
=	O
ctf_bufopen	O
(	O
&	O
parentsect	O
,	O
symsectp	O
,	O
strsectp	O
,	O
&	O
err	O
)	O
)	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"CTF open failure: %s\n"	*(char)
)	O
,	O
ctf_errmsg	O
(	O
err	O
)	O
)	O
;	O
goto	O
fail	O
;	O
}	O
ctf_import	O
(	O
ctf	O
,	O
parent	O
)	O
;	O
}	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
TRUE	int
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nDump of CTF section '%s':\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
thing	O
=	O
things	O
;	O
*	O
thing	O
[	O
0	int
]	O
;	O
thing	O
++	O
,	O
i	*(struct)
++	O
)	O
{	O
ctf_dump_state_t	O
*	O
s	*(char)
=	O
NULL	O
;	O
char	O
*	O
item	O
;	O
printf	(*(char))->(int)
(	O
"\n  %s:\n"	*(char)
,	O
*	O
thing	O
)	O
;	O
while	O
(	O
(	O
item	O
=	O
ctf_dump	O
(	O
ctf	O
,	O
&	O
s	*(char)
,	O
i	*(struct)
,	O
dump_ctf_indent_lines	O
,	O
(	O
void	O
*	O
)	O
"    "	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
item	O
)	O
;	O
free	(*(void))->(void)
(	O
item	O
)	O
;	O
}	O
if	O
(	O
ctf_errno	O
(	O
ctf	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"Iteration failed: %s, %s\n"	*(char)
)	O
,	O
*	O
thing	O
,	O
ctf_errmsg	O
(	O
ctf_errno	O
(	O
ctf	O
)	O
)	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
}	O
}	O
fail	O
:	O
ctf_file_close	O
(	O
ctf	O
)	O
;	O
ctf_file_close	O
(	O
parent	O
)	O
;	O
free	(*(void))->(void)
(	O
parentdata	O
)	O
;	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
symdata	O
)	O
;	O
free	(*(void))->(void)
(	O
strdata	O
)	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
static	O
bfd_boolean	int
load_specific_debug_section	O
(	O
enum	O
dwarf_section_display_enum	O
debug	O
,	O
const	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
dwarf_section	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
&	O
debug_displays	O
[	O
debug	O
]	O
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
char	O
buf	*(void)
[	O
64	int
]	O
;	O
Filedata	O
*	O
filedata	O
=	O
(	O
Filedata	O
*	O
)	O
data	*(void)
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
streq	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
filename	*(char)
,	O
filedata	O
->	O
file_name	O
)	O
)	O
return	O
TRUE	int
;	O
free	(*(void))->(void)
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
)	O
;	O
}	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	*(void)
,	O
sizeof	O
(	O
buf	*(void)
)	O
,	O
_	O
(	O
"%s section data"	*(char)
)	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
name	*(char)
)	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
address	*(void)
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addr	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
user_data	O
=	O
NULL	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
filename	*(char)
=	O
filedata	O
->	O
file_name	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
buf	*(void)
)	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
==	O
NULL	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
size	int
=	O
0	int
;	O
else	O
{	O
unsigned	O
char	O
*	O
start	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
;	O
dwarf_size_type	O
size	int
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
dwarf_size_type	O
uncompressed_size	*(long)
=	O
0	int
;	O
if	O
(	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_flags	O
&	O
SHF_COMPRESSED	O
)	O
!=	O
0	int
)	O
{	O
Elf_Internal_Chdr	O
chdr	O
;	O
unsigned	O
int	O
compression_header_size	O
;	O
if	O
(	O
size	int
<	O
(	O
is_32bit_elf	O
?	O
sizeof	O
(	O
Elf32_External_Chdr	O
)	O
:	O
sizeof	O
(	O
Elf64_External_Chdr	O
)	O
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"compressed section %s is too small to contain a compression header"	*(char)
)	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
name	*(char)
)	O
;	O
return	O
FALSE	O
;	O
}	O
compression_header_size	O
=	O
get_compression_header	O
(	O
&	O
chdr	O
,	O
start	O
,	O
size	int
)	O
;	O
if	O
(	O
chdr	O
.	O
ch_type	O
!=	O
ELFCOMPRESS_ZLIB	O
)	O
{	O
warn	O
(	O
_	O
(	O
"section '%s' has unsupported compress type: %d\n"	*(char)
)	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
name	*(char)
,	O
chdr	O
.	O
ch_type	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
uncompressed_size	*(long)
=	O
chdr	O
.	O
ch_size	O
;	O
start	O
+=	O
compression_header_size	O
;	O
size	int
-=	O
compression_header_size	O
;	O
}	O
else	O
if	O
(	O
size	int
>	O
12	int
&&	O
streq	O
(	O
(	O
char	O
*	O
)	O
start	O
,	O
"ZLIB"	*(char)
)	O
)	O
{	O
uncompressed_size	*(long)
=	O
start	O
[	O
4	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
5	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
6	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
7	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
8	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
9	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
10	int
]	O
;	O
uncompressed_size	*(long)
<<=	O
8	int
;	O
uncompressed_size	*(long)
+=	O
start	O
[	O
11	int
]	O
;	O
start	O
+=	O
12	int
;	O
size	int
-=	O
12	int
;	O
}	O
if	O
(	O
uncompressed_size	*(long)
)	O
{	O
if	O
(	O
uncompress_section_contents	O
(	O
&	O
start	O
,	O
uncompressed_size	*(long)
,	O
&	O
size	int
)	O
)	O
{	O
free	(*(void))->(void)
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
)	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
=	O
start	O
;	O
}	O
else	O
{	O
error	O
(	O
_	O
(	O
"Unable to decompress section %s\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
size	int
=	O
size	int
;	O
}	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
debug_displays	O
[	O
debug	O
]	O
.	O
relocate	O
)	O
{	O
if	O
(	O
!	O
apply_relocations	O
(	O
filedata	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
size	int
,	O
&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
reloc_info	O
,	O
&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
num_relocs	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
reloc_info	O
=	O
NULL	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
num_relocs	O
=	O
0	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
unsigned	O
int	O
*	O
section_subset	O
=	O
NULL	O
;	O
bfd_boolean	int
load_debug_section	O
(	O
enum	O
dwarf_section_display_enum	O
debug	O
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
dwarf_section	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
&	O
debug_displays	O
[	O
debug	O
]	O
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
Elf_Internal_Shdr	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
Filedata	O
*	O
filedata	O
=	O
(	O
Filedata	O
*	O
)	O
data	*(void)
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
filedata	O
->	O
string_table	O
==	O
NULL	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_shstrndx	O
!=	O
SHN_UNDEF	O
&&	O
filedata	O
->	O
file_header	O
.	O
e_shstrndx	O
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
strs	O
;	O
strs	O
=	O
filedata	O
->	O
section_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_shstrndx	O
;	O
if	O
(	O
strs	O
!=	O
NULL	O
&&	O
strs	O
->	O
sh_size	O
!=	O
0	int
)	O
{	O
filedata	O
->	O
string_table	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
strs	O
->	O
sh_offset	O
,	O
1	int
,	O
strs	O
->	O
sh_size	O
,	O
_	O
(	O
"string table"	*(char)
)	O
)	O
;	O
filedata	O
->	O
string_table_length	O
=	O
filedata	O
->	O
string_table	O
!=	O
NULL	O
?	O
strs	O
->	O
sh_size	O
:	O
0	int
;	O
}	O
}	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
find_section_in_set	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
uncompressed_name	O
,	O
section_subset	O
)	O
;	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
!=	O
NULL	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
name	*(char)
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
uncompressed_name	O
;	O
else	O
{	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
find_section_in_set	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
compressed_name	O
,	O
section_subset	O
)	O
;	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
!=	O
NULL	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
name	*(char)
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
compressed_name	O
;	O
}	O
if	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
section_subset	O
!=	O
NULL	O
)	O
free_debug_section	O
(	O
debug	O
)	O
;	O
return	O
load_specific_debug_section	O
(	O
debug	O
,	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
data	*(void)
)	O
;	O
}	O
void	O
free_debug_section	O
(	O
enum	O
dwarf_section_display_enum	O
debug	O
)	O
{	O
struct	O
dwarf_section	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
&	O
debug_displays	O
[	O
debug	O
]	O
.	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
==	O
NULL	O
)	O
return	O
;	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
)	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
start	O
=	O
NULL	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
address	*(void)
=	O
0	int
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
size	int
=	O
0	int
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
reloc_info	O
!=	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
reloc_info	O
)	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
reloc_info	O
=	O
NULL	O
;	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
num_relocs	O
=	O
0	int
;	O
}	O
}	O
static	O
bfd_boolean	int
display_debug_section	O
(	O
int	O
shndx	O
,	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
Filedata	O
*	O
filedata	O
)	O
{	O
char	O
*	O
name	*(char)
=	O
SECTION_NAME	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
const	O
char	O
*	O
print_name	O
=	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
bfd_size_type	long
length	O
;	O
bfd_boolean	int
result	O
=	O
TRUE	int
;	O
int	O
i	*(struct)
;	O
length	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
;	O
if	O
(	O
length	O
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nSection '%s' has no debugging data.\n"	*(char)
)	O
,	O
print_name	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_NOBITS	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"section '%s' has the NOBITS type - its contents are unreliable.\n"	*(char)
)	O
,	O
print_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
const_strneq	O
(	O
name	*(char)
,	O
".gnu.linkonce.wi."	*(char)
)	O
)	O
name	*(char)
=	O
".debug_info"	*(char)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
max	O
;	O
i	*(struct)
++	O
)	O
{	O
enum	O
dwarf_section_display_enum	O
id	int
=	O
(	O
enum	O
dwarf_section_display_enum	O
)	O
i	*(struct)
;	O
struct	O
dwarf_section_display	O
*	O
display	O
=	O
debug_displays	O
+	O
i	*(struct)
;	O
struct	O
dwarf_section	O
*	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
&	O
display	O
->	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
if	O
(	O
streq	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
uncompressed_name	O
,	O
name	*(char)
)	O
||	O
(	O
id	int
==	O
line	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
".debug_line."	*(char)
)	O
)	O
||	O
streq	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
compressed_name	O
,	O
name	*(char)
)	O
)	O
{	O
bfd_boolean	int
secondary	O
=	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
!=	O
find_section	O
(	O
filedata	O
,	O
name	*(char)
)	O
)	O
;	O
if	O
(	O
secondary	O
)	O
free_debug_section	O
(	O
id	int
)	O
;	O
if	O
(	O
i	*(struct)
==	O
line	O
&&	O
const_strneq	O
(	O
name	*(char)
,	O
".debug_line."	*(char)
)	O
)	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
name	*(char)
=	O
name	*(char)
;	O
else	O
if	O
(	O
streq	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
uncompressed_name	O
,	O
name	*(char)
)	O
)	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
name	*(char)
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
uncompressed_name	O
;	O
else	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
name	*(char)
=	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
compressed_name	O
;	O
if	O
(	O
load_specific_debug_section	O
(	O
id	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
)	O
)	O
{	O
section_subset	O
=	O
find_cu_tu_set	O
(	O
filedata	O
,	O
shndx	O
)	O
;	O
result	O
&=	O
display	O
->	O
display	O
(	O
sec	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
)	O
;	O
section_subset	O
=	O
NULL	O
;	O
if	O
(	O
secondary	O
||	O
(	O
id	int
!=	O
info	*(void)
&&	O
id	int
!=	O
abbrev	O
)	O
)	O
free_debug_section	O
(	O
id	int
)	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
i	*(struct)
==	O
max	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Unrecognized debug section: %s\n"	*(char)
)	O
,	O
print_name	O
)	O
;	O
result	O
=	O
FALSE	O
;	O
}	O
return	O
result	O
;	O
}	O
static	O
void	O
initialise_dumps_byname	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
struct	O
dump_list_entry	O
*	O
cur	O
;	O
for	O
(	O
cur	O
=	O
dump_sects_byname	O
;	O
cur	O
;	O
cur	O
=	O
cur	O
->	O
next	*(char)
)	O
{	O
unsigned	O
int	O
i	*(struct)
;	O
bfd_boolean	int
any	*(void)
=	O
FALSE	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
)	O
if	O
(	O
streq	O
(	O
SECTION_NAME	O
(	O
filedata	O
->	O
section_headers	O
+	O
i	*(struct)
)	O
,	O
cur	O
->	O
name	*(char)
)	O
)	O
{	O
request_dump_bynumber	O
(	O
filedata	O
,	O
i	*(struct)
,	O
cur	O
->	O
type	enum(int,int,int,int)
)	O
;	O
any	*(void)
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
any	*(void)
)	O
warn	O
(	O
_	O
(	O
"Section '%s' was not dumped because it does not exist!\n"	*(char)
)	O
,	O
cur	O
->	O
name	*(char)
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
process_section_contents	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
unsigned	O
int	O
i	*(struct)
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
if	O
(	O
!	O
do_dump	O
)	O
return	O
TRUE	int
;	O
initialise_dumps_byname	O
(	O
filedata	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
&&	O
i	*(struct)
<	O
filedata	O
->	O
num_dump_sects	O
;	O
i	*(struct)
++	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
)	O
{	O
dump_type	O
dump	O
=	O
filedata	O
->	O
dump_sects	O
[	O
i	*(struct)
]	O
;	O
if	O
(	O
dump	O
&	O
HEX_DUMP	O
)	O
{	O
if	O
(	O
!	O
dump_section_as_bytes	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
,	O
FALSE	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
if	O
(	O
dump	O
&	O
RELOC_DUMP	O
)	O
{	O
if	O
(	O
!	O
dump_section_as_bytes	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
,	O
TRUE	int
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
if	O
(	O
dump	O
&	O
STRING_DUMP	O
)	O
{	O
if	O
(	O
!	O
dump_section_as_strings	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
if	O
(	O
dump	O
&	O
DEBUG_DUMP	O
)	O
{	O
if	O
(	O
!	O
display_debug_section	O
(	O
i	*(struct)
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
if	O
(	O
dump	O
&	O
CTF_DUMP	O
)	O
{	O
if	O
(	O
!	O
dump_section_as_ctf	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
}	O
while	O
(	O
i	*(struct)
<	O
filedata	O
->	O
num_dump_sects	O
)	O
{	O
if	O
(	O
filedata	O
->	O
dump_sects	O
[	O
i	*(struct)
]	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Section %d was not dumped because it does not exist!\n"	*(char)
)	O
,	O
i	*(struct)
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
i	*(struct)
++	O
;	O
}	O
return	O
res	O
;	O
}	O
static	O
void	O
process_mips_fpe_exception	O
(	O
int	O
mask	O
)	O
{	O
if	O
(	O
mask	O
)	O
{	O
bfd_boolean	int
first	O
=	O
TRUE	int
;	O
if	O
(	O
mask	O
&	O
OEX_FPU_INEX	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"INEX"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
OEX_FPU_UFLO	O
)	O
printf	(*(char))->(int)
(	O
"%sUFLO"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
OEX_FPU_OFLO	O
)	O
printf	(*(char))->(int)
(	O
"%sOFLO"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
OEX_FPU_DIV0	O
)	O
printf	(*(char))->(int)
(	O
"%sDIV0"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
OEX_FPU_INVAL	O
)	O
printf	(*(char))->(int)
(	O
"%sINVAL"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
;	O
}	O
else	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"0"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_tag_value	O
(	O
signed	O
int	O
tag	O
,	O
unsigned	O
char	O
*	O
p	*(void)
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
unsigned	O
long	O
val	array(int)
;	O
if	O
(	O
tag	O
>	O
0	int
)	O
printf	(*(char))->(int)
(	O
"  Tag_unknown_%d: "	*(char)
,	O
tag	O
)	O
;	O
if	O
(	O
p	*(void)
>=	O
end	*(*(char))
)	O
{	O
warn	O
(	O
_	O
(	O
"<corrupt tag>\n"	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
tag	O
&	O
1	int
)	O
{	O
size_t	long
maxlen	O
=	O
(	O
end	*(*(char))
-	O
p	*(void)
)	O
-	O
1	int
;	O
putchar	(int)->(int)
(	O
'"'	O
)	O
;	O
if	O
(	O
maxlen	O
>	O
0	int
)	O
{	O
print_symbol	O
(	O
(	O
int	O
)	O
maxlen	O
,	O
(	O
const	O
char	O
*	O
)	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
strnlen	(*(char),long)->(long)
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
maxlen	O
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt string tag>"	*(char)
)	O
)	O
;	O
p	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	*(*(char))
;	O
}	O
printf	(*(char))->(int)
(	O
"\"\n"	*(char)
)	O
;	O
}	O
else	O
{	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"%ld (0x%lx)\n"	*(char)
,	O
val	array(int)
,	O
val	array(int)
)	O
;	O
}	O
assert	O
(	O
p	*(void)
<=	O
end	*(*(char))
)	O
;	O
return	O
p	*(void)
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_arc_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
unsigned	O
int	O
tag	O
;	O
unsigned	O
int	O
val	array(int)
;	O
READ_ULEB	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
tag	O
)	O
{	O
case	O
Tag_ARC_PCS_config	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_PCS_config: "	*(char)
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Absent/Non standard\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Bare metal/mwdt\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Bare metal/newlib\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Linux/uclibc\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Linux/glibc\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Unknown\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
Tag_ARC_CPU_base	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_CPU_base: "	*(char)
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
default	O
:	O
case	O
TAG_CPU_NONE	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Absent\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
TAG_CPU_ARC6xx	O
:	O
printf	(*(char))->(int)
(	O
"ARC6xx\n"	*(char)
)	O
;	O
break	O
;	O
case	O
TAG_CPU_ARC7xx	O
:	O
printf	(*(char))->(int)
(	O
"ARC7xx\n"	*(char)
)	O
;	O
break	O
;	O
case	O
TAG_CPU_ARCEM	O
:	O
printf	(*(char))->(int)
(	O
"ARCEM\n"	*(char)
)	O
;	O
break	O
;	O
case	O
TAG_CPU_ARCHS	O
:	O
printf	(*(char))->(int)
(	O
"ARCHS\n"	*(char)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
Tag_ARC_CPU_variation	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_CPU_variation: "	*(char)
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
default	O
:	O
if	O
(	O
val	array(int)
>	O
0	int
&&	O
val	array(int)
<	O
16	int
)	O
printf	(*(char))->(int)
(	O
"Core%d\n"	*(char)
,	O
val	array(int)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"Unknown\n"	*(char)
)	O
;	O
break	O
;	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Absent\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
Tag_ARC_CPU_name	O
:	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_CPU_name: "	*(char)
)	O
;	O
p	*(void)
=	O
display_tag_value	O
(	O
-	O
1	int
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_rf16	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_ABI_rf16: %s\n"	*(char)
,	O
val	array(int)
?	O
_	O
(	O
"yes"	*(char)
)	O
:	O
_	O
(	O
"no"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_osver	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_ABI_osver: v%d\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_pic	O
:	O
case	O
Tag_ARC_ABI_sda	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
tag	O
==	O
Tag_ARC_ABI_sda	O
?	O
"  Tag_ARC_ABI_sda: "	*(char)
:	O
"  Tag_ARC_ABI_pic: "	*(char)
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Absent\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
"MWDT\n"	*(char)
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
"GNU\n"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Unknown\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
Tag_ARC_ABI_tls	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_ABI_tls: %s\n"	*(char)
,	O
val	array(int)
?	O
"r25"	*(char)
:	O
"none"	*(char)
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_enumsize	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_ABI_enumsize: %s\n"	*(char)
,	O
val	array(int)
?	O
_	O
(	O
"default"	*(char)
)	O
:	O
_	O
(	O
"smallest"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_exceptions	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_ABI_exceptions: %s\n"	*(char)
,	O
val	array(int)
?	O
_	O
(	O
"OPTFP"	*(char)
)	O
:	O
_	O
(	O
"default"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ABI_double_size	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_ABI_double_size: %d\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ISA_config	O
:	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_ISA_config: "	*(char)
)	O
;	O
p	*(void)
=	O
display_tag_value	O
(	O
-	O
1	int
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ISA_apex	O
:	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_ISA_apex: "	*(char)
)	O
;	O
p	*(void)
=	O
display_tag_value	O
(	O
-	O
1	int
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ISA_mpy_option	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_ISA_mpy_option: %d\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
case	O
Tag_ARC_ATR_version	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ARC_ATR_version: %d\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
default	O
:	O
return	O
display_tag_value	O
(	O
tag	O
&	O
1	int
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
typedef	O
struct	O
{	O
unsigned	O
int	O
tag	O
;	O
const	O
char	O
*	O
name	*(char)
;	O
unsigned	O
int	O
type	enum(int,int,int,int)
;	O
const	O
char	O
*	O
*	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
;	O
}	O
arm_attr_public_tag	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_CPU_arch	O
[	O
]	O
=	O
{	O
"Pre-v4"	*(char)
,	O
"v4"	*(char)
,	O
"v4T"	*(char)
,	O
"v5T"	*(char)
,	O
"v5TE"	*(char)
,	O
"v5TEJ"	*(char)
,	O
"v6"	*(char)
,	O
"v6KZ"	*(char)
,	O
"v6T2"	*(char)
,	O
"v6K"	*(char)
,	O
"v7"	*(char)
,	O
"v6-M"	*(char)
,	O
"v6S-M"	*(char)
,	O
"v7E-M"	*(char)
,	O
"v8"	*(char)
,	O
"v8-R"	*(char)
,	O
"v8-M.baseline"	*(char)
,	O
"v8-M.mainline"	*(char)
,	O
""	*(char)
,	O
""	*(char)
,	O
""	*(char)
,	O
"v8.1-M.mainline"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ARM_ISA_use	O
[	O
]	O
=	O
{	O
"No"	*(char)
,	O
"Yes"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_THUMB_ISA_use	O
[	O
]	O
=	O
{	O
"No"	*(char)
,	O
"Thumb-1"	*(char)
,	O
"Thumb-2"	*(char)
,	O
"Yes"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_FP_arch	O
[	O
]	O
=	O
{	O
"No"	*(char)
,	O
"VFPv1"	*(char)
,	O
"VFPv2"	*(char)
,	O
"VFPv3"	*(char)
,	O
"VFPv3-D16"	*(char)
,	O
"VFPv4"	*(char)
,	O
"VFPv4-D16"	*(char)
,	O
"FP for ARMv8"	*(char)
,	O
"FPv5/FP-D16 for ARMv8"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_WMMX_arch	O
[	O
]	O
=	O
{	O
"No"	*(char)
,	O
"WMMXv1"	*(char)
,	O
"WMMXv2"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_Advanced_SIMD_arch	O
[	O
]	O
=	O
{	O
"No"	*(char)
,	O
"NEONv1"	*(char)
,	O
"NEONv1 with Fused-MAC"	*(char)
,	O
"NEON for ARMv8"	*(char)
,	O
"NEON for ARMv8.1"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_PCS_config	O
[	O
]	O
=	O
{	O
"None"	*(char)
,	O
"Bare platform"	*(char)
,	O
"Linux application"	*(char)
,	O
"Linux DSO"	*(char)
,	O
"PalmOS 2004"	*(char)
,	O
"PalmOS (reserved)"	*(char)
,	O
"SymbianOS 2004"	*(char)
,	O
"SymbianOS (reserved)"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_PCS_R9_use	O
[	O
]	O
=	O
{	O
"V6"	*(char)
,	O
"SB"	*(char)
,	O
"TLS"	*(char)
,	O
"Unused"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_PCS_RW_data	O
[	O
]	O
=	O
{	O
"Absolute"	*(char)
,	O
"PC-relative"	*(char)
,	O
"SB-relative"	*(char)
,	O
"None"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_PCS_RO_data	O
[	O
]	O
=	O
{	O
"Absolute"	*(char)
,	O
"PC-relative"	*(char)
,	O
"None"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_PCS_GOT_use	O
[	O
]	O
=	O
{	O
"None"	*(char)
,	O
"direct"	*(char)
,	O
"GOT-indirect"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_PCS_wchar_t	O
[	O
]	O
=	O
{	O
"None"	*(char)
,	O
"??? 1"	*(char)
,	O
"2"	*(char)
,	O
"??? 3"	*(char)
,	O
"4"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_rounding	O
[	O
]	O
=	O
{	O
"Unused"	*(char)
,	O
"Needed"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_denormal	O
[	O
]	O
=	O
{	O
"Unused"	*(char)
,	O
"Needed"	*(char)
,	O
"Sign only"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_exceptions	O
[	O
]	O
=	O
{	O
"Unused"	*(char)
,	O
"Needed"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_user_exceptions	O
[	O
]	O
=	O
{	O
"Unused"	*(char)
,	O
"Needed"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_number_model	O
[	O
]	O
=	O
{	O
"Unused"	*(char)
,	O
"Finite"	*(char)
,	O
"RTABI"	*(char)
,	O
"IEEE 754"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_enum_size	O
[	O
]	O
=	O
{	O
"Unused"	*(char)
,	O
"small"	*(char)
,	O
"int"	*(char)
,	O
"forced to int"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_HardFP_use	O
[	O
]	O
=	O
{	O
"As Tag_FP_arch"	*(char)
,	O
"SP only"	*(char)
,	O
"Reserved"	*(char)
,	O
"Deprecated"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_VFP_args	O
[	O
]	O
=	O
{	O
"AAPCS"	*(char)
,	O
"VFP registers"	*(char)
,	O
"custom"	*(char)
,	O
"compatible"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_WMMX_args	O
[	O
]	O
=	O
{	O
"AAPCS"	*(char)
,	O
"WMMX registers"	*(char)
,	O
"custom"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_optimization_goals	O
[	O
]	O
=	O
{	O
"None"	*(char)
,	O
"Prefer Speed"	*(char)
,	O
"Aggressive Speed"	*(char)
,	O
"Prefer Size"	*(char)
,	O
"Aggressive Size"	*(char)
,	O
"Prefer Debug"	*(char)
,	O
"Aggressive Debug"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_optimization_goals	O
[	O
]	O
=	O
{	O
"None"	*(char)
,	O
"Prefer Speed"	*(char)
,	O
"Aggressive Speed"	*(char)
,	O
"Prefer Size"	*(char)
,	O
"Aggressive Size"	*(char)
,	O
"Prefer Accuracy"	*(char)
,	O
"Aggressive Accuracy"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_CPU_unaligned_access	O
[	O
]	O
=	O
{	O
"None"	*(char)
,	O
"v6"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_FP_HP_extension	O
[	O
]	O
=	O
{	O
"Not Allowed"	*(char)
,	O
"Allowed"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_ABI_FP_16bit_format	O
[	O
]	O
=	O
{	O
"None"	*(char)
,	O
"IEEE 754"	*(char)
,	O
"Alternative Format"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_DSP_extension	O
[	O
]	O
=	O
{	O
"Follow architecture"	*(char)
,	O
"Allowed"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_MPextension_use	O
[	O
]	O
=	O
{	O
"Not Allowed"	*(char)
,	O
"Allowed"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_DIV_use	O
[	O
]	O
=	O
{	O
"Allowed in Thumb-ISA, v7-R or v7-M"	*(char)
,	O
"Not allowed"	*(char)
,	O
"Allowed in v7-A with integer division extension"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_T2EE_use	O
[	O
]	O
=	O
{	O
"Not Allowed"	*(char)
,	O
"Allowed"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_Virtualization_use	O
[	O
]	O
=	O
{	O
"Not Allowed"	*(char)
,	O
"TrustZone"	*(char)
,	O
"Virtualization Extensions"	*(char)
,	O
"TrustZone and Virtualization Extensions"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_MPextension_use_legacy	O
[	O
]	O
=	O
{	O
"Not Allowed"	*(char)
,	O
"Allowed"	*(char)
}	O
;	O
static	O
const	O
char	O
*	O
arm_attr_tag_MVE_arch	O
[	O
]	O
=	O
{	O
"No MVE"	*(char)
,	O
"MVE Integer only"	*(char)
,	O
"MVE Integer and FP"	*(char)
}	O
;	O
static	O
arm_attr_public_tag	O
arm_attr_public_tags	O
[	O
]	O
=	O
{	O
{	O
4	int
,	O
"CPU_raw_name"	*(char)
,	O
1	int
,	O
NULL	O
}	O
,	O
{	O
5	int
,	O
"CPU_name"	*(char)
,	O
1	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
6	int
,	O
CPU_arch	O
)	O
,	O
{	O
7	int
,	O
"CPU_arch_profile"	*(char)
,	O
0	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
8	int
,	O
ARM_ISA_use	O
)	O
,	O
LOOKUP	O
(	O
9	int
,	O
THUMB_ISA_use	O
)	O
,	O
LOOKUP	O
(	O
10	int
,	O
FP_arch	O
)	O
,	O
LOOKUP	O
(	O
11	int
,	O
WMMX_arch	O
)	O
,	O
LOOKUP	O
(	O
12	int
,	O
Advanced_SIMD_arch	O
)	O
,	O
LOOKUP	O
(	O
13	int
,	O
PCS_config	O
)	O
,	O
LOOKUP	O
(	O
14	int
,	O
ABI_PCS_R9_use	O
)	O
,	O
LOOKUP	O
(	O
15	int
,	O
ABI_PCS_RW_data	O
)	O
,	O
LOOKUP	O
(	O
16	int
,	O
ABI_PCS_RO_data	O
)	O
,	O
LOOKUP	O
(	O
17	int
,	O
ABI_PCS_GOT_use	O
)	O
,	O
LOOKUP	O
(	O
18	int
,	O
ABI_PCS_wchar_t	O
)	O
,	O
LOOKUP	O
(	O
19	int
,	O
ABI_FP_rounding	O
)	O
,	O
LOOKUP	O
(	O
20	int
,	O
ABI_FP_denormal	O
)	O
,	O
LOOKUP	O
(	O
21	int
,	O
ABI_FP_exceptions	O
)	O
,	O
LOOKUP	O
(	O
22	int
,	O
ABI_FP_user_exceptions	O
)	O
,	O
LOOKUP	O
(	O
23	int
,	O
ABI_FP_number_model	O
)	O
,	O
{	O
24	int
,	O
"ABI_align_needed"	*(char)
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
25	int
,	O
"ABI_align_preserved"	*(char)
,	O
0	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
26	int
,	O
ABI_enum_size	O
)	O
,	O
LOOKUP	O
(	O
27	int
,	O
ABI_HardFP_use	O
)	O
,	O
LOOKUP	O
(	O
28	int
,	O
ABI_VFP_args	O
)	O
,	O
LOOKUP	O
(	O
29	int
,	O
ABI_WMMX_args	O
)	O
,	O
LOOKUP	O
(	O
30	int
,	O
ABI_optimization_goals	O
)	O
,	O
LOOKUP	O
(	O
31	int
,	O
ABI_FP_optimization_goals	O
)	O
,	O
{	O
32	int
,	O
"compatibility"	*(char)
,	O
0	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
34	int
,	O
CPU_unaligned_access	O
)	O
,	O
LOOKUP	O
(	O
36	int
,	O
FP_HP_extension	O
)	O
,	O
LOOKUP	O
(	O
38	int
,	O
ABI_FP_16bit_format	O
)	O
,	O
LOOKUP	O
(	O
42	int
,	O
MPextension_use	O
)	O
,	O
LOOKUP	O
(	O
44	int
,	O
DIV_use	O
)	O
,	O
LOOKUP	O
(	O
46	int
,	O
DSP_extension	O
)	O
,	O
LOOKUP	O
(	O
48	int
,	O
MVE_arch	O
)	O
,	O
{	O
64	int
,	O
"nodefaults"	*(char)
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
65	int
,	O
"also_compatible_with"	*(char)
,	O
0	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
66	int
,	O
T2EE_use	O
)	O
,	O
{	O
67	int
,	O
"conformance"	*(char)
,	O
1	int
,	O
NULL	O
}	O
,	O
LOOKUP	O
(	O
68	int
,	O
Virtualization_use	O
)	O
,	O
LOOKUP	O
(	O
70	int
,	O
MPextension_use_legacy	O
)	O
}	O
;	O
static	O
unsigned	O
char	O
*	O
display_arm_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
unsigned	O
int	O
tag	O
;	O
unsigned	O
int	O
val	array(int)
;	O
arm_attr_public_tag	O
*	O
attr	O
;	O
unsigned	O
i	*(struct)
;	O
unsigned	O
int	O
type	enum(int,int,int,int)
;	O
READ_ULEB	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
attr	O
=	O
NULL	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
ARRAY_SIZE	O
(	O
arm_attr_public_tags	O
)	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
arm_attr_public_tags	O
[	O
i	*(struct)
]	O
.	O
tag	O
==	O
tag	O
)	O
{	O
attr	O
=	O
&	O
arm_attr_public_tags	O
[	O
i	*(struct)
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
attr	O
)	O
{	O
printf	(*(char))->(int)
(	O
"  Tag_%s: "	*(char)
,	O
attr	O
->	O
name	*(char)
)	O
;	O
switch	O
(	O
attr	O
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
0	int
:	O
switch	O
(	O
tag	O
)	O
{	O
case	O
7	int
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"None\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Application\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Realtime\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Microcontroller\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Application or Realtime\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
24	int
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"None\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"8-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"4-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	(*(char))->(int)
(	O
"??? 3\n"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
val	array(int)
<=	O
12	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"8-byte and up to %d-byte extended\n"	*(char)
)	O
,	O
1	int
<<	O
val	array(int)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
25	int
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"None\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"8-byte, except leaf SP\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"8-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	(*(char))->(int)
(	O
"??? 3\n"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
val	array(int)
<=	O
12	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"8-byte and up to %d-byte extended\n"	*(char)
)	O
,	O
1	int
<<	O
val	array(int)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
32	int
:	O
{	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"flag = %d, vendor = "	*(char)
)	O
,	O
val	array(int)
)	O
;	O
if	O
(	O
p	*(void)
<	O
end	*(*(char))
-	O
1	int
)	O
{	O
size_t	long
maxlen	O
=	O
(	O
end	*(*(char))
-	O
p	*(void)
)	O
-	O
1	int
;	O
print_symbol	O
(	O
(	O
int	O
)	O
maxlen	O
,	O
(	O
const	O
char	O
*	O
)	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
strnlen	(*(char),long)->(long)
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
maxlen	O
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
p	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	*(*(char))
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
break	O
;	O
case	O
64	int
:	O
if	O
(	O
p	*(void)
<	O
end	*(*(char))
)	O
p	*(void)
++	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"True\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
65	int
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
if	O
(	O
val	array(int)
==	O
6	int
)	O
{	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
if	O
(	O
(	O
unsigned	O
int	O
)	O
val	array(int)
>=	O
ARRAY_SIZE	O
(	O
arm_attr_tag_CPU_arch	O
)	O
)	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
arm_attr_tag_CPU_arch	O
[	O
val	array(int)
]	O
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
"???\n"	*(char)
)	O
;	O
while	O
(	O
p	*(void)
<	O
end	*(*(char))
&&	O
*	O
(	O
p	*(void)
++	O
)	O
!=	O
'\0'	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<unknown: %d>\n"	*(char)
)	O
,	O
tag	O
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
case	O
1	int
:	O
return	O
display_tag_value	O
(	O
-	O
1	int
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
case	O
2	int
:	O
return	O
display_tag_value	O
(	O
0	int
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
default	O
:	O
assert	O
(	O
attr	O
->	O
type	enum(int,int,int,int)
&	O
0x80	int
)	O
;	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
type	enum(int,int,int,int)
=	O
attr	O
->	O
type	enum(int,int,int,int)
&	O
0x7f	int
;	O
if	O
(	O
val	array(int)
>=	O
type	enum(int,int,int,int)
)	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%s\n"	*(char)
,	O
attr	O
->	O
table	*(*(struct(*(struct(*`,*`,long)),*(char),long)))
[	O
val	array(int)
]	O
)	O
;	O
return	O
p	*(void)
;	O
}	O
}	O
return	O
display_tag_value	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_gnu_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
unsigned	O
char	O
*	O
(	O
*	O
display_proc_gnu_attribute	O
)	O
(	O
unsigned	O
char	O
*	O
,	O
unsigned	O
int	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
)	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
unsigned	O
int	O
tag	O
;	O
unsigned	O
int	O
val	array(int)
;	O
READ_ULEB	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
if	O
(	O
tag	O
==	O
32	int
)	O
{	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"flag = %d, vendor = "	*(char)
)	O
,	O
val	array(int)
)	O
;	O
if	O
(	O
p	*(void)
==	O
end	*(*(char))
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>\n"	*(char)
)	O
)	O
;	O
warn	O
(	O
_	O
(	O
"corrupt vendor attribute\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
p	*(void)
<	O
end	*(*(char))
-	O
1	int
)	O
{	O
size_t	long
maxlen	O
=	O
(	O
end	*(*(char))
-	O
p	*(void)
)	O
-	O
1	int
;	O
print_symbol	O
(	O
(	O
int	O
)	O
maxlen	O
,	O
(	O
const	O
char	O
*	O
)	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
strnlen	(*(char),long)->(long)
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
maxlen	O
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
p	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	*(*(char))
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
if	O
(	O
(	O
tag	O
&	O
2	int
)	O
==	O
0	int
&&	O
display_proc_gnu_attribute	O
)	O
return	O
display_proc_gnu_attribute	O
(	O
p	*(void)
,	O
tag	O
,	O
end	*(*(char))
)	O
;	O
return	O
display_tag_value	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_power_gnu_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
unsigned	O
int	O
tag	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
unsigned	O
int	O
val	array(int)
;	O
if	O
(	O
tag	O
==	O
Tag_GNU_Power_ABI_FP	O
)	O
{	O
printf	(*(char))->(int)
(	O
"  Tag_GNU_Power_ABI_FP: "	*(char)
)	O
;	O
if	O
(	O
p	*(void)
==	O
end	*(*(char))
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>\n"	*(char)
)	O
)	O
;	O
return	O
p	*(void)
;	O
}	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
if	O
(	O
val	array(int)
>	O
15	int
)	O
printf	(*(char))->(int)
(	O
"(%#x), "	*(char)
,	O
val	array(int)
)	O
;	O
switch	O
(	O
val	array(int)
&	O
3	int
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"unspecified hard/soft float, "	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"hard float, "	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"soft float, "	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"single-precision hard float, "	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
val	array(int)
&	O
0xC	int
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"unspecified long double\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"128-bit IBM long double\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
8	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"64-bit long double\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
12	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"128-bit IEEE long double\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
if	O
(	O
tag	O
==	O
Tag_GNU_Power_ABI_Vector	O
)	O
{	O
printf	(*(char))->(int)
(	O
"  Tag_GNU_Power_ABI_Vector: "	*(char)
)	O
;	O
if	O
(	O
p	*(void)
==	O
end	*(*(char))
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>\n"	*(char)
)	O
)	O
;	O
return	O
p	*(void)
;	O
}	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
if	O
(	O
val	array(int)
>	O
3	int
)	O
printf	(*(char))->(int)
(	O
"(%#x), "	*(char)
,	O
val	array(int)
)	O
;	O
switch	O
(	O
val	array(int)
&	O
3	int
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"unspecified\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"generic\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
"AltiVec\n"	*(char)
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	(*(char))->(int)
(	O
"SPE\n"	*(char)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
if	O
(	O
tag	O
==	O
Tag_GNU_Power_ABI_Struct_Return	O
)	O
{	O
printf	(*(char))->(int)
(	O
"  Tag_GNU_Power_ABI_Struct_Return: "	*(char)
)	O
;	O
if	O
(	O
p	*(void)
==	O
end	*(*(char))
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>\n"	*(char)
)	O
)	O
;	O
return	O
p	*(void)
;	O
}	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
if	O
(	O
val	array(int)
>	O
2	int
)	O
printf	(*(char))->(int)
(	O
"(%#x), "	*(char)
,	O
val	array(int)
)	O
;	O
switch	O
(	O
val	array(int)
&	O
3	int
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"unspecified\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
"r3/r4\n"	*(char)
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"memory\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	(*(char))->(int)
(	O
"???\n"	*(char)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
return	O
display_tag_value	O
(	O
tag	O
&	O
1	int
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_s390_gnu_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
unsigned	O
int	O
tag	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
unsigned	O
int	O
val	array(int)
;	O
if	O
(	O
tag	O
==	O
Tag_GNU_S390_ABI_Vector	O
)	O
{	O
printf	(*(char))->(int)
(	O
"  Tag_GNU_S390_ABI_Vector: "	*(char)
)	O
;	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"any\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"software\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"hardware\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
return	O
display_tag_value	O
(	O
tag	O
&	O
1	int
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
}	O
static	O
void	O
display_sparc_hwcaps	O
(	O
unsigned	O
int	O
mask	O
)	O
{	O
if	O
(	O
mask	O
)	O
{	O
bfd_boolean	int
first	O
=	O
TRUE	int
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_MUL32	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"mul32"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_DIV32	O
)	O
printf	(*(char))->(int)
(	O
"%sdiv32"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_FSMULD	O
)	O
printf	(*(char))->(int)
(	O
"%sfsmuld"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_V8PLUS	O
)	O
printf	(*(char))->(int)
(	O
"%sv8plus"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_POPC	O
)	O
printf	(*(char))->(int)
(	O
"%spopc"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_VIS	O
)	O
printf	(*(char))->(int)
(	O
"%svis"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_VIS2	O
)	O
printf	(*(char))->(int)
(	O
"%svis2"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_ASI_BLK_INIT	O
)	O
printf	(*(char))->(int)
(	O
"%sASIBlkInit"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_FMAF	O
)	O
printf	(*(char))->(int)
(	O
"%sfmaf"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_VIS3	O
)	O
printf	(*(char))->(int)
(	O
"%svis3"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_HPC	O
)	O
printf	(*(char))->(int)
(	O
"%shpc"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_RANDOM	O
)	O
printf	(*(char))->(int)
(	O
"%srandom"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_TRANS	O
)	O
printf	(*(char))->(int)
(	O
"%strans"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_FJFMAU	O
)	O
printf	(*(char))->(int)
(	O
"%sfjfmau"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_IMA	O
)	O
printf	(*(char))->(int)
(	O
"%sima"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP_ASI_CACHE_SPARING	O
)	O
printf	(*(char))->(int)
(	O
"%scspare"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
}	O
else	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'0'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
display_sparc_hwcaps2	O
(	O
unsigned	O
int	O
mask	O
)	O
{	O
if	O
(	O
mask	O
)	O
{	O
bfd_boolean	int
first	O
=	O
TRUE	int
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP2_FJATHPLUS	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"fjathplus"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP2_VIS3B	O
)	O
printf	(*(char))->(int)
(	O
"%svis3b"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP2_ADP	O
)	O
printf	(*(char))->(int)
(	O
"%sadp"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP2_SPARC5	O
)	O
printf	(*(char))->(int)
(	O
"%ssparc5"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP2_MWAIT	O
)	O
printf	(*(char))->(int)
(	O
"%smwait"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP2_XMPMUL	O
)	O
printf	(*(char))->(int)
(	O
"%sxmpmul"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP2_XMONT	O
)	O
printf	(*(char))->(int)
(	O
"%sxmont2"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP2_NSEC	O
)	O
printf	(*(char))->(int)
(	O
"%snsec"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP2_FJATHHPC	O
)	O
printf	(*(char))->(int)
(	O
"%sfjathhpc"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP2_FJDES	O
)	O
printf	(*(char))->(int)
(	O
"%sfjdes"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
if	O
(	O
mask	O
&	O
ELF_SPARC_HWCAP2_FJAES	O
)	O
printf	(*(char))->(int)
(	O
"%sfjaes"	*(char)
,	O
first	O
?	O
""	*(char)
:	O
"|"	*(char)
)	O
,	O
first	O
=	O
FALSE	O
;	O
}	O
else	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'0'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_sparc_gnu_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
unsigned	O
int	O
tag	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
unsigned	O
int	O
val	array(int)
;	O
if	O
(	O
tag	O
==	O
Tag_GNU_Sparc_HWCAPS	O
)	O
{	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_GNU_Sparc_HWCAPS: "	*(char)
)	O
;	O
display_sparc_hwcaps	O
(	O
val	array(int)
)	O
;	O
return	O
p	*(void)
;	O
}	O
if	O
(	O
tag	O
==	O
Tag_GNU_Sparc_HWCAPS2	O
)	O
{	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_GNU_Sparc_HWCAPS2: "	*(char)
)	O
;	O
display_sparc_hwcaps2	O
(	O
val	array(int)
)	O
;	O
return	O
p	*(void)
;	O
}	O
return	O
display_tag_value	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
}	O
static	O
void	O
print_mips_fp_abi_value	O
(	O
unsigned	O
int	O
val	array(int)
)	O
{	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
Val_GNU_MIPS_ABI_FP_ANY	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Hard or soft float\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_DOUBLE	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Hard float (double precision)\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_SINGLE	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Hard float (single precision)\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_SOFT	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Soft float\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_OLD_64	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Hard float (MIPS32r2 64-bit FPU 12 callee-saved)\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_XX	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Hard float (32-bit CPU, Any FPU)\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_64	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Hard float (32-bit CPU, 64-bit FPU)\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_64A	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Hard float compat (32-bit CPU, 64-bit FPU)\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_FP_NAN2008	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"NaN 2008 compatibility\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
}	O
static	O
unsigned	O
char	O
*	O
display_mips_gnu_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
unsigned	O
int	O
tag	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
if	O
(	O
tag	O
==	O
Tag_GNU_MIPS_ABI_FP	O
)	O
{	O
unsigned	O
int	O
val	array(int)
;	O
printf	(*(char))->(int)
(	O
"  Tag_GNU_MIPS_ABI_FP: "	*(char)
)	O
;	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
print_mips_fp_abi_value	O
(	O
val	array(int)
)	O
;	O
return	O
p	*(void)
;	O
}	O
if	O
(	O
tag	O
==	O
Tag_GNU_MIPS_ABI_MSA	O
)	O
{	O
unsigned	O
int	O
val	array(int)
;	O
printf	(*(char))->(int)
(	O
"  Tag_GNU_MIPS_ABI_MSA: "	*(char)
)	O
;	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
Val_GNU_MIPS_ABI_MSA_ANY	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Any MSA or not\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MIPS_ABI_MSA_128	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"128-bit MSA\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
return	O
display_tag_value	O
(	O
tag	O
&	O
1	int
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_tic6x_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
unsigned	O
int	O
tag	O
;	O
unsigned	O
int	O
val	array(int)
;	O
READ_ULEB	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
tag	O
)	O
{	O
case	O
Tag_ISA	O
:	O
printf	(*(char))->(int)
(	O
"  Tag_ISA: "	*(char)
)	O
;	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
C6XABI_Tag_ISA_none	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"None\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C62X	O
:	O
printf	(*(char))->(int)
(	O
"C62x\n"	*(char)
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C67X	O
:	O
printf	(*(char))->(int)
(	O
"C67x\n"	*(char)
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C67XP	O
:	O
printf	(*(char))->(int)
(	O
"C67x+\n"	*(char)
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C64X	O
:	O
printf	(*(char))->(int)
(	O
"C64x\n"	*(char)
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C64XP	O
:	O
printf	(*(char))->(int)
(	O
"C64x+\n"	*(char)
)	O
;	O
break	O
;	O
case	O
C6XABI_Tag_ISA_C674X	O
:	O
printf	(*(char))->(int)
(	O
"C674x\n"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
case	O
Tag_ABI_wchar_t	O
:	O
printf	(*(char))->(int)
(	O
"  Tag_ABI_wchar_t: "	*(char)
)	O
;	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Not used\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"2 bytes\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"4 bytes\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
case	O
Tag_ABI_stack_align_needed	O
:	O
printf	(*(char))->(int)
(	O
"  Tag_ABI_stack_align_needed: "	*(char)
)	O
;	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"8-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"16-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
case	O
Tag_ABI_stack_align_preserved	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ABI_stack_align_preserved: "	*(char)
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"8-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"16-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
case	O
Tag_ABI_DSBT	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ABI_DSBT: "	*(char)
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"DSBT addressing not used\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"DSBT addressing used\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
case	O
Tag_ABI_PID	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ABI_PID: "	*(char)
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Data addressing position-dependent\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Data addressing position-independent, GOT near DP\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Data addressing position-independent, GOT far from DP\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
case	O
Tag_ABI_PIC	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ABI_PIC: "	*(char)
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Code addressing position-dependent\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Code addressing position-independent\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
case	O
Tag_ABI_array_object_alignment	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ABI_array_object_alignment: "	*(char)
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"8-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"4-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"16-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
case	O
Tag_ABI_array_object_align_expected	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ABI_array_object_align_expected: "	*(char)
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"8-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"4-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"16-byte\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
return	O
p	*(void)
;	O
case	O
Tag_ABI_compatibility	O
:	O
{	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"  Tag_ABI_compatibility: "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"flag = %d, vendor = "	*(char)
)	O
,	O
val	array(int)
)	O
;	O
if	O
(	O
p	*(void)
<	O
end	*(*(char))
-	O
1	int
)	O
{	O
size_t	long
maxlen	O
=	O
(	O
end	*(*(char))
-	O
p	*(void)
)	O
-	O
1	int
;	O
print_symbol	O
(	O
(	O
int	O
)	O
maxlen	O
,	O
(	O
const	O
char	O
*	O
)	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
strnlen	(*(char),long)->(long)
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
maxlen	O
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
p	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	*(*(char))
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
return	O
p	*(void)
;	O
}	O
case	O
Tag_ABI_conformance	O
:	O
{	O
printf	(*(char))->(int)
(	O
"  Tag_ABI_conformance: \""	*(char)
)	O
;	O
if	O
(	O
p	*(void)
<	O
end	*(*(char))
-	O
1	int
)	O
{	O
size_t	long
maxlen	O
=	O
(	O
end	*(*(char))
-	O
p	*(void)
)	O
-	O
1	int
;	O
print_symbol	O
(	O
(	O
int	O
)	O
maxlen	O
,	O
(	O
const	O
char	O
*	O
)	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
strnlen	(*(char),long)->(long)
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
maxlen	O
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
p	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	*(*(char))
;	O
}	O
printf	(*(char))->(int)
(	O
"\"\n"	*(char)
)	O
;	O
return	O
p	*(void)
;	O
}	O
}	O
return	O
display_tag_value	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
}	O
static	O
void	O
display_raw_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
unsigned	O
char	O
const	O
*	O
const	O
end	*(*(char))
)	O
{	O
unsigned	O
long	O
addr	*(void)
=	O
0	int
;	O
size_t	long
bytes	O
=	O
end	*(*(char))
-	O
p	*(void)
;	O
assert	O
(	O
end	*(*(char))
>=	O
p	*(void)
)	O
;	O
while	O
(	O
bytes	O
)	O
{	O
int	O
j	O
;	O
int	O
k	O
;	O
int	O
lbytes	O
=	O
(	O
bytes	O
>	O
16	int
?	O
16	int
:	O
bytes	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  0x%8.8lx "	*(char)
,	O
addr	*(void)
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
16	int
;	O
j	O
++	O
)	O
{	O
if	O
(	O
j	O
<	O
lbytes	O
)	O
printf	(*(char))->(int)
(	O
"%2.2x"	*(char)
,	O
p	*(void)
[	O
j	O
]	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"  "	*(char)
)	O
;	O
if	O
(	O
(	O
j	O
&	O
3	int
)	O
==	O
3	int
)	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
}	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
lbytes	O
;	O
j	O
++	O
)	O
{	O
k	O
=	O
p	*(void)
[	O
j	O
]	O
;	O
if	O
(	O
k	O
>=	O
' '	O
&&	O
k	O
<	O
0x7f	int
)	O
printf	(*(char))->(int)
(	O
"%c"	*(char)
,	O
k	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"."	*(char)
)	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
p	*(void)
+=	O
lbytes	O
;	O
bytes	O
-=	O
lbytes	O
;	O
addr	*(void)
+=	O
lbytes	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_msp430x_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
unsigned	O
int	O
val	array(int)
;	O
unsigned	O
int	O
tag	O
;	O
READ_ULEB	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
tag	O
)	O
{	O
case	O
OFBA_MSPABI_Tag_ISA	O
:	O
printf	(*(char))->(int)
(	O
"  Tag_ISA: "	*(char)
)	O
;	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"None\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"MSP430\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"MSP430X\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
OFBA_MSPABI_Tag_Code_Model	O
:	O
printf	(*(char))->(int)
(	O
"  Tag_Code_Model: "	*(char)
)	O
;	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"None\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Small\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Large\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
OFBA_MSPABI_Tag_Data_Model	O
:	O
printf	(*(char))->(int)
(	O
"  Tag_Data_Model: "	*(char)
)	O
;	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"None\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Small\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Large\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Restricted Large\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%d)\n"	*(char)
,	O
val	array(int)
)	O
;	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  <unknown tag %d>: "	*(char)
)	O
,	O
tag	O
)	O
;	O
if	O
(	O
tag	O
&	O
1	int
)	O
{	O
putchar	(int)->(int)
(	O
'"'	O
)	O
;	O
if	O
(	O
p	*(void)
<	O
end	*(*(char))
-	O
1	int
)	O
{	O
size_t	long
maxlen	O
=	O
(	O
end	*(*(char))
-	O
p	*(void)
)	O
-	O
1	int
;	O
print_symbol	O
(	O
(	O
int	O
)	O
maxlen	O
,	O
(	O
const	O
char	O
*	O
)	O
p	*(void)
)	O
;	O
p	*(void)
+=	O
strnlen	(*(char),long)->(long)
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
maxlen	O
)	O
+	O
1	int
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
p	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
end	*(*(char))
;	O
}	O
printf	(*(char))->(int)
(	O
"\"\n"	*(char)
)	O
;	O
}	O
else	O
{	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
"%d (0x%x)\n"	*(char)
,	O
val	array(int)
,	O
val	array(int)
)	O
;	O
}	O
break	O
;	O
}	O
assert	O
(	O
p	*(void)
<=	O
end	*(*(char))
)	O
;	O
return	O
p	*(void)
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_msp430_gnu_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
unsigned	O
int	O
tag	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
if	O
(	O
tag	O
==	O
Tag_GNU_MSP430_Data_Region	O
)	O
{	O
unsigned	O
int	O
val	array(int)
;	O
printf	(*(char))->(int)
(	O
"  Tag_GNU_MSP430_Data_Region: "	*(char)
)	O
;	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
Val_GNU_MSP430_Data_Region_Any	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Any Region\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
Val_GNU_MSP430_Data_Region_Lower	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Lower Region Only\n"	*(char)
)	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"??? (%u)\n"	*(char)
,	O
val	array(int)
)	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
return	O
display_tag_value	O
(	O
tag	O
&	O
1	int
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
}	O
struct	O
riscv_attr_tag_t	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
unsigned	O
int	O
tag	O
;	O
}	O
;	O
static	O
struct	O
riscv_attr_tag_t	O
riscv_attr_tag	O
[	O
]	O
=	O
{	O
T	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
,	O
T	O
(	O
priv_spec	O
)	O
,	O
T	O
(	O
priv_spec_minor	O
)	O
,	O
T	O
(	O
priv_spec_revision	O
)	O
,	O
T	O
(	O
unaligned_access	O
)	O
,	O
T	O
(	O
stack_align	O
)	O
,	O
}	O
;	O
static	O
unsigned	O
char	O
*	O
display_riscv_attribute	O
(	O
unsigned	O
char	O
*	O
p	*(void)
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
unsigned	O
int	O
val	array(int)
;	O
unsigned	O
int	O
tag	O
;	O
struct	O
riscv_attr_tag_t	O
*	O
attr	O
=	O
NULL	O
;	O
unsigned	O
i	*(struct)
;	O
READ_ULEB	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
ARRAY_SIZE	O
(	O
riscv_attr_tag	O
)	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
riscv_attr_tag	O
[	O
i	*(struct)
]	O
.	O
tag	O
==	O
tag	O
)	O
{	O
attr	O
=	O
&	O
riscv_attr_tag	O
[	O
i	*(struct)
]	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
attr	O
)	O
printf	(*(char))->(int)
(	O
"  %s: "	*(char)
,	O
attr	O
->	O
name	*(char)
)	O
;	O
else	O
return	O
display_tag_value	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
tag	O
)	O
{	O
case	O
Tag_RISCV_priv_spec	O
:	O
case	O
Tag_RISCV_priv_spec_minor	O
:	O
case	O
Tag_RISCV_priv_spec_revision	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"%u\n"	*(char)
)	O
,	O
val	array(int)
)	O
;	O
break	O
;	O
case	O
Tag_RISCV_unaligned_access	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"No unaligned access\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Unaligned access\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
Tag_RISCV_stack_align	O
:	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"%u-bytes\n"	*(char)
)	O
,	O
val	array(int)
)	O
;	O
break	O
;	O
case	O
Tag_RISCV_arch	O
:	O
p	*(void)
=	O
display_tag_value	O
(	O
-	O
1	int
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
break	O
;	O
default	O
:	O
return	O
display_tag_value	O
(	O
tag	O
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
}	O
return	O
p	*(void)
;	O
}	O
static	O
bfd_boolean	int
process_attributes	O
(	O
Filedata	O
*	O
filedata	O
,	O
const	O
char	O
*	O
public_name	O
,	O
unsigned	O
int	O
proc_type	O
,	O
unsigned	O
char	O
*	O
(	O
*	O
display_pub_attribute	O
)	O
(	O
unsigned	O
char	O
*	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
)	O
,	O
unsigned	O
char	O
*	O
(	O
*	O
display_proc_gnu_attribute	O
)	O
(	O
unsigned	O
char	O
*	O
,	O
unsigned	O
int	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
)	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
sect	*(struct)
;	O
unsigned	O
i	*(struct)
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
sect	*(struct)
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
,	O
sect	*(struct)
++	O
)	O
{	O
unsigned	O
char	O
*	O
contents	*(char)
;	O
unsigned	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
sect	*(struct)
->	O
sh_type	O
!=	O
proc_type	O
&&	O
sect	*(struct)
->	O
sh_type	O
!=	O
SHT_GNU_ATTRIBUTES	O
)	O
continue	O
;	O
contents	*(char)
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
sect	*(struct)
->	O
sh_offset	O
,	O
1	int
,	O
sect	*(struct)
->	O
sh_size	O
,	O
_	O
(	O
"attributes"	*(char)
)	O
)	O
;	O
if	O
(	O
contents	*(char)
==	O
NULL	O
)	O
{	O
res	O
=	O
FALSE	O
;	O
continue	O
;	O
}	O
p	*(void)
=	O
contents	*(char)
;	O
if	O
(	O
*	O
p	*(void)
!=	O
'A'	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Unknown attributes version '%c'(%d) - expecting 'A'\n"	*(char)
)	O
,	O
*	O
p	*(void)
,	O
*	O
p	*(void)
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
else	O
{	O
bfd_vma	long
section_len	O
;	O
section_len	O
=	O
sect	*(struct)
->	O
sh_size	O
-	O
1	int
;	O
p	*(void)
++	O
;	O
while	O
(	O
section_len	O
>	O
0	int
)	O
{	O
bfd_vma	long
attr_len	O
;	O
unsigned	O
int	O
namelen	O
;	O
bfd_boolean	int
public_section	O
;	O
bfd_boolean	int
gnu_section	O
;	O
if	O
(	O
section_len	O
<=	O
4	int
)	O
{	O
error	O
(	O
_	O
(	O
"Tag section ends prematurely\n"	*(char)
)	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
break	O
;	O
}	O
attr_len	O
=	O
byte_get	O
(	O
p	*(void)
,	O
4	int
)	O
;	O
p	*(void)
+=	O
4	int
;	O
if	O
(	O
attr_len	O
>	O
section_len	O
)	O
{	O
error	O
(	O
_	O
(	O
"Bad attribute length (%u > %u)\n"	*(char)
)	O
,	O
(	O
unsigned	O
)	O
attr_len	O
,	O
(	O
unsigned	O
)	O
section_len	O
)	O
;	O
attr_len	O
=	O
section_len	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
attr_len	O
<	O
5	int
)	O
{	O
error	O
(	O
_	O
(	O
"Attribute length of %u is too small\n"	*(char)
)	O
,	O
(	O
unsigned	O
)	O
attr_len	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
break	O
;	O
}	O
section_len	O
-=	O
attr_len	O
;	O
attr_len	O
-=	O
4	int
;	O
namelen	O
=	O
strnlen	(*(char),long)->(long)
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
attr_len	O
)	O
+	O
1	int
;	O
if	O
(	O
namelen	O
==	O
0	int
||	O
namelen	O
>=	O
attr_len	O
)	O
{	O
error	O
(	O
_	O
(	O
"Corrupt attribute section name\n"	*(char)
)	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Attribute Section: "	*(char)
)	O
)	O
;	O
print_symbol	O
(	O
INT_MAX	O
,	O
(	O
const	O
char	O
*	O
)	O
p	*(void)
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
if	O
(	O
public_name	O
&&	O
streq	O
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
public_name	O
)	O
)	O
public_section	O
=	O
TRUE	int
;	O
else	O
public_section	O
=	O
FALSE	O
;	O
if	O
(	O
streq	O
(	O
(	O
char	O
*	O
)	O
p	*(void)
,	O
"gnu"	*(char)
)	O
)	O
gnu_section	O
=	O
TRUE	int
;	O
else	O
gnu_section	O
=	O
FALSE	O
;	O
p	*(void)
+=	O
namelen	O
;	O
attr_len	O
-=	O
namelen	O
;	O
while	O
(	O
attr_len	O
>	O
0	int
&&	O
p	*(void)
<	O
contents	*(char)
+	O
sect	*(struct)
->	O
sh_size	O
)	O
{	O
int	O
tag	O
;	O
unsigned	O
int	O
val	array(int)
;	O
bfd_vma	long
size	int
;	O
unsigned	O
char	O
*	O
end	*(*(char))
;	O
if	O
(	O
attr_len	O
<	O
6	int
)	O
{	O
error	O
(	O
_	O
(	O
"Unused bytes at end of section\n"	*(char)
)	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
section_len	O
=	O
0	int
;	O
break	O
;	O
}	O
tag	O
=	O
*	O
(	O
p	*(void)
++	O
)	O
;	O
size	int
=	O
byte_get	O
(	O
p	*(void)
,	O
4	int
)	O
;	O
if	O
(	O
size	int
>	O
attr_len	O
)	O
{	O
error	O
(	O
_	O
(	O
"Bad subsection length (%u > %u)\n"	*(char)
)	O
,	O
(	O
unsigned	O
)	O
size	int
,	O
(	O
unsigned	O
)	O
attr_len	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
size	int
=	O
attr_len	O
;	O
}	O
if	O
(	O
size	int
<	O
6	int
)	O
{	O
error	O
(	O
_	O
(	O
"Bad subsection length (%u < 6)\n"	*(char)
)	O
,	O
(	O
unsigned	O
)	O
size	int
)	O
;	O
res	O
=	O
FALSE	O
;	O
section_len	O
=	O
0	int
;	O
break	O
;	O
}	O
attr_len	O
-=	O
size	int
;	O
end	*(*(char))
=	O
p	*(void)
+	O
size	int
-	O
1	int
;	O
assert	O
(	O
end	*(*(char))
<=	O
contents	*(char)
+	O
sect	*(struct)
->	O
sh_size	O
)	O
;	O
p	*(void)
+=	O
4	int
;	O
switch	O
(	O
tag	O
)	O
{	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"File Attributes\n"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Section Attributes:"	*(char)
)	O
)	O
;	O
goto	O
do_numlist	O
;	O
case	O
3	int
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Symbol Attributes:"	*(char)
)	O
)	O
;	O
do_numlist	O
:	O
for	O
(	O
;	O
;	O
)	O
{	O
READ_ULEB	O
(	O
val	array(int)
,	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
if	O
(	O
val	array(int)
==	O
0	int
)	O
break	O
;	O
printf	(*(char))->(int)
(	O
" %d"	*(char)
,	O
val	array(int)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Unknown tag: %d\n"	*(char)
)	O
,	O
tag	O
)	O
;	O
public_section	O
=	O
FALSE	O
;	O
break	O
;	O
}	O
if	O
(	O
public_section	O
&&	O
display_pub_attribute	O
!=	O
NULL	O
)	O
{	O
while	O
(	O
p	*(void)
<	O
end	*(*(char))
)	O
p	*(void)
=	O
display_pub_attribute	O
(	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
assert	O
(	O
p	*(void)
==	O
end	*(*(char))
)	O
;	O
}	O
else	O
if	O
(	O
gnu_section	O
&&	O
display_proc_gnu_attribute	O
!=	O
NULL	O
)	O
{	O
while	O
(	O
p	*(void)
<	O
end	*(*(char))
)	O
p	*(void)
=	O
display_gnu_attribute	O
(	O
p	*(void)
,	O
display_proc_gnu_attribute	O
,	O
end	*(*(char))
)	O
;	O
assert	O
(	O
p	*(void)
==	O
end	*(*(char))
)	O
;	O
}	O
else	O
if	O
(	O
p	*(void)
<	O
end	*(*(char))
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Unknown attribute:\n"	*(char)
)	O
)	O
;	O
display_raw_attribute	O
(	O
p	*(void)
,	O
end	*(*(char))
)	O
;	O
p	*(void)
=	O
end	*(*(char))
;	O
}	O
else	O
attr_len	O
=	O
0	int
;	O
}	O
}	O
}	O
free	(*(void))->(void)
(	O
contents	*(char)
)	O
;	O
}	O
return	O
res	O
;	O
}	O
static	O
bfd_vma	long
print_mips_got_entry	O
(	O
unsigned	O
char	O
*	O
data	*(void)
,	O
bfd_vma	long
pltgot	O
,	O
bfd_vma	long
addr	*(void)
,	O
unsigned	O
char	O
*	O
data_end	O
)	O
{	O
printf	(*(char))->(int)
(	O
"  "	*(char)
)	O
;	O
print_vma	O
(	O
addr	*(void)
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
if	O
(	O
addr	*(void)
<	O
pltgot	O
+	O
0xfff0	int
)	O
printf	(*(char))->(int)
(	O
"%6d(gp)"	*(char)
,	O
(	O
int	O
)	O
(	O
addr	*(void)
-	O
pltgot	O
-	O
0x7ff0	int
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%10s"	*(char)
,	O
""	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
if	O
(	O
data	*(void)
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
"%*s"	*(char)
,	O
is_32bit_elf	O
?	O
8	int
:	O
16	int
,	O
_	O
(	O
"<unknown>"	*(char)
)	O
)	O
;	O
else	O
{	O
bfd_vma	long
entry	O
;	O
unsigned	O
char	O
*	O
from	O
=	O
data	*(void)
+	O
addr	*(void)
-	O
pltgot	O
;	O
if	O
(	O
from	O
+	O
(	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
)	O
>	O
data_end	O
)	O
{	O
warn	O
(	O
_	O
(	O
"MIPS GOT entry extends beyond the end of available data\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%*s"	*(char)
,	O
is_32bit_elf	O
?	O
8	int
:	O
16	int
,	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
return	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
else	O
{	O
entry	O
=	O
byte_get	O
(	O
data	*(void)
+	O
addr	*(void)
-	O
pltgot	O
,	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
)	O
;	O
print_vma	O
(	O
entry	O
,	O
LONG_HEX	O
)	O
;	O
}	O
}	O
return	O
addr	*(void)
+	O
(	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
)	O
;	O
}	O
static	O
bfd_vma	long
print_mips_pltgot_entry	O
(	O
unsigned	O
char	O
*	O
data	*(void)
,	O
bfd_vma	long
pltgot	O
,	O
bfd_vma	long
addr	*(void)
)	O
{	O
printf	(*(char))->(int)
(	O
"  "	*(char)
)	O
;	O
print_vma	O
(	O
addr	*(void)
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
if	O
(	O
data	*(void)
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
"%*s"	*(char)
,	O
is_32bit_elf	O
?	O
8	int
:	O
16	int
,	O
_	O
(	O
"<unknown>"	*(char)
)	O
)	O
;	O
else	O
{	O
bfd_vma	long
entry	O
;	O
entry	O
=	O
byte_get	O
(	O
data	*(void)
+	O
addr	*(void)
-	O
pltgot	O
,	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
)	O
;	O
print_vma	O
(	O
entry	O
,	O
LONG_HEX	O
)	O
;	O
}	O
return	O
addr	*(void)
+	O
(	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
)	O
;	O
}	O
static	O
void	O
print_mips_ases	O
(	O
unsigned	O
int	O
mask	O
)	O
{	O
if	O
(	O
mask	O
&	O
AFL_ASE_DSP	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tDSP ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_DSPR2	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tDSP R2 ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_DSPR3	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tDSP R3 ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_EVA	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tEnhanced VA Scheme"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_MCU	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tMCU (MicroController) ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_MDMX	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tMDMX ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_MIPS3D	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tMIPS-3D ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_MT	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tMT ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_SMARTMIPS	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tSmartMIPS ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_VIRT	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tVZ ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_MSA	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tMSA ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_MIPS16	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tMIPS16 ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_MICROMIPS	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tMICROMIPS ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_XPA	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tXPA ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_MIPS16E2	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tMIPS16e2 ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_CRC	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tCRC ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_GINV	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tGINV ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_LOONGSON_MMI	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tLoongson MMI ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_LOONGSON_CAM	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tLoongson CAM ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_LOONGSON_EXT	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tLoongson EXT ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
&	O
AFL_ASE_LOONGSON_EXT2	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n\tLoongson EXT2 ASE"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
mask	O
==	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n\t%s"	*(char)
,	O
_	O
(	O
"None"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
(	O
mask	O
&	O
~	O
AFL_ASE_MASK	O
)	O
!=	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n\t%s (%x)"	*(char)
,	O
_	O
(	O
"Unknown"	*(char)
)	O
,	O
mask	O
&	O
~	O
AFL_ASE_MASK	O
)	O
;	O
}	O
static	O
void	O
print_mips_isa_ext	O
(	O
unsigned	O
int	O
isa_ext	O
)	O
{	O
switch	O
(	O
isa_ext	O
)	O
{	O
case	O
0	int
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"None"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_XLR	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"RMI XLR"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_OCTEON3	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Cavium Networks Octeon3"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_OCTEON2	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Cavium Networks Octeon2"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_OCTEONP	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Cavium Networks OcteonP"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_OCTEON	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Cavium Networks Octeon"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_5900	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Toshiba R5900"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_4650	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"MIPS R4650"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_4010	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"LSI R4010"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_4100	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"NEC VR4100"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_3900	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Toshiba R3900"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_10000	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"MIPS R10000"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_SB1	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Broadcom SB-1"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_4111	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"NEC VR4111/VR4181"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_4120	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"NEC VR4120"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_5400	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"NEC VR5400"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_5500	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"NEC VR5500"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_LOONGSON_2E	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"ST Microelectronics Loongson 2E"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_LOONGSON_2F	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"ST Microelectronics Loongson 2F"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
AFL_EXT_INTERAPTIV_MR2	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"Imagination interAptiv MR2"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s (%d)"	*(char)
,	O
_	O
(	O
"Unknown"	*(char)
)	O
,	O
isa_ext	O
)	O
;	O
}	O
}	O
static	O
signed	O
int	O
get_mips_reg_size	O
(	O
int	O
reg_size	O
)	O
{	O
return	O
(	O
reg_size	O
==	O
AFL_REG_NONE	O
)	O
?	O
0	int
:	O
(	O
reg_size	O
==	O
AFL_REG_32	O
)	O
?	O
32	int
:	O
(	O
reg_size	O
==	O
AFL_REG_64	O
)	O
?	O
64	int
:	O
(	O
reg_size	O
==	O
AFL_REG_128	O
)	O
?	O
128	int
:	O
-	O
1	int
;	O
}	O
static	O
bfd_boolean	int
process_mips_specific	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Dyn	O
*	O
entry	O
;	O
Elf_Internal_Shdr	O
*	O
sect	*(struct)
=	O
NULL	O
;	O
size_t	long
liblist_offset	O
=	O
0	int
;	O
size_t	long
liblistno	O
=	O
0	int
;	O
size_t	long
conflictsno	O
=	O
0	int
;	O
size_t	long
options_offset	O
=	O
0	int
;	O
size_t	long
conflicts_offset	O
=	O
0	int
;	O
size_t	long
pltrelsz	O
=	O
0	int
;	O
size_t	long
pltrel	O
=	O
0	int
;	O
bfd_vma	long
pltgot	O
=	O
0	int
;	O
bfd_vma	long
mips_pltgot	O
=	O
0	int
;	O
bfd_vma	long
jmprel	O
=	O
0	int
;	O
bfd_vma	long
local_gotno	O
=	O
0	int
;	O
bfd_vma	long
gotsym	O
=	O
0	int
;	O
bfd_vma	long
symtabno	O
=	O
0	int
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
if	O
(	O
!	O
process_attributes	O
(	O
filedata	O
,	O
NULL	O
,	O
SHT_GNU_ATTRIBUTES	O
,	O
NULL	O
,	O
display_mips_gnu_attribute	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
sect	*(struct)
=	O
find_section	O
(	O
filedata	O
,	O
".MIPS.abiflags"	*(char)
)	O
;	O
if	O
(	O
sect	*(struct)
!=	O
NULL	O
)	O
{	O
Elf_External_ABIFlags_v0	O
*	O
abiflags_ext	O
;	O
Elf_Internal_ABIFlags_v0	O
abiflags_in	O
;	O
if	O
(	O
sizeof	O
(	O
Elf_External_ABIFlags_v0	O
)	O
!=	O
sect	*(struct)
->	O
sh_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Corrupt MIPS ABI Flags section.\n"	*(char)
)	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
}	O
else	O
{	O
abiflags_ext	O
=	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
sect	*(struct)
->	O
sh_offset	O
,	O
1	int
,	O
sect	*(struct)
->	O
sh_size	O
,	O
_	O
(	O
"MIPS ABI Flags section"	*(char)
)	O
)	O
;	O
if	O
(	O
abiflags_ext	O
)	O
{	O
abiflags_in	O
.	O
version	*(char)
=	O
BYTE_GET	O
(	O
abiflags_ext	O
->	O
version	*(char)
)	O
;	O
abiflags_in	O
.	O
isa_level	O
=	O
BYTE_GET	O
(	O
abiflags_ext	O
->	O
isa_level	O
)	O
;	O
abiflags_in	O
.	O
isa_rev	O
=	O
BYTE_GET	O
(	O
abiflags_ext	O
->	O
isa_rev	O
)	O
;	O
abiflags_in	O
.	O
gpr_size	O
=	O
BYTE_GET	O
(	O
abiflags_ext	O
->	O
gpr_size	O
)	O
;	O
abiflags_in	O
.	O
cpr1_size	O
=	O
BYTE_GET	O
(	O
abiflags_ext	O
->	O
cpr1_size	O
)	O
;	O
abiflags_in	O
.	O
cpr2_size	O
=	O
BYTE_GET	O
(	O
abiflags_ext	O
->	O
cpr2_size	O
)	O
;	O
abiflags_in	O
.	O
fp_abi	O
=	O
BYTE_GET	O
(	O
abiflags_ext	O
->	O
fp_abi	O
)	O
;	O
abiflags_in	O
.	O
isa_ext	O
=	O
BYTE_GET	O
(	O
abiflags_ext	O
->	O
isa_ext	O
)	O
;	O
abiflags_in	O
.	O
ases	O
=	O
BYTE_GET	O
(	O
abiflags_ext	O
->	O
ases	O
)	O
;	O
abiflags_in	O
.	O
flags1	O
=	O
BYTE_GET	O
(	O
abiflags_ext	O
->	O
flags1	O
)	O
;	O
abiflags_in	O
.	O
flags2	O
=	O
BYTE_GET	O
(	O
abiflags_ext	O
->	O
flags2	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\nMIPS ABI Flags Version: %d\n"	*(char)
,	O
abiflags_in	O
.	O
version	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\nISA: MIPS%d"	*(char)
,	O
abiflags_in	O
.	O
isa_level	O
)	O
;	O
if	O
(	O
abiflags_in	O
.	O
isa_rev	O
>	O
1	int
)	O
printf	(*(char))->(int)
(	O
"r%d"	*(char)
,	O
abiflags_in	O
.	O
isa_rev	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\nGPR size: %d"	*(char)
,	O
get_mips_reg_size	O
(	O
abiflags_in	O
.	O
gpr_size	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\nCPR1 size: %d"	*(char)
,	O
get_mips_reg_size	O
(	O
abiflags_in	O
.	O
cpr1_size	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\nCPR2 size: %d"	*(char)
,	O
get_mips_reg_size	O
(	O
abiflags_in	O
.	O
cpr2_size	O
)	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\nFP ABI: "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_mips_fp_abi_value	O
(	O
abiflags_in	O
.	O
fp_abi	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"ISA Extension: "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_mips_isa_ext	O
(	O
abiflags_in	O
.	O
isa_ext	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\nASEs:"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_mips_ases	O
(	O
abiflags_in	O
.	O
ases	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\nFLAGS 1: %8.8lx"	*(char)
,	O
abiflags_in	O
.	O
flags1	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\nFLAGS 2: %8.8lx"	*(char)
,	O
abiflags_in	O
.	O
flags2	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
abiflags_ext	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
dynamic_section	O
==	O
NULL	O
)	O
{	O
sect	*(struct)
=	O
find_section	O
(	O
filedata	O
,	O
".got"	*(char)
)	O
;	O
if	O
(	O
sect	*(struct)
!=	O
NULL	O
)	O
{	O
unsigned	O
char	O
*	O
data_end	O
;	O
unsigned	O
char	O
*	O
data	*(void)
;	O
bfd_vma	long
ent	O
,	O
end	*(*(char))
;	O
int	O
addr_size	O
;	O
pltgot	O
=	O
sect	*(struct)
->	O
sh_addr	O
;	O
ent	O
=	O
pltgot	O
;	O
addr_size	O
=	O
(	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
)	O
;	O
end	*(*(char))
=	O
pltgot	O
+	O
sect	*(struct)
->	O
sh_size	O
;	O
data	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
sect	*(struct)
->	O
sh_offset	O
,	O
end	*(*(char))
-	O
pltgot	O
,	O
1	int
,	O
_	O
(	O
"Global Offset Table data"	*(char)
)	O
)	O
;	O
data_end	O
=	O
data	*(void)
+	O
(	O
end	*(*(char))
-	O
pltgot	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nStatic GOT:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Canonical gp value: "	*(char)
)	O
)	O
;	O
print_vma	O
(	O
ent	O
+	O
0x7ff0	int
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n\n"	*(char)
)	O
;	O
if	O
(	O
data	*(void)
&&	O
data	*(void)
+	O
ent	O
-	O
pltgot	O
+	O
addr_size	O
<=	O
data_end	O
&&	O
byte_get	O
(	O
data	*(void)
+	O
ent	O
-	O
pltgot	O
,	O
addr_size	O
)	O
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Reserved entries:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  %*s %10s %*s\n"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Address"	*(char)
)	O
,	O
_	O
(	O
"Access"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Value"	*(char)
)	O
)	O
;	O
ent	O
=	O
print_mips_got_entry	O
(	O
data	*(void)
,	O
pltgot	O
,	O
ent	O
,	O
data_end	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
if	O
(	O
ent	O
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
sgot_print_fail	O
;	O
if	O
(	O
data	*(void)
&&	O
data	*(void)
+	O
ent	O
-	O
pltgot	O
+	O
addr_size	O
<=	O
data_end	O
&&	O
(	O
byte_get	O
(	O
data	*(void)
+	O
ent	O
-	O
pltgot	O
,	O
addr_size	O
)	O
>>	O
(	O
addr_size	O
*	O
8	int
-	O
1	int
)	O
)	O
!=	O
0	int
)	O
{	O
ent	O
=	O
print_mips_got_entry	O
(	O
data	*(void)
,	O
pltgot	O
,	O
ent	O
,	O
data_end	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
if	O
(	O
ent	O
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
sgot_print_fail	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
data	*(void)
!=	O
NULL	O
&&	O
ent	O
<	O
end	*(*(char))
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Local entries:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  %*s %10s %*s\n"	*(char)
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Address"	*(char)
)	O
,	O
_	O
(	O
"Access"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Value"	*(char)
)	O
)	O
;	O
while	O
(	O
ent	O
<	O
end	*(*(char))
)	O
{	O
ent	O
=	O
print_mips_got_entry	O
(	O
data	*(void)
,	O
pltgot	O
,	O
ent	O
,	O
data_end	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
if	O
(	O
ent	O
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
sgot_print_fail	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
sgot_print_fail	O
:	O
if	O
(	O
data	*(void)
)	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
}	O
return	O
res	O
;	O
}	O
for	O
(	O
entry	O
=	O
dynamic_section	O
;	O
entry	O
<	O
dynamic_section	O
+	O
dynamic_nent	O
&&	O
entry	O
->	O
d_tag	O
!=	O
DT_NULL	O
;	O
++	O
entry	O
)	O
switch	O
(	O
entry	O
->	O
d_tag	O
)	O
{	O
case	O
DT_MIPS_LIBLIST	O
:	O
liblist_offset	O
=	O
offset_from_vma	O
(	O
filedata	O
,	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
liblistno	O
*	O
sizeof	O
(	O
Elf32_External_Lib	O
)	O
)	O
;	O
break	O
;	O
case	O
DT_MIPS_LIBLISTNO	O
:	O
liblistno	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_MIPS_OPTIONS	O
:	O
options_offset	O
=	O
offset_from_vma	O
(	O
filedata	O
,	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
DT_MIPS_CONFLICT	O
:	O
conflicts_offset	O
=	O
offset_from_vma	O
(	O
filedata	O
,	O
entry	O
->	O
d_un	O
.	O
d_val	O
,	O
conflictsno	O
*	O
sizeof	O
(	O
Elf32_External_Conflict	O
)	O
)	O
;	O
break	O
;	O
case	O
DT_MIPS_CONFLICTNO	O
:	O
conflictsno	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_PLTGOT	O
:	O
pltgot	O
=	O
entry	O
->	O
d_un	O
.	O
d_ptr	O
;	O
break	O
;	O
case	O
DT_MIPS_LOCAL_GOTNO	O
:	O
local_gotno	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_MIPS_GOTSYM	O
:	O
gotsym	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_MIPS_SYMTABNO	O
:	O
symtabno	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_MIPS_PLTGOT	O
:	O
mips_pltgot	O
=	O
entry	O
->	O
d_un	O
.	O
d_ptr	O
;	O
break	O
;	O
case	O
DT_PLTREL	O
:	O
pltrel	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_PLTRELSZ	O
:	O
pltrelsz	O
=	O
entry	O
->	O
d_un	O
.	O
d_val	O
;	O
break	O
;	O
case	O
DT_JMPREL	O
:	O
jmprel	O
=	O
entry	O
->	O
d_un	O
.	O
d_ptr	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
liblist_offset	O
!=	O
0	int
&&	O
liblistno	O
!=	O
0	int
&&	O
do_dynamic	O
)	O
{	O
Elf32_External_Lib	O
*	O
elib	O
;	O
size_t	long
cnt	O
;	O
elib	O
=	O
(	O
Elf32_External_Lib	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
liblist_offset	O
,	O
liblistno	O
,	O
sizeof	O
(	O
Elf32_External_Lib	O
)	O
,	O
_	O
(	O
"liblist section data"	*(char)
)	O
)	O
;	O
if	O
(	O
elib	O
)	O
{	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nSection '.liblist' contains %lu entry:\n"	*(char)
,	O
"\nSection '.liblist' contains %lu entries:\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
liblistno	O
)	O
,	O
(	O
unsigned	O
long	O
)	O
liblistno	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"     Library              Time Stamp          Checksum   Version Flags\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
for	O
(	O
cnt	O
=	O
0	int
;	O
cnt	O
<	O
liblistno	O
;	O
++	O
cnt	O
)	O
{	O
Elf32_Lib	O
liblist	O
;	O
time_t	long
atime	O
;	O
char	O
timebuf	O
[	O
128	int
]	O
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tmp	O
;	O
liblist	O
.	O
l_name	O
=	O
BYTE_GET	O
(	O
elib	O
[	O
cnt	O
]	O
.	O
l_name	O
)	O
;	O
atime	O
=	O
BYTE_GET	O
(	O
elib	O
[	O
cnt	O
]	O
.	O
l_time_stamp	O
)	O
;	O
liblist	O
.	O
l_checksum	O
=	O
BYTE_GET	O
(	O
elib	O
[	O
cnt	O
]	O
.	O
l_checksum	O
)	O
;	O
liblist	O
.	O
l_version	O
=	O
BYTE_GET	O
(	O
elib	O
[	O
cnt	O
]	O
.	O
l_version	O
)	O
;	O
liblist	O
.	O
l_flags	O
=	O
BYTE_GET	O
(	O
elib	O
[	O
cnt	O
]	O
.	O
l_flags	O
)	O
;	O
tmp	O
=	O
gmtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
atime	O
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
timebuf	O
,	O
sizeof	O
(	O
timebuf	O
)	O
,	O
"%04u-%02u-%02uT%02u:%02u:%02u"	*(char)
,	O
tmp	O
->	O
tm_year	int
+	O
1900	int
,	O
tmp	O
->	O
tm_mon	int
+	O
1	int
,	O
tmp	O
->	O
tm_mday	int
,	O
tmp	O
->	O
tm_hour	int
,	O
tmp	O
->	O
tm_min	int
,	O
tmp	O
->	O
tm_sec	int
)	O
;	O
printf	(*(char))->(int)
(	O
"%3lu: "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
cnt	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
liblist	O
.	O
l_name	O
)	O
)	O
print_symbol	O
(	O
20	int
,	O
GET_DYNAMIC_NAME	O
(	O
liblist	O
.	O
l_name	O
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt: %9ld>"	*(char)
)	O
,	O
liblist	O
.	O
l_name	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %s %#10lx %-7ld"	*(char)
,	O
timebuf	O
,	O
liblist	O
.	O
l_checksum	O
,	O
liblist	O
.	O
l_version	O
)	O
;	O
if	O
(	O
liblist	O
.	O
l_flags	O
==	O
0	int
)	O
puts	(*(char))->(int)
(	O
_	O
(	O
" NONE"	*(char)
)	O
)	O
;	O
else	O
{	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
int	O
bit	O
;	O
}	O
l_flags_vals	O
[	O
]	O
=	O
{	O
{	O
" EXACT_MATCH"	*(char)
,	O
LL_EXACT_MATCH	O
}	O
,	O
{	O
" IGNORE_INT_VER"	*(char)
,	O
LL_IGNORE_INT_VER	O
}	O
,	O
{	O
" REQUIRE_MINOR"	*(char)
,	O
LL_REQUIRE_MINOR	O
}	O
,	O
{	O
" EXPORTS"	*(char)
,	O
LL_EXPORTS	O
}	O
,	O
{	O
" DELAY_LOAD"	*(char)
,	O
LL_DELAY_LOAD	O
}	O
,	O
{	O
" DELTA"	*(char)
,	O
LL_DELTA	O
}	O
}	O
;	O
int	O
flags	int
=	O
liblist	O
.	O
l_flags	O
;	O
size_t	long
fcnt	O
;	O
for	O
(	O
fcnt	O
=	O
0	int
;	O
fcnt	O
<	O
ARRAY_SIZE	O
(	O
l_flags_vals	O
)	O
;	O
++	O
fcnt	O
)	O
if	O
(	O
(	O
flags	int
&	O
l_flags_vals	O
[	O
fcnt	O
]	O
.	O
bit	O
)	O
!=	O
0	int
)	O
{	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
l_flags_vals	O
[	O
fcnt	O
]	O
.	O
name	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
flags	int
^=	O
l_flags_vals	O
[	O
fcnt	O
]	O
.	O
bit	O
;	O
}	O
if	O
(	O
flags	int
!=	O
0	int
)	O
printf	(*(char))->(int)
(	O
" %#x"	*(char)
,	O
(	O
unsigned	O
int	O
)	O
flags	int
)	O
;	O
puts	(*(char))->(int)
(	O
""	*(char)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
elib	O
)	O
;	O
}	O
else	O
res	O
=	O
FALSE	O
;	O
}	O
if	O
(	O
options_offset	O
!=	O
0	int
)	O
{	O
Elf_External_Options	O
*	O
eopt	O
;	O
size_t	long
offset	long
;	O
int	O
cnt	O
;	O
sect	*(struct)
=	O
filedata	O
->	O
section_headers	O
;	O
sect	*(struct)
=	O
find_section_by_type	O
(	O
filedata	O
,	O
SHT_MIPS_OPTIONS	O
)	O
;	O
if	O
(	O
sect	*(struct)
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"No MIPS_OPTIONS header found\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
sect	*(struct)
->	O
sh_size	O
<	O
sizeof	O
(	O
*	O
eopt	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"The MIPS options section is too small.\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
eopt	O
=	O
(	O
Elf_External_Options	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
options_offset	O
,	O
1	int
,	O
sect	*(struct)
->	O
sh_size	O
,	O
_	O
(	O
"options"	*(char)
)	O
)	O
;	O
if	O
(	O
eopt	O
)	O
{	O
Elf_Internal_Options	O
*	O
iopt	O
;	O
Elf_Internal_Options	O
*	O
option	O
;	O
Elf_Internal_Options	O
*	O
iopt_end	O
;	O
iopt	O
=	O
(	O
Elf_Internal_Options	O
*	O
)	O
cmalloc	O
(	O
(	O
sect	*(struct)
->	O
sh_size	O
/	O
sizeof	O
(	O
eopt	O
)	O
)	O
,	O
sizeof	O
(	O
*	O
iopt	O
)	O
)	O
;	O
if	O
(	O
iopt	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory allocating space for MIPS options\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
offset	long
=	O
cnt	O
=	O
0	int
;	O
option	O
=	O
iopt	O
;	O
iopt_end	O
=	O
iopt	O
+	O
(	O
sect	*(struct)
->	O
sh_size	O
/	O
sizeof	O
(	O
eopt	O
)	O
)	O
;	O
while	O
(	O
offset	long
<=	O
sect	*(struct)
->	O
sh_size	O
-	O
sizeof	O
(	O
*	O
eopt	O
)	O
)	O
{	O
Elf_External_Options	O
*	O
eoption	O
;	O
eoption	O
=	O
(	O
Elf_External_Options	O
*	O
)	O
(	O
(	O
char	O
*	O
)	O
eopt	O
+	O
offset	long
)	O
;	O
option	O
->	O
kind	O
=	O
BYTE_GET	O
(	O
eoption	O
->	O
kind	O
)	O
;	O
option	O
->	O
size	int
=	O
BYTE_GET	O
(	O
eoption	O
->	O
size	int
)	O
;	O
option	O
->	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
BYTE_GET	O
(	O
eoption	O
->	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
;	O
option	O
->	O
info	*(void)
=	O
BYTE_GET	O
(	O
eoption	O
->	O
info	*(void)
)	O
;	O
if	O
(	O
option	O
->	O
size	int
<	O
sizeof	O
(	O
*	O
eopt	O
)	O
||	O
offset	long
+	O
option	O
->	O
size	int
>	O
sect	*(struct)
->	O
sh_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Invalid size (%u) for MIPS option\n"	*(char)
)	O
,	O
option	O
->	O
size	int
)	O
;	O
return	O
FALSE	O
;	O
}	O
offset	long
+=	O
option	O
->	O
size	int
;	O
++	O
option	O
;	O
++	O
cnt	O
;	O
}	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nSection '%s' contains %d entry:\n"	*(char)
,	O
"\nSection '%s' contains %d entries:\n"	*(char)
,	O
cnt	O
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
sect	*(struct)
)	O
,	O
cnt	O
)	O
;	O
option	O
=	O
iopt	O
;	O
offset	long
=	O
0	int
;	O
while	O
(	O
cnt	O
--	O
>	O
0	int
)	O
{	O
size_t	long
len	int
;	O
switch	O
(	O
option	O
->	O
kind	O
)	O
{	O
case	O
ODK_NULL	O
:	O
printf	(*(char))->(int)
(	O
" NULL       %d %lx"	*(char)
,	O
option	O
->	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
option	O
->	O
info	*(void)
)	O
;	O
break	O
;	O
case	O
ODK_REGINFO	O
:	O
printf	(*(char))->(int)
(	O
" REGINFO    "	*(char)
)	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_MIPS	O
)	O
{	O
Elf32_External_RegInfo	O
*	O
ereg	O
;	O
Elf32_RegInfo	O
reginfo	O
;	O
if	O
(	O
option	O
+	O
2	int
>	O
iopt_end	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>\n"	*(char)
)	O
)	O
;	O
error	O
(	O
_	O
(	O
"Truncated MIPS REGINFO option\n"	*(char)
)	O
)	O
;	O
cnt	O
=	O
0	int
;	O
break	O
;	O
}	O
ereg	O
=	O
(	O
Elf32_External_RegInfo	O
*	O
)	O
(	O
option	O
+	O
1	int
)	O
;	O
reginfo	O
.	O
ri_gprmask	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_gprmask	O
)	O
;	O
reginfo	O
.	O
ri_cprmask	O
[	O
0	int
]	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_cprmask	O
[	O
0	int
]	O
)	O
;	O
reginfo	O
.	O
ri_cprmask	O
[	O
1	int
]	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_cprmask	O
[	O
1	int
]	O
)	O
;	O
reginfo	O
.	O
ri_cprmask	O
[	O
2	int
]	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_cprmask	O
[	O
2	int
]	O
)	O
;	O
reginfo	O
.	O
ri_cprmask	O
[	O
3	int
]	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_cprmask	O
[	O
3	int
]	O
)	O
;	O
reginfo	O
.	O
ri_gp_value	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_gp_value	O
)	O
;	O
printf	(*(char))->(int)
(	O
"GPR %08lx  GP 0x%lx\n"	*(char)
,	O
reginfo	O
.	O
ri_gprmask	O
,	O
(	O
unsigned	O
long	O
)	O
reginfo	O
.	O
ri_gp_value	O
)	O
;	O
printf	(*(char))->(int)
(	O
"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"	*(char)
,	O
reginfo	O
.	O
ri_cprmask	O
[	O
0	int
]	O
,	O
reginfo	O
.	O
ri_cprmask	O
[	O
1	int
]	O
,	O
reginfo	O
.	O
ri_cprmask	O
[	O
2	int
]	O
,	O
reginfo	O
.	O
ri_cprmask	O
[	O
3	int
]	O
)	O
;	O
}	O
else	O
{	O
Elf64_External_RegInfo	O
*	O
ereg	O
;	O
Elf64_Internal_RegInfo	O
reginfo	O
;	O
if	O
(	O
option	O
+	O
2	int
>	O
iopt_end	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt>\n"	*(char)
)	O
)	O
;	O
error	O
(	O
_	O
(	O
"Truncated MIPS REGINFO option\n"	*(char)
)	O
)	O
;	O
cnt	O
=	O
0	int
;	O
break	O
;	O
}	O
ereg	O
=	O
(	O
Elf64_External_RegInfo	O
*	O
)	O
(	O
option	O
+	O
1	int
)	O
;	O
reginfo	O
.	O
ri_gprmask	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_gprmask	O
)	O
;	O
reginfo	O
.	O
ri_cprmask	O
[	O
0	int
]	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_cprmask	O
[	O
0	int
]	O
)	O
;	O
reginfo	O
.	O
ri_cprmask	O
[	O
1	int
]	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_cprmask	O
[	O
1	int
]	O
)	O
;	O
reginfo	O
.	O
ri_cprmask	O
[	O
2	int
]	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_cprmask	O
[	O
2	int
]	O
)	O
;	O
reginfo	O
.	O
ri_cprmask	O
[	O
3	int
]	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_cprmask	O
[	O
3	int
]	O
)	O
;	O
reginfo	O
.	O
ri_gp_value	O
=	O
BYTE_GET	O
(	O
ereg	O
->	O
ri_gp_value	O
)	O
;	O
printf	(*(char))->(int)
(	O
"GPR %08lx  GP 0x"	*(char)
,	O
reginfo	O
.	O
ri_gprmask	O
)	O
;	O
printf_vma	O
(	O
reginfo	O
.	O
ri_gp_value	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"	*(char)
,	O
reginfo	O
.	O
ri_cprmask	O
[	O
0	int
]	O
,	O
reginfo	O
.	O
ri_cprmask	O
[	O
1	int
]	O
,	O
reginfo	O
.	O
ri_cprmask	O
[	O
2	int
]	O
,	O
reginfo	O
.	O
ri_cprmask	O
[	O
3	int
]	O
)	O
;	O
}	O
++	O
option	O
;	O
continue	O
;	O
case	O
ODK_EXCEPTIONS	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" EXCEPTIONS fpe_min("	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
process_mips_fpe_exception	O
(	O
option	O
->	O
info	*(void)
&	O
OEX_FPU_MIN	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
") fpe_max("	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
process_mips_fpe_exception	O
(	O
(	O
option	O
->	O
info	*(void)
&	O
OEX_FPU_MAX	O
)	O
>>	O
8	int
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
")"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OEX_PAGE0	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" PAGE0"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OEX_SMM	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" SMM"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OEX_FPDBUG	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" FPDBUG"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OEX_DISMISS	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" DISMISS"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
ODK_PAD	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" PAD       "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OPAD_PREFIX	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" PREFIX"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OPAD_POSTFIX	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" POSTFIX"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OPAD_SYMBOL	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" SYMBOL"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
ODK_HWPATCH	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" HWPATCH   "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OHW_R4KEOP	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" R4KEOP"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OHW_R8KPFETCH	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" R8KPFETCH"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OHW_R5KEOP	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" R5KEOP"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OHW_R5KCVTL	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" R5KCVTL"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
ODK_FILL	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" FILL       "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
ODK_TAGS	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" TAGS       "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
ODK_HWAND	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" HWAND     "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OHWA0_R4KEOP_CHECKED	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" R4KEOP_CHECKED"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OHWA0_R4KEOP_CLEAN	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" R4KEOP_CLEAN"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
ODK_HWOR	O
:	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" HWOR      "	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OHWA0_R4KEOP_CHECKED	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" R4KEOP_CHECKED"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
option	O
->	O
info	*(void)
&	O
OHWA0_R4KEOP_CLEAN	O
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
" R4KEOP_CLEAN"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
ODK_GP_GROUP	O
:	O
printf	(*(char))->(int)
(	O
" GP_GROUP  %#06lx  self-contained %#06lx"	*(char)
,	O
option	O
->	O
info	*(void)
&	O
OGP_GROUP	O
,	O
(	O
option	O
->	O
info	*(void)
&	O
OGP_SELF	O
)	O
>>	O
16	int
)	O
;	O
break	O
;	O
case	O
ODK_IDENT	O
:	O
printf	(*(char))->(int)
(	O
" IDENT     %#06lx  self-contained %#06lx"	*(char)
,	O
option	O
->	O
info	*(void)
&	O
OGP_GROUP	O
,	O
(	O
option	O
->	O
info	*(void)
&	O
OGP_SELF	O
)	O
>>	O
16	int
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
" %3d ???     %d %lx"	*(char)
,	O
option	O
->	O
kind	O
,	O
option	O
->	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
option	O
->	O
info	*(void)
)	O
;	O
break	O
;	O
}	O
len	int
=	O
sizeof	O
(	O
*	O
eopt	O
)	O
;	O
while	O
(	O
len	int
<	O
option	O
->	O
size	int
)	O
{	O
unsigned	O
char	O
datum	O
=	O
*	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
eopt	O
+	O
offset	long
+	O
len	int
)	O
;	O
if	O
(	O
ISPRINT	O
(	O
datum	O
)	O
)	O
printf	(*(char))->(int)
(	O
"%c"	*(char)
,	O
datum	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"\\%03o"	*(char)
,	O
datum	O
)	O
;	O
len	int
++	O
;	O
}	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
offset	long
+=	O
option	O
->	O
size	int
;	O
++	O
option	O
;	O
}	O
free	(*(void))->(void)
(	O
eopt	O
)	O
;	O
}	O
else	O
res	O
=	O
FALSE	O
;	O
}	O
if	O
(	O
conflicts_offset	O
!=	O
0	int
&&	O
conflictsno	O
!=	O
0	int
)	O
{	O
Elf32_Conflict	O
*	O
iconf	O
;	O
size_t	long
cnt	O
;	O
if	O
(	O
dynamic_symbols	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"conflict list found without a dynamic symbol table\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
conflictsno	O
*	O
sizeof	O
(	O
*	O
iconf	O
)	O
>	O
filedata	O
->	O
file_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"Overlarge number of conflicts detected: %lx\n"	*(char)
)	O
,	O
(	O
long	O
)	O
conflictsno	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
iconf	O
=	O
(	O
Elf32_Conflict	O
*	O
)	O
cmalloc	O
(	O
conflictsno	O
,	O
sizeof	O
(	O
*	O
iconf	O
)	O
)	O
;	O
if	O
(	O
iconf	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory allocating space for dynamic conflicts\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
Elf32_External_Conflict	O
*	O
econf32	O
;	O
econf32	O
=	O
(	O
Elf32_External_Conflict	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
conflicts_offset	O
,	O
conflictsno	O
,	O
sizeof	O
(	O
*	O
econf32	O
)	O
,	O
_	O
(	O
"conflict"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
econf32	O
)	O
return	O
FALSE	O
;	O
for	O
(	O
cnt	O
=	O
0	int
;	O
cnt	O
<	O
conflictsno	O
;	O
++	O
cnt	O
)	O
iconf	O
[	O
cnt	O
]	O
=	O
BYTE_GET	O
(	O
econf32	O
[	O
cnt	O
]	O
)	O
;	O
free	(*(void))->(void)
(	O
econf32	O
)	O
;	O
}	O
else	O
{	O
Elf64_External_Conflict	O
*	O
econf64	O
;	O
econf64	O
=	O
(	O
Elf64_External_Conflict	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
conflicts_offset	O
,	O
conflictsno	O
,	O
sizeof	O
(	O
*	O
econf64	O
)	O
,	O
_	O
(	O
"conflict"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
econf64	O
)	O
return	O
FALSE	O
;	O
for	O
(	O
cnt	O
=	O
0	int
;	O
cnt	O
<	O
conflictsno	O
;	O
++	O
cnt	O
)	O
iconf	O
[	O
cnt	O
]	O
=	O
BYTE_GET	O
(	O
econf64	O
[	O
cnt	O
]	O
)	O
;	O
free	(*(void))->(void)
(	O
econf64	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nSection '.conflict' contains %lu entry:\n"	*(char)
,	O
"\nSection '.conflict' contains %lu entries:\n"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
conflictsno	O
)	O
,	O
(	O
unsigned	O
long	O
)	O
conflictsno	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"  Num:    Index       Value  Name"	*(char)
)	O
)	O
;	O
for	O
(	O
cnt	O
=	O
0	int
;	O
cnt	O
<	O
conflictsno	O
;	O
++	O
cnt	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%5lu: %8lu  "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
cnt	O
,	O
iconf	O
[	O
cnt	O
]	O
)	O
;	O
if	O
(	O
iconf	O
[	O
cnt	O
]	O
>=	O
num_dynamic_syms	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt symbol index>"	*(char)
)	O
)	O
;	O
else	O
{	O
Elf_Internal_Sym	O
*	O
psym	O
;	O
psym	O
=	O
&	O
dynamic_symbols	O
[	O
iconf	O
[	O
cnt	O
]	O
]	O
;	O
print_vma	O
(	O
psym	O
->	O
st_value	O
,	O
FULL_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
' '	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
psym	O
->	O
st_name	O
)	O
)	O
print_symbol	O
(	O
25	int
,	O
GET_DYNAMIC_NAME	O
(	O
psym	O
->	O
st_name	O
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt: %14ld>"	*(char)
)	O
,	O
psym	O
->	O
st_name	O
)	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
iconf	O
)	O
;	O
}	O
if	O
(	O
pltgot	O
!=	O
0	int
&&	O
local_gotno	O
!=	O
0	int
)	O
{	O
bfd_vma	long
ent	O
,	O
local_end	O
,	O
global_end	O
;	O
size_t	long
i	*(struct)
,	O
offset	long
;	O
unsigned	O
char	O
*	O
data	*(void)
;	O
unsigned	O
char	O
*	O
data_end	O
;	O
int	O
addr_size	O
;	O
ent	O
=	O
pltgot	O
;	O
addr_size	O
=	O
(	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
)	O
;	O
local_end	O
=	O
pltgot	O
+	O
local_gotno	O
*	O
addr_size	O
;	O
if	O
(	O
symtabno	O
<	O
gotsym	O
)	O
{	O
error	O
(	O
_	O
(	O
"The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
gotsym	O
,	O
(	O
unsigned	O
long	O
)	O
symtabno	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
global_end	O
=	O
local_end	O
+	O
(	O
symtabno	O
-	O
gotsym	O
)	O
*	O
addr_size	O
;	O
if	O
(	O
global_end	O
<	O
local_end	O
)	O
{	O
error	O
(	O
_	O
(	O
"Too many GOT symbols: %lu\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
symtabno	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
offset	long
=	O
offset_from_vma	O
(	O
filedata	O
,	O
pltgot	O
,	O
global_end	O
-	O
pltgot	O
)	O
;	O
data	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
offset	long
,	O
global_end	O
-	O
pltgot	O
,	O
1	int
,	O
_	O
(	O
"Global Offset Table data"	*(char)
)	O
)	O
;	O
data_end	O
=	O
data	*(void)
+	O
(	O
global_end	O
-	O
pltgot	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nPrimary GOT:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Canonical gp value: "	*(char)
)	O
)	O
;	O
print_vma	O
(	O
pltgot	O
+	O
0x7ff0	int
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Reserved entries:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  %*s %10s %*s Purpose\n"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Address"	*(char)
)	O
,	O
_	O
(	O
"Access"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Initial"	*(char)
)	O
)	O
;	O
ent	O
=	O
print_mips_got_entry	O
(	O
data	*(void)
,	O
pltgot	O
,	O
ent	O
,	O
data_end	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Lazy resolver\n"	*(char)
)	O
)	O
;	O
if	O
(	O
ent	O
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
got_print_fail	O
;	O
if	O
(	O
data	*(void)
&&	O
data	*(void)
+	O
ent	O
-	O
pltgot	O
+	O
addr_size	O
<=	O
data_end	O
&&	O
(	O
byte_get	O
(	O
data	*(void)
+	O
ent	O
-	O
pltgot	O
,	O
addr_size	O
)	O
>>	O
(	O
addr_size	O
*	O
8	int
-	O
1	int
)	O
)	O
!=	O
0	int
)	O
{	O
ent	O
=	O
print_mips_got_entry	O
(	O
data	*(void)
,	O
pltgot	O
,	O
ent	O
,	O
data_end	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Module pointer (GNU extension)\n"	*(char)
)	O
)	O
;	O
if	O
(	O
ent	O
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
got_print_fail	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
if	O
(	O
data	*(void)
!=	O
NULL	O
&&	O
ent	O
<	O
local_end	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Local entries:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  %*s %10s %*s\n"	*(char)
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Address"	*(char)
)	O
,	O
_	O
(	O
"Access"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Initial"	*(char)
)	O
)	O
;	O
while	O
(	O
ent	O
<	O
local_end	O
)	O
{	O
ent	O
=	O
print_mips_got_entry	O
(	O
data	*(void)
,	O
pltgot	O
,	O
ent	O
,	O
data_end	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
if	O
(	O
ent	O
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
goto	O
got_print_fail	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
data	*(void)
!=	O
NULL	O
&&	O
gotsym	O
<	O
symtabno	O
)	O
{	O
int	O
sym_width	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Global entries:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  %*s %10s %*s %*s %-7s %3s %s\n"	*(char)
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Address"	*(char)
)	O
,	O
_	O
(	O
"Access"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Initial"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Sym.Val."	*(char)
)	O
,	O
_	O
(	O
"Type"	*(char)
)	O
,	O
_	O
(	O
"Ndx"	*(char)
)	O
,	O
_	O
(	O
"Name"	*(char)
)	O
)	O
;	O
sym_width	O
=	O
(	O
is_32bit_elf	O
?	O
80	int
:	O
160	int
)	O
-	O
28	int
-	O
addr_size	O
*	O
6	int
-	O
1	int
;	O
for	O
(	O
i	*(struct)
=	O
gotsym	O
;	O
i	*(struct)
<	O
symtabno	O
;	O
i	*(struct)
++	O
)	O
{	O
ent	O
=	O
print_mips_got_entry	O
(	O
data	*(void)
,	O
pltgot	O
,	O
ent	O
,	O
data_end	O
)	O
;	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
if	O
(	O
dynamic_symbols	O
==	O
NULL	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<no dynamic symbols>"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
i	*(struct)
<	O
num_dynamic_syms	O
)	O
{	O
Elf_Internal_Sym	O
*	O
psym	O
=	O
dynamic_symbols	O
+	O
i	*(struct)
;	O
print_vma	O
(	O
psym	O
->	O
st_value	O
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %-7s %3s "	*(char)
,	O
get_symbol_type	O
(	O
filedata	O
,	O
ELF_ST_TYPE	O
(	O
psym	O
->	O
st_info	O
)	O
)	O
,	O
get_symbol_index_type	O
(	O
filedata	O
,	O
psym	O
->	O
st_shndx	O
)	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
psym	O
->	O
st_name	O
)	O
)	O
print_symbol	O
(	O
sym_width	O
,	O
GET_DYNAMIC_NAME	O
(	O
psym	O
->	O
st_name	O
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt: %14ld>"	*(char)
)	O
,	O
psym	O
->	O
st_name	O
)	O
;	O
}	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<symbol index %lu exceeds number of dynamic symbols>"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
i	*(struct)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
if	O
(	O
ent	O
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
got_print_fail	O
:	O
if	O
(	O
data	*(void)
)	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
}	O
if	O
(	O
mips_pltgot	O
!=	O
0	int
&&	O
jmprel	O
!=	O
0	int
&&	O
pltrel	O
!=	O
0	int
&&	O
pltrelsz	O
!=	O
0	int
)	O
{	O
bfd_vma	long
ent	O
,	O
end	*(*(char))
;	O
size_t	long
offset	long
,	O
rel_offset	O
;	O
unsigned	O
long	O
count	int
,	O
i	*(struct)
;	O
unsigned	O
char	O
*	O
data	*(void)
;	O
int	O
addr_size	O
,	O
sym_width	O
;	O
Elf_Internal_Rela	O
*	O
rels	O
;	O
rel_offset	O
=	O
offset_from_vma	O
(	O
filedata	O
,	O
jmprel	O
,	O
pltrelsz	O
)	O
;	O
if	O
(	O
pltrel	O
==	O
DT_RELA	O
)	O
{	O
if	O
(	O
!	O
slurp_rela_relocs	O
(	O
filedata	O
,	O
rel_offset	O
,	O
pltrelsz	O
,	O
&	O
rels	O
,	O
&	O
count	int
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
slurp_rel_relocs	O
(	O
filedata	O
,	O
rel_offset	O
,	O
pltrelsz	O
,	O
&	O
rels	O
,	O
&	O
count	int
)	O
)	O
return	O
FALSE	O
;	O
}	O
ent	O
=	O
mips_pltgot	O
;	O
addr_size	O
=	O
(	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
)	O
;	O
end	*(*(char))
=	O
mips_pltgot	O
+	O
(	O
2	int
+	O
count	int
)	O
*	O
addr_size	O
;	O
offset	long
=	O
offset_from_vma	O
(	O
filedata	O
,	O
mips_pltgot	O
,	O
end	*(*(char))
-	O
mips_pltgot	O
)	O
;	O
data	*(void)
=	O
(	O
unsigned	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
offset	long
,	O
end	*(*(char))
-	O
mips_pltgot	O
,	O
1	int
,	O
_	O
(	O
"Procedure Linkage Table data"	*(char)
)	O
)	O
;	O
if	O
(	O
data	*(void)
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
printf	(*(char))->(int)
(	O
"\nPLT GOT:\n\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Reserved entries:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  %*s %*s Purpose\n"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Address"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Initial"	*(char)
)	O
)	O
;	O
ent	O
=	O
print_mips_pltgot_entry	O
(	O
data	*(void)
,	O
mips_pltgot	O
,	O
ent	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" PLT lazy resolver\n"	*(char)
)	O
)	O
;	O
ent	O
=	O
print_mips_pltgot_entry	O
(	O
data	*(void)
,	O
mips_pltgot	O
,	O
ent	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Module pointer\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
" Entries:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  %*s %*s %*s %-7s %3s %s\n"	*(char)
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Address"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Initial"	*(char)
)	O
,	O
addr_size	O
*	O
2	int
,	O
_	O
(	O
"Sym.Val."	*(char)
)	O
,	O
_	O
(	O
"Type"	*(char)
)	O
,	O
_	O
(	O
"Ndx"	*(char)
)	O
,	O
_	O
(	O
"Name"	*(char)
)	O
)	O
;	O
sym_width	O
=	O
(	O
is_32bit_elf	O
?	O
80	int
:	O
160	int
)	O
-	O
17	int
-	O
addr_size	O
*	O
6	int
-	O
1	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
count	int
;	O
i	*(struct)
++	O
)	O
{	O
unsigned	O
long	O
idx	O
=	O
get_reloc_symindex	O
(	O
rels	O
[	O
i	*(struct)
]	O
.	O
r_info	O
)	O
;	O
ent	O
=	O
print_mips_pltgot_entry	O
(	O
data	*(void)
,	O
mips_pltgot	O
,	O
ent	O
)	O
;	O
printf	(*(char))->(int)
(	O
" "	*(char)
)	O
;	O
if	O
(	O
idx	O
>=	O
num_dynamic_syms	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt symbol index: %lu>"	*(char)
)	O
,	O
idx	O
)	O
;	O
else	O
{	O
Elf_Internal_Sym	O
*	O
psym	O
=	O
dynamic_symbols	O
+	O
idx	O
;	O
print_vma	O
(	O
psym	O
->	O
st_value	O
,	O
LONG_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %-7s %3s "	*(char)
,	O
get_symbol_type	O
(	O
filedata	O
,	O
ELF_ST_TYPE	O
(	O
psym	O
->	O
st_info	O
)	O
)	O
,	O
get_symbol_index_type	O
(	O
filedata	O
,	O
psym	O
->	O
st_shndx	O
)	O
)	O
;	O
if	O
(	O
VALID_DYNAMIC_NAME	O
(	O
psym	O
->	O
st_name	O
)	O
)	O
print_symbol	O
(	O
sym_width	O
,	O
GET_DYNAMIC_NAME	O
(	O
psym	O
->	O
st_name	O
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt: %14ld>"	*(char)
)	O
,	O
psym	O
->	O
st_name	O
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
if	O
(	O
data	*(void)
)	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
rels	O
)	O
;	O
}	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
process_nds32_specific	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
sect	*(struct)
=	O
NULL	O
;	O
sect	*(struct)
=	O
find_section	O
(	O
filedata	O
,	O
".nds32_e_flags"	*(char)
)	O
;	O
if	O
(	O
sect	*(struct)
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
*	O
flag	O
;	O
printf	(*(char))->(int)
(	O
"\nNDS32 elf flags section:\n"	*(char)
)	O
;	O
flag	O
=	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
sect	*(struct)
->	O
sh_offset	O
,	O
1	int
,	O
sect	*(struct)
->	O
sh_size	O
,	O
_	O
(	O
"NDS32 elf flags section"	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
flag	O
)	O
return	O
FALSE	O
;	O
switch	O
(	O
(	O
*	O
flag	O
)	O
&	O
0x3	int
)	O
{	O
case	O
0	int
:	O
printf	(*(char))->(int)
(	O
"(VEC_SIZE):\tNo entry.\n"	*(char)
)	O
;	O
break	O
;	O
case	O
1	int
:	O
printf	(*(char))->(int)
(	O
"(VEC_SIZE):\t4 bytes\n"	*(char)
)	O
;	O
break	O
;	O
case	O
2	int
:	O
printf	(*(char))->(int)
(	O
"(VEC_SIZE):\t16 bytes\n"	*(char)
)	O
;	O
break	O
;	O
case	O
3	int
:	O
printf	(*(char))->(int)
(	O
"(VEC_SIZE):\treserved\n"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
process_gnu_liblist	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
Elf_Internal_Shdr	O
*	O
string_sec	O
;	O
Elf32_External_Lib	O
*	O
elib	O
;	O
char	O
*	O
strtab	O
;	O
size_t	long
strtab_size	O
;	O
size_t	long
cnt	O
;	O
unsigned	O
long	O
num_liblist	O
;	O
unsigned	O
i	*(struct)
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
if	O
(	O
!	O
do_arch	O
)	O
return	O
TRUE	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
i	*(struct)
++	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
)	O
{	O
switch	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
)	O
{	O
case	O
SHT_GNU_LIBLIST	O
:	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
>=	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
break	O
;	O
elib	O
=	O
(	O
Elf32_External_Lib	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
1	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
_	O
(	O
"liblist section data"	*(char)
)	O
)	O
;	O
if	O
(	O
elib	O
==	O
NULL	O
)	O
{	O
res	O
=	O
FALSE	O
;	O
break	O
;	O
}	O
string_sec	O
=	O
filedata	O
->	O
section_headers	O
+	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_link	O
;	O
strtab	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
string_sec	O
->	O
sh_offset	O
,	O
1	int
,	O
string_sec	O
->	O
sh_size	O
,	O
_	O
(	O
"liblist string table"	*(char)
)	O
)	O
;	O
if	O
(	O
strtab	O
==	O
NULL	O
||	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_entsize	O
!=	O
sizeof	O
(	O
Elf32_External_Lib	O
)	O
)	O
{	O
free	(*(void))->(void)
(	O
elib	O
)	O
;	O
free	(*(void))->(void)
(	O
strtab	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
break	O
;	O
}	O
strtab_size	O
=	O
string_sec	O
->	O
sh_size	O
;	O
num_liblist	O
=	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
/	O
sizeof	O
(	O
Elf32_External_Lib	O
)	O
;	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"\nLibrary list section '%s' contains %lu entries:\n"	*(char)
,	O
"\nLibrary list section '%s' contains %lu entries:\n"	*(char)
,	O
num_liblist	O
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
,	O
num_liblist	O
)	O
;	O
puts	(*(char))->(int)
(	O
_	O
(	O
"     Library              Time Stamp          Checksum   Version Flags"	*(char)
)	O
)	O
;	O
for	O
(	O
cnt	O
=	O
0	int
;	O
cnt	O
<	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
/	O
sizeof	O
(	O
Elf32_External_Lib	O
)	O
;	O
++	O
cnt	O
)	O
{	O
Elf32_Lib	O
liblist	O
;	O
time_t	long
atime	O
;	O
char	O
timebuf	O
[	O
128	int
]	O
;	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
tmp	O
;	O
liblist	O
.	O
l_name	O
=	O
BYTE_GET	O
(	O
elib	O
[	O
cnt	O
]	O
.	O
l_name	O
)	O
;	O
atime	O
=	O
BYTE_GET	O
(	O
elib	O
[	O
cnt	O
]	O
.	O
l_time_stamp	O
)	O
;	O
liblist	O
.	O
l_checksum	O
=	O
BYTE_GET	O
(	O
elib	O
[	O
cnt	O
]	O
.	O
l_checksum	O
)	O
;	O
liblist	O
.	O
l_version	O
=	O
BYTE_GET	O
(	O
elib	O
[	O
cnt	O
]	O
.	O
l_version	O
)	O
;	O
liblist	O
.	O
l_flags	O
=	O
BYTE_GET	O
(	O
elib	O
[	O
cnt	O
]	O
.	O
l_flags	O
)	O
;	O
tmp	O
=	O
gmtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
atime	O
)	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
timebuf	O
,	O
sizeof	O
(	O
timebuf	O
)	O
,	O
"%04u-%02u-%02uT%02u:%02u:%02u"	*(char)
,	O
tmp	O
->	O
tm_year	int
+	O
1900	int
,	O
tmp	O
->	O
tm_mon	int
+	O
1	int
,	O
tmp	O
->	O
tm_mday	int
,	O
tmp	O
->	O
tm_hour	int
,	O
tmp	O
->	O
tm_min	int
,	O
tmp	O
->	O
tm_sec	int
)	O
;	O
printf	(*(char))->(int)
(	O
"%3lu: "	*(char)
,	O
(	O
unsigned	O
long	O
)	O
cnt	O
)	O
;	O
if	O
(	O
do_wide	O
)	O
printf	(*(char))->(int)
(	O
"%-20s"	*(char)
,	O
liblist	O
.	O
l_name	O
<	O
strtab_size	O
?	O
strtab	O
+	O
liblist	O
.	O
l_name	O
:	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%-20.20s"	*(char)
,	O
liblist	O
.	O
l_name	O
<	O
strtab_size	O
?	O
strtab	O
+	O
liblist	O
.	O
l_name	O
:	O
_	O
(	O
"<corrupt>"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
" %s %#010lx %-7ld %-7ld\n"	*(char)
,	O
timebuf	O
,	O
liblist	O
.	O
l_checksum	O
,	O
liblist	O
.	O
l_version	O
,	O
liblist	O
.	O
l_flags	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
elib	O
)	O
;	O
free	(*(void))->(void)
(	O
strtab	O
)	O
;	O
}	O
}	O
return	O
res	O
;	O
}	O
static	O
const	O
char	O
*	O
get_note_type	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
e_type	O
)	O
{	O
static	O
char	O
buff	O
[	O
64	int
]	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_type	O
==	O
ET_CORE	O
)	O
switch	O
(	O
e_type	O
)	O
{	O
case	O
NT_AUXV	O
:	O
return	O
_	O
(	O
"NT_AUXV (auxiliary vector)"	*(char)
)	O
;	O
case	O
NT_PRSTATUS	O
:	O
return	O
_	O
(	O
"NT_PRSTATUS (prstatus structure)"	*(char)
)	O
;	O
case	O
NT_FPREGSET	O
:	O
return	O
_	O
(	O
"NT_FPREGSET (floating point registers)"	*(char)
)	O
;	O
case	O
NT_PRPSINFO	O
:	O
return	O
_	O
(	O
"NT_PRPSINFO (prpsinfo structure)"	*(char)
)	O
;	O
case	O
NT_TASKSTRUCT	O
:	O
return	O
_	O
(	O
"NT_TASKSTRUCT (task structure)"	*(char)
)	O
;	O
case	O
NT_PRXFPREG	O
:	O
return	O
_	O
(	O
"NT_PRXFPREG (user_xfpregs structure)"	*(char)
)	O
;	O
case	O
NT_PPC_VMX	O
:	O
return	O
_	O
(	O
"NT_PPC_VMX (ppc Altivec registers)"	*(char)
)	O
;	O
case	O
NT_PPC_VSX	O
:	O
return	O
_	O
(	O
"NT_PPC_VSX (ppc VSX registers)"	*(char)
)	O
;	O
case	O
NT_PPC_TAR	O
:	O
return	O
_	O
(	O
"NT_PPC_TAR (ppc TAR register)"	*(char)
)	O
;	O
case	O
NT_PPC_PPR	O
:	O
return	O
_	O
(	O
"NT_PPC_PPR (ppc PPR register)"	*(char)
)	O
;	O
case	O
NT_PPC_DSCR	O
:	O
return	O
_	O
(	O
"NT_PPC_DSCR (ppc DSCR register)"	*(char)
)	O
;	O
case	O
NT_PPC_EBB	O
:	O
return	O
_	O
(	O
"NT_PPC_EBB (ppc EBB registers)"	*(char)
)	O
;	O
case	O
NT_PPC_PMU	O
:	O
return	O
_	O
(	O
"NT_PPC_PMU (ppc PMU registers)"	*(char)
)	O
;	O
case	O
NT_PPC_TM_CGPR	O
:	O
return	O
_	O
(	O
"NT_PPC_TM_CGPR (ppc checkpointed GPR registers)"	*(char)
)	O
;	O
case	O
NT_PPC_TM_CFPR	O
:	O
return	O
_	O
(	O
"NT_PPC_TM_CFPR (ppc checkpointed floating point registers)"	*(char)
)	O
;	O
case	O
NT_PPC_TM_CVMX	O
:	O
return	O
_	O
(	O
"NT_PPC_TM_CVMX (ppc checkpointed Altivec registers)"	*(char)
)	O
;	O
case	O
NT_PPC_TM_CVSX	O
:	O
return	O
_	O
(	O
"NT_PPC_TM_CVSX (ppc checkpointed VSX registers)"	*(char)
)	O
;	O
case	O
NT_PPC_TM_SPR	O
:	O
return	O
_	O
(	O
"NT_PPC_TM_SPR (ppc TM special purpose registers)"	*(char)
)	O
;	O
case	O
NT_PPC_TM_CTAR	O
:	O
return	O
_	O
(	O
"NT_PPC_TM_CTAR (ppc checkpointed TAR register)"	*(char)
)	O
;	O
case	O
NT_PPC_TM_CPPR	O
:	O
return	O
_	O
(	O
"NT_PPC_TM_CPPR (ppc checkpointed PPR register)"	*(char)
)	O
;	O
case	O
NT_PPC_TM_CDSCR	O
:	O
return	O
_	O
(	O
"NT_PPC_TM_CDSCR (ppc checkpointed DSCR register)"	*(char)
)	O
;	O
case	O
NT_386_TLS	O
:	O
return	O
_	O
(	O
"NT_386_TLS (x86 TLS information)"	*(char)
)	O
;	O
case	O
NT_386_IOPERM	O
:	O
return	O
_	O
(	O
"NT_386_IOPERM (x86 I/O permissions)"	*(char)
)	O
;	O
case	O
NT_X86_XSTATE	O
:	O
return	O
_	O
(	O
"NT_X86_XSTATE (x86 XSAVE extended state)"	*(char)
)	O
;	O
case	O
NT_S390_HIGH_GPRS	O
:	O
return	O
_	O
(	O
"NT_S390_HIGH_GPRS (s390 upper register halves)"	*(char)
)	O
;	O
case	O
NT_S390_TIMER	O
:	O
return	O
_	O
(	O
"NT_S390_TIMER (s390 timer register)"	*(char)
)	O
;	O
case	O
NT_S390_TODCMP	O
:	O
return	O
_	O
(	O
"NT_S390_TODCMP (s390 TOD comparator register)"	*(char)
)	O
;	O
case	O
NT_S390_TODPREG	O
:	O
return	O
_	O
(	O
"NT_S390_TODPREG (s390 TOD programmable register)"	*(char)
)	O
;	O
case	O
NT_S390_CTRS	O
:	O
return	O
_	O
(	O
"NT_S390_CTRS (s390 control registers)"	*(char)
)	O
;	O
case	O
NT_S390_PREFIX	O
:	O
return	O
_	O
(	O
"NT_S390_PREFIX (s390 prefix register)"	*(char)
)	O
;	O
case	O
NT_S390_LAST_BREAK	O
:	O
return	O
_	O
(	O
"NT_S390_LAST_BREAK (s390 last breaking event address)"	*(char)
)	O
;	O
case	O
NT_S390_SYSTEM_CALL	O
:	O
return	O
_	O
(	O
"NT_S390_SYSTEM_CALL (s390 system call restart data)"	*(char)
)	O
;	O
case	O
NT_S390_TDB	O
:	O
return	O
_	O
(	O
"NT_S390_TDB (s390 transaction diagnostic block)"	*(char)
)	O
;	O
case	O
NT_S390_VXRS_LOW	O
:	O
return	O
_	O
(	O
"NT_S390_VXRS_LOW (s390 vector registers 0-15 upper half)"	*(char)
)	O
;	O
case	O
NT_S390_VXRS_HIGH	O
:	O
return	O
_	O
(	O
"NT_S390_VXRS_HIGH (s390 vector registers 16-31)"	*(char)
)	O
;	O
case	O
NT_S390_GS_CB	O
:	O
return	O
_	O
(	O
"NT_S390_GS_CB (s390 guarded-storage registers)"	*(char)
)	O
;	O
case	O
NT_S390_GS_BC	O
:	O
return	O
_	O
(	O
"NT_S390_GS_BC (s390 guarded-storage broadcast control)"	*(char)
)	O
;	O
case	O
NT_ARM_VFP	O
:	O
return	O
_	O
(	O
"NT_ARM_VFP (arm VFP registers)"	*(char)
)	O
;	O
case	O
NT_ARM_TLS	O
:	O
return	O
_	O
(	O
"NT_ARM_TLS (AArch TLS registers)"	*(char)
)	O
;	O
case	O
NT_ARM_HW_BREAK	O
:	O
return	O
_	O
(	O
"NT_ARM_HW_BREAK (AArch hardware breakpoint registers)"	*(char)
)	O
;	O
case	O
NT_ARM_HW_WATCH	O
:	O
return	O
_	O
(	O
"NT_ARM_HW_WATCH (AArch hardware watchpoint registers)"	*(char)
)	O
;	O
case	O
NT_PSTATUS	O
:	O
return	O
_	O
(	O
"NT_PSTATUS (pstatus structure)"	*(char)
)	O
;	O
case	O
NT_FPREGS	O
:	O
return	O
_	O
(	O
"NT_FPREGS (floating point registers)"	*(char)
)	O
;	O
case	O
NT_PSINFO	O
:	O
return	O
_	O
(	O
"NT_PSINFO (psinfo structure)"	*(char)
)	O
;	O
case	O
NT_LWPSTATUS	O
:	O
return	O
_	O
(	O
"NT_LWPSTATUS (lwpstatus_t structure)"	*(char)
)	O
;	O
case	O
NT_LWPSINFO	O
:	O
return	O
_	O
(	O
"NT_LWPSINFO (lwpsinfo_t structure)"	*(char)
)	O
;	O
case	O
NT_WIN32PSTATUS	O
:	O
return	O
_	O
(	O
"NT_WIN32PSTATUS (win32_pstatus structure)"	*(char)
)	O
;	O
case	O
NT_SIGINFO	O
:	O
return	O
_	O
(	O
"NT_SIGINFO (siginfo_t data)"	*(char)
)	O
;	O
case	O
NT_FILE	O
:	O
return	O
_	O
(	O
"NT_FILE (mapped files)"	*(char)
)	O
;	O
default	O
:	O
break	O
;	O
}	O
else	O
switch	O
(	O
e_type	O
)	O
{	O
case	O
NT_VERSION	O
:	O
return	O
_	O
(	O
"NT_VERSION (version)"	*(char)
)	O
;	O
case	O
NT_ARCH	O
:	O
return	O
_	O
(	O
"NT_ARCH (architecture)"	*(char)
)	O
;	O
case	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	O
:	O
return	O
_	O
(	O
"OPEN"	*(char)
)	O
;	O
case	O
NT_GNU_BUILD_ATTRIBUTE_FUNC	O
:	O
return	O
_	O
(	O
"func"	*(char)
)	O
;	O
default	O
:	O
break	O
;	O
}	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	*(char)
)	O
,	O
e_type	O
)	O
;	O
return	O
buff	O
;	O
}	O
static	O
bfd_boolean	int
print_core_note	O
(	O
Elf_Internal_Note	O
*	O
pnote	O
)	O
{	O
unsigned	O
int	O
addr_size	O
=	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
;	O
bfd_vma	long
count	int
,	O
page_size	O
;	O
unsigned	O
char	O
*	O
descdata	O
,	O
*	O
filenames	O
,	O
*	O
descend	O
;	O
if	O
(	O
pnote	O
->	O
type	enum(int,int,int,int)
!=	O
NT_FILE	O
)	O
{	O
if	O
(	O
do_wide	O
)	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
pnote	O
->	O
descsz	O
<	O
2	int
*	O
addr_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"    Malformed note - too short for header\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
descdata	O
=	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
;	O
descend	O
=	O
descdata	O
+	O
pnote	O
->	O
descsz	O
;	O
if	O
(	O
descdata	O
[	O
pnote	O
->	O
descsz	O
-	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
error	O
(	O
_	O
(	O
"    Malformed note - does not end with \\0\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
count	int
=	O
byte_get	O
(	O
descdata	O
,	O
addr_size	O
)	O
;	O
descdata	O
+=	O
addr_size	O
;	O
page_size	O
=	O
byte_get	O
(	O
descdata	O
,	O
addr_size	O
)	O
;	O
descdata	O
+=	O
addr_size	O
;	O
if	O
(	O
count	int
>	O
(	O
(	O
bfd_vma	long
)	O
-	O
1	int
-	O
2	int
*	O
addr_size	O
)	O
/	O
(	O
3	int
*	O
addr_size	O
)	O
||	O
pnote	O
->	O
descsz	O
<	O
2	int
*	O
addr_size	O
+	O
count	int
*	O
3	int
*	O
addr_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"    Malformed note - too short for supplied file count\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Page size: "	*(char)
)	O
)	O
;	O
print_vma	O
(	O
page_size	O
,	O
DEC	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    %*s%*s%*s\n"	*(char)
)	O
,	O
(	O
int	O
)	O
(	O
2	int
+	O
2	int
*	O
addr_size	O
)	O
,	O
_	O
(	O
"Start"	*(char)
)	O
,	O
(	O
int	O
)	O
(	O
4	int
+	O
2	int
*	O
addr_size	O
)	O
,	O
_	O
(	O
"End"	*(char)
)	O
,	O
(	O
int	O
)	O
(	O
4	int
+	O
2	int
*	O
addr_size	O
)	O
,	O
_	O
(	O
"Page Offset"	*(char)
)	O
)	O
;	O
filenames	O
=	O
descdata	O
+	O
count	int
*	O
3	int
*	O
addr_size	O
;	O
while	O
(	O
count	int
--	O
>	O
0	int
)	O
{	O
bfd_vma	long
start	O
,	O
end	*(*(char))
,	O
file_ofs	O
;	O
if	O
(	O
filenames	O
==	O
descend	O
)	O
{	O
error	O
(	O
_	O
(	O
"    Malformed note - filenames end too early\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
start	O
=	O
byte_get	O
(	O
descdata	O
,	O
addr_size	O
)	O
;	O
descdata	O
+=	O
addr_size	O
;	O
end	*(*(char))
=	O
byte_get	O
(	O
descdata	O
,	O
addr_size	O
)	O
;	O
descdata	O
+=	O
addr_size	O
;	O
file_ofs	O
=	O
byte_get	O
(	O
descdata	O
,	O
addr_size	O
)	O
;	O
descdata	O
+=	O
addr_size	O
;	O
printf	(*(char))->(int)
(	O
"    "	*(char)
)	O
;	O
print_vma	O
(	O
start	O
,	O
FULL_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  "	*(char)
)	O
;	O
print_vma	O
(	O
end	*(*(char))
,	O
FULL_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"  "	*(char)
)	O
;	O
print_vma	O
(	O
file_ofs	O
,	O
FULL_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n        %s\n"	*(char)
,	O
filenames	O
)	O
;	O
filenames	O
+=	O
1	int
+	O
strlen	(*(char))->(long)
(	O
(	O
char	O
*	O
)	O
filenames	O
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
get_gnu_elf_note_type	O
(	O
unsigned	O
e_type	O
)	O
{	O
switch	O
(	O
e_type	O
)	O
{	O
case	O
NT_GNU_ABI_TAG	O
:	O
return	O
_	O
(	O
"NT_GNU_ABI_TAG (ABI version tag)"	*(char)
)	O
;	O
case	O
NT_GNU_HWCAP	O
:	O
return	O
_	O
(	O
"NT_GNU_HWCAP (DSO-supplied software HWCAP info)"	*(char)
)	O
;	O
case	O
NT_GNU_BUILD_ID	O
:	O
return	O
_	O
(	O
"NT_GNU_BUILD_ID (unique build ID bitstring)"	*(char)
)	O
;	O
case	O
NT_GNU_GOLD_VERSION	O
:	O
return	O
_	O
(	O
"NT_GNU_GOLD_VERSION (gold version)"	*(char)
)	O
;	O
case	O
NT_GNU_PROPERTY_TYPE_0	O
:	O
return	O
_	O
(	O
"NT_GNU_PROPERTY_TYPE_0"	*(char)
)	O
;	O
case	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	O
:	O
return	O
_	O
(	O
"NT_GNU_BUILD_ATTRIBUTE_OPEN"	*(char)
)	O
;	O
case	O
NT_GNU_BUILD_ATTRIBUTE_FUNC	O
:	O
return	O
_	O
(	O
"NT_GNU_BUILD_ATTRIBUTE_FUNC"	*(char)
)	O
;	O
default	O
:	O
{	O
static	O
char	O
buff	O
[	O
64	int
]	O
;	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	*(char)
)	O
,	O
e_type	O
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
}	O
static	O
void	O
decode_x86_compat_isa	O
(	O
unsigned	O
int	O
bitmask	O
)	O
{	O
while	O
(	O
bitmask	O
)	O
{	O
unsigned	O
int	O
bit	O
=	O
bitmask	O
&	O
(	O
-	O
bitmask	O
)	O
;	O
bitmask	O
&=	O
~	O
bit	O
;	O
switch	O
(	O
bit	O
)	O
{	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_486	O
:	O
printf	(*(char))->(int)
(	O
"i486"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_586	O
:	O
printf	(*(char))->(int)
(	O
"586"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_686	O
:	O
printf	(*(char))->(int)
(	O
"686"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSE	O
:	O
printf	(*(char))->(int)
(	O
"SSE"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSE2	O
:	O
printf	(*(char))->(int)
(	O
"SSE2"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSE3	O
:	O
printf	(*(char))->(int)
(	O
"SSE3"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSSE3	O
:	O
printf	(*(char))->(int)
(	O
"SSSE3"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSE4_1	O
:	O
printf	(*(char))->(int)
(	O
"SSE4_1"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_SSE4_2	O
:	O
printf	(*(char))->(int)
(	O
"SSE4_2"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX	O
:	O
printf	(*(char))->(int)
(	O
"AVX"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX2	O
:	O
printf	(*(char))->(int)
(	O
"AVX2"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512F	O
:	O
printf	(*(char))->(int)
(	O
"AVX512F"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512CD	O
:	O
printf	(*(char))->(int)
(	O
"AVX512CD"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512ER	O
:	O
printf	(*(char))->(int)
(	O
"AVX512ER"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512PF	O
:	O
printf	(*(char))->(int)
(	O
"AVX512PF"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512VL	O
:	O
printf	(*(char))->(int)
(	O
"AVX512VL"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512DQ	O
:	O
printf	(*(char))->(int)
(	O
"AVX512DQ"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512BW	O
:	O
printf	(*(char))->(int)
(	O
"AVX512BW"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<unknown: %x>"	*(char)
)	O
,	O
bit	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
bitmask	O
)	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
decode_x86_isa	O
(	O
unsigned	O
int	O
bitmask	O
)	O
{	O
if	O
(	O
!	O
bitmask	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<None>"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
bitmask	O
)	O
{	O
unsigned	O
int	O
bit	O
=	O
bitmask	O
&	O
(	O
-	O
bitmask	O
)	O
;	O
bitmask	O
&=	O
~	O
bit	O
;	O
switch	O
(	O
bit	O
)	O
{	O
case	O
GNU_PROPERTY_X86_ISA_1_CMOV	O
:	O
printf	(*(char))->(int)
(	O
"CMOV"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSE	O
:	O
printf	(*(char))->(int)
(	O
"SSE"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSE2	O
:	O
printf	(*(char))->(int)
(	O
"SSE2"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSE3	O
:	O
printf	(*(char))->(int)
(	O
"SSE3"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSSE3	O
:	O
printf	(*(char))->(int)
(	O
"SSSE3"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSE4_1	O
:	O
printf	(*(char))->(int)
(	O
"SSE4_1"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_SSE4_2	O
:	O
printf	(*(char))->(int)
(	O
"SSE4_2"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX	O
:	O
printf	(*(char))->(int)
(	O
"AVX"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX2	O
:	O
printf	(*(char))->(int)
(	O
"AVX2"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_FMA	O
:	O
printf	(*(char))->(int)
(	O
"FMA"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512F	O
:	O
printf	(*(char))->(int)
(	O
"AVX512F"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512CD	O
:	O
printf	(*(char))->(int)
(	O
"AVX512CD"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512ER	O
:	O
printf	(*(char))->(int)
(	O
"AVX512ER"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512PF	O
:	O
printf	(*(char))->(int)
(	O
"AVX512PF"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512VL	O
:	O
printf	(*(char))->(int)
(	O
"AVX512VL"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512DQ	O
:	O
printf	(*(char))->(int)
(	O
"AVX512DQ"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512BW	O
:	O
printf	(*(char))->(int)
(	O
"AVX512BW"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_4FMAPS	O
:	O
printf	(*(char))->(int)
(	O
"AVX512_4FMAPS"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_4VNNIW	O
:	O
printf	(*(char))->(int)
(	O
"AVX512_4VNNIW"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_BITALG	O
:	O
printf	(*(char))->(int)
(	O
"AVX512_BITALG"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_IFMA	O
:	O
printf	(*(char))->(int)
(	O
"AVX512_IFMA"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_VBMI	O
:	O
printf	(*(char))->(int)
(	O
"AVX512_VBMI"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_VBMI2	O
:	O
printf	(*(char))->(int)
(	O
"AVX512_VBMI2"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_VNNI	O
:	O
printf	(*(char))->(int)
(	O
"AVX512_VNNI"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_ISA_1_AVX512_BF16	O
:	O
printf	(*(char))->(int)
(	O
"AVX512_BF16"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<unknown: %x>"	*(char)
)	O
,	O
bit	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
bitmask	O
)	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
decode_x86_feature_1	O
(	O
unsigned	O
int	O
bitmask	O
)	O
{	O
if	O
(	O
!	O
bitmask	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<None>"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
bitmask	O
)	O
{	O
unsigned	O
int	O
bit	O
=	O
bitmask	O
&	O
(	O
-	O
bitmask	O
)	O
;	O
bitmask	O
&=	O
~	O
bit	O
;	O
switch	O
(	O
bit	O
)	O
{	O
case	O
GNU_PROPERTY_X86_FEATURE_1_IBT	O
:	O
printf	(*(char))->(int)
(	O
"IBT"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_1_SHSTK	O
:	O
printf	(*(char))->(int)
(	O
"SHSTK"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<unknown: %x>"	*(char)
)	O
,	O
bit	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
bitmask	O
)	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
decode_x86_feature_2	O
(	O
unsigned	O
int	O
bitmask	O
)	O
{	O
if	O
(	O
!	O
bitmask	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<None>"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
bitmask	O
)	O
{	O
unsigned	O
int	O
bit	O
=	O
bitmask	O
&	O
(	O
-	O
bitmask	O
)	O
;	O
bitmask	O
&=	O
~	O
bit	O
;	O
switch	O
(	O
bit	O
)	O
{	O
case	O
GNU_PROPERTY_X86_FEATURE_2_X86	O
:	O
printf	(*(char))->(int)
(	O
"x86"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_X87	O
:	O
printf	(*(char))->(int)
(	O
"x87"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_MMX	O
:	O
printf	(*(char))->(int)
(	O
"MMX"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_XMM	O
:	O
printf	(*(char))->(int)
(	O
"XMM"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_YMM	O
:	O
printf	(*(char))->(int)
(	O
"YMM"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_ZMM	O
:	O
printf	(*(char))->(int)
(	O
"ZMM"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_FXSR	O
:	O
printf	(*(char))->(int)
(	O
"FXSR"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_XSAVE	O
:	O
printf	(*(char))->(int)
(	O
"XSAVE"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_XSAVEOPT	O
:	O
printf	(*(char))->(int)
(	O
"XSAVEOPT"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_XSAVEC	O
:	O
printf	(*(char))->(int)
(	O
"XSAVEC"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<unknown: %x>"	*(char)
)	O
,	O
bit	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
bitmask	O
)	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
decode_aarch64_feature_1_and	O
(	O
unsigned	O
int	O
bitmask	O
)	O
{	O
while	O
(	O
bitmask	O
)	O
{	O
unsigned	O
int	O
bit	O
=	O
bitmask	O
&	O
(	O
-	O
bitmask	O
)	O
;	O
bitmask	O
&=	O
~	O
bit	O
;	O
switch	O
(	O
bit	O
)	O
{	O
case	O
GNU_PROPERTY_AARCH64_FEATURE_1_BTI	O
:	O
printf	(*(char))->(int)
(	O
"BTI"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_PROPERTY_AARCH64_FEATURE_1_PAC	O
:	O
printf	(*(char))->(int)
(	O
"PAC"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<unknown: %x>"	*(char)
)	O
,	O
bit	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
bitmask	O
)	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
print_gnu_property_note	O
(	O
Filedata	O
*	O
filedata	O
,	O
Elf_Internal_Note	O
*	O
pnote	O
)	O
{	O
unsigned	O
char	O
*	O
ptr	*(*(char))
=	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
;	O
unsigned	O
char	O
*	O
ptr_end	O
=	O
ptr	*(*(char))
+	O
pnote	O
->	O
descsz	O
;	O
unsigned	O
int	O
size	int
=	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      Properties: "	*(char)
)	O
)	O
;	O
if	O
(	O
pnote	O
->	O
descsz	O
<	O
8	int
||	O
(	O
pnote	O
->	O
descsz	O
%	O
size	int
)	O
!=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt GNU_PROPERTY_TYPE, size = %#lx>\n"	*(char)
)	O
,	O
pnote	O
->	O
descsz	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
ptr	*(*(char))
<	O
ptr_end	O
)	O
{	O
unsigned	O
int	O
j	O
;	O
unsigned	O
int	O
type	enum(int,int,int,int)
;	O
unsigned	O
int	O
datasz	O
;	O
if	O
(	O
(	O
size_t	long
)	O
(	O
ptr_end	O
-	O
ptr	*(*(char))
)	O
<	O
8	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt descsz: %#lx>\n"	*(char)
)	O
,	O
pnote	O
->	O
descsz	O
)	O
;	O
break	O
;	O
}	O
type	enum(int,int,int,int)
=	O
byte_get	O
(	O
ptr	*(*(char))
,	O
4	int
)	O
;	O
datasz	O
=	O
byte_get	O
(	O
ptr	*(*(char))
+	O
4	int
,	O
4	int
)	O
;	O
ptr	*(*(char))
+=	O
8	int
;	O
if	O
(	O
datasz	O
>	O
(	O
size_t	long
)	O
(	O
ptr_end	O
-	O
ptr	*(*(char))
)	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt type (%#x) datasz: %#x>\n"	*(char)
)	O
,	O
type	enum(int,int,int,int)
,	O
datasz	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
type	enum(int,int,int,int)
>=	O
GNU_PROPERTY_LOPROC	O
&&	O
type	enum(int,int,int,int)
<=	O
GNU_PROPERTY_HIPROC	O
)	O
{	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_X86_64	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_IAMCU	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_386	O
)	O
{	O
unsigned	O
int	O
bitmask	O
;	O
if	O
(	O
datasz	O
==	O
4	int
)	O
bitmask	O
=	O
byte_get	O
(	O
ptr	*(*(char))
,	O
4	int
)	O
;	O
else	O
bitmask	O
=	O
0	int
;	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
GNU_PROPERTY_X86_ISA_1_USED	O
:	O
if	O
(	O
datasz	O
!=	O
4	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"x86 ISA used: <corrupt length: %#x> "	*(char)
)	O
,	O
datasz	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"x86 ISA used: "	*(char)
)	O
;	O
decode_x86_isa	O
(	O
bitmask	O
)	O
;	O
}	O
goto	O
next	*(char)
;	O
case	O
GNU_PROPERTY_X86_ISA_1_NEEDED	O
:	O
if	O
(	O
datasz	O
!=	O
4	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"x86 ISA needed: <corrupt length: %#x> "	*(char)
)	O
,	O
datasz	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"x86 ISA needed: "	*(char)
)	O
;	O
decode_x86_isa	O
(	O
bitmask	O
)	O
;	O
}	O
goto	O
next	*(char)
;	O
case	O
GNU_PROPERTY_X86_FEATURE_1_AND	O
:	O
if	O
(	O
datasz	O
!=	O
4	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"x86 feature: <corrupt length: %#x> "	*(char)
)	O
,	O
datasz	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"x86 feature: "	*(char)
)	O
;	O
decode_x86_feature_1	O
(	O
bitmask	O
)	O
;	O
}	O
goto	O
next	*(char)
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_USED	O
:	O
if	O
(	O
datasz	O
!=	O
4	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"x86 feature used: <corrupt length: %#x> "	*(char)
)	O
,	O
datasz	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"x86 feature used: "	*(char)
)	O
;	O
decode_x86_feature_2	O
(	O
bitmask	O
)	O
;	O
}	O
goto	O
next	*(char)
;	O
case	O
GNU_PROPERTY_X86_FEATURE_2_NEEDED	O
:	O
if	O
(	O
datasz	O
!=	O
4	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"x86 feature needed: <corrupt length: %#x> "	*(char)
)	O
,	O
datasz	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"x86 feature needed: "	*(char)
)	O
;	O
decode_x86_feature_2	O
(	O
bitmask	O
)	O
;	O
}	O
goto	O
next	*(char)
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_USED	O
:	O
if	O
(	O
datasz	O
!=	O
4	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"x86 ISA used: <corrupt length: %#x> "	*(char)
)	O
,	O
datasz	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"x86 ISA used: "	*(char)
)	O
;	O
decode_x86_compat_isa	O
(	O
bitmask	O
)	O
;	O
}	O
goto	O
next	*(char)
;	O
case	O
GNU_PROPERTY_X86_COMPAT_ISA_1_NEEDED	O
:	O
if	O
(	O
datasz	O
!=	O
4	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"x86 ISA needed: <corrupt length: %#x> "	*(char)
)	O
,	O
datasz	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"x86 ISA needed: "	*(char)
)	O
;	O
decode_x86_compat_isa	O
(	O
bitmask	O
)	O
;	O
}	O
goto	O
next	*(char)
;	O
default	O
:	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_AARCH64	O
)	O
{	O
if	O
(	O
type	enum(int,int,int,int)
==	O
GNU_PROPERTY_AARCH64_FEATURE_1_AND	O
)	O
{	O
printf	(*(char))->(int)
(	O
"AArch64 feature: "	*(char)
)	O
;	O
if	O
(	O
datasz	O
!=	O
4	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt length: %#x> "	*(char)
)	O
,	O
datasz	O
)	O
;	O
else	O
decode_aarch64_feature_1_and	O
(	O
byte_get	O
(	O
ptr	*(*(char))
,	O
4	int
)	O
)	O
;	O
goto	O
next	*(char)
;	O
}	O
}	O
}	O
else	O
{	O
switch	O
(	O
type	enum(int,int,int,int)
)	O
{	O
case	O
GNU_PROPERTY_STACK_SIZE	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"stack size: "	*(char)
)	O
)	O
;	O
if	O
(	O
datasz	O
!=	O
size	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt length: %#x> "	*(char)
)	O
,	O
datasz	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"%#lx"	*(char)
,	O
(	O
unsigned	O
long	O
)	O
byte_get	O
(	O
ptr	*(*(char))
,	O
size	int
)	O
)	O
;	O
goto	O
next	*(char)
;	O
case	O
GNU_PROPERTY_NO_COPY_ON_PROTECTED	O
:	O
printf	(*(char))->(int)
(	O
"no copy on protected "	*(char)
)	O
;	O
if	O
(	O
datasz	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<corrupt length: %#x> "	*(char)
)	O
,	O
datasz	O
)	O
;	O
goto	O
next	*(char)
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
type	enum(int,int,int,int)
<	O
GNU_PROPERTY_LOPROC	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<unknown type %#x data: "	*(char)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
else	O
if	O
(	O
type	enum(int,int,int,int)
<	O
GNU_PROPERTY_LOUSER	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<procesor-specific type %#x data: "	*(char)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"<application-specific type %#x data: "	*(char)
)	O
,	O
type	enum(int,int,int,int)
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
datasz	O
;	O
++	O
j	O
)	O
printf	(*(char))->(int)
(	O
"%02x "	*(char)
,	O
ptr	*(*(char))
[	O
j	O
]	O
&	O
0xff	int
)	O
;	O
printf	(*(char))->(int)
(	O
">"	*(char)
)	O
;	O
next	*(char)
:	O
ptr	*(*(char))
+=	O
(	O
(	O
datasz	O
+	O
(	O
size	int
-	O
1	int
)	O
)	O
&	O
~	O
(	O
size	int
-	O
1	int
)	O
)	O
;	O
if	O
(	O
ptr	*(*(char))
==	O
ptr_end	O
)	O
break	O
;	O
if	O
(	O
do_wide	O
)	O
printf	(*(char))->(int)
(	O
", "	*(char)
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"\n\t"	*(char)
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
static	O
bfd_boolean	int
print_gnu_note	O
(	O
Filedata	O
*	O
filedata	O
,	O
Elf_Internal_Note	O
*	O
pnote	O
)	O
{	O
switch	O
(	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
NT_GNU_BUILD_ID	O
:	O
{	O
unsigned	O
long	O
i	*(struct)
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Build ID: "	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
pnote	O
->	O
descsz	O
;	O
++	O
i	*(struct)
)	O
printf	(*(char))->(int)
(	O
"%02x"	*(char)
,	O
pnote	O
->	O
descdata	O
[	O
i	*(struct)
]	O
&	O
0xff	int
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
NT_GNU_ABI_TAG	O
:	O
{	O
unsigned	O
long	O
os	int
,	O
major	O
,	O
minor	O
,	O
subminor	O
;	O
const	O
char	O
*	O
osname	O
;	O
if	O
(	O
pnote	O
->	O
descsz	O
<	O
16	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    <corrupt GNU_ABI_TAG>\n"	*(char)
)	O
)	O
;	O
break	O
;	O
}	O
os	int
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
4	int
)	O
;	O
major	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
+	O
4	int
,	O
4	int
)	O
;	O
minor	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
+	O
8	int
,	O
4	int
)	O
;	O
subminor	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
+	O
12	int
,	O
4	int
)	O
;	O
switch	O
(	O
os	int
)	O
{	O
case	O
GNU_ABI_TAG_LINUX	O
:	O
osname	O
=	O
"Linux"	*(char)
;	O
break	O
;	O
case	O
GNU_ABI_TAG_HURD	O
:	O
osname	O
=	O
"Hurd"	*(char)
;	O
break	O
;	O
case	O
GNU_ABI_TAG_SOLARIS	O
:	O
osname	O
=	O
"Solaris"	*(char)
;	O
break	O
;	O
case	O
GNU_ABI_TAG_FREEBSD	O
:	O
osname	O
=	O
"FreeBSD"	*(char)
;	O
break	O
;	O
case	O
GNU_ABI_TAG_NETBSD	O
:	O
osname	O
=	O
"NetBSD"	*(char)
;	O
break	O
;	O
case	O
GNU_ABI_TAG_SYLLABLE	O
:	O
osname	O
=	O
"Syllable"	*(char)
;	O
break	O
;	O
case	O
GNU_ABI_TAG_NACL	O
:	O
osname	O
=	O
"NaCl"	*(char)
;	O
break	O
;	O
default	O
:	O
osname	O
=	O
"Unknown"	*(char)
;	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    OS: %s, ABI: %ld.%ld.%ld\n"	*(char)
)	O
,	O
osname	O
,	O
major	O
,	O
minor	O
,	O
subminor	O
)	O
;	O
}	O
break	O
;	O
case	O
NT_GNU_GOLD_VERSION	O
:	O
{	O
unsigned	O
long	O
i	*(struct)
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Version: "	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
pnote	O
->	O
descsz	O
&&	O
pnote	O
->	O
descdata	O
[	O
i	*(struct)
]	O
!=	O
'\0'	O
;	O
++	O
i	*(struct)
)	O
printf	(*(char))->(int)
(	O
"%c"	*(char)
,	O
pnote	O
->	O
descdata	O
[	O
i	*(struct)
]	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
NT_GNU_HWCAP	O
:	O
{	O
unsigned	O
long	O
num_entries	O
,	O
mask	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      Hardware Capabilities: "	*(char)
)	O
)	O
;	O
if	O
(	O
pnote	O
->	O
descsz	O
<	O
8	int
)	O
{	O
error	O
(	O
_	O
(	O
"<corrupt GNU_HWCAP>\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
num_entries	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
4	int
)	O
;	O
mask	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
+	O
4	int
,	O
4	int
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"num entries: %ld, enabled mask: %lx\n"	*(char)
)	O
,	O
num_entries	O
,	O
mask	O
)	O
;	O
}	O
break	O
;	O
case	O
NT_GNU_PROPERTY_TYPE_0	O
:	O
print_gnu_property_note	O
(	O
filedata	O
,	O
pnote	O
)	O
;	O
break	O
;	O
default	O
:	O
{	O
unsigned	O
long	O
i	*(struct)
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Description data: "	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
pnote	O
->	O
descsz	O
;	O
++	O
i	*(struct)
)	O
printf	(*(char))->(int)
(	O
"%02x "	*(char)
,	O
pnote	O
->	O
descdata	O
[	O
i	*(struct)
]	O
&	O
0xff	int
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
break	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
char	O
*	O
get_v850_elf_note_type	O
(	O
enum	O
v850_notes	O
n_type	O
)	O
{	O
static	O
char	O
buff	O
[	O
64	int
]	O
;	O
switch	O
(	O
n_type	O
)	O
{	O
case	O
V850_NOTE_ALIGNMENT	O
:	O
return	O
_	O
(	O
"Alignment of 8-byte objects"	*(char)
)	O
;	O
case	O
V850_NOTE_DATA_SIZE	O
:	O
return	O
_	O
(	O
"Sizeof double and long double"	*(char)
)	O
;	O
case	O
V850_NOTE_FPU_INFO	O
:	O
return	O
_	O
(	O
"Type of FPU support needed"	*(char)
)	O
;	O
case	O
V850_NOTE_SIMD_INFO	O
:	O
return	O
_	O
(	O
"Use of SIMD instructions"	*(char)
)	O
;	O
case	O
V850_NOTE_CACHE_INFO	O
:	O
return	O
_	O
(	O
"Use of cache"	*(char)
)	O
;	O
case	O
V850_NOTE_MMU_INFO	O
:	O
return	O
_	O
(	O
"Use of MMU"	*(char)
)	O
;	O
default	O
:	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	*(char)
)	O
,	O
n_type	O
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
bfd_boolean	int
print_v850_note	O
(	O
Elf_Internal_Note	O
*	O
pnote	O
)	O
{	O
unsigned	O
int	O
val	array(int)
;	O
if	O
(	O
pnote	O
->	O
descsz	O
!=	O
4	int
)	O
return	O
FALSE	O
;	O
val	array(int)
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
pnote	O
->	O
descsz	O
)	O
;	O
if	O
(	O
val	array(int)
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"not set\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
switch	O
(	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
V850_NOTE_ALIGNMENT	O
:	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
EF_RH850_DATA_ALIGN4	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"4-byte\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
case	O
EF_RH850_DATA_ALIGN8	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"8-byte\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
case	O
V850_NOTE_DATA_SIZE	O
:	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
EF_RH850_DOUBLE32	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"4-bytes\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
case	O
EF_RH850_DOUBLE64	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"8-bytes\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
case	O
V850_NOTE_FPU_INFO	O
:	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
EF_RH850_FPU20	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"FPU-2.0\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
case	O
EF_RH850_FPU30	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"FPU-3.0\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
case	O
V850_NOTE_MMU_INFO	O
:	O
case	O
V850_NOTE_CACHE_INFO	O
:	O
case	O
V850_NOTE_SIMD_INFO	O
:	O
if	O
(	O
val	array(int)
==	O
EF_RH850_SIMD	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"yes\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
_	O
(	O
"unknown value: %x\n"	*(char)
)	O
,	O
val	array(int)
)	O
;	O
return	O
FALSE	O
;	O
}	O
static	O
bfd_boolean	int
process_netbsd_elf_note	O
(	O
Elf_Internal_Note	O
*	O
pnote	O
)	O
{	O
unsigned	O
int	O
version	*(char)
;	O
switch	O
(	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
NT_NETBSD_IDENT	O
:	O
version	*(char)
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
sizeof	O
(	O
version	*(char)
)	O
)	O
;	O
if	O
(	O
(	O
version	*(char)
/	O
10000	int
)	O
%	O
100	int
)	O
printf	(*(char))->(int)
(	O
"  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u%s%c)\n"	*(char)
,	O
pnote	O
->	O
descsz	O
,	O
version	*(char)
,	O
version	*(char)
/	O
100000000	int
,	O
(	O
version	*(char)
/	O
1000000	int
)	O
%	O
100	int
,	O
(	O
version	*(char)
/	O
10000	int
)	O
%	O
100	int
>	O
26	int
?	O
"Z"	*(char)
:	O
""	*(char)
,	O
'A'	O
+	O
(	O
version	*(char)
/	O
10000	int
)	O
%	O
26	int
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
"  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u.%u)\n"	*(char)
,	O
pnote	O
->	O
descsz	O
,	O
version	*(char)
,	O
version	*(char)
/	O
100000000	int
,	O
(	O
version	*(char)
/	O
1000000	int
)	O
%	O
100	int
,	O
(	O
version	*(char)
/	O
100	int
)	O
%	O
100	int
)	O
;	O
return	O
TRUE	int
;	O
case	O
NT_NETBSD_MARCH	O
:	O
printf	(*(char))->(int)
(	O
"  NetBSD\t\t0x%08lx\tMARCH <%s>\n"	*(char)
,	O
pnote	O
->	O
descsz	O
,	O
pnote	O
->	O
descdata	O
)	O
;	O
return	O
TRUE	int
;	O
default	O
:	O
printf	(*(char))->(int)
(	O
"  NetBSD\t0x%08lx\tUnknown note type: (0x%08lx)\n"	*(char)
,	O
pnote	O
->	O
descsz	O
,	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
get_freebsd_elfcore_note_type	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
e_type	O
)	O
{	O
switch	O
(	O
e_type	O
)	O
{	O
case	O
NT_FREEBSD_THRMISC	O
:	O
return	O
_	O
(	O
"NT_THRMISC (thrmisc structure)"	*(char)
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_PROC	O
:	O
return	O
_	O
(	O
"NT_PROCSTAT_PROC (proc data)"	*(char)
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_FILES	O
:	O
return	O
_	O
(	O
"NT_PROCSTAT_FILES (files data)"	*(char)
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_VMMAP	O
:	O
return	O
_	O
(	O
"NT_PROCSTAT_VMMAP (vmmap data)"	*(char)
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_GROUPS	O
:	O
return	O
_	O
(	O
"NT_PROCSTAT_GROUPS (groups data)"	*(char)
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_UMASK	O
:	O
return	O
_	O
(	O
"NT_PROCSTAT_UMASK (umask data)"	*(char)
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_RLIMIT	O
:	O
return	O
_	O
(	O
"NT_PROCSTAT_RLIMIT (rlimit data)"	*(char)
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_OSREL	O
:	O
return	O
_	O
(	O
"NT_PROCSTAT_OSREL (osreldate data)"	*(char)
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_PSSTRINGS	O
:	O
return	O
_	O
(	O
"NT_PROCSTAT_PSSTRINGS (ps_strings data)"	*(char)
)	O
;	O
case	O
NT_FREEBSD_PROCSTAT_AUXV	O
:	O
return	O
_	O
(	O
"NT_PROCSTAT_AUXV (auxv data)"	*(char)
)	O
;	O
case	O
NT_FREEBSD_PTLWPINFO	O
:	O
return	O
_	O
(	O
"NT_PTLWPINFO (ptrace_lwpinfo structure)"	*(char)
)	O
;	O
}	O
return	O
get_note_type	O
(	O
filedata	O
,	O
e_type	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
get_netbsd_elfcore_note_type	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
e_type	O
)	O
{	O
static	O
char	O
buff	O
[	O
64	int
]	O
;	O
switch	O
(	O
e_type	O
)	O
{	O
case	O
NT_NETBSDCORE_PROCINFO	O
:	O
return	O
_	O
(	O
"NetBSD procinfo structure"	*(char)
)	O
;	O
default	O
:	O
if	O
(	O
e_type	O
<	O
NT_NETBSDCORE_FIRSTMACH	O
)	O
{	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	*(char)
)	O
,	O
e_type	O
)	O
;	O
return	O
buff	O
;	O
}	O
break	O
;	O
}	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_OLD_ALPHA	O
:	O
case	O
EM_ALPHA	O
:	O
case	O
EM_SPARC	O
:	O
case	O
EM_SPARC32PLUS	O
:	O
case	O
EM_SPARCV9	O
:	O
switch	O
(	O
e_type	O
)	O
{	O
case	O
NT_NETBSDCORE_FIRSTMACH	O
+	O
0	int
:	O
return	O
_	O
(	O
"PT_GETREGS (reg structure)"	*(char)
)	O
;	O
case	O
NT_NETBSDCORE_FIRSTMACH	O
+	O
2	int
:	O
return	O
_	O
(	O
"PT_GETFPREGS (fpreg structure)"	*(char)
)	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
EM_SH	O
:	O
switch	O
(	O
e_type	O
)	O
{	O
case	O
NT_NETBSDCORE_FIRSTMACH	O
+	O
1	int
:	O
return	O
_	O
(	O
"PT___GETREGS40 (old reg structure)"	*(char)
)	O
;	O
case	O
NT_NETBSDCORE_FIRSTMACH	O
+	O
3	int
:	O
return	O
_	O
(	O
"PT_GETREGS (reg structure)"	*(char)
)	O
;	O
case	O
NT_NETBSDCORE_FIRSTMACH	O
+	O
5	int
:	O
return	O
_	O
(	O
"PT_GETFPREGS (fpreg structure)"	*(char)
)	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
switch	O
(	O
e_type	O
)	O
{	O
case	O
NT_NETBSDCORE_FIRSTMACH	O
+	O
1	int
:	O
return	O
_	O
(	O
"PT_GETREGS (reg structure)"	*(char)
)	O
;	O
case	O
NT_NETBSDCORE_FIRSTMACH	O
+	O
3	int
:	O
return	O
_	O
(	O
"PT_GETFPREGS (fpreg structure)"	*(char)
)	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
"PT_FIRSTMACH+%d"	*(char)
,	O
e_type	O
-	O
NT_NETBSDCORE_FIRSTMACH	O
)	O
;	O
return	O
buff	O
;	O
}	O
static	O
const	O
char	O
*	O
get_stapsdt_note_type	O
(	O
unsigned	O
e_type	O
)	O
{	O
static	O
char	O
buff	O
[	O
64	int
]	O
;	O
switch	O
(	O
e_type	O
)	O
{	O
case	O
NT_STAPSDT	O
:	O
return	O
_	O
(	O
"NT_STAPSDT (SystemTap probe descriptors)"	*(char)
)	O
;	O
default	O
:	O
break	O
;	O
}	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	*(char)
)	O
,	O
e_type	O
)	O
;	O
return	O
buff	O
;	O
}	O
static	O
bfd_boolean	int
print_stapsdt_note	O
(	O
Elf_Internal_Note	O
*	O
pnote	O
)	O
{	O
size_t	long
len	int
,	O
maxlen	O
;	O
unsigned	O
long	O
addr_size	O
=	O
is_32bit_elf	O
?	O
4	int
:	O
8	int
;	O
char	O
*	O
data	*(void)
=	O
pnote	O
->	O
descdata	O
;	O
char	O
*	O
data_end	O
=	O
pnote	O
->	O
descdata	O
+	O
pnote	O
->	O
descsz	O
;	O
bfd_vma	long
pc	O
,	O
base_addr	O
,	O
semaphore	O
;	O
char	O
*	O
provider	O
,	O
*	O
probe	O
,	O
*	O
arg_fmt	O
;	O
if	O
(	O
pnote	O
->	O
descsz	O
<	O
(	O
addr_size	O
*	O
3	int
)	O
)	O
goto	O
stapdt_note_too_small	O
;	O
pc	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
data	*(void)
,	O
addr_size	O
)	O
;	O
data	*(void)
+=	O
addr_size	O
;	O
base_addr	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
data	*(void)
,	O
addr_size	O
)	O
;	O
data	*(void)
+=	O
addr_size	O
;	O
semaphore	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
data	*(void)
,	O
addr_size	O
)	O
;	O
data	*(void)
+=	O
addr_size	O
;	O
if	O
(	O
data	*(void)
>=	O
data_end	O
)	O
goto	O
stapdt_note_too_small	O
;	O
maxlen	O
=	O
data_end	O
-	O
data	*(void)
;	O
len	int
=	O
strnlen	(*(char),long)->(long)
(	O
data	*(void)
,	O
maxlen	O
)	O
;	O
if	O
(	O
len	int
<	O
maxlen	O
)	O
{	O
provider	O
=	O
data	*(void)
;	O
data	*(void)
+=	O
len	int
+	O
1	int
;	O
}	O
else	O
goto	O
stapdt_note_too_small	O
;	O
if	O
(	O
data	*(void)
>=	O
data_end	O
)	O
goto	O
stapdt_note_too_small	O
;	O
maxlen	O
=	O
data_end	O
-	O
data	*(void)
;	O
len	int
=	O
strnlen	(*(char),long)->(long)
(	O
data	*(void)
,	O
maxlen	O
)	O
;	O
if	O
(	O
len	int
<	O
maxlen	O
)	O
{	O
probe	O
=	O
data	*(void)
;	O
data	*(void)
+=	O
len	int
+	O
1	int
;	O
}	O
else	O
goto	O
stapdt_note_too_small	O
;	O
if	O
(	O
data	*(void)
>=	O
data_end	O
)	O
goto	O
stapdt_note_too_small	O
;	O
maxlen	O
=	O
data_end	O
-	O
data	*(void)
;	O
len	int
=	O
strnlen	(*(char),long)->(long)
(	O
data	*(void)
,	O
maxlen	O
)	O
;	O
if	O
(	O
len	int
<	O
maxlen	O
)	O
{	O
arg_fmt	O
=	O
data	*(void)
;	O
data	*(void)
+=	O
len	int
+	O
1	int
;	O
}	O
else	O
goto	O
stapdt_note_too_small	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Provider: %s\n"	*(char)
)	O
,	O
provider	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Name: %s\n"	*(char)
)	O
,	O
probe	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Location: "	*(char)
)	O
)	O
;	O
print_vma	O
(	O
pc	O
,	O
FULL_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
", Base: "	*(char)
)	O
)	O
;	O
print_vma	O
(	O
base_addr	O
,	O
FULL_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
", Semaphore: "	*(char)
)	O
)	O
;	O
print_vma	O
(	O
semaphore	O
,	O
FULL_HEX	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Arguments: %s\n"	*(char)
)	O
,	O
arg_fmt	O
)	O
;	O
return	O
data	*(void)
==	O
data_end	O
;	O
stapdt_note_too_small	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  <corrupt - note is too small>\n"	*(char)
)	O
)	O
;	O
error	O
(	O
_	O
(	O
"corrupt stapdt note - the data size is too small\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
static	O
const	O
char	O
*	O
get_ia64_vms_note_type	O
(	O
unsigned	O
e_type	O
)	O
{	O
static	O
char	O
buff	O
[	O
64	int
]	O
;	O
switch	O
(	O
e_type	O
)	O
{	O
case	O
NT_VMS_MHD	O
:	O
return	O
_	O
(	O
"NT_VMS_MHD (module header)"	*(char)
)	O
;	O
case	O
NT_VMS_LNM	O
:	O
return	O
_	O
(	O
"NT_VMS_LNM (language name)"	*(char)
)	O
;	O
case	O
NT_VMS_SRC	O
:	O
return	O
_	O
(	O
"NT_VMS_SRC (source files)"	*(char)
)	O
;	O
case	O
NT_VMS_TITLE	O
:	O
return	O
"NT_VMS_TITLE"	*(char)
;	O
case	O
NT_VMS_EIDC	O
:	O
return	O
_	O
(	O
"NT_VMS_EIDC (consistency check)"	*(char)
)	O
;	O
case	O
NT_VMS_FPMODE	O
:	O
return	O
_	O
(	O
"NT_VMS_FPMODE (FP mode)"	*(char)
)	O
;	O
case	O
NT_VMS_LINKTIME	O
:	O
return	O
"NT_VMS_LINKTIME"	*(char)
;	O
case	O
NT_VMS_IMGNAM	O
:	O
return	O
_	O
(	O
"NT_VMS_IMGNAM (image name)"	*(char)
)	O
;	O
case	O
NT_VMS_IMGID	O
:	O
return	O
_	O
(	O
"NT_VMS_IMGID (image id)"	*(char)
)	O
;	O
case	O
NT_VMS_LINKID	O
:	O
return	O
_	O
(	O
"NT_VMS_LINKID (link id)"	*(char)
)	O
;	O
case	O
NT_VMS_IMGBID	O
:	O
return	O
_	O
(	O
"NT_VMS_IMGBID (build id)"	*(char)
)	O
;	O
case	O
NT_VMS_GSTNAM	O
:	O
return	O
_	O
(	O
"NT_VMS_GSTNAM (sym table name)"	*(char)
)	O
;	O
case	O
NT_VMS_ORIG_DYN	O
:	O
return	O
"NT_VMS_ORIG_DYN"	*(char)
;	O
case	O
NT_VMS_PATCHTIME	O
:	O
return	O
"NT_VMS_PATCHTIME"	*(char)
;	O
default	O
:	O
snprintf	(*(char),long,*(char))->(int)
(	O
buff	O
,	O
sizeof	O
(	O
buff	O
)	O
,	O
_	O
(	O
"Unknown note type: (0x%08x)"	*(char)
)	O
,	O
e_type	O
)	O
;	O
return	O
buff	O
;	O
}	O
}	O
static	O
bfd_boolean	int
print_ia64_vms_note	O
(	O
Elf_Internal_Note	O
*	O
pnote	O
)	O
{	O
int	O
maxlen	O
=	O
pnote	O
->	O
descsz	O
;	O
if	O
(	O
maxlen	O
<	O
2	int
||	O
(	O
unsigned	O
long	O
)	O
maxlen	O
!=	O
pnote	O
->	O
descsz	O
)	O
goto	O
desc_size_fail	O
;	O
switch	O
(	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
{	O
case	O
NT_VMS_MHD	O
:	O
if	O
(	O
maxlen	O
<=	O
36	int
)	O
goto	O
desc_size_fail	O
;	O
int	O
l	O
=	O
(	O
int	O
)	O
strnlen	(*(char),long)->(long)
(	O
pnote	O
->	O
descdata	O
+	O
34	int
,	O
maxlen	O
-	O
34	int
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Creation date  : %.17s\n"	*(char)
)	O
,	O
pnote	O
->	O
descdata	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Last patch date: %.17s\n"	*(char)
)	O
,	O
pnote	O
->	O
descdata	O
+	O
17	int
)	O
;	O
if	O
(	O
l	O
+	O
34	int
<	O
maxlen	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Module name    : %s\n"	*(char)
)	O
,	O
pnote	O
->	O
descdata	O
+	O
34	int
)	O
;	O
if	O
(	O
l	O
+	O
35	int
<	O
maxlen	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Module version : %s\n"	*(char)
)	O
,	O
pnote	O
->	O
descdata	O
+	O
34	int
+	O
l	O
+	O
1	int
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Module version : <missing>\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Module name    : <missing>\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Module version : <missing>\n"	*(char)
)	O
)	O
;	O
}	O
break	O
;	O
case	O
NT_VMS_LNM	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   Language: %.*s\n"	*(char)
)	O
,	O
maxlen	O
,	O
pnote	O
->	O
descdata	O
)	O
;	O
break	O
;	O
case	O
NT_VMS_FPMODE	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   Floating Point mode: "	*(char)
)	O
)	O
;	O
if	O
(	O
maxlen	O
<	O
8	int
)	O
goto	O
desc_size_fail	O
;	O
printf	(*(char))->(int)
(	O
"0x%016"	*(char)
BFD_VMA_FMT	O
"x\n"	*(char)
,	O
(	O
bfd_vma	long
)	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
8	int
)	O
)	O
;	O
break	O
;	O
case	O
NT_VMS_LINKTIME	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   Link time: "	*(char)
)	O
)	O
;	O
if	O
(	O
maxlen	O
<	O
8	int
)	O
goto	O
desc_size_fail	O
;	O
print_vms_time	O
(	O
(	O
bfd_int64_t	long
)	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
8	int
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
break	O
;	O
case	O
NT_VMS_PATCHTIME	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   Patch time: "	*(char)
)	O
)	O
;	O
if	O
(	O
maxlen	O
<	O
8	int
)	O
goto	O
desc_size_fail	O
;	O
print_vms_time	O
(	O
(	O
bfd_int64_t	long
)	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
8	int
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
break	O
;	O
case	O
NT_VMS_ORIG_DYN	O
:	O
if	O
(	O
maxlen	O
<	O
34	int
)	O
goto	O
desc_size_fail	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   Major id: %u,  minor id: %u\n"	*(char)
)	O
,	O
(	O
unsigned	O
)	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
4	int
)	O
,	O
(	O
unsigned	O
)	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
+	O
4	int
,	O
4	int
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   Last modified  : "	*(char)
)	O
)	O
;	O
print_vms_time	O
(	O
(	O
bfd_int64_t	long
)	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
+	O
8	int
,	O
8	int
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\n   Link flags  : "	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"0x%016"	*(char)
BFD_VMA_FMT	O
"x\n"	*(char)
,	O
(	O
bfd_vma	long
)	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
+	O
16	int
,	O
8	int
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   Header flags: 0x%08x\n"	*(char)
)	O
,	O
(	O
unsigned	O
)	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
+	O
24	int
,	O
4	int
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   Image id    : %.*s\n"	*(char)
)	O
,	O
maxlen	O
-	O
32	int
,	O
pnote	O
->	O
descdata	O
+	O
32	int
)	O
;	O
break	O
;	O
case	O
NT_VMS_IMGNAM	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Image name: %.*s\n"	*(char)
)	O
,	O
maxlen	O
,	O
pnote	O
->	O
descdata	O
)	O
;	O
break	O
;	O
case	O
NT_VMS_GSTNAM	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Global symbol table name: %.*s\n"	*(char)
)	O
,	O
maxlen	O
,	O
pnote	O
->	O
descdata	O
)	O
;	O
break	O
;	O
case	O
NT_VMS_IMGID	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Image id: %.*s\n"	*(char)
)	O
,	O
maxlen	O
,	O
pnote	O
->	O
descdata	O
)	O
;	O
break	O
;	O
case	O
NT_VMS_LINKID	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Linker id: %.*s\n"	*(char)
)	O
,	O
maxlen	O
,	O
pnote	O
->	O
descdata	O
)	O
;	O
break	O
;	O
default	O
:	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	int
;	O
desc_size_fail	O
:	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  <corrupt - data size is too small>\n"	*(char)
)	O
)	O
;	O
error	O
(	O
_	O
(	O
"corrupt IA64 note: data size is too small\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
static	O
Elf_Internal_Sym	O
*	O
get_symbol_for_build_attribute	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
long	O
offset	long
,	O
bfd_boolean	int
is_open_attr	O
,	O
const	O
char	O
*	O
*	O
pname	O
)	O
{	O
static	O
Filedata	O
*	O
saved_filedata	O
=	O
NULL	O
;	O
static	O
char	O
*	O
strtab	O
;	O
static	O
unsigned	O
long	O
strtablen	O
;	O
static	O
Elf_Internal_Sym	O
*	O
symtab	O
;	O
static	O
unsigned	O
long	O
nsyms	O
;	O
Elf_Internal_Sym	O
*	O
saved_sym	O
=	O
NULL	O
;	O
Elf_Internal_Sym	O
*	O
sym	*(struct)
;	O
if	O
(	O
filedata	O
->	O
section_headers	O
!=	O
NULL	O
&&	O
(	O
saved_filedata	O
==	O
NULL	O
||	O
filedata	O
!=	O
saved_filedata	O
)	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
symsec	O
;	O
for	O
(	O
symsec	O
=	O
filedata	O
->	O
section_headers	O
;	O
symsec	O
<	O
filedata	O
->	O
section_headers	O
+	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
;	O
symsec	O
++	O
)	O
{	O
if	O
(	O
symsec	O
->	O
sh_type	O
==	O
SHT_SYMTAB	O
)	O
{	O
symtab	O
=	O
GET_ELF_SYMBOLS	O
(	O
filedata	O
,	O
symsec	O
,	O
&	O
nsyms	O
)	O
;	O
if	O
(	O
symsec	O
->	O
sh_link	O
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
strtab_sec	O
=	O
filedata	O
->	O
section_headers	O
+	O
symsec	O
->	O
sh_link	O
;	O
strtab	O
=	O
(	O
char	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
strtab_sec	O
->	O
sh_offset	O
,	O
1	int
,	O
strtab_sec	O
->	O
sh_size	O
,	O
_	O
(	O
"string table"	*(char)
)	O
)	O
;	O
strtablen	O
=	O
strtab	O
!=	O
NULL	O
?	O
strtab_sec	O
->	O
sh_size	O
:	O
0	int
;	O
}	O
}	O
}	O
saved_filedata	O
=	O
filedata	O
;	O
}	O
if	O
(	O
symtab	O
==	O
NULL	O
||	O
strtab	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
sym	*(struct)
=	O
symtab	O
;	O
sym	*(struct)
<	O
symtab	O
+	O
nsyms	O
;	O
sym	*(struct)
++	O
)	O
if	O
(	O
sym	*(struct)
->	O
st_value	O
==	O
offset	long
)	O
{	O
if	O
(	O
sym	*(struct)
->	O
st_name	O
>=	O
strtablen	O
)	O
continue	O
;	O
if	O
(	O
strtab	O
[	O
sym	*(struct)
->	O
st_name	O
]	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
strtab	O
[	O
sym	*(struct)
->	O
st_name	O
]	O
==	O
'$'	O
&&	O
strtab	O
[	O
sym	*(struct)
->	O
st_name	O
+	O
1	int
]	O
!=	O
0	int
&&	O
strtab	O
[	O
sym	*(struct)
->	O
st_name	O
+	O
2	int
]	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
is_open_attr	O
)	O
{	O
switch	O
(	O
ELF_ST_TYPE	O
(	O
sym	*(struct)
->	O
st_info	O
)	O
)	O
{	O
case	O
STT_OBJECT	O
:	O
case	O
STT_FILE	O
:	O
saved_sym	O
=	O
sym	*(struct)
;	O
if	O
(	O
sym	*(struct)
->	O
st_size	long
)	O
{	O
sym	*(struct)
=	O
symtab	O
+	O
nsyms	O
;	O
}	O
continue	O
;	O
case	O
STT_FUNC	O
:	O
continue	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
ELF_ST_BIND	O
(	O
sym	*(struct)
->	O
st_info	O
)	O
)	O
{	O
case	O
STB_GLOBAL	O
:	O
if	O
(	O
saved_sym	O
==	O
NULL	O
||	O
ELF_ST_TYPE	O
(	O
saved_sym	O
->	O
st_info	O
)	O
!=	O
STT_OBJECT	O
)	O
saved_sym	O
=	O
sym	*(struct)
;	O
break	O
;	O
case	O
STB_LOCAL	O
:	O
if	O
(	O
saved_sym	O
==	O
NULL	O
)	O
saved_sym	O
=	O
sym	*(struct)
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
ELF_ST_TYPE	O
(	O
sym	*(struct)
->	O
st_info	O
)	O
!=	O
STT_FUNC	O
)	O
continue	O
;	O
saved_sym	O
=	O
sym	*(struct)
;	O
break	O
;	O
}	O
}	O
if	O
(	O
saved_sym	O
&&	O
pname	O
)	O
*	O
pname	O
=	O
strtab	O
+	O
saved_sym	O
->	O
st_name	O
;	O
return	O
saved_sym	O
;	O
}	O
static	O
bfd_boolean	int
same_section	O
(	O
Filedata	O
*	O
filedata	O
,	O
unsigned	O
long	O
addr1	O
,	O
unsigned	O
long	O
addr2	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
a1	O
;	O
Elf_Internal_Shdr	O
*	O
a2	O
;	O
a1	O
=	O
find_section_by_address	O
(	O
filedata	O
,	O
addr1	O
)	O
;	O
a2	O
=	O
find_section_by_address	O
(	O
filedata	O
,	O
addr2	O
)	O
;	O
return	O
a1	O
==	O
a2	O
&&	O
a1	O
!=	O
NULL	O
;	O
}	O
static	O
bfd_boolean	int
print_gnu_build_attribute_description	O
(	O
Elf_Internal_Note	O
*	O
pnote	O
,	O
Filedata	O
*	O
filedata	O
)	O
{	O
static	O
unsigned	O
long	O
global_offset	O
=	O
0	int
;	O
static	O
unsigned	O
long	O
global_end	O
=	O
0	int
;	O
static	O
unsigned	O
long	O
func_offset	O
=	O
0	int
;	O
static	O
unsigned	O
long	O
func_end	O
=	O
0	int
;	O
Elf_Internal_Sym	O
*	O
sym	*(struct)
;	O
const	O
char	O
*	O
name	*(char)
;	O
unsigned	O
long	O
start	O
;	O
unsigned	O
long	O
end	*(*(char))
;	O
bfd_boolean	int
is_open_attr	O
=	O
pnote	O
->	O
type	enum(int,int,int,int)
==	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	O
;	O
switch	O
(	O
pnote	O
->	O
descsz	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
is_open_attr	O
)	O
{	O
if	O
(	O
global_end	O
>	O
global_offset	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Applies to region from %#lx to %#lx\n"	*(char)
)	O
,	O
global_offset	O
,	O
global_end	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Applies to region from %#lx\n"	*(char)
)	O
,	O
global_offset	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
func_end	O
>	O
func_offset	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Applies to region from %#lx to %#lx\n"	*(char)
)	O
,	O
func_offset	O
,	O
func_end	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Applies to region from %#lx\n"	*(char)
)	O
,	O
func_offset	O
)	O
;	O
}	O
return	O
TRUE	int
;	O
case	O
4	int
:	O
start	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
4	int
)	O
;	O
end	*(*(char))
=	O
0	int
;	O
break	O
;	O
case	O
8	int
:	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
start	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
4	int
)	O
;	O
end	*(*(char))
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
+	O
4	int
,	O
4	int
)	O
;	O
}	O
else	O
{	O
start	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
8	int
)	O
;	O
end	*(*(char))
=	O
0	int
;	O
}	O
break	O
;	O
case	O
16	int
:	O
start	O
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
,	O
8	int
)	O
;	O
end	*(*(char))
=	O
byte_get	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
pnote	O
->	O
descdata	O
+	O
8	int
,	O
8	int
)	O
;	O
break	O
;	O
default	O
:	O
error	O
(	O
_	O
(	O
"    <invalid description size: %lx>\n"	*(char)
)	O
,	O
pnote	O
->	O
descsz	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    <invalid descsz>"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
name	*(char)
=	O
NULL	O
;	O
sym	*(struct)
=	O
get_symbol_for_build_attribute	O
(	O
filedata	O
,	O
start	O
,	O
is_open_attr	O
,	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
sym	*(struct)
==	O
NULL	O
&&	O
is_open_attr	O
)	O
sym	*(struct)
=	O
get_symbol_for_build_attribute	O
(	O
filedata	O
,	O
start	O
+	O
2	int
,	O
is_open_attr	O
,	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
end	*(*(char))
==	O
0	int
&&	O
sym	*(struct)
!=	O
NULL	O
&&	O
sym	*(struct)
->	O
st_size	long
>	O
0	int
)	O
end	*(*(char))
=	O
start	O
+	O
sym	*(struct)
->	O
st_size	long
;	O
if	O
(	O
is_open_attr	O
)	O
{	O
if	O
(	O
global_end	O
>	O
0	int
&&	O
start	O
>	O
BFD_ALIGN	O
(	O
global_end	O
,	O
16	int
)	O
&&	O
same_section	O
(	O
filedata	O
,	O
start	O
,	O
global_end	O
)	O
)	O
warn	O
(	O
_	O
(	O
"Gap in build notes detected from %#lx to %#lx\n"	*(char)
)	O
,	O
global_end	O
+	O
1	int
,	O
start	O
-	O
1	int
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Applies to region from %#lx"	*(char)
)	O
,	O
start	O
)	O
;	O
global_offset	O
=	O
start	O
;	O
if	O
(	O
end	*(*(char))
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
" to %#lx"	*(char)
)	O
,	O
end	*(*(char))
)	O
;	O
global_end	O
=	O
end	*(*(char))
;	O
}	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"    Applies to region from %#lx"	*(char)
)	O
,	O
start	O
)	O
;	O
func_offset	O
=	O
start	O
;	O
if	O
(	O
end	*(*(char))
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
" to %#lx"	*(char)
)	O
,	O
end	*(*(char))
)	O
;	O
func_end	O
=	O
end	*(*(char))
;	O
}	O
}	O
if	O
(	O
sym	*(struct)
&&	O
name	*(char)
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
" (%s)"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
print_gnu_build_attribute_name	O
(	O
Elf_Internal_Note	O
*	O
pnote	O
)	O
{	O
static	O
const	O
char	O
string_expected	O
[	O
2	int
]	O
=	O
{	O
GNU_BUILD_ATTRIBUTE_TYPE_STRING	O
,	O
0	int
}	O
;	O
static	O
const	O
char	O
number_expected	O
[	O
2	int
]	O
=	O
{	O
GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC	O
,	O
0	int
}	O
;	O
static	O
const	O
char	O
bool_expected	O
[	O
3	int
]	O
=	O
{	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE	O
,	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE	O
,	O
0	int
}	O
;	O
char	O
name_type	O
;	O
char	O
name_attribute	O
;	O
const	O
char	O
*	O
expected_types	O
;	O
const	O
char	O
*	O
name	*(char)
=	O
pnote	O
->	O
namedata	O
;	O
const	O
char	O
*	O
text	int
;	O
signed	O
int	O
left	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
||	O
pnote	O
->	O
namesz	O
<	O
2	int
)	O
{	O
error	O
(	O
_	O
(	O
"corrupt name field in GNU build attribute note: size = %ld\n"	*(char)
)	O
,	O
pnote	O
->	O
namesz	O
)	O
;	O
print_symbol	O
(	O
-	O
20	int
,	O
_	O
(	O
"  <corrupt name>"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
do_wide	O
)	O
left	O
=	O
28	int
;	O
else	O
left	O
=	O
20	int
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'G'	O
&&	O
name	*(char)
[	O
1	int
]	O
==	O
'A'	O
)	O
{	O
if	O
(	O
pnote	O
->	O
namesz	O
<	O
4	int
)	O
{	O
error	O
(	O
_	O
(	O
"corrupt name field in GNU build attribute note: size = %ld\n"	*(char)
)	O
,	O
pnote	O
->	O
namesz	O
)	O
;	O
print_symbol	O
(	O
-	O
20	int
,	O
_	O
(	O
"  <corrupt name>"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
printf	(*(char))->(int)
(	O
"GA"	*(char)
)	O
;	O
name	*(char)
+=	O
2	int
;	O
left	O
-=	O
2	int
;	O
}	O
switch	O
(	O
(	O
name_type	O
=	O
*	O
name	*(char)
)	O
)	O
{	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC	O
:	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_STRING	O
:	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE	O
:	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE	O
:	O
printf	(*(char))->(int)
(	O
"%c"	*(char)
,	O
*	O
name	*(char)
)	O
;	O
left	O
--	O
;	O
break	O
;	O
default	O
:	O
error	O
(	O
_	O
(	O
"unrecognised attribute type in name field: %d\n"	*(char)
)	O
,	O
name_type	O
)	O
;	O
print_symbol	O
(	O
-	O
20	int
,	O
_	O
(	O
"<unknown name type>"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
++	O
name	*(char)
;	O
text	int
=	O
NULL	O
;	O
switch	O
(	O
(	O
name_attribute	O
=	O
*	O
name	*(char)
)	O
)	O
{	O
case	O
GNU_BUILD_ATTRIBUTE_VERSION	O
:	O
text	int
=	O
_	O
(	O
"<version>"	*(char)
)	O
;	O
expected_types	O
=	O
string_expected	O
;	O
++	O
name	*(char)
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_STACK_PROT	O
:	O
text	int
=	O
_	O
(	O
"<stack prot>"	*(char)
)	O
;	O
expected_types	O
=	O
"!+*"	*(char)
;	O
++	O
name	*(char)
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_RELRO	O
:	O
text	int
=	O
_	O
(	O
"<relro>"	*(char)
)	O
;	O
expected_types	O
=	O
bool_expected	O
;	O
++	O
name	*(char)
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_STACK_SIZE	O
:	O
text	int
=	O
_	O
(	O
"<stack size>"	*(char)
)	O
;	O
expected_types	O
=	O
number_expected	O
;	O
++	O
name	*(char)
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_TOOL	O
:	O
text	int
=	O
_	O
(	O
"<tool>"	*(char)
)	O
;	O
expected_types	O
=	O
string_expected	O
;	O
++	O
name	*(char)
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_ABI	O
:	O
text	int
=	O
_	O
(	O
"<ABI>"	*(char)
)	O
;	O
expected_types	O
=	O
"$*"	*(char)
;	O
++	O
name	*(char)
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_PIC	O
:	O
text	int
=	O
_	O
(	O
"<PIC>"	*(char)
)	O
;	O
expected_types	O
=	O
number_expected	O
;	O
++	O
name	*(char)
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_SHORT_ENUM	O
:	O
text	int
=	O
_	O
(	O
"<short enum>"	*(char)
)	O
;	O
expected_types	O
=	O
bool_expected	O
;	O
++	O
name	*(char)
;	O
break	O
;	O
default	O
:	O
if	O
(	O
ISPRINT	O
(	O
*	O
name	*(char)
)	O
)	O
{	O
int	O
len	int
=	O
strnlen	(*(char),long)->(long)
(	O
name	*(char)
,	O
pnote	O
->	O
namesz	O
-	O
(	O
name	*(char)
-	O
pnote	O
->	O
namedata	O
)	O
)	O
+	O
1	int
;	O
if	O
(	O
len	int
>	O
left	O
&&	O
!	O
do_wide	O
)	O
len	int
=	O
left	O
;	O
printf	(*(char))->(int)
(	O
"%.*s:"	*(char)
,	O
len	int
,	O
name	*(char)
)	O
;	O
left	O
-=	O
len	int
;	O
name	*(char)
+=	O
len	int
;	O
}	O
else	O
{	O
static	O
char	O
tmpbuf	O
[	O
128	int
]	O
;	O
error	O
(	O
_	O
(	O
"unrecognised byte in name field: %d\n"	*(char)
)	O
,	O
*	O
name	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
tmpbuf	O
,	O
_	O
(	O
"<unknown:_%d>"	*(char)
)	O
,	O
*	O
name	*(char)
)	O
;	O
text	int
=	O
tmpbuf	O
;	O
name	*(char)
++	O
;	O
}	O
expected_types	O
=	O
"*$!+"	*(char)
;	O
break	O
;	O
}	O
if	O
(	O
text	int
)	O
left	O
-=	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
text	int
)	O
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
expected_types	O
,	O
name_type	O
)	O
==	O
NULL	O
)	O
warn	O
(	O
_	O
(	O
"attribute does not have an expected type (%c)\n"	*(char)
)	O
,	O
name_type	O
)	O
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
name	*(char)
-	O
pnote	O
->	O
namedata	O
)	O
>	O
pnote	O
->	O
namesz	O
)	O
{	O
error	O
(	O
_	O
(	O
"corrupt name field: namesz: %lu but parsing gets to %ld\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
pnote	O
->	O
namesz	O
,	O
(	O
long	O
)	O
(	O
name	*(char)
-	O
pnote	O
->	O
namedata	O
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
left	O
<	O
1	int
&&	O
!	O
do_wide	O
)	O
return	O
TRUE	int
;	O
switch	O
(	O
name_type	O
)	O
{	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC	O
:	O
{	O
unsigned	O
int	O
bytes	O
;	O
unsigned	O
long	O
long	O
val	array(int)
=	O
0	int
;	O
unsigned	O
int	O
shift	int
=	O
0	int
;	O
char	O
*	O
decoded	O
=	O
NULL	O
;	O
bytes	O
=	O
pnote	O
->	O
namesz	O
-	O
(	O
name	*(char)
-	O
pnote	O
->	O
namedata	O
)	O
;	O
if	O
(	O
bytes	O
>	O
0	int
)	O
--	O
bytes	O
;	O
if	O
(	O
bytes	O
>	O
sizeof	O
(	O
val	array(int)
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"corrupt numeric name field: too many bytes in the value: %x\n"	*(char)
)	O
,	O
bytes	O
)	O
;	O
bytes	O
=	O
sizeof	O
(	O
val	array(int)
)	O
;	O
}	O
while	O
(	O
bytes	O
--	O
)	O
{	O
unsigned	O
long	O
byte	O
=	O
(	O
*	O
name	*(char)
++	O
)	O
&	O
0xff	int
;	O
val	array(int)
|=	O
byte	O
<<	O
shift	int
;	O
shift	int
+=	O
8	int
;	O
}	O
switch	O
(	O
name_attribute	O
)	O
{	O
case	O
GNU_BUILD_ATTRIBUTE_PIC	O
:	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
decoded	O
=	O
"static"	*(char)
;	O
break	O
;	O
case	O
1	int
:	O
decoded	O
=	O
"pic"	*(char)
;	O
break	O
;	O
case	O
2	int
:	O
decoded	O
=	O
"PIC"	*(char)
;	O
break	O
;	O
case	O
3	int
:	O
decoded	O
=	O
"pie"	*(char)
;	O
break	O
;	O
case	O
4	int
:	O
decoded	O
=	O
"PIE"	*(char)
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_STACK_PROT	O
:	O
switch	O
(	O
val	array(int)
)	O
{	O
case	O
0	int
:	O
decoded	O
=	O
"off"	*(char)
;	O
break	O
;	O
case	O
1	int
:	O
decoded	O
=	O
"on"	*(char)
;	O
break	O
;	O
case	O
2	int
:	O
decoded	O
=	O
"all"	*(char)
;	O
break	O
;	O
case	O
3	int
:	O
decoded	O
=	O
"strong"	*(char)
;	O
break	O
;	O
case	O
4	int
:	O
decoded	O
=	O
"explicit"	*(char)
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
decoded	O
!=	O
NULL	O
)	O
{	O
print_symbol	O
(	O
-	O
left	O
,	O
decoded	O
)	O
;	O
left	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
val	array(int)
==	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"0x0"	*(char)
)	O
;	O
left	O
-=	O
3	int
;	O
}	O
else	O
{	O
if	O
(	O
do_wide	O
)	O
left	O
-=	O
printf	(*(char))->(int)
(	O
"0x%llx"	*(char)
,	O
val	array(int)
)	O
;	O
else	O
left	O
-=	O
printf	(*(char))->(int)
(	O
"0x%-.*llx"	*(char)
,	O
left	O
,	O
val	array(int)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_STRING	O
:	O
left	O
-=	O
print_symbol	O
(	O
-	O
left	O
,	O
name	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE	O
:	O
left	O
-=	O
print_symbol	O
(	O
-	O
left	O
,	O
"true"	*(char)
)	O
;	O
break	O
;	O
case	O
GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE	O
:	O
left	O
-=	O
print_symbol	O
(	O
-	O
left	O
,	O
"false"	*(char)
)	O
;	O
break	O
;	O
}	O
if	O
(	O
do_wide	O
&&	O
left	O
>	O
0	int
)	O
printf	(*(char))->(int)
(	O
"%-*s"	*(char)
,	O
left	O
,	O
" "	*(char)
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
process_note	O
(	O
Elf_Internal_Note	O
*	O
pnote	O
,	O
Filedata	O
*	O
filedata	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
=	O
pnote	O
->	O
namesz	O
?	O
pnote	O
->	O
namedata	O
:	O
"(NONE)"	*(char)
;	O
const	O
char	O
*	O
nt	O
;	O
if	O
(	O
pnote	O
->	O
namesz	O
==	O
0	int
)	O
nt	O
=	O
get_note_type	O
(	O
filedata	O
,	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"GNU"	*(char)
)	O
)	O
nt	O
=	O
get_gnu_elf_note_type	O
(	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"FreeBSD"	*(char)
)	O
)	O
nt	O
=	O
get_freebsd_elfcore_note_type	O
(	O
filedata	O
,	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"NetBSD-CORE"	*(char)
)	O
)	O
nt	O
=	O
get_netbsd_elfcore_note_type	O
(	O
filedata	O
,	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"NetBSD"	*(char)
)	O
)	O
return	O
process_netbsd_elf_note	O
(	O
pnote	O
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"PaX"	*(char)
)	O
)	O
return	O
process_netbsd_elf_note	O
(	O
pnote	O
)	O
;	O
else	O
if	O
(	O
strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"SPU/"	*(char)
,	O
4	int
)	O
)	O
{	O
nt	O
=	O
pnote	O
->	O
namedata	O
+	O
4	int
;	O
name	*(char)
=	O
"SPU"	*(char)
;	O
}	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"IPF/VMS"	*(char)
)	O
)	O
nt	O
=	O
get_ia64_vms_note_type	O
(	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"stapsdt"	*(char)
)	O
)	O
nt	O
=	O
get_stapsdt_note_type	O
(	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
;	O
else	O
nt	O
=	O
get_note_type	O
(	O
filedata	O
,	O
pnote	O
->	O
type	enum(int,int,int,int)
)	O
;	O
printf	(*(char))->(int)
(	O
"  "	*(char)
)	O
;	O
if	O
(	O
(	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"GA"	*(char)
)	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
"*$!+"	*(char)
,	O
pnote	O
->	O
namedata	O
[	O
2	int
]	O
)	O
!=	O
NULL	O
)	O
||	O
strchr	(*(char),int)->(*(char))
(	O
"*$!+"	*(char)
,	O
pnote	O
->	O
namedata	O
[	O
0	int
]	O
)	O
!=	O
NULL	O
)	O
&&	O
(	O
pnote	O
->	O
type	enum(int,int,int,int)
==	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	O
||	O
pnote	O
->	O
type	enum(int,int,int,int)
==	O
NT_GNU_BUILD_ATTRIBUTE_FUNC	O
)	O
)	O
print_gnu_build_attribute_name	O
(	O
pnote	O
)	O
;	O
else	O
print_symbol	O
(	O
-	O
20	int
,	O
name	*(char)
)	O
;	O
if	O
(	O
do_wide	O
)	O
printf	(*(char))->(int)
(	O
" 0x%08lx\t%s\t"	*(char)
,	O
pnote	O
->	O
descsz	O
,	O
nt	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
" 0x%08lx\t%s\n"	*(char)
,	O
pnote	O
->	O
descsz	O
,	O
nt	O
)	O
;	O
if	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"IPF/VMS"	*(char)
)	O
)	O
return	O
print_ia64_vms_note	O
(	O
pnote	O
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"GNU"	*(char)
)	O
)	O
return	O
print_gnu_note	O
(	O
filedata	O
,	O
pnote	O
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"stapsdt"	*(char)
)	O
)	O
return	O
print_stapsdt_note	O
(	O
pnote	O
)	O
;	O
else	O
if	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"CORE"	*(char)
)	O
)	O
return	O
print_core_note	O
(	O
pnote	O
)	O
;	O
else	O
if	O
(	O
(	O
(	O
const_strneq	O
(	O
pnote	O
->	O
namedata	O
,	O
"GA"	*(char)
)	O
&&	O
strchr	(*(char),int)->(*(char))
(	O
"*$!+"	*(char)
,	O
pnote	O
->	O
namedata	O
[	O
2	int
]	O
)	O
!=	O
NULL	O
)	O
||	O
strchr	(*(char),int)->(*(char))
(	O
"*$!+"	*(char)
,	O
pnote	O
->	O
namedata	O
[	O
0	int
]	O
)	O
!=	O
NULL	O
)	O
&&	O
(	O
pnote	O
->	O
type	enum(int,int,int,int)
==	O
NT_GNU_BUILD_ATTRIBUTE_OPEN	O
||	O
pnote	O
->	O
type	enum(int,int,int,int)
==	O
NT_GNU_BUILD_ATTRIBUTE_FUNC	O
)	O
)	O
return	O
print_gnu_build_attribute_description	O
(	O
pnote	O
,	O
filedata	O
)	O
;	O
if	O
(	O
pnote	O
->	O
descsz	O
)	O
{	O
unsigned	O
long	O
i	*(struct)
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"   description data: "	*(char)
)	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
pnote	O
->	O
descsz	O
;	O
i	*(struct)
++	O
)	O
printf	(*(char))->(int)
(	O
"%02x "	*(char)
,	O
pnote	O
->	O
descdata	O
[	O
i	*(struct)
]	O
&	O
0xff	int
)	O
;	O
if	O
(	O
!	O
do_wide	O
)	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
if	O
(	O
do_wide	O
)	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
process_notes_at	O
(	O
Filedata	O
*	O
filedata	O
,	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
bfd_vma	long
offset	long
,	O
bfd_vma	long
length	O
,	O
bfd_vma	long
align	O
)	O
{	O
Elf_External_Note	O
*	O
pnotes	O
;	O
Elf_External_Note	O
*	O
external	O
;	O
char	O
*	O
end	*(*(char))
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
if	O
(	O
length	O
<=	O
0	int
)	O
return	O
FALSE	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
{	O
pnotes	O
=	O
(	O
Elf_External_Note	O
*	O
)	O
get_section_contents	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
filedata	O
)	O
;	O
if	O
(	O
pnotes	O
)	O
{	O
if	O
(	O
!	O
apply_relocations	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
(	O
unsigned	O
char	O
*	O
)	O
pnotes	O
,	O
length	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
}	O
else	O
pnotes	O
=	O
(	O
Elf_External_Note	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
offset	long
,	O
1	int
,	O
length	O
,	O
_	O
(	O
"notes"	*(char)
)	O
)	O
;	O
if	O
(	O
pnotes	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
external	O
=	O
pnotes	O
;	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nDisplaying notes found in: %s\n"	*(char)
)	O
,	O
printable_section_name	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
)	O
)	O
;	O
else	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nDisplaying notes found at file offset 0x%08lx with length 0x%08lx:\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
,	O
(	O
unsigned	O
long	O
)	O
length	O
)	O
;	O
if	O
(	O
align	O
<	O
4	int
)	O
align	O
=	O
4	int
;	O
else	O
if	O
(	O
align	O
!=	O
4	int
&&	O
align	O
!=	O
8	int
)	O
{	O
warn	O
(	O
_	O
(	O
"Corrupt note: alignment %ld, expecting 4 or 8\n"	*(char)
)	O
,	O
(	O
long	O
)	O
align	O
)	O
;	O
free	(*(void))->(void)
(	O
pnotes	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  %-20s %-10s\tDescription\n"	*(char)
)	O
,	O
_	O
(	O
"Owner"	*(char)
)	O
,	O
_	O
(	O
"Data size"	*(char)
)	O
)	O
;	O
end	*(*(char))
=	O
(	O
char	O
*	O
)	O
pnotes	O
+	O
length	O
;	O
while	O
(	O
(	O
char	O
*	O
)	O
external	O
<	O
end	*(*(char))
)	O
{	O
Elf_Internal_Note	O
inote	O
;	O
size_t	long
min_notesz	O
;	O
char	O
*	O
next	*(char)
;	O
char	O
*	O
temp	O
=	O
NULL	O
;	O
size_t	long
data_remaining	O
=	O
end	*(*(char))
-	O
(	O
char	O
*	O
)	O
external	O
;	O
if	O
(	O
!	O
is_ia64_vms	O
(	O
filedata	O
)	O
)	O
{	O
min_notesz	O
=	O
offsetof	O
(	O
Elf_External_Note	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
data_remaining	O
<	O
min_notesz	O
)	O
{	O
warn	O
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"Corrupt note: only %ld byte remains, "	*(char)
"not enough for a full note\n"	*(char)
,	O
"Corrupt note: only %ld bytes remain, "	*(char)
"not enough for a full note\n"	*(char)
,	O
data_remaining	O
)	O
,	O
(	O
long	O
)	O
data_remaining	O
)	O
;	O
break	O
;	O
}	O
data_remaining	O
-=	O
min_notesz	O
;	O
inote	O
.	O
type	enum(int,int,int,int)
=	O
BYTE_GET	O
(	O
external	O
->	O
type	enum(int,int,int,int)
)	O
;	O
inote	O
.	O
namesz	O
=	O
BYTE_GET	O
(	O
external	O
->	O
namesz	O
)	O
;	O
inote	O
.	O
namedata	O
=	O
external	O
->	O
name	*(char)
;	O
inote	O
.	O
descsz	O
=	O
BYTE_GET	O
(	O
external	O
->	O
descsz	O
)	O
;	O
inote	O
.	O
descdata	O
=	O
(	O
(	O
char	O
*	O
)	O
external	O
+	O
ELF_NOTE_DESC_OFFSET	O
(	O
inote	O
.	O
namesz	O
,	O
align	O
)	O
)	O
;	O
inote	O
.	O
descpos	O
=	O
offset	long
+	O
(	O
inote	O
.	O
descdata	O
-	O
(	O
char	O
*	O
)	O
pnotes	O
)	O
;	O
next	*(char)
=	O
(	O
(	O
char	O
*	O
)	O
external	O
+	O
ELF_NOTE_NEXT_OFFSET	O
(	O
inote	O
.	O
namesz	O
,	O
inote	O
.	O
descsz	O
,	O
align	O
)	O
)	O
;	O
}	O
else	O
{	O
Elf64_External_VMS_Note	O
*	O
vms_external	O
;	O
min_notesz	O
=	O
offsetof	O
(	O
Elf64_External_VMS_Note	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
data_remaining	O
<	O
min_notesz	O
)	O
{	O
warn	O
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"Corrupt note: only %ld byte remains, "	*(char)
"not enough for a full note\n"	*(char)
,	O
"Corrupt note: only %ld bytes remain, "	*(char)
"not enough for a full note\n"	*(char)
,	O
data_remaining	O
)	O
,	O
(	O
long	O
)	O
data_remaining	O
)	O
;	O
break	O
;	O
}	O
data_remaining	O
-=	O
min_notesz	O
;	O
vms_external	O
=	O
(	O
Elf64_External_VMS_Note	O
*	O
)	O
external	O
;	O
inote	O
.	O
type	enum(int,int,int,int)
=	O
BYTE_GET	O
(	O
vms_external	O
->	O
type	enum(int,int,int,int)
)	O
;	O
inote	O
.	O
namesz	O
=	O
BYTE_GET	O
(	O
vms_external	O
->	O
namesz	O
)	O
;	O
inote	O
.	O
namedata	O
=	O
vms_external	O
->	O
name	*(char)
;	O
inote	O
.	O
descsz	O
=	O
BYTE_GET	O
(	O
vms_external	O
->	O
descsz	O
)	O
;	O
inote	O
.	O
descdata	O
=	O
inote	O
.	O
namedata	O
+	O
align_power	O
(	O
inote	O
.	O
namesz	O
,	O
3	int
)	O
;	O
inote	O
.	O
descpos	O
=	O
offset	long
+	O
(	O
inote	O
.	O
descdata	O
-	O
(	O
char	O
*	O
)	O
pnotes	O
)	O
;	O
next	*(char)
=	O
inote	O
.	O
descdata	O
+	O
align_power	O
(	O
inote	O
.	O
descsz	O
,	O
3	int
)	O
;	O
}	O
if	O
(	O
(	O
size_t	long
)	O
(	O
inote	O
.	O
descdata	O
-	O
inote	O
.	O
namedata	O
)	O
<	O
inote	O
.	O
namesz	O
||	O
(	O
size_t	long
)	O
(	O
inote	O
.	O
descdata	O
-	O
inote	O
.	O
namedata	O
)	O
>	O
data_remaining	O
||	O
(	O
size_t	long
)	O
(	O
next	*(char)
-	O
inote	O
.	O
descdata	O
)	O
<	O
inote	O
.	O
descsz	O
||	O
(	O
(	O
size_t	long
)	O
(	O
next	*(char)
-	O
inote	O
.	O
descdata	O
)	O
>	O
data_remaining	O
-	O
(	O
size_t	long
)	O
(	O
inote	O
.	O
descdata	O
-	O
inote	O
.	O
namedata	O
)	O
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"note with invalid namesz and/or descsz found at offset 0x%lx\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
(	O
char	O
*	O
)	O
external	O
-	O
(	O
char	O
*	O
)	O
pnotes	O
)	O
)	O
;	O
warn	O
(	O
_	O
(	O
" type: 0x%lx, namesize: 0x%08lx, descsize: 0x%08lx, alignment: %u\n"	*(char)
)	O
,	O
inote	O
.	O
type	enum(int,int,int,int)
,	O
inote	O
.	O
namesz	O
,	O
inote	O
.	O
descsz	O
,	O
(	O
int	O
)	O
align	O
)	O
;	O
break	O
;	O
}	O
external	O
=	O
(	O
Elf_External_Note	O
*	O
)	O
next	*(char)
;	O
if	O
(	O
inote	O
.	O
namesz	O
>	O
0	int
&&	O
inote	O
.	O
namedata	O
[	O
inote	O
.	O
namesz	O
-	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
(	O
size_t	long
)	O
(	O
inote	O
.	O
descdata	O
-	O
inote	O
.	O
namedata	O
)	O
==	O
inote	O
.	O
namesz	O
)	O
{	O
temp	O
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
inote	O
.	O
namesz	O
+	O
1	int
)	O
;	O
if	O
(	O
temp	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory allocating space for inote name\n"	*(char)
)	O
)	O
;	O
res	O
=	O
FALSE	O
;	O
break	O
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
temp	O
,	O
inote	O
.	O
namedata	O
,	O
inote	O
.	O
namesz	O
)	O
;	O
inote	O
.	O
namedata	O
=	O
temp	O
;	O
}	O
inote	O
.	O
namedata	O
[	O
inote	O
.	O
namesz	O
]	O
=	O
0	int
;	O
}	O
if	O
(	O
!	O
process_note	O
(	O
&	O
inote	O
,	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
if	O
(	O
temp	O
!=	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
temp	O
)	O
;	O
temp	O
=	O
NULL	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
pnotes	O
)	O
;	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
process_corefile_note_segments	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Phdr	O
*	O
segment	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
if	O
(	O
!	O
get_program_headers	O
(	O
filedata	O
)	O
)	O
return	O
TRUE	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
segment	O
=	O
filedata	O
->	O
program_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
;	O
i	*(struct)
++	O
,	O
segment	O
++	O
)	O
{	O
if	O
(	O
segment	O
->	O
p_type	O
==	O
PT_NOTE	O
)	O
if	O
(	O
!	O
process_notes_at	O
(	O
filedata	O
,	O
NULL	O
,	O
(	O
bfd_vma	long
)	O
segment	O
->	O
p_offset	O
,	O
(	O
bfd_vma	long
)	O
segment	O
->	O
p_filesz	O
,	O
(	O
bfd_vma	long
)	O
segment	O
->	O
p_align	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
process_v850_notes	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_vma	long
offset	long
,	O
bfd_vma	long
length	O
)	O
{	O
Elf_External_Note	O
*	O
pnotes	O
;	O
Elf_External_Note	O
*	O
external	O
;	O
char	O
*	O
end	*(*(char))
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
if	O
(	O
length	O
<=	O
0	int
)	O
return	O
FALSE	O
;	O
pnotes	O
=	O
(	O
Elf_External_Note	O
*	O
)	O
get_data	O
(	O
NULL	O
,	O
filedata	O
,	O
offset	long
,	O
1	int
,	O
length	O
,	O
_	O
(	O
"v850 notes"	*(char)
)	O
)	O
;	O
if	O
(	O
pnotes	O
==	O
NULL	O
)	O
return	O
FALSE	O
;	O
external	O
=	O
pnotes	O
;	O
end	*(*(char))
=	O
(	O
char	O
*	O
)	O
pnotes	O
+	O
length	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nDisplaying contents of Renesas V850 notes section at offset 0x%lx with length 0x%lx:\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
offset	long
,	O
(	O
unsigned	O
long	O
)	O
length	O
)	O
;	O
while	O
(	O
(	O
char	O
*	O
)	O
external	O
+	O
sizeof	O
(	O
Elf_External_Note	O
)	O
<	O
end	*(*(char))
)	O
{	O
Elf_External_Note	O
*	O
next	*(char)
;	O
Elf_Internal_Note	O
inote	O
;	O
inote	O
.	O
type	enum(int,int,int,int)
=	O
BYTE_GET	O
(	O
external	O
->	O
type	enum(int,int,int,int)
)	O
;	O
inote	O
.	O
namesz	O
=	O
BYTE_GET	O
(	O
external	O
->	O
namesz	O
)	O
;	O
inote	O
.	O
namedata	O
=	O
external	O
->	O
name	*(char)
;	O
inote	O
.	O
descsz	O
=	O
BYTE_GET	O
(	O
external	O
->	O
descsz	O
)	O
;	O
inote	O
.	O
descdata	O
=	O
inote	O
.	O
namedata	O
+	O
align_power	O
(	O
inote	O
.	O
namesz	O
,	O
2	int
)	O
;	O
inote	O
.	O
descpos	O
=	O
offset	long
+	O
(	O
inote	O
.	O
descdata	O
-	O
(	O
char	O
*	O
)	O
pnotes	O
)	O
;	O
if	O
(	O
inote	O
.	O
descdata	O
<	O
(	O
char	O
*	O
)	O
pnotes	O
||	O
inote	O
.	O
descdata	O
>=	O
end	*(*(char))
)	O
{	O
warn	O
(	O
_	O
(	O
"Corrupt note: name size is too big: %lx\n"	*(char)
)	O
,	O
inote	O
.	O
namesz	O
)	O
;	O
inote	O
.	O
descdata	O
=	O
inote	O
.	O
namedata	O
;	O
inote	O
.	O
namesz	O
=	O
0	int
;	O
}	O
next	*(char)
=	O
(	O
Elf_External_Note	O
*	O
)	O
(	O
inote	O
.	O
descdata	O
+	O
align_power	O
(	O
inote	O
.	O
descsz	O
,	O
2	int
)	O
)	O
;	O
if	O
(	O
(	O
(	O
char	O
*	O
)	O
next	*(char)
>	O
end	*(*(char))
)	O
||	O
(	O
(	O
char	O
*	O
)	O
next	*(char)
<	O
(	O
char	O
*	O
)	O
pnotes	O
)	O
)	O
{	O
warn	O
(	O
_	O
(	O
"corrupt descsz found in note at offset 0x%lx\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
(	O
char	O
*	O
)	O
external	O
-	O
(	O
char	O
*	O
)	O
pnotes	O
)	O
)	O
;	O
warn	O
(	O
_	O
(	O
" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n"	*(char)
)	O
,	O
inote	O
.	O
type	enum(int,int,int,int)
,	O
inote	O
.	O
namesz	O
,	O
inote	O
.	O
descsz	O
)	O
;	O
break	O
;	O
}	O
external	O
=	O
next	*(char)
;	O
if	O
(	O
inote	O
.	O
namedata	O
+	O
inote	O
.	O
namesz	O
>	O
end	*(*(char))
||	O
inote	O
.	O
namedata	O
+	O
inote	O
.	O
namesz	O
<	O
inote	O
.	O
namedata	O
)	O
{	O
warn	O
(	O
_	O
(	O
"corrupt namesz found in note at offset 0x%lx\n"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
(	O
(	O
char	O
*	O
)	O
external	O
-	O
(	O
char	O
*	O
)	O
pnotes	O
)	O
)	O
;	O
warn	O
(	O
_	O
(	O
" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n"	*(char)
)	O
,	O
inote	O
.	O
type	enum(int,int,int,int)
,	O
inote	O
.	O
namesz	O
,	O
inote	O
.	O
descsz	O
)	O
;	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
"  %s: "	*(char)
,	O
get_v850_elf_note_type	O
(	O
inote	O
.	O
type	enum(int,int,int,int)
)	O
)	O
;	O
if	O
(	O
!	O
print_v850_note	O
(	O
&	O
inote	O
)	O
)	O
{	O
res	O
=	O
FALSE	O
;	O
printf	(*(char))->(int)
(	O
"<corrupt sizes: namesz: %lx, descsz: %lx>\n"	*(char)
,	O
inote	O
.	O
namesz	O
,	O
inote	O
.	O
descsz	O
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
pnotes	O
)	O
;	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
process_note_sections	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
Elf_Internal_Shdr	O
*	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
;	O
unsigned	O
long	O
i	*(struct)
;	O
unsigned	O
int	O
n	O
=	O
0	int
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
for	O
(	O
i	*(struct)
=	O
0	int
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
=	O
filedata	O
->	O
section_headers	O
;	O
i	*(struct)
<	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
!=	O
NULL	O
;	O
i	*(struct)
++	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
++	O
)	O
{	O
if	O
(	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_NOTE	O
)	O
{	O
if	O
(	O
!	O
process_notes_at	O
(	O
filedata	O
,	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
,	O
(	O
bfd_vma	long
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
(	O
bfd_vma	long
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
,	O
(	O
bfd_vma	long
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_addralign	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
n	O
++	O
;	O
}	O
if	O
(	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_V800	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_V850	O
||	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
==	O
EM_CYGNUS_V850	O
)	O
&&	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_type	O
==	O
SHT_RENESAS_INFO	O
)	O
{	O
if	O
(	O
!	O
process_v850_notes	O
(	O
filedata	O
,	O
(	O
bfd_vma	long
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_offset	O
,	O
(	O
bfd_vma	long
)	O
section	*(struct(*(char),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct(long,int)),int,long,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),int,*(struct),*(*(struct)),int,long,long,long,*(void),*(char),*(struct(int,union(*`,long))),int,int,*(struct(*(char),int,int,*(struct`),*(struct`),int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*(struct`),int,long,*(struct`),int,*(struct`),*(*`),int,long,long,long,*(void),*(char),*(struct`),int,int,*(struct`),long,int,*(void),*(struct`),*(struct`),*(struct`),*(*`),union(*`,*`),union(*`,*`))),long,int,*(void),*(struct),*(struct),*(struct),*(*(struct)),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`))),union(*(struct),*(struct(*`,int,int,*`,*`,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,long,long,long,long,long,*`,int,long,*`,int,*`,*`,int,long,long,long,*`,*`,*`,int,int,*`,long,int,*`,*`,*`,*`,*`,union`,union`)))))
->	O
sh_size	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
n	O
++	O
;	O
}	O
}	O
if	O
(	O
n	O
==	O
0	int
)	O
return	O
process_corefile_note_segments	O
(	O
filedata	O
)	O
;	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
process_notes	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
if	O
(	O
!	O
do_notes	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_type	O
!=	O
ET_CORE	O
)	O
return	O
process_note_sections	O
(	O
filedata	O
)	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
>	O
0	int
)	O
return	O
process_corefile_note_segments	O
(	O
filedata	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"No note segments present in the core file.\n"	*(char)
)	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_public_gnu_attributes	O
(	O
unsigned	O
char	O
*	O
start	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  Unknown GNU attribute: %s\n"	*(char)
)	O
,	O
start	O
)	O
;	O
start	O
+=	O
strnlen	(*(char),long)->(long)
(	O
(	O
char	O
*	O
)	O
start	O
,	O
end	*(*(char))
-	O
start	O
)	O
;	O
display_raw_attribute	O
(	O
start	O
,	O
end	*(*(char))
)	O
;	O
return	O
(	O
unsigned	O
char	O
*	O
)	O
end	*(*(char))
;	O
}	O
static	O
unsigned	O
char	O
*	O
display_generic_attribute	O
(	O
unsigned	O
char	O
*	O
start	O
,	O
unsigned	O
int	O
tag	O
,	O
const	O
unsigned	O
char	O
*	O
const	O
end	*(*(char))
)	O
{	O
if	O
(	O
tag	O
==	O
0	int
)	O
return	O
(	O
unsigned	O
char	O
*	O
)	O
end	*(*(char))
;	O
return	O
display_tag_value	O
(	O
tag	O
,	O
start	O
,	O
end	*(*(char))
)	O
;	O
}	O
static	O
bfd_boolean	int
process_arch_specific	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
if	O
(	O
!	O
do_arch	O
)	O
return	O
TRUE	int
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
)	O
{	O
case	O
EM_ARC	O
:	O
case	O
EM_ARC_COMPACT	O
:	O
case	O
EM_ARC_COMPACT2	O
:	O
return	O
process_attributes	O
(	O
filedata	O
,	O
"ARC"	*(char)
,	O
SHT_ARC_ATTRIBUTES	O
,	O
display_arc_attribute	O
,	O
display_generic_attribute	O
)	O
;	O
case	O
EM_ARM	O
:	O
return	O
process_attributes	O
(	O
filedata	O
,	O
"aeabi"	*(char)
,	O
SHT_ARM_ATTRIBUTES	O
,	O
display_arm_attribute	O
,	O
display_generic_attribute	O
)	O
;	O
case	O
EM_MIPS	O
:	O
case	O
EM_MIPS_RS3_LE	O
:	O
return	O
process_mips_specific	O
(	O
filedata	O
)	O
;	O
case	O
EM_MSP430	O
:	O
return	O
process_attributes	O
(	O
filedata	O
,	O
"mspabi"	*(char)
,	O
SHT_MSP430_ATTRIBUTES	O
,	O
display_msp430x_attribute	O
,	O
display_msp430_gnu_attribute	O
)	O
;	O
case	O
EM_RISCV	O
:	O
return	O
process_attributes	O
(	O
filedata	O
,	O
"riscv"	*(char)
,	O
SHT_RISCV_ATTRIBUTES	O
,	O
display_riscv_attribute	O
,	O
display_generic_attribute	O
)	O
;	O
case	O
EM_NDS32	O
:	O
return	O
process_nds32_specific	O
(	O
filedata	O
)	O
;	O
case	O
EM_PPC	O
:	O
case	O
EM_PPC64	O
:	O
return	O
process_attributes	O
(	O
filedata	O
,	O
NULL	O
,	O
SHT_GNU_ATTRIBUTES	O
,	O
NULL	O
,	O
display_power_gnu_attribute	O
)	O
;	O
case	O
EM_S390	O
:	O
case	O
EM_S390_OLD	O
:	O
return	O
process_attributes	O
(	O
filedata	O
,	O
NULL	O
,	O
SHT_GNU_ATTRIBUTES	O
,	O
NULL	O
,	O
display_s390_gnu_attribute	O
)	O
;	O
case	O
EM_SPARC	O
:	O
case	O
EM_SPARC32PLUS	O
:	O
case	O
EM_SPARCV9	O
:	O
return	O
process_attributes	O
(	O
filedata	O
,	O
NULL	O
,	O
SHT_GNU_ATTRIBUTES	O
,	O
NULL	O
,	O
display_sparc_gnu_attribute	O
)	O
;	O
case	O
EM_TI_C6000	O
:	O
return	O
process_attributes	O
(	O
filedata	O
,	O
"c6xabi"	*(char)
,	O
SHT_C6000_ATTRIBUTES	O
,	O
display_tic6x_attribute	O
,	O
display_generic_attribute	O
)	O
;	O
default	O
:	O
return	O
process_attributes	O
(	O
filedata	O
,	O
"gnu"	*(char)
,	O
SHT_GNU_ATTRIBUTES	O
,	O
display_public_gnu_attributes	O
,	O
display_generic_attribute	O
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
get_file_header	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
,	O
EI_NIDENT	O
,	O
1	int
,	O
filedata	O
->	O
handle	O
)	O
!=	O
1	int
)	O
return	O
FALSE	O
;	O
switch	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_DATA	O
]	O
)	O
{	O
default	O
:	O
case	O
ELFDATANONE	O
:	O
case	O
ELFDATA2LSB	O
:	O
byte_get	O
=	O
byte_get_little_endian	O
;	O
byte_put	O
=	O
byte_put_little_endian	O
;	O
break	O
;	O
case	O
ELFDATA2MSB	O
:	O
byte_get	O
=	O
byte_get_big_endian	O
;	O
byte_put	O
=	O
byte_put_big_endian	O
;	O
break	O
;	O
}	O
is_32bit_elf	O
=	O
(	O
filedata	O
->	O
file_header	O
.	O
e_ident	O
[	O
EI_CLASS	O
]	O
!=	O
ELFCLASS64	O
)	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
{	O
Elf32_External_Ehdr	O
ehdr32	O
;	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
ehdr32	O
.	O
e_type	O
,	O
sizeof	O
(	O
ehdr32	O
)	O
-	O
EI_NIDENT	O
,	O
1	int
,	O
filedata	O
->	O
handle	O
)	O
!=	O
1	int
)	O
return	O
FALSE	O
;	O
filedata	O
->	O
file_header	O
.	O
e_type	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_type	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_machine	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_version	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_version	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_entry	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_entry	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_phoff	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_phoff	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_shoff	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_shoff	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_flags	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_flags	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_ehsize	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_ehsize	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_phentsize	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_phentsize	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_phnum	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_shentsize	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_shentsize	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_shnum	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_shstrndx	O
=	O
BYTE_GET	O
(	O
ehdr32	O
.	O
e_shstrndx	O
)	O
;	O
}	O
else	O
{	O
Elf64_External_Ehdr	O
ehdr64	O
;	O
if	O
(	O
sizeof	O
(	O
bfd_vma	long
)	O
<	O
8	int
)	O
{	O
error	O
(	O
_	O
(	O
"This instance of readelf has been built without support for a\n64 bit data type and so it cannot read 64 bit ELF files.\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
ehdr64	O
.	O
e_type	O
,	O
sizeof	O
(	O
ehdr64	O
)	O
-	O
EI_NIDENT	O
,	O
1	int
,	O
filedata	O
->	O
handle	O
)	O
!=	O
1	int
)	O
return	O
FALSE	O
;	O
filedata	O
->	O
file_header	O
.	O
e_type	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_type	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_machine	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_machine	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_version	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_version	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_entry	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_entry	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_phoff	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_phoff	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_shoff	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_shoff	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_flags	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_flags	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_ehsize	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_ehsize	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_phentsize	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_phentsize	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_phnum	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_phnum	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_shentsize	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_shentsize	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_shnum	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_shnum	O
)	O
;	O
filedata	O
->	O
file_header	O
.	O
e_shstrndx	O
=	O
BYTE_GET	O
(	O
ehdr64	O
.	O
e_shstrndx	O
)	O
;	O
}	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_shoff	O
)	O
{	O
if	O
(	O
is_32bit_elf	O
)	O
get_32bit_section_headers	O
(	O
filedata	O
,	O
TRUE	int
)	O
;	O
else	O
get_64bit_section_headers	O
(	O
filedata	O
,	O
TRUE	int
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
void	O
close_file	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
if	O
(	O
filedata	O
)	O
{	O
if	O
(	O
filedata	O
->	O
handle	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
filedata	O
->	O
handle	O
)	O
;	O
free	(*(void))->(void)
(	O
filedata	O
)	O
;	O
}	O
}	O
void	O
close_debug_file	O
(	O
void	O
*	O
data	*(void)
)	O
{	O
close_file	O
(	O
(	O
Filedata	O
*	O
)	O
data	*(void)
)	O
;	O
}	O
static	O
Filedata	O
*	O
open_file	O
(	O
const	O
char	O
*	O
pathname	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	O
;	O
Filedata	O
*	O
filedata	O
=	O
NULL	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
pathname	O
,	O
&	O
statbuf	O
)	O
<	O
0	int
||	O
!	O
S_ISREG	O
(	O
statbuf	O
.	O
st_mode	int
)	O
)	O
goto	O
fail	O
;	O
filedata	O
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
*	O
filedata	O
)	O
;	O
if	O
(	O
filedata	O
==	O
NULL	O
)	O
goto	O
fail	O
;	O
filedata	O
->	O
handle	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
pathname	O
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
filedata	O
->	O
handle	O
==	O
NULL	O
)	O
goto	O
fail	O
;	O
filedata	O
->	O
file_size	O
=	O
(	O
bfd_size_type	long
)	O
statbuf	O
.	O
st_size	long
;	O
filedata	O
->	O
file_name	O
=	O
pathname	O
;	O
if	O
(	O
!	O
get_file_header	O
(	O
filedata	O
)	O
)	O
goto	O
fail	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_shoff	O
)	O
{	O
bfd_boolean	int
res	O
;	O
if	O
(	O
is_32bit_elf	O
)	O
res	O
=	O
get_32bit_section_headers	O
(	O
filedata	O
,	O
FALSE	O
)	O
;	O
else	O
res	O
=	O
get_64bit_section_headers	O
(	O
filedata	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
!	O
res	O
)	O
goto	O
fail	O
;	O
}	O
return	O
filedata	O
;	O
fail	O
:	O
if	O
(	O
filedata	O
)	O
{	O
if	O
(	O
filedata	O
->	O
handle	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
filedata	O
->	O
handle	O
)	O
;	O
free	(*(void))->(void)
(	O
filedata	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
*	O
open_debug_file	O
(	O
const	O
char	O
*	O
pathname	O
)	O
{	O
return	O
open_file	O
(	O
pathname	O
)	O
;	O
}	O
static	O
bfd_boolean	int
process_object	O
(	O
Filedata	O
*	O
filedata	O
)	O
{	O
bfd_boolean	int
have_separate_files	O
;	O
unsigned	O
int	O
i	*(struct)
;	O
bfd_boolean	int
res	O
=	O
TRUE	int
;	O
if	O
(	O
!	O
get_file_header	O
(	O
filedata	O
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Failed to read file header\n"	*(char)
)	O
,	O
filedata	O
->	O
file_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
for	O
(	O
i	*(struct)
=	O
ARRAY_SIZE	O
(	O
version_info	O
)	O
;	O
i	*(struct)
--	O
;	O
)	O
version_info	O
[	O
i	*(struct)
]	O
=	O
0	int
;	O
for	O
(	O
i	*(struct)
=	O
ARRAY_SIZE	O
(	O
dynamic_info	O
)	O
;	O
i	*(struct)
--	O
;	O
)	O
dynamic_info	O
[	O
i	*(struct)
]	O
=	O
0	int
;	O
dynamic_info_DT_GNU_HASH	O
=	O
0	int
;	O
dynamic_info_DT_MIPS_XHASH	O
=	O
0	int
;	O
if	O
(	O
show_name	O
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nFile: %s\n"	*(char)
)	O
,	O
filedata	O
->	O
file_name	O
)	O
;	O
if	O
(	O
filedata	O
->	O
num_dump_sects	O
>	O
cmdline	O
.	O
num_dump_sects	O
)	O
memset	(*(void),int,long)->(*(void))
(	O
filedata	O
->	O
dump_sects	O
,	O
0	int
,	O
filedata	O
->	O
num_dump_sects	O
*	O
sizeof	O
(	O
*	O
filedata	O
->	O
dump_sects	O
)	O
)	O
;	O
if	O
(	O
cmdline	O
.	O
num_dump_sects	O
>	O
0	int
)	O
{	O
if	O
(	O
filedata	O
->	O
num_dump_sects	O
==	O
0	int
)	O
request_dump_bynumber	O
(	O
filedata	O
,	O
cmdline	O
.	O
num_dump_sects	O
,	O
0	int
)	O
;	O
assert	O
(	O
filedata	O
->	O
num_dump_sects	O
>=	O
cmdline	O
.	O
num_dump_sects	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
filedata	O
->	O
dump_sects	O
,	O
cmdline	O
.	O
dump_sects	O
,	O
cmdline	O
.	O
num_dump_sects	O
*	O
sizeof	O
(	O
*	O
filedata	O
->	O
dump_sects	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
process_file_header	O
(	O
filedata	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
!	O
process_section_headers	O
(	O
filedata	O
)	O
)	O
{	O
do_unwind	O
=	O
do_version	O
=	O
do_dump	O
=	O
do_arch	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
do_using_dynamic	O
)	O
do_syms	O
=	O
do_dyn_syms	O
=	O
do_reloc	O
=	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
process_section_groups	O
(	O
filedata	O
)	O
)	O
do_unwind	O
=	O
FALSE	O
;	O
if	O
(	O
process_program_headers	O
(	O
filedata	O
)	O
)	O
process_dynamic_section	O
(	O
filedata	O
)	O
;	O
else	O
res	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
process_relocs	O
(	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
process_unwind	O
(	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
process_symbol_table	O
(	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
process_syminfo	O
(	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
process_version_sections	O
(	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
if	O
(	O
filedata	O
->	O
file_header	O
.	O
e_shstrndx	O
!=	O
SHN_UNDEF	O
)	O
have_separate_files	O
=	O
load_separate_debug_files	O
(	O
filedata	O
,	O
filedata	O
->	O
file_name	O
)	O
;	O
else	O
have_separate_files	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
process_section_contents	O
(	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
if	O
(	O
have_separate_files	O
)	O
{	O
separate_info	O
*	O
d	O
;	O
for	O
(	O
d	O
=	O
first_separate_info	O
;	O
d	O
!=	O
NULL	O
;	O
d	O
=	O
d	O
->	O
next	*(char)
)	O
{	O
if	O
(	O
!	O
process_section_headers	O
(	O
d	O
->	O
handle	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
else	O
if	O
(	O
!	O
process_section_contents	O
(	O
d	O
->	O
handle	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
!	O
process_notes	O
(	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
process_gnu_liblist	O
(	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
if	O
(	O
!	O
process_arch_specific	O
(	O
filedata	O
)	O
)	O
res	O
=	O
FALSE	O
;	O
free	(*(void))->(void)
(	O
filedata	O
->	O
program_headers	O
)	O
;	O
filedata	O
->	O
program_headers	O
=	O
NULL	O
;	O
free	(*(void))->(void)
(	O
filedata	O
->	O
section_headers	O
)	O
;	O
filedata	O
->	O
section_headers	O
=	O
NULL	O
;	O
free	(*(void))->(void)
(	O
filedata	O
->	O
string_table	O
)	O
;	O
filedata	O
->	O
string_table	O
=	O
NULL	O
;	O
filedata	O
->	O
string_table_length	O
=	O
0	int
;	O
if	O
(	O
filedata	O
->	O
dump_sects	O
!=	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
filedata	O
->	O
dump_sects	O
)	O
;	O
filedata	O
->	O
dump_sects	O
=	O
NULL	O
;	O
filedata	O
->	O
num_dump_sects	O
=	O
0	int
;	O
}	O
if	O
(	O
dynamic_strings	O
)	O
{	O
free	(*(void))->(void)
(	O
dynamic_strings	O
)	O
;	O
dynamic_strings	O
=	O
NULL	O
;	O
dynamic_strings_length	O
=	O
0	int
;	O
}	O
if	O
(	O
dynamic_symbols	O
)	O
{	O
free	(*(void))->(void)
(	O
dynamic_symbols	O
)	O
;	O
dynamic_symbols	O
=	O
NULL	O
;	O
num_dynamic_syms	O
=	O
0	int
;	O
}	O
if	O
(	O
dynamic_syminfo	O
)	O
{	O
free	(*(void))->(void)
(	O
dynamic_syminfo	O
)	O
;	O
dynamic_syminfo	O
=	O
NULL	O
;	O
}	O
if	O
(	O
dynamic_section	O
)	O
{	O
free	(*(void))->(void)
(	O
dynamic_section	O
)	O
;	O
dynamic_section	O
=	O
NULL	O
;	O
}	O
if	O
(	O
section_headers_groups	O
)	O
{	O
free	(*(void))->(void)
(	O
section_headers_groups	O
)	O
;	O
section_headers_groups	O
=	O
NULL	O
;	O
}	O
if	O
(	O
section_groups	O
)	O
{	O
struct	O
group_list	O
*	O
g	O
;	O
struct	O
group_list	O
*	O
next	*(char)
;	O
for	O
(	O
i	*(struct)
=	O
0	int
;	O
i	*(struct)
<	O
group_count	O
;	O
i	*(struct)
++	O
)	O
{	O
for	O
(	O
g	O
=	O
section_groups	O
[	O
i	*(struct)
]	O
.	O
root	O
;	O
g	O
!=	O
NULL	O
;	O
g	O
=	O
next	*(char)
)	O
{	O
next	*(char)
=	O
g	O
->	O
next	*(char)
;	O
free	(*(void))->(void)
(	O
g	O
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
section_groups	O
)	O
;	O
section_groups	O
=	O
NULL	O
;	O
}	O
free_debug_memory	O
(	O
)	O
;	O
return	O
res	O
;	O
}	O
static	O
bfd_boolean	int
process_archive	O
(	O
Filedata	O
*	O
filedata	O
,	O
bfd_boolean	int
is_thin_archive	int
)	O
{	O
struct	O
archive_info	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
;	O
struct	O
archive_info	O
nested_arch	O
;	O
size_t	long
got	O
;	O
bfd_boolean	int
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
TRUE	int
;	O
show_name	O
=	O
TRUE	int
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
file_name	O
=	O
NULL	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
file	*(struct)
=	O
NULL	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
index_array	O
=	O
NULL	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_table	O
=	O
NULL	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
longnames	O
=	O
NULL	O
;	O
nested_arch	O
.	O
file_name	O
=	O
NULL	O
;	O
nested_arch	O
.	O
file	*(struct)
=	O
NULL	O
;	O
nested_arch	O
.	O
index_array	O
=	O
NULL	O
;	O
nested_arch	O
.	O
sym_table	O
=	O
NULL	O
;	O
nested_arch	O
.	O
longnames	O
=	O
NULL	O
;	O
if	O
(	O
setup_archive	O
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
filedata	O
->	O
file_name	O
,	O
filedata	O
->	O
handle	O
,	O
is_thin_archive	int
,	O
do_archive_index	O
)	O
!=	O
0	int
)	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
goto	O
out	*((*(void),*(char),int)->(int))
;	O
}	O
if	O
(	O
do_archive_index	O
)	O
{	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_table	O
==	O
NULL	O
)	O
error	O
(	O
_	O
(	O
"%s: unable to dump the index as none was found\n"	*(char)
)	O
,	O
filedata	O
->	O
file_name	O
)	O
;	O
else	O
{	O
unsigned	O
long	O
i	*(struct)
,	O
l	O
;	O
unsigned	O
long	O
current_pos	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Index of archive %s: (%lu entries, 0x%lx bytes in the symbol table)\n"	*(char)
)	O
,	O
filedata	O
->	O
file_name	O
,	O
(	O
unsigned	O
long	O
)	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
index_num	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_size	O
)	O
;	O
current_pos	O
=	O
ftell	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
filedata	O
->	O
handle	O
)	O
;	O
for	O
(	O
i	*(struct)
=	O
l	O
=	O
0	int
;	O
i	*(struct)
<	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
index_num	O
;	O
i	*(struct)
++	O
)	O
{	O
if	O
(	O
(	O
i	*(struct)
==	O
0	int
)	O
||	O
(	O
(	O
i	*(struct)
>	O
0	int
)	O
&&	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
index_array	O
[	O
i	*(struct)
]	O
!=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
index_array	O
[	O
i	*(struct)
-	O
1	int
]	O
)	O
)	O
)	O
{	O
char	O
*	O
member_name	O
;	O
member_name	O
=	O
get_archive_member_name_at	O
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
index_array	O
[	O
i	*(struct)
]	O
,	O
&	O
nested_arch	O
)	O
;	O
if	O
(	O
member_name	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
qualified_name	O
=	O
make_qualified_name	O
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
nested_arch	O
,	O
member_name	O
)	O
;	O
if	O
(	O
qualified_name	O
!=	O
NULL	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Contents of binary %s at offset "	*(char)
)	O
,	O
qualified_name	O
)	O
;	O
(	O
void	O
)	O
print_vma	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
index_array	O
[	O
i	*(struct)
]	O
,	O
PREFIX_HEX	O
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
free	(*(void))->(void)
(	O
qualified_name	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
l	O
>=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_size	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: end of the symbol table reached before the end of the index\n"	*(char)
)	O
,	O
filedata	O
->	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
break	O
;	O
}	O
printf	(*(char))->(int)
(	O
"\t%.*s\n"	*(char)
,	O
(	O
int	O
)	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_size	O
-	O
l	O
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_table	O
+	O
l	O
)	O
;	O
l	O
+=	O
strnlen	(*(char),long)->(long)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_table	O
+	O
l	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_size	O
-	O
l	O
)	O
+	O
1	int
;	O
}	O
if	O
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
uses_64bit_indices	O
)	O
l	O
=	O
(	O
l	O
+	O
7	int
)	O
&	O
~	O
7	int
;	O
else	O
l	O
+=	O
l	O
&	O
1	int
;	O
if	O
(	O
l	O
<	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_size	O
)	O
{	O
error	O
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"%s: %ld byte remains in the symbol table, "	*(char)
"but without corresponding entries in "	*(char)
"the index table\n"	*(char)
,	O
"%s: %ld bytes remain in the symbol table, "	*(char)
"but without corresponding entries in "	*(char)
"the index table\n"	*(char)
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_size	O
-	O
l	O
)	O
,	O
filedata	O
->	O
file_name	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
sym_size	O
-	O
l	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
}	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
filedata	O
->	O
handle	O
,	O
current_pos	O
,	O
SEEK_SET	O
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to seek back to start of object files in the archive\n"	*(char)
)	O
,	O
filedata	O
->	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
goto	O
out	*((*(void),*(char),int)->(int))
;	O
}	O
}	O
if	O
(	O
!	O
do_dynamic	O
&&	O
!	O
do_syms	O
&&	O
!	O
do_reloc	O
&&	O
!	O
do_unwind	O
&&	O
!	O
do_sections	O
&&	O
!	O
do_segments	O
&&	O
!	O
do_header	O
&&	O
!	O
do_dump	O
&&	O
!	O
do_version	O
&&	O
!	O
do_histogram	O
&&	O
!	O
do_debugging	O
&&	O
!	O
do_arch	O
&&	O
!	O
do_notes	O
&&	O
!	O
do_section_groups	O
&&	O
!	O
do_dyn_syms	O
)	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
TRUE	int
;	O
goto	O
out	*((*(void),*(char),int)->(int))
;	O
}	O
}	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
name	*(char)
;	O
size_t	long
namelen	O
;	O
char	O
*	O
qualified_name	O
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
filedata	O
->	O
handle	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
next_arhdr_offset	O
,	O
SEEK_SET	O
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to seek to next archive header\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
file_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
got	O
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
,	O
1	int
,	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
,	O
filedata	O
->	O
handle	O
)	O
;	O
if	O
(	O
got	O
!=	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
)	O
{	O
if	O
(	O
got	O
==	O
0	int
)	O
break	O
;	O
error	O
(	O
_	O
(	O
"%s: failed to read archive header\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
break	O
;	O
}	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
.	O
ar_fmag	O
,	O
ARFMAG	O
,	O
2	int
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: did not find a valid archive header\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
break	O
;	O
}	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
next_arhdr_offset	O
+=	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
;	O
archive_file_size	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
.	O
ar_size	O
,	O
NULL	O
,	O
10	int
)	O
;	O
if	O
(	O
archive_file_size	O
&	O
01	int
)	O
++	O
archive_file_size	O
;	O
name	*(char)
=	O
get_archive_member_name	O
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
nested_arch	O
)	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: bad archive file name\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
break	O
;	O
}	O
namelen	O
=	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
;	O
qualified_name	O
=	O
make_qualified_name	O
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
,	O
&	O
nested_arch	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
qualified_name	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: bad archive file name\n"	*(char)
)	O
,	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
break	O
;	O
}	O
if	O
(	O
is_thin_archive	int
&&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
nested_member_origin	O
==	O
0	int
)	O
{	O
Filedata	O
*	O
member_filedata	O
;	O
char	O
*	O
member_file_name	O
=	O
adjust_relative_path	O
(	O
filedata	O
->	O
file_name	O
,	O
name	*(char)
,	O
namelen	O
)	O
;	O
if	O
(	O
member_file_name	O
==	O
NULL	O
)	O
{	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
break	O
;	O
}	O
member_filedata	O
=	O
open_file	O
(	O
member_file_name	O
)	O
;	O
if	O
(	O
member_filedata	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Input file '%s' is not readable.\n"	*(char)
)	O
,	O
member_file_name	O
)	O
;	O
free	(*(void))->(void)
(	O
member_file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
break	O
;	O
}	O
archive_file_offset	O
=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
nested_member_origin	O
;	O
member_filedata	O
->	O
file_name	O
=	O
qualified_name	O
;	O
if	O
(	O
!	O
process_object	O
(	O
member_filedata	O
)	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
close_file	O
(	O
member_filedata	O
)	O
;	O
free	(*(void))->(void)
(	O
member_file_name	O
)	O
;	O
}	O
else	O
if	O
(	O
is_thin_archive	int
)	O
{	O
Filedata	O
thin_filedata	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
thin_filedata	O
,	O
0	int
,	O
sizeof	O
(	O
thin_filedata	O
)	O
)	O
;	O
if	O
(	O
nested_arch	O
.	O
file	*(struct)
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"%s: contains corrupt thin archive: %s\n"	*(char)
)	O
,	O
qualified_name	O
,	O
name	*(char)
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
break	O
;	O
}	O
archive_file_offset	O
=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
nested_member_origin	O
+	O
sizeof	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
arhdr	O
;	O
if	O
(	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
nested_arch	O
.	O
file	*(struct)
,	O
archive_file_offset	O
,	O
SEEK_SET	O
)	O
!=	O
0	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: failed to seek to archive member.\n"	*(char)
)	O
,	O
nested_arch	O
.	O
file_name	O
)	O
;	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
break	O
;	O
}	O
thin_filedata	O
.	O
handle	O
=	O
nested_arch	O
.	O
file	*(struct)
;	O
thin_filedata	O
.	O
file_name	O
=	O
qualified_name	O
;	O
if	O
(	O
!	O
process_object	O
(	O
&	O
thin_filedata	O
)	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
}	O
else	O
{	O
archive_file_offset	O
=	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
next_arhdr_offset	O
;	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
.	O
next_arhdr_offset	O
+=	O
archive_file_size	O
;	O
filedata	O
->	O
file_name	O
=	O
qualified_name	O
;	O
if	O
(	O
!	O
process_object	O
(	O
filedata	O
)	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
}	O
free	(*(void))->(void)
(	O
qualified_name	O
)	O
;	O
}	O
out	*((*(void),*(char),int)->(int))
:	O
if	O
(	O
nested_arch	O
.	O
file	*(struct)
!=	O
NULL	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
nested_arch	O
.	O
file	*(struct)
)	O
;	O
release_archive	O
(	O
&	O
nested_arch	O
)	O
;	O
release_archive	O
(	O
&	O
arch	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
)	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
static	O
bfd_boolean	int
process_file	O
(	O
char	O
*	O
file_name	O
)	O
{	O
Filedata	O
*	O
filedata	O
=	O
NULL	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	O
;	O
char	O
armag	O
[	O
SARMAG	O
]	O
;	O
bfd_boolean	int
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
TRUE	int
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
file_name	O
,	O
&	O
statbuf	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	O
)	O
error	O
(	O
_	O
(	O
"'%s': No such file\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
else	O
error	O
(	O
_	O
(	O
"Could not locate '%s'.  System error message: %s\n"	*(char)
)	O
,	O
file_name	O
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
statbuf	O
.	O
st_mode	int
)	O
)	O
{	O
error	O
(	O
_	O
(	O
"'%s' is not an ordinary file\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
filedata	O
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
*	O
filedata	O
)	O
;	O
if	O
(	O
filedata	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Out of memory allocating file data structure\n"	*(char)
)	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
filedata	O
->	O
file_name	O
=	O
file_name	O
;	O
filedata	O
->	O
handle	O
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file_name	O
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
filedata	O
->	O
handle	O
==	O
NULL	O
)	O
{	O
error	O
(	O
_	O
(	O
"Input file '%s' is not readable.\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
free	(*(void))->(void)
(	O
filedata	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
if	O
(	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
armag	O
,	O
SARMAG	O
,	O
1	int
,	O
filedata	O
->	O
handle	O
)	O
!=	O
1	int
)	O
{	O
error	O
(	O
_	O
(	O
"%s: Failed to read file's magic number\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
filedata	O
->	O
handle	O
)	O
;	O
free	(*(void))->(void)
(	O
filedata	O
)	O
;	O
return	O
FALSE	O
;	O
}	O
filedata	O
->	O
file_size	O
=	O
(	O
bfd_size_type	long
)	O
statbuf	O
.	O
st_size	long
;	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
armag	O
,	O
ARMAG	O
,	O
SARMAG	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
process_archive	O
(	O
filedata	O
,	O
FALSE	O
)	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
}	O
else	O
if	O
(	O
memcmp	(*(void),*(void),long)->(int)
(	O
armag	O
,	O
ARMAGT	O
,	O
SARMAG	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
process_archive	O
(	O
filedata	O
,	O
TRUE	int
)	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
}	O
else	O
{	O
if	O
(	O
do_archive_index	O
)	O
error	O
(	O
_	O
(	O
"File %s is not an archive so its index cannot be displayed.\n"	*(char)
)	O
,	O
file_name	O
)	O
;	O
rewind	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
filedata	O
->	O
handle	O
)	O
;	O
archive_file_size	O
=	O
archive_file_offset	O
=	O
0	int
;	O
if	O
(	O
!	O
process_object	O
(	O
filedata	O
)	O
)	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
=	O
FALSE	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
filedata	O
->	O
handle	O
)	O
;	O
free	(*(void))->(void)
(	O
filedata	O
)	O
;	O
return	O
ret	*(struct(long,char,*(char),char,char,short,*(char)))
;	O
}	O
int	O
main	O
(	O
int	O
argc	O
,	O
char	O
*	O
*	O
argv	O
)	O
{	O
int	O
err	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_MESSAGES	O
,	O
""	*(char)
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_CTYPE	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	O
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	O
)	O
;	O
expandargv	O
(	O
&	O
argc	O
,	O
&	O
argv	O
)	O
;	O
cmdline	O
.	O
file_name	O
=	O
"<cmdline>"	*(char)
;	O
parse_args	O
(	O
&	O
cmdline	O
,	O
argc	O
,	O
argv	O
)	O
;	O
if	O
(	O
optind	int
<	O
(	O
argc	O
-	O
1	int
)	O
)	O
show_name	O
=	O
TRUE	int
;	O
else	O
if	O
(	O
optind	int
>=	O
argc	O
)	O
{	O
warn	O
(	O
_	O
(	O
"Nothing to do.\n"	*(char)
)	O
)	O
;	O
usage	O
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
err	O
=	O
FALSE	O
;	O
while	O
(	O
optind	int
<	O
argc	O
)	O
if	O
(	O
!	O
process_file	O
(	O
argv	O
[	O
optind	int
++	O
]	O
)	O
)	O
err	O
=	O
TRUE	int
;	O
if	O
(	O
cmdline	O
.	O
dump_sects	O
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
cmdline	O
.	O
dump_sects	O
)	O
;	O
free	(*(void))->(void)
(	O
dump_ctf_symtab_name	O
)	O
;	O
free	(*(void))->(void)
(	O
dump_ctf_strtab_name	O
)	O
;	O
free	(*(void))->(void)
(	O
dump_ctf_parent_name	O
)	O
;	O
return	O
err	O
?	O
EXIT_FAILURE	O
:	O
EXIT_SUCCESS	O
;	O
}	O
