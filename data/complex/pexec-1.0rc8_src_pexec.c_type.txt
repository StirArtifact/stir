static	O
void	O
*	O
xmalloc	(long)->(*(void))
(	O
size_t	long
size	long
)	O
{	O
void	O
*	O
ret	*(*(void))
;	O
ret	*(*(void))
=	O
malloc	(long)->(*(void))
(	O
size	long
)	O
;	O
malloc_check	O
(	O
ret	*(*(void))
)	O
;	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
static	O
void	O
*	O
xrealloc	(*(void),long)->(*(void))
(	O
void	O
*	O
ptr	*(void)
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
ret	*(*(void))
;	O
ret	*(*(void))
=	O
realloc	(*(void),long)->(*(void))
(	O
ptr	*(void)
,	O
size	long
)	O
;	O
realloc_check	O
(	O
ret	*(*(void))
,	O
size	long
)	O
;	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
static	O
char	O
*	O
xstrdup	(*(char))->(*(char))
(	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
char	O
*	O
ret	*(*(void))
;	O
ret	*(*(void))
=	O
strdup	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
malloc_check	O
(	O
ret	*(*(void))
)	O
;	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
char	O
*	O
progbasename	*(char)
;	O
int	O
sig_pipe	array(int)
[	O
2	int
]	O
;	O
char	O
*	O
logmsg_submit_task	array(*(char))
[	O
]	O
=	O
{	O
NULL	O
,	O
"unable to open "	*(char)
PEXEC_DEFAULT_NULLFILE	*(char)
" special file for reading"	*(char)
,	O
"unable to redirect from input file: file cannot be opened"	*(char)
,	O
"unable to open "	*(char)
PEXEC_DEFAULT_NULLFILE	*(char)
" special file for writing"	*(char)
,	O
"unable to create internal pipes"	*(char)
,	O
"unable to redirect to output file: file cannot be created"	*(char)
,	O
"unable to redirect to error file: file cannot be created"	*(char)
,	O
"unknown error"	*(char)
,	O
NULL	O
}	O
;	O
int	O
log_message	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),int,*(struct(*(char),int,struct(int,*(*`),int),int,int)),*(char))->(int)
(	O
logdata	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
*	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
,	O
int	O
loglevel	int
,	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
char	O
*	O
msg	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
if	O
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
||	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
loglevel	int
<	O
loglevel	int
||	O
msg	*(char)
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
!=	O
NULL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"[%s] "	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
name	*(char)
)	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
msg	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
msg	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
->	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
background	(int,int)->(int)
(	O
int	O
nochdir	int
,	O
int	O
noclose	int
)	O
{	O
int	O
child_pid	int
;	O
int	O
nulldev_fd	int
;	O
child_pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
child_pid	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
child_pid	int
==	O
0	int
)	O
{	O
if	O
(	O
!	O
nochdir	int
)	O
chdir	(*(char))->(int)
(	O
"/"	*(char)
)	O
;	O
if	O
(	O
!	O
noclose	int
)	O
{	O
nulldev_fd	int
=	O
open	(*(char),int)->(int)
(	O
"/dev/null"	*(char)
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
nulldev_fd	int
>=	O
0	int
)	O
{	O
if	O
(	O
isatty	(int)->(int)
(	O
0	int
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
0	int
)	O
;	O
dup2	(int,int)->(int)
(	O
nulldev_fd	int
,	O
0	int
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
nulldev_fd	int
)	O
;	O
}	O
nulldev_fd	int
=	O
open	(*(char),int)->(int)
(	O
"/dev/null"	*(char)
,	O
O_WRONLY	int
)	O
;	O
if	O
(	O
nulldev_fd	int
>=	O
0	int
)	O
{	O
if	O
(	O
isatty	(int)->(int)
(	O
1	int
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
1	int
)	O
;	O
dup2	(int,int)->(int)
(	O
nulldev_fd	int
,	O
1	int
)	O
;	O
}	O
if	O
(	O
isatty	(int)->(int)
(	O
2	int
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
2	int
)	O
;	O
dup2	(int,int)->(int)
(	O
nulldev_fd	int
,	O
2	int
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
nulldev_fd	int
)	O
;	O
}	O
}	O
}	O
else	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
sig_act_child	(int)->(void)
(	O
int	O
signum	int
)	O
{	O
int	O
pid	int
,	O
ret	*(*(void))
,	O
status	int
;	O
signalinfo	struct(int,int,int,int)
sci	struct(int,int,int,int)
;	O
if	O
(	O
sig_pipe	array(int)
[	O
1	int
]	O
<	O
0	int
)	O
return	O
;	O
while	O
(	O
(	O
pid	int
=	O
waitpid	(int,*(int),int)->(int)
(	O
-	O
1	int
,	O
&	O
status	int
,	O
WNOHANG	int
)	O
)	O
>	O
0	int
)	O
{	O
sci	struct(int,int,int,int)
.	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
=	O
SIGCHLD	int
;	O
sci	struct(int,int,int,int)
.	O
pid	int
=	O
pid	int
;	O
sci	struct(int,int,int,int)
.	O
exitstatus	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
sci	struct(int,int,int,int)
.	O
exitsignal	int
=	O
WTERMSIG	O
(	O
status	int
)	O
;	O
else	O
sci	struct(int,int,int,int)
.	O
exitsignal	int
=	O
-	O
1	int
;	O
ret	*(*(void))
=	O
write	*((*(void),*(char),long)->(long))
(	O
sig_pipe	array(int)
[	O
1	int
]	O
,	O
&	O
sci	struct(int,int,int,int)
,	O
sizeof	O
(	O
signalinfo	struct(int,int,int,int)
)	O
)	O
;	O
}	O
}	O
void	O
sig_act_interrupt	(int)->(void)
(	O
int	O
signum	int
)	O
{	O
signalinfo	struct(int,int,int,int)
sci	struct(int,int,int,int)
;	O
int	O
ret	*(*(void))
;	O
if	O
(	O
sig_pipe	array(int)
[	O
1	int
]	O
<	O
0	int
)	O
return	O
;	O
sci	struct(int,int,int,int)
.	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
=	O
signum	int
;	O
sci	struct(int,int,int,int)
.	O
pid	int
=	O
0	int
;	O
sci	struct(int,int,int,int)
.	O
exitstatus	int
=	O
0	int
;	O
sci	struct(int,int,int,int)
.	O
exitsignal	int
=	O
!	O
0	int
;	O
ret	*(*(void))
=	O
write	*((*(void),*(char),long)->(long))
(	O
sig_pipe	array(int)
[	O
1	int
]	O
,	O
&	O
sci	struct(int,int,int,int)
,	O
sizeof	O
(	O
signalinfo	struct(int,int,int,int)
)	O
)	O
;	O
}	O
int	O
fdwait	(int,int)->(int)
(	O
int	O
fd	int
,	O
int	O
timeout	int
)	O
{	O
fd_set	struct(array(long))
set	struct(array(long))
;	O
struct	O
timeval	struct(long,long)
tv	struct(long,long)
;	O
int	O
ret	*(*(void))
;	O
FD_ZERO	O
(	O
&	O
set	struct(array(long))
)	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
timeout	int
>	O
0	int
)	O
{	O
tv	struct(long,long)
.	O
tv_sec	long
=	O
timeout	int
;	O
tv	struct(long,long)
.	O
tv_usec	long
=	O
0	int
;	O
ret	*(*(void))
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
fd	int
+	O
1	int
,	O
&	O
set	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tv	struct(long,long)
)	O
;	O
}	O
else	O
ret	*(*(void))
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
fd	int
+	O
1	int
,	O
&	O
set	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
int	O
env_export	(*(char),*(char))->(int)
(	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
value	*(char)
)	O
{	O
int	O
ret	*(*(void))
;	O
ret	*(*(void))
=	O
setenv	(*(char),*(char),int)->(int)
(	O
name	*(char)
,	O
value	*(char)
,	O
!	O
0	int
)	O
;	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
int	O
is_nasty_char	(int)->(int)
(	O
int	O
c	int
)	O
{	O
if	O
(	O
isalnum	(int)->(int)
(	O
c	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
c	int
==	O
'-'	O
||	O
c	int
==	O
'+'	O
||	O
c	int
==	O
'@'	O
||	O
c	int
==	O
'^'	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
c	int
==	O
'_'	O
||	O
c	int
==	O
'='	O
||	O
c	int
==	O
':'	O
||	O
c	int
==	O
'/'	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
c	int
==	O
','	O
||	O
c	int
==	O
'.'	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
get_nasty_char_number	(*(char))->(int)
(	O
char	O
*	O
arg	*(char)
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
*	O
arg	*(char)
;	O
arg	*(char)
++	O
)	O
{	O
if	O
(	O
is_nasty_char	(int)->(int)
(	O
*	O
arg	*(char)
)	O
)	O
n	int
++	O
;	O
}	O
return	O
(	O
n	int
)	O
;	O
}	O
char	O
*	O
concatenate_arguments	(int,*(*(char)))->(*(char))
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
char	O
*	O
command	struct(int,*(*(char)),int)
;	O
int	O
len	int
,	O
i	int
,	O
l	int
;	O
len	int
=	O
0	int
;	O
command	struct(int,*(*(char)),int)
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
l	int
=	O
strlen	(*(char))->(long)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
command	struct(int,*(*(char)),int)
==	O
NULL	O
)	O
command	struct(int,*(*(char)),int)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
l	int
+	O
1	int
)	O
;	O
else	O
{	O
command	struct(int,*(*(char)),int)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
command	struct(int,*(*(char)),int)
,	O
len	int
+	O
1	int
+	O
l	int
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
command	struct(int,*(*(char)),int)
+	O
len	int
,	O
" "	*(char)
)	O
;	O
len	int
++	O
;	O
}	O
strcpy	(*(char),*(char))->(*(char))
(	O
command	struct(int,*(*(char)),int)
+	O
len	int
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
len	int
+=	O
l	int
;	O
}	O
if	O
(	O
command	struct(int,*(*(char)),int)
==	O
NULL	O
)	O
command	struct(int,*(*(char)),int)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
16	int
)	O
;	O
command	struct(int,*(*(char)),int)
[	O
len	int
]	O
=	O
0	int
;	O
return	O
(	O
command	struct(int,*(*(char)),int)
)	O
;	O
}	O
static	O
int	O
daemon_commandtoken_is_nasty	(int)->(int)
(	O
int	O
c	int
)	O
{	O
if	O
(	O
c	int
<=	O
32	int
||	O
c	int
>=	O
127	int
||	O
c	int
==	O
'\"'	O
||	O
c	int
==	O
'\''	O
||	O
c	int
==	O
'\\'	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
hex_digit	(int)->(int)
(	O
int	O
c	int
)	O
{	O
if	O
(	O
'0'	O
<=	O
c	int
&&	O
c	int
<=	O
'9'	O
)	O
return	O
(	O
c	int
-	O
'0'	O
)	O
;	O
else	O
if	O
(	O
'a'	O
<=	O
c	int
&&	O
c	int
<=	O
'f'	O
)	O
return	O
(	O
c	int
-	O
'a'	O
+	O
10	int
)	O
;	O
else	O
if	O
(	O
'A'	O
<=	O
c	int
&&	O
c	int
<=	O
'F'	O
)	O
return	O
(	O
c	int
-	O
'A'	O
+	O
10	int
)	O
;	O
else	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
char	O
*	O
daemon_commandtoken_escape	(*(char),int)->(*(char))
(	O
char	O
*	O
buff	*(char)
,	O
int	O
size	long
)	O
{	O
int	O
l	int
,	O
s	*(char)
,	O
c	int
;	O
char	O
*	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
*	O
q	*(char)
,	O
*	O
out	*(char)
;	O
if	O
(	O
buff	*(char)
==	O
NULL	O
)	O
return	O
(	O
NULL	O
)	O
;	O
l	int
=	O
0	int
;	O
for	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
buff	*(char)
,	O
s	*(char)
=	O
size	long
;	O
s	*(char)
>	O
0	int
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
++	O
,	O
s	*(char)
--	O
)	O
{	O
if	O
(	O
daemon_commandtoken_is_nasty	(int)->(int)
(	O
(	O
int	O
)	O
(	O
*	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
)	O
)	O
l	int
+=	O
3	int
;	O
else	O
l	int
++	O
;	O
}	O
out	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
l	int
+	O
1	int
)	O
;	O
for	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
buff	*(char)
,	O
q	*(char)
=	O
out	*(char)
,	O
s	*(char)
=	O
size	long
;	O
s	*(char)
>	O
0	int
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
++	O
,	O
s	*(char)
--	O
)	O
{	O
if	O
(	O
daemon_commandtoken_is_nasty	(int)->(int)
(	O
(	O
int	O
)	O
(	O
*	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
)	O
)	O
{	O
c	int
=	O
(	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
q	*(char)
,	O
"\\%.2X"	*(char)
,	O
c	int
)	O
;	O
q	*(char)
+=	O
3	int
;	O
}	O
else	O
{	O
*	O
q	*(char)
=	O
*	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
;	O
q	*(char)
++	O
;	O
}	O
}	O
*	O
q	*(char)
=	O
0	int
;	O
return	O
(	O
out	*(char)
)	O
;	O
}	O
char	O
*	O
daemon_commandtoken_escape_string	(*(char))->(*(char))
(	O
char	O
*	O
buff	*(char)
)	O
{	O
int	O
len	int
;	O
if	O
(	O
buff	*(char)
==	O
NULL	O
||	O
(	O
len	int
=	O
strlen	(*(char))->(long)
(	O
buff	*(char)
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
NULL	O
)	O
;	O
else	O
return	O
(	O
daemon_commandtoken_escape	(*(char),int)->(*(char))
(	O
buff	*(char)
,	O
len	int
)	O
)	O
;	O
}	O
int	O
daemon_commandtoken_unescape	(*(char))->(int)
(	O
char	O
*	O
buff	*(char)
)	O
{	O
char	O
*	O
out	*(char)
;	O
int	O
h1	int
,	O
h2	int
,	O
ret	*(*(void))
;	O
ret	*(*(void))
=	O
0	int
;	O
for	O
(	O
out	*(char)
=	O
buff	*(char)
;	O
*	O
buff	*(char)
;	O
)	O
{	O
if	O
(	O
*	O
buff	*(char)
==	O
'\\'	O
&&	O
(	O
h1	int
=	O
hex_digit	(int)->(int)
(	O
(	O
int	O
)	O
(	O
*	O
(	O
buff	*(char)
+	O
1	int
)	O
)	O
)	O
)	O
>=	O
0	int
&&	O
(	O
h2	int
=	O
hex_digit	(int)->(int)
(	O
(	O
int	O
)	O
(	O
*	O
(	O
buff	*(char)
+	O
2	int
)	O
)	O
)	O
)	O
>=	O
0	int
)	O
{	O
*	O
out	*(char)
=	O
h1	int
*	O
16	int
+	O
h2	int
;	O
buff	*(char)
+=	O
3	int
;	O
out	*(char)
++	O
;	O
}	O
else	O
{	O
*	O
out	*(char)
=	O
*	O
buff	*(char)
;	O
buff	*(char)
++	O
;	O
out	*(char)
++	O
;	O
}	O
ret	*(*(void))
++	O
;	O
}	O
*	O
out	*(char)
=	O
0	int
;	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
int	O
hprintf	(int,*(char))->(int)
(	O
int	O
handle	int
,	O
char	O
*	O
msg	*(char)
,	O
...	O
)	O
{	O
char	O
buff	*(char)
[	O
HPRINT_BUFFER_SIZE	int
]	O
,	O
*	O
tbuff	*(char)
;	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
int	O
n	int
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
msg	*(char)
)	O
;	O
n	int
=	O
vsnprintf	(*(char),long,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
buff	*(char)
,	O
HPRINT_BUFFER_SIZE	int
,	O
msg	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
n	int
<	O
HPRINT_BUFFER_SIZE	int
)	O
{	O
write	*((*(void),*(char),long)->(long))
(	O
handle	int
,	O
buff	*(char)
,	O
n	int
)	O
;	O
return	O
(	O
n	int
)	O
;	O
}	O
else	O
{	O
tbuff	*(char)
=	O
NULL	O
;	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
msg	*(char)
)	O
;	O
vstrappendf	(*(*(char)),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
&	O
tbuff	*(char)
,	O
msg	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
if	O
(	O
tbuff	*(char)
!=	O
NULL	O
)	O
{	O
n	int
=	O
strlen	(*(char))->(long)
(	O
tbuff	*(char)
)	O
;	O
write	*((*(void),*(char),long)->(long))
(	O
handle	int
,	O
tbuff	*(char)
,	O
n	int
)	O
;	O
free	(*(void))->(void)
(	O
tbuff	*(char)
)	O
;	O
}	O
else	O
n	int
=	O
0	int
;	O
return	O
(	O
n	int
)	O
;	O
}	O
}	O
int	O
get_number_of_cpus_proccpuinfo	()->(int)
(	O
void	O
)	O
{	O
FILE	struct
*	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
buff	*(char)
[	O
BUFF_LEN	int
]	O
;	O
int	O
ncpu	int
,	O
i	int
,	O
j	int
;	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
"/proc/cpuinfo"	*(char)
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
ncpu	int
=	O
0	int
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
if	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buff	*(char)
,	O
BUFF_LEN	int
-	O
1	int
,	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
NULL	O
)	O
break	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
strlen	(*(char))->(long)
(	O
buff	*(char)
)	O
;	O
)	O
{	O
if	O
(	O
buff	*(char)
[	O
i	int
]	O
==	O
10	int
||	O
buff	*(char)
[	O
i	int
]	O
==	O
9	int
||	O
buff	*(char)
[	O
i	int
]	O
==	O
13	int
||	O
buff	*(char)
[	O
i	int
]	O
==	O
32	int
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
buff	*(char)
+	O
i	int
,	O
buff	*(char)
+	O
i	int
+	O
1	int
,	O
strlen	(*(char))->(long)
(	O
buff	*(char)
+	O
i	int
)	O
)	O
;	O
else	O
i	int
++	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
strlen	(*(char))->(long)
(	O
buff	*(char)
)	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
buff	*(char)
[	O
j	int
]	O
==	O
':'	O
)	O
break	O
;	O
}	O
if	O
(	O
j	int
==	O
strlen	(*(char))->(long)
(	O
buff	*(char)
)	O
)	O
continue	O
;	O
buff	*(char)
[	O
j	int
]	O
=	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
buff	*(char)
,	O
"processor"	*(char)
)	O
==	O
0	int
)	O
ncpu	int
++	O
;	O
}	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
ncpu	int
=	O
0	int
;	O
return	O
(	O
ncpu	int
)	O
;	O
}	O
int	O
get_number_of_cpus_sysconf	()->(int)
(	O
void	O
)	O
{	O
int	O
ncpu	int
;	O
ncpu	int
=	O
sysconf	(int)->(long)
(	O
_SC_NPROCESSORS_ONLN	int
)	O
;	O
return	O
(	O
ncpu	int
)	O
;	O
}	O
int	O
get_number_of_cpus	()->(int)
(	O
void	O
)	O
{	O
int	O
ncpu	int
,	O
w	int
;	O
ncpu	int
=	O
get_number_of_cpus_proccpuinfo	()->(int)
(	O
)	O
;	O
w	int
=	O
get_number_of_cpus_sysconf	()->(int)
(	O
)	O
;	O
if	O
(	O
w	int
>	O
0	int
&&	O
ncpu	int
>	O
0	int
)	O
ncpu	int
=	O
(	O
w	int
<	O
ncpu	int
?	O
w	int
:	O
ncpu	int
)	O
;	O
if	O
(	O
ncpu	int
<=	O
0	int
)	O
ncpu	int
=	O
1	int
;	O
return	O
(	O
ncpu	int
)	O
;	O
}	O
int	O
get_bit_size	(int)->(int)
(	O
int	O
n	int
)	O
{	O
int	O
r	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
n	int
>	O
0	int
;	O
n	int
/=	O
2	int
)	O
{	O
r	int
++	O
;	O
}	O
return	O
(	O
r	int
)	O
;	O
}	O
child	struct
*	O
get_child_by_pid	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int)->(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))))
(	O
child	struct
*	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
int	O
pid	int
)	O
{	O
for	O
(	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
!=	O
NULL	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
==	O
pid	int
)	O
return	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
child	struct
*	O
get_child_by_id	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int)->(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))))
(	O
child	struct
*	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
int	O
id	int
)	O
{	O
for	O
(	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
!=	O
NULL	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
==	O
id	int
)	O
return	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
imutex	struct
*	O
get_imutex_by_name	(*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(char))->(*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)))
(	O
imutex	struct
*	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
,	O
char	O
*	O
name	*(char)
)	O
{	O
for	O
(	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
!=	O
NULL	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
=	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
int	O
fd_avail	(int)->(int)
(	O
int	O
fd	int
)	O
{	O
fd_set	struct(array(long))
set	struct(array(long))
;	O
struct	O
timeval	struct(long,long)
tv	struct(long,long)
;	O
FD_ZERO	O
(	O
&	O
set	struct(array(long))
)	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
set	struct(array(long))
)	O
;	O
tv	struct(long,long)
.	O
tv_sec	long
=	O
0	int
;	O
tv	struct(long,long)
.	O
tv_usec	long
=	O
0	int
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
fd	int
+	O
1	int
,	O
&	O
set	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tv	struct(long,long)
)	O
;	O
if	O
(	O
FD_ISSET	O
(	O
fd	int
,	O
&	O
set	struct(array(long))
)	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
char	O
*	O
fileformat_replace	(*(char),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(*(char))
(	O
char	O
*	O
format	*(char)
,	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
{	O
char	O
*	O
name	*(char)
;	O
name	*(char)
=	O
format_replace	(*(char),int)->(*(char))
(	O
format	*(char)
,	O
0	int
,	O
's'	O
,	O
FORMAT_STRING	int
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
name	*(char)
,	O
'k'	O
,	O
FORMAT_STRING	int
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
id	int
,	O
'd'	O
,	O
FORMAT_STRING	int
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
id	int
+	O
1	int
,	O
0	int
)	O
;	O
return	O
(	O
name	*(char)
)	O
;	O
}	O
int	O
submit_task	(*(struct(*(char),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*`,int)))),*(struct(*(char),int,struct(int,*(*`),int),int,int)),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)))->(int)
(	O
paralleldata	struct(*(char),*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)))
*	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
child	struct
*	O
c	int
,	O
int	O
no_format_replace	int
,	O
parallelstatus	struct(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(struct(*(struct(*`,*`,*`,int)),*(struct(*`,*`,*`,int)),*(struct(*`,*`,int,struct`,int)),int)),int,int,int,int,long)
*	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
)	O
{	O
int	O
stdfd	array(int)
[	O
3	int
]	O
;	O
int	O
pipeout	array(int)
[	O
2	int
]	O
,	O
pipeerr	array(int)
[	O
2	int
]	O
;	O
int	O
pid	int
;	O
if	O
(	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
no_touch_std	int
)	O
{	O
stdfd	array(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
stdfd	array(int)
[	O
1	int
]	O
=	O
-	O
1	int
;	O
stdfd	array(int)
[	O
2	int
]	O
=	O
-	O
1	int
;	O
pipeout	array(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeout	array(int)
[	O
1	int
]	O
=	O
-	O
1	int
;	O
pipeerr	array(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeerr	array(int)
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
in	*(char)
==	O
NULL	O
)	O
{	O
stdfd	array(int)
[	O
0	int
]	O
=	O
open	(*(char),int)->(int)
(	O
PEXEC_DEFAULT_NULLFILE	*(char)
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
stdfd	array(int)
[	O
0	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
inname	*(char)
;	O
if	O
(	O
no_format_replace	int
)	O
stdfd	array(int)
[	O
0	int
]	O
=	O
open	(*(char),int)->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
in	*(char)
,	O
O_RDONLY	int
)	O
;	O
else	O
{	O
inname	*(char)
=	O
fileformat_replace	(*(char),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(*(char))
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
in	*(char)
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
stdfd	array(int)
[	O
0	int
]	O
=	O
open	(*(char),int)->(int)
(	O
inname	*(char)
,	O
O_RDONLY	int
)	O
;	O
free	(*(void))->(void)
(	O
inname	*(char)
)	O
;	O
}	O
if	O
(	O
stdfd	array(int)
[	O
0	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
2	int
)	O
;	O
}	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
out	*(char)
==	O
NULL	O
)	O
{	O
stdfd	array(int)
[	O
1	int
]	O
=	O
open	(*(char),int)->(int)
(	O
PEXEC_DEFAULT_NULLFILE	*(char)
,	O
O_WRONLY	int
)	O
;	O
if	O
(	O
stdfd	array(int)
[	O
1	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
3	int
)	O
;	O
pipeout	array(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeout	array(int)
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
if	O
(	O
pipe	(array(int))->(int)
(	O
pipeout	array(int)
)	O
)	O
return	O
(	O
-	O
4	int
)	O
;	O
stdfd	array(int)
[	O
1	int
]	O
=	O
pipeout	array(int)
[	O
1	int
]	O
;	O
}	O
else	O
{	O
char	O
*	O
outname	*(char)
;	O
if	O
(	O
no_format_replace	int
)	O
stdfd	array(int)
[	O
1	int
]	O
=	O
open	(*(char),int)->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
out	*(char)
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
0644	int
)	O
;	O
else	O
{	O
outname	*(char)
=	O
fileformat_replace	(*(char),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(*(char))
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
out	*(char)
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
stdfd	array(int)
[	O
1	int
]	O
=	O
open	(*(char),int)->(int)
(	O
outname	*(char)
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
0644	int
)	O
;	O
free	(*(void))->(void)
(	O
outname	*(char)
)	O
;	O
}	O
if	O
(	O
stdfd	array(int)
[	O
1	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
5	int
)	O
;	O
pipeout	array(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeout	array(int)
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
err	long
==	O
NULL	O
)	O
{	O
stdfd	array(int)
[	O
2	int
]	O
=	O
open	(*(char),int)->(int)
(	O
PEXEC_DEFAULT_NULLFILE	*(char)
,	O
O_WRONLY	int
)	O
;	O
if	O
(	O
stdfd	array(int)
[	O
2	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
3	int
)	O
;	O
pipeerr	array(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeerr	array(int)
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
if	O
(	O
pipe	(array(int))->(int)
(	O
pipeerr	array(int)
)	O
)	O
return	O
(	O
-	O
4	int
)	O
;	O
stdfd	array(int)
[	O
2	int
]	O
=	O
pipeerr	array(int)
[	O
1	int
]	O
;	O
}	O
else	O
{	O
char	O
*	O
errname	*(char)
;	O
if	O
(	O
no_format_replace	int
)	O
stdfd	array(int)
[	O
2	int
]	O
=	O
open	(*(char),int)->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
err	long
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
0644	int
)	O
;	O
else	O
{	O
errname	*(char)
=	O
fileformat_replace	(*(char),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(*(char))
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
err	long
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
stdfd	array(int)
[	O
2	int
]	O
=	O
open	(*(char),int)->(int)
(	O
errname	*(char)
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
0644	int
)	O
;	O
free	(*(void))->(void)
(	O
errname	*(char)
)	O
;	O
}	O
if	O
(	O
stdfd	array(int)
[	O
2	int
]	O
<	O
0	int
)	O
return	O
(	O
-	O
6	int
)	O
;	O
pipeerr	array(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
pipeerr	array(int)
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
}	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
return	O
(	O
-	O
4	int
)	O
;	O
else	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
if	O
(	O
pipeout	array(int)
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
c	int
->	O
fdstdout	int
=	O
pipeout	array(int)
[	O
0	int
]	O
;	O
close	*((*(void))->(int))
(	O
pipeout	array(int)
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
c	int
->	O
fdstdout	int
=	O
-	O
1	int
;	O
if	O
(	O
stdfd	array(int)
[	O
1	int
]	O
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
stdfd	array(int)
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
pipeerr	array(int)
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
c	int
->	O
fdstderr	int
=	O
pipeerr	array(int)
[	O
0	int
]	O
;	O
close	*((*(void))->(int))
(	O
pipeerr	array(int)
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
c	int
->	O
fdstderr	int
=	O
-	O
1	int
;	O
if	O
(	O
stdfd	array(int)
[	O
2	int
]	O
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
stdfd	array(int)
[	O
2	int
]	O
)	O
;	O
}	O
if	O
(	O
stdfd	array(int)
[	O
0	int
]	O
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
stdfd	array(int)
[	O
0	int
]	O
)	O
;	O
return	O
(	O
pid	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pipeout	array(int)
[	O
0	int
]	O
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
pipeout	array(int)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
pipeerr	array(int)
[	O
0	int
]	O
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
pipeerr	array(int)
[	O
0	int
]	O
)	O
;	O
if	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
!=	O
NULL	O
)	O
{	O
client	struct
*	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
child	struct
*	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
for	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
!=	O
NULL	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
)	O
;	O
}	O
if	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
sock	int
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
sock	int
)	O
;	O
if	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
hsck	int
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
hsck	int
)	O
;	O
for	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
!=	O
NULL	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
)	O
;	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
)	O
;	O
}	O
}	O
if	O
(	O
stdfd	array(int)
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
0	int
)	O
;	O
dup2	(int,int)->(int)
(	O
stdfd	array(int)
[	O
0	int
]	O
,	O
0	int
)	O
;	O
close	*((*(void))->(int))
(	O
stdfd	array(int)
[	O
0	int
]	O
)	O
;	O
}	O
if	O
(	O
stdfd	array(int)
[	O
1	int
]	O
>=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
1	int
)	O
;	O
dup2	(int,int)->(int)
(	O
stdfd	array(int)
[	O
1	int
]	O
,	O
1	int
)	O
;	O
close	*((*(void))->(int))
(	O
stdfd	array(int)
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
stdfd	array(int)
[	O
2	int
]	O
>=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
2	int
)	O
;	O
dup2	(int,int)->(int)
(	O
stdfd	array(int)
[	O
2	int
]	O
,	O
2	int
)	O
;	O
close	*((*(void))->(int))
(	O
stdfd	array(int)
[	O
2	int
]	O
)	O
;	O
}	O
close	*((*(void))->(int))
(	O
sig_pipe	array(int)
[	O
0	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
sig_pipe	array(int)
[	O
1	int
]	O
)	O
;	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
envvarname	*(char)
!=	O
NULL	O
&&	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
name	*(char)
!=	O
NULL	O
)	O
env_export	(*(char),*(char))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
envvarname	*(char)
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
name	*(char)
)	O
;	O
if	O
(	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
is_shell	int
>	O
0	int
)	O
{	O
char	O
*	O
argv	*(*(char))
[	O
4	int
]	O
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
shell	*(char)
;	O
argv	*(*(char))
[	O
1	int
]	O
=	O
"-c"	*(char)
;	O
argv	*(*(char))
[	O
2	int
]	O
=	O
concatenate_arguments	(int,*(*(char)))->(*(char))
(	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argc	int
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argv	*(*(char))
)	O
;	O
argv	*(*(char))
[	O
3	int
]	O
=	O
NULL	O
;	O
execv	(*(char),array(*(char)))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
shell	*(char)
,	O
argv	*(*(char))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: unable to execute the shell '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
shell	*(char)
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
else	O
if	O
(	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
is_shell	int
<	O
0	int
)	O
{	O
char	O
*	O
*	O
argv	*(*(char))
;	O
int	O
i	int
,	O
argc	int
,	O
n	int
;	O
n	int
=	O
0	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
rshargs	*(*(char))
[	O
n	int
]	O
!=	O
NULL	O
;	O
)	O
n	int
++	O
;	O
argc	int
=	O
n	int
+	O
1	int
+	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argc	int
+	O
1	int
;	O
argv	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
argc	int
+	O
1	int
)	O
)	O
;	O
argc	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
argv	*(*(char))
[	O
argc	int
]	O
=	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
rshargs	*(*(char))
[	O
i	int
]	O
;	O
argc	int
++	O
;	O
}	O
if	O
(	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
name	*(char)
!=	O
NULL	O
)	O
{	O
argv	*(*(char))
[	O
argc	int
]	O
=	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
name	*(char)
;	O
argc	int
++	O
;	O
}	O
else	O
{	O
argv	*(*(char))
[	O
argc	int
]	O
=	O
"localhost"	*(char)
;	O
argc	int
++	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argc	int
;	O
i	int
++	O
)	O
{	O
argv	*(*(char))
[	O
argc	int
]	O
=	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argv	*(*(char))
[	O
i	int
]	O
;	O
argc	int
++	O
;	O
}	O
argv	*(*(char))
[	O
argc	int
]	O
=	O
NULL	O
;	O
execvp	(*(char),array(*(char)))->(int)
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
argv	*(*(char))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: unable to execute the remote shell command '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
*	O
argv	*(*(char))
;	O
int	O
i	int
,	O
argc	int
;	O
argc	int
=	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argc	int
;	O
argv	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
argc	int
+	O
1	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
argv	*(*(char))
[	O
i	int
]	O
=	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
argv	*(*(char))
[	O
argc	int
]	O
=	O
NULL	O
;	O
execvp	(*(char),array(*(char)))->(int)
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
argv	*(*(char))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: unable to execute the command '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
}	O
return	O
(	O
-	O
7	int
)	O
;	O
}	O
int	O
send_task	(*(struct(*(char),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*`,int)))),*(struct(*(char),int,struct(int,*(*`),int),int,int)),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))))->(int)
(	O
paralleldata	struct(*(char),*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)))
*	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
child	struct
*	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
char	O
*	O
*	O
args	*(*(char))
,	O
*	O
token	*(char)
;	O
int	O
a	int
,	O
i	int
;	O
args	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
16	int
)	O
;	O
for	O
(	O
a	int
=	O
0	int
;	O
a	int
<	O
16	int
;	O
a	int
++	O
)	O
{	O
args	*(*(char))
[	O
a	int
]	O
=	O
NULL	O
;	O
}	O
a	int
=	O
0	int
;	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"execute"	*(char)
)	O
;	O
a	int
++	O
;	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"identifier=%d"	*(char)
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
id	int
)	O
;	O
a	int
++	O
;	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
envvarname	*(char)
!=	O
NULL	O
&&	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
name	*(char)
!=	O
NULL	O
)	O
{	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"envname=%s"	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
envvarname	*(char)
)	O
;	O
a	int
++	O
;	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"envvalue=%s"	*(char)
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
name	*(char)
)	O
;	O
a	int
++	O
;	O
}	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
in	*(char)
!=	O
NULL	O
)	O
{	O
char	O
*	O
inname	*(char)
;	O
inname	*(char)
=	O
fileformat_replace	(*(char),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(*(char))
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
in	*(char)
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"in=%s"	*(char)
,	O
inname	*(char)
)	O
;	O
a	int
++	O
;	O
free	(*(void))->(void)
(	O
inname	*(char)
)	O
;	O
}	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
out	*(char)
!=	O
NULL	O
&&	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
char	O
*	O
outname	*(char)
;	O
outname	*(char)
=	O
fileformat_replace	(*(char),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(*(char))
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
out	*(char)
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"out=%s"	*(char)
,	O
outname	*(char)
)	O
;	O
a	int
++	O
;	O
free	(*(void))->(void)
(	O
outname	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"out=-"	*(char)
)	O
;	O
a	int
++	O
;	O
}	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
err	long
!=	O
NULL	O
&&	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
char	O
*	O
errname	*(char)
;	O
errname	*(char)
=	O
fileformat_replace	(*(char),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(*(char))
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
err	long
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"err=%s"	*(char)
,	O
errname	*(char)
)	O
;	O
a	int
++	O
;	O
free	(*(void))->(void)
(	O
errname	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"err=-"	*(char)
)	O
;	O
a	int
++	O
;	O
}	O
if	O
(	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
is_shell	int
)	O
{	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"shell=%s"	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
shell	*(char)
)	O
;	O
a	int
++	O
;	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"-"	*(char)
)	O
;	O
a	int
++	O
;	O
args	*(*(char))
[	O
a	int
]	O
=	O
concatenate_arguments	(int,*(*(char)))->(*(char))
(	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argc	int
,	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argv	*(*(char))
)	O
;	O
a	int
++	O
;	O
}	O
else	O
{	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
args	*(*(char))
[	O
a	int
]	O
,	O
"-"	*(char)
)	O
;	O
a	int
++	O
;	O
args	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
args	*(*(char))
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
16	int
+	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argc	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argc	int
;	O
i	int
++	O
)	O
{	O
args	*(*(char))
[	O
a	int
]	O
=	O
xstrdup	(*(char))->(*(char))
(	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
c	int
.	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
a	int
++	O
;	O
}	O
}	O
args	*(*(char))
[	O
a	int
]	O
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
a	int
;	O
i	int
++	O
)	O
{	O
token	*(char)
=	O
daemon_commandtoken_escape_string	(*(char))->(*(char))
(	O
args	*(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
i	int
<	O
a	int
-	O
1	int
)	O
hprintf	(int,*(char))->(int)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
,	O
"%s "	*(char)
,	O
token	*(char)
)	O
;	O
else	O
hprintf	(int,*(char))->(int)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
,	O
"%s\n"	*(char)
,	O
token	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
token	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
args	*(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
args	*(*(char))
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
size_t	long
read_fd_block	(int,*(void),long)->(long)
(	O
int	O
fd	int
,	O
void	O
*	O
data	*(void)
,	O
size_t	long
size	long
)	O
{	O
char	O
*	O
cdata	*(char)
;	O
ssize_t	long
rd	long
;	O
size_t	long
tr	long
;	O
cdata	*(char)
=	O
data	*(void)
;	O
tr	long
=	O
0	int
;	O
while	O
(	O
size	long
>	O
0	int
)	O
{	O
rd	long
=	O
read	*((*(void),*(char),long)->(long))
(	O
fd	int
,	O
cdata	*(char)
,	O
size	long
)	O
;	O
if	O
(	O
rd	long
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
else	O
if	O
(	O
rd	long
<=	O
0	int
)	O
{	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
size	long
-=	O
rd	long
;	O
cdata	*(char)
+=	O
rd	long
;	O
tr	long
+=	O
rd	long
;	O
}	O
}	O
;	O
return	O
(	O
tr	long
)	O
;	O
}	O
int	O
read_signalinfo	(int,*(struct(int,int,int,int)))->(int)
(	O
int	O
fd	int
,	O
signalinfo	struct(int,int,int,int)
*	O
sci	struct(int,int,int,int)
)	O
{	O
return	O
(	O
(	O
int	O
)	O
read_fd_block	(int,*(void),long)->(long)
(	O
fd	int
,	O
sci	struct(int,int,int,int)
,	O
sizeof	O
(	O
signalinfo	struct(int,int,int,int)
)	O
)	O
)	O
;	O
}	O
int	O
write_out_line	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),*(struct(*(char),int,struct(int,*(*`),int),int,int)),int)->(int)
(	O
FILE	struct
*	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
char	O
*	O
format	*(char)
,	O
char	O
*	O
lbuffer	*(char)
,	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
int	O
omit_newlines	int
)	O
{	O
char	O
*	O
outline	*(char)
;	O
size_t	long
len	int
;	O
outline	*(char)
=	O
format_replace	(*(char),int)->(*(char))
(	O
format	*(char)
,	O
1	int
,	O
'k'	O
,	O
FORMAT_INTEGER	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
id	int
,	O
'd'	O
,	O
FORMAT_INTEGER	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
id	int
+	O
1	int
,	O
's'	O
,	O
FORMAT_STRING	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
name	*(char)
,	O
'l'	O
,	O
FORMAT_STRING	int
,	O
lbuffer	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
outline	*(char)
!=	O
NULL	O
)	O
{	O
len	int
=	O
strlen	(*(char))->(long)
(	O
outline	*(char)
)	O
;	O
if	O
(	O
omit_newlines	int
)	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
outline	*(char)
,	O
1	int
,	O
len	int
,	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
outline	*(char)
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
free	(*(void))->(void)
(	O
outline	*(char)
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
write_output	(*(char),long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(struct(*(char),long)),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(int)
(	O
char	O
*	O
buff	*(char)
,	O
size_t	long
n	int
,	O
FILE	struct
*	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
char	O
*	O
format	*(char)
,	O
int	O
omit_newlines	int
,	O
linebuffer	struct(*(char),long)
*	O
lb	*(struct(*(char),long))
,	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
{	O
char	O
*	O
line	*(char)
;	O
if	O
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
buff	*(char)
==	O
NULL	O
)	O
n	int
=	O
0	int
;	O
if	O
(	O
format	*(char)
==	O
NULL	O
||	O
lb	*(struct(*(char),long))
==	O
NULL	O
)	O
{	O
if	O
(	O
n	int
>	O
0	int
&&	O
buff	*(char)
!=	O
NULL	O
)	O
{	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buff	*(char)
,	O
1	int
,	O
n	int
,	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
format	*(char)
!=	O
NULL	O
&&	O
lb	*(struct(*(char),long))
!=	O
NULL	O
)	O
{	O
linebuffer_concatenate	(*(struct(*(char),long)),*(char),long)->(int)
(	O
lb	*(struct(*(char),long))
,	O
buff	*(char)
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	*(char)
=	O
linebuffer_fetch	(*(struct(*(char),long)))->(*(char))
(	O
lb	*(struct(*(char),long))
)	O
)	O
!=	O
NULL	O
||	O
(	O
buff	*(char)
==	O
NULL	O
&&	O
(	O
line	*(char)
=	O
linebuffer_flush	(*(struct(*(char),long)))->(*(char))
(	O
lb	*(struct(*(char),long))
)	O
)	O
!=	O
NULL	O
)	O
)	O
{	O
write_out_line	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),*(struct(*(char),int,struct(int,*(*`),int),int,int)),int)->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
format	*(char)
,	O
line	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
omit_newlines	int
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
int	O
imutex_cleanup	(*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),int,*(void))->(int)
(	O
imutex	struct
*	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
,	O
int	O
qid	int
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
i	int
,	O
j	int
,	O
r	int
;	O
for	O
(	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
!=	O
NULL	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
=	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
==	O
NULL	O
||	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
<=	O
0	int
)	O
continue	O
;	O
r	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
[	O
i	int
]	O
.	O
qid	int
==	O
qid	int
&&	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
[	O
i	int
]	O
.	O
data	*(void)
==	O
data	*(void)
)	O
{	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
[	O
i	int
]	O
.	O
qid	int
=	O
-	O
1	int
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
[	O
i	int
]	O
.	O
data	*(void)
=	O
NULL	O
;	O
r	int
++	O
;	O
}	O
}	O
if	O
(	O
r	int
==	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
)	O
{	O
free	(*(void))->(void)
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
)	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
=	O
NULL	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
r	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
;	O
i	int
<	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
[	O
i	int
]	O
.	O
qid	int
<	O
0	int
&&	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
[	O
i	int
]	O
.	O
data	*(void)
==	O
NULL	O
)	O
)	O
{	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
[	O
j	int
]	O
=	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
[	O
i	int
]	O
;	O
j	int
++	O
;	O
}	O
}	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
=	O
j	int
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
imutex_lock_get_params	(*(*(char)),*(*(char)),*(int))->(int)
(	O
char	O
*	O
*	O
cmd	*(*(char))
,	O
char	O
*	O
*	O
rname	*(*(char))
,	O
int	O
*	O
rmaxnum	*(int)
)	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
i	int
,	O
maxnum	int
;	O
name	*(char)
=	O
NULL	O
;	O
maxnum	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
cmd	*(*(char))
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"-m"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"--maximum"	*(char)
)	O
==	O
0	int
)	O
&&	O
cmd	*(*(char))
[	O
i	int
+	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
i	int
++	O
;	O
sscanf	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"%d"	*(char)
,	O
&	O
maxnum	int
)	O
;	O
}	O
else	O
if	O
(	O
cmd	*(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
name	*(char)
=	O
cmd	*(*(char))
[	O
i	int
]	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
*	O
rname	*(*(char))
=	O
name	*(char)
;	O
*	O
rmaxnum	*(int)
=	O
maxnum	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
imutex_unlock_get_params	(*(*(char)),*(*(char)))->(int)
(	O
char	O
*	O
*	O
cmd	*(*(char))
,	O
char	O
*	O
*	O
rname	*(*(char))
)	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
i	int
;	O
name	*(char)
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
cmd	*(*(char))
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
cmd	*(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
name	*(char)
=	O
cmd	*(*(char))
[	O
i	int
]	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
*	O
rname	*(*(char))
=	O
name	*(char)
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
imutex_mutex_get_params	(*(*(char)),*(*(char)))->(int)
(	O
char	O
*	O
*	O
cmd	*(*(char))
,	O
char	O
*	O
*	O
rname	*(*(char))
)	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
i	int
;	O
name	*(char)
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
cmd	*(*(char))
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
cmd	*(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
name	*(char)
=	O
cmd	*(*(char))
[	O
i	int
]	O
;	O
else	O
return	O
(	O
1	int
)	O
;	O
}	O
*	O
rname	*(*(char))
=	O
name	*(char)
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_client_master_parse_command_tokens	(*(*(char)),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),int,*(void))->(int)
(	O
char	O
*	O
*	O
cmd	*(*(char))
,	O
parallelstatus	struct(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(struct(*(struct(*`,*`,*`,int)),*(struct(*`,*`,*`,int)),*(struct(*`,*`,int,struct`,int)),int)),int,int,int,int,long)
*	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
int	O
qid	int
,	O
void	O
*	O
dd	*(void)
)	O
{	O
time_t	long
tc	long
;	O
int	O
i	int
,	O
ret	*(*(void))
;	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
;	O
client	struct
*	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
if	O
(	O
qid	int
>=	O
0	int
)	O
{	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
(	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
)	O
dd	*(void)
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
NULL	O
;	O
}	O
else	O
{	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
NULL	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
(	O
client	struct
*	O
)	O
dd	*(void)
;	O
}	O
if	O
(	O
cmd	*(*(char))
==	O
NULL	O
||	O
cmd	*(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"status"	*(char)
)	O
==	O
0	int
)	O
{	O
time	struct(long,long)
(	O
&	O
tc	long
)	O
;	O
if	O
(	O
qid	int
>=	O
0	int
&&	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
!=	O
NULL	O
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
,	O
"remote %d status %d/%d/%d %d %d\n"	*(char)
,	O
qid	int
,	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
nfinished	int
,	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
npending	int
,	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
nparam	int
,	O
(	O
int	O
)	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
t0	long
,	O
(	O
int	O
)	O
tc	long
)	O
;	O
}	O
else	O
if	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
!=	O
NULL	O
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"status %d/%d/%d %d %d\n"	*(char)
,	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
nfinished	int
,	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
npending	int
,	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
nparam	int
,	O
(	O
int	O
)	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
t0	long
,	O
(	O
int	O
)	O
tc	long
)	O
;	O
}	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"lock"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
maxnum	int
;	O
imutex	struct
*	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
;	O
name	*(char)
=	O
NULL	O
;	O
maxnum	int
=	O
0	int
;	O
i	int
=	O
imutex_lock_get_params	(*(*(char)),*(*(char)),*(int))->(int)
(	O
cmd	*(*(char))
,	O
&	O
name	*(char)
,	O
&	O
maxnum	int
)	O
;	O
if	O
(	O
i	int
||	O
name	*(char)
==	O
NULL	O
)	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"error unexpected arguments for '%s'\n"	*(char)
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
else	O
if	O
(	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
=	O
get_imutex_by_name	(*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(char))->(*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
imutexlist	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
,	O
name	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
=	O
(	O
pendingclient	struct(int,*(void))
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
,	O
sizeof	O
(	O
pendingclient	struct(int,*(void))
)	O
*	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
+	O
1	int
)	O
)	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
[	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
]	O
.	O
qid	int
=	O
qid	int
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
[	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
]	O
.	O
data	*(void)
=	O
dd	*(void)
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
++	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
state	*(int)
++	O
;	O
}	O
else	O
{	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
=	O
list_new	O
(	O
imutex	struct
)	O
;	O
list_insert_first	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
imutexlist	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
,	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
)	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
state	*(int)
=	O
1	int
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
=	O
NULL	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
=	O
0	int
;	O
if	O
(	O
qid	int
>=	O
0	int
&&	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
!=	O
NULL	O
)	O
hprintf	(int,*(char))->(int)
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
,	O
"remote %d locked \"%s\"\n"	*(char)
,	O
qid	int
,	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
name	*(char)
)	O
;	O
else	O
if	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
!=	O
NULL	O
)	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"locked \"%s\"\n"	*(char)
,	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
name	*(char)
)	O
;	O
}	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"unlock"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
name	*(char)
;	O
imutex	struct
*	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
;	O
pendingclient	struct(int,*(void))
pcw	struct(int,*(void))
;	O
int	O
is_pcw_set	int
;	O
name	*(char)
=	O
NULL	O
;	O
i	int
=	O
imutex_unlock_get_params	(*(*(char)),*(*(char)))->(int)
(	O
cmd	*(*(char))
,	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
(	O
!	O
i	int
)	O
&&	O
name	*(char)
!=	O
NULL	O
&&	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
=	O
get_imutex_by_name	(*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(char))->(*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
imutexlist	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
,	O
name	*(char)
)	O
)	O
!=	O
NULL	O
)	O
{	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
state	*(int)
--	O
;	O
if	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
!=	O
NULL	O
&&	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
>	O
0	int
)	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
pcw	struct(int,*(void))
,	O
&	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
[	O
0	int
]	O
,	O
sizeof	O
(	O
pendingclient	struct(int,*(void))
)	O
)	O
;	O
is_pcw_set	int
=	O
1	int
;	O
if	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
>	O
1	int
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
,	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
+	O
1	int
,	O
sizeof	O
(	O
pendingclient	struct(int,*(void))
)	O
*	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
-	O
1	int
)	O
)	O
;	O
else	O
{	O
free	(*(void))->(void)
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
)	O
;	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
pclients	*(struct(int,*(void)))
=	O
NULL	O
;	O
}	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
--	O
;	O
}	O
else	O
is_pcw_set	int
=	O
0	int
;	O
if	O
(	O
is_pcw_set	int
)	O
{	O
if	O
(	O
pcw	struct(int,*(void))
.	O
qid	int
>=	O
0	int
&&	O
pcw	struct(int,*(void))
.	O
data	*(void)
!=	O
NULL	O
)	O
hprintf	(int,*(char))->(int)
(	O
(	O
(	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
)	O
pcw	struct(int,*(void))
.	O
data	*(void)
)	O
->	O
fhsend	int
,	O
"remote %d locked \"%s\"\n"	*(char)
,	O
pcw	struct(int,*(void))
.	O
qid	int
,	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
name	*(char)
)	O
;	O
else	O
if	O
(	O
pcw	struct(int,*(void))
.	O
data	*(void)
!=	O
NULL	O
)	O
hprintf	(int,*(char))->(int)
(	O
(	O
(	O
client	struct
*	O
)	O
pcw	struct(int,*(void))
.	O
data	*(void)
)	O
->	O
peer	int
,	O
"locked \"%s\"\n"	*(char)
,	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
name	*(char)
)	O
;	O
}	O
if	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
state	*(int)
<=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
name	*(char)
)	O
;	O
list_remove	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
imutexlist	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
,	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
)	O
;	O
free	(*(void))->(void)
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
)	O
;	O
}	O
}	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"mutex"	*(char)
)	O
==	O
0	int
)	O
{	O
imutex	struct
*	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
;	O
char	O
*	O
name	*(char)
;	O
int	O
lcnt	int
;	O
name	*(char)
=	O
NULL	O
;	O
i	int
=	O
imutex_mutex_get_params	(*(*(char)),*(*(char)))->(int)
(	O
cmd	*(*(char))
,	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
i	int
||	O
name	*(char)
==	O
NULL	O
)	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"error unexpected arguments for '%s'\n"	*(char)
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
else	O
{	O
if	O
(	O
(	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
=	O
get_imutex_by_name	(*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(char))->(*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
imutexlist	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
,	O
name	*(char)
)	O
)	O
!=	O
NULL	O
)	O
lcnt	int
=	O
mx	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
->	O
npclient	int
;	O
else	O
lcnt	int
=	O
0	int
;	O
if	O
(	O
qid	int
>=	O
0	int
&&	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
!=	O
NULL	O
)	O
hprintf	(int,*(char))->(int)
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
,	O
"remote %d mutex \"%s\" %d\n"	*(char)
,	O
qid	int
,	O
name	*(char)
,	O
lcnt	int
)	O
;	O
else	O
if	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
!=	O
NULL	O
)	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"mutex \"%s\" %d\n"	*(char)
,	O
name	*(char)
,	O
lcnt	int
)	O
;	O
}	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"exit"	*(char)
)	O
==	O
0	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"bye\n"	*(char)
)	O
;	O
ret	*(*(void))
=	O
1	int
;	O
}	O
else	O
{	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"error unexpected command '%s'\n"	*(char)
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
ret	*(*(void))
=	O
0	int
;	O
}	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
int	O
remote_client_master_parse_command	(*(char),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),int,*(void))->(int)
(	O
char	O
*	O
line	*(char)
,	O
parallelstatus	struct(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(struct(*(struct(*`,*`,*`,int)),*(struct(*`,*`,*`,int)),*(struct(*`,*`,int,struct`,int)),int)),int,int,int,int,long)
*	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
int	O
qid	int
,	O
void	O
*	O
dd	*(void)
)	O
{	O
int	O
ret	*(*(void))
;	O
char	O
*	O
*	O
cmd	*(*(char))
;	O
cmd	*(*(char))
=	O
tokenize_spaces_dyn	(*(char))->(*(*(char)))
(	O
line	*(char)
)	O
;	O
if	O
(	O
cmd	*(*(char))
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
cmd	*(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
cmd	*(*(char))
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
ret	*(*(void))
=	O
remote_client_master_parse_command_tokens	(*(*(char)),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),int,*(void))->(int)
(	O
cmd	*(*(char))
,	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
qid	int
,	O
dd	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
cmd	*(*(char))
)	O
;	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
int	O
pexec_submit	(*(struct(*(char),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*`,int)))),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),*(struct(struct(union(*`,*`),int),int,int)),*(struct(struct(union(*`,*`),int),int,int)),*(struct(int,int,int,int,int,int,struct(*(char),long))),*(struct(*(char),int,struct(int,*(*`),int),int,int)),int)->(int)
(	O
paralleldata	struct(*(char),*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)))
*	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
parallelstatus	struct(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(struct(*(struct(*`,*`,*`,int)),*(struct(*`,*`,*`,int)),*(struct(*`,*`,int,struct`,int)),int)),int,int,int,int,long)
*	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
numhashtable	struct(struct(union(*(struct(union`,int)),*(void)),int),int,int)
*	O
ntp	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
numhashtable	struct(struct(union(*(struct(union`,int)),*(void)),int),int,int)
*	O
ntf	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
int	O
n	int
)	O
{	O
child	struct
*	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
list_new	O
(	O
child	struct
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
=	O
-	O
1	int
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
=	O
-	O
1	int
;	O
list_insert_first	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
achild	int
++	O
;	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
achild	int
++	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
;	O
if	O
(	O
!	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
num_processes	int
)	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
estatus	int
=	O
0	int
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
lout	struct(*(char),long)
)	O
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
lerr	struct(*(char),long)
)	O
;	O
if	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
pid	int
>=	O
0	int
)	O
{	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
=	O
n	int
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
=	O
-	O
1	int
;	O
send_task	(*(struct(*(char),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*`,int)))),*(struct(*(char),int,struct(int,*(*`),int),int,int)),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
npending	int
++	O
;	O
numhash_add	(*(struct(struct(union(*`,*`),int),int,int)),int,*(void))->(int)
(	O
ntp	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
n	int
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
=	O
n	int
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
=	O
submit_task	(*(struct(*(char),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*`,int)))),*(struct(*(char),int,struct(int,*(*`),int),int,int)),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
0	int
,	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
npending	int
++	O
;	O
numhash_add	(*(struct(struct(union(*`,*`),int),int,int)),int,*(void))->(int)
(	O
ntp	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
n	int
,	O
NULL	O
)	O
;	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
<	O
0	int
)	O
{	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
nfinished	int
++	O
;	O
numhash_add	(*(struct(struct(union(*`,*`),int),int,int)),int,*(void))->(int)
(	O
ntf	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
n	int
,	O
NULL	O
)	O
;	O
log_message	(*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)),int,*(struct(*(char),int,struct(int,*(*`),int),int,int)),*(char))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
,	O
1	int
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
"error while invoking task:"	*(char)
" %s"	*(char)
,	O
logmsg_submit_task	array(*(char))
[	O
-	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
]	O
)	O
;	O
list_remove	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
free	(*(void))->(void)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
achild	int
--	O
;	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
achild	int
--	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
pexec_get_free_remote_shell	(*(struct(int,int,int,int,int,int,struct(*(char),long))),int)->(*(struct(int,int,int,int,int,int,struct(*(char),long))))
(	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
int	O
nrshell	int
)	O
{	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
;	O
int	O
r	int
;	O
for	O
(	O
r	int
=	O
0	int
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
++	O
)	O
{	O
if	O
(	O
(	O
0	int
<	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
num_processes	int
&&	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
achild	int
<	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
num_processes	int
)	O
||	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
estatus	int
>=	O
2	int
)	O
return	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
int	O
pexec_do_parallelized_execution	(*(struct(*(char),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*`,int)))),*(struct(*(char),int,struct(int,*(*`),int),int,int)),int,*(struct(int,int,int,int,int,int,struct(*(char),long))),int,int,int)->(int)
(	O
paralleldata	struct(*(char),*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)))
*	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
int	O
nparam	int
,	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
int	O
nrshell	int
,	O
int	O
sock	int
,	O
int	O
hsck	int
)	O
{	O
child	struct
*	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
chldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
signalinfo	struct(int,int,int,int)
sci	struct(int,int,int,int)
;	O
numhashtable	struct(struct(union(*(struct(union`,int)),*(void)),int),int,int)
ntp	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
ntf	*(struct(struct(union(*(struct`),*(void)),int),int,int))
;	O
int	O
i	int
,	O
n	int
,	O
r	int
;	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
;	O
fd_set	struct(array(long))
set	struct(array(long))
;	O
int	O
spipe	int
,	O
max	int
,	O
status	int
;	O
char	O
*	O
buff	*(char)
;	O
int	O
buffsize	int
;	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
;	O
client	struct
*	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
parallelstatus	struct(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(struct(*(struct(*`,*`,*`,int)),*(struct(*`,*`,*`,int)),*(struct(*`,*`,int,struct`,int)),int)),int,int,int,int,long)
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
;	O
linebuffer	struct(*(char),long)
lhyp	struct(*(char),long)
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
sig_pipe	array(int)
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
spipe	int
=	O
sig_pipe	array(int)
[	O
0	int
]	O
;	O
chldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
sig_act_child	(int)->(void)
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
chldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
chldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
(	O
SA_NOCLDSTOP	int
|	O
SA_RESTART	int
)	O
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGCHLD	int
,	O
&	O
chldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
NULL	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
achild	int
=	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
++	O
)	O
{	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
achild	int
=	O
0	int
;	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
estatus	int
=	O
0	int
;	O
}	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
nfinished	int
=	O
0	int
;	O
numhash_init	(*(struct(struct(union(*`,*`),int),int,int)),int,int)->(int)
(	O
&	O
ntf	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
get_bit_size	(int)->(int)
(	O
nparam	int
)	O
,	O
4	int
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
npending	int
=	O
0	int
;	O
numhash_init	(*(struct(struct(union(*`,*`),int),int,int)),int,int)->(int)
(	O
&	O
ntp	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
get_bit_size	(int)->(int)
(	O
nparam	int
)	O
,	O
4	int
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
nparam	int
=	O
nparam	int
;	O
buffsize	int
=	O
getpagesize	()->(int)
(	O
)	O
;	O
buff	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
buffsize	int
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
sock	int
=	O
sock	int
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
hsck	int
=	O
hsck	int
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
NULL	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
imutexlist	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
=	O
NULL	O
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
lhyp	struct(*(char),long)
)	O
;	O
time	struct(long,long)
(	O
&	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
t0	long
)	O
;	O
while	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
nfinished	int
<	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
nparam	int
)	O
{	O
while	O
(	O
1	int
)	O
{	O
n	int
=	O
numhash_get_smallest_free	(*(struct(struct(union(*`,*`),int),int,int)))->(int)
(	O
&	O
ntp	*(struct(struct(union(*(struct`),*(void)),int),int,int))
)	O
;	O
if	O
(	O
n	int
<	O
0	int
||	O
n	int
>=	O
nparam	int
)	O
break	O
;	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
pexec_get_free_remote_shell	(*(struct(int,int,int,int,int,int,struct(*(char),long))),int)->(*(struct(int,int,int,int,int,int,struct(*(char),long))))
(	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
nrshell	int
)	O
;	O
if	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
==	O
NULL	O
)	O
break	O
;	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
&	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
n	int
]	O
;	O
pexec_submit	(*(struct(*(char),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*`,int)))),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),*(struct(struct(union(*`,*`),int),int,int)),*(struct(struct(union(*`,*`),int),int,int)),*(struct(int,int,int,int,int,int,struct(*(char),long))),*(struct(*(char),int,struct(int,*(*`),int),int,int)),int)->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
&	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
&	O
ntp	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
&	O
ntf	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
n	int
)	O
;	O
}	O
for	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
r	int
=	O
0	int
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
++	O
)	O
{	O
if	O
(	O
!	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
num_processes	int
&&	O
!	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
estatus	int
)	O
{	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
estatus	int
=	O
1	int
;	O
if	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
pid	int
>=	O
0	int
)	O
hprintf	(int,*(char))->(int)
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
,	O
"request\n"	*(char)
)	O
;	O
else	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
hprintf	(int,*(char))->(int)
(	O
hsck	int
,	O
"request\n"	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
nfinished	int
>=	O
nparam	int
)	O
break	O
;	O
FD_ZERO	O
(	O
&	O
set	struct(array(long))
)	O
;	O
FD_SET	O
(	O
spipe	int
,	O
&	O
set	struct(array(long))
)	O
;	O
max	int
=	O
spipe	int
;	O
for	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
!=	O
NULL	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
<	O
0	int
||	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
)	O
max	int
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
;	O
}	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
)	O
max	int
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
;	O
}	O
}	O
for	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
r	int
=	O
0	int
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
++	O
)	O
{	O
if	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
pid	int
<	O
0	int
||	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
<	O
0	int
||	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhrecv	int
<	O
0	int
)	O
continue	O
;	O
FD_SET	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhrecv	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhrecv	int
)	O
max	int
=	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhrecv	int
;	O
}	O
if	O
(	O
sock	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
sock	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
sock	int
)	O
max	int
=	O
sock	int
;	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
hsck	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
hsck	int
)	O
max	int
=	O
hsck	int
;	O
}	O
for	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
!=	O
NULL	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
FD_SET	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
)	O
max	int
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
;	O
}	O
i	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
max	int
+	O
1	int
,	O
&	O
set	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
FD_ISSET	O
(	O
spipe	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
if	O
(	O
!	O
(	O
read_signalinfo	(int,*(struct(int,int,int,int)))->(int)
(	O
spipe	int
,	O
&	O
sci	struct(int,int,int,int)
)	O
>	O
0	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: fatal error: read_signalinfo() failed.\n"	*(char)
)	O
,	O
progbasename	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
sci	struct(int,int,int,int)
.	O
exitsignal	int
<	O
0	int
)	O
{	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
get_child_by_pid	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int)->(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
sci	struct(int,int,int,int)
.	O
pid	int
)	O
;	O
n	int
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
=	O
-	O
1	int
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
=	O
-	O
1	int
;	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
&	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
n	int
]	O
;	O
numhash_add	(*(struct(struct(union(*`,*`),int),int,int)),int,*(void))->(int)
(	O
&	O
ntf	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
n	int
,	O
NULL	O
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
nfinished	int
++	O
;	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
>=	O
0	int
&&	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
while	O
(	O
fd_avail	(int)->(int)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
)	O
)	O
{	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
write_output	(*(char),long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(struct(*(char),long)),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(int)
(	O
buff	*(char)
,	O
n	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
formatout	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
omit_newlines	int
,	O
&	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
lout	struct(*(char),long)
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
break	O
;	O
}	O
write_output	(*(char),long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(struct(*(char),long)),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(int)
(	O
NULL	O
,	O
0	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
formatout	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
omit_newlines	int
,	O
&	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
lout	struct(*(char),long)
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
close	*((*(void))->(int))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
>=	O
0	int
&&	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
{	O
while	O
(	O
fd_avail	(int)->(int)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
)	O
)	O
{	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
write_output	(*(char),long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(struct(*(char),long)),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(int)
(	O
buff	*(char)
,	O
n	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
formaterr	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
omit_newlines	int
,	O
&	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
lerr	struct(*(char),long)
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
break	O
;	O
}	O
write_output	(*(char),long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(struct(*(char),long)),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(int)
(	O
NULL	O
,	O
0	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
formaterr	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
omit_newlines	int
,	O
&	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
lerr	struct(*(char),long)
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
close	*((*(void))->(int))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
=	O
-	O
1	int
;	O
}	O
list_remove	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
achild	int
--	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
achild	int
--	O
;	O
if	O
(	O
!	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
num_processes	int
&&	O
hsck	int
>=	O
0	int
)	O
hprintf	(int,*(char))->(int)
(	O
hsck	int
,	O
"ready\n"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
}	O
else	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fallback_to_die	int
)	O
{	O
close	*((*(void))->(int))
(	O
sig_pipe	array(int)
[	O
0	int
]	O
)	O
;	O
sig_pipe	array(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
close	*((*(void))->(int))
(	O
sig_pipe	array(int)
[	O
1	int
]	O
)	O
;	O
sig_pipe	array(int)
[	O
1	int
]	O
=	O
-	O
1	int
;	O
for	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
!=	O
NULL	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
kill	(int,int)->(int)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
,	O
SIGKILL	int
)	O
;	O
waitpid	(int,*(int),int)->(int)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
free	(*(void))->(void)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
}	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
NULL	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
achild	int
=	O
0	int
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
get_child_by_pid	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int)->(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
sci	struct(int,int,int,int)
.	O
pid	int
)	O
;	O
numhash_remove	(*(struct(struct(union(*`,*`),int),int,int)),int)->(int)
(	O
&	O
ntp	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
n	int
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
npending	int
--	O
;	O
list_remove	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
achild	int
--	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
achild	int
--	O
;	O
free	(*(void))->(void)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
}	O
}	O
for	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
!=	O
NULL	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
<	O
0	int
||	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
&	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
]	O
;	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
>=	O
0	int
&&	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
&&	O
FD_ISSET	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
write_output	(*(char),long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(struct(*(char),long)),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(int)
(	O
buff	*(char)
,	O
n	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
formatout	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
omit_newlines	int
,	O
&	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
lout	struct(*(char),long)
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
>=	O
0	int
&&	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
&&	O
FD_ISSET	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
write_output	(*(char),long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(struct(*(char),long)),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(int)
(	O
buff	*(char)
,	O
n	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
formaterr	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
omit_newlines	int
,	O
&	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
lerr	struct(*(char),long)
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
for	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
r	int
=	O
0	int
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
++	O
)	O
{	O
int	O
len	int
;	O
char	O
*	O
line	*(char)
,	O
*	O
*	O
cmd	*(*(char))
;	O
if	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
pid	int
<	O
0	int
||	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
<	O
0	int
||	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhrecv	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
!	O
FD_ISSET	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhrecv	int
,	O
&	O
set	struct(array(long))
)	O
)	O
continue	O
;	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhrecv	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
linebuffer_concatenate	(*(struct(*(char),long)),*(char),long)->(int)
(	O
&	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
lrsh	struct(*(char),long)
,	O
buff	*(char)
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	*(char)
=	O
linebuffer_fetch	(*(struct(*(char),long)))->(*(char))
(	O
&	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
lrsh	struct(*(char),long)
)	O
)	O
!=	O
NULL	O
)	O
{	O
cmd	*(*(char))
=	O
tokenize_spaces_dyn	(*(char))->(*(*(char)))
(	O
line	*(char)
)	O
;	O
if	O
(	O
cmd	*(*(char))
!=	O
NULL	O
&&	O
cmd	*(*(char))
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"output"	*(char)
)	O
==	O
0	int
&&	O
cmd	*(*(char))
[	O
1	int
]	O
!=	O
NULL	O
&&	O
cmd	*(*(char))
[	O
2	int
]	O
!=	O
NULL	O
)	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
1	int
]	O
,	O
"%d"	*(char)
,	O
&	O
n	int
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
get_child_by_id	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int)->(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
n	int
)	O
;	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
&	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
n	int
]	O
;	O
len	int
=	O
daemon_commandtoken_unescape	(*(char))->(int)
(	O
cmd	*(*(char))
[	O
2	int
]	O
)	O
;	O
write_output	(*(char),long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(struct(*(char),long)),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(int)
(	O
cmd	*(*(char))
[	O
2	int
]	O
,	O
len	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
formatout	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
omit_newlines	int
,	O
&	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
lout	struct(*(char),long)
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"error"	*(char)
)	O
==	O
0	int
&&	O
cmd	*(*(char))
[	O
1	int
]	O
!=	O
NULL	O
&&	O
cmd	*(*(char))
[	O
2	int
]	O
!=	O
NULL	O
)	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
1	int
]	O
,	O
"%d"	*(char)
,	O
&	O
n	int
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
get_child_by_id	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int)->(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
n	int
)	O
;	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
&	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
n	int
]	O
;	O
len	int
=	O
daemon_commandtoken_unescape	(*(char))->(int)
(	O
cmd	*(*(char))
[	O
2	int
]	O
)	O
;	O
write_output	(*(char),long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(struct(*(char),long)),*(struct(*(char),int,struct(int,*(*`),int),int,int)))->(int)
(	O
cmd	*(*(char))
[	O
2	int
]	O
,	O
len	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
formaterr	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
->	O
omit_newlines	int
,	O
&	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
lerr	struct(*(char),long)
,	O
cp	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"finish"	*(char)
)	O
==	O
0	int
&&	O
cmd	*(*(char))
[	O
1	int
]	O
!=	O
NULL	O
)	O
{	O
sscanf	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
1	int
]	O
,	O
"%d"	*(char)
,	O
&	O
n	int
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
get_child_by_id	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int)->(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
n	int
)	O
;	O
numhash_add	(*(struct(struct(union(*`,*`),int),int,int)),int,*(void))->(int)
(	O
&	O
ntf	*(struct(struct(union(*(struct`),*(void)),int),int,int))
,	O
n	int
,	O
NULL	O
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
nfinished	int
++	O
;	O
list_remove	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
achild	int
--	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
achild	int
--	O
;	O
if	O
(	O
!	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
num_processes	int
)	O
hprintf	(int,*(char))->(int)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
,	O
"ready\n"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"remote"	*(char)
)	O
==	O
0	int
&&	O
cmd	*(*(char))
[	O
1	int
]	O
!=	O
NULL	O
&&	O
cmd	*(*(char))
[	O
2	int
]	O
!=	O
NULL	O
)	O
{	O
int	O
qid	int
;	O
void	O
*	O
dd	*(void)
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
1	int
]	O
,	O
"%d"	*(char)
,	O
&	O
qid	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
qid	int
>=	O
0	int
)	O
dd	*(void)
=	O
(	O
void	O
*	O
)	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
;	O
else	O
dd	*(void)
=	O
NULL	O
;	O
remote_client_master_parse_command_tokens	(*(*(char)),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),int,*(void))->(int)
(	O
cmd	*(*(char))
+	O
2	int
,	O
&	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
qid	int
,	O
dd	*(void)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"acknowledged"	*(char)
)	O
==	O
0	int
)	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
estatus	int
=	O
2	int
;	O
}	O
if	O
(	O
cmd	*(*(char))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
cmd	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
}	O
}	O
for	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
!=	O
NULL	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
char	O
*	O
line	*(char)
;	O
int	O
closepeer	int
;	O
if	O
(	O
!	O
FD_ISSET	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
&	O
set	struct(array(long))
)	O
)	O
continue	O
;	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
)	O
;	O
linebuffer_free	(*(struct(*(char),long)))->(int)
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
)	O
;	O
imutex_cleanup	(*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),int,*(void))->(int)
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
imutexlist	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
,	O
-	O
1	int
,	O
(	O
void	O
*	O
)	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
list_remove	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
,	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
free	(*(void))->(void)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
linebuffer_concatenate	(*(struct(*(char),long)),*(char),long)->(int)
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
,	O
buff	*(char)
,	O
n	int
)	O
;	O
closepeer	int
=	O
0	int
;	O
while	O
(	O
(	O
line	*(char)
=	O
linebuffer_fetch	(*(struct(*(char),long)))->(*(char))
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
)	O
)	O
!=	O
NULL	O
)	O
{	O
closepeer	int
=	O
remote_client_master_parse_command	(*(char),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),int,*(void))->(int)
(	O
line	*(char)
,	O
&	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
-	O
1	int
,	O
(	O
void	O
*	O
)	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
if	O
(	O
closepeer	int
)	O
break	O
;	O
}	O
;	O
if	O
(	O
closepeer	int
)	O
{	O
close	*((*(void))->(int))
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
)	O
;	O
linebuffer_free	(*(struct(*(char),long)))->(int)
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
)	O
;	O
imutex_cleanup	(*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),int,*(void))->(int)
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
imutexlist	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
,	O
-	O
1	int
,	O
(	O
void	O
*	O
)	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
list_remove	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
,	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
free	(*(void))->(void)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
hsck	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
char	O
*	O
line	*(char)
,	O
*	O
*	O
cmd	*(*(char))
;	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
hsck	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
linebuffer_concatenate	(*(struct(*(char),long)),*(char),long)->(int)
(	O
&	O
lhyp	struct(*(char),long)
,	O
buff	*(char)
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	*(char)
=	O
linebuffer_fetch	(*(struct(*(char),long)))->(*(char))
(	O
&	O
lhyp	struct(*(char),long)
)	O
)	O
!=	O
NULL	O
)	O
{	O
cmd	*(*(char))
=	O
tokenize_spaces_dyn	(*(char))->(*(*(char)))
(	O
line	*(char)
)	O
;	O
if	O
(	O
cmd	*(*(char))
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"acknowledged"	*(char)
)	O
==	O
0	int
)	O
{	O
for	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
r	int
=	O
0	int
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
++	O
)	O
{	O
if	O
(	O
!	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
num_processes	int
)	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
estatus	int
=	O
2	int
;	O
}	O
}	O
free	(*(void))->(void)
(	O
cmd	*(*(char))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
sock	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
sock	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
list_new	O
(	O
client	struct
)	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
=	O
accept	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
sock	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
)	O
;	O
list_insert_first	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
,	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
status	int
=	O
0	int
;	O
}	O
}	O
for	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
r	int
=	O
0	int
;	O
r	int
<	O
nrshell	int
;	O
r	int
++	O
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
++	O
)	O
{	O
if	O
(	O
!	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
num_processes	int
)	O
{	O
if	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
pid	int
>=	O
0	int
)	O
hprintf	(int,*(char))->(int)
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
,	O
"completed\n"	*(char)
)	O
;	O
else	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
hprintf	(int,*(char))->(int)
(	O
hsck	int
,	O
"completed\n"	*(char)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
buff	*(char)
)	O
;	O
numhash_free	(*(struct(struct(union(*`,*`),int),int,int)))->(int)
(	O
&	O
ntp	*(struct(struct(union(*(struct`),*(void)),int),int,int))
)	O
;	O
numhash_free	(*(struct(struct(union(*`,*`),int),int,int)))->(int)
(	O
&	O
ntf	*(struct(struct(union(*(struct`),*(void)),int),int,int))
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
close	*((*(void))->(int))
(	O
sig_pipe	array(int)
[	O
0	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
sig_pipe	array(int)
[	O
1	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_client_daemon_parse_command	(*(char),*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),int)->(int)
(	O
char	O
*	O
line	*(char)
,	O
client	struct
*	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
,	O
parallelstatus	struct(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(struct(*(struct(*`,*`,*`,int)),*(struct(*`,*`,*`,int)),*(struct(*`,*`,int,struct`,int)),int)),int,int,int,int,long)
*	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
int	O
fhsend	int
)	O
{	O
int	O
i	int
,	O
ret	*(*(void))
;	O
char	O
*	O
*	O
cmd	*(*(char))
;	O
cmd	*(*(char))
=	O
tokenize_spaces_dyn	(*(char))->(*(*(char)))
(	O
line	*(char)
)	O
;	O
if	O
(	O
cmd	*(*(char))
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
cmd	*(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
cmd	*(*(char))
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"status"	*(char)
)	O
==	O
0	int
)	O
{	O
dqueue	struct
*	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
;	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
=	O
list_new	O
(	O
dqueue	struct
)	O
;	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
id	int
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
iqueue	int
;	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
qclient	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
list_insert_first	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
dqueuelist	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
,	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
)	O
;	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"remote %d status\n"	*(char)
,	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
id	int
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
iqueue	int
++	O
;	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"lock"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
maxnum	int
;	O
dqueue	struct
*	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
;	O
name	*(char)
=	O
NULL	O
;	O
maxnum	int
=	O
0	int
;	O
i	int
=	O
imutex_lock_get_params	(*(*(char)),*(*(char)),*(int))->(int)
(	O
cmd	*(*(char))
,	O
&	O
name	*(char)
,	O
&	O
maxnum	int
)	O
;	O
if	O
(	O
i	int
||	O
name	*(char)
==	O
NULL	O
)	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"error unexpected arguments for '%s'\n"	*(char)
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
else	O
{	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
=	O
list_new	O
(	O
dqueue	struct
)	O
;	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
id	int
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
iqueue	int
;	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
qclient	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
list_insert_first	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
dqueuelist	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
,	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
)	O
;	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"remote %d lock \"%s\"\n"	*(char)
,	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
id	int
,	O
name	*(char)
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
iqueue	int
++	O
;	O
}	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"unlock"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
name	*(char)
;	O
name	*(char)
=	O
NULL	O
;	O
i	int
=	O
imutex_unlock_get_params	(*(*(char)),*(*(char)))->(int)
(	O
cmd	*(*(char))
,	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
i	int
||	O
name	*(char)
==	O
NULL	O
)	O
)	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"remote -1 unlock \"%s\"\n"	*(char)
,	O
name	*(char)
)	O
;	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"mutex"	*(char)
)	O
==	O
0	int
)	O
{	O
char	O
*	O
name	*(char)
;	O
dqueue	struct
*	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
;	O
name	*(char)
=	O
NULL	O
;	O
i	int
=	O
imutex_mutex_get_params	(*(*(char)),*(*(char)))->(int)
(	O
cmd	*(*(char))
,	O
&	O
name	*(char)
)	O
;	O
if	O
(	O
i	int
||	O
name	*(char)
==	O
NULL	O
)	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"error unexpected arguments for '%s'\n"	*(char)
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
else	O
{	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
=	O
list_new	O
(	O
dqueue	struct
)	O
;	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
id	int
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
iqueue	int
;	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
qclient	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
list_insert_first	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
dqueuelist	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
,	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
)	O
;	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"remote %d mutex \"%s\"\n"	*(char)
,	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
id	int
,	O
name	*(char)
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
iqueue	int
++	O
;	O
}	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"exit"	*(char)
)	O
==	O
0	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"bye\n"	*(char)
)	O
;	O
ret	*(*(void))
=	O
1	int
;	O
}	O
else	O
{	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"error unexpected command '%s'\n"	*(char)
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
ret	*(*(void))
=	O
0	int
;	O
}	O
free	(*(void))->(void)
(	O
cmd	*(*(char))
)	O
;	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
dqueue	struct
*	O
dqueue_get_queue_by_id	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),int)->(*(struct(*(struct(*`,*`,*`,int)),*(struct(*`,*`,*`,int)),*(struct(*`,*`,int,struct`,int)),int)))
(	O
parallelstatus	struct(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(struct(*(struct(*`,*`,*`,int)),*(struct(*`,*`,*`,int)),*(struct(*`,*`,int,struct`,int)),int)),int,int,int,int,long)
*	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
int	O
id	int
)	O
{	O
dqueue	struct
*	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
;	O
for	O
(	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
dqueuelist	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
;	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
!=	O
NULL	O
;	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
=	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
id	int
==	O
id	int
)	O
return	O
(	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
int	O
daemon_process_command	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),int,*(*(char)))->(int)
(	O
parallelstatus	struct(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(struct(*(struct(*`,*`,*`,int)),*(struct(*`,*`,*`,int)),*(struct(*`,*`,int,struct`,int)),int)),int,int,int,int,long)
*	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
int	O
fhsend	int
,	O
char	O
*	O
*	O
cmd	*(*(char))
)	O
{	O
int	O
i	int
,	O
n	int
,	O
id	int
,	O
zeroarg	int
;	O
char	O
*	O
shell	*(char)
,	O
*	O
in	*(char)
,	O
*	O
out	*(char)
,	O
*	O
err	long
,	O
*	O
envname	*(char)
,	O
*	O
envvalue	*(char)
,	O
*	O
eoc	*(char)
;	O
paralleldata	struct(*(char),*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)))
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
;	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
;	O
child	struct
*	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
dqueue	struct
*	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
;	O
if	O
(	O
cmd	*(*(char))
==	O
NULL	O
||	O
cmd	*(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
cmd	*(*(char))
[	O
n	int
]	O
!=	O
NULL	O
;	O
)	O
n	int
++	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"exit"	*(char)
)	O
==	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"remote"	*(char)
)	O
==	O
0	int
&&	O
n	int
>=	O
3	int
)	O
{	O
int	O
qid	int
,	O
j	int
;	O
char	O
*	O
buff	*(char)
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
1	int
]	O
,	O
"%d"	*(char)
,	O
&	O
qid	int
)	O
<	O
1	int
)	O
qid	int
=	O
-	O
1	int
;	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
=	O
dqueue_get_queue_by_id	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),int)->(*(struct(*(struct(*`,*`,*`,int)),*(struct(*`,*`,*`,int)),*(struct(*`,*`,int,struct`,int)),int)))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
qid	int
)	O
;	O
if	O
(	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
!=	O
NULL	O
)	O
{	O
buff	*(char)
=	O
NULL	O
;	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
buff	*(char)
,	O
"%s"	*(char)
,	O
cmd	*(*(char))
[	O
2	int
]	O
)	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
2	int
]	O
,	O
"locked"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
2	int
]	O
,	O
"mutex"	*(char)
)	O
==	O
0	int
)	O
{	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
buff	*(char)
,	O
" \"%s\""	*(char)
,	O
(	O
cmd	*(*(char))
[	O
3	int
]	O
!=	O
NULL	O
?	O
cmd	*(*(char))
[	O
3	int
]	O
:	O
"-"	*(char)
)	O
)	O
;	O
if	O
(	O
cmd	*(*(char))
[	O
3	int
]	O
!=	O
NULL	O
)	O
j	int
=	O
4	int
;	O
else	O
j	int
=	O
3	int
;	O
}	O
else	O
j	int
=	O
3	int
;	O
for	O
(	O
;	O
cmd	*(*(char))
[	O
j	int
]	O
!=	O
NULL	O
;	O
j	int
++	O
)	O
strappendf	(*(*(char)),*(char))->(int)
(	O
&	O
buff	*(char)
,	O
" %s"	*(char)
,	O
cmd	*(*(char))
[	O
j	int
]	O
)	O
;	O
hprintf	(int,*(char))->(int)
(	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
->	O
qclient	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"%s\n"	*(char)
,	O
buff	*(char)
)	O
;	O
if	O
(	O
buff	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
buff	*(char)
)	O
;	O
list_remove	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
dqueuelist	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
,	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
)	O
;	O
free	(*(void))->(void)
(	O
dq	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"execute"	*(char)
)	O
==	O
0	int
)	O
{	O
shell	*(char)
=	O
NULL	O
;	O
in	*(char)
=	O
NULL	O
;	O
out	*(char)
=	O
NULL	O
;	O
err	long
=	O
NULL	O
;	O
envname	*(char)
=	O
NULL	O
;	O
envvalue	*(char)
=	O
NULL	O
;	O
id	int
=	O
-	O
1	int
;	O
zeroarg	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
cmd	*(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
zeroarg	int
=	O
i	int
+	O
1	int
;	O
break	O
;	O
}	O
eoc	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
'='	O
)	O
;	O
if	O
(	O
eoc	*(char)
==	O
NULL	O
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"message \"invalid argument '%s' for '%s'\"\n"	*(char)
,	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
*	O
eoc	*(char)
=	O
0	int
;	O
eoc	*(char)
++	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"id"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"identifier"	*(char)
)	O
==	O
0	int
)	O
sscanf	(*(char),*(char))->(int)
(	O
eoc	*(char)
,	O
"%d"	*(char)
,	O
&	O
id	int
)	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"shell"	*(char)
)	O
==	O
0	int
)	O
shell	*(char)
=	O
eoc	*(char)
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"in"	*(char)
)	O
==	O
0	int
)	O
in	*(char)
=	O
eoc	*(char)
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"out"	*(char)
)	O
==	O
0	int
)	O
out	*(char)
=	O
eoc	*(char)
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"err"	*(char)
)	O
==	O
0	int
)	O
err	long
=	O
eoc	*(char)
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"envname"	*(char)
)	O
==	O
0	int
)	O
envname	*(char)
=	O
eoc	*(char)
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"envvalue"	*(char)
)	O
==	O
0	int
)	O
envvalue	*(char)
=	O
eoc	*(char)
;	O
else	O
{	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"message \"invalid argument '%s' for '%s'\"\n"	*(char)
,	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
zeroarg	int
<	O
0	int
||	O
id	int
<	O
0	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"message \"invalid syntax near '%s'\"\n"	*(char)
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
zeroarg	int
>=	O
n	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"message \"command specification is missing near '%s'\"\n"	*(char)
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
in	*(char)
==	O
NULL	O
)	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
in	*(char)
=	O
NULL	O
;	O
else	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
in	*(char)
=	O
in	*(char)
;	O
if	O
(	O
out	*(char)
==	O
NULL	O
)	O
{	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
=	O
NULL	O
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
out	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
{	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
=	O
out	*(char)
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
else	O
{	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
=	O
out	*(char)
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
}	O
if	O
(	O
err	long
==	O
NULL	O
)	O
{	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
=	O
NULL	O
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
err	long
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
{	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
=	O
err	long
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
}	O
else	O
{	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
=	O
err	long
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
}	O
if	O
(	O
envname	*(char)
!=	O
NULL	O
&&	O
envvalue	*(char)
!=	O
NULL	O
)	O
{	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
envvarname	*(char)
=	O
envname	*(char)
;	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
name	*(char)
=	O
envvalue	*(char)
;	O
}	O
else	O
{	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
envvarname	*(char)
=	O
NULL	O
;	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
name	*(char)
=	O
NULL	O
;	O
}	O
if	O
(	O
shell	*(char)
!=	O
NULL	O
)	O
{	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
shell	*(char)
=	O
shell	*(char)
;	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
c	int
.	O
is_shell	int
=	O
1	int
;	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
c	int
.	O
argc	int
=	O
n	int
-	O
zeroarg	int
;	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
c	int
.	O
argv	*(*(char))
=	O
cmd	*(*(char))
+	O
zeroarg	int
;	O
}	O
else	O
{	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
shell	*(char)
=	O
NULL	O
;	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
c	int
.	O
is_shell	int
=	O
0	int
;	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
c	int
.	O
argc	int
=	O
n	int
-	O
zeroarg	int
;	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
c	int
.	O
argv	*(*(char))
=	O
cmd	*(*(char))
+	O
zeroarg	int
;	O
}	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
no_touch_std	int
=	O
0	int
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
list_new	O
(	O
child	struct
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
=	O
-	O
1	int
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
=	O
-	O
1	int
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
=	O
id	int
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
=	O
submit_task	(*(struct(*(char),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*`,int)))),*(struct(*(char),int,struct(int,*(*`),int),int,int)),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)))->(int)
(	O
&	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
&	O
par	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
!	O
0	int
,	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
)	O
;	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
<	O
0	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"message \"unable to execute, reason code: %d\"\n"	*(char)
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
)	O
;	O
free	(*(void))->(void)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
list_insert_first	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"request"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
hsck	int
<	O
0	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"message \"unexpected 'request': hypervisor has not been connected to daemon\"\n"	*(char)
)	O
;	O
}	O
else	O
{	O
hprintf	(int,*(char))->(int)
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
hsck	int
,	O
"request\n"	*(char)
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"ready"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
hsck	int
<	O
0	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"message \"unexpected 'ready': hypervisor has not been connected to daemon\"\n"	*(char)
)	O
;	O
}	O
else	O
{	O
hprintf	(int,*(char))->(int)
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
hsck	int
,	O
"ready\n"	*(char)
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"completed"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
hsck	int
<	O
0	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"message \"unexpected 'completed': hypervisor has not been connected to daemon\"\n"	*(char)
)	O
;	O
}	O
else	O
{	O
hprintf	(int,*(char))->(int)
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
->	O
hsck	int
,	O
"completed\n"	*(char)
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"message \"invalid command: %s\"\n"	*(char)
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
daemon_send_data	(int,*(char),int,*(char),int)->(int)
(	O
int	O
fhsend	int
,	O
char	O
*	O
streamname	*(char)
,	O
int	O
id	int
,	O
char	O
*	O
buff	*(char)
,	O
int	O
size	long
)	O
{	O
char	O
*	O
out	*(char)
;	O
if	O
(	O
buff	*(char)
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
out	*(char)
=	O
daemon_commandtoken_escape	(*(char),int)->(*(char))
(	O
buff	*(char)
,	O
size	long
)	O
;	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"%s %d "	*(char)
,	O
streamname	*(char)
,	O
id	int
)	O
;	O
write	*((*(void),*(char),long)->(long))
(	O
fhsend	int
,	O
out	*(char)
,	O
strlen	(*(char))->(long)
(	O
out	*(char)
)	O
)	O
;	O
free	(*(void))->(void)
(	O
out	*(char)
)	O
;	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"\n"	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
daemon_send_output	(int,int,*(char),int)->(int)
(	O
int	O
fhsend	int
,	O
int	O
id	int
,	O
char	O
*	O
buff	*(char)
,	O
int	O
size	long
)	O
{	O
return	O
(	O
daemon_send_data	(int,*(char),int,*(char),int)->(int)
(	O
fhsend	int
,	O
"output"	*(char)
,	O
id	int
,	O
buff	*(char)
,	O
size	long
)	O
)	O
;	O
}	O
int	O
daemon_send_error	(int,int,*(char),int)->(int)
(	O
int	O
fhsend	int
,	O
int	O
id	int
,	O
char	O
*	O
buff	*(char)
,	O
int	O
size	long
)	O
{	O
return	O
(	O
daemon_send_data	(int,*(char),int,*(char),int)->(int)
(	O
fhsend	int
,	O
"error"	*(char)
,	O
id	int
,	O
buff	*(char)
,	O
size	long
)	O
)	O
;	O
}	O
int	O
pexec_daemon_main_loop	(int,int,int,int,int)->(int)
(	O
int	O
fhrecv	int
,	O
int	O
fhsend	int
,	O
int	O
num_processes	int
,	O
int	O
sock	int
,	O
int	O
hsck	int
)	O
{	O
fd_set	struct(array(long))
set	struct(array(long))
;	O
parallelstatus	struct(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),*(struct(*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int,*`,int)),*(char),int,*(struct(int,*`)),int)),*(struct(*(struct(*`,*`,*`,int)),*(struct(*`,*`,*`,int)),*(struct(*`,*`,int,struct`,int)),int)),int,int,int,int,long)
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
;	O
child	struct
*	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
chldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
signalinfo	struct(int,int,int,int)
sci	struct(int,int,int,int)
;	O
int	O
spipe	int
,	O
max	int
,	O
status	int
;	O
int	O
buffsize	int
,	O
i	int
,	O
n	int
;	O
char	O
*	O
buff	*(char)
,	O
*	O
*	O
cmd	*(*(char))
,	O
*	O
line	*(char)
;	O
int	O
is_in_loop	int
,	O
ret	*(*(void))
;	O
linebuffer	struct(*(char),long)
lcmd	struct(*(char),long)
,	O
lhyp	struct(*(char),long)
;	O
client	struct
*	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"initialization num_processes=%d\n"	*(char)
,	O
num_processes	int
)	O
;	O
buffsize	int
=	O
getpagesize	()->(int)
(	O
)	O
;	O
buff	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
buffsize	int
)	O
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
sig_pipe	array(int)
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
spipe	int
=	O
sig_pipe	array(int)
[	O
0	int
]	O
;	O
chldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
sig_act_child	(int)->(void)
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
chldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
chldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
(	O
SA_NOCLDSTOP	int
|	O
SA_RESTART	int
)	O
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGCHLD	int
,	O
&	O
chldact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
NULL	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
achild	int
=	O
0	int
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
NULL	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
imutexlist	*(struct(*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(char),int,*(struct(int,*(void))),int))
=	O
NULL	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
dqueuelist	*(struct(*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int))
=	O
NULL	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
iqueue	int
=	O
0	int
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
sock	int
=	O
sock	int
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
hsck	int
=	O
hsck	int
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
lcmd	struct(*(char),long)
)	O
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
lhyp	struct(*(char),long)
)	O
;	O
is_in_loop	int
=	O
1	int
;	O
while	O
(	O
is_in_loop	int
)	O
{	O
FD_ZERO	O
(	O
&	O
set	struct(array(long))
)	O
;	O
FD_SET	O
(	O
spipe	int
,	O
&	O
set	struct(array(long))
)	O
;	O
max	int
=	O
spipe	int
;	O
FD_SET	O
(	O
fhrecv	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
fhrecv	int
)	O
max	int
=	O
fhrecv	int
;	O
for	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
!=	O
NULL	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
<	O
0	int
||	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
)	O
max	int
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
;	O
}	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
)	O
max	int
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
;	O
}	O
}	O
if	O
(	O
sock	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
sock	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
sock	int
)	O
max	int
=	O
sock	int
;	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
hsck	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
hsck	int
)	O
max	int
=	O
hsck	int
;	O
}	O
for	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
!=	O
NULL	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
FD_SET	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
)	O
max	int
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
;	O
}	O
i	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
max	int
+	O
1	int
,	O
&	O
set	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
FD_ISSET	O
(	O
spipe	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
if	O
(	O
!	O
(	O
read_signalinfo	(int,*(struct(int,int,int,int)))->(int)
(	O
spipe	int
,	O
&	O
sci	struct(int,int,int,int)
)	O
>	O
0	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: fatal error: read_signalinfo() failed.\n"	*(char)
)	O
,	O
progbasename	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
sci	struct(int,int,int,int)
.	O
exitsignal	int
<	O
0	int
)	O
{	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
get_child_by_pid	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))),int)->(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,*(struct(int,int,int,int,int,int,struct`)),int,struct(*(char),long),int,struct(*(char),long))))
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
sci	struct(int,int,int,int)
.	O
pid	int
)	O
;	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
>=	O
0	int
)	O
{	O
while	O
(	O
fd_avail	(int)->(int)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
)	O
)	O
{	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
daemon_send_output	(int,int,*(char),int)->(int)
(	O
fhsend	int
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
,	O
buff	*(char)
,	O
n	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
break	O
;	O
}	O
close	*((*(void))->(int))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
>=	O
0	int
)	O
{	O
while	O
(	O
fd_avail	(int)->(int)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
)	O
)	O
{	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
daemon_send_error	(int,int,*(char),int)->(int)
(	O
fhsend	int
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
,	O
buff	*(char)
,	O
n	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
break	O
;	O
}	O
close	*((*(void))->(int))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
=	O
-	O
1	int
;	O
}	O
}	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"finish %d signal=%d status=%d\n"	*(char)
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
,	O
sci	struct(int,int,int,int)
.	O
exitsignal	int
,	O
sci	struct(int,int,int,int)
.	O
exitstatus	int
)	O
;	O
list_remove	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
free	(*(void))->(void)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
achild	int
--	O
;	O
continue	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
fhrecv	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
fhrecv	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
is_in_loop	int
=	O
0	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
linebuffer_concatenate	(*(struct(*(char),long)),*(char),long)->(int)
(	O
&	O
lcmd	struct(*(char),long)
,	O
buff	*(char)
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	*(char)
=	O
linebuffer_fetch	(*(struct(*(char),long)))->(*(char))
(	O
&	O
lcmd	struct(*(char),long)
)	O
)	O
!=	O
NULL	O
)	O
{	O
cmd	*(*(char))
=	O
tokenize_spaces_dyn	(*(char))->(*(*(char)))
(	O
line	*(char)
)	O
;	O
if	O
(	O
cmd	*(*(char))
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
cmd	*(*(char))
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
daemon_commandtoken_unescape	(*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
)	O
;	O
ret	*(*(void))
=	O
daemon_process_command	(*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),int,*(*(char)))->(int)
(	O
&	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
fhsend	int
,	O
cmd	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
cmd	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
if	O
(	O
ret	*(*(void))
>	O
0	int
)	O
{	O
is_in_loop	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
else	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
}	O
continue	O
;	O
}	O
for	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
!=	O
NULL	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
<	O
0	int
||	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
daemon_send_output	(int,int,*(char),int)->(int)
(	O
fhsend	int
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
,	O
buff	*(char)
,	O
n	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstdout	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
daemon_send_error	(int,int,*(char),int)->(int)
(	O
fhsend	int
,	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
id	int
,	O
buff	*(char)
,	O
n	int
)	O
;	O
else	O
if	O
(	O
!	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
)	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
fdstderr	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
for	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
!=	O
NULL	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
char	O
*	O
line	*(char)
;	O
int	O
closepeer	int
;	O
if	O
(	O
!	O
FD_ISSET	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
&	O
set	struct(array(long))
)	O
)	O
continue	O
;	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
)	O
;	O
linebuffer_free	(*(struct(*(char),long)))->(int)
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
)	O
;	O
list_remove	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
,	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
free	(*(void))->(void)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
n	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
linebuffer_concatenate	(*(struct(*(char),long)),*(char),long)->(int)
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
,	O
buff	*(char)
,	O
n	int
)	O
;	O
closepeer	int
=	O
0	int
;	O
while	O
(	O
(	O
line	*(char)
=	O
linebuffer_fetch	(*(struct(*(char),long)))->(*(char))
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
)	O
)	O
!=	O
NULL	O
)	O
{	O
closepeer	int
=	O
remote_client_daemon_parse_command	(*(char),*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),*(struct(*(struct(*`,*`,int,int,*`,int,struct`,int,struct`)),int,int,int,*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,*`,int,*`,int)),*(struct(*`,*`,*`,int)),int,int,int,int,long)),int)->(int)
(	O
line	*(char)
,	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
,	O
&	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
,	O
fhsend	int
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
if	O
(	O
closepeer	int
)	O
break	O
;	O
}	O
;	O
if	O
(	O
closepeer	int
)	O
{	O
close	*((*(void))->(int))
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
)	O
;	O
linebuffer_free	(*(struct(*(char),long)))->(int)
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
)	O
;	O
list_remove	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
,	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
free	(*(void))->(void)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
hsck	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
hsck	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
linebuffer_concatenate	(*(struct(*(char),long)),*(char),long)->(int)
(	O
&	O
lhyp	struct(*(char),long)
,	O
buff	*(char)
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	*(char)
=	O
linebuffer_fetch	(*(struct(*(char),long)))->(*(char))
(	O
&	O
lhyp	struct(*(char),long)
)	O
)	O
!=	O
NULL	O
)	O
{	O
cmd	*(*(char))
=	O
tokenize_spaces_dyn	(*(char))->(*(*(char)))
(	O
line	*(char)
)	O
;	O
if	O
(	O
cmd	*(*(char))
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"acknowledged"	*(char)
)	O
==	O
0	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
fhsend	int
,	O
"acknowledged\n"	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
cmd	*(*(char))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
sock	int
>=	O
0	int
&&	O
FD_ISSET	O
(	O
sock	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
list_new	O
(	O
client	struct
)	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
=	O
accept	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
sock	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
)	O
;	O
list_insert_first	O
(	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
,	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
status	int
=	O
0	int
;	O
}	O
}	O
linebuffer_free	(*(struct(*(char),long)))->(int)
(	O
&	O
lcmd	struct(*(char),long)
)	O
;	O
free	(*(void))->(void)
(	O
buff	*(char)
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
close	*((*(void))->(int))
(	O
sig_pipe	array(int)
[	O
0	int
]	O
)	O
;	O
sig_pipe	array(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
close	*((*(void))->(int))
(	O
sig_pipe	array(int)
[	O
1	int
]	O
)	O
;	O
sig_pipe	array(int)
[	O
1	int
]	O
=	O
-	O
1	int
;	O
for	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
!=	O
NULL	O
;	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
if	O
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
kill	(int,int)->(int)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
,	O
SIGKILL	int
)	O
;	O
waitpid	(int,*(int),int)->(int)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
->	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
free	(*(void))->(void)
(	O
cc	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
;	O
}	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
childlist	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
=	O
NULL	O
;	O
ps	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,int,*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),*(char),int,*(struct`),int)),*(struct(*(struct`),*(struct`),*(struct`),int)),int,int,int,int,long))
.	O
achild	int
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
parse_host_data	(*(char),*(*(struct(*(char),int))),*(int))->(int)
(	O
char	O
*	O
arg	*(char)
,	O
remotehost	struct(*(char),int)
*	O
*	O
rrhosts	*(*(struct(*(char),int)))
,	O
int	O
*	O
rnrhost	*(int)
)	O
{	O
char	O
*	O
hostlist	*(char)
,	O
*	O
*	O
hosts	*(*(char))
,	O
*	O
eoc	*(char)
;	O
int	O
j	int
,	O
n	int
,	O
r	int
;	O
remotehost	struct(*(char),int)
*	O
rhosts	*(struct(*(char),int))
;	O
int	O
nrhost	int
;	O
if	O
(	O
arg	*(char)
==	O
NULL	O
||	O
*	O
arg	*(char)
==	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
hostlist	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
arg	*(char)
)	O
;	O
hosts	*(*(char))
=	O
tokenize_char_dyn	(*(char),int)->(*(*(char)))
(	O
hostlist	*(char)
,	O
','	O
)	O
;	O
rhosts	*(struct(*(char),int))
=	O
NULL	O
;	O
nrhost	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
hosts	*(*(char))
!=	O
NULL	O
&&	O
hosts	*(*(char))
[	O
j	int
]	O
!=	O
NULL	O
;	O
j	int
++	O
)	O
{	O
eoc	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
hosts	*(*(char))
[	O
j	int
]	O
,	O
':'	O
)	O
;	O
rhosts	*(struct(*(char),int))
=	O
(	O
remotehost	struct(*(char),int)
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
rhosts	*(struct(*(char),int))
,	O
sizeof	O
(	O
remotehost	struct(*(char),int)
)	O
*	O
(	O
nrhost	int
+	O
1	int
)	O
)	O
;	O
if	O
(	O
eoc	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
hosts	*(*(char))
[	O
j	int
]	O
,	O
PEXEC_ISTR_AUTO	*(char)
)	O
==	O
0	int
)	O
{	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
hostspec	*(char)
=	O
NULL	O
;	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
PEXEC_MNP_AUTO	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
hosts	*(*(char))
[	O
j	int
]	O
,	O
PEXEC_ISTR_MANAGED	*(char)
)	O
==	O
0	int
)	O
{	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
hostspec	*(char)
=	O
NULL	O
;	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
PEXEC_MNP_MANAGED	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
hosts	*(*(char))
[	O
j	int
]	O
,	O
PEXEC_ISTR_NCPU	*(char)
)	O
==	O
0	int
)	O
{	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
hostspec	*(char)
=	O
NULL	O
;	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
PEXEC_MNP_NCPU	O
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
hosts	*(*(char))
[	O
j	int
]	O
,	O
"%d"	*(char)
,	O
&	O
n	int
)	O
==	O
1	int
&&	O
n	int
>	O
0	int
)	O
{	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
hostspec	*(char)
=	O
NULL	O
;	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
n	int
;	O
}	O
else	O
{	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
hostspec	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
hosts	*(*(char))
[	O
j	int
]	O
)	O
;	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
PEXEC_MNP_AUTO	O
;	O
}	O
}	O
else	O
if	O
(	O
eoc	*(char)
==	O
hosts	*(*(char))
[	O
j	int
]	O
)	O
{	O
free	(*(void))->(void)
(	O
rhosts	*(struct(*(char),int))
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
*	O
eoc	*(char)
=	O
0	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
eoc	*(char)
+	O
1	int
,	O
PEXEC_ISTR_AUTO	*(char)
)	O
==	O
0	int
)	O
n	int
=	O
PEXEC_MNP_AUTO	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
eoc	*(char)
+	O
1	int
,	O
PEXEC_ISTR_MANAGED	*(char)
)	O
==	O
0	int
)	O
n	int
=	O
PEXEC_MNP_MANAGED	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
eoc	*(char)
+	O
1	int
,	O
PEXEC_ISTR_NCPU	*(char)
)	O
==	O
0	int
)	O
n	int
=	O
PEXEC_MNP_NCPU	O
;	O
else	O
if	O
(	O
(	O
r	int
=	O
sscanf	(*(char),*(char))->(int)
(	O
eoc	*(char)
+	O
1	int
,	O
"%d"	*(char)
,	O
&	O
n	int
)	O
)	O
==	O
0	int
||	O
(	O
r	int
==	O
1	int
&&	O
n	int
<=	O
0	int
)	O
)	O
{	O
free	(*(void))->(void)
(	O
rhosts	*(struct(*(char),int))
)	O
;	O
free	(*(void))->(void)
(	O
hostlist	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
hostspec	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
hosts	*(*(char))
[	O
j	int
]	O
)	O
;	O
rhosts	*(struct(*(char),int))
[	O
nrhost	int
]	O
.	O
num_processes	int
=	O
n	int
;	O
}	O
nrhost	int
++	O
;	O
}	O
free	(*(void))->(void)
(	O
hosts	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
hostlist	*(char)
)	O
;	O
*	O
rrhosts	*(*(struct(*(char),int)))
=	O
rhosts	*(struct(*(char),int))
;	O
*	O
rnrhost	*(int)
=	O
nrhost	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_shell_init	(*(char),*(*(char)),*(char),*(char),int,*(struct(*(char),int)),*(struct(int,int,int,int,int,int,struct(*(char),long))),int)->(int)
(	O
char	O
*	O
rsh	*(char)
,	O
char	O
*	O
*	O
rshargs	*(*(char))
,	O
char	O
*	O
pexec_self	*(char)
,	O
char	O
*	O
ctrlport	*(char)
,	O
int	O
timeout	int
,	O
remotehost	struct(*(char),int)
*	O
rh	*(struct(*(char),int))
,	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
int	O
prio	int
)	O
{	O
int	O
pipesend	array(int)
[	O
2	int
]	O
,	O
piperecv	array(int)
[	O
2	int
]	O
;	O
int	O
pid	int
;	O
if	O
(	O
rh	*(struct(*(char),int))
->	O
hostspec	*(char)
==	O
NULL	O
)	O
{	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
pid	int
=	O
-	O
1	int
;	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
=	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhrecv	int
=	O
-	O
1	int
;	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
num_processes	int
=	O
rh	*(struct(*(char),int))
->	O
num_processes	int
;	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
achild	int
=	O
0	int
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
lrsh	struct(*(char),long)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
pipe	(array(int))->(int)
(	O
pipesend	array(int)
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
piperecv	array(int)
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
return	O
(	O
-	O
2	int
)	O
;	O
else	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
char	O
*	O
line	*(char)
,	O
*	O
*	O
tokens	*(*(char))
;	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
pid	int
=	O
pid	int
;	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
=	O
pipesend	array(int)
[	O
1	int
]	O
;	O
close	*((*(void))->(int))
(	O
pipesend	array(int)
[	O
0	int
]	O
)	O
;	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhrecv	int
=	O
piperecv	array(int)
[	O
0	int
]	O
;	O
close	*((*(void))->(int))
(	O
piperecv	array(int)
[	O
1	int
]	O
)	O
;	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
achild	int
=	O
0	int
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
lrsh	struct(*(char),long)
)	O
;	O
line	*(char)
=	O
linebuffer_read_line	(int,*(struct(*(char),long)),int)->(*(char))
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhrecv	int
,	O
&	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
lrsh	struct(*(char),long)
,	O
timeout	int
)	O
;	O
if	O
(	O
line	*(char)
==	O
NULL	O
)	O
return	O
(	O
-	O
3	int
)	O
;	O
tokens	*(*(char))
=	O
tokenize_spaces_dyn	(*(char))->(*(*(char)))
(	O
line	*(char)
)	O
;	O
if	O
(	O
tokens	*(*(char))
!=	O
NULL	O
&&	O
tokens	*(*(char))
[	O
0	int
]	O
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
tokens	*(*(char))
[	O
0	int
]	O
,	O
"initialization"	*(char)
)	O
==	O
0	int
&&	O
tokens	*(*(char))
[	O
1	int
]	O
!=	O
NULL	O
&&	O
sscanf	(*(char),*(char))->(int)
(	O
tokens	*(*(char))
[	O
1	int
]	O
,	O
"num_processes=%d"	*(char)
,	O
&	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
num_processes	int
)	O
==	O
1	int
&&	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
num_processes	int
>=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
tokens	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tokens	*(*(char))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
tokens	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
return	O
(	O
-	O
4	int
)	O
;	O
}	O
}	O
else	O
{	O
int	O
i	int
,	O
n	int
;	O
char	O
*	O
*	O
argv	*(*(char))
,	O
num_buff	array(char)
[	O
32	int
]	O
,	O
pri_buff	array(char)
[	O
32	int
]	O
;	O
close	*((*(void))->(int))
(	O
pipesend	array(int)
[	O
1	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
piperecv	array(int)
[	O
0	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
0	int
)	O
;	O
dup2	(int,int)->(int)
(	O
pipesend	array(int)
[	O
0	int
]	O
,	O
0	int
)	O
;	O
close	*((*(void))->(int))
(	O
pipesend	array(int)
[	O
0	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
1	int
)	O
;	O
dup2	(int,int)->(int)
(	O
piperecv	array(int)
[	O
1	int
]	O
,	O
1	int
)	O
;	O
close	*((*(void))->(int))
(	O
piperecv	array(int)
[	O
1	int
]	O
)	O
;	O
close	*((*(void))->(int))
(	O
2	int
)	O
;	O
dup2	(int,int)->(int)
(	O
1	int
,	O
2	int
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
rshargs	*(*(char))
[	O
n	int
]	O
!=	O
NULL	O
;	O
)	O
n	int
++	O
;	O
argv	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
n	int
+	O
32	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
)	O
{	O
argv	*(*(char))
[	O
i	int
]	O
=	O
rshargs	*(*(char))
[	O
i	int
]	O
;	O
i	int
++	O
;	O
}	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
rh	*(struct(*(char),int))
->	O
hostspec	*(char)
;	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
pexec_self	*(char)
;	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
"--tunnel"	*(char)
;	O
if	O
(	O
rh	*(struct(*(char),int))
->	O
num_processes	int
>	O
0	int
)	O
{	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
"--number"	*(char)
;	O
sprintf	(*(char),*(char))->(int)
(	O
num_buff	array(char)
,	O
"%d"	*(char)
,	O
rh	*(struct(*(char),int))
->	O
num_processes	int
)	O
;	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
num_buff	array(char)
;	O
}	O
else	O
if	O
(	O
rh	*(struct(*(char),int))
->	O
num_processes	int
==	O
PEXEC_MNP_AUTO	O
)	O
{	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
"--number"	*(char)
;	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
PEXEC_ISTR_AUTO	*(char)
;	O
}	O
else	O
if	O
(	O
rh	*(struct(*(char),int))
->	O
num_processes	int
==	O
PEXEC_MNP_MANAGED	O
)	O
{	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
"--number"	*(char)
;	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
PEXEC_ISTR_MANAGED	*(char)
;	O
}	O
else	O
if	O
(	O
rh	*(struct(*(char),int))
->	O
num_processes	int
==	O
PEXEC_MNP_NCPU	O
)	O
{	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
"--number"	*(char)
;	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
PEXEC_ISTR_NCPU	*(char)
;	O
}	O
if	O
(	O
prio	int
>	O
0	int
)	O
{	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
"--nice"	*(char)
;	O
sprintf	(*(char),*(char))->(int)
(	O
pri_buff	array(char)
,	O
"%d"	*(char)
,	O
prio	int
-	O
128	int
)	O
;	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
pri_buff	array(char)
;	O
}	O
if	O
(	O
ctrlport	*(char)
!=	O
NULL	O
)	O
{	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
"--bind"	*(char)
;	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
ctrlport	*(char)
;	O
}	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
NULL	O
;	O
execvp	(*(char),array(*(char)))->(int)
(	O
rsh	*(char)
,	O
argv	*(*(char))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"initialization execution=failed\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
is_unix_socket_name	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
name	*(char)
,	O
'/'	O
)	O
!=	O
NULL	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
is_inet_socket_name	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
port	int
;	O
char	O
*	O
colon	*(char)
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"%d"	*(char)
,	O
&	O
port	int
)	O
==	O
1	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"*:%d"	*(char)
,	O
&	O
port	int
)	O
==	O
1	int
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
(	O
colon	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
name	*(char)
,	O
':'	O
)	O
)	O
!=	O
NULL	O
&&	O
sscanf	(*(char),*(char))->(int)
(	O
colon	*(char)
+	O
1	int
,	O
"%d"	*(char)
,	O
&	O
port	int
)	O
==	O
1	int
)	O
return	O
(	O
2	int
)	O
;	O
else	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_control_port_bind	(*(char),*(*(char)),int,int)->(int)
(	O
char	O
*	O
ctrlport	*(char)
,	O
char	O
*	O
*	O
rctrlport	*(*(char))
,	O
int	O
allow_auto	int
,	O
int	O
fail_on_existing	int
)	O
{	O
int	O
sock	int
,	O
port	int
,	O
ret	*(*(void))
,	O
pid	int
;	O
char	O
buff	*(char)
[	O
256	int
]	O
,	O
*	O
colon	*(char)
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
if	O
(	O
ctrlport	*(char)
==	O
NULL	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
allow_auto	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
ctrlport	*(char)
,	O
"inet"	*(char)
)	O
==	O
0	int
)	O
{	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
inaddr	struct(short,short,struct(int),array(char))
;	O
sock	int
=	O
socket	(int,int,int)->(int)
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
for	O
(	O
port	int
=	O
11228	int
,	O
ret	*(*(void))
=	O
-	O
1	int
;	O
port	int
<	O
16384	int
;	O
port	int
++	O
)	O
{	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_family	short
=	O
AF_INET	O
;	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_port	short
=	O
htons	(short)->(short)
(	O
port	int
)	O
;	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
ret	*(*(void))
=	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
(	O
&	O
inaddr	struct(short,short,struct(int),array(char))
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
inaddr	struct(short,short,struct(int),array(char))
)	O
)	O
)	O
;	O
if	O
(	O
!	O
ret	*(*(void))
)	O
break	O
;	O
}	O
if	O
(	O
ret	*(*(void))
<	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
buff	*(char)
,	O
"%d"	*(char)
,	O
port	int
)	O
;	O
if	O
(	O
rctrlport	*(*(char))
!=	O
NULL	O
)	O
*	O
rctrlport	*(*(char))
=	O
xstrdup	(*(char))->(*(char))
(	O
buff	*(char)
)	O
;	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
ctrlport	*(char)
,	O
"%d"	*(char)
,	O
&	O
port	int
)	O
==	O
1	int
||	O
sscanf	(*(char),*(char))->(int)
(	O
ctrlport	*(char)
,	O
"*:%d"	*(char)
,	O
&	O
port	int
)	O
==	O
1	int
)	O
{	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
inaddr	struct(short,short,struct(int),array(char))
;	O
sock	int
=	O
socket	(int,int,int)->(int)
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_family	short
=	O
AF_INET	O
;	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_port	short
=	O
htons	(short)->(short)
(	O
port	int
)	O
;	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
ret	*(*(void))
=	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
(	O
&	O
inaddr	struct(short,short,struct(int),array(char))
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
inaddr	struct(short,short,struct(int),array(char))
)	O
)	O
)	O
;	O
if	O
(	O
ret	*(*(void))
<	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
buff	*(char)
,	O
"%d"	*(char)
,	O
port	int
)	O
;	O
if	O
(	O
rctrlport	*(*(char))
!=	O
NULL	O
)	O
*	O
rctrlport	*(*(char))
=	O
xstrdup	(*(char))->(*(char))
(	O
buff	*(char)
)	O
;	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
colon	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
ctrlport	*(char)
,	O
':'	O
)	O
)	O
!=	O
NULL	O
&&	O
sscanf	(*(char),*(char))->(int)
(	O
colon	*(char)
+	O
1	int
,	O
"%d"	*(char)
,	O
&	O
port	int
)	O
==	O
1	int
)	O
{	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
inaddr	struct(short,short,struct(int),array(char))
;	O
char	O
*	O
hostname	*(char)
;	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
peer	int
;	O
hostname	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
(	O
size_t	long
)	O
(	O
colon	*(char)
-	O
ctrlport	*(char)
)	O
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hostname	*(char)
,	O
ctrlport	*(char)
,	O
(	O
colon	*(char)
-	O
ctrlport	*(char)
)	O
)	O
;	O
hostname	*(char)
[	O
(	O
colon	*(char)
-	O
ctrlport	*(char)
)	O
]	O
=	O
0	int
;	O
peer	int
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
hostname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
hostname	*(char)
)	O
;	O
if	O
(	O
peer	int
==	O
NULL	O
||	O
peer	int
->	O
h_addrtype	int
!=	O
AF_INET	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
sock	int
=	O
socket	(int,int,int)->(int)
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_family	short
=	O
AF_INET	O
;	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_port	short
=	O
htons	(short)->(short)
(	O
port	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
.	O
s_addr	int
,	O
peer	int
->	O
h_addr	O
,	O
peer	int
->	O
h_length	int
)	O
;	O
ret	*(*(void))
=	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
(	O
&	O
inaddr	struct(short,short,struct(int),array(char))
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
inaddr	struct(short,short,struct(int),array(char))
)	O
)	O
)	O
;	O
if	O
(	O
ret	*(*(void))
<	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
rctrlport	*(*(char))
!=	O
NULL	O
)	O
*	O
rctrlport	*(*(char))
=	O
xstrdup	(*(char))->(*(char))
(	O
ctrlport	*(char)
)	O
;	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
if	O
(	O
allow_auto	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
ctrlport	*(char)
,	O
"unix"	*(char)
)	O
==	O
0	int
)	O
{	O
struct	O
sockaddr_un	struct(short,array(char))
unaddr	struct(short,array(char))
;	O
sock	int
=	O
socket	(int,int,int)->(int)
(	O
PF_UNIX	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
unaddr	struct(short,array(char))
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
pid	int
=	O
(	O
int	O
)	O
getpid	()->(int)
(	O
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
,	O
"/tmp/pexec.%d.sock"	*(char)
,	O
pid	int
)	O
;	O
if	O
(	O
!	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
&&	O
S_ISSOCK	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
unlink	(*(char))->(int)
(	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
)	O
;	O
ret	*(*(void))
=	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
(	O
&	O
unaddr	struct(short,array(char))
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
unaddr	struct(short,array(char))
)	O
)	O
)	O
;	O
if	O
(	O
ret	*(*(void))
<	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
rctrlport	*(*(char))
!=	O
NULL	O
)	O
*	O
rctrlport	*(*(char))
=	O
xstrdup	(*(char))->(*(char))
(	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
)	O
;	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
if	O
(	O
is_unix_socket_name	(*(char))->(int)
(	O
ctrlport	*(char)
)	O
)	O
{	O
struct	O
sockaddr_un	struct(short,array(char))
unaddr	struct(short,array(char))
;	O
sock	int
=	O
socket	(int,int,int)->(int)
(	O
PF_UNIX	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
unaddr	struct(short,array(char))
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
,	O
ctrlport	*(char)
,	O
UNIX_PATH_MAX	int
-	O
1	int
)	O
;	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
[	O
UNIX_PATH_MAX	int
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
fail_on_existing	int
&&	O
(	O
!	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
!	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
,	O
&	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
&&	O
S_ISSOCK	O
(	O
st	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
unlink	(*(char))->(int)
(	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
)	O
;	O
ret	*(*(void))
=	O
bind	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
(	O
&	O
unaddr	struct(short,array(char))
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
unaddr	struct(short,array(char))
)	O
)	O
)	O
;	O
if	O
(	O
ret	*(*(void))
<	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
rctrlport	*(*(char))
!=	O
NULL	O
)	O
*	O
rctrlport	*(*(char))
=	O
xstrdup	(*(char))->(*(char))
(	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
)	O
;	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
int	O
bind_variable_export	(*(char),*(char))->(int)
(	O
char	O
*	O
envvar	*(char)
,	O
char	O
*	O
ctrlport	*(char)
)	O
{	O
if	O
(	O
ctrlport	*(char)
==	O
NULL	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
env_export	(*(char),*(char))->(int)
(	O
envvar	*(char)
,	O
ctrlport	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_control_port_connect	(*(char))->(int)
(	O
char	O
*	O
ctrlport	*(char)
)	O
{	O
int	O
sock	int
,	O
port	int
,	O
ret	*(*(void))
;	O
struct	O
sockaddr_in	struct(short,short,struct(int),array(char))
inaddr	struct(short,short,struct(int),array(char))
;	O
struct	O
sockaddr_un	struct(short,array(char))
unaddr	struct(short,array(char))
;	O
char	O
*	O
sc	*(char)
;	O
if	O
(	O
ctrlport	*(char)
==	O
NULL	O
||	O
(	O
!	O
ctrlport	*(char)
[	O
0	int
]	O
)	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
is_unix_socket_name	(*(char))->(int)
(	O
ctrlport	*(char)
)	O
)	O
{	O
if	O
(	O
(	O
sock	int
=	O
socket	(int,int,int)->(int)
(	O
PF_UNIX	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
unaddr	struct(short,array(char))
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
,	O
ctrlport	*(char)
,	O
UNIX_PATH_MAX	int
-	O
1	int
)	O
;	O
unaddr	struct(short,array(char))
.	O
sun_path	array(char)
[	O
UNIX_PATH_MAX	int
-	O
1	int
]	O
=	O
0	int
;	O
ret	*(*(void))
=	O
connect	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
(	O
&	O
unaddr	struct(short,array(char))
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
unaddr	struct(short,array(char))
)	O
)	O
)	O
;	O
if	O
(	O
ret	*(*(void))
<	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
return	O
(	O
sock	int
)	O
;	O
}	O
else	O
{	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_family	short
=	O
AF_INET	O
;	O
sc	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
ctrlport	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
sc	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
ctrlport	*(char)
,	O
"%d"	*(char)
,	O
&	O
port	int
)	O
<	O
1	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
.	O
s_addr	int
=	O
htonl	(int)->(int)
(	O
INADDR_LOOPBACK	O
)	O
;	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_port	short
=	O
htons	(short)->(short)
(	O
port	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
hostname	*(char)
;	O
int	O
len	int
;	O
struct	O
hostent	struct(*(char),*(*(char)),int,int,*(*(char)))
*	O
peer	int
;	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
sc	*(char)
+	O
1	int
,	O
"%d"	*(char)
,	O
&	O
port	int
)	O
<	O
1	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
len	int
=	O
(	O
int	O
)	O
(	O
sc	*(char)
-	O
ctrlport	*(char)
)	O
;	O
hostname	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
len	int
+	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
hostname	*(char)
,	O
ctrlport	*(char)
,	O
len	int
)	O
;	O
hostname	*(char)
[	O
len	int
]	O
=	O
0	int
;	O
peer	int
=	O
gethostbyname	(*(char))->(*(struct(*(char),*(*(char)),int,int,*(*(char)))))
(	O
hostname	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
hostname	*(char)
)	O
;	O
if	O
(	O
peer	int
==	O
NULL	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_addr	struct(int)
.	O
s_addr	int
,	O
peer	int
->	O
h_addr	O
,	O
peer	int
->	O
h_length	int
)	O
;	O
inaddr	struct(short,short,struct(int),array(char))
.	O
sin_port	short
=	O
htons	(short)->(short)
(	O
port	int
)	O
;	O
}	O
if	O
(	O
(	O
sock	int
=	O
socket	(int,int,int)->(int)
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
ret	*(*(void))
=	O
connect	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),int)->(int)
(	O
sock	int
,	O
(	O
struct	O
sockaddr	struct(short,array(char))
*	O
)	O
(	O
&	O
inaddr	struct(short,short,struct(int),array(char))
)	O
,	O
(	O
socklen_t	int
)	O
(	O
sizeof	O
(	O
inaddr	struct(short,short,struct(int),array(char))
)	O
)	O
)	O
;	O
if	O
(	O
ret	*(*(void))
<	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
return	O
(	O
sock	int
)	O
;	O
}	O
}	O
int	O
remote_status	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
int	O
sock	int
,	O
FILE	struct
*	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
linebuffer	struct(*(char),long)
lrcv	struct(*(char),long)
;	O
char	O
*	O
line	*(char)
;	O
hprintf	(int,*(char))->(int)
(	O
sock	int
,	O
"status --all\n"	*(char)
)	O
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
lrcv	struct(*(char),long)
)	O
;	O
line	*(char)
=	O
linebuffer_read_line	(int,*(struct(*(char),long)),int)->(*(char))
(	O
sock	int
,	O
&	O
lrcv	struct(*(char),long)
,	O
0	int
)	O
;	O
if	O
(	O
line	*(char)
!=	O
NULL	O
)	O
{	O
remove_newlines_and_comments	(*(char))->(void)
(	O
line	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
line	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_lock	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
int	O
sock	int
,	O
FILE	struct
*	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
char	O
*	O
name	*(char)
)	O
{	O
linebuffer	struct(*(char),long)
lrcv	struct(*(char),long)
;	O
char	O
*	O
line	*(char)
;	O
hprintf	(int,*(char))->(int)
(	O
sock	int
,	O
"lock \"%s\"\n"	*(char)
,	O
name	*(char)
)	O
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
lrcv	struct(*(char),long)
)	O
;	O
line	*(char)
=	O
linebuffer_read_line	(int,*(struct(*(char),long)),int)->(*(char))
(	O
sock	int
,	O
&	O
lrcv	struct(*(char),long)
,	O
0	int
)	O
;	O
if	O
(	O
line	*(char)
!=	O
NULL	O
)	O
{	O
remove_newlines_and_comments	(*(char))->(void)
(	O
line	*(char)
)	O
;	O
if	O
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s\n"	*(char)
,	O
line	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_unlock	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
int	O
sock	int
,	O
FILE	struct
*	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
char	O
*	O
name	*(char)
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
sock	int
,	O
"unlock \"%s\"\n"	*(char)
,	O
name	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_copy	(int,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
int	O
sock	int
,	O
char	O
*	O
name	*(char)
,	O
FILE	struct
*	O
frin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
FILE	struct
*	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
char	O
*	O
buff	*(char)
;	O
int	O
blksize	int
,	O
r	int
,	O
fd	int
;	O
fd_set	struct(array(long))
set	struct(array(long))
;	O
FD_ZERO	O
(	O
&	O
set	struct(array(long))
)	O
;	O
fd	int
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
frin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
FD_SET	O
(	O
fd	int
,	O
&	O
set	struct(array(long))
)	O
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
fd	int
+	O
1	int
,	O
&	O
set	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
&&	O
name	*(char)
!=	O
NULL	O
)	O
remote_lock	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
sock	int
,	O
NULL	O
,	O
name	*(char)
)	O
;	O
blksize	int
=	O
getpagesize	()->(int)
(	O
)	O
;	O
buff	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
blksize	int
)	O
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
frin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
r	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buff	*(char)
,	O
1	int
,	O
blksize	int
,	O
frin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
r	int
<=	O
0	int
)	O
break	O
;	O
else	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
buff	*(char)
,	O
1	int
,	O
r	int
,	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
free	(*(void))->(void)
(	O
buff	*(char)
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
&&	O
name	*(char)
!=	O
NULL	O
)	O
remote_unlock	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
sock	int
,	O
NULL	O
,	O
name	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
remote_atomic_execute	(int,*(char),int,*(*(char)),int)->(int)
(	O
int	O
is_shell_commands	int
,	O
char	O
*	O
shell	*(char)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
sock	int
)	O
{	O
int	O
pid	int
,	O
status	int
;	O
pid	int
=	O
fork	()->(int)
(	O
)	O
;	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
waitpid	(int,*(int),int)->(int)
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
return	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
sock	int
>=	O
0	int
)	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
if	O
(	O
is_shell_commands	int
)	O
{	O
char	O
*	O
largv	array(*(char))
[	O
4	int
]	O
;	O
largv	array(*(char))
[	O
0	int
]	O
=	O
shell	*(char)
;	O
largv	array(*(char))
[	O
1	int
]	O
=	O
"-c"	*(char)
;	O
largv	array(*(char))
[	O
2	int
]	O
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
largv	array(*(char))
[	O
3	int
]	O
=	O
NULL	O
;	O
execv	(*(char),array(*(char)))->(int)
(	O
shell	*(char)
,	O
largv	array(*(char))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: unable to execute the script '%s'.\n"	*(char)
)	O
,	O
shell	*(char)
,	O
progbasename	*(char)
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
*	O
largv	array(*(char))
;	O
int	O
i	int
,	O
largc	int
;	O
largc	int
=	O
argc	int
;	O
largv	array(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
argc	int
+	O
1	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
largv	array(*(char))
[	O
i	int
]	O
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
largv	array(*(char))
[	O
argc	int
]	O
=	O
NULL	O
;	O
execvp	(*(char),array(*(char)))->(int)
(	O
largv	array(*(char))
[	O
0	int
]	O
,	O
largv	array(*(char))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: unable to execute the command '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
exit	(int)->(void)
(	O
2	int
)	O
;	O
}	O
}	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
int	O
remote_disconnect	(int)->(int)
(	O
int	O
sock	int
)	O
{	O
char	O
buff	*(char)
[	O
16	int
]	O
;	O
int	O
n	int
;	O
hprintf	(int,*(char))->(int)
(	O
sock	int
,	O
"exit\n"	*(char)
)	O
;	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
sock	int
,	O
buff	*(char)
,	O
16	int
)	O
;	O
return	O
(	O
n	int
)	O
;	O
}	O
int	O
pexec_hypervisor_check_load	(int)->(int)
(	O
int	O
loadtype	int
)	O
{	O
double	O
loadavg	array(double)
[	O
3	int
]	O
;	O
if	O
(	O
!	O
(	O
0	int
<=	O
loadtype	int
&&	O
loadtype	int
<	O
3	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
getloadavg	(array(double),int)->(int)
(	O
loadavg	array(double)
,	O
3	int
)	O
;	O
return	O
(	O
(	O
int	O
)	O
loadavg	array(double)
[	O
loadtype	int
]	O
)	O
;	O
}	O
int	O
pexec_hypervisor_request_cleanup	(*(struct(*(struct(*`,*`,int,struct`,int)),int,int,int,*(struct(*`)),int,int)),*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)))->(int)
(	O
hypervisorstatus	struct(*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)))),int,int)
*	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
,	O
client	struct
*	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
;	O
)	O
{	O
if	O
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
[	O
i	int
]	O
.	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
==	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
{	O
if	O
(	O
i	int
<	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
-	O
1	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
+	O
i	int
,	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
+	O
i	int
+	O
1	int
,	O
sizeof	O
(	O
request	struct
)	O
*	O
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
-	O
i	int
-	O
1	int
)	O
)	O
;	O
}	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
--	O
;	O
}	O
else	O
i	int
++	O
;	O
}	O
if	O
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
<=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
)	O
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
=	O
NULL	O
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
=	O
0	int
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
pexec_hypervisor_acknowledge_pending	(*(struct(*(struct(*`,*`,int,struct`,int)),int,int,int,*(struct(*`)),int,int)))->(int)
(	O
hypervisorstatus	struct(*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)))),int,int)
*	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
)	O
{	O
request	struct
*	O
rw	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
;	O
while	O
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
>	O
0	int
&&	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrunning	int
<	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
num_processes	int
&&	O
pexec_hypervisor_check_load	(int)->(int)
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
use_load	int
)	O
<	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
num_processes	int
)	O
{	O
if	O
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
use_fifo	int
)	O
rw	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
=	O
&	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
[	O
0	int
]	O
;	O
else	O
rw	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
=	O
&	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
[	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
-	O
1	int
]	O
;	O
hprintf	(int,*(char))->(int)
(	O
rw	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
->	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"acknowledged\n"	*(char)
)	O
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrunning	int
++	O
;	O
rw	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
->	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
status	int
++	O
;	O
if	O
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
>	O
1	int
&&	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
use_fifo	int
)	O
{	O
memmove	(*(void),*(void),long)->(*(void))
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
,	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
+	O
1	int
,	O
sizeof	O
(	O
request	struct
)	O
*	O
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
-	O
1	int
)	O
)	O
;	O
}	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
--	O
;	O
if	O
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
<=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
)	O
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
=	O
NULL	O
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
=	O
0	int
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
pexec_hypervisor_client_parse_command	(*(char),*(struct(*(struct(*`,*`,int,struct`,int)),int,int,int,*(struct(*`)),int,int)),*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)))->(int)
(	O
char	O
*	O
line	*(char)
,	O
hypervisorstatus	struct(*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)))),int,int)
*	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
,	O
client	struct
*	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
{	O
char	O
*	O
*	O
cmd	*(*(char))
;	O
request	struct
*	O
rw	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
;	O
int	O
ret	*(*(void))
;	O
cmd	*(*(char))
=	O
tokenize_spaces_dyn	(*(char))->(*(*(char)))
(	O
line	*(char)
)	O
;	O
if	O
(	O
cmd	*(*(char))
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
cmd	*(*(char))
[	O
0	int
]	O
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
cmd	*(*(char))
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"request"	*(char)
)	O
==	O
0	int
)	O
{	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
=	O
(	O
request	struct
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
,	O
sizeof	O
(	O
request	struct
)	O
*	O
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
+	O
1	int
)	O
)	O
;	O
rw	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
=	O
&	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
[	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
]	O
;	O
rw	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
->	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
++	O
;	O
pexec_hypervisor_acknowledge_pending	(*(struct(*(struct(*`,*`,int,struct`,int)),int,int,int,*(struct(*`)),int,int)))->(int)
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
)	O
;	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"ready"	*(char)
)	O
==	O
0	int
)	O
{	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrunning	int
--	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
status	int
--	O
;	O
pexec_hypervisor_acknowledge_pending	(*(struct(*(struct(*`,*`,int,struct`,int)),int,int,int,*(struct(*`)),int,int)))->(int)
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
)	O
;	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"completed"	*(char)
)	O
==	O
0	int
)	O
{	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"status"	*(char)
)	O
==	O
0	int
)	O
{	O
double	O
loadavg	array(double)
[	O
3	int
]	O
;	O
getloadavg	(array(double),int)->(int)
(	O
loadavg	array(double)
,	O
3	int
)	O
;	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"status num_processes=%d use_load=%d use_fifo=%d nrunning=%d nrequest=%d load=%.2f,%.2f,%.2f\n"	*(char)
,	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
num_processes	int
,	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
use_load	int
,	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
use_fifo	int
,	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrunning	int
,	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
nrequest	int
,	O
loadavg	array(double)
[	O
0	int
]	O
,	O
loadavg	array(double)
[	O
1	int
]	O
,	O
loadavg	array(double)
[	O
2	int
]	O
)	O
;	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"set"	*(char)
)	O
==	O
0	int
)	O
{	O
int	O
i	int
,	O
w	int
;	O
char	O
*	O
invvar	*(char)
;	O
invvar	*(char)
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
cmd	*(*(char))
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"num_processes=%d"	*(char)
,	O
&	O
w	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
w	int
<	O
0	int
)	O
w	int
=	O
0	int
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
num_processes	int
=	O
w	int
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"use_load=%d"	*(char)
,	O
&	O
w	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
w	int
<	O
0	int
)	O
w	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
w	int
>	O
2	int
)	O
w	int
=	O
2	int
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
use_load	int
=	O
w	int
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
i	int
]	O
,	O
"use_fifo=%d"	*(char)
,	O
&	O
w	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
!	O
w	int
)	O
w	int
=	O
0	int
;	O
else	O
w	int
=	O
1	int
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
->	O
use_fifo	int
=	O
w	int
;	O
}	O
else	O
invvar	*(char)
=	O
cmd	*(*(char))
[	O
i	int
]	O
;	O
}	O
if	O
(	O
invvar	*(char)
!=	O
NULL	O
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"message \"invalid variable alternation '%s'\"\n"	*(char)
,	O
invvar	*(char)
)	O
;	O
}	O
ret	*(*(void))
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"close"	*(char)
)	O
==	O
0	int
)	O
ret	*(*(void))
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
cmd	*(*(char))
[	O
0	int
]	O
,	O
"terminate"	*(char)
)	O
==	O
0	int
)	O
ret	*(*(void))
=	O
-	O
1	int
;	O
else	O
{	O
hprintf	(int,*(char))->(int)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
"message \"invalid command '%s'\"\n"	*(char)
,	O
cmd	*(*(char))
[	O
0	int
]	O
)	O
;	O
ret	*(*(void))
=	O
0	int
;	O
}	O
free	(*(void))->(void)
(	O
cmd	*(*(char))
)	O
;	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
int	O
pexec_hypervisor_main_loop	(int,int,int,int)->(int)
(	O
int	O
sock	int
,	O
int	O
num_processes	int
,	O
int	O
use_load	int
,	O
int	O
use_fifo	int
)	O
{	O
client	struct
*	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
,	O
*	O
cnext	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
hypervisorstatus	struct(*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)),int,int,int,*(struct(*(struct(*`,*`,int,struct`,int)))),int,int)
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
;	O
fd_set	struct(array(long))
set	struct(array(long))
;	O
int	O
i	int
,	O
max	int
,	O
buffsize	int
,	O
n	int
;	O
char	O
*	O
buff	*(char)
;	O
int	O
is_in_loop	int
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
intact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
signalinfo	struct(int,int,int,int)
sci	struct(int,int,int,int)
;	O
int	O
spipe	int
;	O
struct	O
timeval	struct(long,long)
tv	struct(long,long)
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
NULL	O
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
num_processes	int
=	O
num_processes	int
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
use_load	int
=	O
use_load	int
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
use_fifo	int
=	O
use_fifo	int
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
requests	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int))))
=	O
NULL	O
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
nrequest	int
=	O
0	int
;	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
nrunning	int
=	O
0	int
;	O
buffsize	int
=	O
getpagesize	()->(int)
(	O
)	O
;	O
buff	*(char)
=	O
(	O
char	O
*	O
)	O
xmalloc	(long)->(*(void))
(	O
(	O
size_t	long
)	O
buffsize	int
)	O
;	O
is_in_loop	int
=	O
1	int
;	O
if	O
(	O
pipe	(array(int))->(int)
(	O
sig_pipe	array(int)
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
intact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
sig_act_interrupt	(int)->(void)
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
intact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
intact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
(	O
SA_NOCLDSTOP	int
|	O
SA_RESTART	int
)	O
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
SIGINT	int
,	O
&	O
intact	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
NULL	O
)	O
;	O
spipe	int
=	O
sig_pipe	array(int)
[	O
0	int
]	O
;	O
while	O
(	O
is_in_loop	int
)	O
{	O
FD_ZERO	O
(	O
&	O
set	struct(array(long))
)	O
;	O
FD_SET	O
(	O
sock	int
,	O
&	O
set	struct(array(long))
)	O
;	O
max	int
=	O
sock	int
;	O
for	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
!=	O
NULL	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
)	O
{	O
FD_SET	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
)	O
max	int
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
;	O
}	O
if	O
(	O
spipe	int
>=	O
0	int
)	O
{	O
FD_SET	O
(	O
spipe	int
,	O
&	O
set	struct(array(long))
)	O
;	O
if	O
(	O
max	int
<	O
spipe	int
)	O
max	int
=	O
spipe	int
;	O
}	O
if	O
(	O
use_load	int
>=	O
0	int
)	O
{	O
tv	struct(long,long)
.	O
tv_sec	long
=	O
PEXEC_LOAD_CHECK_PERIOD	int
;	O
tv	struct(long,long)
.	O
tv_usec	long
=	O
0	int
;	O
i	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
max	int
+	O
1	int
,	O
&	O
set	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tv	struct(long,long)
)	O
;	O
}	O
else	O
i	int
=	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
(	O
max	int
+	O
1	int
,	O
&	O
set	struct(array(long))
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
pexec_hypervisor_acknowledge_pending	(*(struct(*(struct(*`,*`,int,struct`,int)),int,int,int,*(struct(*`)),int,int)))->(int)
(	O
&	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
)	O
;	O
for	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
!=	O
NULL	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cnext	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
{	O
char	O
*	O
line	*(char)
;	O
int	O
closepeer	int
;	O
cnext	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),*(struct(*(struct`),*(struct`),int,int,*(struct`),int,struct(*`,long),int,struct(*`,long))),int,int,*(struct(int,int,int,int,int,int,struct(*`,long))),int,struct(*(char),long),int,struct(*(char),long)))
;	O
if	O
(	O
!	O
FD_ISSET	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
&	O
set	struct(array(long))
)	O
)	O
continue	O
;	O
n	int
=	O
read	*((*(void),*(char),long)->(long))
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
,	O
buff	*(char)
,	O
buffsize	int
)	O
;	O
if	O
(	O
n	int
<=	O
0	int
)	O
closepeer	int
=	O
1	int
;	O
else	O
closepeer	int
=	O
0	int
;	O
if	O
(	O
n	int
>	O
0	int
&&	O
(	O
!	O
closepeer	int
)	O
)	O
linebuffer_concatenate	(*(struct(*(char),long)),*(char),long)->(int)
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
,	O
buff	*(char)
,	O
n	int
)	O
;	O
while	O
(	O
(	O
line	*(char)
=	O
linebuffer_fetch	(*(struct(*(char),long)))->(*(char))
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
)	O
)	O
!=	O
NULL	O
&&	O
!	O
closepeer	int
)	O
{	O
closepeer	int
=	O
pexec_hypervisor_client_parse_command	(*(char),*(struct(*(struct(*`,*`,int,struct`,int)),int,int,int,*(struct(*`)),int,int)),*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)))->(int)
(	O
line	*(char)
,	O
&	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
,	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
if	O
(	O
closepeer	int
)	O
break	O
;	O
}	O
;	O
if	O
(	O
closepeer	int
)	O
{	O
close	*((*(void))->(int))
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
)	O
;	O
if	O
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
status	int
>	O
0	int
)	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
nrunning	int
-=	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
status	int
;	O
linebuffer_free	(*(struct(*(char),long)))->(int)
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
)	O
;	O
pexec_hypervisor_request_cleanup	(*(struct(*(struct(*`,*`,int,struct`,int)),int,int,int,*(struct(*`)),int,int)),*(struct(*(struct(*`,*`,int,struct`,int)),*(struct(*`,*`,int,struct`,int)),int,struct(*(char),long),int)))->(int)
(	O
&	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
,	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
list_remove	O
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
,	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
free	(*(void))->(void)
(	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
pexec_hypervisor_acknowledge_pending	(*(struct(*(struct(*`,*`,int,struct`,int)),int,int,int,*(struct(*`)),int,int)))->(int)
(	O
&	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
)	O
;	O
}	O
if	O
(	O
closepeer	int
<	O
0	int
)	O
is_in_loop	int
=	O
0	int
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
spipe	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
if	O
(	O
!	O
(	O
read_signalinfo	(int,*(struct(int,int,int,int)))->(int)
(	O
spipe	int
,	O
&	O
sci	struct(int,int,int,int)
)	O
>	O
0	int
)	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: fatal error: read_signalinfo() failed.\n"	*(char)
)	O
,	O
progbasename	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
sci	struct(int,int,int,int)
.	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
==	O
SIGINT	int
&&	O
sci	struct(int,int,int,int)
.	O
exitsignal	int
)	O
is_in_loop	int
=	O
0	int
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
sock	int
,	O
&	O
set	struct(array(long))
)	O
)	O
{	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
=	O
list_new	O
(	O
client	struct
)	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
peer	int
=	O
accept	(int,union(*(struct(short,array(char))),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct),*(struct)),*(int))->(int)
(	O
sock	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
linebuffer_reset	(*(struct(*(char),long)))->(int)
(	O
&	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
lcli	struct(*(char),long)
)	O
;	O
list_insert_first	O
(	O
hs	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,int,int,*(struct(*(struct`))),int,int))
.	O
clientlist	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
,	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
)	O
;	O
cl	*(struct(*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),*(struct(*(struct`),*(struct`),int,struct(*`,long),int)),int,struct(*(char),long),int))
->	O
status	int
=	O
0	int
;	O
}	O
}	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
SIG_DFL	O
)	O
;	O
close	*((*(void))->(int))
(	O
sig_pipe	array(int)
[	O
0	int
]	O
)	O
;	O
sig_pipe	array(int)
[	O
0	int
]	O
=	O
-	O
1	int
;	O
close	*((*(void))->(int))
(	O
sig_pipe	array(int)
[	O
1	int
]	O
)	O
;	O
sig_pipe	array(int)
[	O
1	int
]	O
=	O
-	O
1	int
;	O
free	(*(void))->(void)
(	O
buff	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
pexec_hypervisor_stop	(int)->(int)
(	O
int	O
sock	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
sock	int
,	O
"terminate\n"	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_parameters	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),int,struct(int,*(*`),int),int,int)),int)->(int)
(	O
FILE	struct
*	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
int	O
nparam	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"name='%s' is_shell=%d "	*(char)
,	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
name	*(char)
,	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"args:"	*(char)
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
;	O
j	int
++	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" '%s'"	*(char)
,	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argv	*(*(char))
[	O
j	int
]	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
longhelp_entry	struct(*(char),*(char))
pexec_long_help	array(struct(*(char),*(char)))
[	O
]	O
=	O
{	O
LONGHELP_OPTIONS	O
,	O
{	O
"General options:"	*(char)
,	O
NULL	O
}	O
,	O
{	O
"-h, --help"	*(char)
,	O
"Gives general summary about the command line options."	*(char)
}	O
,	O
{	O
"--long-help"	*(char)
,	O
"Gives a detailed list of command line options."	*(char)
}	O
,	O
{	O
"--version"	*(char)
,	O
"Gives some version information about the program."	*(char)
}	O
,	O
{	O
"-s, --shell <shell>"	*(char)
,	O
"Full path (e.g. /bin/sh) of the shell or interpreter to be used "	*(char)
"for script execution."	*(char)
}	O
,	O
{	O
"-c, --shell-command"	*(char)
,	O
"Use the specified shell to interpret the command(s) instead of "	*(char)
"direct execution."	*(char)
}	O
,	O
{	O
"-m, --multiple-command"	*(char)
,	O
"Allow multiple individual shell command scripts to be executed "	*(char)
"in parallel with the variation of the parameters."	*(char)
}	O
,	O
{	O
"-e, --environment <variable>"	*(char)
,	O
"Name of an environmental variable which is set to the respective "	*(char)
"parameter before each execution."	*(char)
}	O
,	O
{	O
"-n, --number <number>"	*(char)
,	O
"The maximal number of processes running simultaneously. The <number> "	*(char)
"itself can even be a complex specification of remote hosts (see "	*(char)
"documentation for more details)."	*(char)
}	O
,	O
{	O
"-C, --control <port>"	*(char)
,	O
"The control port of a hypervisor daemon (full path of a UNIX "	*(char)
"socket or an INET host specification)."	*(char)
}	O
,	O
{	O
"-p, --list <list>"	*(char)
,	O
"The single-argument form of main parameter list."	*(char)
}	O
,	O
{	O
"-r, --parameters <list>"	*(char)
,	O
"The multiple-argument form of the main parameter list."	*(char)
}	O
,	O
{	O
"-f, --listfile <file>"	*(char)
,	O
"The main parameter list file."	*(char)
}	O
,	O
{	O
"-w, --column <index>"	*(char)
,	O
"The column index from where the parameters should be taken if "	*(char)
"they are read from a parameter file."	*(char)
}	O
,	O
{	O
"-t, --complete"	*(char)
,	O
"Threat the whole line as a single parameter if the "	*(char)
"parameters are read from a file."	*(char)
}	O
,	O
{	O
"-z, --nice"	*(char)
,	O
"Sets the scheduling priority of pexec and all children "	*(char)
"(executed processes) to the priority defined by this nice value."	*(char)
}	O
,	O
{	O
"--"	*(char)
,	O
"A marker after which the command to execute begins."	*(char)
}	O
,	O
{	O
"Redirecting standard input, output and error:"	*(char)
,	O
NULL	O
}	O
,	O
{	O
"-i, --input <input>"	*(char)
,	O
"The (optionally formatted) name of the input file which is used "	*(char)
"for redirecting the standard input."	*(char)
}	O
,	O
{	O
"-o, --output <output>"	*(char)
,	O
"The (optionally formatted) name of the output "	*(char)
"file which is used for redirecting the standard output."	*(char)
}	O
,	O
{	O
"-u, --error <output>"	*(char)
,	O
"The (optionally formatted) name of the output "	*(char)
"error file, which is used for redirecting the standard error."	*(char)
}	O
,	O
{	O
"-R, --normal-redirection"	*(char)
,	O
"Equivalent to specifying --output -, --error - and --input /dev/null."	*(char)
}	O
,	O
{	O
"-a, --output-format <format>"	*(char)
,	O
"The format of the final standard output redirection if the output "	*(char)
"of all of the processes are gathered into the same file."	*(char)
}	O
,	O
{	O
"-b, --error-format <format>"	*(char)
,	O
"The same final redirection format for the standard error."	*(char)
}	O
,	O
{	O
"-x, --omit-newlines"	*(char)
,	O
"Disable automatic newlines after the output and error formats."	*(char)
}	O
,	O
{	O
"Execution using remote hosts:"	*(char)
,	O
NULL	O
}	O
,	O
{	O
"-g, --remote-shell <remote_shell>"	*(char)
,	O
"The name or full path of the remote shell to be used for building "	*(char)
"the tunnel between the local and the peer host(s). "	*(char)
"Default: ``/usr/bin/ssh''."	*(char)
}	O
,	O
{	O
"-P, --pexec <pexec>"	*(char)
,	O
"The full path of the pexec program on the remote hosts. "	*(char)
"If this option is omitted, pexec tries to figure out from the "	*(char)
"invoking syntax and/or the current path."	*(char)
}	O
,	O
{	O
"-T, --tunnel"	*(char)
,	O
"Internal use only (pexec will start in tunnel daemon mode)."	*(char)
}	O
,	O
{	O
"Remote control, mutual exclusions and atomic command execution:"	*(char)
,	O
NULL	O
}	O
,	O
{	O
"-y, --bind <port>"	*(char)
,	O
"This option lets pexec to be remote controlled via INET or "	*(char)
"UNIX domain sockets."	*(char)
}	O
,	O
{	O
"-E, --pexec-connection-variable <env>"	*(char)
,	O
"This option overrides the default environment name PEXEC_REMOTE_PORT "	*(char)
"to the specified value, which is used by the ``-p|--connect auto'' "	*(char)
"combination to determine the control socket with which the running "	*(char)
"pexec instance can be controlled."	*(char)
}	O
,	O
{	O
"-j, --remote"	*(char)
,	O
"Used to remote control and/or poll the status of other running "	*(char)
"instances of pexec."	*(char)
}	O
,	O
{	O
"-p, --connect <port>"	*(char)
,	O
"Remote control port to connect to."	*(char)
}	O
,	O
{	O
"-t, --status"	*(char)
,	O
"Prints the actual status of the running jobs in a "	*(char)
"human-readable form."	*(char)
}	O
,	O
{	O
"-l, --lock <mutex>"	*(char)
,	O
"Locks the specified mutex (if the mutex is not locked by "	*(char)
"someone else, otherwise it will block until the mutex is released)."	*(char)
}	O
,	O
{	O
"-u, --unlock <mutex>"	*(char)
,	O
"Unlocks the specified mutex."	*(char)
}	O
,	O
{	O
"-m, --mutex <mutex>"	*(char)
,	O
"Name of the mutex."	*(char)
}	O
,	O
{	O
"-d, --dump <filename>"	*(char)
,	O
"Dump the content of the given file to standard output, "	*(char)
"if ``-m|--mutex'' is given, this will be atomic."	*(char)
}	O
,	O
{	O
"-s, --save <filename>"	*(char)
,	O
"Save the content of standard input to the given file, "	*(char)
"if ``-m|--mutex'' is given, this will be atomic."	*(char)
}	O
,	O
{	O
"-a, --atomic <command>"	*(char)
,	O
"Execute the given command. If ``-m|--mutex'' is given, the "	*(char)
"exectution is going to be atomic with respect to that mutex."	*(char)
}	O
,	O
{	O
"Hypervisor mode:"	*(char)
,	O
NULL	O
}	O
,	O
{	O
"-H, --hypervisor"	*(char)
,	O
"Starts pexec in hypervisor mode."	*(char)
}	O
,	O
{	O
"-C, --control <port>"	*(char)
,	O
"The control port used by the hypervisor."	*(char)
}	O
,	O
{	O
"-l, --load <window>"	*(char)
,	O
"Use load also to limit the number of simultaneous processes "	*(char)
"with the specified load average interval (0, 1 or 2, or 1min, "	*(char)
"5min or 15min, respectively)."	*(char)
}	O
,	O
{	O
"-f, --fifo"	*(char)
,	O
"First in first out queue processing."	*(char)
}	O
,	O
{	O
"-s, --lifo"	*(char)
,	O
"Last in first out (stack) queue processing (default)."	*(char)
}	O
,	O
{	O
"Logging:"	*(char)
,	O
NULL	O
}	O
,	O
{	O
"-L, --log <file>"	*(char)
,	O
"The name of the log file."	*(char)
}	O
,	O
{	O
"-W, --log-level <level>"	*(char)
,	O
"The logging level."	*(char)
}	O
,	O
{	O
"-V, --verbose"	*(char)
,	O
"Increase the log level by one."	*(char)
}	O
,	O
{	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
int	O
fprint_pexec_long_help	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
FILE	struct
*	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Usage:\tpexec [options] [-c|-m] [--] command [arguments] | 'compound command'\n"	*(char)
"Execute commands or shell scripts in parallel on a single host or\n"	*(char)
"on remote hosts using a remote shell.\n\n"	*(char)
)	O
;	O
longhelp_fprint	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(*(char),*(char))),int,int)->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
pexec_long_help	array(struct(*(char),*(char)))
,	O
0	int
,	O
-	O
1	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Report bugs to <apal@szofi.elte.hu>\n"	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_pexec_usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
FILE	struct
*	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Usage:\tpexec"	*(char)
"\t[options] [--] command [arguments]\n"	*(char)
"\t\t[options] -c [--] 'compound command'\n"	*(char)
"\t\t[options] -m [--] 'compound command 1' 'compound command 2' ...\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"General Options:\n"	*(char)
"\t[-h|--help|--long-help] [--version]\n"	*(char)
"\t[-c|--shell-command] [-m|--multiple-command] [-s|--shell <shell>]\n"	*(char)
"\t[-e|--environment <environmental_variable_name>]\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\t[-p|--list <list_of_parametes> [-p ...] [-p ...]]\n"	*(char)
"\t[-r|--parameters <list_of_parametes> {--|-<option} [-r ...] [-r ...]]\n"	*(char)
"\t[-f|--listfile <parameter_file> [-w|--column <column>|-t|--complete]]\n"	*(char)
"\t[-n|--number auto|<num>|managed|ncpu [-C|--control {<port>|</path>}]]\n"	*(char)
"\t[-l|--load|--use-load <load>] [-z|--nice <nice>]\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Redirecting input and output:\n"	*(char)
"\t[-i|--input <format_for_standard_input_file>]\n"	*(char)
"\t[-o|--output <format_for_standard_output_file>]\n"	*(char)
"\t[-u|--error <format_for_standard_error_file>]\n"	*(char)
"\t[-a|--output-format <format_for_stdout_redirection> [-x]]\n"	*(char)
"\t[-b|--error-format <format_for_stderr_redirection> [-x|--omit-newlines]]\n"	*(char)
"\t[-R|--normal-redirection]\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Parallelization using remote hosts:\n"	*(char)
"\t[-g|--remote-shell \"<remote_shell [options]>\"] [-q|--timeout <sec>]\n"	*(char)
"\t-n|--number [<host>:]{auto|<num>|managed|ncpu}[,...],[auto|<num>|...]\n"	*(char)
"\t[-P|--pexec <full_pexec_path_on_the_remote_host(s)>] [-k|--local-files]\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Running as a tunnel daemon (only for internal use, see also the manual):\n"	*(char)
"\t-T|--tunnel [-z|--nice <nice>]\n"	*(char)
"\t[-n|--number auto|<num>|managed|ncpu [-C|--control {<port>|</path>}]]\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Remote control, mutual exclusions and atomic command execution:\n"	*(char)
"\t[-y|--bind inet|unix|<port>|/<path>]\n"	*(char)
"\t-j|--remote [-p|--connect auto|/<path>|[host:]<port>] [-t|--status]\n"	*(char)
"\t[-E|--pexec-connection-variable <env_variable_name>]\n"	*(char)
"\t[{-l|--lock|--mutex-lock | -u|--unlock|--mutex-unlock} <name>]\n"	*(char)
"\t[-m|--mutex <name> {-d|--dump | -s|--save} <filename> ]\n"	*(char)
"\t[-m|--mutex <name> -a|--atomic [-c|--shell-command] [--] command [...]]\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Hypervisor mode and operations:\n"	*(char)
"\t-H|--hypervisor [-C|--control {<port>|</path>}] [start|stop]\n"	*(char)
"\t[-n|--number auto|<num>] [-l|--load|--use-load <load>]\n"	*(char)
"\t[-f|--fifo | -s|--lifo|--stack]\n"	*(char)
"\t(default hypervisor socket: %s)\n"	*(char)
,	O
PEXEC_DEFAULT_HYPERVISOR_SOCKET	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Logging (for normal and hypervisor modes):\n"	*(char)
"\t[-L|--log <log_file>] [-W|--log-level <log_level> | -V|--verbose [...]]\n"	*(char)
"Command specifications:\n"	*(char)
"\t[--] { command [args] | 'compound' | 'compound 1' ['compound 2'...] }\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"For more information, see --long-help or the full texinfo documentation.\n"	*(char)
"Examples can be found in the ``Examples'' section of the documentation.\n"	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_version	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
FILE	struct
*	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s %s (%s)\n"	*(char)
,	O
progbasename	*(char)
,	O
PEXEC_VERSION	*(char)
,	O
PEXEC_LAST_MODIFICATION	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Copyright (C) 2007, 2008-2009; Pal, Andras <apal@szofi.elte.hu>\n\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"This is free software. You may redistribute copies of it under the terms of\n"	*(char)
"the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\n"	*(char)
"There is NO WARRANTY, to the extent permitted by law. \n\n"	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"This software was written by Andras Pal. The core part was written \n"	*(char)
"while working for the Hungarian-made Automated Telescope (HAT) project \n"	*(char)
"to make the data processing more easier and therefore find many-many \n"	*(char)
"extrasolar planets. See more information about this project: \n"	*(char)
"http://hatnet.hu. Another internal libraries (e.g. numhash.[ch]) were \n"	*(char)
"primarily written for other projects.\n"	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_err_invarg0	(*(char))->(int)
(	O
char	O
*	O
arg	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: invalid command line argument '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
arg	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_err_invarg1	(*(char))->(int)
(	O
char	O
*	O
arg	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: invalid or missing argument near '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
arg	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
fprint_err_invarg2	(*(char))->(int)
(	O
char	O
*	O
arg	*(char)
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: special command line argument '%s' must be the first in the list.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
arg	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
main	(int,array(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
argv	*(*(char))
[	O
]	O
)	O
{	O
int	O
is_shell_commands	int
,	O
is_multi_commands	int
,	O
zeroarg	int
;	O
remotehost	struct(*(char),int)
*	O
rhosts	*(struct(*(char),int))
;	O
int	O
nrhost	int
;	O
char	O
*	O
list	*(char)
,	O
*	O
listfile	*(char)
,	O
*	O
logfile	*(char)
;	O
int	O
listcolumn	int
;	O
paralleldata	struct(*(char),*(char),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int)))
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
;	O
logdata	struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int)
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
;	O
int	O
ncmd	int
;	O
int	O
llen	int
;	O
int	O
i	int
,	O
ret	*(*(void))
,	O
prio	int
;	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
;	O
int	O
nparam	int
;	O
char	O
*	O
*	O
pnames	*(*(char))
;	O
char	O
*	O
pexec_self	*(char)
,	O
*	O
ctrlport	*(char)
,	O
*	O
ctrlenv	*(char)
,	O
*	O
hypcport	*(char)
;	O
int	O
timeout	int
,	O
use_load	int
;	O
int	O
mode	int
;	O
is_shell_commands	int
=	O
0	int
;	O
is_multi_commands	int
=	O
0	int
;	O
zeroarg	int
=	O
-	O
1	int
;	O
list	*(char)
=	O
NULL	O
;	O
pnames	*(*(char))
=	O
NULL	O
;	O
listfile	*(char)
=	O
logfile	*(char)
=	O
NULL	O
;	O
llen	int
=	O
0	int
;	O
rhosts	*(struct(*(char),int))
=	O
NULL	O
;	O
nrhost	int
=	O
PEXEC_MNP_AUTO	O
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
envvarname	*(char)
=	O
NULL	O
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
=	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
=	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
in	*(char)
=	O
NULL	O
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
shell	*(char)
=	O
PEXEC_DEFAULT_SHELL	*(char)
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rshcmd	*(char)
=	O
NULL	O
;	O
prio	int
=	O
0	int
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
formatout	*(char)
=	O
NULL	O
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
formaterr	*(char)
=	O
NULL	O
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
omit_newlines	int
=	O
0	int
;	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
=	O
-	O
1	int
;	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
listcolumn	int
=	O
0	int
;	O
progbasename	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
progbasename	*(char)
!=	O
NULL	O
)	O
progbasename	*(char)
++	O
;	O
else	O
progbasename	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
mode	int
=	O
PEXEC_MODE_DEFAULT	int
;	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
argv	*(*(char))
[	O
0	int
]	O
,	O
'/'	O
)	O
!=	O
NULL	O
)	O
pexec_self	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
else	O
{	O
pexec_self	*(char)
=	O
progbasename	*(char)
;	O
}	O
timeout	int
=	O
60	int
;	O
ctrlport	*(char)
=	O
NULL	O
;	O
ctrlenv	*(char)
=	O
PEXEC_DEFAULT_ENVVARIABLE	*(char)
;	O
hypcport	*(char)
=	O
NULL	O
;	O
use_load	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-h"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--short-help"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--help"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--help-short"	*(char)
)	O
==	O
0	int
)	O
{	O
fprint_pexec_usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--long-help"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--help-long"	*(char)
)	O
==	O
0	int
)	O
{	O
fprint_pexec_long_help	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--version"	*(char)
)	O
==	O
0	int
)	O
{	O
fprint_version	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-c"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--shell-command"	*(char)
)	O
==	O
0	int
)	O
is_shell_commands	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-m"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--multiple-command"	*(char)
)	O
==	O
0	int
)	O
is_multi_commands	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-e"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--environment"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--setenv"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
envvarname	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-s"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--shell"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
shell	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-g"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--remote-shell"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
i	int
++	O
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rshcmd	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-p"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--list"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
list	*(char)
==	O
NULL	O
)	O
{	O
list	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
llen	int
=	O
strlen	(*(char))->(long)
(	O
list	*(char)
)	O
;	O
}	O
else	O
{	O
int	O
ilen	int
;	O
ilen	int
=	O
strlen	(*(char))->(long)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
list	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
list	*(char)
,	O
llen	int
+	O
ilen	int
+	O
2	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
list	*(char)
+	O
llen	int
,	O
" "	*(char)
)	O
;	O
llen	int
++	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
list	*(char)
+	O
llen	int
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
llen	int
+=	O
ilen	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-r"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--parameters"	*(char)
)	O
==	O
0	int
)	O
{	O
i	int
++	O
;	O
for	O
(	O
;	O
i	int
<	O
argc	int
&&	O
argv	*(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
!=	O
'-'	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
list	*(char)
==	O
NULL	O
)	O
{	O
list	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
llen	int
=	O
strlen	(*(char))->(long)
(	O
list	*(char)
)	O
;	O
}	O
else	O
{	O
int	O
ilen	int
;	O
ilen	int
=	O
strlen	(*(char))->(long)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
list	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
list	*(char)
,	O
llen	int
+	O
ilen	int
+	O
2	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
list	*(char)
+	O
llen	int
,	O
" "	*(char)
)	O
;	O
llen	int
++	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
list	*(char)
+	O
llen	int
,	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
llen	int
+=	O
ilen	int
;	O
}	O
}	O
i	int
--	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-f"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--listfile"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
listfile	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-w"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--column"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"%d"	*(char)
,	O
&	O
listcolumn	int
)	O
<	O
1	int
||	O
listcolumn	int
<=	O
0	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
listcolumn	int
--	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-t"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--complete"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--complete-line"	*(char)
)	O
==	O
0	int
)	O
listcolumn	int
=	O
-	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-n"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--number"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
PEXEC_ISTR_AUTO	*(char)
)	O
==	O
0	int
)	O
{	O
rhosts	*(struct(*(char),int))
=	O
NULL	O
;	O
nrhost	int
=	O
PEXEC_MNP_AUTO	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
PEXEC_ISTR_MANAGED	*(char)
)	O
==	O
0	int
)	O
{	O
rhosts	*(struct(*(char),int))
=	O
NULL	O
;	O
nrhost	int
=	O
PEXEC_MNP_MANAGED	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
PEXEC_ISTR_NCPU	*(char)
)	O
==	O
0	int
)	O
{	O
rhosts	*(struct(*(char),int))
=	O
NULL	O
;	O
nrhost	int
=	O
PEXEC_MNP_NCPU	O
;	O
}	O
else	O
if	O
(	O
parse_host_data	(*(char),*(*(struct(*(char),int))),*(int))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
&	O
rhosts	*(struct(*(char),int))
,	O
&	O
nrhost	int
)	O
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-M"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--managed"	*(char)
)	O
==	O
0	int
)	O
{	O
rhosts	*(struct(*(char),int))
=	O
NULL	O
;	O
nrhost	int
=	O
PEXEC_MNP_MANAGED	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-l"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--load"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--use-load"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"0"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"1m"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"1min"	*(char)
)	O
==	O
0	int
)	O
use_load	int
=	O
0	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"1"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"5m"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"5min"	*(char)
)	O
==	O
0	int
)	O
use_load	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"2"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"15m"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"15min"	*(char)
)	O
==	O
0	int
)	O
use_load	int
=	O
2	int
;	O
else	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-z"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--nice"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"%d"	*(char)
,	O
&	O
prio	int
)	O
<	O
1	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
prio	int
+=	O
128	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-q"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--timeout"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"%d"	*(char)
,	O
&	O
timeout	int
)	O
<	O
1	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
timeout	int
<	O
0	int
)	O
timeout	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-P"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--pexec"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
pexec_self	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-E"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--pexec-connection-variable"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
ctrlenv	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-i"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--input"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
in	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-o"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--output"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-u"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--error"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--output-error"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-R"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--normal-redirection"	*(char)
)	O
==	O
0	int
)	O
{	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
in	*(char)
=	O
NULL	O
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
=	O
"-"	*(char)
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
=	O
"-"	*(char)
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-a"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--output-format"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
formatout	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-b"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--error-format"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
formaterr	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-x"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--omit-newlines"	*(char)
)	O
==	O
0	int
)	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
omit_newlines	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-y"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--bind"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
ctrlport	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-C"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--control"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
hypcport	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-L"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--log"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
logfile	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-V"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--verbose"	*(char)
)	O
==	O
0	int
)	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
++	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-W"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--log-level"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"%d"	*(char)
,	O
&	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
)	O
<	O
1	int
||	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
<	O
0	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-T"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--tunnel"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
{	O
fprint_err_invarg2	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
zeroarg	int
=	O
i	int
+	O
1	int
;	O
mode	int
=	O
PEXEC_MODE_DAEMON	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-j"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--remote"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
{	O
fprint_err_invarg2	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
zeroarg	int
=	O
i	int
+	O
1	int
;	O
mode	int
=	O
PEXEC_MODE_REMOTECONTROL	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-H"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--hypervisor"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
{	O
fprint_err_invarg2	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
zeroarg	int
=	O
i	int
+	O
1	int
;	O
mode	int
=	O
PEXEC_MODE_HYPERVISOR	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--"	*(char)
)	O
==	O
0	int
)	O
{	O
zeroarg	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
zeroarg	int
>=	O
argc	int
)	O
zeroarg	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
fprint_err_invarg0	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
{	O
zeroarg	int
=	O
i	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
zeroarg	int
<	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
mode	int
==	O
PEXEC_MODE_DEFAULT	int
)	O
{	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
*	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
;	O
int	O
nrshell	int
,	O
r	int
;	O
int	O
status	int
,	O
sock	int
,	O
hsck	int
;	O
char	O
*	O
pctrlport	*(char)
;	O
int	O
is_rhosts_defined	int
,	O
no_touch_std	int
;	O
if	O
(	O
rhosts	*(struct(*(char),int))
==	O
NULL	O
)	O
{	O
rhosts	*(struct(*(char),int))
=	O
(	O
remotehost	struct(*(char),int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
remotehost	struct(*(char),int)
)	O
*	O
1	int
)	O
;	O
rhosts	*(struct(*(char),int))
[	O
0	int
]	O
.	O
hostspec	*(char)
=	O
NULL	O
;	O
rhosts	*(struct(*(char),int))
[	O
0	int
]	O
.	O
num_processes	int
=	O
nrhost	int
;	O
nrhost	int
=	O
1	int
;	O
is_rhosts_defined	int
=	O
0	int
;	O
}	O
else	O
is_rhosts_defined	int
=	O
!	O
0	int
;	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rshcmd	*(char)
==	O
NULL	O
)	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rshcmd	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
PEXEC_DEFAULT_RSH	*(char)
)	O
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rshargs	*(*(char))
=	O
tokenize_spaces_dyn	(*(char))->(*(*(char)))
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rshcmd	*(char)
)	O
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rsh	*(char)
=	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rshargs	*(*(char))
[	O
0	int
]	O
;	O
if	O
(	O
list	*(char)
!=	O
NULL	O
&&	O
listfile	*(char)
!=	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: both parameter list and list file are defined.\n"	*(char)
)	O
,	O
progbasename	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
list	*(char)
!=	O
NULL	O
)	O
{	O
pnames	*(*(char))
=	O
tokenize_spaces_dyn	(*(char))->(*(*(char)))
(	O
list	*(char)
)	O
;	O
for	O
(	O
nparam	int
=	O
0	int
;	O
pnames	*(*(char))
!=	O
NULL	O
&&	O
pnames	*(*(char))
[	O
nparam	int
]	O
!=	O
NULL	O
;	O
)	O
nparam	int
++	O
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
)	O
*	O
nparam	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
name	*(char)
=	O
pnames	*(*(char))
[	O
i	int
]	O
;	O
}	O
}	O
else	O
if	O
(	O
listfile	*(char)
!=	O
NULL	O
)	O
{	O
FILE	struct
*	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
char	O
*	O
line	*(char)
,	O
*	O
*	O
tokens	*(*(char))
;	O
int	O
ntoken	int
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
listfile	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
)	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
listfile	*(char)
,	O
"rb"	*(char)
)	O
;	O
if	O
(	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to open list file.\n"	*(char)
)	O
,	O
progbasename	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
NULL	O
;	O
nparam	int
=	O
0	int
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
line	*(char)
=	O
freadline	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
line	*(char)
==	O
NULL	O
)	O
break	O
;	O
remove_newlines_and_comments	(*(char))->(void)
(	O
line	*(char)
)	O
;	O
if	O
(	O
!	O
(	O
strlen	(*(char))->(long)
(	O
line	*(char)
)	O
>	O
0	int
)	O
)	O
{	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
listcolumn	int
<	O
0	int
)	O
{	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
sizeof	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
)	O
*	O
(	O
nparam	int
+	O
1	int
)	O
)	O
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
nparam	int
]	O
.	O
name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
line	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
nparam	int
++	O
;	O
}	O
else	O
{	O
tokens	*(*(char))
=	O
tokenize_spaces_dyn	(*(char))->(*(*(char)))
(	O
line	*(char)
)	O
;	O
if	O
(	O
tokens	*(*(char))
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
ntoken	int
=	O
0	int
;	O
tokens	*(*(char))
[	O
ntoken	int
]	O
!=	O
NULL	O
;	O
)	O
ntoken	int
++	O
;	O
if	O
(	O
listcolumn	int
>=	O
ntoken	int
)	O
{	O
free	(*(void))->(void)
(	O
tokens	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
continue	O
;	O
}	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
sizeof	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
)	O
*	O
(	O
nparam	int
+	O
1	int
)	O
)	O
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
nparam	int
]	O
.	O
name	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
tokens	*(*(char))
[	O
listcolumn	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
tokens	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
line	*(char)
)	O
;	O
nparam	int
++	O
;	O
}	O
}	O
if	O
(	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
NULL	O
;	O
nparam	int
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
0	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argv	*(*(char))
=	O
NULL	O
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
0	int
;	O
}	O
if	O
(	O
is_multi_commands	int
)	O
ncmd	int
=	O
argc	int
-	O
zeroarg	int
;	O
else	O
ncmd	int
=	O
1	int
;	O
no_touch_std	int
=	O
0	int
;	O
if	O
(	O
nparam	int
>	O
0	int
&&	O
is_multi_commands	int
&&	O
nparam	int
!=	O
ncmd	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: number of parameters and commands mismatch.\n"	*(char)
)	O
,	O
progbasename	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
is_multi_commands	int
&&	O
nparam	int
>	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
1	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
1	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argv	*(*(char))
=	O
argv	*(*(char))
+	O
zeroarg	int
+	O
i	int
;	O
}	O
}	O
else	O
if	O
(	O
is_multi_commands	int
)	O
{	O
nparam	int
=	O
ncmd	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
)	O
*	O
nparam	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ncmd	int
;	O
i	int
++	O
)	O
{	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
name	*(char)
=	O
NULL	O
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
1	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
1	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argv	*(*(char))
=	O
argv	*(*(char))
+	O
zeroarg	int
+	O
i	int
;	O
}	O
}	O
else	O
if	O
(	O
nparam	int
>	O
0	int
&&	O
is_shell_commands	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
1	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
argc	int
-	O
zeroarg	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argv	*(*(char))
=	O
argv	*(*(char))
+	O
zeroarg	int
;	O
}	O
}	O
else	O
if	O
(	O
nparam	int
>	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
0	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
argc	int
-	O
zeroarg	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argv	*(*(char))
=	O
argv	*(*(char))
+	O
zeroarg	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
is_rhosts_defined	int
)	O
{	O
nparam	int
=	O
1	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
)	O
*	O
nparam	int
)	O
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
0	int
]	O
.	O
name	*(char)
=	O
NULL	O
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
0	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
is_shell_commands	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
0	int
]	O
.	O
c	int
.	O
argv	*(*(char))
=	O
argv	*(*(char))
+	O
zeroarg	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
0	int
]	O
.	O
c	int
.	O
argc	int
=	O
argc	int
-	O
zeroarg	int
;	O
no_touch_std	int
=	O
!	O
0	int
;	O
}	O
else	O
{	O
nparam	int
=	O
nrhost	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
=	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
parameter	struct(*(char),int,struct(int,*(*(char)),int),int,int)
)	O
*	O
nparam	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
name	*(char)
=	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
hostspec	*(char)
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
is_shell	int
=	O
-	O
1	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argv	*(*(char))
=	O
argv	*(*(char))
+	O
zeroarg	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
c	int
.	O
argc	int
=	O
argc	int
-	O
zeroarg	int
;	O
}	O
rhosts	*(struct(*(char),int))
[	O
0	int
]	O
.	O
hostspec	*(char)
=	O
NULL	O
;	O
rhosts	*(struct(*(char),int))
[	O
0	int
]	O
.	O
num_processes	int
=	O
nparam	int
;	O
nrhost	int
=	O
1	int
;	O
no_touch_std	int
=	O
!	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
status	int
=	O
0	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
no_touch_std	int
=	O
0	int
;	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
id	int
=	O
i	int
;	O
}	O
if	O
(	O
(	O
no_touch_std	int
||	O
nparam	int
<=	O
1	int
)	O
&&	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
in	*(char)
==	O
NULL	O
&&	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
==	O
NULL	O
&&	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
==	O
NULL	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nparam	int
;	O
i	int
++	O
)	O
{	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
[	O
i	int
]	O
.	O
no_touch_std	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
!=	O
NULL	O
&&	O
(	O
!	O
format_check_if_formatted	(*(char),*(char))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
,	O
"skd"	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
,	O
"-1"	*(char)
)	O
==	O
0	int
)	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
,	O
"-2"	*(char)
)	O
==	O
0	int
)	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
,	O
"wb"	*(char)
)	O
;	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to create collective output file '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
out	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
!=	O
NULL	O
&&	O
(	O
!	O
format_check_if_formatted	(*(char),*(char))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
,	O
"skd"	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
,	O
"-"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
,	O
"-2"	*(char)
)	O
==	O
0	int
)	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
,	O
"-1"	*(char)
)	O
==	O
0	int
)	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
,	O
"wb"	*(char)
)	O
;	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to create collective error file '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
err	long
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
if	O
(	O
logfile	*(char)
!=	O
NULL	O
&&	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
!=	O
0	int
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
logfile	*(char)
,	O
"-"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
logfile	*(char)
,	O
"-2"	*(char)
)	O
==	O
0	int
)	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
logfile	*(char)
,	O
"-1"	*(char)
)	O
==	O
0	int
)	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
logfile	*(char)
,	O
"wb"	*(char)
)	O
;	O
if	O
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to create log file '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
logfile	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
<	O
0	int
)	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
=	O
+	O
1	int
;	O
}	O
else	O
if	O
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
>	O
0	int
)	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
else	O
{	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
NULL	O
;	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
=	O
0	int
;	O
}	O
if	O
(	O
prio	int
>	O
0	int
)	O
{	O
i	int
=	O
setpriority	(enum(int,int,int),int,int)->(int)
(	O
PRIO_PROCESS	int
,	O
0	int
,	O
prio	int
-	O
128	int
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: warning: unable to set scheduling priority to %d.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
prio	int
-	O
128	int
)	O
;	O
}	O
}	O
if	O
(	O
ctrlport	*(char)
!=	O
NULL	O
)	O
{	O
sock	int
=	O
remote_control_port_bind	(*(char),*(*(char)),int,int)->(int)
(	O
ctrlport	*(char)
,	O
&	O
pctrlport	*(char)
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to create or bind control socket to %s.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
ctrlport	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
sock	int
=	O
-	O
1	int
;	O
pctrlport	*(char)
=	O
NULL	O
;	O
}	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fallback_to_die	int
=	O
1	int
;	O
nrshell	int
=	O
nrhost	int
;	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
(	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
*	O
)	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
remoteshell	struct(int,int,int,int,int,int,struct(*(char),long))
)	O
*	O
nrshell	int
)	O
;	O
hsck	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nrhost	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
hostspec	*(char)
==	O
NULL	O
&&	O
(	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
num_processes	int
==	O
PEXEC_MNP_AUTO	O
||	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
num_processes	int
==	O
PEXEC_MNP_MANAGED	O
)	O
&&	O
hsck	int
<	O
0	int
)	O
{	O
if	O
(	O
hypcport	*(char)
==	O
NULL	O
)	O
hypcport	*(char)
=	O
PEXEC_DEFAULT_HYPERVISOR_SOCKET	*(char)
;	O
hsck	int
=	O
remote_control_port_connect	(*(char))->(int)
(	O
hypcport	*(char)
)	O
;	O
if	O
(	O
hsck	int
<	O
0	int
&&	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
num_processes	int
==	O
PEXEC_MNP_MANAGED	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to connect hypervisor socket '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
hypcport	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
hsck	int
<	O
0	int
)	O
{	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
num_processes	int
=	O
PEXEC_MNP_NCPU	O
;	O
hsck	int
=	O
-	O
1	int
;	O
}	O
else	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
num_processes	int
=	O
0	int
;	O
if	O
(	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
num_processes	int
<	O
0	int
)	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
num_processes	int
=	O
get_number_of_cpus	()->(int)
(	O
)	O
;	O
}	O
r	int
=	O
remote_shell_init	(*(char),*(*(char)),*(char),*(char),int,*(struct(*(char),int)),*(struct(int,int,int,int,int,int,struct(*(char),long))),int)->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rsh	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rshargs	*(*(char))
,	O
pexec_self	*(char)
,	O
ctrlport	*(char)
,	O
timeout	int
,	O
&	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
,	O
&	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
[	O
i	int
]	O
,	O
prio	int
)	O
;	O
if	O
(	O
r	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to connect or initialize remote shell '%s' and/or pexec daemon '%s' to the host '%s' (reason code=%d).\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rsh	*(char)
,	O
pexec_self	*(char)
,	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
hostspec	*(char)
,	O
r	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
pctrlport	*(char)
!=	O
NULL	O
)	O
bind_variable_export	(*(char),*(char))->(int)
(	O
ctrlenv	*(char)
,	O
pctrlport	*(char)
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
)	O
listen	(int,int)->(int)
(	O
sock	int
,	O
256	int
)	O
;	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
=	O
&	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
ret	*(*(void))
=	O
pexec_do_parallelized_execution	(*(struct(*(char),*(char),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),int,*(char),*(char),*(char),*(char),*(*(char)),int,*(struct(*`,int)))),*(struct(*(char),int,struct(int,*(*`),int),int,int)),int,*(struct(int,int,int,int,int,int,struct(*(char),long))),int,int,int)->(int)
(	O
&	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
,	O
nparam	int
,	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
,	O
nrshell	int
,	O
sock	int
,	O
hsck	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
=	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
;	O
i	int
<	O
nrshell	int
;	O
i	int
++	O
,	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
++	O
)	O
{	O
if	O
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
pid	int
<	O
0	int
)	O
continue	O
;	O
hprintf	(int,*(char))->(int)
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
fhsend	int
,	O
"exit\n"	*(char)
)	O
;	O
waitpid	(int,*(int),int)->(int)
(	O
rs	*(struct(int,int,int,int,int,int,struct(*(char),long)))
->	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
rshells	*(struct(int,int,int,int,int,int,struct(*(char),long)))
)	O
;	O
if	O
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
&&	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
1	int
&&	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
2	int
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
fwlog	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
&&	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
1	int
&&	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
2	int
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
NULL	O
&&	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
1	int
&&	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
!=	O
2	int
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
fwerr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
if	O
(	O
pctrlport	*(char)
!=	O
NULL	O
&&	O
is_unix_socket_name	(*(char))->(int)
(	O
pctrlport	*(char)
)	O
)	O
unlink	(*(char))->(int)
(	O
pctrlport	*(char)
)	O
;	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
hsck	int
,	O
"close\n"	*(char)
)	O
;	O
fdwait	(int,int)->(int)
(	O
hsck	int
,	O
0	int
)	O
;	O
i	int
=	O
close	*((*(void))->(int))
(	O
hsck	int
)	O
;	O
}	O
if	O
(	O
pnames	*(*(char))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
pnames	*(*(char))
)	O
;	O
if	O
(	O
list	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
list	*(char)
)	O
;	O
if	O
(	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
params	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
)	O
;	O
if	O
(	O
pctrlport	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
pctrlport	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rshcmd	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
rshargs	*(*(char))
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nrhost	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
hostspec	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
rhosts	*(struct(*(char),int))
[	O
i	int
]	O
.	O
hostspec	*(char)
)	O
;	O
}	O
free	(*(void))->(void)
(	O
rhosts	*(struct(*(char),int))
)	O
;	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
else	O
if	O
(	O
mode	int
==	O
PEXEC_MODE_DAEMON	int
)	O
{	O
int	O
fhrecv	int
,	O
fhsend	int
;	O
int	O
num_processes	int
;	O
int	O
sock	int
,	O
hsck	int
;	O
char	O
*	O
pctrlport	*(char)
;	O
num_processes	int
=	O
-	O
1	int
;	O
ctrlport	*(char)
=	O
NULL	O
;	O
prio	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
zeroarg	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-n"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--number"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
PEXEC_ISTR_AUTO	*(char)
)	O
==	O
0	int
)	O
num_processes	int
=	O
PEXEC_MNP_AUTO	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
PEXEC_ISTR_MANAGED	*(char)
)	O
==	O
0	int
)	O
num_processes	int
=	O
PEXEC_MNP_MANAGED	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
PEXEC_ISTR_NCPU	*(char)
)	O
==	O
0	int
)	O
num_processes	int
=	O
PEXEC_MNP_NCPU	O
;	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"%d"	*(char)
,	O
&	O
num_processes	int
)	O
<	O
1	int
||	O
num_processes	int
<=	O
0	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-y"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--bind"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
ctrlport	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-C"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--control"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
hypcport	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-z"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--nice"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"%d"	*(char)
,	O
&	O
prio	int
)	O
<	O
1	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
prio	int
+=	O
128	int
;	O
}	O
else	O
{	O
fprint_err_invarg0	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
num_processes	int
==	O
PEXEC_MNP_AUTO	O
||	O
num_processes	int
==	O
PEXEC_MNP_MANAGED	O
)	O
{	O
if	O
(	O
hypcport	*(char)
==	O
NULL	O
)	O
hypcport	*(char)
=	O
PEXEC_DEFAULT_HYPERVISOR_SOCKET	*(char)
;	O
hsck	int
=	O
remote_control_port_connect	(*(char))->(int)
(	O
hypcport	*(char)
)	O
;	O
if	O
(	O
hsck	int
<	O
0	int
&&	O
num_processes	int
==	O
PEXEC_MNP_MANAGED	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to connect hypervisor socket '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
hypcport	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
hsck	int
<	O
0	int
)	O
{	O
num_processes	int
=	O
PEXEC_MNP_NCPU	O
;	O
hsck	int
=	O
-	O
1	int
;	O
}	O
else	O
num_processes	int
=	O
0	int
;	O
}	O
else	O
hsck	int
=	O
-	O
1	int
;	O
if	O
(	O
num_processes	int
<	O
0	int
)	O
num_processes	int
=	O
get_number_of_cpus	()->(int)
(	O
)	O
;	O
if	O
(	O
ctrlport	*(char)
!=	O
NULL	O
)	O
{	O
sock	int
=	O
remote_control_port_bind	(*(char),*(*(char)),int,int)->(int)
(	O
ctrlport	*(char)
,	O
&	O
pctrlport	*(char)
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to create or bind control socket to %s.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
ctrlport	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
sock	int
=	O
-	O
1	int
;	O
pctrlport	*(char)
=	O
NULL	O
;	O
}	O
fhrecv	int
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fhsend	int
=	O
fileno	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
pctrlport	*(char)
!=	O
NULL	O
)	O
bind_variable_export	(*(char),*(char))->(int)
(	O
ctrlenv	*(char)
,	O
pctrlport	*(char)
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
)	O
listen	(int,int)->(int)
(	O
sock	int
,	O
256	int
)	O
;	O
if	O
(	O
prio	int
>	O
0	int
)	O
{	O
i	int
=	O
setpriority	(enum(int,int,int),int,int)->(int)
(	O
PRIO_PROCESS	int
,	O
0	int
,	O
prio	int
-	O
128	int
)	O
;	O
}	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
pexec_daemon_main_loop	(int,int,int,int,int)->(int)
(	O
fhrecv	int
,	O
fhsend	int
,	O
num_processes	int
,	O
sock	int
,	O
hsck	int
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
if	O
(	O
pctrlport	*(char)
!=	O
NULL	O
&&	O
is_unix_socket_name	(*(char))->(int)
(	O
pctrlport	*(char)
)	O
)	O
unlink	(*(char))->(int)
(	O
pctrlport	*(char)
)	O
;	O
}	O
if	O
(	O
hsck	int
>=	O
0	int
)	O
{	O
hprintf	(int,*(char))->(int)
(	O
hsck	int
,	O
"close\n"	*(char)
)	O
;	O
fdwait	(int,int)->(int)
(	O
hsck	int
,	O
0	int
)	O
;	O
i	int
=	O
close	*((*(void))->(int))
(	O
hsck	int
)	O
;	O
}	O
if	O
(	O
pctrlport	*(char)
!=	O
NULL	O
)	O
free	(*(void))->(void)
(	O
pctrlport	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
mode	int
==	O
PEXEC_MODE_REMOTECONTROL	int
)	O
{	O
char	O
*	O
ctrlport	*(char)
;	O
int	O
sock	int
;	O
int	O
task	int
;	O
char	O
*	O
file	*(char)
,	O
*	O
name	*(char)
;	O
FILE	struct
*	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
*	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
int	O
azeroarg	int
;	O
ctrlport	*(char)
=	O
NULL	O
;	O
task	int
=	O
PEXEC_REMOTE_STATUS	int
;	O
name	*(char)
=	O
NULL	O
;	O
file	*(char)
=	O
NULL	O
;	O
is_shell_commands	int
=	O
0	int
;	O
azeroarg	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
zeroarg	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-p"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--connect"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
ctrlport	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-t"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--status"	*(char)
)	O
==	O
0	int
)	O
task	int
=	O
PEXEC_REMOTE_STATUS	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-l"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--lock"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--mutex-lock"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
task	int
=	O
PEXEC_REMOTE_LOCK	int
;	O
name	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-u"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--unlock"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--mutex-unlock"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
task	int
=	O
PEXEC_REMOTE_UNLOCK	int
;	O
name	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-m"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--mutex"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
name	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-d"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--dump"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
task	int
=	O
PEXEC_REMOTE_DUMP	int
;	O
file	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-s"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--save"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
task	int
=	O
PEXEC_REMOTE_SAVE	int
;	O
file	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-c"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--shell-command"	*(char)
)	O
==	O
0	int
)	O
is_shell_commands	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-a"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--atomic"	*(char)
)	O
==	O
0	int
)	O
task	int
=	O
PEXEC_REMOTE_ATOMIC	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--"	*(char)
)	O
==	O
0	int
&&	O
task	int
==	O
PEXEC_REMOTE_ATOMIC	int
)	O
{	O
azeroarg	int
=	O
i	int
+	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
argv	*(*(char))
[	O
i	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
fprint_err_invarg0	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
task	int
==	O
PEXEC_REMOTE_ATOMIC	int
)	O
{	O
azeroarg	int
=	O
i	int
;	O
break	O
;	O
}	O
else	O
{	O
fprint_err_invarg0	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
ctrlport	*(char)
==	O
NULL	O
||	O
strcmp	(*(char),*(char))->(int)
(	O
ctrlport	*(char)
,	O
PEXEC_ISTR_AUTO	*(char)
)	O
==	O
0	int
)	O
ctrlport	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
ctrlenv	*(char)
)	O
;	O
if	O
(	O
ctrlport	*(char)
==	O
NULL	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: connection port has not been defined or set in the environment.\n"	*(char)
)	O
,	O
progbasename	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
sock	int
=	O
remote_control_port_connect	(*(char))->(int)
(	O
ctrlport	*(char)
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to connect to '%s'.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
ctrlport	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
switch	O
(	O
task	int
)	O
{	O
case	O
PEXEC_REMOTE_STATUS	int
:	O
ret	*(*(void))
=	O
remote_status	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
sock	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
break	O
;	O
case	O
PEXEC_REMOTE_LOCK	int
:	O
ret	*(*(void))
=	O
remote_lock	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
sock	int
,	O
NULL	O
,	O
name	*(char)
)	O
;	O
break	O
;	O
case	O
PEXEC_REMOTE_UNLOCK	int
:	O
ret	*(*(void))
=	O
remote_unlock	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
sock	int
,	O
NULL	O
,	O
name	*(char)
)	O
;	O
break	O
;	O
case	O
PEXEC_REMOTE_DUMP	int
:	O
if	O
(	O
file	*(char)
!=	O
NULL	O
&&	O
(	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file	*(char)
,	O
"rb"	*(char)
)	O
)	O
!=	O
NULL	O
&&	O
name	*(char)
!=	O
NULL	O
)	O
{	O
ret	*(*(void))
=	O
remote_copy	(int,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
sock	int
,	O
name	*(char)
,	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: invalid or unspecified input file (%s).\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
(	O
file	*(char)
==	O
NULL	O
?	O
"-"	*(char)
:	O
file	*(char)
)	O
)	O
;	O
ret	*(*(void))
=	O
1	int
;	O
}	O
break	O
;	O
case	O
PEXEC_REMOTE_SAVE	int
:	O
if	O
(	O
file	*(char)
!=	O
NULL	O
&&	O
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file	*(char)
,	O
"wb"	*(char)
)	O
)	O
!=	O
NULL	O
&&	O
name	*(char)
!=	O
NULL	O
)	O
{	O
ret	*(*(void))
=	O
remote_copy	(int,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
sock	int
,	O
name	*(char)
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fw	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: invalid or unspecified output file (%s).\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
(	O
file	*(char)
==	O
NULL	O
?	O
"-"	*(char)
:	O
file	*(char)
)	O
)	O
;	O
ret	*(*(void))
=	O
1	int
;	O
}	O
break	O
;	O
case	O
PEXEC_REMOTE_ATOMIC	int
:	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
remote_lock	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
sock	int
,	O
NULL	O
,	O
name	*(char)
)	O
;	O
if	O
(	O
azeroarg	int
<	O
argc	int
)	O
ret	*(*(void))
=	O
remote_atomic_execute	(int,*(char),int,*(*(char)),int)->(int)
(	O
is_shell_commands	int
,	O
p	*(struct(*(char),int,struct(int,*(*(char)),int),int,int))
.	O
shell	*(char)
,	O
argc	int
-	O
azeroarg	int
,	O
argv	*(*(char))
+	O
azeroarg	int
,	O
sock	int
)	O
;	O
else	O
ret	*(*(void))
=	O
0	int
;	O
if	O
(	O
name	*(char)
!=	O
NULL	O
)	O
remote_unlock	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
sock	int
,	O
NULL	O
,	O
name	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
ret	*(*(void))
=	O
1	int
;	O
break	O
;	O
}	O
remote_disconnect	(int)->(int)
(	O
sock	int
)	O
;	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
return	O
(	O
ret	*(*(void))
)	O
;	O
}	O
else	O
if	O
(	O
mode	int
==	O
PEXEC_MODE_HYPERVISOR	int
)	O
{	O
int	O
startstop	int
;	O
int	O
num_processes	int
,	O
use_load	int
,	O
use_fifo	int
;	O
int	O
sock	int
;	O
hypcport	*(char)
=	O
NULL	O
;	O
startstop	int
=	O
-	O
1	int
;	O
num_processes	int
=	O
-	O
1	int
;	O
use_load	int
=	O
-	O
1	int
;	O
use_fifo	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
zeroarg	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-n"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--number"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
PEXEC_ISTR_AUTO	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
PEXEC_ISTR_NCPU	*(char)
)	O
==	O
0	int
)	O
num_processes	int
=	O
PEXEC_MNP_NCPU	O
;	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"%d"	*(char)
,	O
&	O
num_processes	int
)	O
<	O
1	int
||	O
num_processes	int
<=	O
0	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-l"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--load"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--use-load"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"0"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"1m"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"1min"	*(char)
)	O
==	O
0	int
)	O
use_load	int
=	O
0	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"1"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"5m"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"5min"	*(char)
)	O
==	O
0	int
)	O
use_load	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"2"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"15m"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"15min"	*(char)
)	O
==	O
0	int
)	O
use_load	int
=	O
2	int
;	O
else	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-C"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--control"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
hypcport	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-L"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--log"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
logfile	*(char)
=	O
argv	*(*(char))
[	O
i	int
]	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-V"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--verbose"	*(char)
)	O
==	O
0	int
)	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
++	O
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-W"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--log-level"	*(char)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
(	O
++	O
i	int
)	O
>=	O
argc	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"%d"	*(char)
,	O
&	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
)	O
<	O
1	int
||	O
log	*(struct(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int))
.	O
loglevel	int
<	O
0	int
)	O
{	O
fprint_err_invarg1	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
-	O
1	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-f"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--fifo"	*(char)
)	O
==	O
0	int
)	O
use_fifo	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"-s"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--lifo"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"--stack"	*(char)
)	O
==	O
0	int
)	O
use_fifo	int
=	O
0	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"start"	*(char)
)	O
==	O
0	int
)	O
startstop	int
=	O
0	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
,	O
"stop"	*(char)
)	O
==	O
0	int
)	O
startstop	int
=	O
1	int
;	O
else	O
{	O
fprint_err_invarg0	(*(char))->(int)
(	O
argv	*(*(char))
[	O
i	int
]	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
num_processes	int
<=	O
0	int
)	O
num_processes	int
=	O
get_number_of_cpus	()->(int)
(	O
)	O
;	O
if	O
(	O
hypcport	*(char)
==	O
NULL	O
)	O
hypcport	*(char)
=	O
PEXEC_DEFAULT_HYPERVISOR_SOCKET	*(char)
;	O
if	O
(	O
startstop	int
>	O
0	int
)	O
{	O
sock	int
=	O
remote_control_port_connect	(*(char))->(int)
(	O
hypcport	*(char)
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to connect to hypervisor control socket '%s' in order to stop the service.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
hypcport	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
pexec_hypervisor_stop	(int)->(int)
(	O
sock	int
)	O
;	O
close	*((*(void))->(int))
(	O
sock	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
sock	int
=	O
remote_control_port_bind	(*(char),*(*(char)),int,int)->(int)
(	O
hypcport	*(char)
,	O
NULL	O
,	O
0	int
,	O
1	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: unable to create or bind control socket to %s.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
hypcport	*(char)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
(	O
startstop	int
<	O
0	int
)	O
)	O
background	(int,int)->(int)
(	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
>=	O
0	int
)	O
listen	(int,int)->(int)
(	O
sock	int
,	O
256	int
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
pexec_hypervisor_main_loop	(int,int,int,int)->(int)
(	O
sock	int
,	O
num_processes	int
,	O
use_load	int
,	O
use_fifo	int
)	O
;	O
if	O
(	O
is_unix_socket_name	(*(char))->(int)
(	O
hypcport	*(char)
)	O
)	O
unlink	(*(char))->(int)
(	O
hypcport	*(char)
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: error: internal: invalid mode code %d.\n"	*(char)
)	O
,	O
progbasename	*(char)
,	O
mode	int
)	O
;	O
return	O
(	O
2	int
)	O
;	O
}	O
}	O
