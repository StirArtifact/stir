void	O
prepare_pattern_profiling	()->(void)
(	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Warning, no support for pattern profiling in this binary.\n"	*(char)
)	O
;	O
}	O
void	O
report_pattern_profiling	()->(void)
(	O
)	O
{	O
}	O
static	O
void	O
fixup_patterns_for_board_size	(*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)))->(void)
(	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
)	O
;	O
static	O
void	O
prepare_for_match	(int)->(void)
(	O
int	O
color	int
)	O
;	O
static	O
void	O
do_matchpat	(int,*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(void),array(char))->(void)
(	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
database	*(struct)
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
matchpat_loop	(*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,int,*(struct(int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),*(struct(array(char),*`,*`)))),*(void),array(char),int)->(void)
(	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
int	O
anchor	int
,	O
struct	O
pattern_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
*	O
pdb	*(struct)
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
;	O
static	O
const	O
int	O
and_mask	array(int)
[	O
2	int
]	O
[	O
8	int
]	O
=	O
{	O
{	O
3	int
,	O
3	int
,	O
3	int
,	O
WHITE	int
,	O
BLACK	int
,	O
3	int
,	O
3	int
,	O
3	int
}	O
,	O
{	O
3	int
,	O
3	int
,	O
3	int
,	O
BLACK	int
,	O
WHITE	int
,	O
3	int
,	O
3	int
,	O
3	int
}	O
}	O
;	O
static	O
const	O
int	O
val_mask	array(int)
[	O
2	int
]	O
[	O
8	int
]	O
=	O
{	O
{	O
EMPTY	int
,	O
BLACK	int
,	O
WHITE	int
,	O
0	int
,	O
0	int
,	O
EMPTY	int
,	O
EMPTY	int
,	O
EMPTY	int
}	O
,	O
{	O
EMPTY	int
,	O
WHITE	int
,	O
BLACK	int
,	O
0	int
,	O
0	int
,	O
EMPTY	int
,	O
EMPTY	int
,	O
EMPTY	int
}	O
}	O
;	O
static	O
unsigned	O
int	O
class_mask	array(array(int))
[	O
NUM_DRAGON_STATUS	int
]	O
[	O
3	int
]	O
;	O
static	O
void	O
fixup_patterns_for_board_size	(*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)))->(void)
(	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
)	O
{	O
for	O
(	O
;	O
pattern	*(struct)
->	O
patn	*(struct(short,char))
;	O
++	O
pattern	*(struct)
)	O
if	O
(	O
pattern	*(struct)
->	O
edge_constraints	int
!=	O
0	int
)	O
{	O
if	O
(	O
pattern	*(struct)
->	O
edge_constraints	int
&	O
NORTH_EDGE	int
)	O
pattern	*(struct)
->	O
maxi	int
=	O
pattern	*(struct)
->	O
mini	int
+	O
pattern	*(struct)
->	O
height	int
;	O
if	O
(	O
pattern	*(struct)
->	O
edge_constraints	int
&	O
SOUTH_EDGE	int
)	O
pattern	*(struct)
->	O
mini	int
=	O
pattern	*(struct)
->	O
maxi	int
-	O
pattern	*(struct)
->	O
height	int
;	O
if	O
(	O
pattern	*(struct)
->	O
edge_constraints	int
&	O
WEST_EDGE	int
)	O
pattern	*(struct)
->	O
maxj	int
=	O
pattern	*(struct)
->	O
minj	int
+	O
pattern	*(struct)
->	O
width	long
;	O
if	O
(	O
pattern	*(struct)
->	O
edge_constraints	int
&	O
EAST_EDGE	int
)	O
pattern	*(struct)
->	O
minj	int
=	O
pattern	*(struct)
->	O
maxj	int
-	O
pattern	*(struct)
->	O
width	long
;	O
if	O
(	O
pattern	*(struct)
->	O
edge_constraints	int
&	O
NORTH_EDGE	int
)	O
if	O
(	O
pattern	*(struct)
->	O
maxi	int
<	O
(	O
board_size	int
-	O
1	int
)	O
+	O
pattern	*(struct)
->	O
mini	int
)	O
pattern	*(struct)
->	O
maxi	int
=	O
(	O
board_size	int
-	O
1	int
)	O
+	O
pattern	*(struct)
->	O
mini	int
;	O
if	O
(	O
pattern	*(struct)
->	O
edge_constraints	int
&	O
SOUTH_EDGE	int
)	O
if	O
(	O
pattern	*(struct)
->	O
mini	int
>	O
pattern	*(struct)
->	O
maxi	int
-	O
(	O
board_size	int
-	O
1	int
)	O
)	O
pattern	*(struct)
->	O
mini	int
=	O
pattern	*(struct)
->	O
maxi	int
-	O
(	O
board_size	int
-	O
1	int
)	O
;	O
if	O
(	O
pattern	*(struct)
->	O
edge_constraints	int
&	O
WEST_EDGE	int
)	O
if	O
(	O
pattern	*(struct)
->	O
maxj	int
<	O
(	O
board_size	int
-	O
1	int
)	O
+	O
pattern	*(struct)
->	O
minj	int
)	O
pattern	*(struct)
->	O
maxj	int
=	O
(	O
board_size	int
-	O
1	int
)	O
+	O
pattern	*(struct)
->	O
minj	int
;	O
if	O
(	O
pattern	*(struct)
->	O
edge_constraints	int
&	O
EAST_EDGE	int
)	O
if	O
(	O
pattern	*(struct)
->	O
minj	int
>	O
pattern	*(struct)
->	O
maxj	int
-	O
(	O
board_size	int
-	O
1	int
)	O
)	O
pattern	*(struct)
->	O
minj	int
=	O
pattern	*(struct)
->	O
maxj	int
-	O
(	O
board_size	int
-	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
prepare_for_match	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
gg_assert	O
(	O
color	int
!=	O
EMPTY	int
)	O
;	O
class_mask	array(array(int))
[	O
DEAD	int
]	O
[	O
color	int
]	O
=	O
CLASS_O	int
;	O
class_mask	array(array(int))
[	O
DEAD	int
]	O
[	O
other	int
]	O
=	O
CLASS_X	int
;	O
class_mask	array(array(int))
[	O
CRITICAL	int
]	O
[	O
color	int
]	O
=	O
CLASS_O	int
;	O
class_mask	array(array(int))
[	O
CRITICAL	int
]	O
[	O
other	int
]	O
=	O
0	int
;	O
class_mask	array(array(int))
[	O
ALIVE	int
]	O
[	O
color	int
]	O
=	O
CLASS_o	int
;	O
class_mask	array(array(int))
[	O
ALIVE	int
]	O
[	O
other	int
]	O
=	O
CLASS_x	int
;	O
}	O
static	O
void	O
do_matchpat	(int,*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(void),array(char))->(void)
(	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
const	O
int	O
anchor_test	int
=	O
board	*(char)
[	O
anchor	int
]	O
^	O
color	int
;	O
int	O
m	int
=	O
I	O
(	O
anchor	int
)	O
;	O
int	O
n	int
=	O
J	O
(	O
anchor	int
)	O
;	O
int	O
merged_val	int
;	O
ASSERT_ON_BOARD1	O
(	O
anchor	int
)	O
;	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
shift	int
=	O
30	int
;	O
merged_val	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
m	int
-	O
1	int
;	O
i	int
<=	O
m	int
+	O
2	int
;	O
++	O
i	int
)	O
for	O
(	O
j	int
=	O
n	int
-	O
1	int
;	O
j	int
<=	O
n	int
+	O
2	int
;	O
shift	int
-=	O
2	int
,	O
++	O
j	int
)	O
{	O
unsigned	O
int	O
this	int
;	O
if	O
(	O
!	O
ON_BOARD2	O
(	O
i	int
,	O
j	int
)	O
)	O
this	int
=	O
3	int
;	O
else	O
if	O
(	O
(	O
this	int
=	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
)	O
==	O
0	int
)	O
continue	O
;	O
else	O
if	O
(	O
color	int
==	O
2	int
)	O
this	int
=	O
OTHER_COLOR	O
(	O
this	int
)	O
;	O
merged_val	int
|=	O
(	O
this	int
<<	O
shift	int
)	O
;	O
}	O
}	O
gg_assert	O
(	O
pattern	*(struct)
->	O
patn	*(struct(short,char))
)	O
;	O
do	O
{	O
{	O
int	O
end_transformation	int
;	O
int	O
ll	int
;	O
int	O
k	int
;	O
int	O
found_goal	int
;	O
if	O
(	O
anchor_test	int
!=	O
pattern	*(struct)
->	O
anchored_at_X	int
)	O
continue	O
;	O
ll	int
=	O
0	int
;	O
end_transformation	int
=	O
pattern	*(struct)
->	O
trfno	int
;	O
if	O
(	O
pattern	*(struct)
->	O
trfno	int
==	O
5	int
)	O
{	O
ll	int
=	O
2	int
;	O
end_transformation	int
=	O
6	int
;	O
}	O
do	O
{	O
if	O
(	O
(	O
merged_val	int
&	O
pattern	*(struct)
->	O
and_mask	array(int)
[	O
ll	int
]	O
)	O
!=	O
pattern	*(struct)
->	O
val_mask	array(int)
[	O
ll	int
]	O
)	O
continue	O
;	O
{	O
int	O
mi	int
,	O
mj	int
,	O
xi	int
,	O
xj	int
;	O
TRANSFORM2	O
(	O
pattern	*(struct)
->	O
mini	int
,	O
pattern	*(struct)
->	O
minj	int
,	O
&	O
mi	int
,	O
&	O
mj	int
,	O
ll	int
)	O
;	O
TRANSFORM2	O
(	O
pattern	*(struct)
->	O
maxi	int
,	O
pattern	*(struct)
->	O
maxj	int
,	O
&	O
xi	int
,	O
&	O
xj	int
,	O
ll	int
)	O
;	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"---\nconsidering pattern '%s', rotation %d at %1m. Range %d,%d -> %d,%d\n"	*(char)
,	O
pattern	*(struct)
->	O
name	short
,	O
ll	int
,	O
anchor	int
,	O
mi	int
,	O
mj	int
,	O
xi	int
,	O
xj	int
)	O
;	O
if	O
(	O
!	O
ON_BOARD2	O
(	O
m	int
+	O
mi	int
,	O
n	int
+	O
mj	int
)	O
||	O
!	O
ON_BOARD2	O
(	O
m	int
+	O
xi	int
,	O
n	int
+	O
xj	int
)	O
)	O
continue	O
;	O
}	O
found_goal	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	*(struct)
->	O
patlen	int
;	O
++	O
k	int
)	O
{	O
int	O
pos	int
;	O
int	O
att	char
=	O
pattern	*(struct)
->	O
patn	*(struct(short,char))
[	O
k	int
]	O
.	O
att	char
;	O
pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	*(struct)
->	O
patn	*(struct(short,char))
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
(	O
board	*(char)
[	O
pos	int
]	O
&	O
and_mask	array(int)
[	O
color	int
-	O
1	int
]	O
[	O
att	char
]	O
)	O
!=	O
val_mask	array(int)
[	O
color	int
-	O
1	int
]	O
[	O
att	char
]	O
)	O
goto	O
match_failed	O
;	O
if	O
(	O
goal	*(char)
!=	O
NULL	O
&&	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
&&	O
goal	*(char)
[	O
pos	int
]	O
)	O
found_goal	int
=	O
1	int
;	O
if	O
(	O
(	O
pattern	*(struct)
->	O
class	int
&	O
class_mask	array(array(int))
[	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
[	O
board	*(char)
[	O
pos	int
]	O
]	O
)	O
!=	O
0	int
)	O
goto	O
match_failed	O
;	O
}	O
if	O
(	O
(	O
goal	*(char)
!=	O
NULL	O
)	O
&&	O
!	O
found_goal	int
)	O
goto	O
match_failed	O
;	O
callback	*((int,int,*(struct),int,*(void))->(void))
(	O
anchor	int
,	O
color	int
,	O
pattern	*(struct)
,	O
ll	int
,	O
callback_data	*(void)
)	O
;	O
match_failed	O
:	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"end of pattern '%s', rotation %d at %1m\n---\n"	*(char)
,	O
pattern	*(struct)
->	O
name	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
}	O
while	O
(	O
++	O
ll	int
<	O
end_transformation	int
)	O
;	O
}	O
}	O
while	O
(	O
(	O
++	O
pattern	*(struct)
)	O
->	O
patn	*(struct(short,char))
)	O
;	O
}	O
static	O
void	O
matchpat_loop	(*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,int,*(struct(int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),*(struct(array(char),*`,*`)))),*(void),array(char),int)->(void)
(	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
int	O
anchor	int
,	O
struct	O
pattern_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
*	O
pdb	*(struct)
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
anchor	int
&&	O
(	O
!	O
anchor_in_goal	int
||	O
goal	*(char)
[	O
pos	int
]	O
!=	O
0	int
)	O
)	O
do_matchpat	(int,*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(void),array(char))->(void)
(	O
pos	int
,	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
color	int
,	O
pdb	*(struct)
->	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
,	O
callback_data	*(void)
,	O
goal	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
dfa_board_size	int
=	O
-	O
1	int
;	O
static	O
int	O
dfa_p	array(int)
[	O
DFA_BASE	O
*	O
DFA_BASE	O
]	O
;	O
static	O
const	O
int	O
convert	array(array(int))
[	O
3	int
]	O
[	O
4	int
]	O
=	O
{	O
{	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
}	O
,	O
{	O
EMPTY	int
,	O
WHITE	int
,	O
BLACK	int
,	O
OUT_BOARD	int
}	O
,	O
{	O
EMPTY	int
,	O
BLACK	int
,	O
WHITE	int
,	O
OUT_BOARD	int
}	O
}	O
;	O
static	O
void	O
dfa_prepare_for_match	(int)->(void)
(	O
int	O
color	int
)	O
;	O
static	O
int	O
scan_for_patterns	(*(struct(array(char),*(struct(array(short),short)),*(struct(short,short)))),int,*(int),*(int))->(int)
(	O
dfa_rt_t	struct(array(char),*(struct(array(short),short)),*(struct(short,short)))
*	O
pdfa	*(struct)
,	O
int	O
l	int
,	O
int	O
*	O
dfa_pos	*(int)
,	O
int	O
*	O
pat_list	*(int)
)	O
;	O
static	O
void	O
do_dfa_matchpat	(*(struct(array(char),*(struct(array(short),short)),*(struct(short,short)))),int,*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(void),array(char),int)->(void)
(	O
dfa_rt_t	struct(array(char),*(struct(array(short),short)),*(struct(short,short)))
*	O
pdfa	*(struct)
,	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
database	*(struct)
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
;	O
static	O
void	O
check_pattern_light	(int,*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),int,*(void),array(char),int)->(void)
(	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
,	O
int	O
ll	int
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
;	O
static	O
void	O
dfa_matchpat_loop	(*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,int,*(struct(int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),*(struct(array(char),*`,*`)))),*(void),array(char),int)->(void)
(	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
int	O
anchor	int
,	O
struct	O
pattern_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
*	O
pdb	*(struct)
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
;	O
void	O
dfa_match_init	()->(void)
(	O
void	O
)	O
{	O
build_spiral_order	()->(void)
(	O
)	O
;	O
if	O
(	O
owl_vital_apat_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
.	O
pdfa	*(struct)
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"owl_vital_apat --> using dfa\n"	*(char)
)	O
;	O
if	O
(	O
owl_attackpat_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
.	O
pdfa	*(struct)
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"owl_attackpat --> using dfa\n"	*(char)
)	O
;	O
if	O
(	O
owl_defendpat_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
.	O
pdfa	*(struct)
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"owl_defendpat --> using dfa\n"	*(char)
)	O
;	O
if	O
(	O
pat_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
.	O
pdfa	*(struct)
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"pat --> using dfa\n"	*(char)
)	O
;	O
if	O
(	O
attpat_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
.	O
pdfa	*(struct)
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"attpat --> using dfa\n"	*(char)
)	O
;	O
if	O
(	O
defpat_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
.	O
pdfa	*(struct)
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"defpat --> using dfa\n"	*(char)
)	O
;	O
if	O
(	O
endpat_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
.	O
pdfa	*(struct)
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"endpat --> using dfa\n"	*(char)
)	O
;	O
if	O
(	O
conn_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
.	O
pdfa	*(struct)
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"conn --> using dfa\n"	*(char)
)	O
;	O
if	O
(	O
influencepat_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
.	O
pdfa	*(struct)
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"influencepat --> using dfa\n"	*(char)
)	O
;	O
if	O
(	O
barrierspat_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
.	O
pdfa	*(struct)
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"barrierspat --> using dfa\n"	*(char)
)	O
;	O
if	O
(	O
fusekipat_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
.	O
pdfa	*(struct)
!=	O
NULL	O
)	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"barrierspat --> using dfa\n"	*(char)
)	O
;	O
dfa_board_size	int
=	O
-	O
1	int
;	O
}	O
static	O
void	O
dfa_prepare_for_match	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
pos	int
;	O
if	O
(	O
dfa_board_size	int
!=	O
board_size	int
)	O
{	O
dfa_board_size	int
=	O
board_size	int
;	O
for	O
(	O
pos	int
=	O
0	int
;	O
pos	int
<	O
DFA_BASE	O
*	O
DFA_BASE	O
;	O
pos	int
++	O
)	O
dfa_p	array(int)
[	O
pos	int
]	O
=	O
OUT_BOARD	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dfa_board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dfa_board_size	int
;	O
j	int
++	O
)	O
dfa_p	array(int)
[	O
DFA_POS	O
(	O
i	int
,	O
j	int
)	O
]	O
=	O
EXPECTED_COLOR	O
(	O
color	int
,	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
prepare_for_match	(int)->(void)
(	O
color	int
)	O
;	O
}	O
static	O
int	O
scan_for_patterns	(*(struct(array(char),*(struct(array(short),short)),*(struct(short,short)))),int,*(int),*(int))->(int)
(	O
dfa_rt_t	struct(array(char),*(struct(array(short),short)),*(struct(short,short)))
*	O
pdfa	*(struct)
,	O
int	O
l	int
,	O
int	O
*	O
dfa_pos	*(int)
,	O
int	O
*	O
pat_list	*(int)
)	O
{	O
int	O
delta	array(int)
;	O
int	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
=	O
1	int
;	O
int	O
row	int
=	O
0	int
;	O
int	O
id	int
=	O
0	int
;	O
do	O
{	O
int	O
att	char
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
.	O
att	char
;	O
while	O
(	O
att	char
!=	O
0	int
)	O
{	O
pat_list	*(int)
[	O
id	int
]	O
=	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
att	char
]	O
.	O
val	long
;	O
id	int
++	O
;	O
att	char
=	O
pdfa	*(struct)
->	O
indexes	*(struct(short,short))
[	O
att	char
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
;	O
}	O
delta	array(int)
=	O
pdfa	*(struct)
->	O
states	*(struct(array(short),short))
[	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
]	O
.	O
next	*(struct(*(struct(*(struct`),short,*(char))),short,*(char)))
[	O
dfa_pos	*(int)
[	O
spiral	array(array(int))
[	O
row	int
]	O
[	O
l	int
]	O
]	O
]	O
;	O
state	*(struct(int,array(char),int,int,int,array(char),int,int,int,array(int),array(int),array(struct(array(long))),int,float,int,int))
+=	O
delta	array(int)
;	O
row	int
++	O
;	O
}	O
while	O
(	O
delta	array(int)
!=	O
0	int
)	O
;	O
return	O
id	int
;	O
}	O
static	O
void	O
do_dfa_matchpat	(*(struct(array(char),*(struct(array(short),short)),*(struct(short,short)))),int,*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(void),array(char),int)->(void)
(	O
dfa_rt_t	struct(array(char),*(struct(array(short),short)),*(struct(short,short)))
*	O
pdfa	*(struct)
,	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
database	*(struct)
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
{	O
int	O
k	int
;	O
int	O
ll	int
;	O
int	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
[	O
DFA_MAX_MATCHED	O
+	O
8	int
]	O
;	O
int	O
num_matched	int
=	O
0	int
;	O
int	O
*	O
dfa_pos	*(int)
=	O
dfa_p	array(int)
+	O
DFA_POS	O
(	O
I	O
(	O
anchor	int
)	O
,	O
J	O
(	O
anchor	int
)	O
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
anchor	int
)	O
;	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
ll	int
++	O
)	O
{	O
num_matched	int
+=	O
scan_for_patterns	(*(struct(array(char),*(struct(array(short),short)),*(struct(short,short)))),int,*(int),*(int))->(int)
(	O
pdfa	*(struct)
,	O
ll	int
,	O
dfa_pos	*(int)
,	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
+	O
num_matched	int
)	O
;	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
[	O
num_matched	int
++	O
]	O
=	O
-	O
1	int
;	O
}	O
ASSERT1	O
(	O
num_matched	int
<=	O
DFA_MAX_MATCHED	O
+	O
8	int
,	O
anchor	int
)	O
;	O
for	O
(	O
ll	int
=	O
0	int
,	O
k	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
matched	int
;	O
if	O
(	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
[	O
k	int
]	O
==	O
-	O
1	int
)	O
{	O
ll	int
++	O
;	O
continue	O
;	O
}	O
matched	int
=	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
[	O
k	int
]	O
;	O
check_pattern_light	(int,*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),int,*(void),array(char),int)->(void)
(	O
anchor	int
,	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
color	int
,	O
database	*(struct)
+	O
matched	int
,	O
ll	int
,	O
callback_data	*(void)
,	O
goal	*(char)
,	O
anchor_in_goal	int
)	O
;	O
}	O
}	O
static	O
void	O
check_pattern_light	(int,*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),int,*(void),array(char),int)->(void)
(	O
int	O
anchor	int
,	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
,	O
int	O
ll	int
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
{	O
int	O
k	int
;	O
int	O
found_goal	int
=	O
0	int
;	O
if	O
(	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"check_pattern_light @ %1m rot:%d pattern: %s\n"	*(char)
,	O
anchor	int
,	O
ll	int
,	O
pattern	*(struct)
->	O
name	short
)	O
;	O
if	O
(	O
pattern	*(struct)
->	O
trfno	int
==	O
5	int
)	O
{	O
if	O
(	O
ll	int
<	O
2	int
||	O
ll	int
>=	O
6	int
)	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
ll	int
>=	O
pattern	*(struct)
->	O
trfno	int
)	O
return	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	*(struct)
->	O
patlen	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
;	O
pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	*(struct)
->	O
patn	*(struct(short,char))
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
!	O
anchor_in_goal	int
)	O
{	O
if	O
(	O
goal	*(char)
!=	O
NULL	O
&&	O
board	*(char)
[	O
pos	int
]	O
!=	O
EMPTY	int
&&	O
goal	*(char)
[	O
pos	int
]	O
)	O
found_goal	int
=	O
1	int
;	O
}	O
ASSERT1	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
<	O
4	int
,	O
anchor	int
)	O
;	O
if	O
(	O
(	O
pattern	*(struct)
->	O
class	int
&	O
class_mask	array(array(int))
[	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
]	O
[	O
board	*(char)
[	O
pos	int
]	O
]	O
)	O
!=	O
0	int
)	O
goto	O
match_failed	O
;	O
}	O
if	O
(	O
!	O
anchor_in_goal	int
)	O
{	O
if	O
(	O
goal	*(char)
!=	O
NULL	O
&&	O
!	O
found_goal	int
)	O
goto	O
match_failed	O
;	O
}	O
callback	*((int,int,*(struct),int,*(void))->(void))
(	O
anchor	int
,	O
color	int
,	O
pattern	*(struct)
,	O
ll	int
,	O
callback_data	*(void)
)	O
;	O
match_failed	O
:	O
DEBUG	O
(	O
DEBUG_MATCHER	int
,	O
"end of pattern '%s', rotation %d at %1m\n---\n"	*(char)
,	O
pattern	*(struct)
->	O
name	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
}	O
static	O
void	O
dfa_matchpat_loop	(*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,int,*(struct(int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),*(struct(array(char),*`,*`)))),*(void),array(char),int)->(void)
(	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
int	O
anchor	int
,	O
struct	O
pattern_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
*	O
pdb	*(struct)
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
anchor	int
&&	O
(	O
!	O
anchor_in_goal	int
||	O
goal	*(char)
[	O
pos	int
]	O
!=	O
0	int
)	O
)	O
do_dfa_matchpat	(*(struct(array(char),*(struct(array(short),short)),*(struct(short,short)))),int,*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(void),array(char),int)->(void)
(	O
pdb	*(struct)
->	O
pdfa	*(struct)
,	O
pos	int
,	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
color	int
,	O
pdb	*(struct)
->	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
,	O
callback_data	*(void)
,	O
goal	*(char)
,	O
anchor_in_goal	int
)	O
;	O
}	O
}	O
typedef	O
void	O
(	O
*	O
loop_fn_ptr_t	*((*((int,int,*(struct`),int,*(void))->(void)),int,int,*(struct(int,int,*(struct`),*(struct`))),*(void),array(char),int)->(void))
)	O
(	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
int	O
anchor	int
,	O
struct	O
pattern_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
*	O
pdb	*(struct)
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
;	O
typedef	O
void	O
(	O
*	O
prepare_fn_ptr_t	*((int)->(void))
)	O
(	O
int	O
color	int
)	O
;	O
void	O
matchpat	(*((int,int,*(struct),int,*(void))->(void)),int,*(struct),*(void),array(char))->(void)
(	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
struct	O
pattern_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
*	O
pdb	*(struct)
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
matchpat_goal_anchor	(*((int,int,*(struct),int,*(void))->(void)),int,*(struct),*(void),array(char),int)->(void)
(	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
color	int
,	O
pdb	*(struct)
,	O
callback_data	*(void)
,	O
goal	*(char)
,	O
pdb	*(struct)
->	O
fixed_anchor	int
)	O
;	O
}	O
void	O
matchpat_goal_anchor	(*((int,int,*(struct),int,*(void))->(void)),int,*(struct),*(void),array(char),int)->(void)
(	O
matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(void))->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
struct	O
pattern_db	struct(int,int,*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)),*(struct))
*	O
pdb	*(struct)
,	O
void	O
*	O
callback_data	*(void)
,	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
anchor_in_goal	int
)	O
{	O
loop_fn_ptr_t	*((*((int,int,*(struct`),int,*(void))->(void)),int,int,*(struct(int,int,*(struct`),*(struct`))),*(void),array(char),int)->(void))
loop	*((*((int,int,*(struct`),int,*(void))->(void)),int,int,*(struct(int,int,*(struct`),*(struct`))),*(void),array(char),int)->(void))
=	O
matchpat_loop	(*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,int,*(struct(int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),*(struct(array(char),*`,*`)))),*(void),array(char),int)->(void)
;	O
prepare_fn_ptr_t	*((int)->(void))
prepare	*((int)->(void))
=	O
prepare_for_match	(int)->(void)
;	O
if	O
(	O
pdb	*(struct)
->	O
fixed_for_size	int
!=	O
board_size	int
)	O
{	O
fixup_patterns_for_board_size	(*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union`)),int,*((*`,int,int,int)->(int)),*((int,int,int,int)->(int)),int,float)))->(void)
(	O
pdb	*(struct)
->	O
patterns	*(struct(*(struct(short,char)),int,int,*(char),int,int,int,int,int,int,int,int,array(int),array(int),int,float,*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((*(struct`),int,int,int)->(int)),*((int,int,int,int)->(int)),int,float))
)	O
;	O
pdb	*(struct)
->	O
fixed_for_size	int
=	O
board_size	int
;	O
}	O
if	O
(	O
pdb	*(struct)
->	O
pdfa	*(struct)
!=	O
NULL	O
)	O
{	O
loop	*((*((int,int,*(struct`),int,*(void))->(void)),int,int,*(struct(int,int,*(struct`),*(struct`))),*(void),array(char),int)->(void))
=	O
dfa_matchpat_loop	(*((int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),int,*(void))->(void)),int,int,*(struct(int,int,*(struct(*`,int,int,*`,int,int,int,int,int,int,int,int,array(int),array(int),int,float,*`,int,*`,*`,int,float)),*(struct(array(char),*`,*`)))),*(void),array(char),int)->(void)
;	O
prepare	*((int)->(void))
=	O
dfa_prepare_for_match	(int)->(void)
;	O
}	O
switch	O
(	O
color	int
)	O
{	O
case	O
ANCHOR_COLOR	int
:	O
{	O
prepare	*((int)->(void))
(	O
WHITE	int
)	O
;	O
loop	*((*((int,int,*(struct`),int,*(void))->(void)),int,int,*(struct(int,int,*(struct`),*(struct`))),*(void),array(char),int)->(void))
(	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
WHITE	int
,	O
WHITE	int
,	O
pdb	*(struct)
,	O
callback_data	*(void)
,	O
goal	*(char)
,	O
anchor_in_goal	int
)	O
;	O
prepare	*((int)->(void))
(	O
BLACK	int
)	O
;	O
loop	*((*((int,int,*(struct`),int,*(void))->(void)),int,int,*(struct(int,int,*(struct`),*(struct`))),*(void),array(char),int)->(void))
(	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
BLACK	int
,	O
BLACK	int
,	O
pdb	*(struct)
,	O
callback_data	*(void)
,	O
goal	*(char)
,	O
anchor_in_goal	int
)	O
;	O
}	O
break	O
;	O
case	O
ANCHOR_OTHER	int
:	O
{	O
prepare	*((int)->(void))
(	O
WHITE	int
)	O
;	O
loop	*((*((int,int,*(struct`),int,*(void))->(void)),int,int,*(struct(int,int,*(struct`),*(struct`))),*(void),array(char),int)->(void))
(	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
WHITE	int
,	O
BLACK	int
,	O
pdb	*(struct)
,	O
callback_data	*(void)
,	O
goal	*(char)
,	O
anchor_in_goal	int
)	O
;	O
prepare	*((int)->(void))
(	O
BLACK	int
)	O
;	O
loop	*((*((int,int,*(struct`),int,*(void))->(void)),int,int,*(struct(int,int,*(struct`),*(struct`))),*(void),array(char),int)->(void))
(	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
BLACK	int
,	O
WHITE	int
,	O
pdb	*(struct)
,	O
callback_data	*(void)
,	O
goal	*(char)
,	O
anchor_in_goal	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
{	O
prepare	*((int)->(void))
(	O
color	int
)	O
;	O
loop	*((*((int,int,*(struct`),int,*(void))->(void)),int,int,*(struct(int,int,*(struct`),*(struct`))),*(void),array(char),int)->(void))
(	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
color	int
,	O
WHITE	int
,	O
pdb	*(struct)
,	O
callback_data	*(void)
,	O
goal	*(char)
,	O
anchor_in_goal	int
)	O
;	O
loop	*((*((int,int,*(struct`),int,*(void))->(void)),int,int,*(struct(int,int,*(struct`),*(struct`))),*(void),array(char),int)->(void))
(	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
color	int
,	O
BLACK	int
,	O
pdb	*(struct)
,	O
callback_data	*(void)
,	O
goal	*(char)
,	O
anchor_in_goal	int
)	O
;	O
}	O
}	O
}	O
static	O
int	O
fullboard_transform	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
trans	int
)	O
{	O
int	O
dx	int
=	O
I	O
(	O
pos	int
)	O
-	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
;	O
int	O
dy	int
=	O
J	O
(	O
pos	int
)	O
-	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
;	O
int	O
x	int
,	O
y	int
;	O
gg_assert	O
(	O
POS	O
(	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
,	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
)	O
+	O
DELTA	O
(	O
dx	int
,	O
dy	int
)	O
==	O
pos	int
)	O
;	O
TRANSFORM2	O
(	O
dx	int
,	O
dy	int
,	O
&	O
x	int
,	O
&	O
y	int
,	O
trans	int
)	O
;	O
return	O
POS	O
(	O
x	int
+	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
,	O
y	int
+	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
)	O
;	O
}	O
void	O
fullboard_matchpat	(*((int,*(struct),int)->(void)),int,*(struct))->(void)
(	O
fullboard_matchpat_callback_fn_ptr	*((int,*(struct),int)->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
struct	O
fullboard_pattern	struct(struct(array(long)),int,*(char),int,int)
*	O
pattern	*(struct)
)	O
{	O
int	O
ll	int
;	O
int	O
number_of_stones_on_board	int
=	O
stones_on_board	(int)->(int)
(	O
BLACK	int
|	O
WHITE	int
)	O
;	O
static	O
int	O
color_map	array(int)
[	O
gg_max	O
(	O
WHITE	int
,	O
BLACK	int
)	O
+	O
1	int
]	O
;	O
Hash_data	struct(array(long))
current_board_hash	array(struct(array(long)))
[	O
8	int
]	O
;	O
gg_assert	O
(	O
color	int
!=	O
EMPTY	int
)	O
;	O
gg_assert	O
(	O
board_size	int
%	O
2	int
==	O
1	int
)	O
;	O
color_map	array(int)
[	O
EMPTY	int
]	O
=	O
EMPTY	int
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
{	O
color_map	array(int)
[	O
WHITE	int
]	O
=	O
WHITE	int
;	O
color_map	array(int)
[	O
BLACK	int
]	O
=	O
BLACK	int
;	O
}	O
else	O
{	O
color_map	array(int)
[	O
WHITE	int
]	O
=	O
BLACK	int
;	O
color_map	array(int)
[	O
BLACK	int
]	O
=	O
WHITE	int
;	O
}	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
ll	int
++	O
)	O
{	O
Intersection	char
p	array(char)
[	O
BOARDSIZE	O
]	O
;	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
0	int
;	O
pos	int
<	O
BOARDSIZE	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
p	array(char)
[	O
pos	int
]	O
=	O
color_map	array(int)
[	O
board	*(char)
[	O
fullboard_transform	(int,int)->(int)
(	O
pos	int
,	O
ll	int
)	O
]	O
]	O
;	O
else	O
p	array(char)
[	O
pos	int
]	O
=	O
GRAY	int
;	O
if	O
(	O
ON_BOARD	O
(	O
board_ko_pos	int
)	O
)	O
hashdata_recalc	(*(struct(array(long))),*(char),int)->(void)
(	O
&	O
current_board_hash	array(struct(array(long)))
[	O
ll	int
]	O
,	O
p	array(char)
,	O
fullboard_transform	(int,int)->(int)
(	O
board_ko_pos	int
,	O
ll	int
)	O
)	O
;	O
else	O
hashdata_recalc	(*(struct(array(long))),*(char),int)->(void)
(	O
&	O
current_board_hash	array(struct(array(long)))
[	O
ll	int
]	O
,	O
p	array(char)
,	O
NO_MOVE	O
)	O
;	O
}	O
for	O
(	O
;	O
pattern	*(struct)
->	O
name	short
;	O
pattern	*(struct)
++	O
)	O
{	O
if	O
(	O
pattern	*(struct)
->	O
number_of_stones	int
!=	O
number_of_stones_on_board	int
)	O
continue	O
;	O
for	O
(	O
ll	int
=	O
0	int
;	O
ll	int
<	O
8	int
;	O
ll	int
++	O
)	O
if	O
(	O
hashdata_is_equal	O
(	O
current_board_hash	array(struct(array(long)))
[	O
ll	int
]	O
,	O
pattern	*(struct)
->	O
fullboard_hash	struct(array(long))
)	O
)	O
{	O
int	O
pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	*(struct)
->	O
move_offset	int
,	O
ll	int
,	O
POS	O
(	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
,	O
(	O
board_size	int
-	O
1	int
)	O
/	O
2	int
)	O
)	O
;	O
callback	*((int,int,*(struct),int,*(void))->(void))
(	O
pos	int
,	O
pattern	*(struct)
,	O
ll	int
)	O
;	O
}	O
}	O
}	O
static	O
const	O
int	O
corner_x	array(int)
[	O
8	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
const	O
int	O
corner_y	array(int)
[	O
8	int
]	O
=	O
{	O
0	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
1	int
}	O
;	O
static	O
int	O
num_stones	int
[	O
2	int
*	O
BOARDMAX	O
]	O
;	O
static	O
int	O
pattern_stones	array(int)
[	O
BOARDMAX	O
]	O
;	O
static	O
void	O
do_corner_matchpat	(int,*(struct(int,char,char,char,*(struct(int,char,char,char,*`,*`)),*(struct(int,int,int,*`,*`,int,*`)))),int,*((int,int,*(struct(int,int,int,*`,*`,int,*`)),int,*(int),int)->(void)),int,int,int,int)->(void)
(	O
int	O
num_variations	char
,	O
struct	O
corner_variation	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct))),*(struct))
*	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
,	O
int	O
match_color	int
,	O
corner_matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(int),int)->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
callback_color	int
,	O
int	O
trans	int
,	O
int	O
anchor	int
,	O
int	O
stones	*(int)
)	O
{	O
for	O
(	O
;	O
--	O
num_variations	char
>=	O
0	int
;	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
++	O
)	O
{	O
int	O
move	*(int)
=	O
AFFINE_TRANSFORM	O
(	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
->	O
move_offset	int
,	O
trans	int
,	O
anchor	int
)	O
;	O
int	O
color_check	int
=	O
match_color	int
^	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
->	O
xor_att	char
;	O
struct	O
corner_pattern	struct(int,int,int,*(char),*(struct(enum(int,int,int,int,int,int,int,int,int,int,int,int,int),union(float,int))),int,*((int,int,int,int)->(int)))
*	O
pattern	*(struct)
=	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
->	O
pattern	*(struct)
;	O
if	O
(	O
pattern	*(struct)
&&	O
color_check	int
==	O
callback_color	int
)	O
{	O
int	O
second_corner	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	*(struct)
->	O
second_corner_offset	int
,	O
trans	int
,	O
anchor	int
)	O
;	O
if	O
(	O
NUM_STONES	O
(	O
second_corner	int
)	O
==	O
stones	*(int)
&&	O
(	O
!	O
pattern	*(struct)
->	O
symmetric	int
||	O
trans	int
<	O
4	int
)	O
)	O
{	O
ASSERT1	O
(	O
board	*(char)
[	O
move	*(int)
]	O
==	O
EMPTY	int
,	O
move	*(int)
)	O
;	O
callback	*((int,int,*(struct),int,*(void))->(void))
(	O
move	*(int)
,	O
callback_color	int
,	O
pattern	*(struct)
,	O
trans	int
,	O
pattern_stones	array(int)
,	O
stones	*(int)
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
->	O
num_variations	char
&&	O
NUM_STONES	O
(	O
move	*(int)
)	O
==	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
->	O
num_stones	int
&&	O
board	*(char)
[	O
move	*(int)
]	O
==	O
color_check	int
)	O
{	O
pattern_stones	array(int)
[	O
stones	*(int)
]	O
=	O
move	*(int)
;	O
do_corner_matchpat	(int,*(struct(int,char,char,char,*(struct(int,char,char,char,*`,*`)),*(struct(int,int,int,*`,*`,int,*`)))),int,*((int,int,*(struct(int,int,int,*`,*`,int,*`)),int,*(int),int)->(void)),int,int,int,int)->(void)
(	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
->	O
num_variations	char
,	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
->	O
variations	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct)))
,	O
match_color	int
,	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
callback_color	int
,	O
trans	int
,	O
anchor	int
,	O
stones	*(int)
+	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
corner_matchpat	(*((int,int,*(struct),int,*(int),int)->(void)),int,*(struct))->(void)
(	O
corner_matchpat_callback_fn_ptr	*((int,int,*(struct),int,*(int),int)->(void))
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
int	O
color	int
,	O
struct	O
corner_db	struct(int,int,char,*(struct))
*	O
database	*(struct)
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
anchor	int
=	O
POS	O
(	O
corner_x	array(int)
[	O
k	int
]	O
*	O
(	O
board_size	int
-	O
1	int
)	O
,	O
corner_y	array(int)
[	O
k	int
]	O
*	O
(	O
board_size	int
-	O
1	int
)	O
)	O
;	O
int	O
i	int
;	O
int	O
j	int
;	O
int	O
dx	int
=	O
TRANSFORM	O
(	O
OFFSET	O
(	O
1	int
,	O
0	int
)	O
,	O
k	int
)	O
;	O
int	O
dy	int
=	O
TRANSFORM	O
(	O
OFFSET	O
(	O
0	int
,	O
1	int
)	O
,	O
k	int
)	O
;	O
int	O
pos	int
;	O
struct	O
corner_variation	struct(int,char,char,char,*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct))),*(struct))
*	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
=	O
database	*(struct)
->	O
top_variations	*(struct)
;	O
NUM_STONES	O
(	O
anchor	int
)	O
=	O
IS_STONE	O
(	O
board	*(char)
[	O
anchor	int
]	O
)	O
;	O
pos	int
=	O
anchor	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
database	*(struct)
->	O
max_height	int
;	O
i	int
++	O
)	O
{	O
pos	int
+=	O
dx	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
do	O
{	O
NUM_STONES	O
(	O
pos	int
)	O
=	O
BOARDMAX	O
;	O
pos	int
+=	O
dx	int
;	O
}	O
while	O
(	O
++	O
i	int
<	O
database	*(struct)
->	O
max_height	int
)	O
;	O
break	O
;	O
}	O
NUM_STONES	O
(	O
pos	int
)	O
=	O
NUM_STONES	O
(	O
pos	int
-	O
dx	int
)	O
+	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
;	O
}	O
pos	int
=	O
anchor	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
database	*(struct)
->	O
max_width	int
;	O
j	int
++	O
)	O
{	O
pos	int
+=	O
dy	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
do	O
{	O
NUM_STONES	O
(	O
pos	int
)	O
=	O
BOARDMAX	O
;	O
pos	int
+=	O
dy	int
;	O
}	O
while	O
(	O
++	O
j	int
<	O
database	*(struct)
->	O
max_width	int
)	O
;	O
break	O
;	O
}	O
NUM_STONES	O
(	O
pos	int
)	O
=	O
NUM_STONES	O
(	O
pos	int
-	O
dy	int
)	O
+	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
database	*(struct)
->	O
max_height	int
;	O
i	int
++	O
)	O
{	O
pos	int
=	O
anchor	int
+	O
i	int
*	O
dy	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
database	*(struct)
->	O
max_width	int
;	O
j	int
++	O
)	O
{	O
pos	int
+=	O
dx	int
;	O
NUM_STONES	O
(	O
pos	int
)	O
=	O
NUM_STONES	O
(	O
pos	int
-	O
dx	int
)	O
+	O
NUM_STONES	O
(	O
pos	int
-	O
dy	int
)	O
-	O
NUM_STONES	O
(	O
pos	int
-	O
dx	int
-	O
dy	int
)	O
;	O
if	O
(	O
ON_BOARD1	O
(	O
pos	int
)	O
&&	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
)	O
NUM_STONES	O
(	O
pos	int
)	O
++	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
database	*(struct)
->	O
num_top_variations	char
;	O
i	int
++	O
)	O
{	O
int	O
move	*(int)
=	O
AFFINE_TRANSFORM	O
(	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
->	O
move_offset	int
,	O
k	int
,	O
anchor	int
)	O
;	O
if	O
(	O
NUM_STONES	O
(	O
move	*(int)
)	O
==	O
1	int
&&	O
IS_STONE	O
(	O
board	*(char)
[	O
move	*(int)
]	O
)	O
)	O
{	O
pattern_stones	array(int)
[	O
0	int
]	O
=	O
move	*(int)
;	O
do_corner_matchpat	(int,*(struct(int,char,char,char,*(struct(int,char,char,char,*`,*`)),*(struct(int,int,int,*`,*`,int,*`)))),int,*((int,int,*(struct(int,int,int,*`,*`,int,*`)),int,*(int),int)->(void)),int,int,int,int)->(void)
(	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
->	O
num_variations	char
,	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
->	O
variations	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct)))
,	O
board	*(char)
[	O
move	*(int)
]	O
,	O
callback	*((int,int,*(struct),int,*(void))->(void))
,	O
color	int
,	O
k	int
,	O
anchor	int
,	O
1	int
)	O
;	O
}	O
variation	*(struct(int,char,char,char,*(struct(int,char,char,char,*(struct`),*(struct`))),*(struct(int,int,int,*(char),*(struct`),int,*((int,int,int,int)->(int))))))
++	O
;	O
}	O
}	O
}	O
