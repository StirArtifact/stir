typedef	O
struct	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
type_end	int
;	O
int	O
parmcnt	int
;	O
int	O
line	int
;	O
enum	O
storage	enum(int,int,int,int,int)
storage	enum(int,int,int,int,int)
;	O
}	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
;	O
void	O
parse_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
,	O
int	O
)	O
;	O
void	O
parse_variable_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
,	O
int	O
)	O
;	O
void	O
parse_function_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
,	O
int	O
)	O
;	O
void	O
parse_dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
,	O
int	O
maybe_knr	int
)	O
;	O
void	O
parse_knr_dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
)	O
;	O
void	O
parse_typedef	()->(void)
(	O
)	O
;	O
void	O
expression	()->(void)
(	O
)	O
;	O
void	O
initializer_list	()->(void)
(	O
)	O
;	O
void	O
func_body	()->(void)
(	O
)	O
;	O
void	O
declare	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
,	O
int	O
maybe_knr	int
)	O
;	O
void	O
declare_type	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
)	O
;	O
int	O
dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
)	O
;	O
int	O
parmdcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
)	O
;	O
int	O
dirdcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
)	O
;	O
void	O
skip_struct	()->(void)
(	O
)	O
;	O
Symbol	struct
*	O
get_symbol	(*(char))->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
char	O
*	O
name	*(char)
)	O
;	O
void	O
maybe_parm_list	(*(int))->(void)
(	O
int	O
*	O
parm_cnt_return	*(int)
)	O
;	O
void	O
call	(*(char),int)->(void)
(	O
char	O
*	O
,	O
int	O
)	O
;	O
void	O
reference	(*(char),int)->(void)
(	O
char	O
*	O
,	O
int	O
)	O
;	O
int	O
level	int
;	O
Symbol	struct
*	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
;	O
struct	O
obstack	struct(long,*(struct(*(char),*(struct(*(char),*(struct`),array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
;	O
int	O
parm_level	int
;	O
typedef	O
struct	O
{	O
int	O
type	enum(int,int,int)
;	O
char	O
*	O
token	*(char)
;	O
int	O
line	int
;	O
}	O
TOKSTK	struct(int,*(char),int)
;	O
typedef	O
int	O
Stackpos	array(int)
[	O
1	int
]	O
;	O
TOKSTK	struct(int,*(char),int)
tok	struct(int,*(char),int)
;	O
TOKSTK	struct(int,*(char),int)
*	O
token_stack	*(struct(int,*(char),int))
;	O
int	O
tos	int
;	O
int	O
curs	int
;	O
int	O
token_stack_length	int
=	O
64	int
;	O
int	O
token_stack_increase	int
=	O
32	int
;	O
static	O
int	O
need_space	int
;	O
void	O
mark	(array(int))->(void)
(	O
Stackpos	array(int)
)	O
;	O
void	O
restore	(array(int))->(void)
(	O
Stackpos	array(int)
)	O
;	O
void	O
tokpush	(int,int,*(char))->(void)
(	O
int	O
,	O
int	O
,	O
char	O
*	O
)	O
;	O
void	O
save_token	(*(struct(int,*(char),int)))->(void)
(	O
TOKSTK	struct(int,*(char),int)
*	O
)	O
;	O
static	O
void	O
print_token	(*(struct(int,*(char),int)))->(void)
(	O
TOKSTK	struct(int,*(char),int)
*	O
tokptr	*(struct(int,*(char),int))
)	O
{	O
switch	O
(	O
tokptr	*(struct(int,*(char),int))
->	O
type	enum(int,int,int)
)	O
{	O
case	O
IDENTIFIER	int
:	O
case	O
TYPE	int
:	O
case	O
WORD	int
:	O
case	O
MODIFIER	int
:	O
case	O
STRUCT	int
:	O
case	O
PARM_WRAPPER	int
:	O
case	O
QUALIFIER	int
:	O
case	O
OP	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"`%s'"	*(char)
,	O
tokptr	*(struct(int,*(char),int))
->	O
token	*(char)
)	O
;	O
break	O
;	O
case	O
LBRACE0	int
:	O
case	O
LBRACE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"`{'"	*(char)
)	O
;	O
break	O
;	O
case	O
RBRACE0	int
:	O
case	O
RBRACE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"`}'"	*(char)
)	O
;	O
break	O
;	O
case	O
EXTERN	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"`extern'"	*(char)
)	O
;	O
break	O
;	O
case	O
STATIC	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"`static'"	*(char)
)	O
;	O
break	O
;	O
case	O
TYPEDEF	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"`typedef'"	*(char)
)	O
;	O
break	O
;	O
case	O
STRING	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\"%s\""	*(char)
,	O
tokptr	*(struct(int,*(char),int))
->	O
token	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"`%c'"	*(char)
,	O
tokptr	*(struct(int,*(char),int))
->	O
type	enum(int,int,int)
)	O
;	O
}	O
}	O
static	O
char	O
*	O
token_type_str	(int)->(*(char))
(	O
int	O
t	int
)	O
{	O
static	O
char	O
buf	array(char)
[	O
80	int
]	O
;	O
switch	O
(	O
t	int
)	O
{	O
case	O
0	int
:	O
return	O
"EOF"	*(char)
;	O
case	O
WORD	int
:	O
return	O
"WORD"	*(char)
;	O
case	O
LBRACE0	int
:	O
return	O
"'{'"	*(char)
;	O
case	O
RBRACE0	int
:	O
return	O
"'}'"	*(char)
;	O
case	O
IDENTIFIER	int
:	O
return	O
"IDENTIFIER"	*(char)
;	O
case	O
EXTERN	int
:	O
return	O
"EXTERN"	*(char)
;	O
case	O
STATIC	int
:	O
return	O
"STATIC"	*(char)
;	O
case	O
TYPEDEF	int
:	O
return	O
"TYPEDEF"	*(char)
;	O
case	O
STRUCT	int
:	O
return	O
"STRUCT"	*(char)
;	O
case	O
MODIFIER	int
:	O
return	O
"MODIFIER"	*(char)
;	O
case	O
OP	int
:	O
return	O
"OP"	*(char)
;	O
case	O
UNION	int
:	O
return	O
"UNION"	*(char)
;	O
case	O
ENUM	int
:	O
return	O
"ENUM"	*(char)
;	O
case	O
LBRACE	int
:	O
return	O
"' {'"	*(char)
;	O
case	O
RBRACE	int
:	O
return	O
"' }'"	*(char)
;	O
case	O
MEMBER_OF	int
:	O
return	O
"MEMBER_OF"	*(char)
;	O
case	O
TYPE	int
:	O
return	O
"TYPE"	*(char)
;	O
case	O
STRING	int
:	O
return	O
"STRING"	*(char)
;	O
case	O
PARM_WRAPPER	int
:	O
return	O
"PARM_WRAPPER"	*(char)
;	O
case	O
QUALIFIER	int
:	O
return	O
"QUALIFIER"	*(char)
;	O
}	O
if	O
(	O
isprint	(int)->(int)
(	O
t	int
)	O
)	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	array(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
,	O
"'%c'(%d)"	*(char)
,	O
t	int
,	O
t	int
)	O
;	O
else	O
snprintf	(*(char),long,*(char))->(int)
(	O
buf	array(char)
,	O
sizeof	O
(	O
buf	array(char)
)	O
,	O
"%d"	*(char)
,	O
t	int
)	O
;	O
return	O
buf	array(char)
;	O
}	O
static	O
void	O
dbgtok	(*(struct(int,*(char),int)),int)->(void)
(	O
TOKSTK	struct(int,*(char),int)
*	O
t	int
,	O
int	O
delim	int
)	O
{	O
if	O
(	O
delim	int
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
delim	int
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"{ %s "	*(char)
,	O
token_type_str	(int)->(*(char))
(	O
t	int
->	O
type	enum(int,int,int)
)	O
)	O
;	O
if	O
(	O
t	int
->	O
type	enum(int,int,int)
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
", %s, %d "	*(char)
,	O
t	int
->	O
token	*(char)
?	O
t	int
->	O
token	*(char)
:	O
"NULL"	*(char)
,	O
t	int
->	O
line	int
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'}'	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
debugtoken	(*(struct(int,*(char),int)),*(char))->(void)
(	O
TOKSTK	struct(int,*(char),int)
*	O
t	int
,	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
if	O
(	O
debug	int
>	O
1	int
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
ap	array(struct(int,int,*(void),*(void)))
;	O
int	O
i	long
;	O
if	O
(	O
fmt	*(char)
)	O
{	O
va_start	O
(	O
ap	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
vfprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
fmt	*(char)
,	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
ap	array(struct(int,int,*(void),*(void)))
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
": "	*(char)
)	O
;	O
}	O
if	O
(	O
t	int
)	O
{	O
dbgtok	(*(struct(int,*(char),int)),int)->(void)
(	O
t	int
,	O
0	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"; "	*(char)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%d: {"	*(char)
,	O
curs	int
)	O
;	O
for	O
(	O
i	long
=	O
curs	int
;	O
i	long
<	O
tos	int
;	O
i	long
++	O
)	O
dbgtok	(*(struct(int,*(char),int)),int)->(void)
(	O
token_stack	*(struct(int,*(char),int))
+	O
i	long
,	O
i	long
==	O
curs	int
?	O
0	int
:	O
','	O
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"}\n"	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
char	O
*	O
msg	*(char)
,	O
TOKSTK	struct(int,*(char),int)
*	O
tokptr	*(struct(int,*(char),int))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s:%d: %s"	*(char)
,	O
filename	*(char)
,	O
tok	struct(int,*(char),int)
.	O
line	int
,	O
msg	*(char)
)	O
;	O
if	O
(	O
tokptr	*(struct(int,*(char),int))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
" near "	*(char)
)	O
)	O
;	O
print_token	(*(struct(int,*(char),int)))->(void)
(	O
tokptr	*(struct(int,*(char),int))
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
void	O
mark	(array(int))->(void)
(	O
Stackpos	array(int)
pos	array(int)
)	O
{	O
pos	array(int)
[	O
0	int
]	O
=	O
curs	int
;	O
if	O
(	O
debug	int
>	O
1	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"marking stack at %d\n"	*(char)
,	O
curs	int
)	O
;	O
}	O
void	O
restore	(array(int))->(void)
(	O
Stackpos	array(int)
pos	array(int)
)	O
{	O
curs	int
=	O
pos	array(int)
[	O
0	int
]	O
;	O
if	O
(	O
curs	int
)	O
{	O
tok	struct(int,*(char),int)
=	O
token_stack	*(struct(int,*(char),int))
[	O
curs	int
-	O
1	int
]	O
;	O
debugtoken	(*(struct(int,*(char),int)),*(char))->(void)
(	O
&	O
tok	struct(int,*(char),int)
,	O
"restored stack"	*(char)
)	O
;	O
}	O
}	O
void	O
tokdel	(int,int)->(void)
(	O
int	O
beg	int
,	O
int	O
end	int
)	O
{	O
if	O
(	O
end	int
>=	O
beg	int
)	O
{	O
if	O
(	O
end	int
<	O
tos	int
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
token_stack	*(struct(int,*(char),int))
+	O
beg	int
,	O
token_stack	*(struct(int,*(char),int))
+	O
end	int
+	O
1	int
,	O
(	O
tos	int
-	O
end	int
-	O
1	int
)	O
*	O
sizeof	O
(	O
token_stack	*(struct(int,*(char),int))
[	O
0	int
]	O
)	O
)	O
;	O
tos	int
-=	O
(	O
end	int
-	O
beg	int
+	O
1	int
)	O
;	O
}	O
}	O
void	O
tokins	(int,int,int,*(char))->(void)
(	O
int	O
pos	array(int)
,	O
int	O
type	enum(int,int,int)
,	O
int	O
line	int
,	O
char	O
*	O
token	*(char)
)	O
{	O
if	O
(	O
++	O
tos	int
==	O
token_stack_length	int
)	O
{	O
token_stack_length	int
+=	O
token_stack_increase	int
;	O
token_stack	*(struct(int,*(char),int))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
token_stack	*(struct(int,*(char),int))
,	O
token_stack_length	int
*	O
sizeof	O
(	O
*	O
token_stack	*(struct(int,*(char),int))
)	O
)	O
;	O
}	O
memmove	(*(void),*(void),long)->(*(void))
(	O
token_stack	*(struct(int,*(char),int))
+	O
pos	array(int)
+	O
1	int
,	O
token_stack	*(struct(int,*(char),int))
+	O
pos	array(int)
,	O
(	O
tos	int
-	O
pos	array(int)
-	O
1	int
)	O
*	O
sizeof	O
(	O
token_stack	*(struct(int,*(char),int))
[	O
0	int
]	O
)	O
)	O
;	O
token_stack	*(struct(int,*(char),int))
[	O
pos	array(int)
]	O
.	O
type	enum(int,int,int)
=	O
type	enum(int,int,int)
;	O
token_stack	*(struct(int,*(char),int))
[	O
pos	array(int)
]	O
.	O
token	*(char)
=	O
token	*(char)
;	O
token_stack	*(struct(int,*(char),int))
[	O
pos	array(int)
]	O
.	O
line	int
=	O
line	int
;	O
debugtoken	(*(struct(int,*(char),int)),*(char))->(void)
(	O
&	O
token_stack	*(struct(int,*(char),int))
[	O
pos	array(int)
]	O
,	O
"insert at %d"	*(char)
,	O
pos	array(int)
)	O
;	O
}	O
void	O
tokpush	(int,int,*(char))->(void)
(	O
int	O
type	enum(int,int,int)
,	O
int	O
line	int
,	O
char	O
*	O
token	*(char)
)	O
{	O
token_stack	*(struct(int,*(char),int))
[	O
tos	int
]	O
.	O
type	enum(int,int,int)
=	O
type	enum(int,int,int)
;	O
token_stack	*(struct(int,*(char),int))
[	O
tos	int
]	O
.	O
token	*(char)
=	O
token	*(char)
;	O
token_stack	*(struct(int,*(char),int))
[	O
tos	int
]	O
.	O
line	int
=	O
line	int
;	O
if	O
(	O
++	O
tos	int
==	O
token_stack_length	int
)	O
{	O
token_stack_length	int
+=	O
token_stack_increase	int
;	O
token_stack	*(struct(int,*(char),int))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
token_stack	*(struct(int,*(char),int))
,	O
token_stack_length	int
*	O
sizeof	O
(	O
*	O
token_stack	*(struct(int,*(char),int))
)	O
)	O
;	O
}	O
}	O
void	O
cleanup_stack	()->(void)
(	O
)	O
{	O
int	O
delta	int
=	O
tos	int
-	O
curs	int
;	O
if	O
(	O
delta	int
>	O
0	int
)	O
memmove	(*(void),*(void),long)->(*(void))
(	O
token_stack	*(struct(int,*(char),int))
,	O
token_stack	*(struct(int,*(char),int))
+	O
curs	int
,	O
delta	int
*	O
sizeof	O
(	O
token_stack	*(struct(int,*(char),int))
[	O
0	int
]	O
)	O
)	O
;	O
else	O
if	O
(	O
delta	int
<	O
0	int
)	O
delta	int
=	O
0	int
;	O
tos	int
=	O
delta	int
;	O
curs	int
=	O
0	int
;	O
}	O
void	O
clearstack	()->(void)
(	O
)	O
{	O
tos	int
=	O
curs	int
=	O
0	int
;	O
}	O
int	O
nexttoken	()->(int)
(	O
)	O
{	O
int	O
type	enum(int,int,int)
;	O
if	O
(	O
curs	int
==	O
tos	int
)	O
{	O
type	enum(int,int,int)
=	O
get_token	()->(int)
(	O
)	O
;	O
tokpush	(int,int,*(char))->(void)
(	O
type	enum(int,int,int)
,	O
line_num	int
,	O
yylval	struct(*(char))
.	O
str	*(char)
)	O
;	O
yylval	struct(*(char))
.	O
str	*(char)
=	O
NULL	O
;	O
}	O
tok	struct(int,*(char),int)
=	O
token_stack	*(struct(int,*(char),int))
[	O
curs	int
]	O
;	O
curs	int
++	O
;	O
debugtoken	(*(struct(int,*(char),int)),*(char))->(void)
(	O
&	O
tok	struct(int,*(char),int)
,	O
"next token"	*(char)
)	O
;	O
return	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
;	O
}	O
int	O
putback	()->(int)
(	O
)	O
{	O
if	O
(	O
curs	int
==	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"INTERNAL ERROR: cannot return token to stream"	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
}	O
curs	int
--	O
;	O
if	O
(	O
curs	int
>	O
0	int
)	O
{	O
tok	struct(int,*(char),int)
=	O
token_stack	*(struct(int,*(char),int))
[	O
curs	int
-	O
1	int
]	O
;	O
}	O
else	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
=	O
0	int
;	O
debugtoken	(*(struct(int,*(char),int)),*(char))->(void)
(	O
&	O
tok	struct(int,*(char),int)
,	O
"putback"	*(char)
)	O
;	O
return	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
;	O
}	O
void	O
init_parse	()->(void)
(	O
)	O
{	O
obstack_init	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
)	O
;	O
token_stack	*(struct(int,*(char),int))
=	O
xmalloc	(long)->(*(void))
(	O
token_stack_length	int
*	O
sizeof	O
(	O
*	O
token_stack	*(struct(int,*(char),int))
)	O
)	O
;	O
clearstack	()->(void)
(	O
)	O
;	O
}	O
void	O
save_token	(*(struct(int,*(char),int)))->(void)
(	O
TOKSTK	struct(int,*(char),int)
*	O
tokptr	*(struct(int,*(char),int))
)	O
{	O
int	O
len	int
;	O
switch	O
(	O
tokptr	*(struct(int,*(char),int))
->	O
type	enum(int,int,int)
)	O
{	O
case	O
IDENTIFIER	int
:	O
case	O
TYPE	int
:	O
case	O
STRUCT	int
:	O
case	O
PARM_WRAPPER	int
:	O
case	O
WORD	int
:	O
case	O
QUALIFIER	int
:	O
if	O
(	O
need_space	int
)	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
' '	O
)	O
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
tokptr	*(struct(int,*(char),int))
->	O
token	*(char)
)	O
;	O
obstack_grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
tokptr	*(struct(int,*(char),int))
->	O
token	*(char)
,	O
len	int
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
case	O
MODIFIER	int
:	O
if	O
(	O
need_space	int
)	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
' '	O
)	O
;	O
if	O
(	O
tokptr	*(struct(int,*(char),int))
->	O
token	*(char)
[	O
0	int
]	O
==	O
'*'	O
)	O
need_space	int
=	O
0	int
;	O
else	O
need_space	int
=	O
1	int
;	O
len	int
=	O
strlen	(*(char))->(long)
(	O
tokptr	*(struct(int,*(char),int))
->	O
token	*(char)
)	O
;	O
obstack_grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
tokptr	*(struct(int,*(char),int))
->	O
token	*(char)
,	O
len	int
)	O
;	O
break	O
;	O
case	O
EXTERN	int
:	O
case	O
STATIC	int
:	O
break	O
;	O
case	O
','	O
:	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
','	O
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
case	O
'('	O
:	O
if	O
(	O
need_space	int
)	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
' '	O
)	O
;	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
tokptr	*(struct(int,*(char),int))
->	O
type	enum(int,int,int)
)	O
;	O
need_space	int
=	O
0	int
;	O
break	O
;	O
case	O
')'	O
:	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
tokptr	*(struct(int,*(char),int))
->	O
type	enum(int,int,int)
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
case	O
'['	O
:	O
case	O
']'	O
:	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
tokptr	*(struct(int,*(char),int))
->	O
type	enum(int,int,int)
)	O
;	O
need_space	int
=	O
0	int
;	O
break	O
;	O
case	O
LBRACE	int
:	O
case	O
LBRACE0	int
:	O
if	O
(	O
need_space	int
)	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
' '	O
)	O
;	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
'{'	O
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
case	O
RBRACE	int
:	O
case	O
RBRACE0	int
:	O
if	O
(	O
need_space	int
)	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
' '	O
)	O
;	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
'}'	O
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
case	O
OP	int
:	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
' '	O
)	O
;	O
obstack_grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
tokptr	*(struct(int,*(char),int))
->	O
token	*(char)
,	O
strlen	(*(char))->(long)
(	O
tokptr	*(struct(int,*(char),int))
->	O
token	*(char)
)	O
)	O
;	O
need_space	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
verbose	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unrecognized definition"	*(char)
)	O
,	O
tokptr	*(struct(int,*(char),int))
)	O
;	O
}	O
}	O
static	O
Stackpos	array(int)
start_pos	array(int)
;	O
static	O
int	O
save_end	int
;	O
void	O
save_stack	()->(void)
(	O
)	O
{	O
mark	(array(int))->(void)
(	O
start_pos	array(int)
)	O
;	O
save_end	int
=	O
curs	int
-	O
1	int
;	O
}	O
void	O
undo_save_stack	()->(void)
(	O
)	O
{	O
save_end	int
=	O
-	O
1	int
;	O
}	O
int	O
save_stack_is_empty	()->(int)
(	O
)	O
{	O
return	O
save_end	int
<=	O
0	int
;	O
}	O
char	O
*	O
finish_save_stack	(*(char))->(*(char))
(	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
i	long
;	O
int	O
level	int
=	O
0	int
;	O
int	O
found_ident	int
=	O
!	O
omit_symbol_names_option	int
;	O
need_space	int
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
save_end	int
;	O
i	long
++	O
)	O
{	O
switch	O
(	O
token_stack	*(struct(int,*(char),int))
[	O
i	long
]	O
.	O
type	enum(int,int,int)
)	O
{	O
case	O
'('	O
:	O
if	O
(	O
omit_arguments_option	int
)	O
{	O
if	O
(	O
level	int
==	O
0	int
)	O
{	O
save_token	(*(struct(int,*(char),int)))->(void)
(	O
token_stack	*(struct(int,*(char),int))
+	O
i	long
)	O
;	O
}	O
level	int
++	O
;	O
}	O
break	O
;	O
case	O
')'	O
:	O
if	O
(	O
omit_arguments_option	int
)	O
level	int
--	O
;	O
break	O
;	O
case	O
IDENTIFIER	int
:	O
if	O
(	O
!	O
found_ident	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
token_stack	*(struct(int,*(char),int))
[	O
i	long
]	O
.	O
token	*(char)
)	O
==	O
0	int
)	O
{	O
need_space	int
=	O
1	int
;	O
found_ident	int
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
level	int
==	O
0	int
)	O
save_token	(*(struct(int,*(char),int)))->(void)
(	O
token_stack	*(struct(int,*(char),int))
+	O
i	long
)	O
;	O
}	O
obstack_1grow	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
,	O
0	int
)	O
;	O
return	O
obstack_finish	O
(	O
&	O
text_stk	struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int)
)	O
;	O
}	O
void	O
skip_to	(int)->(void)
(	O
int	O
c	int
)	O
{	O
while	O
(	O
nexttoken	()->(int)
(	O
)	O
)	O
{	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
c	int
)	O
break	O
;	O
}	O
}	O
int	O
skip_balanced	(int,int,int)->(int)
(	O
int	O
open_tok	int
,	O
int	O
close_tok	int
,	O
int	O
level	int
)	O
{	O
if	O
(	O
level	int
==	O
0	int
)	O
{	O
if	O
(	O
nexttoken	()->(int)
(	O
)	O
!=	O
open_tok	int
)	O
{	O
return	O
1	int
;	O
}	O
level	int
++	O
;	O
}	O
while	O
(	O
nexttoken	()->(int)
(	O
)	O
)	O
{	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
LBRACE0	int
&&	O
open_tok	int
==	O
'{'	O
)	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
=	O
'{'	O
;	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
RBRACE0	int
&&	O
close_tok	int
==	O
'}'	O
)	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
=	O
'}'	O
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
open_tok	int
)	O
level	int
++	O
;	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
close_tok	int
)	O
{	O
if	O
(	O
--	O
level	int
==	O
0	int
)	O
{	O
nexttoken	()->(int)
(	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
yyparse	()->(int)
(	O
)	O
{	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
identifier	struct(*(char),int,int,int,enum(int,int,int,int,int))
;	O
level	int
=	O
0	int
;	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
=	O
NULL	O
;	O
clearstack	()->(void)
(	O
)	O
;	O
while	O
(	O
nexttoken	()->(int)
(	O
)	O
)	O
{	O
identifier	struct(*(char),int,int,int,enum(int,int,int,int,int))
.	O
storage	enum(int,int,int,int,int)
=	O
ExternStorage	int
;	O
switch	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
)	O
{	O
case	O
0	int
:	O
return	O
0	int
;	O
case	O
QUALIFIER	int
:	O
continue	O
;	O
case	O
TYPEDEF	int
:	O
parse_typedef	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
EXTERN	int
:	O
identifier	struct(*(char),int,int,int,enum(int,int,int,int,int))
.	O
storage	enum(int,int,int,int,int)
=	O
ExplicitExternStorage	int
;	O
parse_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
&	O
identifier	struct(*(char),int,int,int,enum(int,int,int,int,int))
,	O
0	int
)	O
;	O
break	O
;	O
case	O
STATIC	int
:	O
identifier	struct(*(char),int,int,int,enum(int,int,int,int,int))
.	O
storage	enum(int,int,int,int,int)
=	O
StaticStorage	int
;	O
nexttoken	()->(int)
(	O
)	O
;	O
default	O
:	O
parse_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
&	O
identifier	struct(*(char),int,int,int,enum(int,int,int,int,int))
,	O
0	int
)	O
;	O
break	O
;	O
}	O
cleanup_stack	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
is_function	()->(int)
(	O
)	O
{	O
Stackpos	array(int)
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
;	O
int	O
res	int
=	O
0	int
;	O
mark	(array(int))->(void)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
)	O
{	O
case	O
QUALIFIER	int
:	O
case	O
TYPE	int
:	O
case	O
IDENTIFIER	int
:	O
case	O
MODIFIER	int
:	O
case	O
STATIC	int
:	O
case	O
EXTERN	int
:	O
case	O
STRUCT	int
:	O
case	O
UNION	int
:	O
case	O
ENUM	int
:	O
nexttoken	()->(int)
(	O
)	O
;	O
continue	O
;	O
case	O
PARM_WRAPPER	int
:	O
if	O
(	O
skip_balanced	(int,int,int)->(int)
(	O
'('	O
,	O
')'	O
,	O
0	int
)	O
==	O
-	O
1	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected end of file in declaration"	*(char)
)	O
,	O
NULL	O
)	O
;	O
continue	O
;	O
case	O
'('	O
:	O
res	int
=	O
nexttoken	()->(int)
(	O
)	O
!=	O
MODIFIER	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
restore	(array(int))->(void)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
;	O
return	O
res	int
;	O
}	O
void	O
parse_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
int	O
parm	int
)	O
{	O
if	O
(	O
is_function	()->(int)
(	O
)	O
)	O
parse_function_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
parm	int
)	O
;	O
else	O
parse_variable_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
parm	int
)	O
;	O
delete_parms	(int)->(void)
(	O
parm_level	int
)	O
;	O
}	O
void	O
expression	()->(void)
(	O
)	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
line	int
;	O
int	O
parens_lev	int
;	O
parens_lev	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
)	O
{	O
case	O
';'	O
:	O
return	O
;	O
case	O
LBRACE	int
:	O
case	O
LBRACE0	int
:	O
case	O
RBRACE	int
:	O
case	O
RBRACE0	int
:	O
putback	()->(int)
(	O
)	O
;	O
return	O
;	O
case	O
','	O
:	O
if	O
(	O
parens_lev	int
==	O
0	int
)	O
return	O
;	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
verbose	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected end of file in expression"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
;	O
case	O
IDENTIFIER	int
:	O
name	*(char)
=	O
tok	struct(int,*(char),int)
.	O
token	*(char)
;	O
line	int
=	O
tok	struct(int,*(char),int)
.	O
line	int
;	O
nexttoken	()->(int)
(	O
)	O
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
'('	O
)	O
{	O
call	(*(char),int)->(void)
(	O
name	*(char)
,	O
line	int
)	O
;	O
parens_lev	int
++	O
;	O
}	O
else	O
{	O
reference	(*(char),int)->(void)
(	O
name	*(char)
,	O
line	int
)	O
;	O
while	O
(	O
parens_lev	int
>	O
0	int
&&	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
')'	O
)	O
{	O
parens_lev	int
--	O
;	O
nexttoken	()->(int)
(	O
)	O
;	O
}	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
MEMBER_OF	int
)	O
{	O
nexttoken	()->(int)
(	O
)	O
;	O
}	O
else	O
{	O
putback	()->(int)
(	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'('	O
:	O
if	O
(	O
nexttoken	()->(int)
(	O
)	O
==	O
TYPE	int
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
STRUCT	int
)	O
skip_to	(int)->(void)
(	O
')'	O
)	O
;	O
else	O
{	O
putback	()->(int)
(	O
)	O
;	O
parens_lev	int
++	O
;	O
}	O
break	O
;	O
case	O
')'	O
:	O
parens_lev	int
--	O
;	O
break	O
;	O
case	O
MEMBER_OF	int
:	O
nexttoken	()->(int)
(	O
)	O
;	O
break	O
;	O
}	O
nexttoken	()->(int)
(	O
)	O
;	O
}	O
}	O
void	O
parse_function_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
int	O
parm	int
)	O
{	O
int	O
error_recovery	int
=	O
0	int
;	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
=	O
-	O
1	int
;	O
parse_knr_dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(void)
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
;	O
restart	O
:	O
switch	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
)	O
{	O
case	O
')'	O
:	O
if	O
(	O
parm	int
)	O
break	O
;	O
default	O
:	O
if	O
(	O
error_recovery	int
)	O
nexttoken	()->(int)
(	O
)	O
;	O
else	O
{	O
if	O
(	O
verbose	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"expected `;'"	*(char)
)	O
,	O
&	O
tok	struct(int,*(char),int)
)	O
;	O
error_recovery	int
=	O
1	int
;	O
}	O
goto	O
restart	O
;	O
case	O
';'	O
:	O
case	O
','	O
:	O
break	O
;	O
case	O
LBRACE0	int
:	O
case	O
LBRACE	int
:	O
if	O
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
)	O
{	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
=	O
lookup	(*(char))->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
&&	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
->	O
storage	enum(int,int,int,int,int)
==	O
AutoStorage	int
)	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
=	O
NULL	O
;	O
func_body	()->(void)
(	O
)	O
;	O
}	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
verbose	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected end of file in declaration"	*(char)
)	O
,	O
NULL	O
)	O
;	O
}	O
}	O
int	O
fake_struct	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
{	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
=	O
-	O
1	int
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
STRUCT	int
)	O
{	O
if	O
(	O
nexttoken	()->(int)
(	O
)	O
==	O
IDENTIFIER	int
)	O
{	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
=	O
curs	int
;	O
}	O
putback	()->(int)
(	O
)	O
;	O
skip_struct	()->(void)
(	O
)	O
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
IDENTIFIER	int
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
MODIFIER	int
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
QUALIFIER	int
)	O
{	O
putback	()->(int)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
'('	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
!=	O
';'	O
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"missing `;' after struct declaration"	*(char)
)	O
,	O
&	O
tok	struct(int,*(char),int)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
parse_variable_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
int	O
parm	int
)	O
{	O
Stackpos	array(int)
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
;	O
mark	(array(int))->(void)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
;	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
=	O
-	O
1	int
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
STRUCT	int
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
UNION	int
)	O
{	O
if	O
(	O
nexttoken	()->(int)
(	O
)	O
==	O
IDENTIFIER	int
)	O
{	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
=	O
curs	int
;	O
}	O
putback	()->(int)
(	O
)	O
;	O
skip_struct	()->(void)
(	O
)	O
;	O
while	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
MODIFIER	int
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
QUALIFIER	int
)	O
nexttoken	()->(int)
(	O
)	O
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
IDENTIFIER	int
)	O
{	O
if	O
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
==	O
-	O
1	int
)	O
{	O
int	O
pos	array(int)
=	O
curs	int
-	O
1	int
;	O
restore	(array(int))->(void)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
;	O
tokdel	(int,int)->(void)
(	O
curs	int
,	O
pos	array(int)
-	O
1	int
)	O
;	O
tokins	(int,int,int,*(char))->(void)
(	O
curs	int
,	O
IDENTIFIER	int
,	O
tok	struct(int,*(char),int)
.	O
line	int
,	O
"{ ... }"	*(char)
)	O
;	O
debugtoken	(*(struct(int,*(char),int)),*(char))->(void)
(	O
&	O
tok	struct(int,*(char),int)
,	O
"modified stack"	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
';'	O
)	O
return	O
;	O
restore	(array(int))->(void)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
;	O
}	O
}	O
again	O
:	O
parse_dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
0	int
)	O
;	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
:	O
switch	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
)	O
{	O
case	O
')'	O
:	O
if	O
(	O
parm	int
)	O
break	O
;	O
default	O
:	O
if	O
(	O
verbose	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"expected `;'"	*(char)
)	O
,	O
&	O
tok	struct(int,*(char),int)
)	O
;	O
case	O
';'	O
:	O
break	O
;	O
case	O
','	O
:	O
if	O
(	O
parm	int
)	O
break	O
;	O
tos	int
=	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
;	O
restore	(array(int))->(void)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
;	O
goto	O
again	O
;	O
case	O
'='	O
:	O
nexttoken	()->(int)
(	O
)	O
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
LBRACE	int
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
LBRACE0	int
)	O
initializer_list	()->(void)
(	O
)	O
;	O
else	O
expression	()->(void)
(	O
)	O
;	O
goto	O
select	(int,*(struct(array(long))),*(struct(array(long))),*(struct(array(long))),*(struct(long,long)))->(int)
;	O
case	O
LBRACE0	int
:	O
case	O
LBRACE	int
:	O
func_body	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
verbose	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected end of file in declaration"	*(char)
)	O
,	O
NULL	O
)	O
;	O
}	O
}	O
void	O
initializer_list	()->(void)
(	O
)	O
{	O
int	O
lev	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
)	O
{	O
case	O
LBRACE	int
:	O
case	O
LBRACE0	int
:	O
lev	int
++	O
;	O
break	O
;	O
case	O
RBRACE	int
:	O
case	O
RBRACE0	int
:	O
if	O
(	O
--	O
lev	int
<=	O
0	int
)	O
{	O
nexttoken	()->(int)
(	O
)	O
;	O
return	O
;	O
}	O
break	O
;	O
case	O
0	int
:	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected end of file in initializer list"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
;	O
case	O
','	O
:	O
break	O
;	O
default	O
:	O
expression	()->(void)
(	O
)	O
;	O
break	O
;	O
}	O
nexttoken	()->(int)
(	O
)	O
;	O
}	O
}	O
void	O
parse_knr_dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
{	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
=	O
-	O
1	int
;	O
parse_dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
!	O
strict_ansi	int
)	O
;	O
}	O
void	O
skip_struct	()->(void)
(	O
)	O
{	O
if	O
(	O
nexttoken	()->(int)
(	O
)	O
==	O
IDENTIFIER	int
)	O
{	O
nexttoken	()->(int)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
';'	O
)	O
return	O
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
LBRACE	int
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
LBRACE0	int
)	O
{	O
if	O
(	O
skip_balanced	(int,int,int)->(int)
(	O
'{'	O
,	O
'}'	O
,	O
1	int
)	O
==	O
-	O
1	int
)	O
{	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected end of file in struct"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
}	O
while	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
PARM_WRAPPER	int
)	O
{	O
if	O
(	O
skip_balanced	(int,int,int)->(int)
(	O
'('	O
,	O
')'	O
,	O
0	int
)	O
==	O
-	O
1	int
)	O
{	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected end of file in struct"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
;	O
}	O
}	O
}	O
void	O
parse_typedef	()->(void)
(	O
)	O
{	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
;	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
.	O
name	*(char)
=	O
NULL	O
;	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
.	O
type_end	int
=	O
-	O
1	int
;	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
.	O
parmcnt	int
=	O
-	O
1	int
;	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
.	O
line	int
=	O
-	O
1	int
;	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
.	O
storage	enum(int,int,int,int,int)
=	O
AnyStorage	int
;	O
nexttoken	()->(int)
(	O
)	O
;	O
if	O
(	O
!	O
fake_struct	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
&	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
)	O
putback	()->(int)
(	O
)	O
;	O
dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
&	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
;	O
if	O
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
.	O
name	*(char)
)	O
declare_type	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(void)
(	O
&	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
;	O
}	O
void	O
parse_dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
int	O
maybe_knr	int
)	O
{	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
parmcnt	int
=	O
-	O
1	int
;	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
=	O
NULL	O
;	O
putback	()->(int)
(	O
)	O
;	O
dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
;	O
save_stack	()->(void)
(	O
)	O
;	O
if	O
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
)	O
declare	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
maybe_knr	int
)	O
;	O
else	O
undo_save_stack	()->(void)
(	O
)	O
;	O
}	O
int	O
dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
{	O
while	O
(	O
nexttoken	()->(int)
(	O
)	O
!=	O
0	int
&&	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
!=	O
'('	O
)	O
{	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
MODIFIER	int
)	O
{	O
if	O
(	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
&&	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
==	O
-	O
1	int
)	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
=	O
curs	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
PARM_WRAPPER	int
)	O
{	O
if	O
(	O
skip_balanced	(int,int,int)->(int)
(	O
'('	O
,	O
')'	O
,	O
0	int
)	O
==	O
-	O
1	int
)	O
{	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected end of file in function declaration"	*(char)
)	O
,	O
NULL	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
IDENTIFIER	int
)	O
{	O
int	O
type	enum(int,int,int)
;	O
while	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
IDENTIFIER	int
)	O
nexttoken	()->(int)
(	O
)	O
;	O
type	enum(int,int,int)
=	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
;	O
putback	()->(int)
(	O
)	O
;	O
if	O
(	O
!	O
(	O
type	enum(int,int,int)
==	O
TYPE	int
||	O
type	enum(int,int,int)
==	O
MODIFIER	int
||	O
type	enum(int,int,int)
==	O
QUALIFIER	int
)	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
')'	O
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
';'	O
)	O
{	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
&&	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
==	O
-	O
1	int
)	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
=	O
curs	int
-	O
1	int
;	O
return	O
dirdcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
;	O
}	O
int	O
dirdcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
{	O
int	O
wrapper	int
=	O
0	int
;	O
int	O
*	O
parm_ptr	*(int)
=	O
NULL	O
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
'('	O
)	O
{	O
dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
!=	O
')'	O
&&	O
verbose	int
)	O
{	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"expected `)'"	*(char)
)	O
,	O
&	O
tok	struct(int,*(char),int)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
IDENTIFIER	int
)	O
{	O
if	O
(	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
{	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
=	O
tok	struct(int,*(char),int)
.	O
token	*(char)
;	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
line	int
=	O
tok	struct(int,*(char),int)
.	O
line	int
;	O
parm_ptr	*(int)
=	O
&	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
parmcnt	int
;	O
}	O
}	O
if	O
(	O
nexttoken	()->(int)
(	O
)	O
==	O
PARM_WRAPPER	int
)	O
{	O
wrapper	int
=	O
1	int
;	O
nexttoken	()->(int)
(	O
)	O
;	O
}	O
else	O
putback	()->(int)
(	O
)	O
;	O
while	O
(	O
nexttoken	()->(int)
(	O
)	O
==	O
'['	O
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
'('	O
)	O
{	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
'['	O
)	O
skip_to	(int)->(void)
(	O
']'	O
)	O
;	O
else	O
{	O
maybe_parm_list	(*(int))->(void)
(	O
parm_ptr	*(int)
)	O
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
!=	O
')'	O
&&	O
verbose	int
)	O
{	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"expected `)'"	*(char)
)	O
,	O
&	O
tok	struct(int,*(char),int)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
wrapper	int
)	O
nexttoken	()->(int)
(	O
)	O
;	O
while	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
PARM_WRAPPER	int
)	O
{	O
if	O
(	O
skip_balanced	(int,int,int)->(int)
(	O
'('	O
,	O
')'	O
,	O
0	int
)	O
==	O
-	O
1	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected end of file in function declaration"	*(char)
)	O
,	O
NULL	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
parmdcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
{	O
int	O
type	enum(int,int,int)
;	O
while	O
(	O
nexttoken	()->(int)
(	O
)	O
!=	O
0	int
&&	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
!=	O
'('	O
)	O
{	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
MODIFIER	int
)	O
{	O
if	O
(	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
&&	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
==	O
-	O
1	int
)	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
=	O
curs	int
-	O
1	int
;	O
}	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
IDENTIFIER	int
)	O
{	O
while	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
IDENTIFIER	int
)	O
nexttoken	()->(int)
(	O
)	O
;	O
type	enum(int,int,int)
=	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
;	O
putback	()->(int)
(	O
)	O
;	O
if	O
(	O
type	enum(int,int,int)
!=	O
MODIFIER	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
')'	O
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
','	O
)	O
return	O
0	int
;	O
}	O
if	O
(	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
&&	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
==	O
-	O
1	int
)	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
type_end	int
=	O
curs	int
-	O
1	int
;	O
return	O
dirdcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
idptr	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
;	O
}	O
void	O
maybe_parm_list	(*(int))->(void)
(	O
int	O
*	O
parm_cnt_return	*(int)
)	O
{	O
int	O
parmcnt	int
=	O
0	int
;	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
;	O
int	O
level	int
;	O
parm_level	int
++	O
;	O
while	O
(	O
nexttoken	()->(int)
(	O
)	O
)	O
{	O
switch	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
)	O
{	O
case	O
')'	O
:	O
if	O
(	O
parm_cnt_return	*(int)
)	O
*	O
parm_cnt_return	*(int)
=	O
parmcnt	int
;	O
parm_level	int
--	O
;	O
return	O
;	O
case	O
','	O
:	O
break	O
;	O
case	O
QUALIFIER	int
:	O
case	O
IDENTIFIER	int
:	O
case	O
MODIFIER	int
:	O
case	O
STRUCT	int
:	O
case	O
UNION	int
:	O
case	O
TYPE	int
:	O
parmcnt	int
++	O
;	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
.	O
storage	enum(int,int,int,int,int)
=	O
AutoStorage	int
;	O
parse_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
&	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
1	int
)	O
;	O
putback	()->(int)
(	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
verbose	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected token in parameter list"	*(char)
)	O
,	O
&	O
tok	struct(int,*(char),int)
)	O
;	O
level	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
'('	O
)	O
level	int
++	O
;	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
')'	O
)	O
{	O
if	O
(	O
level	int
--	O
==	O
0	int
)	O
break	O
;	O
}	O
}	O
while	O
(	O
nexttoken	()->(int)
(	O
)	O
)	O
;	O
;	O
putback	()->(int)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
verbose	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected end of file in parameter list"	*(char)
)	O
,	O
NULL	O
)	O
;	O
}	O
void	O
func_body	()->(void)
(	O
)	O
{	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
;	O
level	int
++	O
;	O
move_parms	(int)->(void)
(	O
level	int
)	O
;	O
while	O
(	O
level	int
)	O
{	O
cleanup_stack	()->(void)
(	O
)	O
;	O
nexttoken	()->(int)
(	O
)	O
;	O
switch	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
)	O
{	O
default	O
:	O
expression	()->(void)
(	O
)	O
;	O
break	O
;	O
case	O
STATIC	int
:	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
.	O
storage	enum(int,int,int,int,int)
=	O
StaticStorage	int
;	O
nexttoken	()->(int)
(	O
)	O
;	O
parse_variable_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
&	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
0	int
)	O
;	O
break	O
;	O
case	O
TYPE	int
:	O
case	O
STRUCT	int
:	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
.	O
storage	enum(int,int,int,int,int)
=	O
AutoStorage	int
;	O
parse_variable_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
&	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
0	int
)	O
;	O
break	O
;	O
case	O
EXTERN	int
:	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
.	O
storage	enum(int,int,int,int,int)
=	O
ExplicitExternStorage	int
;	O
parse_declaration	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
&	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
0	int
)	O
;	O
break	O
;	O
case	O
LBRACE0	int
:	O
case	O
'{'	O
:	O
level	int
++	O
;	O
break	O
;	O
case	O
RBRACE0	int
:	O
if	O
(	O
use_indentation	int
)	O
{	O
if	O
(	O
verbose	int
&&	O
level	int
!=	O
1	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"forced function body close"	*(char)
)	O
,	O
NULL	O
)	O
;	O
for	O
(	O
;	O
level	int
;	O
level	int
--	O
)	O
{	O
delete_autos	(int)->(void)
(	O
level	int
)	O
;	O
}	O
break	O
;	O
}	O
case	O
'}'	O
:	O
delete_autos	(int)->(void)
(	O
level	int
)	O
;	O
level	int
--	O
;	O
break	O
;	O
case	O
0	int
:	O
if	O
(	O
verbose	int
)	O
file_error	(*(char),*(struct(int,*(char),int)))->(void)
(	O
_	O
(	O
"unexpected end of file in function body"	*(char)
)	O
,	O
NULL	O
)	O
;	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
=	O
NULL	O
;	O
return	O
;	O
}	O
}	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
=	O
NULL	O
;	O
}	O
int	O
get_knr_args	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
{	O
int	O
parmcnt	int
,	O
stop	int
;	O
Stackpos	array(int)
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
,	O
new_sp	array(int)
;	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
id	struct(*(char),int,int,int,enum(int,int,int,int,int))
;	O
switch	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
)	O
{	O
case	O
IDENTIFIER	int
:	O
case	O
TYPE	int
:	O
case	O
STRUCT	int
:	O
mark	(array(int))->(void)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
;	O
parmcnt	int
=	O
0	int
;	O
for	O
(	O
stop	int
=	O
0	int
;	O
!	O
stop	int
&&	O
parmcnt	int
<	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
parmcnt	int
;	O
nexttoken	()->(int)
(	O
)	O
)	O
{	O
id	struct(*(char),int,int,int,enum(int,int,int,int,int))
.	O
type_end	int
=	O
-	O
1	int
;	O
switch	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
)	O
{	O
case	O
LBRACE	int
:	O
case	O
LBRACE0	int
:	O
putback	()->(int)
(	O
)	O
;	O
stop	int
=	O
1	int
;	O
break	O
;	O
case	O
TYPE	int
:	O
case	O
IDENTIFIER	int
:	O
case	O
STRUCT	int
:	O
putback	()->(int)
(	O
)	O
;	O
mark	(array(int))->(void)
(	O
new_sp	array(int)
)	O
;	O
if	O
(	O
dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
&	O
id	struct(*(char),int,int,int,enum(int,int,int,int,int))
)	O
==	O
0	int
)	O
{	O
parmcnt	int
++	O
;	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
','	O
)	O
{	O
do	O
{	O
tos	int
=	O
id	struct(*(char),int,int,int,enum(int,int,int,int,int))
.	O
type_end	int
;	O
restore	(array(int))->(void)
(	O
new_sp	array(int)
)	O
;	O
dcl	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
&	O
id	struct(*(char),int,int,int,enum(int,int,int,int,int))
)	O
;	O
}	O
while	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
','	O
)	O
;	O
}	O
else	O
if	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
!=	O
';'	O
)	O
putback	()->(int)
(	O
)	O
;	O
break	O
;	O
}	O
default	O
:	O
restore	(array(int))->(void)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
declare	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))),int)->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
,	O
int	O
maybe_knr	int
)	O
{	O
Symbol	struct
*	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
;	O
if	O
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
storage	enum(int,int,int,int,int)
==	O
AutoStorage	int
)	O
{	O
undo_save_stack	()->(void)
(	O
)	O
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
install_ident	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
,	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
storage	enum(int,int,int,int,int)
)	O
;	O
if	O
(	O
parm_level	int
)	O
{	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
level	int
=	O
parm_level	int
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
flag	*(int)
=	O
symbol_parm	int
;	O
}	O
else	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
level	int
=	O
level	int
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
arity	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
parmcnt	int
>=	O
0	int
&&	O
(	O
!	O
maybe_knr	int
||	O
get_knr_args	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(int)
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
==	O
0	int
)	O
&&	O
!	O
(	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
LBRACE	int
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
LBRACE0	int
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
TYPE	int
||	O
tok	struct(int,*(char),int)
.	O
type	enum(int,int,int)
==	O
PARM_WRAPPER	int
)	O
)	O
||	O
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
parmcnt	int
<	O
0	int
&&	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
storage	enum(int,int,int,int,int)
==	O
ExplicitExternStorage	int
)	O
||	O
save_stack_is_empty	()->(int)
(	O
)	O
)	O
{	O
undo_save_stack	()->(void)
(	O
)	O
;	O
return	O
;	O
}	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
get_symbol	(*(char))->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
)	O
;	O
if	O
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
source	*(char)
)	O
{	O
if	O
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
storage	enum(int,int,int,int,int)
==	O
StaticStorage	int
&&	O
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
storage	enum(int,int,int,int,int)
!=	O
StaticStorage	int
||	O
level	int
>	O
0	int
)	O
)	O
{	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
install_ident	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
,	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
storage	enum(int,int,int,int,int)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
arity	int
>=	O
0	int
)	O
error_at_line	(int,int,*(char),int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
filename	*(char)
,	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
line	int
,	O
_	O
(	O
"%s/%d redefined"	*(char)
)	O
,	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
,	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
arity	int
)	O
;	O
else	O
error_at_line	(int,int,*(char),int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
filename	*(char)
,	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
line	int
,	O
_	O
(	O
"%s redefined"	*(char)
)	O
,	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
)	O
;	O
error_at_line	(int,int,*(char),int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
source	*(char)
,	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
def_line	int
,	O
_	O
(	O
"this is the place of previous definition"	*(char)
)	O
)	O
;	O
}	O
}	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int)
=	O
SymIdentifier	int
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
arity	int
=	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
parmcnt	int
;	O
ident_change_storage	(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),enum(int,int,int,int,int))->(void)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
,	O
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
storage	enum(int,int,int,int,int)
==	O
ExplicitExternStorage	int
)	O
?	O
ExternStorage	int
:	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
storage	enum(int,int,int,int,int)
)	O
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
decl	*(char)
=	O
finish_save_stack	(*(char))->(*(char))
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
)	O
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
source	*(char)
=	O
filename	*(char)
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
def_line	int
=	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
line	int
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
level	int
=	O
level	int
;	O
if	O
(	O
debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: %s/%d defined to %s\n"	*(char)
)	O
,	O
filename	*(char)
,	O
line_num	int
,	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
,	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
parmcnt	int
,	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
decl	*(char)
)	O
;	O
}	O
void	O
declare_type	(*(struct(*(char),int,int,int,enum(int,int,int,int,int))))->(void)
(	O
Ident	struct(*(char),int,int,int,enum(int,int,int,int,int))
*	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
)	O
{	O
Symbol	struct
*	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
;	O
undo_save_stack	()->(void)
(	O
)	O
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
lookup	(*(char))->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
)	O
;	O
for	O
(	O
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct),*(void)))
)	O
if	O
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int)
==	O
SymToken	int
&&	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
token_type	int
==	O
TYPE	int
)	O
break	O
;	O
if	O
(	O
!	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
install	(*(char),int)->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
,	O
INSTALL_UNIT_LOCAL	int
)	O
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int)
=	O
SymToken	int
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
token_type	int
=	O
TYPE	int
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
source	*(char)
=	O
filename	*(char)
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
def_line	int
=	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
line	int
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
ref_line	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
=	O
NULL	O
;	O
if	O
(	O
debug	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s:%d: type %s\n"	*(char)
)	O
,	O
filename	*(char)
,	O
line_num	int
,	O
ident	*(struct(*(char),int,int,int,enum(int,int,int,int,int)))
->	O
name	*(char)
)	O
;	O
}	O
Symbol	struct
*	O
get_symbol	(*(char))->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
char	O
*	O
name	*(char)
)	O
{	O
Symbol	struct
*	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
lookup	(*(char))->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
name	*(char)
)	O
;	O
if	O
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
{	O
for	O
(	O
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
next	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct),*(void)))
)	O
{	O
if	O
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
type	enum(int,int,int)
==	O
SymIdentifier	int
&&	O
strcmp	(*(char),*(char))->(int)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
return	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
;	O
}	O
return	O
install_ident	(*(char),enum(int,int,int,int,int))->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
name	*(char)
,	O
ExternStorage	int
)	O
;	O
}	O
Symbol	struct
*	O
add_reference	(*(char),int)->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
char	O
*	O
name	*(char)
,	O
int	O
line	int
)	O
{	O
Symbol	struct
*	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
get_symbol	(*(char))->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
name	*(char)
)	O
;	O
Ref	struct(int,*(char))
*	O
refptr	*(struct(int,*(char)))
;	O
if	O
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
storage	enum(int,int,int,int,int)
==	O
AutoStorage	int
||	O
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
storage	enum(int,int,int,int,int)
==	O
StaticStorage	int
&&	O
globals_only	()->(int)
(	O
)	O
)	O
)	O
return	O
NULL	O
;	O
refptr	*(struct(int,*(char)))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
refptr	*(struct(int,*(char)))
)	O
)	O
;	O
refptr	*(struct(int,*(char)))
->	O
source	*(char)
=	O
filename	*(char)
;	O
refptr	*(struct(int,*(char)))
->	O
line	int
=	O
line	int
;	O
if	O
(	O
!	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
ref_line	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
ref_line	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
=	O
linked_list_create	(*((*(void))->(void)))->(*(struct(*((*`)->(void)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
(	O
free	(*(void))->(void)
)	O
;	O
linked_list_append	(*(*(struct(*((*`)->(void)),*(struct`),*(struct`)))),*(void))->(void)
(	O
&	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
ref_line	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
,	O
refptr	*(struct(int,*(char)))
)	O
;	O
return	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
;	O
}	O
void	O
call	(*(char),int)->(void)
(	O
char	O
*	O
name	*(char)
,	O
int	O
line	int
)	O
{	O
Symbol	struct
*	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
;	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
add_reference	(*(char),int)->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
name	*(char)
,	O
line	int
)	O
;	O
if	O
(	O
!	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
return	O
;	O
if	O
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
arity	int
<	O
0	int
)	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
arity	int
=	O
0	int
;	O
if	O
(	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
{	O
if	O
(	O
!	O
data_in_list	(*(void),*(struct(*((*`)->(void)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(int)
(	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
,	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
)	O
linked_list_append	(*(*(struct(*((*`)->(void)),*(struct`),*(struct`)))),*(void))->(void)
(	O
&	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
,	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
;	O
if	O
(	O
!	O
data_in_list	(*(void),*(struct(*((*`)->(void)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(int)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
,	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
->	O
callee	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
)	O
linked_list_append	(*(*(struct(*((*`)->(void)),*(struct`),*(struct`)))),*(void))->(void)
(	O
&	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
->	O
callee	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
,	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
;	O
}	O
}	O
void	O
reference	(*(char),int)->(void)
(	O
char	O
*	O
name	*(char)
,	O
int	O
line	int
)	O
{	O
Symbol	struct
*	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
=	O
add_reference	(*(char),int)->(*(struct(*(struct),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),*(struct(*`,*`,*`,*`)),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*`,*`,*`,enum(int,int,int),*`,enum(int,int,int,int),*`,int,int,int,*`,int,*`,int,*`,enum(int,int,int,int,int),int,int,long,*`,*`)),int,int,int,*(char),int,*(struct(*`,*`,*`)),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))))
(	O
name	*(char)
,	O
line	int
)	O
;	O
if	O
(	O
!	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
return	O
;	O
if	O
(	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
{	O
if	O
(	O
!	O
data_in_list	(*(void),*(struct(*((*`)->(void)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(int)
(	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
,	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
)	O
linked_list_append	(*(*(struct(*((*`)->(void)),*(struct`),*(struct`)))),*(void))->(void)
(	O
&	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
->	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
,	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
;	O
if	O
(	O
!	O
data_in_list	(*(void),*(struct(*((*`)->(void)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))->(int)
(	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
,	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
->	O
callee	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
)	O
)	O
linked_list_append	(*(*(struct(*((*`)->(void)),*(struct`),*(struct`)))),*(void))->(void)
(	O
&	O
caller	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
->	O
callee	*(struct(*((*(void))->(void)),*(struct(*(struct`),*(struct`),*(struct`),*(void))),*(struct(*(struct`),*(struct`),*(struct`),*(void)))))
,	O
sp	*(struct(*(struct),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(void))),enum(int,int,int),*(char),enum(int,int,int,int),*(struct(*(struct`),*(struct`),*(struct`),enum(int,int,int),*(char),enum(int,int,int,int),*(struct`),int,int,int,*(char),int,*(struct`),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct`),*(struct`))),int,int,int,*(char),int,*(struct(*((*`)->(void)),*(struct`),*(struct`))),int,*(char),enum(int,int,int,int,int),int,int,long,*(struct(*((*`)->(void)),*(struct`),*(struct`))),*(struct(*((*`)->(void)),*(struct`),*(struct`)))))
)	O
;	O
}	O
}	O
