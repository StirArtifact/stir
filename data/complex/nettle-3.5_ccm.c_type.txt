static	O
void	O
ccm_pad	(*(struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)),*(void),*((*(void),long,*(char),*(char))->(void)))->(void)
(	O
struct	O
ccm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)
*	O
ctx	*(void)
,	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
)	O
{	O
if	O
(	O
ctx	*(void)
->	O
blength	int
)	O
f	*((*(void),long,*(char),*(char))->(void))
(	O
cipher	*(void)
,	O
CCM_BLOCK_SIZE	int
,	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
)	O
;	O
ctx	*(void)
->	O
blength	int
=	O
0	int
;	O
}	O
static	O
void	O
ccm_build_iv	(*(char),long,*(char),char,long)->(void)
(	O
uint8_t	char
*	O
iv	*(char)
,	O
size_t	long
noncelen	long
,	O
const	O
uint8_t	char
*	O
nonce	*(char)
,	O
uint8_t	char
flags	char
,	O
size_t	long
count	long
)	O
{	O
unsigned	O
int	O
i	int
;	O
assert	O
(	O
noncelen	long
>=	O
CCM_MIN_NONCE_SIZE	int
)	O
;	O
assert	O
(	O
noncelen	long
<=	O
CCM_MAX_NONCE_SIZE	int
)	O
;	O
iv	*(char)
[	O
CCM_OFFSET_FLAGS	int
]	O
=	O
flags	char
|	O
CCM_FLAG_SET_L	O
(	O
CCM_L_SIZE	O
(	O
noncelen	long
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
&	O
iv	*(char)
[	O
CCM_OFFSET_NONCE	int
]	O
,	O
nonce	*(char)
,	O
noncelen	long
)	O
;	O
for	O
(	O
i	int
=	O
(	O
CCM_BLOCK_SIZE	int
-	O
1	int
)	O
;	O
i	int
>=	O
(	O
CCM_OFFSET_NONCE	int
+	O
noncelen	long
)	O
;	O
i	int
--	O
)	O
{	O
iv	*(char)
[	O
i	int
]	O
=	O
count	long
&	O
0xff	int
;	O
count	long
>>=	O
8	int
;	O
}	O
assert	O
(	O
!	O
count	long
)	O
;	O
}	O
void	O
ccm_set_nonce	O
(	O
struct	O
ccm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)
*	O
ctx	*(void)
,	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
nonce	*(char)
,	O
size_t	long
authlen	long
,	O
size_t	long
msglen	long
,	O
size_t	long
taglen	long
)	O
{	O
ctx	*(void)
->	O
blength	int
=	O
0	int
;	O
ccm_build_iv	(*(char),long,*(char),char,long)->(void)
(	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
length	long
,	O
nonce	*(char)
,	O
CCM_FLAG_SET_M	O
(	O
taglen	long
)	O
,	O
msglen	long
)	O
;	O
ccm_build_iv	(*(char),long,*(char),char,long)->(void)
(	O
ctx	*(void)
->	O
ctr	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
length	long
,	O
nonce	*(char)
,	O
0	int
,	O
1	int
)	O
;	O
if	O
(	O
!	O
authlen	long
)	O
{	O
f	*((*(void),long,*(char),*(char))->(void))
(	O
cipher	*(void)
,	O
CCM_BLOCK_SIZE	int
,	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
)	O
;	O
return	O
;	O
}	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
CCM_OFFSET_FLAGS	int
]	O
|=	O
CCM_FLAG_ADATA	int
;	O
f	*((*(void),long,*(char),*(char))->(void))
(	O
cipher	*(void)
,	O
CCM_BLOCK_SIZE	int
,	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
)	O
;	O
if	O
(	O
authlen	long
>=	O
(	O
0x01ULL	int
<<	O
32	int
)	O
)	O
{	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
0xff	int
;	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
0xff	int
;	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
(	O
authlen	long
>>	O
56	int
)	O
&	O
0xff	int
;	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
(	O
authlen	long
>>	O
48	int
)	O
&	O
0xff	int
;	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
(	O
authlen	long
>>	O
40	int
)	O
&	O
0xff	int
;	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
(	O
authlen	long
>>	O
32	int
)	O
&	O
0xff	int
;	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
(	O
authlen	long
>>	O
24	int
)	O
&	O
0xff	int
;	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
(	O
authlen	long
>>	O
16	int
)	O
&	O
0xff	int
;	O
}	O
else	O
if	O
(	O
authlen	long
>=	O
(	O
(	O
0x1ULL	int
<<	O
16	int
)	O
-	O
(	O
0x1ULL	int
<<	O
8	int
)	O
)	O
)	O
{	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
0xff	int
;	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
0xfe	int
;	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
(	O
authlen	long
>>	O
24	int
)	O
&	O
0xff	int
;	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
(	O
authlen	long
>>	O
16	int
)	O
&	O
0xff	int
;	O
}	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
(	O
authlen	long
>>	O
8	int
)	O
&	O
0xff	int
;	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
++	O
]	O
^=	O
(	O
authlen	long
>>	O
0	int
)	O
&	O
0xff	int
;	O
}	O
void	O
ccm_update	O
(	O
struct	O
ccm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)
*	O
ctx	*(void)
,	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
data	*(char)
)	O
{	O
const	O
uint8_t	char
*	O
end	*(char)
=	O
data	*(char)
+	O
length	long
;	O
if	O
(	O
(	O
ctx	*(void)
->	O
blength	int
+	O
length	long
)	O
<	O
CCM_BLOCK_SIZE	int
)	O
{	O
memxor	O
(	O
&	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
]	O
,	O
data	*(char)
,	O
length	long
)	O
;	O
ctx	*(void)
->	O
blength	int
+=	O
length	long
;	O
return	O
;	O
}	O
if	O
(	O
ctx	*(void)
->	O
blength	int
)	O
{	O
memxor	O
(	O
&	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
ctx	*(void)
->	O
blength	int
]	O
,	O
data	*(char)
,	O
CCM_BLOCK_SIZE	int
-	O
ctx	*(void)
->	O
blength	int
)	O
;	O
data	*(char)
+=	O
(	O
CCM_BLOCK_SIZE	int
-	O
ctx	*(void)
->	O
blength	int
)	O
;	O
f	*((*(void),long,*(char),*(char))->(void))
(	O
cipher	*(void)
,	O
CCM_BLOCK_SIZE	int
,	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
)	O
;	O
}	O
while	O
(	O
(	O
data	*(char)
+	O
CCM_BLOCK_SIZE	int
)	O
<	O
end	*(char)
)	O
{	O
memxor	O
(	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
data	*(char)
,	O
CCM_BLOCK_SIZE	int
)	O
;	O
f	*((*(void),long,*(char),*(char))->(void))
(	O
cipher	*(void)
,	O
CCM_BLOCK_SIZE	int
,	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
)	O
;	O
data	*(char)
+=	O
CCM_BLOCK_SIZE	int
;	O
}	O
ctx	*(void)
->	O
blength	int
=	O
(	O
end	*(char)
-	O
data	*(char)
)	O
;	O
if	O
(	O
ctx	*(void)
->	O
blength	int
)	O
memxor	O
(	O
&	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
data	*(char)
,	O
ctx	*(void)
->	O
blength	int
)	O
;	O
}	O
void	O
ccm_encrypt	O
(	O
struct	O
ccm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)
*	O
ctx	*(void)
,	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
dst	*(char)
,	O
const	O
uint8_t	char
*	O
src	*(char)
)	O
{	O
ccm_pad	(*(struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)),*(void),*((*(void),long,*(char),*(char))->(void)))->(void)
(	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
)	O
;	O
ccm_update	O
(	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
length	long
,	O
src	*(char)
)	O
;	O
ctr_crypt	O
(	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
CCM_BLOCK_SIZE	int
,	O
ctx	*(void)
->	O
ctr	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
length	long
,	O
dst	*(char)
,	O
src	*(char)
)	O
;	O
}	O
void	O
ccm_decrypt	O
(	O
struct	O
ccm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)
*	O
ctx	*(void)
,	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
dst	*(char)
,	O
const	O
uint8_t	char
*	O
src	*(char)
)	O
{	O
ctr_crypt	O
(	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
CCM_BLOCK_SIZE	int
,	O
ctx	*(void)
->	O
ctr	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
length	long
,	O
dst	*(char)
,	O
src	*(char)
)	O
;	O
ccm_pad	(*(struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)),*(void),*((*(void),long,*(char),*(char))->(void)))->(void)
(	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
)	O
;	O
ccm_update	O
(	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
length	long
,	O
dst	*(char)
)	O
;	O
}	O
void	O
ccm_digest	O
(	O
struct	O
ccm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)
*	O
ctx	*(void)
,	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
digest	*(char)
)	O
{	O
int	O
i	int
=	O
CCM_BLOCK_SIZE	int
-	O
CCM_FLAG_GET_L	O
(	O
ctx	*(void)
->	O
ctr	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
CCM_OFFSET_FLAGS	int
]	O
)	O
;	O
assert	O
(	O
length	long
<=	O
CCM_BLOCK_SIZE	int
)	O
;	O
while	O
(	O
i	int
<	O
CCM_BLOCK_SIZE	int
)	O
ctx	*(void)
->	O
ctr	union(array(char),array(long),array(long))
.	O
b	array(char)
[	O
i	int
++	O
]	O
=	O
0	int
;	O
ccm_pad	(*(struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)),*(void),*((*(void),long,*(char),*(char))->(void)))->(void)
(	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
)	O
;	O
ctr_crypt	O
(	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
CCM_BLOCK_SIZE	int
,	O
ctx	*(void)
->	O
ctr	union(array(char),array(long),array(long))
.	O
b	array(char)
,	O
length	long
,	O
digest	*(char)
,	O
ctx	*(void)
->	O
tag	union(array(char),array(long),array(long))
.	O
b	array(char)
)	O
;	O
}	O
void	O
ccm_encrypt_message	O
(	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
size_t	long
nlength	long
,	O
const	O
uint8_t	char
*	O
nonce	*(char)
,	O
size_t	long
alength	long
,	O
const	O
uint8_t	char
*	O
adata	*(char)
,	O
size_t	long
tlength	long
,	O
size_t	long
clength	long
,	O
uint8_t	char
*	O
dst	*(char)
,	O
const	O
uint8_t	char
*	O
src	*(char)
)	O
{	O
struct	O
ccm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)
ctx	*(void)
;	O
uint8_t	char
*	O
tag	union(array(char),array(long),array(long))
=	O
dst	*(char)
+	O
(	O
clength	long
-	O
tlength	long
)	O
;	O
assert	O
(	O
clength	long
>=	O
tlength	long
)	O
;	O
ccm_set_nonce	O
(	O
&	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
nlength	long
,	O
nonce	*(char)
,	O
alength	long
,	O
clength	long
-	O
tlength	long
,	O
tlength	long
)	O
;	O
ccm_update	O
(	O
&	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
alength	long
,	O
adata	*(char)
)	O
;	O
ccm_encrypt	O
(	O
&	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
clength	long
-	O
tlength	long
,	O
dst	*(char)
,	O
src	*(char)
)	O
;	O
ccm_digest	O
(	O
&	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
tlength	long
,	O
tag	union(array(char),array(long),array(long))
)	O
;	O
}	O
int	O
ccm_decrypt_message	O
(	O
const	O
void	O
*	O
cipher	*(void)
,	O
nettle_cipher_func	(*(void),long,*(char),*(char))->(void)
*	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
size_t	long
nlength	long
,	O
const	O
uint8_t	char
*	O
nonce	*(char)
,	O
size_t	long
alength	long
,	O
const	O
uint8_t	char
*	O
adata	*(char)
,	O
size_t	long
tlength	long
,	O
size_t	long
mlength	long
,	O
uint8_t	char
*	O
dst	*(char)
,	O
const	O
uint8_t	char
*	O
src	*(char)
)	O
{	O
struct	O
ccm_ctx	struct(union(array(char),array(long),array(long)),union(array(char),array(long),array(long)),int)
ctx	*(void)
;	O
uint8_t	char
tag	union(array(char),array(long),array(long))
[	O
CCM_BLOCK_SIZE	int
]	O
;	O
ccm_set_nonce	O
(	O
&	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
nlength	long
,	O
nonce	*(char)
,	O
alength	long
,	O
mlength	long
,	O
tlength	long
)	O
;	O
ccm_update	O
(	O
&	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
alength	long
,	O
adata	*(char)
)	O
;	O
ccm_decrypt	O
(	O
&	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
mlength	long
,	O
dst	*(char)
,	O
src	*(char)
)	O
;	O
ccm_digest	O
(	O
&	O
ctx	*(void)
,	O
cipher	*(void)
,	O
f	*((*(void),long,*(char),*(char))->(void))
,	O
tlength	long
,	O
tag	union(array(char),array(long),array(long))
)	O
;	O
return	O
memeql_sec	O
(	O
tag	union(array(char),array(long),array(long))
,	O
src	*(char)
+	O
mlength	long
,	O
tlength	long
)	O
;	O
}	O
