static	O
char	O
*	O
setaf	*(char)
;	O
static	O
char	O
*	O
op	*(char)
;	O
static	O
int	O
init	int
=	O
0	int
;	O
void	O
gg_init_color	()->(void)
(	O
)	O
{	O
static	O
char	O
setaf_literal	array(char)
[	O
]	O
=	O
"setaf"	*(char)
;	O
static	O
char	O
op_literal	array(char)
[	O
]	O
=	O
"op"	*(char)
;	O
static	O
char	O
empty_literal	array(char)
[	O
]	O
=	O
""	*(char)
;	O
if	O
(	O
init	int
)	O
return	O
;	O
init	int
=	O
1	int
;	O
setupterm	(*(char),int,*(int))->(int)
(	O
NULL	O
,	O
2	int
,	O
NULL	O
)	O
;	O
setaf	*(char)
=	O
tigetstr	(*(char))->(*(char))
(	O
setaf_literal	array(char)
)	O
;	O
if	O
(	O
!	O
setaf	*(char)
)	O
setaf	*(char)
=	O
empty_literal	array(char)
;	O
op	*(char)
=	O
tigetstr	(*(char))->(*(char))
(	O
op_literal	array(char)
)	O
;	O
if	O
(	O
!	O
op	*(char)
)	O
op	*(char)
=	O
empty_literal	array(char)
;	O
}	O
void	O
write_color_char_no_space	(int,int)->(void)
(	O
int	O
c	int
,	O
int	O
x	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s%c"	*(char)
,	O
tparm	(*(char))->(*(char))
(	O
setaf	*(char)
,	O
c	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
,	O
x	int
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
tparm	(*(char))->(*(char))
(	O
op	*(char)
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
write_color_string	(int,*(char))->(void)
(	O
int	O
c	int
,	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
while	O
(	O
*	O
str	*(char)
)	O
write_color_char_no_space	(int,int)->(void)
(	O
c	int
,	O
*	O
str	*(char)
++	O
)	O
;	O
}	O
void	O
write_color_char	(int,int)->(void)
(	O
int	O
c	int
,	O
int	O
x	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
" "	*(char)
)	O
;	O
write_color_char_no_space	(int,int)->(void)
(	O
c	int
,	O
x	int
)	O
;	O
}	O
void	O
gg_vsnprintf	(*(char),long,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
char	O
*	O
dest	*(char)
,	O
unsigned	O
long	O
len	long
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
)	O
{	O
vsnprintf	(*(char),long,*(char),array(struct(int,int,*(void),*(void))))->(int)
(	O
dest	*(char)
,	O
len	long
,	O
fmt	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
void	O
gg_snprintf	(*(char),long,*(char))->(void)
(	O
char	O
*	O
dest	*(char)
,	O
unsigned	O
long	O
len	long
,	O
const	O
char	O
*	O
fmt	*(char)
,	O
...	O
)	O
{	O
va_list	array(struct(int,int,*(void),*(void)))
args	array(struct(int,int,*(void),*(void)))
;	O
va_start	O
(	O
args	array(struct(int,int,*(void),*(void)))
,	O
fmt	*(char)
)	O
;	O
gg_vsnprintf	(*(char),long,*(char),array(struct(int,int,*(void),*(void))))->(void)
(	O
dest	*(char)
,	O
len	long
,	O
fmt	*(char)
,	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
va_end	O
(	O
args	array(struct(int,int,*(void),*(void)))
)	O
;	O
}	O
double	O
gg_gettimeofday	()->(double)
(	O
void	O
)	O
{	O
struct	O
timeval	struct(long,long)
tv	struct(long,long)
;	O
gettimeofday	(*(struct(long,long)),*(void))->(int)
(	O
&	O
tv	struct(long,long)
,	O
NULL	O
)	O
;	O
return	O
tv	struct(long,long)
.	O
tv_sec	long
+	O
1.e-6	int
*	O
tv	struct(long,long)
.	O
tv_usec	long
;	O
}	O
const	O
char	O
*	O
gg_version	()->(*(char))
(	O
void	O
)	O
{	O
return	O
VERSION	*(char)
;	O
}	O
double	O
gg_cputime	()->(double)
(	O
void	O
)	O
{	O
struct	O
tms	struct(long,long,long,long)
t	struct(long,long,long,long)
;	O
times	(*(struct(long,long,long,long)))->(long)
(	O
&	O
t	struct(long,long,long,long)
)	O
;	O
return	O
(	O
t	struct(long,long,long,long)
.	O
tms_utime	long
+	O
t	struct(long,long,long,long)
.	O
tms_stime	long
+	O
t	struct(long,long,long,long)
.	O
tms_cutime	long
+	O
t	struct(long,long,long,long)
.	O
tms_cstime	long
)	O
/	O
(	O
(	O
double	O
)	O
sysconf	(int)->(long)
(	O
_SC_CLK_TCK	int
)	O
)	O
;	O
}	O
float	O
gg_normalize_float	(float,float)->(float)
(	O
float	O
x	int
,	O
float	O
a	float
)	O
{	O
return	O
a	float
*	O
(	O
(	O
int	O
)	O
(	O
0.5	int
+	O
x	int
/	O
a	float
)	O
)	O
;	O
}	O
int	O
gg_normalize_float2int	(float,float)->(int)
(	O
float	O
x	int
,	O
float	O
a	float
)	O
{	O
return	O
(	O
(	O
int	O
)	O
(	O
0.5	int
+	O
x	int
/	O
a	float
)	O
)	O
;	O
}	O
void	O
gg_sort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
void	O
*	O
base	*(void)
,	O
size_t	long
nel	long
,	O
size_t	long
width	long
,	O
int	O
(	O
*	O
cmp	*((*(void),*(void))->(int))
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
{	O
int	O
gap	int
=	O
nel	long
;	O
int	O
swap_made	int
;	O
char	O
*	O
end	*(char)
=	O
(	O
char	O
*	O
)	O
base	*(void)
+	O
width	long
*	O
(	O
nel	long
-	O
1	int
)	O
;	O
do	O
{	O
char	O
*	O
a	float
,	O
*	O
b	float
;	O
swap_made	int
=	O
0	int
;	O
gap	int
=	O
(	O
10	int
*	O
gap	int
+	O
3	int
)	O
/	O
13	int
;	O
for	O
(	O
a	float
=	O
base	*(void)
,	O
b	float
=	O
a	float
+	O
gap	int
*	O
width	long
;	O
b	float
<=	O
end	*(char)
;	O
a	float
+=	O
width	long
,	O
b	float
+=	O
width	long
)	O
{	O
if	O
(	O
cmp	*((*(void),*(void))->(int))
(	O
(	O
void	O
*	O
)	O
a	float
,	O
(	O
void	O
*	O
)	O
b	float
)	O
>	O
0	int
)	O
{	O
char	O
*	O
c	int
=	O
a	float
;	O
char	O
*	O
d	*(char)
=	O
b	float
;	O
size_t	long
size	long
=	O
width	long
;	O
while	O
(	O
size	long
--	O
>	O
0	int
)	O
{	O
char	O
tmp	char
=	O
*	O
c	int
;	O
*	O
c	int
++	O
=	O
*	O
d	*(char)
;	O
*	O
d	*(char)
++	O
=	O
tmp	char
;	O
}	O
swap_made	int
=	O
1	int
;	O
}	O
}	O
}	O
while	O
(	O
gap	int
>	O
1	int
||	O
swap_made	int
)	O
;	O
}	O
float	O
gg_interpolate	(*(struct(int,float,float,array(float))),float)->(float)
(	O
struct	O
interpolation_data	struct(int,float,float,array(float))
*	O
f	*(struct(int,float,float,array(float)))
,	O
float	O
x	int
)	O
{	O
int	O
i	int
;	O
float	O
ratio	float
;	O
float	O
diff	float
;	O
if	O
(	O
x	int
<	O
f	*(struct(int,float,float,array(float)))
->	O
range_lowerbound	float
)	O
return	O
f	*(struct(int,float,float,array(float)))
->	O
values	array(float)
[	O
0	int
]	O
;	O
else	O
if	O
(	O
x	int
>	O
f	*(struct(int,float,float,array(float)))
->	O
range_upperbound	float
)	O
return	O
f	*(struct(int,float,float,array(float)))
->	O
values	array(float)
[	O
f	*(struct(int,float,float,array(float)))
->	O
sections	int
]	O
;	O
else	O
{	O
ratio	float
=	O
(	O
(	O
float	O
)	O
f	*(struct(int,float,float,array(float)))
->	O
sections	int
)	O
*	O
(	O
x	int
-	O
f	*(struct(int,float,float,array(float)))
->	O
range_lowerbound	float
)	O
/	O
(	O
f	*(struct(int,float,float,array(float)))
->	O
range_upperbound	float
-	O
f	*(struct(int,float,float,array(float)))
->	O
range_lowerbound	float
)	O
;	O
i	int
=	O
(	O
int	O
)	O
ratio	float
;	O
diff	float
=	O
ratio	float
-	O
(	O
(	O
float	O
)	O
i	int
)	O
;	O
if	O
(	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"Floating point Ratio: %f, integer: %d, diff %f"	*(char)
,	O
ratio	float
,	O
i	int
,	O
diff	float
)	O
;	O
return	O
(	O
(	O
1	int
-	O
diff	float
)	O
*	O
f	*(struct(int,float,float,array(float)))
->	O
values	array(float)
[	O
i	int
]	O
+	O
diff	float
*	O
f	*(struct(int,float,float,array(float)))
->	O
values	array(float)
[	O
i	int
+	O
1	int
]	O
)	O
;	O
}	O
}	O
float	O
soft_cap	(float,float)->(float)
(	O
float	O
a	float
,	O
float	O
b	float
)	O
{	O
return	O
(	O
(	O
a	float
*	O
b	float
)	O
/	O
(	O
a	float
+	O
b	float
)	O
)	O
;	O
}	O
void	O
rotate	(int,int,*(int),*(int),int,int)->(void)
(	O
int	O
i	int
,	O
int	O
j	int
,	O
int	O
*	O
ri	*(int)
,	O
int	O
*	O
rj	*(int)
,	O
int	O
bs	int
,	O
int	O
rot	int
)	O
{	O
int	O
bs1	int
;	O
assert	O
(	O
bs	int
>	O
0	int
)	O
;	O
assert	O
(	O
ri	*(int)
!=	O
NULL	O
&&	O
rj	*(int)
!=	O
NULL	O
)	O
;	O
assert	O
(	O
rot	int
>=	O
0	int
&&	O
rot	int
<	O
8	int
)	O
;	O
if	O
(	O
i	int
==	O
-	O
1	int
&&	O
j	int
==	O
-	O
1	int
)	O
{	O
*	O
ri	*(int)
=	O
i	int
;	O
*	O
rj	*(int)
=	O
j	int
;	O
return	O
;	O
}	O
assert	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
bs	int
)	O
;	O
assert	O
(	O
j	int
>=	O
0	int
&&	O
j	int
<	O
bs	int
)	O
;	O
bs1	int
=	O
bs	int
-	O
1	int
;	O
if	O
(	O
rot	int
==	O
0	int
)	O
{	O
*	O
ri	*(int)
=	O
i	int
;	O
*	O
rj	*(int)
=	O
j	int
;	O
}	O
else	O
if	O
(	O
rot	int
==	O
1	int
)	O
{	O
*	O
ri	*(int)
=	O
bs1	int
-	O
j	int
;	O
*	O
rj	*(int)
=	O
i	int
;	O
}	O
else	O
if	O
(	O
rot	int
==	O
2	int
)	O
{	O
*	O
ri	*(int)
=	O
bs1	int
-	O
i	int
;	O
*	O
rj	*(int)
=	O
bs1	int
-	O
j	int
;	O
}	O
else	O
if	O
(	O
rot	int
==	O
3	int
)	O
{	O
*	O
ri	*(int)
=	O
j	int
;	O
*	O
rj	*(int)
=	O
bs1	int
-	O
i	int
;	O
}	O
else	O
if	O
(	O
rot	int
==	O
4	int
)	O
{	O
*	O
ri	*(int)
=	O
j	int
;	O
*	O
rj	*(int)
=	O
i	int
;	O
}	O
else	O
if	O
(	O
rot	int
==	O
5	int
)	O
{	O
*	O
ri	*(int)
=	O
bs1	int
-	O
i	int
;	O
*	O
rj	*(int)
=	O
j	int
;	O
}	O
else	O
if	O
(	O
rot	int
==	O
6	int
)	O
{	O
*	O
ri	*(int)
=	O
bs1	int
-	O
j	int
;	O
*	O
rj	*(int)
=	O
bs1	int
-	O
i	int
;	O
}	O
else	O
if	O
(	O
rot	int
==	O
7	int
)	O
{	O
*	O
ri	*(int)
=	O
i	int
;	O
*	O
rj	*(int)
=	O
bs1	int
-	O
j	int
;	O
}	O
}	O
void	O
inv_rotate	(int,int,*(int),*(int),int,int)->(void)
(	O
int	O
i	int
,	O
int	O
j	int
,	O
int	O
*	O
ri	*(int)
,	O
int	O
*	O
rj	*(int)
,	O
int	O
bs	int
,	O
int	O
rot	int
)	O
{	O
if	O
(	O
rot	int
==	O
1	int
)	O
rotate	(int,int,*(int),*(int),int,int)->(void)
(	O
i	int
,	O
j	int
,	O
ri	*(int)
,	O
rj	*(int)
,	O
bs	int
,	O
3	int
)	O
;	O
else	O
if	O
(	O
rot	int
==	O
3	int
)	O
rotate	(int,int,*(int),*(int),int,int)->(void)
(	O
i	int
,	O
j	int
,	O
ri	*(int)
,	O
rj	*(int)
,	O
bs	int
,	O
1	int
)	O
;	O
else	O
rotate	(int,int,*(int),*(int),int,int)->(void)
(	O
i	int
,	O
j	int
,	O
ri	*(int)
,	O
rj	*(int)
,	O
bs	int
,	O
rot	int
)	O
;	O
}	O
static	O
unsigned	O
int	O
random_seed	int
;	O
unsigned	O
int	O
get_random_seed	()->(int)
(	O
)	O
{	O
return	O
random_seed	int
;	O
}	O
void	O
set_random_seed	(int)->(void)
(	O
unsigned	O
int	O
seed	int
)	O
{	O
random_seed	int
=	O
seed	int
;	O
gg_srand	(int)->(void)
(	O
seed	int
)	O
;	O
}	O
void	O
update_random_seed	()->(void)
(	O
void	O
)	O
{	O
gg_srand	(int)->(void)
(	O
random_seed	int
)	O
;	O
random_seed	int
=	O
gg_rand	()->(int)
(	O
)	O
;	O
if	O
(	O
random_seed	int
==	O
0	int
)	O
random_seed	int
=	O
1	int
;	O
gg_srand	(int)->(void)
(	O
random_seed	int
)	O
;	O
}	O
void	O
reuse_random_seed	()->(void)
(	O
)	O
{	O
gg_srand	(int)->(void)
(	O
random_seed	int
)	O
;	O
}	O
