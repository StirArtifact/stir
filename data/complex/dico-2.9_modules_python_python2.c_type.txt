static	O
char	O
*	O
init_script	*(char)
;	O
static	O
char	O
*	O
load_path	*(char)
;	O
static	O
char	O
*	O
root_class	*(char)
=	O
"DicoModule"	*(char)
;	O
static	O
struct	O
dico_option	O
init_option	int
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	()->(int)
(	O
init	O
-	O
script	O
)	O
,	O
dico_opt_string	O
,	O
&	O
init_script	*(char)
}	O
,	O
{	O
DICO_OPTSTR	()->(int)
(	O
load	O
-	O
path	O
)	O
,	O
dico_opt_string	O
,	O
&	O
load_path	*(char)
}	O
,	O
{	O
DICO_OPTSTR	()->(int)
(	O
root	O
-	O
class	O
)	O
,	O
dico_opt_string	O
,	O
&	O
root_class	*(char)
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
{	O
const	O
char	O
*	O
dbname	*(char)
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
PyThreadState	O
*	O
py_ths	*(int)
;	O
PyObject	O
*	O
py_instance	*(int)
;	O
}	O
;	O
typedef	O
struct	O
{	O
PyObject_HEAD	int
;	O
struct	O
dico_key	O
*	O
key	*(struct)
;	O
}	O
PySelectionKey	struct(int,*(struct))
;	O
static	O
void	O
_PySelectionKey_dealloc	(*(int))->(void)
(	O
PyObject	O
*	O
self	*(int)
)	O
{	O
}	O
static	O
PyMethodDef	O
selection_key_methods	array(int)
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
PyObject	O
*	O
_PySelectionKey_getattr	(*(int),*(char))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
,	O
char	O
*	O
name	*(char)
)	O
{	O
PySelectionKey	struct(int,*(struct))
*	O
py_key	*(struct(int,*(struct)))
=	O
(	O
PySelectionKey	struct(int,*(struct))
*	O
)	O
self	*(int)
;	O
if	O
(	O
strcmp	O
(	O
name	*(char)
,	O
"word"	*(char)
)	O
==	O
0	int
)	O
return	O
PyString_FromString	()->(int)
(	O
py_key	*(struct(int,*(struct)))
->	O
key	*(struct)
->	O
word	*(char)
)	O
;	O
return	O
Py_FindMethod	()->(int)
(	O
selection_key_methods	array(int)
,	O
self	*(int)
,	O
name	*(char)
)	O
;	O
}	O
static	O
PyObject	O
*	O
_PySelectionKey_repr	(*(int))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
)	O
{	O
PySelectionKey	struct(int,*(struct))
*	O
py_key	*(struct(int,*(struct)))
=	O
(	O
PySelectionKey	struct(int,*(struct))
*	O
)	O
self	*(int)
;	O
char	O
buf	array(char)
[	O
80	int
]	O
;	O
snprintf	O
(	O
buf	array(char)
,	O
sizeof	O
buf	array(char)
,	O
"<DicoSelectionKey %s>"	*(char)
,	O
py_key	*(struct(int,*(struct)))
->	O
key	*(struct)
->	O
word	*(char)
)	O
;	O
return	O
PyString_FromString	()->(int)
(	O
buf	array(char)
)	O
;	O
}	O
static	O
PyObject	O
*	O
_PySelectionKey_str	(*(int))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
)	O
{	O
PySelectionKey	struct(int,*(struct))
*	O
py_key	*(struct(int,*(struct)))
=	O
(	O
PySelectionKey	struct(int,*(struct))
*	O
)	O
self	*(int)
;	O
return	O
PyString_FromString	()->(int)
(	O
py_key	*(struct(int,*(struct)))
->	O
key	*(struct)
->	O
word	*(char)
)	O
;	O
}	O
static	O
PyTypeObject	O
PySelectionKeyType	int
=	O
{	O
PyObject_HEAD_INIT	()->(int)
(	O
&	O
PyType_Type	O
)	O
0	int
,	O
"DicoSelectionKey"	*(char)
,	O
sizeof	O
(	O
PySelectionKey	struct(int,*(struct))
)	O
,	O
0	int
,	O
_PySelectionKey_dealloc	(*(int))->(void)
,	O
NULL	O
,	O
_PySelectionKey_getattr	(*(int),*(char))->(*(int))
,	O
NULL	O
,	O
NULL	O
,	O
_PySelectionKey_repr	(*(int))->(*(int))
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
_PySelectionKey_str	(*(int))->(*(int))
,	O
}	O
;	O
typedef	O
struct	O
{	O
PyObject_HEAD	int
;	O
dico_strategy_t	O
strat	int
;	O
}	O
PyStrategy	struct(int,int)
;	O
static	O
inline	O
PyObject	O
*	O
_ro	(*(int))->(*(int))
(	O
PyObject	O
*	O
obj	*(int)
)	O
{	O
Py_INCREF	()->(int)
(	O
obj	*(int)
)	O
;	O
return	O
obj	*(int)
;	O
}	O
static	O
PyObject	O
*	O
strat_select_method	(*(int),*(int))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
,	O
PyObject	O
*	O
args	*(int)
)	O
{	O
PyStrategy	struct(int,int)
*	O
py_strat	*(struct(int,int))
=	O
(	O
PyStrategy	struct(int,int)
*	O
)	O
self	*(int)
;	O
PySelectionKey	struct(int,*(struct))
*	O
py_key	*(struct(int,*(struct)))
;	O
char	O
*	O
word	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
PyArg_ParseTuple	()->(int)
(	O
args	*(int)
,	O
"sO!"	*(char)
,	O
&	O
word	*(char)
,	O
&	O
PySelectionKeyType	int
,	O
&	O
py_key	*(struct(int,*(struct)))
)	O
)	O
return	O
_ro	(*(int))->(*(int))
(	O
Py_False	O
)	O
;	O
return	O
_ro	(*(int))->(*(int))
(	O
py_strat	*(struct(int,int))
->	O
strat	int
->	O
sel	O
(	O
DICO_SELECT_RUN	O
,	O
py_key	*(struct(int,*(struct)))
->	O
key	*(struct)
,	O
word	*(char)
)	O
?	O
Py_True	O
:	O
Py_False	O
)	O
;	O
}	O
static	O
PyMethodDef	O
strategy_methods	array(int)
[	O
]	O
=	O
{	O
{	O
"select"	*(char)
,	O
strat_select_method	(*(int),*(int))->(*(int))
,	O
METH_VARARGS	O
,	O
"Return True if KEY matches WORD as per this strategy."	*(char)
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
void	O
_PyStrategy_dealloc	(*(int))->(void)
(	O
PyObject	O
*	O
self	*(int)
)	O
{	O
}	O
static	O
PyObject	O
*	O
_PyStrategy_getattr	(*(int),*(char))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
,	O
char	O
*	O
name	*(char)
)	O
{	O
PyStrategy	struct(int,int)
*	O
py_strat	*(struct(int,int))
=	O
(	O
PyStrategy	struct(int,int)
*	O
)	O
self	*(int)
;	O
dico_strategy_t	O
strat	int
=	O
py_strat	*(struct(int,int))
->	O
strat	int
;	O
if	O
(	O
strcmp	O
(	O
name	*(char)
,	O
"name"	*(char)
)	O
==	O
0	int
)	O
{	O
return	O
PyString_FromString	()->(int)
(	O
strat	int
->	O
name	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	O
(	O
name	*(char)
,	O
"descr"	*(char)
)	O
==	O
0	int
)	O
{	O
return	O
PyString_FromString	()->(int)
(	O
strat	int
->	O
descr	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	O
(	O
name	*(char)
,	O
"has_selector"	*(char)
)	O
==	O
0	int
)	O
{	O
return	O
_ro	(*(int))->(*(int))
(	O
strat	int
->	O
sel	O
?	O
Py_True	O
:	O
Py_False	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	O
(	O
name	*(char)
,	O
"is_default"	*(char)
)	O
==	O
0	int
)	O
{	O
return	O
_ro	(*(int))->(*(int))
(	O
dico_strategy_is_default_p	()->(int)
(	O
strat	int
)	O
?	O
Py_True	O
:	O
Py_False	O
)	O
;	O
}	O
return	O
Py_FindMethod	()->(int)
(	O
strategy_methods	array(int)
,	O
self	*(int)
,	O
name	*(char)
)	O
;	O
}	O
static	O
PyObject	O
*	O
_PyStrategy_repr	(*(int))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
)	O
{	O
PyStrategy	struct(int,int)
*	O
py_strat	*(struct(int,int))
=	O
(	O
PyStrategy	struct(int,int)
*	O
)	O
self	*(int)
;	O
char	O
buf	array(char)
[	O
80	int
]	O
;	O
snprintf	O
(	O
buf	array(char)
,	O
sizeof	O
buf	array(char)
,	O
"<DicoStrategy %s>"	*(char)
,	O
py_strat	*(struct(int,int))
->	O
strat	int
->	O
name	*(char)
)	O
;	O
return	O
PyString_FromString	()->(int)
(	O
buf	array(char)
)	O
;	O
}	O
static	O
PyObject	O
*	O
_PyStrategy_str	(*(int))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
)	O
{	O
PyStrategy	struct(int,int)
*	O
py_strat	*(struct(int,int))
=	O
(	O
PyStrategy	struct(int,int)
*	O
)	O
self	*(int)
;	O
return	O
PyString_FromString	()->(int)
(	O
py_strat	*(struct(int,int))
->	O
strat	int
->	O
name	*(char)
)	O
;	O
}	O
static	O
PyTypeObject	O
PyStrategyType	int
=	O
{	O
PyObject_HEAD_INIT	()->(int)
(	O
&	O
PyType_Type	O
)	O
0	int
,	O
"DicoStrategy"	*(char)
,	O
sizeof	O
(	O
PyStrategy	struct(int,int)
)	O
,	O
0	int
,	O
_PyStrategy_dealloc	(*(int))->(void)
,	O
NULL	O
,	O
_PyStrategy_getattr	(*(int),*(char))->(*(int))
,	O
NULL	O
,	O
NULL	O
,	O
_PyStrategy_repr	(*(int))->(*(int))
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
_PyStrategy_str	(*(int))->(*(int))
,	O
}	O
;	O
static	O
dico_stream_t	O
dico_stream_output	int
;	O
static	O
dico_stream_t	O
dico_stream_log_err	int
;	O
static	O
dico_stream_t	O
dico_stream_log_info	int
;	O
static	O
PyObject	O
*	O
_capture_stdout_result	(*(int),*(int))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
,	O
PyObject	O
*	O
args	*(int)
)	O
{	O
char	O
*	O
buf	array(char)
=	O
""	*(char)
;	O
if	O
(	O
!	O
PyArg_ParseTuple	()->(int)
(	O
args	*(int)
,	O
"s"	*(char)
,	O
&	O
buf	array(char)
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
dico_stream_output	int
)	O
dico_stream_write	()->(int)
(	O
dico_stream_output	int
,	O
buf	array(char)
,	O
strlen	O
(	O
buf	array(char)
)	O
)	O
;	O
return	O
_ro	(*(int))->(*(int))
(	O
Py_None	O
)	O
;	O
}	O
static	O
PyObject	O
*	O
_capture_stdout_info	(*(int),*(int))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
,	O
PyObject	O
*	O
args	*(int)
)	O
{	O
char	O
*	O
buf	array(char)
=	O
""	*(char)
;	O
if	O
(	O
!	O
PyArg_ParseTuple	()->(int)
(	O
args	*(int)
,	O
"s"	*(char)
,	O
&	O
buf	array(char)
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
dico_stream_log_info	int
)	O
dico_stream_write	()->(int)
(	O
dico_stream_log_info	int
,	O
buf	array(char)
,	O
strlen	O
(	O
buf	array(char)
)	O
)	O
;	O
return	O
_ro	(*(int))->(*(int))
(	O
Py_None	O
)	O
;	O
}	O
static	O
PyObject	O
*	O
_capture_stderr	(*(int),*(int))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
,	O
PyObject	O
*	O
args	*(int)
)	O
{	O
char	O
*	O
buf	array(char)
=	O
""	*(char)
;	O
if	O
(	O
!	O
PyArg_ParseTuple	()->(int)
(	O
args	*(int)
,	O
"s"	*(char)
,	O
&	O
buf	array(char)
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
dico_stream_log_err	int
)	O
dico_stream_write	()->(int)
(	O
dico_stream_log_err	int
,	O
buf	array(char)
,	O
strlen	O
(	O
buf	array(char)
)	O
)	O
;	O
return	O
_ro	(*(int))->(*(int))
(	O
Py_None	O
)	O
;	O
}	O
static	O
PyMethodDef	O
capture_stdout_result_method	array(int)
[	O
]	O
=	O
{	O
{	O
"write"	*(char)
,	O
_capture_stdout_result	(*(int),*(int))->(*(int))
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
PyMethodDef	O
capture_stdout_info_method	array(int)
[	O
]	O
=	O
{	O
{	O
"write"	*(char)
,	O
_capture_stdout_info	(*(int),*(int))->(*(int))
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
PyMethodDef	O
capture_stderr_method	array(int)
[	O
]	O
=	O
{	O
{	O
"write"	*(char)
,	O
_capture_stderr	(*(int),*(int))->(*(int))
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
int	O
_python_selector	(int,*(struct),*(char))->(int)
(	O
int	O
cmd	int
,	O
struct	O
dico_key	O
*	O
key	*(struct)
,	O
const	O
char	O
*	O
dict_word	*(char)
)	O
{	O
PyObject	O
*	O
py_args	*(int)
,	O
*	O
py_res	O
;	O
PySelectionKey	struct(int,*(struct))
*	O
py_key	*(struct(int,*(struct)))
;	O
void	O
*	O
closure	*(void)
=	O
key	*(struct)
->	O
strat	int
->	O
closure	*(void)
;	O
py_args	*(int)
=	O
PyTuple_New	()->(int)
(	O
3	int
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
0	int
,	O
PyInt_FromLong	()->(int)
(	O
cmd	int
)	O
)	O
;	O
py_key	*(struct(int,*(struct)))
=	O
PyObject_NEW	()->(int)
(	O
PySelectionKey	struct(int,*(struct))
,	O
&	O
PySelectionKeyType	int
)	O
;	O
py_key	*(struct(int,*(struct)))
->	O
key	*(struct)
=	O
key	*(struct)
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
1	int
,	O
(	O
PyObject	O
*	O
)	O
py_key	*(struct(int,*(struct)))
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
2	int
,	O
PyString_FromString	()->(int)
(	O
dict_word	*(char)
)	O
)	O
;	O
if	O
(	O
closure	*(void)
&&	O
PyCallable_Check	()->(int)
(	O
closure	*(void)
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	()->(int)
(	O
closure	*(void)
,	O
py_args	*(int)
)	O
;	O
if	O
(	O
py_res	O
)	O
{	O
if	O
(	O
PyBool_Check	()->(int)
(	O
py_res	O
)	O
)	O
return	O
py_res	O
==	O
Py_True	O
?	O
1	int
:	O
0	int
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
PyErr_Print	()->(int)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
PyObject	O
*	O
dico_register_strat	(*(int),*(int))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
,	O
PyObject	O
*	O
args	*(int)
)	O
{	O
struct	O
dico_strategy	O
strat	int
;	O
char	O
*	O
name	*(char)
=	O
NULL	O
;	O
char	O
*	O
descr	*(char)
=	O
NULL	O
;	O
char	O
*	O
fnc	*(char)
=	O
NULL	O
;	O
if	O
(	O
!	O
PyArg_ParseTuple	()->(int)
(	O
args	*(int)
,	O
"ss|s"	*(char)
,	O
&	O
name	*(char)
,	O
&	O
descr	*(char)
,	O
&	O
fnc	*(char)
)	O
)	O
return	O
NULL	O
;	O
strat	int
.	O
name	*(char)
=	O
name	*(char)
;	O
strat	int
.	O
descr	*(char)
=	O
descr	*(char)
;	O
if	O
(	O
!	O
fnc	*(char)
)	O
{	O
strat	int
.	O
sel	O
=	O
NULL	O
;	O
strat	int
.	O
closure	*(void)
=	O
NULL	O
;	O
}	O
else	O
{	O
strat	int
.	O
sel	O
=	O
_python_selector	(int,*(struct),*(char))->(int)
;	O
strat	int
.	O
closure	*(void)
=	O
fnc	*(char)
;	O
}	O
dico_strategy_add	()->(int)
(	O
&	O
strat	int
)	O
;	O
return	O
_ro	(*(int))->(*(int))
(	O
Py_None	O
)	O
;	O
}	O
static	O
PyObject	O
*	O
dico_register_markup	(*(int),*(int))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
,	O
PyObject	O
*	O
py_obj	*(int)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
type	*(char)
;	O
if	O
(	O
!	O
PyString_Check	()->(int)
(	O
py_obj	*(int)
)	O
)	O
{	O
PyErr_SetString	()->(int)
(	O
PyExc_TypeError	O
,	O
_	()->(int)
(	O
"This parameter must be a string"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
type	*(char)
=	O
strdup	O
(	O
PyString_AsString	()->(int)
(	O
py_obj	*(int)
)	O
)	O
;	O
rc	int
=	O
dico_markup_register	()->(int)
(	O
type	*(char)
)	O
;	O
free	()->(int)
(	O
type	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
NULL	O
;	O
return	O
_ro	(*(int))->(*(int))
(	O
Py_None	O
)	O
;	O
}	O
static	O
PyObject	O
*	O
dico_current_markup	(*(int))->(*(int))
(	O
PyObject	O
*	O
self	*(int)
)	O
{	O
return	O
_ro	(*(int))->(*(int))
(	O
PyString_FromString	()->(int)
(	O
dico_markup_type	O
)	O
)	O
;	O
}	O
static	O
PyMethodDef	O
dico_methods	array(int)
[	O
]	O
=	O
{	O
{	O
"register_strat"	*(char)
,	O
dico_register_strat	(*(int),*(int))->(*(int))
,	O
METH_VARARGS	O
,	O
"Register a new strategy."	*(char)
}	O
,	O
{	O
"register_markup"	*(char)
,	O
dico_register_markup	(*(int),*(int))->(*(int))
,	O
METH_O	O
,	O
"Register a new markup type."	*(char)
}	O
,	O
{	O
"current_markup"	*(char)
,	O
(	O
PyCFunction	O
)	O
dico_current_markup	(*(int))->(*(int))
,	O
METH_NOARGS	O
,	O
"Return current dico markup type."	*(char)
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
PyObject	O
*	O
_argv_to_tuple	(int,*(*(char)))->(*(int))
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
i	int
;	O
PyObject	O
*	O
py_args	*(int)
=	O
PyTuple_New	()->(int)
(	O
argc	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
argc	int
;	O
argc	int
--	O
,	O
argv	*(*(char))
++	O
,	O
i	int
++	O
)	O
{	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
i	int
,	O
PyString_FromString	()->(int)
(	O
*	O
argv	*(*(char))
)	O
)	O
;	O
}	O
return	O
py_args	*(int)
;	O
}	O
static	O
int	O
mod_init	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
dico_parseopt	()->(int)
(	O
init_option	int
,	O
argc	int
,	O
argv	*(*(char))
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
Py_IsInitialized	()->(int)
(	O
)	O
)	O
Py_Initialize	()->(int)
(	O
)	O
;	O
dico_stream_log_err	int
=	O
dico_log_stream_create	()->(int)
(	O
L_ERR	O
)	O
;	O
dico_stream_log_info	int
=	O
dico_log_stream_create	()->(int)
(	O
L_INFO	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
insert_load_path	(*(char))->(void)
(	O
const	O
char	O
*	O
dir	*(char)
)	O
{	O
PyObject	O
*	O
py_sys	O
,	O
*	O
py_path	O
,	O
*	O
py_dirstr	O
;	O
const	O
char	O
*	O
p	*(char)
;	O
py_sys	O
=	O
PyImport_ImportModule	()->(int)
(	O
"sys"	*(char)
)	O
;	O
py_path	O
=	O
PyObject_GetAttrString	()->(int)
(	O
py_sys	O
,	O
"path"	*(char)
)	O
;	O
p	*(char)
=	O
dir	*(char)
+	O
strlen	O
(	O
dir	*(char)
)	O
;	O
do	O
{	O
size_t	O
len	O
;	O
for	O
(	O
len	O
=	O
0	int
;	O
p	*(char)
>	O
dir	*(char)
&&	O
p	*(char)
[	O
-	O
1	int
]	O
!=	O
':'	O
;	O
p	*(char)
--	O
,	O
len	O
++	O
)	O
;	O
py_dirstr	O
=	O
PyString_FromStringAndSize	()->(int)
(	O
p	*(char)
,	O
len	O
)	O
;	O
if	O
(	O
PySequence_Index	()->(int)
(	O
py_path	O
,	O
py_dirstr	O
)	O
==	O
-	O
1	int
)	O
{	O
PyObject	O
*	O
py_list	O
;	O
PyErr_Clear	()->(int)
(	O
)	O
;	O
py_list	O
=	O
Py_BuildValue	()->(int)
(	O
"[O]"	*(char)
,	O
py_dirstr	O
)	O
;	O
PyList_SetSlice	()->(int)
(	O
py_path	O
,	O
0	int
,	O
0	int
,	O
py_list	O
)	O
;	O
Py_DECREF	()->(int)
(	O
py_list	O
)	O
;	O
}	O
Py_DECREF	()->(int)
(	O
py_dirstr	O
)	O
;	O
}	O
while	O
(	O
p	*(char)
--	O
>	O
dir	*(char)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_path	O
)	O
;	O
Py_DECREF	()->(int)
(	O
py_sys	O
)	O
;	O
}	O
static	O
struct	O
{	O
char	O
*	O
name	*(char)
;	O
int	O
value	int
;	O
}	O
constab	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"DICO_SELECT_BEGIN"	*(char)
,	O
DICO_SELECT_BEGIN	O
}	O
,	O
{	O
"DICO_SELECT_RUN"	*(char)
,	O
DICO_SELECT_RUN	O
}	O
,	O
{	O
"DICO_SELECT_END"	*(char)
,	O
DICO_SELECT_END	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
void	O
declare_constants	(*(int))->(void)
(	O
PyObject	O
*	O
module	*(int)
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
constab	array(struct(*(char),int))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
PyModule_AddIntConstant	()->(int)
(	O
module	*(int)
,	O
constab	array(struct(*(char),int))
[	O
i	int
]	O
.	O
name	*(char)
,	O
constab	array(struct(*(char),int))
[	O
i	int
]	O
.	O
value	int
)	O
;	O
}	O
static	O
dico_handle_t	O
mod_init_db	(*(char),int,*(*(char)))->(int)
(	O
const	O
char	O
*	O
dbname	*(char)
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
pindex	int
;	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
;	O
PyObject	O
*	O
py_err	O
,	O
*	O
py_out	O
,	O
*	O
py_name	O
,	O
*	O
py_module	O
,	O
*	O
py_class	O
;	O
PyThreadState	O
*	O
py_ths	*(int)
;	O
if	O
(	O
dico_parseopt	()->(int)
(	O
init_option	int
,	O
argc	int
,	O
argv	*(*(char))
,	O
DICO_PARSEOPT_PERMUTE	O
,	O
&	O
pindex	int
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
init_script	*(char)
)	O
return	O
NULL	O
;	O
argv	*(*(char))
+=	O
pindex	int
;	O
argc	int
-=	O
pindex	int
;	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
malloc	O
(	O
sizeof	O
(	O
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
)	O
)	O
;	O
if	O
(	O
!	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
)	O
{	O
DICO_LOG_ERRNO	()->(int)
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
dbname	*(char)
=	O
dbname	*(char)
;	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
argc	int
=	O
argc	int
;	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
argv	*(*(char))
=	O
argv	*(*(char))
;	O
py_ths	*(int)
=	O
Py_NewInterpreter	()->(int)
(	O
)	O
;	O
if	O
(	O
!	O
py_ths	*(int)
)	O
{	O
dico_log	()->(int)
(	O
L_ERR	O
,	O
0	int
,	O
_	()->(int)
(	O
"mod_init_db: cannot create new interpreter: %s"	*(char)
)	O
,	O
init_script	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
PyThreadState_Swap	()->(int)
(	O
py_ths	*(int)
)	O
;	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
=	O
py_ths	*(int)
;	O
declare_constants	(*(int))->(void)
(	O
Py_InitModule	()->(int)
(	O
"dico"	*(char)
,	O
dico_methods	array(int)
)	O
)	O
;	O
PyRun_SimpleString	()->(int)
(	O
"import sys"	*(char)
)	O
;	O
if	O
(	O
load_path	*(char)
)	O
insert_load_path	(*(char))->(void)
(	O
load_path	*(char)
)	O
;	O
insert_load_path	(*(char))->(void)
(	O
""	*(char)
)	O
;	O
py_err	O
=	O
Py_InitModule	()->(int)
(	O
"stderr"	*(char)
,	O
capture_stderr_method	array(int)
)	O
;	O
if	O
(	O
py_err	O
)	O
PySys_SetObject	()->(int)
(	O
"stderr"	*(char)
,	O
py_err	O
)	O
;	O
py_out	O
=	O
Py_InitModule	()->(int)
(	O
"stdout"	*(char)
,	O
capture_stdout_info_method	array(int)
)	O
;	O
if	O
(	O
py_out	O
)	O
PySys_SetObject	()->(int)
(	O
"stdout"	*(char)
,	O
py_out	O
)	O
;	O
py_name	O
=	O
PyString_FromString	()->(int)
(	O
init_script	*(char)
)	O
;	O
py_module	O
=	O
PyImport_Import	()->(int)
(	O
py_name	O
)	O
;	O
Py_DECREF	()->(int)
(	O
py_name	O
)	O
;	O
if	O
(	O
!	O
py_module	O
)	O
{	O
dico_log	()->(int)
(	O
L_ERR	O
,	O
0	int
,	O
_	()->(int)
(	O
"mod_init_db: cannot load init script: %s"	*(char)
)	O
,	O
init_script	*(char)
)	O
;	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
PyErr_Print	()->(int)
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
py_class	O
=	O
PyObject_GetAttrString	()->(int)
(	O
py_module	O
,	O
root_class	*(char)
)	O
;	O
if	O
(	O
py_class	O
&&	O
PyClass_Check	()->(int)
(	O
py_class	O
)	O
)	O
{	O
PyObject	O
*	O
py_instance	*(int)
=	O
PyInstance_New	()->(int)
(	O
py_class	O
,	O
_argv_to_tuple	(int,*(*(char)))->(*(int))
(	O
argc	int
,	O
argv	*(*(char))
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
py_instance	*(int)
&&	O
PyInstance_Check	()->(int)
(	O
py_instance	*(int)
)	O
)	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
=	O
py_instance	*(int)
;	O
else	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
{	O
PyErr_Print	()->(int)
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
{	O
dico_log	()->(int)
(	O
L_ERR	O
,	O
0	int
,	O
_	()->(int)
(	O
"mod_init_db: cannot create class instance: %s"	*(char)
)	O
,	O
root_class	*(char)
)	O
;	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
PyErr_Print	()->(int)
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
(	O
dico_handle_t	O
)	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
;	O
}	O
static	O
int	O
mod_free_db	(int)->(int)
(	O
dico_handle_t	O
hp	int
)	O
{	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
hp	int
;	O
PyThreadState_Swap	()->(int)
(	O
NULL	O
)	O
;	O
PyThreadState_Delete	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
free	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mod_open	(int)->(int)
(	O
dico_handle_t	O
hp	int
)	O
{	O
PyObject	O
*	O
py_args	*(int)
,	O
*	O
py_value	O
,	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
hp	int
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
py_value	O
=	O
PyString_FromString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
dbname	*(char)
)	O
;	O
py_args	*(int)
=	O
PyTuple_New	()->(int)
(	O
1	int
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
0	int
,	O
py_value	O
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"open"	*(char)
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	()->(int)
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	()->(int)
(	O
py_fnc	O
,	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
&&	O
PyBool_Check	()->(int)
(	O
py_res	O
)	O
&&	O
py_res	O
==	O
Py_False	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
{	O
PyErr_Print	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
mod_close	(int)->(int)
(	O
dico_handle_t	O
hp	int
)	O
{	O
PyObject	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
hp	int
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"close"	*(char)
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	()->(int)
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	()->(int)
(	O
py_fnc	O
,	O
NULL	O
)	O
;	O
Py_DECREF	()->(int)
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
&&	O
PyBool_Check	()->(int)
(	O
py_res	O
)	O
&&	O
py_res	O
==	O
Py_False	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
{	O
PyErr_Print	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
_mod_get_text	(*(int),*(char))->(*(char))
(	O
PyObject	O
*	O
py_instance	*(int)
,	O
const	O
char	O
*	O
method	*(char)
)	O
{	O
PyObject	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
if	O
(	O
!	O
py_instance	*(int)
)	O
return	O
NULL	O
;	O
else	O
if	O
(	O
!	O
PyObject_HasAttrString	()->(int)
(	O
py_instance	*(int)
,	O
method	*(char)
)	O
)	O
return	O
NULL	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	()->(int)
(	O
py_instance	*(int)
,	O
method	*(char)
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	()->(int)
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	()->(int)
(	O
py_fnc	O
,	O
NULL	O
)	O
;	O
Py_DECREF	()->(int)
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
&&	O
PyString_Check	()->(int)
(	O
py_res	O
)	O
)	O
{	O
char	O
*	O
text	*(char)
=	O
strdup	O
(	O
PyString_AsString	()->(int)
(	O
py_res	O
)	O
)	O
;	O
Py_DECREF	()->(int)
(	O
py_res	O
)	O
;	O
return	O
text	*(char)
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
PyErr_Print	()->(int)
(	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
mod_info	(int)->(*(char))
(	O
dico_handle_t	O
hp	int
)	O
{	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
hp	int
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
return	O
_mod_get_text	(*(int),*(char))->(*(char))
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"info"	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
mod_descr	(int)->(*(char))
(	O
dico_handle_t	O
hp	int
)	O
{	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
hp	int
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
return	O
_mod_get_text	(*(int),*(char))->(*(char))
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"descr"	*(char)
)	O
;	O
}	O
static	O
dico_list_t	O
_tuple_to_langlist	(*(int))->(int)
(	O
PyObject	O
*	O
py_obj	*(int)
)	O
{	O
dico_list_t	O
list	array(int)
=	O
NULL	O
;	O
if	O
(	O
!	O
py_obj	*(int)
)	O
return	O
NULL	O
;	O
if	O
(	O
PyString_Check	()->(int)
(	O
py_obj	*(int)
)	O
)	O
{	O
char	O
*	O
text	*(char)
=	O
strdup	O
(	O
PyString_AsString	()->(int)
(	O
py_obj	*(int)
)	O
)	O
;	O
list	array(int)
=	O
dico_list_create	()->(int)
(	O
)	O
;	O
dico_list_append	()->(int)
(	O
list	array(int)
,	O
text	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
PyTuple_Check	()->(int)
(	O
py_obj	*(int)
)	O
||	O
PyList_Check	()->(int)
(	O
py_obj	*(int)
)	O
)	O
{	O
PyObject	O
*	O
py_item	O
;	O
PyObject	O
*	O
py_iterator	O
=	O
PyObject_GetIter	()->(int)
(	O
py_obj	*(int)
)	O
;	O
list	array(int)
=	O
dico_list_create	()->(int)
(	O
)	O
;	O
if	O
(	O
py_iterator	O
)	O
{	O
while	O
(	O
(	O
py_item	O
=	O
PyIter_Next	()->(int)
(	O
py_iterator	O
)	O
)	O
)	O
{	O
if	O
(	O
PyString_Check	()->(int)
(	O
py_item	O
)	O
)	O
{	O
char	O
*	O
text	*(char)
=	O
strdup	O
(	O
PyString_AsString	()->(int)
(	O
py_item	O
)	O
)	O
;	O
dico_list_append	()->(int)
(	O
list	array(int)
,	O
text	*(char)
)	O
;	O
}	O
Py_DECREF	()->(int)
(	O
py_item	O
)	O
;	O
}	O
Py_DECREF	()->(int)
(	O
py_iterator	O
)	O
;	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
{	O
PyErr_Print	()->(int)
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
}	O
return	O
list	array(int)
;	O
}	O
static	O
int	O
mod_lang	(int,array(int))->(int)
(	O
dico_handle_t	O
hp	int
,	O
dico_list_t	O
list	array(int)
[	O
2	int
]	O
)	O
{	O
PyObject	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
hp	int
;	O
list	array(int)
[	O
0	int
]	O
=	O
list	array(int)
[	O
1	int
]	O
=	O
NULL	O
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
if	O
(	O
!	O
PyObject_HasAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"lang"	*(char)
)	O
)	O
return	O
1	int
;	O
py_fnc	O
=	O
PyObject_GetAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"lang"	*(char)
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	()->(int)
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	()->(int)
(	O
py_fnc	O
,	O
NULL	O
)	O
;	O
Py_DECREF	()->(int)
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
)	O
{	O
if	O
(	O
PyString_Check	()->(int)
(	O
py_res	O
)	O
)	O
{	O
char	O
*	O
text	*(char)
=	O
strdup	O
(	O
PyString_AsString	()->(int)
(	O
py_res	O
)	O
)	O
;	O
Py_DECREF	()->(int)
(	O
py_res	O
)	O
;	O
list	array(int)
[	O
0	int
]	O
=	O
dico_list_create	()->(int)
(	O
)	O
;	O
dico_list_append	()->(int)
(	O
list	array(int)
[	O
0	int
]	O
,	O
text	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
PyTuple_Check	()->(int)
(	O
py_res	O
)	O
)	O
{	O
switch	O
(	O
PyTuple_Size	()->(int)
(	O
py_res	O
)	O
)	O
{	O
case	O
2	int
:	O
list	array(int)
[	O
0	int
]	O
=	O
_tuple_to_langlist	(*(int))->(int)
(	O
PyTuple_GetItem	()->(int)
(	O
py_res	O
,	O
0	int
)	O
)	O
;	O
list	array(int)
[	O
1	int
]	O
=	O
_tuple_to_langlist	(*(int))->(int)
(	O
PyTuple_GetItem	()->(int)
(	O
py_res	O
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
list	array(int)
[	O
0	int
]	O
=	O
_tuple_to_langlist	(*(int))->(int)
(	O
PyTuple_GetItem	()->(int)
(	O
py_res	O
,	O
0	int
)	O
)	O
;	O
break	O
;	O
default	O
:	O
dico_log	()->(int)
(	O
L_ERR	O
,	O
0	int
,	O
_	()->(int)
(	O
"Method `lang' must return at most"	*(char)
" 2 elements"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
Py_DECREF	()->(int)
(	O
py_res	O
)	O
;	O
}	O
else	O
if	O
(	O
PyList_Check	()->(int)
(	O
py_res	O
)	O
)	O
{	O
switch	O
(	O
PyList_Size	()->(int)
(	O
py_res	O
)	O
)	O
{	O
case	O
2	int
:	O
list	array(int)
[	O
0	int
]	O
=	O
_tuple_to_langlist	(*(int))->(int)
(	O
PyList_GetItem	()->(int)
(	O
py_res	O
,	O
0	int
)	O
)	O
;	O
list	array(int)
[	O
1	int
]	O
=	O
_tuple_to_langlist	(*(int))->(int)
(	O
PyList_GetItem	()->(int)
(	O
py_res	O
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
list	array(int)
[	O
0	int
]	O
=	O
_tuple_to_langlist	(*(int))->(int)
(	O
PyList_GetItem	()->(int)
(	O
py_res	O
,	O
0	int
)	O
)	O
;	O
break	O
;	O
default	O
:	O
dico_log	()->(int)
(	O
L_ERR	O
,	O
0	int
,	O
_	()->(int)
(	O
"Method `lang' must return at most"	*(char)
" 2 elements"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
Py_DECREF	()->(int)
(	O
py_res	O
)	O
;	O
}	O
else	O
{	O
dico_log	()->(int)
(	O
L_ERR	O
,	O
0	int
,	O
_	()->(int)
(	O
"Method `lang' must return a tuple or "	*(char)
"a list"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
{	O
PyErr_Print	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
{	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
;	O
PyObject	O
*	O
result	*(int)
;	O
}	O
;	O
static	O
dico_result_t	O
_make_python_result	(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))->(int)
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
,	O
PyObject	O
*	O
res	*(int)
)	O
{	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
*	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
=	O
malloc	O
(	O
sizeof	O
(	O
*	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
)	O
)	O
;	O
if	O
(	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
)	O
{	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
;	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
=	O
res	*(int)
;	O
}	O
return	O
(	O
dico_result_t	O
)	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
;	O
}	O
dico_result_t	O
do_match	(*(struct(*(char),int,*(*(char)),*(int),*(int))),int,*(struct))->(int)
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
,	O
const	O
dico_strategy_t	O
strat	int
,	O
struct	O
dico_key	O
*	O
key	*(struct)
)	O
{	O
PyStrategy	struct(int,int)
*	O
py_strat	*(struct(int,int))
;	O
PySelectionKey	struct(int,*(struct))
*	O
py_key	*(struct(int,*(struct)))
;	O
PyObject	O
*	O
py_args	*(int)
,	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
py_key	*(struct(int,*(struct)))
=	O
PyObject_NEW	()->(int)
(	O
PySelectionKey	struct(int,*(struct))
,	O
&	O
PySelectionKeyType	int
)	O
;	O
if	O
(	O
!	O
py_key	*(struct(int,*(struct)))
)	O
return	O
NULL	O
;	O
py_key	*(struct(int,*(struct)))
->	O
key	*(struct)
=	O
key	*(struct)
;	O
py_strat	*(struct(int,int))
=	O
PyObject_NEW	()->(int)
(	O
PyStrategy	struct(int,int)
,	O
&	O
PyStrategyType	int
)	O
;	O
if	O
(	O
py_strat	*(struct(int,int))
)	O
{	O
py_strat	*(struct(int,int))
->	O
strat	int
=	O
strat	int
;	O
py_args	*(int)
=	O
PyTuple_New	()->(int)
(	O
2	int
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
0	int
,	O
(	O
PyObject	O
*	O
)	O
py_strat	*(struct(int,int))
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
1	int
,	O
(	O
PyObject	O
*	O
)	O
py_key	*(struct(int,*(struct)))
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"match_word"	*(char)
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	()->(int)
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	()->(int)
(	O
py_fnc	O
,	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
)	O
{	O
if	O
(	O
PyBool_Check	()->(int)
(	O
py_res	O
)	O
&&	O
py_res	O
==	O
Py_False	O
)	O
return	O
NULL	O
;	O
else	O
return	O
_make_python_result	(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
,	O
py_res	O
)	O
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
PyErr_Print	()->(int)
(	O
)	O
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
dico_result_t	O
mod_match	(int,int,*(char))->(int)
(	O
dico_handle_t	O
hp	int
,	O
const	O
dico_strategy_t	O
strat	int
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
hp	int
;	O
struct	O
dico_key	O
key	*(struct)
;	O
dico_result_t	O
res	*(int)
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
if	O
(	O
dico_key_init	()->(int)
(	O
&	O
key	*(struct)
,	O
strat	int
,	O
word	*(char)
)	O
)	O
{	O
dico_log	()->(int)
(	O
L_ERR	O
,	O
0	int
,	O
_	()->(int)
(	O
"mod_match: key initialization failed"	*(char)
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
res	*(int)
=	O
do_match	(*(struct(*(char),int,*(*(char)),*(int),*(int))),int,*(struct))->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
,	O
strat	int
,	O
&	O
key	*(struct)
)	O
;	O
dico_key_deinit	()->(int)
(	O
&	O
key	*(struct)
)	O
;	O
return	O
res	*(int)
;	O
}	O
static	O
dico_result_t	O
mod_define	(int,*(char))->(int)
(	O
dico_handle_t	O
hp	int
,	O
const	O
char	O
*	O
word	*(char)
)	O
{	O
PyObject	O
*	O
py_args	*(int)
,	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
hp	int
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
py_args	*(int)
=	O
PyTuple_New	()->(int)
(	O
1	int
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
0	int
,	O
PyString_FromString	()->(int)
(	O
word	*(char)
)	O
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"define_word"	*(char)
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	()->(int)
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	()->(int)
(	O
py_fnc	O
,	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
)	O
{	O
if	O
(	O
PyBool_Check	()->(int)
(	O
py_res	O
)	O
&&	O
py_res	O
==	O
Py_False	O
)	O
return	O
NULL	O
;	O
else	O
return	O
_make_python_result	(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
,	O
py_res	O
)	O
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
PyErr_Print	()->(int)
(	O
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
mod_output_result	(int,int,int)->(int)
(	O
dico_result_t	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
,	O
size_t	O
n	int
,	O
dico_stream_t	O
str	int
)	O
{	O
PyObject	O
*	O
py_args	*(int)
,	O
*	O
py_fnc	O
,	O
*	O
py_out	O
;	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
*	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
=	O
(	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
*	O
)	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
;	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
dico_stream_output	int
=	O
str	int
;	O
py_out	O
=	O
Py_InitModule	()->(int)
(	O
"stdout"	*(char)
,	O
capture_stdout_result_method	array(int)
)	O
;	O
if	O
(	O
py_out	O
)	O
PySys_SetObject	()->(int)
(	O
"stdout"	*(char)
,	O
py_out	O
)	O
;	O
else	O
{	O
dico_log	()->(int)
(	O
L_ERR	O
,	O
0	int
,	O
_	()->(int)
(	O
"mod_output_result: cannot capture stdout"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
py_args	*(int)
=	O
PyTuple_New	()->(int)
(	O
2	int
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
0	int
,	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
)	O
;	O
Py_INCREF	()->(int)
(	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
1	int
,	O
PyLong_FromLong	()->(int)
(	O
n	int
)	O
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"output"	*(char)
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	()->(int)
(	O
py_fnc	O
)	O
)	O
{	O
PyObject_CallObject	()->(int)
(	O
py_fnc	O
,	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_fnc	O
)	O
;	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
PyErr_Print	()->(int)
(	O
)	O
;	O
}	O
py_out	O
=	O
Py_InitModule	()->(int)
(	O
"stdout"	*(char)
,	O
capture_stdout_info_method	array(int)
)	O
;	O
if	O
(	O
py_out	O
)	O
PySys_SetObject	()->(int)
(	O
"stdout"	*(char)
,	O
py_out	O
)	O
;	O
dico_stream_output	int
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
size_t	O
_mod_get_size_t	(*(int),*(int),*(char))->(int)
(	O
PyObject	O
*	O
py_instance	*(int)
,	O
PyObject	O
*	O
py_args	*(int)
,	O
const	O
char	O
*	O
method	*(char)
)	O
{	O
PyObject	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
if	O
(	O
!	O
py_instance	*(int)
)	O
return	O
0	int
;	O
py_fnc	O
=	O
PyObject_GetAttrString	()->(int)
(	O
py_instance	*(int)
,	O
method	*(char)
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	()->(int)
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	()->(int)
(	O
py_fnc	O
,	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
&&	O
PyInt_Check	()->(int)
(	O
py_res	O
)	O
)	O
{	O
size_t	O
s	O
=	O
(	O
size_t	O
)	O
PyInt_AsSsize_t	O
(	O
py_res	O
)	O
;	O
Py_DECREF	()->(int)
(	O
py_res	O
)	O
;	O
return	O
s	O
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
PyErr_Print	()->(int)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
size_t	O
mod_result_count	(int)->(int)
(	O
dico_result_t	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
)	O
{	O
PyObject	O
*	O
py_args	*(int)
;	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
*	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
=	O
(	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
*	O
)	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
;	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
;	O
size_t	O
ret	O
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
py_args	*(int)
=	O
PyTuple_New	()->(int)
(	O
1	int
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
0	int
,	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
)	O
;	O
Py_INCREF	()->(int)
(	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
)	O
;	O
ret	O
=	O
_mod_get_size_t	(*(int),*(int),*(char))->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
py_args	*(int)
,	O
"result_count"	*(char)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_args	*(int)
)	O
;	O
return	O
ret	O
;	O
}	O
static	O
size_t	O
mod_compare_count	(int)->(int)
(	O
dico_result_t	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
)	O
{	O
PyObject	O
*	O
py_args	*(int)
;	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
*	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
=	O
(	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
*	O
)	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
;	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
;	O
size_t	O
ret	O
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
if	O
(	O
!	O
PyObject_HasAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"compare_count"	*(char)
)	O
)	O
return	O
0	int
;	O
py_args	*(int)
=	O
PyTuple_New	()->(int)
(	O
1	int
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
0	int
,	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
)	O
;	O
Py_INCREF	()->(int)
(	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
)	O
;	O
ret	O
=	O
_mod_get_size_t	(*(int),*(int),*(char))->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
py_args	*(int)
,	O
"compare_count"	*(char)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_args	*(int)
)	O
;	O
return	O
ret	O
;	O
}	O
static	O
void	O
mod_free_result	(int)->(void)
(	O
dico_result_t	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
)	O
{	O
PyObject	O
*	O
py_args	*(int)
,	O
*	O
py_fnc	O
;	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
*	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
=	O
(	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
*	O
)	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
;	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
if	O
(	O
!	O
PyObject_HasAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"free_result"	*(char)
)	O
)	O
return	O
;	O
py_args	*(int)
=	O
PyTuple_New	()->(int)
(	O
1	int
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
0	int
,	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
)	O
;	O
Py_INCREF	()->(int)
(	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"free_result"	*(char)
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	()->(int)
(	O
py_fnc	O
)	O
)	O
{	O
PyObject_CallObject	()->(int)
(	O
py_fnc	O
,	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_fnc	O
)	O
;	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
PyErr_Print	()->(int)
(	O
)	O
;	O
}	O
Py_DECREF	()->(int)
(	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
)	O
;	O
free	()->(int)
(	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
)	O
;	O
}	O
static	O
PyObject	O
*	O
_assoc_to_dict	(int)->(*(int))
(	O
dico_assoc_list_t	O
assoc	int
)	O
{	O
PyObject	O
*	O
py_dict	*(int)
;	O
dico_iterator_t	O
itr	O
;	O
struct	O
dico_assoc	O
*	O
p	*(char)
;	O
py_dict	*(int)
=	O
PyDict_New	()->(int)
(	O
)	O
;	O
if	O
(	O
py_dict	*(int)
)	O
{	O
itr	O
=	O
dico_assoc_iterator	()->(int)
(	O
assoc	int
)	O
;	O
for	O
(	O
p	*(char)
=	O
dico_iterator_first	()->(int)
(	O
itr	O
)	O
;	O
p	*(char)
;	O
p	*(char)
=	O
dico_iterator_next	()->(int)
(	O
itr	O
)	O
)	O
{	O
PyDict_SetItemString	()->(int)
(	O
py_dict	*(int)
,	O
p	*(char)
->	O
key	*(struct)
,	O
PyString_FromString	()->(int)
(	O
p	*(char)
->	O
value	int
)	O
)	O
;	O
}	O
dico_iterator_destroy	()->(int)
(	O
&	O
itr	O
)	O
;	O
return	O
_ro	(*(int))->(*(int))
(	O
py_dict	*(int)
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
_dict_to_assoc	(int,*(int))->(void)
(	O
dico_assoc_list_t	O
assoc	int
,	O
PyObject	O
*	O
py_dict	*(int)
)	O
{	O
PyObject	O
*	O
py_key	*(struct(int,*(struct)))
,	O
*	O
py_value	O
;	O
Py_ssize_t	O
py_pos	O
=	O
0	int
;	O
dico_assoc_clear	()->(int)
(	O
assoc	int
)	O
;	O
while	O
(	O
PyDict_Next	()->(int)
(	O
py_dict	*(int)
,	O
&	O
py_pos	O
,	O
&	O
py_key	*(struct(int,*(struct)))
,	O
&	O
py_value	O
)	O
)	O
{	O
char	O
*	O
key	*(struct)
,	O
*	O
val	*(char)
;	O
key	*(struct)
=	O
strdup	O
(	O
PyString_AsString	()->(int)
(	O
py_key	*(struct(int,*(struct)))
)	O
)	O
;	O
val	*(char)
=	O
strdup	O
(	O
PyString_AsString	()->(int)
(	O
py_value	O
)	O
)	O
;	O
dico_assoc_append	()->(int)
(	O
assoc	int
,	O
key	*(struct)
,	O
val	*(char)
)	O
;	O
}	O
}	O
static	O
int	O
mod_result_headers	(int,int)->(int)
(	O
dico_result_t	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
,	O
dico_assoc_list_t	O
hdr	int
)	O
{	O
PyObject	O
*	O
py_dict	*(int)
,	O
*	O
py_args	*(int)
,	O
*	O
py_fnc	O
,	O
*	O
py_res	O
;	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
*	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
=	O
(	O
struct	O
python_result	struct(*(struct(*(char),int,*(*(char)),*(int),*(int))),*(int))
*	O
)	O
rp	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
;	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
if	O
(	O
!	O
PyObject_HasAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"result_headers"	*(char)
)	O
)	O
return	O
0	int
;	O
py_dict	*(int)
=	O
_assoc_to_dict	(int)->(*(int))
(	O
hdr	int
)	O
;	O
py_args	*(int)
=	O
PyTuple_New	()->(int)
(	O
2	int
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
0	int
,	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
)	O
;	O
PyTuple_SetItem	()->(int)
(	O
py_args	*(int)
,	O
1	int
,	O
py_dict	*(int)
)	O
;	O
Py_INCREF	()->(int)
(	O
gres	*(struct(*(struct(*(char),int,*(*`),*(int),*(int))),*(int)))
->	O
result	*(int)
)	O
;	O
py_fnc	O
=	O
PyObject_GetAttrString	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"result_headers"	*(char)
)	O
;	O
if	O
(	O
py_fnc	O
&&	O
PyCallable_Check	()->(int)
(	O
py_fnc	O
)	O
)	O
{	O
py_res	O
=	O
PyObject_CallObject	()->(int)
(	O
py_fnc	O
,	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_args	*(int)
)	O
;	O
Py_DECREF	()->(int)
(	O
py_fnc	O
)	O
;	O
if	O
(	O
py_res	O
&&	O
PyDict_Check	()->(int)
(	O
py_res	O
)	O
)	O
{	O
_dict_to_assoc	(int,*(int))->(void)
(	O
hdr	int
,	O
py_res	O
)	O
;	O
Py_DECREF	()->(int)
(	O
py_res	O
)	O
;	O
}	O
else	O
if	O
(	O
PyErr_Occurred	()->(int)
(	O
)	O
)	O
{	O
PyErr_Print	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
Py_DECREF	()->(int)
(	O
py_dict	*(int)
)	O
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
mod_db_mime_header	(int)->(*(char))
(	O
dico_handle_t	O
hp	int
)	O
{	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
=	O
(	O
struct	O
_python_database	struct(*(char),int,*(*(char)),*(int),*(int))
*	O
)	O
hp	int
;	O
PyThreadState_Swap	()->(int)
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_ths	*(int)
)	O
;	O
return	O
_mod_get_text	(*(int),*(char))->(*(char))
(	O
db	*(struct(*(char),int,*(*(char)),*(int),*(int)))
->	O
py_instance	*(int)
,	O
"db_mime_header"	*(char)
)	O
;	O
}	O
struct	O
dico_database_module	O
DICO_EXPORT	()->(struct)
(	O
python	O
,	O
module	*(int)
)	O
=	O
{	O
.	O
dico_version	O
=	O
DICO_MODULE_VERSION	O
,	O
.	O
dico_capabilities	O
=	O
DICO_CAPA_NONE	O
,	O
.	O
dico_init	O
=	O
mod_init	(int,*(*(char)))->(int)
,	O
.	O
dico_init_db	O
=	O
mod_init_db	(*(char),int,*(*(char)))->(int)
,	O
.	O
dico_free_db	O
=	O
mod_free_db	(int)->(int)
,	O
.	O
dico_open	O
=	O
mod_open	(int)->(int)
,	O
.	O
dico_close	O
=	O
mod_close	(int)->(int)
,	O
.	O
dico_db_info	O
=	O
mod_info	(int)->(*(char))
,	O
.	O
dico_db_descr	O
=	O
mod_descr	(int)->(*(char))
,	O
.	O
dico_db_lang	O
=	O
mod_lang	(int,array(int))->(int)
,	O
.	O
dico_match	O
=	O
mod_match	(int,int,*(char))->(int)
,	O
.	O
dico_define	O
=	O
mod_define	(int,*(char))->(int)
,	O
.	O
dico_output_result	O
=	O
mod_output_result	(int,int,int)->(int)
,	O
.	O
dico_result_count	O
=	O
mod_result_count	(int)->(int)
,	O
.	O
dico_compare_count	O
=	O
mod_compare_count	(int)->(int)
,	O
.	O
dico_free_result	O
=	O
mod_free_result	(int)->(void)
,	O
.	O
dico_result_headers	O
=	O
mod_result_headers	(int,int)->(int)
,	O
.	O
dico_db_mime_header	O
=	O
mod_db_mime_header	(int)->(*(char))
}	O
;	O
