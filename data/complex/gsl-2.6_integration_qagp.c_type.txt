static	O
int	O
qagp	(*(struct(*((double,*`)->(double)),*(void))),*(double),long,double,double,long,*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))),*(double),*(double),*((*(struct(*`,*`)),double,double,*(double),*(double),*(double),*(double))->(void)))->(int)
(	O
const	O
gsl_function	struct(*((double,*(void))->(double)),*(void))
*	O
f	*(double)
,	O
const	O
double	O
*	O
pts	*(double)
,	O
const	O
size_t	long
npts	long
,	O
const	O
double	O
epsabs	double
,	O
const	O
double	O
epsrel	double
,	O
const	O
size_t	long
limit	long
,	O
gsl_integration_workspace	struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))
*	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
,	O
double	O
*	O
result	*(double)
,	O
double	O
*	O
abserr	*(double)
,	O
gsl_integration_rule	(*(struct(*((double,*`)->(double)),*(void))),double,double,*(double),*(double),*(double),*(double))->(void)
*	O
q	*((*(struct(*((double,*`)->(double)),*(void))),double,double,*(double),*(double),*(double),*(double))->(void))
)	O
;	O
int	O
gsl_integration_qagp	(*(struct(*((double,*`)->(double)),*(void))),*(double),long,double,double,long,*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))),*(double),*(double))->(int)
(	O
const	O
gsl_function	struct(*((double,*(void))->(double)),*(void))
*	O
f	*(double)
,	O
double	O
*	O
pts	*(double)
,	O
size_t	long
npts	long
,	O
double	O
epsabs	double
,	O
double	O
epsrel	double
,	O
size_t	long
limit	long
,	O
gsl_integration_workspace	struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))
*	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
,	O
double	O
*	O
result	*(double)
,	O
double	O
*	O
abserr	*(double)
)	O
{	O
int	O
status	int
=	O
qagp	(*(struct(*((double,*`)->(double)),*(void))),*(double),long,double,double,long,*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))),*(double),*(double),*((*(struct(*`,*`)),double,double,*(double),*(double),*(double),*(double))->(void)))->(int)
(	O
f	*(double)
,	O
pts	*(double)
,	O
npts	long
,	O
epsabs	double
,	O
epsrel	double
,	O
limit	long
,	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
,	O
result	*(double)
,	O
abserr	*(double)
,	O
&	O
gsl_integration_qk21	(*(struct(*((double,*`)->(double)),*(void))),double,double,*(double),*(double),*(double),*(double))->(void)
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
qagp	(*(struct(*((double,*`)->(double)),*(void))),*(double),long,double,double,long,*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))),*(double),*(double),*((*(struct(*`,*`)),double,double,*(double),*(double),*(double),*(double))->(void)))->(int)
(	O
const	O
gsl_function	struct(*((double,*(void))->(double)),*(void))
*	O
f	*(double)
,	O
const	O
double	O
*	O
pts	*(double)
,	O
const	O
size_t	long
npts	long
,	O
const	O
double	O
epsabs	double
,	O
const	O
double	O
epsrel	double
,	O
const	O
size_t	long
limit	long
,	O
gsl_integration_workspace	struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))
*	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
,	O
double	O
*	O
result	*(double)
,	O
double	O
*	O
abserr	*(double)
,	O
gsl_integration_rule	(*(struct(*((double,*`)->(double)),*(void))),double,double,*(double),*(double),*(double),*(double))->(void)
*	O
q	*((*(struct(*((double,*`)->(double)),*(void))),double,double,*(double),*(double),*(double),*(double))->(void))
)	O
{	O
double	O
area	double
,	O
errsum	double
;	O
double	O
res_ext	double
,	O
err_ext	double
;	O
double	O
result0	double
,	O
abserr0	double
,	O
resabs0	double
;	O
double	O
tolerance	double
;	O
double	O
ertest	double
=	O
0	int
;	O
double	O
error_over_large_intervals	double
=	O
0	int
;	O
double	O
reseps	double
=	O
0	int
,	O
abseps	double
=	O
0	int
,	O
correc	double
=	O
0	int
;	O
size_t	long
ktmin	long
=	O
0	int
;	O
int	O
roundoff_type1	int
=	O
0	int
,	O
roundoff_type2	int
=	O
0	int
,	O
roundoff_type3	int
=	O
0	int
;	O
int	O
error_type	int
=	O
0	int
,	O
error_type2	int
=	O
0	int
;	O
size_t	long
iteration	long
=	O
0	int
;	O
int	O
positive_integrand	int
=	O
0	int
;	O
int	O
extrapolate	int
=	O
0	int
;	O
int	O
disallow_extrapolation	int
=	O
0	int
;	O
struct	O
extrapolation_table	struct(long,array(double),long,array(double))
table	*(struct(long,array(double),long,array(double)))
;	O
const	O
size_t	long
nint	long
=	O
npts	long
-	O
1	int
;	O
size_t	long
*	O
ndin	*(long)
=	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
->	O
level	*(long)
;	O
size_t	long
i	long
;	O
*	O
result	*(double)
=	O
0	int
;	O
*	O
abserr	*(double)
=	O
0	int
;	O
if	O
(	O
limit	long
>	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
->	O
limit	long
)	O
{	O
GSL_ERROR	O
(	O
"iteration limit exceeds available workspace"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
npts	long
>	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
->	O
limit	long
)	O
{	O
GSL_ERROR	O
(	O
"npts exceeds size of workspace"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
epsabs	double
<=	O
0	int
&&	O
(	O
epsrel	double
<	O
50	int
*	O
GSL_DBL_EPSILON	int
||	O
epsrel	double
<	O
0.5e-28	int
)	O
)	O
{	O
GSL_ERROR	O
(	O
"tolerance cannot be achieved with given epsabs and epsrel"	*(char)
,	O
GSL_EBADTOL	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nint	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
pts	*(double)
[	O
i	long
+	O
1	int
]	O
<	O
pts	*(double)
[	O
i	long
]	O
)	O
{	O
GSL_ERROR	O
(	O
"points are not in an ascending sequence"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
}	O
result0	double
=	O
0	int
;	O
abserr0	double
=	O
0	int
;	O
resabs0	double
=	O
0	int
;	O
initialise	(*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))),double,double)->(void)
(	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
,	O
0.0	int
,	O
0.0	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nint	long
;	O
i	long
++	O
)	O
{	O
double	O
area1	double
,	O
error1	double
,	O
resabs1	double
,	O
resasc1	double
;	O
const	O
double	O
a1	double
=	O
pts	*(double)
[	O
i	long
]	O
;	O
const	O
double	O
b1	double
=	O
pts	*(double)
[	O
i	long
+	O
1	int
]	O
;	O
q	*((*(struct(*((double,*`)->(double)),*(void))),double,double,*(double),*(double),*(double),*(double))->(void))
(	O
f	*(double)
,	O
a1	double
,	O
b1	double
,	O
&	O
area1	double
,	O
&	O
error1	double
,	O
&	O
resabs1	double
,	O
&	O
resasc1	double
)	O
;	O
result0	double
=	O
result0	double
+	O
area1	double
;	O
abserr0	double
=	O
abserr0	double
+	O
error1	double
;	O
resabs0	double
=	O
resabs0	double
+	O
resabs1	double
;	O
append_interval	(*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))),double,double,double,double)->(void)
(	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
,	O
a1	double
,	O
b1	double
,	O
area1	double
,	O
error1	double
)	O
;	O
if	O
(	O
error1	double
==	O
resasc1	double
&&	O
error1	double
!=	O
0.0	int
)	O
{	O
ndin	*(long)
[	O
i	long
]	O
=	O
1	int
;	O
}	O
else	O
{	O
ndin	*(long)
[	O
i	long
]	O
=	O
0	int
;	O
}	O
}	O
errsum	double
=	O
0.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nint	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
ndin	*(long)
[	O
i	long
]	O
)	O
{	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
->	O
elist	*(double)
[	O
i	long
]	O
=	O
abserr0	double
;	O
}	O
errsum	double
=	O
errsum	double
+	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
->	O
elist	*(double)
[	O
i	long
]	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nint	long
;	O
i	long
++	O
)	O
{	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
->	O
level	*(long)
[	O
i	long
]	O
=	O
0	int
;	O
}	O
sort_results	(*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))))->(void)
(	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
)	O
;	O
tolerance	double
=	O
GSL_MAX_DBL	(double,double)->(double)
(	O
epsabs	double
,	O
epsrel	double
*	O
fabs	(double)->(double)
(	O
result0	double
)	O
)	O
;	O
if	O
(	O
abserr0	double
<=	O
100	int
*	O
GSL_DBL_EPSILON	int
*	O
resabs0	double
&&	O
abserr0	double
>	O
tolerance	double
)	O
{	O
*	O
result	*(double)
=	O
result0	double
;	O
*	O
abserr	*(double)
=	O
abserr0	double
;	O
GSL_ERROR	O
(	O
"cannot reach tolerance because of roundoff error"	*(char)
"on first attempt"	*(char)
,	O
GSL_EROUND	int
)	O
;	O
}	O
else	O
if	O
(	O
abserr0	double
<=	O
tolerance	double
)	O
{	O
*	O
result	*(double)
=	O
result0	double
;	O
*	O
abserr	*(double)
=	O
abserr0	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
limit	long
==	O
1	int
)	O
{	O
*	O
result	*(double)
=	O
result0	double
;	O
*	O
abserr	*(double)
=	O
abserr0	double
;	O
GSL_ERROR	O
(	O
"a maximum of one iteration was insufficient"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
}	O
initialise_table	(*(struct(long,array(double),long,array(double))))->(void)
(	O
&	O
table	*(struct(long,array(double),long,array(double)))
)	O
;	O
append_table	(*(struct(long,array(double),long,array(double))),double)->(void)
(	O
&	O
table	*(struct(long,array(double),long,array(double)))
,	O
result0	double
)	O
;	O
area	double
=	O
result0	double
;	O
res_ext	double
=	O
result0	double
;	O
err_ext	double
=	O
GSL_DBL_MAX	int
;	O
error_over_large_intervals	double
=	O
errsum	double
;	O
ertest	double
=	O
tolerance	double
;	O
positive_integrand	int
=	O
test_positivity	(double,double)->(int)
(	O
result0	double
,	O
resabs0	double
)	O
;	O
iteration	long
=	O
nint	long
-	O
1	int
;	O
do	O
{	O
size_t	long
current_level	long
;	O
double	O
a1	double
,	O
b1	double
,	O
a2	double
,	O
b2	double
;	O
double	O
a_i	double
,	O
b_i	double
,	O
r_i	double
,	O
e_i	double
;	O
double	O
area1	double
=	O
0	int
,	O
area2	double
=	O
0	int
,	O
area12	double
=	O
0	int
;	O
double	O
error1	double
=	O
0	int
,	O
error2	double
=	O
0	int
,	O
error12	double
=	O
0	int
;	O
double	O
resasc1	double
,	O
resasc2	double
;	O
double	O
resabs1	double
,	O
resabs2	double
;	O
double	O
last_e_i	double
;	O
retrieve	(*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))),*(double),*(double),*(double),*(double))->(void)
(	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
,	O
&	O
a_i	double
,	O
&	O
b_i	double
,	O
&	O
r_i	double
,	O
&	O
e_i	double
)	O
;	O
current_level	long
=	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
->	O
level	*(long)
[	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
->	O
i	long
]	O
+	O
1	int
;	O
a1	double
=	O
a_i	double
;	O
b1	double
=	O
0.5	int
*	O
(	O
a_i	double
+	O
b_i	double
)	O
;	O
a2	double
=	O
b1	double
;	O
b2	double
=	O
b_i	double
;	O
iteration	long
++	O
;	O
q	*((*(struct(*((double,*`)->(double)),*(void))),double,double,*(double),*(double),*(double),*(double))->(void))
(	O
f	*(double)
,	O
a1	double
,	O
b1	double
,	O
&	O
area1	double
,	O
&	O
error1	double
,	O
&	O
resabs1	double
,	O
&	O
resasc1	double
)	O
;	O
q	*((*(struct(*((double,*`)->(double)),*(void))),double,double,*(double),*(double),*(double),*(double))->(void))
(	O
f	*(double)
,	O
a2	double
,	O
b2	double
,	O
&	O
area2	double
,	O
&	O
error2	double
,	O
&	O
resabs2	double
,	O
&	O
resasc2	double
)	O
;	O
area12	double
=	O
area1	double
+	O
area2	double
;	O
error12	double
=	O
error1	double
+	O
error2	double
;	O
last_e_i	double
=	O
e_i	double
;	O
errsum	double
=	O
errsum	double
+	O
error12	double
-	O
e_i	double
;	O
area	double
=	O
area	double
+	O
area12	double
-	O
r_i	double
;	O
tolerance	double
=	O
GSL_MAX_DBL	(double,double)->(double)
(	O
epsabs	double
,	O
epsrel	double
*	O
fabs	(double)->(double)
(	O
area	double
)	O
)	O
;	O
if	O
(	O
resasc1	double
!=	O
error1	double
&&	O
resasc2	double
!=	O
error2	double
)	O
{	O
double	O
delta	double
=	O
r_i	double
-	O
area12	double
;	O
if	O
(	O
fabs	(double)->(double)
(	O
delta	double
)	O
<=	O
1.0e-5	int
*	O
fabs	(double)->(double)
(	O
area12	double
)	O
&&	O
error12	double
>=	O
0.99	int
*	O
e_i	double
)	O
{	O
if	O
(	O
!	O
extrapolate	int
)	O
{	O
roundoff_type1	int
++	O
;	O
}	O
else	O
{	O
roundoff_type2	int
++	O
;	O
}	O
}	O
if	O
(	O
i	long
>	O
10	int
&&	O
error12	double
>	O
e_i	double
)	O
{	O
roundoff_type3	int
++	O
;	O
}	O
}	O
if	O
(	O
roundoff_type1	int
+	O
roundoff_type2	int
>=	O
10	int
||	O
roundoff_type3	int
>=	O
20	int
)	O
{	O
error_type	int
=	O
2	int
;	O
}	O
if	O
(	O
roundoff_type2	int
>=	O
5	int
)	O
{	O
error_type2	int
=	O
1	int
;	O
}	O
if	O
(	O
subinterval_too_small	(double,double,double)->(int)
(	O
a1	double
,	O
a2	double
,	O
b2	double
)	O
)	O
{	O
error_type	int
=	O
4	int
;	O
}	O
update	(*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))),double,double,double,double,double,double,double,double)->(void)
(	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
,	O
a1	double
,	O
b1	double
,	O
area1	double
,	O
error1	double
,	O
a2	double
,	O
b2	double
,	O
area2	double
,	O
error2	double
)	O
;	O
if	O
(	O
errsum	double
<=	O
tolerance	double
)	O
{	O
goto	O
compute_result	O
;	O
}	O
if	O
(	O
error_type	int
)	O
{	O
break	O
;	O
}	O
if	O
(	O
iteration	long
>=	O
limit	long
-	O
1	int
)	O
{	O
error_type	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
disallow_extrapolation	int
)	O
{	O
continue	O
;	O
}	O
error_over_large_intervals	double
+=	O
-	O
last_e_i	double
;	O
if	O
(	O
current_level	long
<	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
->	O
maximum_level	long
)	O
{	O
error_over_large_intervals	double
+=	O
error12	double
;	O
}	O
if	O
(	O
!	O
extrapolate	int
)	O
{	O
if	O
(	O
large_interval	(*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))))->(int)
(	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
)	O
)	O
continue	O
;	O
extrapolate	int
=	O
1	int
;	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
->	O
nrmax	long
=	O
1	int
;	O
}	O
if	O
(	O
!	O
error_type2	int
&&	O
error_over_large_intervals	double
>	O
ertest	double
)	O
{	O
if	O
(	O
increase_nrmax	(*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))))->(int)
(	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
)	O
)	O
continue	O
;	O
}	O
append_table	(*(struct(long,array(double),long,array(double))),double)->(void)
(	O
&	O
table	*(struct(long,array(double),long,array(double)))
,	O
area	double
)	O
;	O
if	O
(	O
table	*(struct(long,array(double),long,array(double)))
.	O
n	int
<	O
3	int
)	O
{	O
goto	O
skip_extrapolation	O
;	O
}	O
qelg	(*(struct(long,array(double),long,array(double))),*(double),*(double))->(void)
(	O
&	O
table	*(struct(long,array(double),long,array(double)))
,	O
&	O
reseps	double
,	O
&	O
abseps	double
)	O
;	O
ktmin	long
++	O
;	O
if	O
(	O
ktmin	long
>	O
5	int
&&	O
err_ext	double
<	O
0.001	int
*	O
errsum	double
)	O
{	O
error_type	int
=	O
5	int
;	O
}	O
if	O
(	O
abseps	double
<	O
err_ext	double
)	O
{	O
ktmin	long
=	O
0	int
;	O
err_ext	double
=	O
abseps	double
;	O
res_ext	double
=	O
reseps	double
;	O
correc	double
=	O
error_over_large_intervals	double
;	O
ertest	double
=	O
GSL_MAX_DBL	(double,double)->(double)
(	O
epsabs	double
,	O
epsrel	double
*	O
fabs	(double)->(double)
(	O
reseps	double
)	O
)	O
;	O
if	O
(	O
err_ext	double
<=	O
ertest	double
)	O
break	O
;	O
}	O
if	O
(	O
table	*(struct(long,array(double),long,array(double)))
.	O
n	int
==	O
1	int
)	O
{	O
disallow_extrapolation	int
=	O
1	int
;	O
}	O
if	O
(	O
error_type	int
==	O
5	int
)	O
{	O
break	O
;	O
}	O
skip_extrapolation	O
:	O
reset_nrmax	(*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))))->(void)
(	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
)	O
;	O
extrapolate	int
=	O
0	int
;	O
error_over_large_intervals	double
=	O
errsum	double
;	O
}	O
while	O
(	O
iteration	long
<	O
limit	long
)	O
;	O
*	O
result	*(double)
=	O
res_ext	double
;	O
*	O
abserr	*(double)
=	O
err_ext	double
;	O
if	O
(	O
err_ext	double
==	O
GSL_DBL_MAX	int
)	O
goto	O
compute_result	O
;	O
if	O
(	O
error_type	int
||	O
error_type2	int
)	O
{	O
if	O
(	O
error_type2	int
)	O
{	O
err_ext	double
+=	O
correc	double
;	O
}	O
if	O
(	O
error_type	int
==	O
0	int
)	O
error_type	int
=	O
3	int
;	O
if	O
(	O
result	*(double)
!=	O
0	int
&&	O
area	double
!=	O
0	int
)	O
{	O
if	O
(	O
err_ext	double
/	O
fabs	(double)->(double)
(	O
res_ext	double
)	O
>	O
errsum	double
/	O
fabs	(double)->(double)
(	O
area	double
)	O
)	O
goto	O
compute_result	O
;	O
}	O
else	O
if	O
(	O
err_ext	double
>	O
errsum	double
)	O
{	O
goto	O
compute_result	O
;	O
}	O
else	O
if	O
(	O
area	double
==	O
0.0	int
)	O
{	O
goto	O
return_error	O
;	O
}	O
}	O
{	O
double	O
max_area	double
=	O
GSL_MAX_DBL	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
res_ext	double
)	O
,	O
fabs	(double)->(double)
(	O
area	double
)	O
)	O
;	O
if	O
(	O
!	O
positive_integrand	int
&&	O
max_area	double
<	O
0.01	int
*	O
resabs0	double
)	O
goto	O
return_error	O
;	O
}	O
{	O
double	O
ratio	double
=	O
res_ext	double
/	O
area	double
;	O
if	O
(	O
ratio	double
<	O
0.01	int
||	O
ratio	double
>	O
100	int
||	O
errsum	double
>	O
fabs	(double)->(double)
(	O
area	double
)	O
)	O
error_type	int
=	O
6	int
;	O
}	O
goto	O
return_error	O
;	O
compute_result	O
:	O
*	O
result	*(double)
=	O
sum_results	(*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long))))->(double)
(	O
workspace	*(struct(long,long,long,long,long,*(double),*(double),*(double),*(double),*(long),*(long)))
)	O
;	O
*	O
abserr	*(double)
=	O
errsum	double
;	O
return_error	O
:	O
if	O
(	O
error_type	int
>	O
2	int
)	O
error_type	int
--	O
;	O
if	O
(	O
error_type	int
==	O
0	int
)	O
{	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
error_type	int
==	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"number of iterations was insufficient"	*(char)
,	O
GSL_EMAXITER	int
)	O
;	O
}	O
else	O
if	O
(	O
error_type	int
==	O
2	int
)	O
{	O
GSL_ERROR	O
(	O
"cannot reach tolerance because of roundoff error"	*(char)
,	O
GSL_EROUND	int
)	O
;	O
}	O
else	O
if	O
(	O
error_type	int
==	O
3	int
)	O
{	O
GSL_ERROR	O
(	O
"bad integrand behavior found in the integration interval"	*(char)
,	O
GSL_ESING	int
)	O
;	O
}	O
else	O
if	O
(	O
error_type	int
==	O
4	int
)	O
{	O
GSL_ERROR	O
(	O
"roundoff error detected in the extrapolation table"	*(char)
,	O
GSL_EROUND	int
)	O
;	O
}	O
else	O
if	O
(	O
error_type	int
==	O
5	int
)	O
{	O
GSL_ERROR	O
(	O
"integral is divergent, or slowly convergent"	*(char)
,	O
GSL_EDIVERGE	int
)	O
;	O
}	O
else	O
{	O
GSL_ERROR	O
(	O
"could not integrate function"	*(char)
,	O
GSL_EFAILED	int
)	O
;	O
}	O
}	O
