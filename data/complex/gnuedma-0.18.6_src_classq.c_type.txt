ESint32	long
EDMAPROC	O
edma_get_class_name	(long,*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
EPChar	*(char)
class_name	*(char)
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_class_name"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
class_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
class_name	*(char)
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
EDMA_CLASS_NAME_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
SOID	long
EDMAPROC	O
edma_get_class_so_id	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_class_so_id"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
SOId	long
;	O
}	O
MAQID	long
EDMAPROC	O
edma_get_class_arch_id	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_class_arch_id"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
MaqId	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_module	(long,*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
EPChar	*(char)
module_name	*(char)
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_class_module"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
module_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
module_name	*(char)
,	O
gClass	O
[	O
class_id	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
ModuleName	array(char)
,	O
EDMA_CLASS_MODULE_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_namespace	(long,*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
EPChar	*(char)
name_space	*(char)
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_class_namespace"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
name_space	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
name_space	*(char)
,	O
gClass	O
[	O
class_id	long
]	O
->	O
NameSpace	array(char)
,	O
EDMA_CLASS_NAMESPACE_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_major_version	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_class_major_version"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
MajorVer	char
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_minor_version	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_class_minor_version"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
MinorVer	char
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_current_version	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_class_current_version"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
)	O
return	O
-	O
1	int
;	O
return	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
actual_version	long
;	O
}	O
EPChar	*(char)
EDMAPROC	O
edma_get_class_repo_dir	(long)->(*(char))
(	O
CLASSID	long
cid	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
cid	long
,	O
"edma_get_class_repo_dir"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
return	O
edma_repo_manager_get_repo_dir	(long)->(*(char))
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
;	O
}	O
EPChar	*(char)
EDMAPROC	O
edma_get_class_repo_name	(long)->(*(char))
(	O
CLASSID	long
cid	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
cid	long
,	O
"edma_get_class_repo_name"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
return	O
edma_repo_manager_get_repo_name	(long)->(*(char))
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_repo_type	(long)->(long)
(	O
CLASSID	long
cid	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
cid	long
,	O
"edma_get_class_repo_type"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
SClass	*(*(struct(char,char,char,char,char,long,long,array(char),char,char,long,array(char),long,long,long,struct(long,long,long,array(char),*(*`)),char,long,char,char,long,long,long,short,short,short,char,char,long,long)))
[	O
cid	long
]	O
->	O
repo_type	char
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_num_reg_classes	()->(long)
(	O
void	O
)	O
{	O
return	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
nClases	long
+	O
nLocalClasses	long
;	O
}	O
CLASSID	long
EDMAPROC	O
edma_get_real_id	(*(char),long)->(long)
(	O
EPChar	*(char)
class_name	*(char)
,	O
CLASSID	long
begin	long
)	O
{	O
EUint32	long
i	long
;	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
begin	long
,	O
"edma_get_real_id"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
class_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
begin	long
;	O
i	long
<	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
nClases	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
!=	O
0	int
)	O
if	O
(	O
ProcMapTable	*(char)
[	O
i	long
]	O
!=	O
CLASS_FREE	int
)	O
if	O
(	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array(char)
,	O
class_name	*(char)
,	O
EDMA_CLASS_NAME_LEN	int
)	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
nClases	long
)	O
return	O
-	O
1	int
;	O
else	O
return	O
i	long
;	O
}	O
CLASSID	long
EDMAPROC	O
edma_get_class_id_with_version	(*(char),long,long)->(long)
(	O
EPChar	*(char)
class_name	*(char)
,	O
ESint32	long
major_ver	long
,	O
ESint32	long
minor_ver	long
)	O
{	O
ESint32	long
i	long
,	O
j	long
;	O
EUint32	long
r	long
;	O
OBJID	long
idEMI	long
;	O
if	O
(	O
class_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
j	long
=	O
-	O
1	int
;	O
i	long
=	O
edma_dict_get_next_index	(*(struct(long,long,long,long,long,*(struct(*`,long,long)))),*(char),*(long))->(long)
(	O
edma_class_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
,	O
class_name	*(char)
,	O
&	O
j	long
)	O
;	O
while	O
(	O
i	long
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
gClass	O
[	O
i	long
]	O
->	O
MajorVer	char
==	O
major_ver	long
)	O
&&	O
(	O
gClass	O
[	O
i	long
]	O
->	O
MinorVer	char
==	O
minor_ver	long
)	O
)	O
break	O
;	O
else	O
{	O
i	long
=	O
edma_dict_get_next_index	(*(struct(long,long,long,long,long,*(struct(*`,long,long)))),*(char),*(long))->(long)
(	O
edma_class_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
,	O
class_name	*(char)
,	O
&	O
j	long
)	O
;	O
}	O
}	O
if	O
(	O
i	long
<	O
0	int
)	O
{	O
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
j	long
<	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
nClases	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
!=	O
0	int
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
->	O
Status	char
!=	O
CLASS_FREE	int
)	O
{	O
if	O
(	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array(char)
,	O
class_name	*(char)
,	O
EDMA_CLASS_NAME_LEN	int
)	O
)	O
==	O
0	int
)	O
if	O
(	O
(	O
gClass	O
[	O
i	long
]	O
->	O
MajorVer	char
==	O
major_ver	long
)	O
&&	O
(	O
gClass	O
[	O
i	long
]	O
->	O
MinorVer	char
==	O
minor_ver	long
)	O
)	O
break	O
;	O
j	long
++	O
;	O
}	O
if	O
(	O
i	long
==	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
nClases	long
)	O
{	O
r	long
=	O
-	O
1	int
;	O
if	O
(	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
GetClassEMI	long
!=	O
0	int
)	O
{	O
idEMI	long
=	O
edma_new_obj	(*(char))->(long)
(	O
gClass	O
[	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
GetClassEMI	long
]	O
->	O
ClassName	array(char)
)	O
;	O
if	O
(	O
idEMI	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_class_id] Can't create "	*(char)
"EMI handler object [%s]"	*(char)
,	O
gClass	O
[	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
GetClassEMI	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	long
=	O
(	O
CLASSID	long
)	O
edma_met3	(long,*(char))->(long)
(	O
idEMI	long
,	O
"GetClass"	*(char)
,	O
class_name	*(char)
)	O
;	O
edma_free_obj	(long)->(long)
(	O
idEMI	long
)	O
;	O
}	O
return	O
r	long
;	O
}	O
else	O
{	O
ProcMapTable	*(char)
[	O
i	long
]	O
=	O
CLASS_DEF	int
;	O
edma_dict_add_entry	(*(struct(long,long,long,long,long,*(struct(*`,long,long)))),*(char),long)->(long)
(	O
edma_class_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
,	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array(char)
,	O
i	long
)	O
;	O
return	O
i	long
;	O
}	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
gClass	O
[	O
i	long
]	O
!=	O
0	int
)	O
&&	O
(	O
ProcMapTable	*(char)
[	O
i	long
]	O
!=	O
CLASS_FREE	int
)	O
)	O
return	O
i	long
;	O
else	O
return	O
-	O
1	int
;	O
}	O
edma_printf	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"(edma_get_class_id_with_version) Unreacheable code"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
CLASSID	long
EDMAPROC	O
edma_get_class_id	(*(char))->(long)
(	O
EPChar	*(char)
class_name	*(char)
)	O
{	O
ESint32	long
i	long
;	O
EUint32	long
r	long
,	O
j	long
;	O
OBJID	long
idEMI	long
;	O
if	O
(	O
class_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
last_checked_versions	long
<	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
time_last_version_update	long
)	O
_edma_class_update_all_versions	()->(long)
(	O
)	O
;	O
if	O
(	O
(	O
i	long
=	O
edma_dict_get_index	(*(struct(long,long,long,long,long,*(struct(*`,long,long)))),*(char))->(long)
(	O
edma_class_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
,	O
class_name	*(char)
)	O
)	O
<	O
0	int
)	O
{	O
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
j	long
<	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
nClases	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
!=	O
0	int
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
->	O
Status	char
!=	O
CLASS_FREE	int
)	O
{	O
if	O
(	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array(char)
,	O
class_name	*(char)
,	O
EDMA_CLASS_NAME_LEN	int
)	O
)	O
==	O
0	int
)	O
break	O
;	O
j	long
++	O
;	O
}	O
if	O
(	O
i	long
==	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
nClases	long
)	O
{	O
r	long
=	O
-	O
1	int
;	O
if	O
(	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
GetClassEMI	long
!=	O
0	int
)	O
{	O
idEMI	long
=	O
edma_new_obj	(*(char))->(long)
(	O
gClass	O
[	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
GetClassEMI	long
]	O
->	O
ClassName	array(char)
)	O
;	O
if	O
(	O
idEMI	long
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_class_id] Can't create "	*(char)
"EMI handler object [%s]"	*(char)
,	O
gClass	O
[	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
GetClassEMI	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
r	long
=	O
(	O
CLASSID	long
)	O
edma_met3	(long,*(char))->(long)
(	O
idEMI	long
,	O
"GetClass"	*(char)
,	O
class_name	*(char)
)	O
;	O
edma_free_obj	(long)->(long)
(	O
idEMI	long
)	O
;	O
}	O
return	O
r	long
==	O
-	O
1	int
?	O
-	O
1	int
:	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
r	long
]	O
->	O
actual_version	long
;	O
}	O
else	O
{	O
ProcMapTable	*(char)
[	O
i	long
]	O
=	O
CLASS_DEF	int
;	O
edma_log	(*(char))->(long)
(	O
"[%s] Registering class %i'%s'"	*(char)
,	O
__FUNCTION__	O
,	O
i	long
,	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array(char)
)	O
;	O
edma_dict_add_entry	(*(struct(long,long,long,long,long,*(struct(*`,long,long)))),*(char),long)->(long)
(	O
edma_class_dict	*(struct(long,long,long,long,long,*(struct(*(char),long,long))))
,	O
gClass	O
[	O
i	long
]	O
->	O
ClassName	array(char)
,	O
i	long
)	O
;	O
return	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
i	long
]	O
->	O
actual_version	long
;	O
}	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
CLASSID	long
sel	long
=	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
i	long
]	O
->	O
actual_version	long
;	O
edma_log	(*(char))->(long)
(	O
"Looking for class '%s' I found '%s' v%d.%d\n"	*(char)
,	O
class_name	*(char)
,	O
gClass	O
[	O
sel	long
]	O
->	O
ClassName	array(char)
,	O
gClass	O
[	O
sel	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
sel	long
]	O
->	O
MinorVer	char
)	O
;	O
if	O
(	O
(	O
gClass	O
[	O
i	long
]	O
!=	O
0	int
)	O
&&	O
(	O
ProcMapTable	*(char)
[	O
i	long
]	O
!=	O
CLASS_FREE	int
)	O
)	O
return	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
i	long
]	O
->	O
actual_version	long
;	O
else	O
return	O
-	O
1	int
;	O
}	O
edma_printf	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"(edma_get_class_id) Unreacheable code"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
CLASSID	long
EDMAPROC	O
edma_get_next_class	(long)->(long)
(	O
CLASSID	long
cid	long
)	O
{	O
int	O
i	long
,	O
base	int
;	O
base	int
=	O
cid	long
;	O
if	O
(	O
cid	long
<	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
nClases	long
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"Looking in shared repository from index: %d"	*(char)
,	O
cid	long
)	O
;	O
for	O
(	O
i	long
=	O
cid	long
;	O
i	long
<	O
GVar	*(struct(long,long,long,long,long,long,long,long,long,array(struct(array(char),long)),array(struct(array(char),long)),long,long,array(char),*(struct(long,long,array(char),long,long,long,char,char)),long,long,long,union(struct(int,int,int,int,int,union(struct`,struct`)),array(char),long),array(struct(long,long,array(char))),long,long,long))
->	O
nClases	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
->	O
Status	char
!=	O
CLASS_FREE	int
)	O
return	O
i	long
;	O
base	int
=	O
MAX_CLASE	int
;	O
}	O
for	O
(	O
i	long
=	O
base	int
;	O
i	long
<	O
MAX_CLASE	int
+	O
nMaxLocalClasses	long
;	O
i	long
++	O
)	O
if	O
(	O
gClass	O
[	O
i	long
]	O
->	O
Status	char
!=	O
CLASS_FREE	int
)	O
return	O
i	long
;	O
return	O
-	O
1	int
;	O
}	O
EPChar	*(char)
EDMAPROC	O
edma_get_idf_file_path	(long)->(*(char))
(	O
CLASSID	long
cid	long
)	O
{	O
EPChar	*(char)
aux	*(char)
;	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
cid	long
,	O
"edma_get_idf_file_path"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
aux	*(char)
=	O
malloc	(int)->(*(void))
(	O
1024	int
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"Cannot alocate memory...\n"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
edma_repo_manager_get_repo_type	(long)->(long)
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
==	O
EDMA_SHARED_REPO	int
)	O
{	O
if	O
(	O
(	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
==	O
0	int
)	O
&&	O
(	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
==	O
0	int
)	O
)	O
snprintf	(*(char),int,*(char))->(int)
(	O
aux	*(char)
,	O
1024	int
,	O
"%s/%s/%s/%s.idf"	*(char)
,	O
edma_repo_manager_get_repo_dir	(long)->(*(char))
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
IDFDIR	*(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
ClassName	array(char)
)	O
;	O
else	O
snprintf	(*(char),int,*(char))->(int)
(	O
aux	*(char)
,	O
1024	int
,	O
"%s/%s/%s/%s_%d_%d.idf"	*(char)
,	O
edma_repo_manager_get_repo_dir	(long)->(*(char))
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
IDFDIR	*(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
ClassName	array(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
==	O
0	int
)	O
&&	O
(	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
==	O
0	int
)	O
)	O
snprintf	(*(char),int,*(char))->(int)
(	O
aux	*(char)
,	O
1024	int
,	O
"%s/%s/idf/%s/%s.idf"	*(char)
,	O
edma_repo_manager_get_repo_dir	(long)->(*(char))
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
edma_repo_manager_get_repo_name	(long)->(*(char))
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
ClassName	array(char)
)	O
;	O
else	O
snprintf	(*(char),int,*(char))->(int)
(	O
aux	*(char)
,	O
1024	int
,	O
"%s/%s/idf/%s/%s_%d_%d.idf"	*(char)
,	O
edma_repo_manager_get_repo_dir	(long)->(*(char))
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
edma_repo_manager_get_repo_name	(long)->(*(char))
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
ClassName	array(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
)	O
;	O
}	O
return	O
aux	*(char)
;	O
}	O
EPChar	*(char)
EDMAPROC	O
edma_get_impl_file_path	(long)->(*(char))
(	O
CLASSID	long
cid	long
)	O
{	O
EPChar	*(char)
aux	*(char)
;	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
cid	long
,	O
"edma_is_class_IDF_parser"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
aux	*(char)
=	O
malloc	(int)->(*(void))
(	O
1024	int
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"Cannot alocate memory...\n"	*(char)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
edma_repo_manager_get_repo_type	(long)->(long)
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
==	O
EDMA_SHARED_REPO	int
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
aux	*(char)
,	O
1024	int
,	O
"%s/lib/edma/%s/%s.so.%d.%d.0"	*(char)
,	O
edma_repo_manager_get_repo_dir	(long)->(*(char))
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
ModuleName	array(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
)	O
;	O
}	O
else	O
{	O
char	O
*	O
rn	*(char)
=	O
edma_repo_manager_get_repo_name	(long)->(*(char))
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
;	O
snprintf	(*(char),int,*(char))->(int)
(	O
aux	*(char)
,	O
1024	int
,	O
"%s/%s/lib/%s/%s.so.%d.%d.0"	*(char)
,	O
edma_repo_manager_get_repo_dir	(long)->(*(char))
(	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
)	O
,	O
rn	*(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
NameSpace	array(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
SysClass	struct(long,long,long,array(char),*(*(char)))
.	O
ModuleName	array(char)
,	O
gClass	O
[	O
cid	long
]	O
->	O
MajorVer	char
,	O
gClass	O
[	O
cid	long
]	O
->	O
MinorVer	char
)	O
;	O
free	(*(void))->(void)
(	O
rn	*(char)
)	O
;	O
}	O
return	O
aux	*(char)
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_class_IDF_parser	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_is_class_IDF_parser"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
IsIDF	char
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_class_SIU_proxy	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_is_class_SIU_proxy"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
IsSIU	char
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_class_EMI_handler	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_is_class_EMI_handler"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
IsEMI	char
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_num	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_prop_num"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_name	(long,long,*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
,	O
EPChar	*(char)
prop_name	*(char)
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_prop_name"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
prop_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_prop_name] Property %d doesn't exist "	*(char)
"for class %s[%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
prop_name	*(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
IdProp	array(char)
,	O
EDMA_PROP_NAME_LEN	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_num_superclasses	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_class_num_superclasses"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
Derived	long
;	O
}	O
CLASSID	long
EDMAPROC	O
edma_get_class_superclass	(long,long)->(long)
(	O
CLASSID	long
class_id	long
,	O
ESint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_class_superclass"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
indx	long
<	O
0	int
)	O
||	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
Derived	long
)	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_class_superclass] Index %d out of range for"	*(char)
"class %s [%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SCList	*(long)
[	O
indx	long
]	O
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_class_superclass_apoints	(long,long,*(char),*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
ESint32	long
indx	long
,	O
EPChar	*(char)
ap1	*(char)
,	O
EPChar	*(char)
ap2	*(char)
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_class_superclass"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
indx	long
<	O
0	int
)	O
||	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
Derived	long
)	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_class_superclass] Index %d out of range for"	*(char)
"class %s [%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
ap1	*(char)
==	O
NULL	O
)	O
||	O
(	O
ap2	*(char)
==	O
NULL	O
)	O
)	O
return	O
-	O
1	int
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
ap1	*(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SCIdList	*(array(char))
[	O
indx	long
]	O
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
ap1	*(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
SubCIdList	*(array(char))
[	O
indx	long
]	O
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_indx	(long,*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
EPChar	*(char)
prop_name	*(char)
)	O
{	O
EUint32	long
i	long
;	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_prop_indx"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
prop_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
i	long
]	O
.	O
IdProp	array(char)
,	O
prop_name	*(char)
,	O
EDMA_PROP_NAME_LEN	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
return	O
-	O
1	int
;	O
else	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_type	(long,long,*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
,	O
EPChar	*(char)
type_name	*(char)
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_prop_type"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
type_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_prop_type] Property %d doesn't exist "	*(char)
"for class %s[%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
type_name	*(char)
,	O
tipo	array(struct(array(char),long,long,array(char)))
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
Tipo	long
]	O
.	O
Id	long
,	O
EDMA_TYPE_NAME_LEN	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_met_num	(long)->(long)
(	O
CLASSID	long
class_id	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_met_num"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_met_name	(long,long,*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
,	O
EPChar	*(char)
met_name	*(char)
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_met_name"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
met_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_met_name] Method %d doesn't exist "	*(char)
"for class %s[%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
met_name	*(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
IdMet	array(char)
,	O
EDMA_MET_NAME_LEN	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_met_sig	(long,long,*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
,	O
EPChar	*(char)
met_sig	*(char)
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_met_sig"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
met_sig	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_met_sig] Method %d doesn't exist "	*(char)
"for class %s[%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
met_sig	*(char)
,	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Sign	array(char)
,	O
EDMA_MET_SIG_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_met_virtual	(long,long)->(long)
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_is_met_virtual"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_is_met_virtual] Method %d doesn't exist "	*(char)
"for class %s[%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Virtual	char
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_met_abstract	(long,long)->(long)
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_is_met_abstract"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_is_met_abstract] Method %d doesn't exist "	*(char)
"for class %s[%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Abstract	char
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_is_met_static	(long,long)->(long)
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_is_met_static"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_is_met_static] Method %d doesn't exist "	*(char)
"for class %s[%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
indx	long
]	O
.	O
Static	char
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_met_indx	(long,*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
EPChar	*(char)
met_name	*(char)
)	O
{	O
EUint32	long
i	long
;	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_method_indx"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
met_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
IdMet	array(char)
,	O
met_name	*(char)
,	O
EDMA_MET_NAME_LEN	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
return	O
-	O
1	int
;	O
else	O
return	O
i	long
;	O
}	O
PPROC	*(()->(long))
*	O
EDMAPROC	O
edma_get_met_func	(long,*(char))->(*(*(()->(long))))
(	O
CLASSID	long
class_id	long
,	O
EPChar	*(char)
met_name	*(char)
)	O
{	O
EUint32	long
i	long
;	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_method_indx"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
met_name	*(char)
==	O
NULL	O
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
IdMet	array(char)
,	O
met_name	*(char)
,	O
EDMA_MET_NAME_LEN	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
return	O
0	int
;	O
else	O
return	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
met_func	*(struct(*(*(()->(long)))))
[	O
i	long
]	O
.	O
Func	*(()->(long))
;	O
}	O
ESint32	long
EDMAPROC	O
edma_set_met_func	(long,*(char),*(*(()->(long))))->(long)
(	O
CLASSID	long
class_id	long
,	O
EPChar	*(char)
met_name	*(char)
,	O
PPROC	*(()->(long))
*	O
func	*((*(void))->(*(void)))
)	O
{	O
EUint32	long
i	long
;	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_method_indx"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
met_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
gClass	O
[	O
class_id	long
]	O
->	O
repo_type	char
!=	O
EDMA_LOCAL_REPO	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	(*(char),*(char),int)->(int)
(	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Met	*(struct(array(char),array(char),char,long,char,char))
[	O
i	long
]	O
.	O
IdMet	array(char)
,	O
met_name	*(char)
,	O
EDMA_MET_NAME_LEN	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
)	O
return	O
-	O
1	int
;	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
met_func	*(struct(*(*(()->(long)))))
[	O
i	long
]	O
.	O
Func	*(()->(long))
=	O
func	*((*(void))->(*(void)))
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_all_met_func	(long,*(*(*(()->(long)))))->(long)
(	O
OBJID	long
IdObj	long
,	O
PPROC	*(()->(long))
*	O
*	O
list	*(*(*(()->(long))))
)	O
{	O
CLASSID	long
class_id	long
;	O
ESint32	long
i	long
,	O
n	long
;	O
if	O
(	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_get_all_met_func"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
class_id	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
n	long
=	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
if	O
(	O
(	O
*	O
list	*(*(*(()->(long))))
=	O
(	O
PPROC	*(()->(long))
*	O
)	O
edma_palloc	(long)->(long)
(	O
sizeof	O
(	O
PPROC	*(()->(long))
*	O
)	O
*	O
n	long
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_all_met_func] Can't alloc space for "	*(char)
"method table from object %ld"	*(char)
,	O
IdObj	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
class_id	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
{	O
*	O
(	O
*	O
list	*(*(*(()->(long))))
+	O
i	long
)	O
=	O
(	O
PPROC	*(()->(long))
)	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
met_func	*(struct(*(*(()->(long)))))
[	O
i	long
]	O
.	O
Func	*(()->(long))
;	O
}	O
return	O
n	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_type_id	(long,long)->(long)
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_prop_type_id"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_prop_type_id] Property %d doesn't exist "	*(char)
"for class %s[%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
Tipo	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_type_sig	(long,long,*(char))->(long)
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
,	O
EPChar	*(char)
type_sig	*(char)
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_prop_type_sig"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
type_sig	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_prop_type_sig] Property %d doesn't exist "	*(char)
"for class %s[%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
type_sig	*(char)
,	O
tipo	array(struct(array(char),long,long,array(char)))
[	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
Tipo	long
]	O
.	O
Sig	array(char)
,	O
EDMA_TYPE_SIG_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_num_elements	(long,long)->(long)
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_prop_num_elements"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_prop_num_elements] Property %d doesn't exist"	*(char)
" for class %s[%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
nElem	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_prop_strlen	(long,long)->(long)
(	O
CLASSID	long
class_id	long
,	O
EUint32	long
indx	long
)	O
{	O
if	O
(	O
(	O
edma_check_class_id	(long,*(char))->(long)
(	O
class_id	long
,	O
"edma_get_prop_num_elements"	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
indx	long
>	O
gClass	O
[	O
class_id	long
]	O
->	O
nProp	short
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_prop_num_elements] Property %d doesn't exist"	*(char)
" for class %s[%ld]"	*(char)
,	O
indx	long
,	O
gClass	O
[	O
class_id	long
]	O
->	O
ClassName	array(char)
,	O
class_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
pClass	*(*(struct(long,struct(long,long,long,long,long,long,long,long),*(struct(array(char),array(char),char,long,char,char)),*(struct(array(char),long,char,short,long,long)),*(struct(array(char),long,*`,long,*`,long)),*(long),*(array(char)),*(array(char)),*(struct(*`)),long,*(struct(long,long,long,long,long,*`)),*(struct(long,long,long,long,long,*`)),long)))
[	O
class_id	long
]	O
->	O
Prop	*(struct(array(char),long,char,short,long,long))
[	O
indx	long
]	O
.	O
nElem	long
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_type_size	(long)->(long)
(	O
EUint32	long
type_id	long
)	O
{	O
if	O
(	O
(	O
type_id	long
<	O
0	int
)	O
||	O
(	O
type_id	long
>	O
MAX_TIPOS	int
)	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_Get_type_size] Type identifier %d "	*(char)
"isn't valid"	*(char)
,	O
type_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
tipo	array(struct(array(char),long,long,array(char)))
[	O
type_id	long
]	O
.	O
tam	long
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_type_sig	(long,*(char))->(long)
(	O
EUint32	long
type_id	long
,	O
EPChar	*(char)
type_name	*(char)
)	O
{	O
if	O
(	O
(	O
type_id	long
<	O
0	int
)	O
||	O
(	O
type_id	long
>	O
MAX_TIPOS	int
)	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_get_type_sig] Type identifier %d isn't valid"	*(char)
,	O
type_id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
type_name	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
type_name	*(char)
,	O
tipo	array(struct(array(char),long,long,array(char)))
[	O
type_id	long
]	O
.	O
Sig	array(char)
,	O
EDMA_TYPE_SIG_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_type_id	(*(char))->(long)
(	O
EPChar	*(char)
pType	*(char)
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
MAX_TIPOS	int
;	O
i	long
++	O
)	O
if	O
(	O
strncasecmp	(*(char),*(char),int)->(int)
(	O
tipo	array(struct(array(char),long,long,array(char)))
[	O
i	long
]	O
.	O
Id	long
,	O
pType	*(char)
,	O
EDMA_TYPE_SIG_LEN	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
MAX_TIPOS	int
)	O
return	O
-	O
1	int
;	O
return	O
i	long
;	O
}	O
