char	O
*	O
hd_table	array(*(char))
[	O
HD_ELEMS_MAX	int
]	O
=	O
{	O
(	O
char	O
*	O
)	O
NULL	O
}	O
;	O
char	O
hd_ldays	array(char)
[	O
HD_MAX	int
]	O
=	O
{	O
'\0'	O
}	O
;	O
char	O
hd_mdays	array(char)
[	O
HD_MAX	int
]	O
=	O
{	O
'\0'	O
}	O
;	O
int	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
,	O
wd	int
,	O
forwards	int
)	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
const	O
int	O
wd	int
;	O
const	O
Bool	int
forwards	int
;	O
{	O
LOOP	O
{	O
if	O
(	O
weekday_of_date	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
==	O
wd	int
)	O
break	O
;	O
else	O
(	O
forwards	int
)	O
?	O
day	int
++	O
:	O
day	int
--	O
;	O
}	O
if	O
(	O
(	O
year	int
==	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
&&	O
(	O
month	int
==	O
greg	*(struct(int,int,int,int))
->	O
month	int
)	O
&&	O
(	O
day	int
>=	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
)	O
&&	O
(	O
day	int
<=	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
)	O
)	O
day	int
=	O
(	O
forwards	int
)	O
?	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
+	O
1	int
,	O
month	int
,	O
year	int
,	O
wd	int
,	O
forwards	int
)	O
:	O
eval_holiday	(int,int,int,int,int)->(int)
(	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
-	O
1	int
,	O
month	int
,	O
year	int
,	O
wd	int
,	O
forwards	int
)	O
;	O
return	O
(	O
day	int
)	O
;	O
}	O
int	O
orthodox_easter	(int,*(int),int,int,int,int)->(int)
(	O
year	int
,	O
greg_diff	*(int)
,	O
greg_year	int
,	O
greg_month	int
,	O
greg_first_day	int
,	O
greg_last_day	int
)	O
const	O
int	O
year	int
;	O
int	O
*	O
greg_diff	*(int)
;	O
const	O
int	O
greg_year	int
;	O
const	O
int	O
greg_month	int
;	O
const	O
int	O
greg_first_day	int
;	O
const	O
int	O
greg_last_day	int
;	O
{	O
auto	O
Greg_struct	struct(int,int,int,int)
tmp_greg	struct(int,int,int,int)
;	O
register	O
int	O
easter	int
;	O
register	O
int	O
diff	int
;	O
tmp_greg	struct(int,int,int,int)
.	O
first_day	int
=	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
;	O
tmp_greg	struct(int,int,int,int)
.	O
last_day	int
=	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
;	O
tmp_greg	struct(int,int,int,int)
.	O
month	int
=	O
greg	*(struct(int,int,int,int))
->	O
month	int
;	O
tmp_greg	struct(int,int,int,int)
.	O
year	int
=	O
greg	*(struct(int,int,int,int))
->	O
year	int
;	O
if	O
(	O
year	int
<	O
325	int
)	O
easter	int
=	O
tishri_1	(int)->(int)
(	O
year	int
)	O
-	O
163	int
;	O
else	O
{	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
=	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
=	O
DAY_MIN	int
;	O
greg	*(struct(int,int,int,int))
->	O
month	int
=	O
MONTH_MIN	int
;	O
greg	*(struct(int,int,int,int))
->	O
year	int
=	O
YEAR_MAX	int
+	O
3	int
;	O
easter	int
=	O
knuth_easter_formula	(int)->(int)
(	O
year	int
)	O
;	O
}	O
greg	*(struct(int,int,int,int))
->	O
year	int
=	O
greg_year	int
;	O
greg	*(struct(int,int,int,int))
->	O
month	int
=	O
greg_month	int
;	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
=	O
greg_first_day	int
;	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
=	O
greg_last_day	int
;	O
diff	int
=	O
julian_gregorian_diff	(int,int,int)->(int)
(	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
+	O
1	int
,	O
greg	*(struct(int,int,int,int))
->	O
month	int
,	O
year	int
)	O
;	O
if	O
(	O
greg_diff	*(int)
!=	O
(	O
int	O
*	O
)	O
NULL	O
)	O
*	O
greg_diff	*(int)
=	O
diff	int
;	O
greg	*(struct(int,int,int,int))
->	O
year	int
=	O
tmp_greg	struct(int,int,int,int)
.	O
year	int
;	O
greg	*(struct(int,int,int,int))
->	O
month	int
=	O
tmp_greg	struct(int,int,int,int)
.	O
month	int
;	O
greg	*(struct(int,int,int,int))
->	O
last_day	int
=	O
tmp_greg	struct(int,int,int,int)
.	O
last_day	int
;	O
greg	*(struct(int,int,int,int))
->	O
first_day	int
=	O
tmp_greg	struct(int,int,int,int)
.	O
first_day	int
;	O
return	O
(	O
easter	int
+	O
diff	int
)	O
;	O
}	O
int	O
tishri_1	(int)->(int)
(	O
year	int
)	O
const	O
int	O
year	int
;	O
{	O
auto	O
double	O
n	long
;	O
register	O
int	O
golden_number	int
=	O
(	O
year	int
%	O
19	int
)	O
+	O
1	int
;	O
register	O
int	O
g12	int
=	O
(	O
12	int
*	O
golden_number	int
)	O
%	O
19	int
;	O
register	O
int	O
doy	int
=	O
day_of_year	(int,int,int)->(int)
(	O
dvec	array(int)
[	O
8	int
-	O
1	int
]	O
,	O
8	int
,	O
year	int
)	O
;	O
n	long
=	O
(	O
(	O
765433.0	int
/	O
492480.0	int
)	O
*	O
g12	int
)	O
+	O
(	O
(	O
year	int
%	O
4	int
)	O
/	O
4.0	int
)	O
-	O
(	O
(	O
(	O
313.0	int
*	O
year	int
)	O
+	O
89081.0	int
)	O
/	O
98496.0	int
)	O
;	O
if	O
(	O
year	int
>=	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
n	long
+=	O
(	O
(	O
year	int
/	O
100	int
)	O
-	O
(	O
year	int
/	O
400	int
)	O
-	O
2.0	int
)	O
;	O
doy	int
+=	O
(	O
int	O
)	O
n	long
;	O
switch	O
(	O
weekday_of_date	(int,int,int)->(int)
(	O
(	O
int	O
)	O
n	long
,	O
9	int
,	O
year	int
)	O
)	O
{	O
case	O
3	int
:	O
case	O
5	int
:	O
case	O
DAY_MAX	int
:	O
doy	int
++	O
;	O
break	O
;	O
case	O
DAY_MIN	int
:	O
if	O
(	O
(	O
n	long
-	O
(	O
int	O
)	O
n	long
>=	O
23269.0	int
/	O
25920.0	int
)	O
&&	O
(	O
g12	int
>	O
11	int
)	O
)	O
doy	int
++	O
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
(	O
n	long
-	O
(	O
int	O
)	O
n	long
>=	O
1367.0	int
/	O
2160.0	int
)	O
&&	O
(	O
g12	int
>	O
6	int
)	O
)	O
doy	int
++	O
;	O
break	O
;	O
default	O
:	O
;	O
}	O
return	O
(	O
doy	int
)	O
;	O
}	O
int	O
muharram_1	(int,*(int))->(int)
(	O
year	int
,	O
doy	int
)	O
const	O
int	O
year	int
;	O
int	O
*	O
doy	int
;	O
{	O
auto	O
Ulint	long
mjd	double
;	O
register	O
int	O
i	int
;	O
register	O
int	O
hijri_year	int
;	O
auto	O
int	O
d	int
;	O
auto	O
int	O
m	int
;	O
auto	O
int	O
y	int
;	O
auto	O
int	O
d2	int
;	O
auto	O
int	O
m2	int
;	O
auto	O
int	O
y2	int
=	O
0	int
;	O
if	O
(	O
year	int
>	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
hijri_year	int
=	O
(	O
greg	*(struct(int,int,int,int))
->	O
year	int
-	O
621	int
)	O
*	O
1.03071206847898	int
+	O
(	O
year	int
-	O
greg	*(struct(int,int,int,int))
->	O
year	int
)	O
*	O
1.03069090396012	int
;	O
else	O
hijri_year	int
=	O
(	O
year	int
-	O
621	int
)	O
*	O
1.03071206847898	int
;	O
LOOP	O
{	O
mjd	double
=	O
227017L	int
+	O
(	O
Ulint	long
)	O
(	O
hijri_year	int
/	O
30	int
)	O
*	O
10631L	int
;	O
i	int
=	O
hijri_year	int
%	O
30	int
;	O
if	O
(	O
i	int
)	O
{	O
mjd	double
+=	O
(	O
Ulint	long
)	O
(	O
(	O
i	int
-	O
1	int
)	O
*	O
354	int
)	O
;	O
for	O
(	O
--	O
i	int
;	O
i	int
;	O
i	int
--	O
)	O
if	O
(	O
i	int
==	O
2	int
||	O
i	int
==	O
5	int
||	O
i	int
==	O
7	int
||	O
i	int
==	O
10	int
||	O
i	int
==	O
13	int
||	O
i	int
==	O
16	int
||	O
i	int
==	O
18	int
||	O
i	int
==	O
21	int
||	O
i	int
==	O
24	int
||	O
i	int
==	O
26	int
||	O
i	int
==	O
29	int
)	O
mjd	double
++	O
;	O
}	O
else	O
mjd	double
-=	O
354L	int
;	O
if	O
(	O
mjd	double
<	O
date2num	(int,int,int)->(long)
(	O
13	int
,	O
MONTH_MIN	int
,	O
year	int
)	O
)	O
{	O
num2date	(long,*(int),*(int),*(int))->(void)
(	O
mjd	double
,	O
&	O
d2	int
,	O
&	O
m2	int
,	O
&	O
y2	int
)	O
;	O
if	O
(	O
!	O
(	O
++	O
hijri_year	int
%	O
30	int
)	O
)	O
{	O
mjd	double
+=	O
355L	int
;	O
break	O
;	O
}	O
}	O
else	O
break	O
;	O
}	O
num2date	(long,*(int),*(int),*(int))->(void)
(	O
mjd	double
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
)	O
;	O
if	O
(	O
y	int
==	O
y2	int
)	O
{	O
*	O
doy	int
=	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
return	O
(	O
day_of_year	(int,int,int)->(int)
(	O
d2	int
,	O
m2	int
,	O
y2	int
)	O
)	O
;	O
}	O
*	O
doy	int
=	O
0	int
;	O
if	O
(	O
y2	int
==	O
year	int
)	O
return	O
(	O
day_of_year	(int,int,int)->(int)
(	O
d2	int
,	O
m2	int
,	O
y2	int
)	O
)	O
;	O
return	O
(	O
day_of_year	(int,int,int)->(int)
(	O
d	int
,	O
m	int
,	O
y	int
)	O
)	O
;	O
}	O
int	O
find_chinese_leap_month	(*(long),*(long),int,int,int)->(int)
(	O
conjunction_vector	*(long)
,	O
nh_ws_prev_year	*(long)
,	O
year	int
,	O
hour	int
,	O
min	int
)	O
Ulint	long
*	O
conjunction_vector	*(long)
;	O
Ulint	long
*	O
nh_ws_prev_year	*(long)
;	O
const	O
int	O
year	int
;	O
const	O
int	O
hour	int
;	O
const	O
int	O
min	int
;	O
{	O
auto	O
double	O
n	long
;	O
auto	O
Ulint	long
the_conjunction	long
=	O
0L	int
;	O
auto	O
Ulint	long
cj_prev	long
;	O
auto	O
Ulint	long
cj	long
;	O
auto	O
Ulint	long
zq_prev	long
;	O
auto	O
Ulint	long
zq	long
;	O
auto	O
Ulint	long
zq1	long
;	O
register	O
int	O
lm_prev	int
=	O
0	int
;	O
register	O
int	O
lm	int
=	O
0	int
;	O
register	O
int	O
i	int
=	O
0	int
;	O
register	O
int	O
j	int
=	O
0	int
;	O
auto	O
int	O
d	int
;	O
auto	O
int	O
m	int
;	O
auto	O
int	O
y	int
;	O
auto	O
int	O
d2	int
;	O
auto	O
int	O
m2	int
;	O
auto	O
int	O
y2	int
;	O
auto	O
Bool	int
lm_found	int
=	O
FALSE	O
;	O
auto	O
Bool	int
double_zq_found	int
=	O
FALSE	O
;	O
auto	O
Bool	int
second_double_zq_found	int
=	O
FALSE	O
;	O
y	int
=	O
year	int
;	O
n	long
=	O
NH_WS	int
;	O
zq1	long
=	O
(	O
Ulint	long
)	O
sun_longitude	(double,*(int),*(int),*(int),int,int,int)->(double)
(	O
n	long
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
hour	int
,	O
min	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
zq1	long
==	O
(	O
Ulint	long
)	O
SPECIAL_VALUE	O
)	O
return	O
(	O
(	O
int	O
)	O
zq1	long
)	O
;	O
zq1	long
=	O
(	O
Ulint	long
)	O
next_sun_longitude	(*(double),double,double,*(int),*(int),*(int),int,int)->(double)
(	O
&	O
n	long
,	O
60.0	int
,	O
(	O
double	O
)	O
zq1	long
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
hour	int
,	O
min	int
)	O
;	O
if	O
(	O
zq1	long
==	O
(	O
Ulint	long
)	O
SPECIAL_VALUE	O
)	O
return	O
(	O
(	O
int	O
)	O
zq1	long
)	O
;	O
y	int
=	O
year	int
-	O
1	int
;	O
n	long
=	O
NH_WS	int
-	O
30.0	int
;	O
zq_prev	long
=	O
(	O
Ulint	long
)	O
sun_longitude	(double,*(int),*(int),*(int),int,int,int)->(double)
(	O
n	long
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
hour	int
,	O
min	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
zq_prev	long
==	O
(	O
Ulint	long
)	O
SPECIAL_VALUE	O
)	O
return	O
(	O
(	O
int	O
)	O
zq_prev	long
)	O
;	O
*	O
nh_ws_prev_year	*(long)
=	O
zq	long
=	O
(	O
Ulint	long
)	O
next_sun_longitude	(*(double),double,double,*(int),*(int),*(int),int,int)->(double)
(	O
&	O
n	long
,	O
30.0	int
,	O
(	O
double	O
)	O
zq_prev	long
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
hour	int
,	O
min	int
)	O
;	O
if	O
(	O
zq	long
==	O
(	O
Ulint	long
)	O
SPECIAL_VALUE	O
)	O
return	O
(	O
(	O
int	O
)	O
zq	long
)	O
;	O
n	long
-=	O
30.0	int
;	O
*	O
conjunction_vector	*(long)
=	O
cj	long
=	O
(	O
Ulint	long
)	O
moonphase	(double,int,*(double),*(long),*(int),*(int),*(int),int,int)->(double)
(	O
MPHASE_NEW	int
,	O
FALSE	O
,	O
NULL	O
,	O
&	O
the_conjunction	long
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
hour	int
,	O
min	int
)	O
;	O
if	O
(	O
cj	long
>	O
zq	long
)	O
the_conjunction	long
--	O
;	O
y2	int
=	O
y	int
=	O
year	int
-	O
1	int
;	O
LOOP	O
{	O
cj_prev	long
=	O
cj	long
;	O
cj	long
=	O
(	O
Ulint	long
)	O
moonphase	(double,int,*(double),*(long),*(int),*(int),*(int),int,int)->(double)
(	O
MPHASE_NEW	int
,	O
FALSE	O
,	O
NULL	O
,	O
&	O
the_conjunction	long
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
hour	int
,	O
min	int
)	O
;	O
if	O
(	O
j	int
)	O
{	O
if	O
(	O
*	O
conjunction_vector	*(long)
!=	O
cj	long
)	O
*	O
(	O
conjunction_vector	*(long)
+	O
j	int
)	O
=	O
cj	long
;	O
else	O
j	int
--	O
;	O
}	O
if	O
(	O
lm	int
||	O
(	O
!	O
lm_found	int
&&	O
(	O
zq	long
<	O
cj	long
)	O
)	O
)	O
{	O
if	O
(	O
lm	int
)	O
{	O
if	O
(	O
!	O
lm_found	int
)	O
{	O
if	O
(	O
zq	long
>=	O
cj	long
)	O
{	O
lm_found	int
=	O
TRUE	O
;	O
lm	int
=	O
(	O
(	O
i	int
+	O
10	int
)	O
%	O
MONTH_MAX	int
)	O
-	O
1	int
;	O
if	O
(	O
lm	int
<=	O
0	int
)	O
{	O
lm	int
+=	O
MONTH_MAX	int
;	O
if	O
(	O
i	int
<	O
MONTH_MAX	int
)	O
lm	int
=	O
-	O
lm	int
;	O
}	O
}	O
}	O
}	O
else	O
lm	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
lm	int
=	O
0	int
;	O
if	O
(	O
lm_found	int
&&	O
(	O
zq_prev	long
>=	O
cj_prev	long
)	O
&&	O
(	O
zq	long
<	O
cj	long
)	O
)	O
{	O
if	O
(	O
!	O
double_zq_found	int
)	O
{	O
double_zq_found	int
=	O
TRUE	O
;	O
lm_prev	int
=	O
lm	int
;	O
}	O
else	O
second_double_zq_found	int
=	O
TRUE	O
;	O
if	O
(	O
lm	int
>	O
0	int
)	O
lm_found	int
=	O
FALSE	O
;	O
}	O
zq_prev	long
=	O
zq	long
;	O
zq	long
=	O
(	O
Ulint	long
)	O
next_sun_longitude	(*(double),double,double,*(int),*(int),*(int),int,int)->(double)
(	O
&	O
n	long
,	O
30.0	int
,	O
(	O
double	O
)	O
zq_prev	long
,	O
&	O
d2	int
,	O
&	O
m2	int
,	O
&	O
y2	int
,	O
hour	int
,	O
min	int
)	O
;	O
if	O
(	O
zq	long
==	O
(	O
Ulint	long
)	O
SPECIAL_VALUE	O
)	O
return	O
(	O
(	O
int	O
)	O
zq	long
)	O
;	O
if	O
(	O
cj	long
>=	O
zq1	long
)	O
break	O
;	O
the_conjunction	long
++	O
;	O
i	int
++	O
;	O
j	int
++	O
;	O
}	O
if	O
(	O
double_zq_found	int
&&	O
!	O
second_double_zq_found	int
)	O
{	O
y	int
=	O
year	int
;	O
zq	long
=	O
(	O
Ulint	long
)	O
sun_longitude	(double,*(int),*(int),*(int),int,int,int)->(double)
(	O
NH_WS	int
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
hour	int
,	O
min	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
zq	long
==	O
(	O
Ulint	long
)	O
SPECIAL_VALUE	O
)	O
return	O
(	O
(	O
int	O
)	O
zq	long
)	O
;	O
if	O
(	O
lm	int
==	O
MONTH_MAX	int
)	O
{	O
the_conjunction	long
=	O
0L	int
;	O
cj	long
=	O
(	O
Ulint	long
)	O
moonphase	(double,int,*(double),*(long),*(int),*(int),*(int),int,int)->(double)
(	O
MPHASE_NEW	int
,	O
FALSE	O
,	O
NULL	O
,	O
&	O
the_conjunction	long
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
hour	int
,	O
min	int
)	O
;	O
if	O
(	O
cj	long
==	O
zq	long
)	O
lm	int
=	O
lm_prev	int
;	O
}	O
else	O
if	O
(	O
lm	int
!=	O
MONTH_MAX	int
-	O
1	int
)	O
{	O
j	int
=	O
MONTH_MAX	int
-	O
2	int
;	O
while	O
(	O
*	O
(	O
conjunction_vector	*(long)
+	O
j	int
)	O
<=	O
zq	long
)	O
j	int
++	O
;	O
if	O
(	O
j	int
>	O
MONTH_MAX	int
)	O
lm	int
=	O
lm_prev	int
;	O
else	O
lm	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
if	O
(	O
lm	int
==	O
SPECIAL_VALUE	O
)	O
lm	int
=	O
0	int
;	O
return	O
(	O
lm	int
)	O
;	O
}	O
int	O
decode_date_format	(*(char),*(*(char)),int,int,int,int,int,int,int)->(int)
(	O
format_txt	*(char)
,	O
result_txt	*(*(char))
,	O
day	int
,	O
month	int
,	O
year	int
,	O
doy	int
,	O
hls1_set	int
,	O
hls2_set	int
,	O
fixed_length_names	int
)	O
char	O
*	O
format_txt	*(char)
;	O
char	O
*	O
*	O
result_txt	*(*(char))
;	O
int	O
day	int
;	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
const	O
int	O
doy	int
;	O
const	O
Bool	int
hls1_set	int
;	O
const	O
Bool	int
hls2_set	int
;	O
const	O
Bool	int
fixed_length_names	int
;	O
{	O
register	O
int	O
skip_space	int
=	O
0	int
;	O
register	O
int	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
format_txt	*(char)
)	O
;	O
register	O
int	O
j	int
;	O
register	O
int	O
k	int
;	O
register	O
int	O
n	long
;	O
register	O
int	O
hls_len	int
=	O
0	int
;	O
register	O
int	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
*	O
result_txt	*(*(char))
)	O
;	O
register	O
int	O
pos	int
;	O
auto	O
int	O
fstyle	*(int)
=	O
FSTYLE_NONE	O
;	O
auto	O
int	O
fwidth	*(int)
=	O
SPECIAL_VALUE	O
;	O
auto	O
int	O
d	int
=	O
day	int
;	O
auto	O
char	O
*	O
ptr_char	*(char)
;	O
auto	O
Bool	int
hlsxe_before_month	int
=	O
TRUE	O
;	O
auto	O
Bool	int
is_obsolete_space	int
=	O
FALSE	O
;	O
auto	O
Bool	int
is_marking_char	int
=	O
(	O
Bool	int
)	O
(	O
ehls1s	struct(*(char),int)
.	O
len	int
==	O
1	int
)	O
;	O
auto	O
Bool	int
is_special_date	int
=	O
(	O
!	O
day	int
&&	O
doy	int
)	O
;	O
auto	O
Bool	int
is_cformat	*(int)
=	O
FALSE	O
;	O
auto	O
Bool	int
is_lformat	*(int)
=	O
FALSE	O
;	O
auto	O
Bool	int
is_sign	*(int)
=	O
FALSE	O
;	O
auto	O
Bool	int
is_lzero	*(int)
=	O
FALSE	O
;	O
auto	O
Bool	int
is_fformat	*(int)
=	O
FALSE	O
;	O
auto	O
Bool	int
is_suffix	*(int)
=	O
FALSE	O
;	O
j	int
=	O
len	int
+	O
i	int
;	O
if	O
(	O
(	O
Uint	int
)	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
(	O
Uint	int
)	O
j	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
if	O
(	O
(	O
hls1_set	int
||	O
hls2_set	int
)	O
&&	O
!	O
is_marking_char	int
)	O
{	O
if	O
(	O
hls1_set	int
)	O
hls_len	int
=	O
ehls1s	struct(*(char),int)
.	O
len	int
+	O
ehls1e	struct(*(char),int)
.	O
len	int
;	O
else	O
hls_len	int
=	O
ehls2s	struct(*(char),int)
.	O
len	int
+	O
ehls2e	struct(*(char),int)
.	O
len	int
;	O
}	O
if	O
(	O
is_special_date	int
)	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
doy	int
,	O
(	O
days_of_february	(int)->(int)
(	O
year	int
)	O
==	O
29	int
)	O
,	O
&	O
day	int
,	O
&	O
month	int
)	O
;	O
do	O
{	O
while	O
(	O
*	O
format_txt	*(char)
&&	O
(	O
*	O
format_txt	*(char)
!=	O
DFORMAT_CHAR	char
)	O
&&	O
(	O
*	O
format_txt	*(char)
!=	O
QUOTE_CHAR	char
)	O
)	O
{	O
if	O
(	O
!	O
skip_space	int
||	O
(	O
(	O
*	O
format_txt	*(char)
!=	O
' '	O
)	O
&&	O
(	O
*	O
format_txt	*(char)
!=	O
PSEUDO_BLANK	char
)	O
)	O
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
if	O
(	O
*	O
format_txt	*(char)
==	O
PSEUDO_BLANK	char
)	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
++	O
)	O
=	O
' '	O
;	O
else	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
++	O
)	O
=	O
*	O
format_txt	*(char)
;	O
}	O
format_txt	*(char)
++	O
;	O
if	O
(	O
skip_space	int
)	O
skip_space	int
--	O
;	O
}	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
)	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
format_txt	*(char)
)	O
{	O
if	O
(	O
*	O
format_txt	*(char)
==	O
DFORMAT_CHAR	char
)	O
{	O
pos	int
=	O
decode_format	(*(char),int,*(int),*(int),*(int),*(int),*(int),*(int),*(int),*(int))->(int)
(	O
format_txt	*(char)
,	O
1	int
,	O
&	O
is_cformat	*(int)
,	O
&	O
is_lformat	*(int)
,	O
&	O
is_sign	*(int)
,	O
&	O
is_lzero	*(int)
,	O
&	O
is_suffix	*(int)
,	O
&	O
is_fformat	*(int)
,	O
&	O
fstyle	*(int)
,	O
&	O
fwidth	*(int)
)	O
;	O
format_txt	*(char)
+=	O
pos	int
;	O
if	O
(	O
fwidth	*(int)
!=	O
SPECIAL_VALUE	O
)	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
fwidth	*(int)
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
switch	O
(	O
*	O
format_txt	*(char)
)	O
{	O
case	O
HLS1S_CHAR	char
:	O
if	O
(	O
highlight_flag	int
)	O
{	O
if	O
(	O
!	O
hls1_set	int
&&	O
!	O
hls2_set	int
)	O
{	O
if	O
(	O
!	O
len	int
&&	O
is_marking_char	int
)	O
{	O
len	int
++	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
NO_HLS	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
len	int
)	O
if	O
(	O
is_marking_char	int
&&	O
(	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
(	O
len	int
-	O
1	int
)	O
)	O
==	O
' '	O
)	O
)	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
--	O
len	int
)	O
=	O
'\0'	O
;	O
if	O
(	O
hls1_set	int
)	O
{	O
len	int
+=	O
ehls1s	struct(*(char),int)
.	O
len	int
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
hls2_set	int
)	O
{	O
len	int
+=	O
ehls2s	struct(*(char),int)
.	O
len	int
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
ehls2s	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
}	O
}	O
break	O
;	O
case	O
HLS1E_CHAR	char
:	O
if	O
(	O
highlight_flag	int
)	O
{	O
if	O
(	O
is_marking_char	int
&&	O
(	O
*	O
(	O
format_txt	*(char)
+	O
1	int
)	O
!=	O
' '	O
)	O
&&	O
(	O
*	O
(	O
format_txt	*(char)
+	O
1	int
)	O
!=	O
PSEUDO_BLANK	char
)	O
&&	O
!	O
hls1_set	int
&&	O
!	O
hls2_set	int
)	O
{	O
len	int
++	O
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
NO_HLS	*(char)
)	O
;	O
}	O
if	O
(	O
hls1_set	int
)	O
{	O
len	int
+=	O
ehls1e	struct(*(char),int)
.	O
len	int
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
if	O
(	O
is_marking_char	int
)	O
{	O
skip_space	int
++	O
;	O
hlsxe_before_month	int
=	O
is_obsolete_space	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
if	O
(	O
hls2_set	int
)	O
{	O
len	int
+=	O
ehls2e	struct(*(char),int)
.	O
len	int
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
ehls2e	struct(*(char),int)
.	O
seq	*(char)
)	O
;	O
if	O
(	O
is_marking_char	int
)	O
{	O
skip_space	int
++	O
;	O
hlsxe_before_month	int
=	O
is_obsolete_space	int
=	O
TRUE	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
DAYNR_CHAR	char
:	O
if	O
(	O
hlsxe_before_month	int
)	O
{	O
hlsxe_before_month	int
=	O
FALSE	O
;	O
if	O
(	O
skip_space	int
)	O
skip_space	int
--	O
;	O
}	O
if	O
(	O
is_special_date	int
)	O
i	int
=	O
doy	int
;	O
else	O
i	int
=	O
day	int
;	O
if	O
(	O
is_suffix	*(int)
)	O
k	int
=	O
len_suffix_max	int
;	O
else	O
k	int
=	O
0	int
;	O
if	O
(	O
fwidth	*(int)
==	O
SPECIAL_VALUE	O
)	O
{	O
if	O
(	O
is_special_date	int
)	O
fwidth	*(int)
=	O
3	int
;	O
else	O
fwidth	*(int)
=	O
2	int
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
fwidth	*(int)
+	O
k	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
}	O
else	O
if	O
(	O
is_special_date	int
)	O
{	O
fwidth	*(int)
++	O
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
fwidth	*(int)
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
}	O
j	int
=	O
use_format	(*(*(char)),int,*(char),long,int,int,int,int,int,int,int,int,int,int)->(int)
(	O
result_txt	*(*(char))
,	O
len	int
,	O
""	*(char)
,	O
i	int
,	O
TRUE	O
,	O
is_cformat	*(int)
,	O
is_lformat	*(int)
,	O
is_sign	*(int)
,	O
is_lzero	*(int)
,	O
is_suffix	*(int)
,	O
is_fformat	*(int)
,	O
fstyle	*(int)
,	O
fwidth	*(int)
,	O
0	int
)	O
;	O
len	int
+=	O
j	int
;	O
if	O
(	O
is_suffix	*(int)
)	O
{	O
k	int
+=	O
fwidth	*(int)
;	O
if	O
(	O
j	int
!=	O
k	int
)	O
{	O
if	O
(	O
j	int
<	O
k	int
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
k	int
-	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
j	int
;	O
i	int
++	O
)	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
-	O
i	int
+	O
k	int
-	O
j	int
)	O
=	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
-	O
i	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
k	int
-	O
j	int
;	O
i	int
++	O
)	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
-	O
j	int
+	O
i	int
)	O
=	O
' '	O
;	O
len	int
+=	O
(	O
k	int
-	O
j	int
)	O
;	O
}	O
else	O
if	O
(	O
is_fformat	*(int)
)	O
len	int
-=	O
(	O
j	int
-	O
k	int
)	O
;	O
}	O
}	O
if	O
(	O
doy	int
)	O
{	O
if	O
(	O
!	O
d	int
)	O
{	O
ptr_char	*(char)
=	O
_	O
(	O
" day"	*(char)
)	O
;	O
len	int
+=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
ptr_char	*(char)
)	O
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
ptr_char	*(char)
)	O
;	O
}	O
else	O
{	O
fwidth	*(int)
++	O
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
2	int
+	O
fwidth	*(int)
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
"("	*(char)
)	O
;	O
len	int
+=	O
use_format	(*(*(char)),int,*(char),long,int,int,int,int,int,int,int,int,int,int)->(int)
(	O
result_txt	*(*(char))
,	O
len	int
+	O
1	int
,	O
""	*(char)
,	O
doy	int
,	O
TRUE	O
,	O
is_cformat	*(int)
,	O
is_lformat	*(int)
,	O
is_sign	*(int)
,	O
is_lzero	*(int)
,	O
FALSE	O
,	O
is_fformat	*(int)
,	O
fstyle	*(int)
,	O
fwidth	*(int)
,	O
0	int
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
")"	*(char)
)	O
;	O
len	int
+=	O
2	int
;	O
}	O
}	O
break	O
;	O
case	O
WDNAME_CHAR	char
:	O
if	O
(	O
hlsxe_before_month	int
)	O
{	O
hlsxe_before_month	int
=	O
FALSE	O
;	O
if	O
(	O
skip_space	int
)	O
skip_space	int
--	O
;	O
}	O
if	O
(	O
fixed_length_names	int
&&	O
(	O
fwidth	*(int)
==	O
SPECIAL_VALUE	O
)	O
)	O
{	O
fwidth	*(int)
=	O
len_dayname_max	int
;	O
is_lformat	*(int)
=	O
TRUE	O
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
fwidth	*(int)
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
}	O
len	int
+=	O
use_format	(*(*(char)),int,*(char),long,int,int,int,int,int,int,int,int,int,int)->(int)
(	O
result_txt	*(*(char))
,	O
len	int
,	O
day_name	(int)->(*(char))
(	O
weekday_of_date	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
)	O
,	O
0	int
,	O
FALSE	O
,	O
is_cformat	*(int)
,	O
is_lformat	*(int)
,	O
is_sign	*(int)
,	O
is_lzero	*(int)
,	O
is_suffix	*(int)
,	O
is_fformat	*(int)
,	O
fstyle	*(int)
,	O
fwidth	*(int)
,	O
0	int
)	O
;	O
break	O
;	O
case	O
MONTHNAME_CHAR	char
:	O
if	O
(	O
!	O
is_special_date	int
)	O
{	O
if	O
(	O
fixed_length_names	int
&&	O
(	O
fwidth	*(int)
==	O
SPECIAL_VALUE	O
)	O
)	O
{	O
fwidth	*(int)
=	O
len_monthname_max	int
;	O
is_lformat	*(int)
=	O
TRUE	O
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
fwidth	*(int)
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
}	O
len	int
+=	O
use_format	(*(*(char)),int,*(char),long,int,int,int,int,int,int,int,int,int,int)->(int)
(	O
result_txt	*(*(char))
,	O
len	int
,	O
month_name	(int)->(*(char))
(	O
month	int
)	O
,	O
0	int
,	O
FALSE	O
,	O
is_cformat	*(int)
,	O
is_lformat	*(int)
,	O
is_sign	*(int)
,	O
is_lzero	*(int)
,	O
is_suffix	*(int)
,	O
is_fformat	*(int)
,	O
fstyle	*(int)
,	O
fwidth	*(int)
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
len	int
)	O
{	O
if	O
(	O
(	O
*	O
(	O
format_txt	*(char)
+	O
1	int
)	O
==	O
' '	O
||	O
*	O
(	O
format_txt	*(char)
+	O
1	int
)	O
==	O
PSEUDO_BLANK	char
)	O
&&	O
(	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
(	O
len	int
-	O
1	int
)	O
)	O
==	O
' '	O
)	O
)	O
skip_space	int
++	O
;	O
else	O
if	O
(	O
!	O
skip_space	int
&&	O
is_obsolete_space	int
&&	O
hlsxe_before_month	int
)	O
skip_space	int
++	O
;	O
}	O
hlsxe_before_month	int
=	O
is_obsolete_space	int
=	O
FALSE	O
;	O
}	O
break	O
;	O
case	O
MONTHNR_CHAR	char
:	O
if	O
(	O
!	O
is_special_date	int
)	O
{	O
if	O
(	O
is_suffix	*(int)
)	O
k	int
=	O
len_suffix_max	int
;	O
else	O
k	int
=	O
0	int
;	O
if	O
(	O
fwidth	*(int)
==	O
SPECIAL_VALUE	O
)	O
{	O
fwidth	*(int)
=	O
2	int
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
fwidth	*(int)
+	O
k	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
}	O
j	int
=	O
use_format	(*(*(char)),int,*(char),long,int,int,int,int,int,int,int,int,int,int)->(int)
(	O
result_txt	*(*(char))
,	O
len	int
,	O
""	*(char)
,	O
month	int
,	O
TRUE	O
,	O
is_cformat	*(int)
,	O
is_lformat	*(int)
,	O
is_sign	*(int)
,	O
is_lzero	*(int)
,	O
is_suffix	*(int)
,	O
is_fformat	*(int)
,	O
fstyle	*(int)
,	O
fwidth	*(int)
,	O
0	int
)	O
;	O
len	int
+=	O
j	int
;	O
if	O
(	O
is_suffix	*(int)
)	O
{	O
k	int
+=	O
fwidth	*(int)
;	O
if	O
(	O
j	int
!=	O
k	int
)	O
{	O
if	O
(	O
j	int
<	O
k	int
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
k	int
-	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
j	int
;	O
i	int
++	O
)	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
-	O
i	int
+	O
k	int
-	O
j	int
)	O
=	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
-	O
i	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
k	int
-	O
j	int
;	O
i	int
++	O
)	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
-	O
j	int
+	O
i	int
)	O
=	O
' '	O
;	O
len	int
+=	O
(	O
k	int
-	O
j	int
)	O
;	O
}	O
else	O
if	O
(	O
is_fformat	*(int)
)	O
len	int
-=	O
(	O
j	int
-	O
k	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
len	int
)	O
{	O
if	O
(	O
(	O
*	O
(	O
format_txt	*(char)
+	O
1	int
)	O
==	O
' '	O
||	O
*	O
(	O
format_txt	*(char)
+	O
1	int
)	O
==	O
PSEUDO_BLANK	char
)	O
&&	O
(	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
(	O
len	int
-	O
1	int
)	O
)	O
==	O
' '	O
)	O
)	O
skip_space	int
++	O
;	O
else	O
if	O
(	O
!	O
skip_space	int
&&	O
is_obsolete_space	int
&&	O
hlsxe_before_month	int
)	O
skip_space	int
++	O
;	O
}	O
hlsxe_before_month	int
=	O
is_obsolete_space	int
=	O
FALSE	O
;	O
}	O
break	O
;	O
case	O
YEARNR_CHAR	char
:	O
if	O
(	O
hlsxe_before_month	int
)	O
{	O
hlsxe_before_month	int
=	O
FALSE	O
;	O
if	O
(	O
skip_space	int
)	O
skip_space	int
--	O
;	O
}	O
n	long
=	O
len_year_max	int
;	O
if	O
(	O
transform_year	int
)	O
{	O
j	int
=	O
year	int
-	O
transform_year	int
;	O
if	O
(	O
(	O
j	int
>=	O
0	int
)	O
&&	O
(	O
transform_year	int
>	O
0	int
)	O
)	O
j	int
++	O
;	O
if	O
(	O
abs	(int)->(int)
(	O
j	int
)	O
>	O
YEAR_MAX	int
)	O
n	long
++	O
;	O
}	O
else	O
j	int
=	O
year	int
;	O
if	O
(	O
is_suffix	*(int)
)	O
k	int
=	O
len_suffix_max	int
;	O
else	O
k	int
=	O
0	int
;	O
if	O
(	O
fwidth	*(int)
==	O
SPECIAL_VALUE	O
)	O
{	O
fwidth	*(int)
=	O
n	long
;	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
fwidth	*(int)
+	O
k	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
}	O
j	int
=	O
use_format	(*(*(char)),int,*(char),long,int,int,int,int,int,int,int,int,int,int)->(int)
(	O
result_txt	*(*(char))
,	O
len	int
,	O
""	*(char)
,	O
j	int
,	O
TRUE	O
,	O
is_cformat	*(int)
,	O
is_lformat	*(int)
,	O
is_sign	*(int)
,	O
is_lzero	*(int)
,	O
is_suffix	*(int)
,	O
is_fformat	*(int)
,	O
fstyle	*(int)
,	O
fwidth	*(int)
,	O
0	int
)	O
;	O
len	int
+=	O
j	int
;	O
if	O
(	O
is_suffix	*(int)
)	O
{	O
k	int
+=	O
fwidth	*(int)
;	O
if	O
(	O
j	int
!=	O
k	int
)	O
{	O
if	O
(	O
j	int
<	O
k	int
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
k	int
-	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
j	int
;	O
i	int
++	O
)	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
-	O
i	int
+	O
k	int
-	O
j	int
)	O
=	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
-	O
i	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
k	int
-	O
j	int
;	O
i	int
++	O
)	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
-	O
j	int
+	O
i	int
)	O
=	O
' '	O
;	O
len	int
+=	O
(	O
k	int
-	O
j	int
)	O
;	O
}	O
else	O
if	O
(	O
is_fformat	*(int)
)	O
len	int
-=	O
(	O
j	int
-	O
k	int
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
abort	()->(void)
(	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
Uint	int
)	O
len	int
+	O
2	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
maxlen_max	int
<<	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
switch	O
(	O
*	O
++	O
format_txt	*(char)
)	O
{	O
case	O
PSEUDO_BLANK	char
:	O
case	O
DFORMAT_CHAR	char
:	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
++	O
)	O
=	O
*	O
format_txt	*(char)
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
)	O
=	O
'\0'	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
*	O
format_txt	*(char)
)	O
{	O
if	O
(	O
*	O
format_txt	*(char)
!=	O
QUOTE_CHAR	char
)	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
++	O
)	O
=	O
QUOTE_CHAR	char
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
++	O
)	O
=	O
*	O
format_txt	*(char)
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
len	int
)	O
=	O
'\0'	O
;	O
}	O
else	O
format_txt	*(char)
--	O
;	O
}	O
}	O
}	O
else	O
break	O
;	O
}	O
while	O
(	O
*	O
++	O
format_txt	*(char)
)	O
;	O
return	O
(	O
hls_len	int
)	O
;	O
}	O
int	O
decode_format	(*(char),int,*(int),*(int),*(int),*(int),*(int),*(int),*(int),*(int))->(int)
(	O
format_txt	*(char)
,	O
pos	int
,	O
is_cformat	*(int)
,	O
is_lformat	*(int)
,	O
is_sign	*(int)
,	O
is_lzero	*(int)
,	O
is_suffix	*(int)
,	O
is_fformat	*(int)
,	O
fstyle	*(int)
,	O
fwidth	*(int)
)	O
char	O
*	O
format_txt	*(char)
;	O
int	O
pos	int
;	O
Bool	int
*	O
is_cformat	*(int)
;	O
Bool	int
*	O
is_lformat	*(int)
;	O
Bool	int
*	O
is_sign	*(int)
;	O
Bool	int
*	O
is_lzero	*(int)
;	O
Bool	int
*	O
is_suffix	*(int)
;	O
Bool	int
*	O
is_fformat	*(int)
;	O
int	O
*	O
fstyle	*(int)
;	O
int	O
*	O
fwidth	*(int)
;	O
{	O
register	O
int	O
old_pos	int
=	O
pos	int
;	O
register	O
int	O
i	int
;	O
register	O
int	O
len	int
;	O
*	O
is_cformat	*(int)
=	O
(	O
*	O
is_lformat	*(int)
)	O
=	O
(	O
*	O
is_sign	*(int)
)	O
=	O
(	O
*	O
is_lzero	*(int)
)	O
=	O
(	O
*	O
is_suffix	*(int)
)	O
=	O
(	O
*	O
is_fformat	*(int)
)	O
=	O
FALSE	O
;	O
*	O
fstyle	*(int)
=	O
FSTYLE_NONE	O
;	O
*	O
fwidth	*(int)
=	O
SPECIAL_VALUE	O
;	O
switch	O
(	O
*	O
(	O
format_txt	*(char)
+	O
pos	int
)	O
)	O
{	O
case	O
FLEFT_CHAR	char
:	O
*	O
is_lformat	*(int)
=	O
TRUE	O
;	O
pos	int
++	O
;	O
break	O
;	O
case	O
FCENTER_CHAR	char
:	O
*	O
is_cformat	*(int)
=	O
TRUE	O
;	O
case	O
FRIGHT_CHAR	char
:	O
pos	int
++	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
old_pos	int
)	O
;	O
}	O
if	O
(	O
*	O
(	O
format_txt	*(char)
+	O
pos	int
)	O
==	O
FSIGN_CHAR	char
)	O
{	O
pos	int
++	O
;	O
*	O
is_sign	*(int)
=	O
TRUE	O
;	O
}	O
if	O
(	O
*	O
(	O
format_txt	*(char)
+	O
pos	int
)	O
==	O
FLZERO_CHAR	char
)	O
{	O
pos	int
++	O
;	O
*	O
is_lzero	*(int)
=	O
TRUE	O
;	O
}	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
(	O
format_txt	*(char)
+	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
*	O
(	O
format_txt	*(char)
+	O
pos	int
)	O
!=	O
FLZERO_CHAR	char
)	O
{	O
*	O
fwidth	*(int)
=	O
atoi	(*(char))->(int)
(	O
format_txt	*(char)
+	O
pos	int
)	O
;	O
if	O
(	O
*	O
fwidth	*(int)
>	O
FWIDTH_MAX	int
)	O
*	O
fwidth	*(int)
=	O
i	int
=	O
FWIDTH_MAX	int
;	O
else	O
i	int
=	O
*	O
fwidth	*(int)
;	O
if	O
(	O
!	O
i	int
)	O
len	int
=	O
1	int
;	O
else	O
{	O
len	int
=	O
0	int
;	O
while	O
(	O
i	int
)	O
{	O
len	int
++	O
;	O
i	int
/=	O
10	int
;	O
}	O
}	O
pos	int
+=	O
len	int
;	O
if	O
(	O
toupper	(int)->(int)
(	O
*	O
(	O
format_txt	*(char)
+	O
pos	int
)	O
)	O
==	O
toupper	(int)->(int)
(	O
FUPPER_CHAR	char
)	O
)	O
{	O
pos	int
++	O
;	O
*	O
fstyle	*(int)
=	O
FSTYLE_UPPER	int
;	O
}	O
if	O
(	O
toupper	(int)->(int)
(	O
*	O
(	O
format_txt	*(char)
+	O
pos	int
)	O
)	O
==	O
toupper	(int)->(int)
(	O
FLOWER_CHAR	char
)	O
)	O
{	O
if	O
(	O
*	O
fstyle	*(int)
==	O
FSTYLE_NONE	O
)	O
{	O
pos	int
++	O
;	O
*	O
fstyle	*(int)
=	O
FSTYLE_LOWER	int
;	O
}	O
else	O
*	O
fwidth	*(int)
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
toupper	(int)->(int)
(	O
*	O
(	O
format_txt	*(char)
+	O
pos	int
)	O
)	O
==	O
toupper	(int)->(int)
(	O
FWORD_CHAR	char
)	O
)	O
{	O
if	O
(	O
*	O
fstyle	*(int)
==	O
FSTYLE_NONE	O
)	O
{	O
pos	int
++	O
;	O
*	O
fstyle	*(int)
=	O
FSTYLE_WORD	int
;	O
}	O
else	O
*	O
fwidth	*(int)
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
*	O
(	O
format_txt	*(char)
+	O
pos	int
)	O
==	O
FSUFFIX_CHAR	char
)	O
{	O
pos	int
++	O
;	O
*	O
is_suffix	*(int)
=	O
TRUE	O
;	O
}	O
switch	O
(	O
*	O
(	O
format_txt	*(char)
+	O
pos	int
)	O
)	O
{	O
case	O
FFIX_CHAR	char
:	O
*	O
is_fformat	*(int)
=	O
TRUE	O
;	O
case	O
FVAR_CHAR	char
:	O
pos	int
++	O
;	O
break	O
;	O
default	O
:	O
*	O
fwidth	*(int)
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
*	O
fwidth	*(int)
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
*	O
fwidth	*(int)
=	O
SPECIAL_VALUE	O
;	O
if	O
(	O
*	O
fwidth	*(int)
==	O
SPECIAL_VALUE	O
)	O
{	O
*	O
is_cformat	*(int)
=	O
(	O
*	O
is_lformat	*(int)
)	O
=	O
(	O
*	O
is_sign	*(int)
)	O
=	O
(	O
*	O
is_lzero	*(int)
)	O
=	O
(	O
*	O
is_suffix	*(int)
)	O
=	O
(	O
*	O
is_fformat	*(int)
)	O
=	O
FALSE	O
;	O
*	O
fstyle	*(int)
=	O
FSTYLE_NONE	O
;	O
return	O
(	O
old_pos	int
)	O
;	O
}	O
return	O
(	O
pos	int
)	O
;	O
}	O
int	O
use_format	(*(*(char)),int,*(char),long,int,int,int,int,int,int,int,int,int,int)->(int)
(	O
result_txt	*(*(char))
,	O
pos	int
,	O
string	*(char)
,	O
value	long
,	O
is_numeric	int
,	O
is_cformat	*(int)
,	O
is_lformat	*(int)
,	O
is_sign	*(int)
,	O
is_lzero	*(int)
,	O
is_suffix	*(int)
,	O
is_fformat	*(int)
,	O
fstyle	*(int)
,	O
fwidth	*(int)
,	O
extra_len	int
)	O
char	O
*	O
*	O
result_txt	*(*(char))
;	O
const	O
int	O
pos	int
;	O
const	O
char	O
*	O
string	*(char)
;	O
const	O
long	O
value	long
;	O
const	O
Bool	int
is_numeric	int
;	O
const	O
Bool	int
is_cformat	*(int)
;	O
const	O
Bool	int
is_lformat	*(int)
;	O
const	O
Bool	int
is_sign	*(int)
;	O
const	O
Bool	int
is_lzero	*(int)
;	O
const	O
Bool	int
is_suffix	*(int)
;	O
const	O
Bool	int
is_fformat	*(int)
;	O
const	O
int	O
fstyle	*(int)
;	O
const	O
int	O
fwidth	*(int)
;	O
const	O
int	O
extra_len	int
;	O
{	O
register	O
int	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
string	*(char)
)	O
;	O
register	O
int	O
j	int
;	O
register	O
int	O
n	long
;	O
register	O
int	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
*	O
result_txt	*(*(char))
)	O
;	O
register	O
int	O
suffix_len	int
=	O
0	int
;	O
auto	O
char	O
*	O
buf	*(char)
;	O
auto	O
char	O
*	O
tmp	*(char)
;	O
auto	O
char	O
*	O
ptr_char	*(char)
;	O
auto	O
Bool	int
is_translated	int
;	O
j	int
=	O
len	int
+	O
fwidth	*(int)
;	O
if	O
(	O
!	O
is_fformat	*(int)
&&	O
(	O
i	int
>	O
fwidth	*(int)
)	O
)	O
j	int
=	O
len	int
+	O
i	int
;	O
if	O
(	O
is_suffix	*(int)
)	O
j	int
+=	O
len_suffix_max	int
;	O
if	O
(	O
(	O
Uint	int
)	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	(int,int,*(char),long)->(void)
(	O
(	O
Uint	int
)	O
j	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
if	O
(	O
is_numeric	int
)	O
{	O
auto	O
long	O
num	long
=	O
value	long
;	O
if	O
(	O
!	O
num	long
)	O
len	int
=	O
1	int
;	O
else	O
{	O
len	int
=	O
0	int
;	O
if	O
(	O
is_sign	*(int)
||	O
(	O
num	long
<	O
0L	int
)	O
)	O
len	int
++	O
;	O
while	O
(	O
num	long
)	O
{	O
len	int
++	O
;	O
num	long
/=	O
10L	int
;	O
}	O
}	O
if	O
(	O
is_lzero	*(int)
&&	O
(	O
len	int
<	O
fwidth	*(int)
)	O
)	O
len	int
=	O
fwidth	*(int)
;	O
if	O
(	O
is_suffix	*(int)
)	O
len	int
+=	O
len_suffix_max	int
;	O
buf	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
len	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"buf"	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
is_sign	*(int)
)	O
{	O
if	O
(	O
is_lzero	*(int)
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%+0*ld"	*(char)
,	O
fwidth	*(int)
,	O
value	long
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%+ld"	*(char)
,	O
value	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
is_lzero	*(int)
)	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%0*ld"	*(char)
,	O
fwidth	*(int)
,	O
value	long
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
buf	*(char)
,	O
"%ld"	*(char)
,	O
value	long
)	O
;	O
}	O
if	O
(	O
is_suffix	*(int)
)	O
{	O
tmp	*(char)
=	O
(	O
char	O
*	O
)	O
day_suffix	(int)->(*(char))
(	O
(	O
int	O
)	O
value	long
)	O
;	O
suffix_len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
tmp	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
tmp	*(char)
)	O
;	O
}	O
}	O
else	O
{	O
buf	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
i	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"buf"	*(char)
,	O
0	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
buf	*(char)
,	O
string	*(char)
)	O
;	O
}	O
j	int
=	O
len	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
buf	*(char)
)	O
;	O
switch	O
(	O
fstyle	*(int)
)	O
{	O
case	O
FSTYLE_UPPER	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
buf	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
isupper	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
&&	O
(	O
translate_string	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
ptr_char	*(char)
=	O
translate_string	*(char)
+	O
1	int
;	O
while	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
buf	*(char)
[	O
i	int
]	O
)	O
{	O
buf	*(char)
[	O
i	int
]	O
=	O
*	O
--	O
ptr_char	*(char)
;	O
break	O
;	O
}	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
FSTYLE_LOWER	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
buf	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
tolower	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
islower	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
&&	O
(	O
translate_string	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
ptr_char	*(char)
=	O
translate_string	*(char)
;	O
while	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
buf	*(char)
[	O
i	int
]	O
)	O
{	O
buf	*(char)
[	O
i	int
]	O
=	O
*	O
++	O
ptr_char	*(char)
;	O
break	O
;	O
}	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
FSTYLE_WORD	int
:	O
*	O
buf	*(char)
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
*	O
buf	*(char)
)	O
;	O
if	O
(	O
translate_string	*(char)
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
isalpha	(int)->(int)
(	O
buf	*(char)
[	O
i	int
-	O
1	int
]	O
)	O
)	O
buf	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
;	O
else	O
buf	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
tolower	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
;	O
}	O
else	O
{	O
is_translated	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
isupper	(int)->(int)
(	O
*	O
buf	*(char)
)	O
)	O
{	O
ptr_char	*(char)
=	O
translate_string	*(char)
+	O
1	int
;	O
while	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
*	O
buf	*(char)
)	O
{	O
*	O
buf	*(char)
=	O
*	O
--	O
ptr_char	*(char)
;	O
is_translated	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
(	O
ptr_char	*(char)
-	O
1	int
)	O
==	O
*	O
buf	*(char)
)	O
{	O
is_translated	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
isalpha	(int)->(int)
(	O
buf	*(char)
[	O
i	int
-	O
1	int
]	O
)	O
&&	O
!	O
is_translated	int
)	O
{	O
buf	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
toupper	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
isupper	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
)	O
{	O
ptr_char	*(char)
=	O
translate_string	*(char)
+	O
1	int
;	O
while	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
buf	*(char)
[	O
i	int
]	O
)	O
{	O
buf	*(char)
[	O
i	int
]	O
=	O
*	O
--	O
ptr_char	*(char)
;	O
is_translated	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
(	O
ptr_char	*(char)
-	O
1	int
)	O
==	O
buf	*(char)
[	O
i	int
]	O
)	O
{	O
is_translated	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
}	O
}	O
else	O
if	O
(	O
isupper	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
)	O
is_translated	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
buf	*(char)
[	O
i	int
]	O
=	O
(	O
char	O
)	O
tolower	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
islower	(int)->(int)
(	O
buf	*(char)
[	O
i	int
]	O
)	O
)	O
{	O
ptr_char	*(char)
=	O
translate_string	*(char)
;	O
while	O
(	O
*	O
ptr_char	*(char)
)	O
{	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
buf	*(char)
[	O
i	int
]	O
)	O
{	O
buf	*(char)
[	O
i	int
]	O
=	O
*	O
++	O
ptr_char	*(char)
;	O
break	O
;	O
}	O
ptr_char	*(char)
++	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
==	O
buf	*(char)
[	O
i	int
]	O
)	O
break	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
}	O
if	O
(	O
!	O
*	O
ptr_char	*(char)
)	O
is_translated	int
=	O
FALSE	O
;	O
}	O
}	O
}	O
}	O
break	O
;	O
default	O
:	O
;	O
}	O
if	O
(	O
!	O
is_numeric	int
&&	O
extra_len	int
&&	O
(	O
len	int
!=	O
extra_len	int
)	O
)	O
len	int
=	O
extra_len	int
;	O
if	O
(	O
is_cformat	*(int)
)	O
{	O
if	O
(	O
len	int
<	O
fwidth	*(int)
)	O
{	O
n	long
=	O
fwidth	*(int)
-	O
len	int
;	O
n	long
>>=	O
1	int
;	O
tmp	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
n	long
+	O
2	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"tmp"	*(char)
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	long
;	O
i	int
++	O
)	O
tmp	*(char)
[	O
i	int
]	O
=	O
' '	O
;	O
tmp	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
tmp	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
buf	*(char)
)	O
;	O
if	O
(	O
(	O
fwidth	*(int)
-	O
len	int
)	O
%	O
2	int
)	O
{	O
tmp	*(char)
[	O
i	int
]	O
=	O
' '	O
;	O
tmp	*(char)
[	O
i	int
+	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
tmp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
j	int
=	O
fwidth	*(int)
;	O
}	O
else	O
{	O
if	O
(	O
is_fformat	*(int)
)	O
{	O
if	O
(	O
is_numeric	int
)	O
{	O
if	O
(	O
is_suffix	*(int)
)	O
{	O
i	int
=	O
len	int
-	O
fwidth	*(int)
-	O
suffix_len	int
;	O
if	O
(	O
i	int
<=	O
0	int
)	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
,	O
fwidth	*(int)
+	O
suffix_len	int
)	O
;	O
else	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
+	O
len	int
-	O
fwidth	*(int)
-	O
suffix_len	int
,	O
fwidth	*(int)
+	O
suffix_len	int
)	O
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
+	O
fwidth	*(int)
+	O
suffix_len	int
)	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
+	O
len	int
-	O
fwidth	*(int)
,	O
fwidth	*(int)
)	O
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
+	O
fwidth	*(int)
)	O
=	O
'\0'	O
;	O
j	int
=	O
fwidth	*(int)
;	O
}	O
}	O
else	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
,	O
fwidth	*(int)
)	O
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
+	O
fwidth	*(int)
)	O
=	O
'\0'	O
;	O
j	int
=	O
fwidth	*(int)
;	O
}	O
}	O
else	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
buf	*(char)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
is_lformat	*(int)
)	O
{	O
if	O
(	O
is_fformat	*(int)
&&	O
(	O
len	int
>	O
fwidth	*(int)
)	O
)	O
{	O
if	O
(	O
is_numeric	int
)	O
{	O
if	O
(	O
is_suffix	*(int)
)	O
{	O
i	int
=	O
len	int
-	O
fwidth	*(int)
-	O
suffix_len	int
;	O
if	O
(	O
i	int
<=	O
0	int
)	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
,	O
fwidth	*(int)
+	O
suffix_len	int
)	O
;	O
else	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
+	O
len	int
-	O
fwidth	*(int)
-	O
suffix_len	int
,	O
fwidth	*(int)
+	O
suffix_len	int
)	O
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
+	O
fwidth	*(int)
+	O
suffix_len	int
)	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
+	O
len	int
-	O
fwidth	*(int)
,	O
fwidth	*(int)
)	O
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
+	O
fwidth	*(int)
)	O
=	O
'\0'	O
;	O
j	int
=	O
fwidth	*(int)
;	O
}	O
}	O
else	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
,	O
fwidth	*(int)
)	O
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
+	O
fwidth	*(int)
)	O
=	O
'\0'	O
;	O
j	int
=	O
fwidth	*(int)
;	O
}	O
}	O
else	O
{	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
buf	*(char)
)	O
;	O
if	O
(	O
len	int
<	O
fwidth	*(int)
)	O
{	O
n	long
=	O
fwidth	*(int)
-	O
len	int
;	O
tmp	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
n	long
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"tmp"	*(char)
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	long
;	O
i	int
++	O
)	O
tmp	*(char)
[	O
i	int
]	O
=	O
' '	O
;	O
tmp	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
tmp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
j	int
=	O
fwidth	*(int)
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
is_fformat	*(int)
&&	O
(	O
len	int
>	O
fwidth	*(int)
)	O
)	O
{	O
if	O
(	O
is_numeric	int
)	O
{	O
if	O
(	O
is_suffix	*(int)
)	O
{	O
i	int
=	O
len	int
-	O
fwidth	*(int)
-	O
suffix_len	int
;	O
if	O
(	O
i	int
<=	O
0	int
)	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
,	O
fwidth	*(int)
+	O
suffix_len	int
)	O
;	O
else	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
+	O
len	int
-	O
fwidth	*(int)
-	O
suffix_len	int
,	O
fwidth	*(int)
+	O
suffix_len	int
)	O
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
+	O
fwidth	*(int)
+	O
suffix_len	int
)	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
+	O
len	int
-	O
fwidth	*(int)
,	O
fwidth	*(int)
)	O
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
+	O
fwidth	*(int)
)	O
=	O
'\0'	O
;	O
j	int
=	O
fwidth	*(int)
;	O
}	O
}	O
else	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
,	O
buf	*(char)
,	O
fwidth	*(int)
)	O
;	O
*	O
(	O
*	O
result_txt	*(*(char))
+	O
pos	int
+	O
fwidth	*(int)
)	O
=	O
'\0'	O
;	O
j	int
=	O
fwidth	*(int)
;	O
}	O
}	O
else	O
{	O
if	O
(	O
len	int
<	O
fwidth	*(int)
)	O
{	O
n	long
=	O
fwidth	*(int)
-	O
len	int
;	O
tmp	*(char)
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
n	long
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"tmp"	*(char)
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	long
;	O
i	int
++	O
)	O
tmp	*(char)
[	O
i	int
]	O
=	O
' '	O
;	O
tmp	*(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
tmp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
j	int
=	O
fwidth	*(int)
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
*	O
result_txt	*(*(char))
,	O
buf	*(char)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
return	O
(	O
j	int
)	O
;	O
}	O
void	O
print_all_holidays	(int,int)->(void)
(	O
init_data	*(int)
,	O
detected	int
)	O
Bool	int
init_data	*(int)
;	O
const	O
Bool	int
detected	int
;	O
{	O
auto	O
const	O
Cc_struct	struct(*(char),*(char),*(()->(void)))
*	O
ptr_cc	*(struct(*(char),*(char),*(()->(void))))
;	O
register	O
int	O
easter	int
;	O
register	O
int	O
i	int
=	O
0	int
;	O
register	O
int	O
j	int
=	O
0	int
;	O
register	O
int	O
k	int
;	O
register	O
int	O
fday	int
=	O
0	int
;	O
register	O
int	O
count	int
=	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
?	O
2	int
:	O
1	int
;	O
auto	O
int	O
hd_elems	*(int)
=	O
0	int
;	O
auto	O
char	O
*	O
ptr_char	*(char)
;	O
if	O
(	O
init_data	*(int)
||	O
detected	int
)	O
{	O
if	O
(	O
init_data	*(int)
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
HD_MAX	int
;	O
i	int
++	O
)	O
hd_ldays	array(char)
[	O
i	int
]	O
=	O
hd_mdays	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
{	O
fday	int
=	O
day_of_year	(int,int,int)->(int)
(	O
DAY_MIN	int
,	O
fiscal_month	int
,	O
year	int
)	O
;	O
j	int
=	O
is_leap_year	int
;	O
i	int
=	O
year	int
;	O
}	O
do	O
{	O
count	int
--	O
;	O
easter	int
=	O
knuth_easter_formula	(int)->(int)
(	O
year	int
)	O
;	O
if	O
(	O
hdy_astronomical	int
)	O
astronomical_hdy	(*(int),int,int,*(int),int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
;	O
if	O
(	O
hdy_bahai	int
)	O
bahai_hdy	(*(int),int,int,*(int),int,int,*(char))->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
NULL	O
)	O
;	O
if	O
(	O
hdy_celtic	int
)	O
celtic_hdy	(*(int),int,int,*(int),int,int,*(char))->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
NULL	O
)	O
;	O
if	O
(	O
hdy_chinese_flexible	int
)	O
chinese_hdy	(*(int),int,int,*(int),int,int,*(char),int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
NULL	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
hdy_chinese	int
)	O
chinese_hdy	(*(int),int,int,*(int),int,int,*(char),int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
NULL	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
hdy_christian	int
)	O
christian_hdy	(*(int),int,int,int,*(int),int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
easter	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
;	O
if	O
(	O
hdy_hebrew	int
)	O
hebrew_hdy	(*(int),int,int,*(int),int,int,*(char))->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
NULL	O
)	O
;	O
if	O
(	O
hdy_islamic	int
)	O
islamic_hdy	(*(int),int,int,*(int),int,int,*(char))->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
NULL	O
)	O
;	O
if	O
(	O
hdy_japanese_flexible	int
)	O
japanese_hdy	(*(int),int,int,*(int),int,int,*(char),int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
NULL	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
hdy_japanese	int
)	O
japanese_hdy	(*(int),int,int,*(int),int,int,*(char),int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
NULL	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
hdy_multicultural_new_year	int
)	O
multicultural_new_year_hdy	(*(int),int,int,*(int),int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
;	O
if	O
(	O
hdy_orthodox_new	int
)	O
orthodox_hdy	(*(int),int,int,int,*(int),int,int,*(char),int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
easter	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
NULL	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
hdy_orthodox_old	int
)	O
orthodox_hdy	(*(int),int,int,int,*(int),int,int,*(char),int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
easter	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
NULL	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
hdy_persian	int
)	O
persian_hdy	(*(int),int,int,*(int),int,int,*(char))->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
NULL	O
)	O
;	O
if	O
(	O
hdy_zodiacal_marker	int
)	O
zodiacal_marker_hdy	(*(int),int,int,*(int),int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
;	O
if	O
(	O
mth_bahai	int
)	O
bahai_mth	(*(int),int,int,*(int),int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
;	O
if	O
(	O
mth_chinese_flexible	int
)	O
chinese_mth	(*(int),int,int,*(int),int,int,int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
TRUE	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
mth_chinese	int
)	O
chinese_mth	(*(int),int,int,*(int),int,int,int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
FALSE	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
mth_coptic	int
)	O
coptic_mth	(*(int),int,int,*(int),int,int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
TRUE	O
)	O
;	O
if	O
(	O
mth_ethiopic	int
)	O
coptic_mth	(*(int),int,int,*(int),int,int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
mth_french_revolutionary	int
)	O
french_revolutionary_mth	(*(int),int,int,*(int),int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
;	O
if	O
(	O
mth_hebrew	int
)	O
hebrew_mth	(*(int),int,int,*(int),int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
;	O
if	O
(	O
mth_indian_civil	int
)	O
indian_civil_mth	(*(int),int,int,*(int),int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
;	O
if	O
(	O
mth_islamic	int
)	O
islamic_mth	(*(int),int,int,*(int),int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
;	O
if	O
(	O
mth_japanese_flexible	int
)	O
chinese_mth	(*(int),int,int,*(int),int,int,int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
TRUE	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
mth_japanese	int
)	O
chinese_mth	(*(int),int,int,*(int),int,int,int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
FALSE	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
mth_old_armenic	int
)	O
old_egyptic_mth	(*(int),int,int,*(int),int,int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
mth_old_egyptic	int
)	O
old_egyptic_mth	(*(int),int,int,*(int),int,int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
,	O
TRUE	O
)	O
;	O
if	O
(	O
mth_persian	int
)	O
persian_mth	(*(int),int,int,*(int),int,int)->(void)
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
;	O
if	O
(	O
cc	*(char)
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	*(char)
=	O
cc	*(char)
;	O
do	O
{	O
k	int
=	O
0	int
;	O
while	O
(	O
*	O
ptr_char	*(char)
&&	O
(	O
*	O
ptr_char	*(char)
!=	O
*	O
CONNECT_SEP	*(char)
)	O
)	O
s1	*(char)
[	O
k	int
++	O
]	O
=	O
*	O
ptr_char	*(char)
++	O
;	O
s1	*(char)
[	O
k	int
]	O
=	O
'\0'	O
;	O
ptr_cc	*(struct(*(char),*(char),*(()->(void))))
=	O
binsearch_cc_id	(*(char))->(*(struct(*(char),*(char),*(()->(void)))))
(	O
s1	*(char)
)	O
;	O
if	O
(	O
ptr_cc	*(struct(*(char),*(char),*(()->(void))))
==	O
(	O
Cc_struct	struct(*(char),*(char),*(()->(void)))
*	O
)	O
NULL	O
)	O
abort	()->(void)
(	O
)	O
;	O
else	O
(	O
*	O
ptr_cc	*(struct(*(char),*(char),*(()->(void))))
->	O
Cc_hdy_handler	*(()->(void))
)	O
(	O
&	O
init_data	*(int)
,	O
detected	int
,	O
easter	int
,	O
year	int
,	O
&	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
;	O
if	O
(	O
*	O
ptr_char	*(char)
)	O
ptr_char	*(char)
++	O
;	O
}	O
while	O
(	O
*	O
ptr_char	*(char)
)	O
;	O
}	O
if	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
{	O
year	int
++	O
;	O
is_leap_year	int
=	O
(	O
days_of_february	(int)->(int)
(	O
year	int
)	O
==	O
29	int
)	O
;	O
}	O
}	O
while	O
(	O
count	int
)	O
;	O
if	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
{	O
is_leap_year	int
=	O
j	int
;	O
year	int
=	O
i	int
;	O
}	O
}	O
if	O
(	O
hd_elems	*(int)
&&	O
holiday_flag	int
)	O
{	O
if	O
(	O
hd_elems	*(int)
>	O
1	int
)	O
{	O
if	O
(	O
!	O
is_presorted	(*(*(char)),int)->(int)
(	O
hd_table	array(*(char))
,	O
hd_elems	*(int)
)	O
)	O
{	O
if	O
(	O
hd_sort_des_flag	int
)	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
(	O
VOID_PTR	O
)	O
hd_table	array(*(char))
,	O
hd_elems	*(int)
,	O
sizeof	O
*	O
hd_table	array(*(char))
,	O
(	O
Cmp_func	*((*(void),*(void))->(int))
)	O
des_sort	(*(*(char)),*(*(char)))->(int)
)	O
;	O
else	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
(	O
VOID_PTR	O
)	O
hd_table	array(*(char))
,	O
hd_elems	*(int)
,	O
sizeof	O
*	O
hd_table	array(*(char))
,	O
(	O
Cmp_func	*((*(void),*(void))->(int))
)	O
asc_sort	(*(*(char)),*(*(char)))->(int)
)	O
;	O
}	O
else	O
if	O
(	O
hd_sort_des_flag	int
)	O
reverse_order	(*(*(char)),int)->(void)
(	O
hd_table	array(*(char))
,	O
hd_elems	*(int)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
detected	int
)	O
{	O
register	O
int	O
n	long
;	O
register	O
int	O
lym	int
;	O
register	O
int	O
m2	int
=	O
fiscal_month	int
+	O
1	int
;	O
register	O
int	O
m3	int
=	O
fiscal_month	int
+	O
2	int
;	O
register	O
int	O
tmp_month	int
=	O
month	int
;	O
auto	O
Bool	int
hd_title_shown	int
=	O
FALSE	O
;	O
auto	O
Bool	int
tmp_ify	int
=	O
is_fiscal_year	int
;	O
if	O
(	O
hd_title_flag	int
&&	O
!	O
is_1month_mode	int
&&	O
!	O
is_2month_mode	int
&&	O
(	O
(	O
!	O
is_3month_mode	int
&&	O
!	O
is_3month_mode2	int
&&	O
(	O
(	O
!	O
is_fiscal_year	int
&&	O
!	O
month	int
)	O
||	O
(	O
is_fiscal_year	int
&&	O
(	O
fiscal_month	int
==	O
MONTH_MIN	int
)	O
)	O
)	O
)	O
||	O
is_3month_mode2	int
||	O
(	O
is_3month_mode	int
&&	O
(	O
fiscal_month	int
<	O
MONTH_MAX	int
-	O
1	int
)	O
)	O
)	O
)	O
{	O
*	O
s1	*(char)
=	O
'\0'	O
;	O
if	O
(	O
!	O
hd_suppr_list_sep_flag	int
)	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s1	*(char)
)	O
;	O
if	O
(	O
hd_title_flag	int
)	O
{	O
lym	int
=	O
len_year_max	int
;	O
if	O
(	O
transform_year	int
)	O
{	O
n	long
=	O
year	int
-	O
transform_year	int
;	O
if	O
(	O
(	O
n	long
>=	O
0	int
)	O
&&	O
(	O
transform_year	int
>	O
0	int
)	O
)	O
n	long
++	O
;	O
if	O
(	O
abs	(int)->(int)
(	O
n	long
)	O
>	O
YEAR_MAX	int
)	O
lym	int
++	O
;	O
}	O
else	O
n	long
=	O
year	int
;	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
_	O
(	O
"Eternal holiday list"	*(char)
)	O
)	O
;	O
if	O
(	O
use_year_zeroleaded	int
)	O
{	O
if	O
(	O
is_leap_year	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s:%*sThe year %0*d is A leap year"	*(char)
)	O
,	O
_	O
(	O
"Eternal holiday list"	*(char)
)	O
,	O
LEN_HD_NAME	int
-	O
i	int
+	O
2	int
,	O
""	*(char)
,	O
lym	int
,	O
n	long
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s:%*sThe year %0*d is NO leap year"	*(char)
)	O
,	O
_	O
(	O
"Eternal holiday list"	*(char)
)	O
,	O
LEN_HD_NAME	int
-	O
i	int
+	O
2	int
,	O
""	*(char)
,	O
lym	int
,	O
n	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
is_leap_year	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s:%*sThe year %d is A leap year"	*(char)
)	O
,	O
_	O
(	O
"Eternal holiday list"	*(char)
)	O
,	O
LEN_HD_NAME	int
-	O
i	int
+	O
2	int
,	O
""	*(char)
,	O
n	long
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s:%*sThe year %d is NO leap year"	*(char)
)	O
,	O
_	O
(	O
"Eternal holiday list"	*(char)
)	O
,	O
LEN_HD_NAME	int
-	O
i	int
+	O
2	int
,	O
""	*(char)
,	O
n	long
)	O
;	O
}	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s1	*(char)
)	O
;	O
if	O
(	O
hd_table	array(*(char))
[	O
0	int
]	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s1	*(char)
)	O
;	O
}	O
hd_title_shown	int
=	O
TRUE	O
;	O
}	O
if	O
(	O
is_3month_mode	int
||	O
is_1month_mode	int
||	O
is_2month_mode	int
||	O
is_3month_mode2	int
)	O
{	O
if	O
(	O
fiscal_month	int
>=	O
MONTH_MAX	int
-	O
1	int
)	O
{	O
m3	int
=	O
MONTH_MIN	int
;	O
if	O
(	O
fiscal_month	int
==	O
MONTH_MAX	int
)	O
{	O
m2	int
=	O
MONTH_MIN	int
;	O
m3	int
++	O
;	O
}	O
}	O
is_fiscal_year	int
=	O
FALSE	O
;	O
month	int
=	O
fiscal_month	int
;	O
}	O
i	int
=	O
j	int
=	O
0	int
;	O
while	O
(	O
(	O
hd_table	array(*(char))
[	O
i	int
]	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
i	int
<	O
HD_ELEMS_MAX	int
)	O
)	O
{	O
if	O
(	O
is_3month_mode	int
||	O
is_1month_mode	int
||	O
is_2month_mode	int
||	O
is_3month_mode2	int
||	O
(	O
month	int
&&	O
!	O
is_fiscal_year	int
)	O
)	O
{	O
s1	*(char)
[	O
0	int
]	O
=	O
hd_table	array(*(char))
[	O
i	int
]	O
[	O
len_year_max	int
]	O
;	O
s1	*(char)
[	O
1	int
]	O
=	O
hd_table	array(*(char))
[	O
i	int
]	O
[	O
len_year_max	int
+	O
1	int
]	O
;	O
s1	*(char)
[	O
2	int
]	O
=	O
'\0'	O
;	O
j	int
=	O
my_atoi	(*(char))->(int)
(	O
s1	*(char)
)	O
;	O
}	O
if	O
(	O
is_fiscal_year	int
||	O
!	O
month	int
||	O
month	int
==	O
j	int
||	O
(	O
is_1month_mode	int
&&	O
(	O
month	int
==	O
j	int
)	O
)	O
||	O
(	O
is_2month_mode	int
&&	O
(	O
j	int
==	O
m2	int
)	O
)	O
||	O
(	O
(	O
is_3month_mode	int
||	O
is_3month_mode2	int
)	O
&&	O
(	O
j	int
==	O
m2	int
||	O
j	int
==	O
m3	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
hd_legal_days_only	int
||	O
(	O
hd_legal_days_only	int
&&	O
(	O
*	O
(	O
*	O
(	O
hd_table	array(*(char))
+	O
i	int
)	O
+	O
LEN_HD_NAME	int
+	O
len_year_max	int
+	O
4	int
+	O
2	int
)	O
!=	O
*	O
DIS_HLS_PREF	*(char)
)	O
&&	O
(	O
*	O
(	O
*	O
(	O
hd_table	array(*(char))
+	O
i	int
)	O
+	O
LEN_HD_NAME	int
+	O
len_year_max	int
+	O
4	int
+	O
2	int
)	O
!=	O
*	O
DIS_HLS_PREF2	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
!	O
hd_title_shown	int
)	O
{	O
*	O
s1	*(char)
=	O
'\0'	O
;	O
if	O
(	O
!	O
hd_suppr_list_sep_flag	int
)	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s1	*(char)
)	O
;	O
if	O
(	O
hd_title_flag	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
"%s:"	*(char)
,	O
_	O
(	O
"Eternal holiday list"	*(char)
)	O
)	O
;	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s1	*(char)
)	O
;	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s1	*(char)
)	O
;	O
}	O
hd_title_shown	int
=	O
TRUE	O
;	O
}	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
"%s"	*(char)
,	O
*	O
(	O
hd_table	array(*(char))
+	O
i	int
)	O
+	O
len_year_max	int
+	O
4	int
+	O
1	int
)	O
;	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s1	*(char)
)	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
hd_table	array(*(char))
[	O
i	int
]	O
)	O
;	O
hd_table	array(*(char))
[	O
i	int
++	O
]	O
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
is_3month_mode	int
||	O
is_1month_mode	int
||	O
is_2month_mode	int
||	O
is_3month_mode2	int
)	O
{	O
month	int
=	O
tmp_month	int
;	O
is_fiscal_year	int
=	O
tmp_ify	int
;	O
}	O
}	O
}	O
void	O
holiday	(int,int,*(char),*(char),*(char),int,int,int,*(int),int,int)->(void)
(	O
init_data	*(int)
,	O
detected	int
,	O
holiday_name	*(char)
,	O
country_code	*(char)
,	O
holiday_prefix	*(char)
,	O
day	int
,	O
month	int
,	O
year	int
,	O
hd_elems	*(int)
,	O
fday	int
,	O
count	int
)	O
Bool	int
init_data	*(int)
;	O
const	O
Bool	int
detected	int
;	O
const	O
char	O
*	O
holiday_name	*(char)
;	O
const	O
char	O
*	O
country_code	*(char)
;	O
const	O
char	O
*	O
holiday_prefix	*(char)
;	O
int	O
day	int
;	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
int	O
*	O
hd_elems	*(int)
;	O
const	O
int	O
fday	int
;	O
const	O
int	O
count	int
;	O
{	O
register	O
int	O
i	int
=	O
day	int
;	O
register	O
int	O
hd	int
;	O
register	O
int	O
hd2	int
;	O
if	O
(	O
!	O
month	int
)	O
(	O
void	O
)	O
doy2date	(int,int,*(int),*(int))->(int)
(	O
i	int
,	O
is_leap_year	int
,	O
&	O
day	int
,	O
&	O
month	int
)	O
;	O
if	O
(	O
month	int
==	O
2	int
)	O
i	int
=	O
is_leap_year	int
;	O
else	O
i	int
=	O
0	int
;	O
hd	int
=	O
hd2	int
=	O
day_of_year	(int,int,int)->(int)
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
if	O
(	O
(	O
year	int
>=	O
EASTER_MIN	int
)	O
&&	O
(	O
year	int
<=	O
EASTER_MAX	O
)	O
&&	O
(	O
day	int
>=	O
DAY_MIN	int
)	O
&&	O
(	O
day	int
<=	O
dvec	array(int)
[	O
month	int
-	O
1	int
]	O
+	O
i	int
)	O
&&	O
(	O
!	O
fday	int
||	O
(	O
count	int
&&	O
(	O
hd	int
>=	O
fday	int
)	O
)	O
||	O
(	O
!	O
count	int
&&	O
(	O
hd	int
<	O
fday	int
-	O
(	O
days_of_february	(int)->(int)
(	O
year	int
-	O
1	int
)	O
==	O
29	int
)	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
holiday_flag	int
||	O
rc_enable_hda_flag	int
||	O
rc_enable_hdl_flag	int
)	O
{	O
register	O
int	O
d	int
=	O
day	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
" (%s)"	*(char)
,	O
country_code	*(char)
)	O
;	O
i	int
=	O
(	O
int	O
)	O
strlen	(*(char))->(long)
(	O
s1	*(char)
)	O
;	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
s2	*(char)
,	O
holiday_name	*(char)
,	O
LEN_HD_NAME	int
-	O
i	int
)	O
;	O
s2	*(char)
[	O
LEN_HD_NAME	int
-	O
i	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s2	*(char)
,	O
s1	*(char)
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
"%0*d%02d%02d %-*s  %1s "	*(char)
,	O
len_year_max	int
,	O
year	int
,	O
month	int
,	O
day	int
,	O
LEN_HD_NAME	int
-	O
1	int
,	O
s2	*(char)
,	O
holiday_prefix	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
s2	*(char)
,	O
s1	*(char)
)	O
;	O
i	int
=	O
hd	int
-	O
(	O
(	O
cal_special_flag	int
)	O
?	O
act_day	int
:	O
day_of_year	(int,int,int)->(int)
(	O
act_day	int
,	O
act_month	int
,	O
act_year	int
)	O
)	O
;	O
if	O
(	O
!	O
hd_both_dates_flag	int
)	O
{	O
if	O
(	O
!	O
hd_special_flag	int
)	O
hd2	int
=	O
0	int
;	O
else	O
d	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
i	int
&&	O
(	O
year	int
==	O
act_year	int
)	O
)	O
(	O
void	O
)	O
decode_date_format	(*(char),*(*(char)),int,int,int,int,int,int,int)->(int)
(	O
date_format	*(struct(*(char),*(char),*(char)))
->	O
df_format	*(char)
,	O
&	O
s2	*(char)
,	O
d	int
,	O
month	int
,	O
year	int
,	O
hd2	int
,	O
TRUE	O
,	O
FALSE	O
,	O
TRUE	O
)	O
;	O
else	O
if	O
(	O
(	O
*	O
holiday_prefix	*(char)
!=	O
*	O
DIS_HLS_PREF	*(char)
)	O
&&	O
(	O
*	O
holiday_prefix	*(char)
!=	O
*	O
DIS_HLS_PREF2	*(char)
)	O
)	O
(	O
void	O
)	O
decode_date_format	(*(char),*(*(char)),int,int,int,int,int,int,int)->(int)
(	O
date_format	*(struct(*(char),*(char),*(char)))
->	O
df_format	*(char)
,	O
&	O
s2	*(char)
,	O
d	int
,	O
month	int
,	O
year	int
,	O
hd2	int
,	O
FALSE	O
,	O
TRUE	O
,	O
TRUE	O
)	O
;	O
else	O
(	O
void	O
)	O
decode_date_format	(*(char),*(*(char)),int,int,int,int,int,int,int)->(int)
(	O
date_format	*(struct(*(char),*(char),*(char)))
->	O
df_format	*(char)
,	O
&	O
s2	*(char)
,	O
d	int
,	O
month	int
,	O
year	int
,	O
hd2	int
,	O
FALSE	O
,	O
FALSE	O
,	O
TRUE	O
)	O
;	O
if	O
(	O
(	O
fday	int
&&	O
(	O
(	O
(	O
year	int
==	O
act_year	int
-	O
1	int
)	O
&&	O
(	O
month	int
>=	O
fiscal_month	int
)	O
)	O
||	O
(	O
(	O
year	int
==	O
act_year	int
+	O
1	int
)	O
&&	O
(	O
month	int
<	O
fiscal_month	int
)	O
)	O
)	O
)	O
||	O
year	int
==	O
act_year	int
)	O
{	O
if	O
(	O
fday	int
&&	O
(	O
year	int
!=	O
act_year	int
)	O
)	O
{	O
if	O
(	O
year	int
==	O
act_year	int
-	O
1	int
)	O
i	int
=	O
hd	int
-	O
(	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
(	O
(	O
cal_special_flag	int
)	O
?	O
act_day	int
:	O
day_of_year	(int,int,int)->(int)
(	O
act_day	int
,	O
act_month	int
,	O
act_year	int
)	O
)	O
)	O
;	O
else	O
i	int
=	O
hd	int
+	O
(	O
DAY_LAST	int
+	O
(	O
days_of_february	(int)->(int)
(	O
act_year	int
)	O
==	O
29	int
)	O
-	O
(	O
(	O
cal_special_flag	int
)	O
?	O
act_day	int
:	O
day_of_year	(int,int,int)->(int)
(	O
act_day	int
,	O
act_month	int
,	O
act_year	int
)	O
)	O
)	O
;	O
}	O
if	O
(	O
i	int
)	O
{	O
if	O
(	O
abs	(int)->(int)
(	O
i	int
)	O
==	O
1	int
)	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
" = %+4d day"	*(char)
)	O
,	O
i	int
)	O
;	O
else	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
" = %+4d days"	*(char)
)	O
,	O
i	int
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
s2	*(char)
,	O
s1	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
*	O
hd_elems	*(int)
<	O
HD_ELEMS_MAX	int
)	O
{	O
hd_table	array(*(char))
[	O
*	O
hd_elems	*(int)
]	O
=	O
(	O
char	O
*	O
)	O
my_malloc	(int,int,*(char),long,*(char),int)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
s2	*(char)
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"hd_table[hd_elems]"	*(char)
,	O
*	O
hd_elems	*(int)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
hd_table	array(*(char))
[	O
(	O
*	O
hd_elems	*(int)
)	O
++	O
]	O
,	O
s2	*(char)
)	O
;	O
}	O
}	O
if	O
(	O
(	O
warning_level	int
>=	O
0	int
)	O
&&	O
(	O
*	O
hd_elems	*(int)
>=	O
HD_ELEMS_MAX	int
)	O
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
s1	*(char)
,	O
_	O
(	O
"%s%s contains %d maximum entries now!%s"	*(char)
)	O
,	O
(	O
(	O
ehls1s	struct(*(char),int)
.	O
len	int
!=	O
1	int
)	O
?	O
ehls1s	struct(*(char),int)
.	O
seq	*(char)
:	O
""	*(char)
)	O
,	O
_	O
(	O
"Eternal holiday list"	*(char)
)	O
,	O
HD_ELEMS_MAX	int
,	O
(	O
(	O
ehls1s	struct(*(char),int)
.	O
len	int
!=	O
1	int
)	O
?	O
ehls1e	struct(*(char),int)
.	O
seq	*(char)
:	O
""	*(char)
)	O
)	O
;	O
print_text	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
s1	*(char)
)	O
;	O
}	O
if	O
(	O
init_data	*(int)
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
HD_MAX	int
;	O
i	int
++	O
)	O
hd_ldays	array(char)
[	O
i	int
]	O
=	O
hd_mdays	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
detected	int
)	O
{	O
if	O
(	O
*	O
holiday_prefix	*(char)
==	O
*	O
DIS_HLS_PREF	*(char)
||	O
*	O
holiday_prefix	*(char)
==	O
*	O
DIS_HLS_PREF2	*(char)
)	O
hd_mdays	array(char)
[	O
(	O
(	O
month	int
-	O
1	int
)	O
*	O
MONTH_LAST	int
)	O
+	O
(	O
day	int
-	O
1	int
)	O
]	O
=	O
'@'	O
;	O
else	O
hd_ldays	array(char)
[	O
(	O
(	O
month	int
-	O
1	int
)	O
*	O
MONTH_LAST	int
)	O
+	O
(	O
day	int
-	O
1	int
)	O
]	O
=	O
'@'	O
;	O
}	O
}	O
else	O
if	O
(	O
init_data	*(int)
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
HD_MAX	int
;	O
i	int
++	O
)	O
hd_ldays	array(char)
[	O
i	int
]	O
=	O
hd_mdays	array(char)
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
