OBJID	long
EDMAPROC	O
edma_apply_classpath	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
classpath	*(char)
)	O
{	O
return	O
edma_parse_classpath	(long,*(char),long,long)->(long)
(	O
IdObj	long
,	O
classpath	*(char)
,	O
strlen	(*(char))->(int)
(	O
classpath	*(char)
)	O
,	O
0	int
)	O
;	O
}	O
OBJID	long
EDMAPROC	O
edma_parse_classpath	(long,*(char),long,long)->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
eclass_path	*(char)
,	O
ESint32	long
len	long
,	O
ESint32	long
ex	long
)	O
{	O
OBJID	long
id	long
,	O
casted_id	long
;	O
OBJID	long
aux_id	long
;	O
ESint32	long
l	long
,	O
pos	long
;	O
ESint32	long
op	*(long)
;	O
EPChar	*(char)
current	*(char)
,	O
next	long
;	O
EPChar	*(char)
iclass_path	*(char)
;	O
EPChar	*(char)
dyn_class_id	*(char)
;	O
EPChar	*(char)
apoint1	*(*(char))
,	O
apoint2	*(*(char))
;	O
CLASSID	long
temp_id	long
;	O
EChar	char
ex_msg	array(char)
[	O
1024	int
]	O
;	O
if	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_parse_classpath"	*(char)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
eclass_path	*(char)
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
l	long
=	O
len	long
+	O
2	int
;	O
current	*(char)
=	O
next	long
=	O
iclass_path	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
eclass_path	*(char)
)	O
;	O
pos	long
=	O
0	int
;	O
op	*(long)
=	O
EDMA_CP_OP_ADD	int
;	O
id	long
=	O
IdObj	long
;	O
while	O
(	O
pos	long
<	O
l	long
)	O
{	O
if	O
(	O
(	O
*	O
next	long
==	O
0	int
)	O
&&	O
(	O
current	*(char)
!=	O
next	long
)	O
)	O
{	O
if	O
(	O
(	O
casted_id	long
=	O
edma_cast_obj	(long,*(char))->(long)
(	O
id	long
,	O
current	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] '%s' "	*(char)
"Anchor Point/ClassName"	*(char)
" not found in classpath"	*(char)
,	O
current	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
if	O
(	O
ex	long
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
else	O
return	O
-	O
1	int
;	O
}	O
id	long
=	O
casted_id	long
;	O
next	long
++	O
;	O
current	*(char)
=	O
next	long
;	O
pos	long
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
next	long
==	O
'>'	O
)	O
{	O
*	O
next	long
=	O
0	int
;	O
_edma_parse_classpath_items	(*(char),*(*(char)),*(*(char)),*(*(char)),*(long))->(long)
(	O
current	*(char)
,	O
&	O
dyn_class_id	*(char)
,	O
&	O
apoint1	*(*(char))
,	O
&	O
apoint2	*(*(char))
,	O
&	O
op	*(long)
)	O
;	O
if	O
(	O
(	O
casted_id	long
=	O
edma_upcast_obj	(long,*(char))->(long)
(	O
id	long
,	O
(	O
apoint1	*(*(char))
==	O
NULL	O
)	O
?	O
dyn_class_id	*(char)
:	O
apoint1	*(*(char))
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
Final	char
)	O
||	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Final	char
)	O
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] "	*(char)
"Object %ld is final. "	*(char)
"Can't add superclass %s"	*(char)
,	O
id	long
,	O
current	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
if	O
(	O
(	O
temp_id	long
=	O
edma_get_class_id	(*(char))->(long)
(	O
dyn_class_id	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Class '%s' "	*(char)
"don't exist."	*(char)
"'%s' Anchor Point/Class not found in classpath"	*(char)
,	O
dyn_class_id	*(char)
,	O
current	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
if	O
(	O
(	O
casted_id	long
=	O
edma_add_superclass	(long,long,*(char),*(char))->(long)
(	O
id	long
,	O
temp_id	long
,	O
apoint1	*(*(char))
,	O
apoint2	*(*(char))
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Can't add "	*(char)
"superclass "	*(char)
"for '%s' classpath item"	*(char)
,	O
current	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
apoint1	*(*(char))
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
temp_id	long
=	O
edma_get_class_id	(*(char))->(long)
(	O
dyn_class_id	*(char)
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
switch	O
(	O
op	*(long)
)	O
{	O
case	O
EDMA_CP_OP_ADD	int
:	O
{	O
if	O
(	O
gObj	O
[	O
casted_id	long
]	O
->	O
IdClass	long
!=	O
temp_id	long
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Can't override existing"	*(char)
"subobject %ld at '%s'. Superobject at %ld of class"	*(char)
"'%s' not '%s"	*(char)
,	O
casted_id	long
,	O
apoint1	*(*(char))
,	O
casted_id	long
,	O
gClass	O
[	O
gObj	O
[	O
casted_id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
gClass	O
[	O
temp_id	long
]	O
->	O
ClassName	array(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
}	O
case	O
EDMA_CP_OP_VERTICAL_INSERT	int
:	O
{	O
if	O
(	O
(	O
casted_id	long
=	O
edma_insert_superclass	(long,long,*(char),*(char))->(long)
(	O
id	long
,	O
temp_id	long
,	O
apoint1	*(*(char))
,	O
apoint2	*(*(char))
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Can't insert superclass"	*(char)
" %s at anchor point %s"	*(char)
,	O
dyn_class_id	*(char)
,	O
apoint1	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
break	O
;	O
}	O
case	O
EDMA_CP_OP_OVERWRITE	int
:	O
{	O
edma_remove_superclass_ap	(long,*(char))->(long)
(	O
id	long
,	O
apoint1	*(*(char))
)	O
;	O
edma_free_obj	(long)->(long)
(	O
casted_id	long
)	O
;	O
if	O
(	O
(	O
casted_id	long
=	O
edma_add_superclass	(long,long,*(char),*(char))->(long)
(	O
id	long
,	O
temp_id	long
,	O
apoint1	*(*(char))
,	O
apoint2	*(*(char))
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Can't overwrite superclass"	*(char)
" %s at anchor point %s"	*(char)
,	O
dyn_class_id	*(char)
,	O
apoint1	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
break	O
;	O
}	O
default	O
:	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Opertation %ld still"	*(char)
" not implemented. Classpath: %s"	*(char)
,	O
op	*(long)
,	O
current	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
}	O
}	O
else	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_class_path] Class '%s' "	*(char)
"in classpath '%s' doesn't exists"	*(char)
,	O
dyn_class_id	*(char)
,	O
eclass_path	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
}	O
}	O
id	long
=	O
casted_id	long
;	O
next	long
++	O
;	O
current	*(char)
=	O
next	long
;	O
pos	long
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
next	long
==	O
'<'	O
)	O
{	O
*	O
next	long
=	O
0	int
;	O
_edma_parse_classpath_items	(*(char),*(*(char)),*(*(char)),*(*(char)),*(long))->(long)
(	O
current	*(char)
,	O
&	O
dyn_class_id	*(char)
,	O
&	O
apoint1	*(*(char))
,	O
&	O
apoint2	*(*(char))
,	O
&	O
op	*(long)
)	O
;	O
if	O
(	O
(	O
casted_id	long
=	O
edma_downcast_obj	(long,*(char))->(long)
(	O
id	long
,	O
(	O
apoint1	*(*(char))
==	O
NULL	O
)	O
?	O
dyn_class_id	*(char)
:	O
apoint1	*(*(char))
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
Final	char
)	O
||	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Final	char
)	O
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Object %ld "	*(char)
"is final. "	*(char)
"Can't add subclass %s"	*(char)
,	O
id	long
,	O
current	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
if	O
(	O
(	O
temp_id	long
=	O
edma_get_class_id	(*(char))->(long)
(	O
dyn_class_id	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Class '%s' "	*(char)
"don't exist."	*(char)
"'%s' Anchor Point/Class not found in classpath"	*(char)
,	O
dyn_class_id	*(char)
,	O
current	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
if	O
(	O
(	O
casted_id	long
=	O
edma_add_subclass	(long,long,*(char),*(char))->(long)
(	O
id	long
,	O
temp_id	long
,	O
apoint1	*(*(char))
,	O
apoint2	*(*(char))
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_class_path] Can't add "	*(char)
"subclass for '%s' "	*(char)
"classpath item"	*(char)
,	O
current	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
apoint1	*(*(char))
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
temp_id	long
=	O
edma_get_class_id	(*(char))->(long)
(	O
dyn_class_id	*(char)
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
switch	O
(	O
op	*(long)
)	O
{	O
case	O
EDMA_CP_OP_ADD	int
:	O
{	O
if	O
(	O
gObj	O
[	O
casted_id	long
]	O
->	O
IdClass	long
!=	O
temp_id	long
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Can't override existing"	*(char)
"subobject %ld at '%s'. Superobject at %ld of class"	*(char)
"'%s' not '%s"	*(char)
,	O
casted_id	long
,	O
apoint1	*(*(char))
,	O
casted_id	long
,	O
gClass	O
[	O
gObj	O
[	O
casted_id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
,	O
gClass	O
[	O
temp_id	long
]	O
->	O
ClassName	array(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
}	O
case	O
EDMA_CP_OP_VERTICAL_INSERT	int
:	O
{	O
edma_printf	(*(char))->(long)
(	O
"[%s] Inserting up: %s @ %s | %s"	*(char)
,	O
__FUNCTION__	O
,	O
gClass	O
[	O
temp_id	long
]	O
->	O
ClassName	array(char)
,	O
apoint1	*(*(char))
,	O
apoint2	*(*(char))
)	O
;	O
if	O
(	O
(	O
casted_id	long
=	O
edma_insert_subclass	(long,long,*(char),*(char))->(long)
(	O
id	long
,	O
temp_id	long
,	O
apoint1	*(*(char))
,	O
apoint2	*(*(char))
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Can't insert superclass"	*(char)
" %s at anchor point %s"	*(char)
,	O
dyn_class_id	*(char)
,	O
apoint1	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
break	O
;	O
}	O
case	O
EDMA_CP_OP_OVERWRITE	int
:	O
{	O
edma_remove_subclass_ap	(long,*(char))->(long)
(	O
id	long
,	O
apoint1	*(*(char))
)	O
;	O
edma_free_obj	(long)->(long)
(	O
casted_id	long
)	O
;	O
aux_id	long
=	O
_edma_new_obj	(*(char),long,*(void))->(long)
(	O
dyn_class_id	*(char)
,	O
id	long
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
casted_id	long
=	O
edma_add_subobject	(long,long,*(char))->(long)
(	O
id	long
,	O
aux_id	long
,	O
apoint1	*(*(char))
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Can't overwrite superclass"	*(char)
" %s at anchor point %s"	*(char)
,	O
dyn_class_id	*(char)
,	O
apoint1	*(*(char))
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
edma_add_superobject	(long,long,*(char))->(long)
(	O
aux_id	long
,	O
id	long
,	O
apoint2	*(*(char))
)	O
;	O
gObj	O
[	O
aux_id	long
]	O
->	O
Father	long
=	O
id	long
;	O
gObj	O
[	O
aux_id	long
]	O
->	O
PseudiFather	long
=	O
id	long
;	O
casted_id	long
=	O
aux_id	long
;	O
break	O
;	O
}	O
default	O
:	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Opertation %ld still"	*(char)
" not implemented. Classpath: %s"	*(char)
,	O
op	*(long)
,	O
current	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
}	O
}	O
else	O
{	O
snprintf	(*(char),int,*(char))->(int)
(	O
ex_msg	array(char)
,	O
1024	int
,	O
"[edma_parse_classpath] Class '%s' in "	*(char)
"classpath '%s' doesn't exists"	*(char)
,	O
dyn_class_id	*(char)
,	O
eclass_path	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"%s"	*(char)
,	O
ex_msg	array(char)
)	O
;	O
}	O
}	O
}	O
id	long
=	O
casted_id	long
;	O
next	long
++	O
;	O
current	*(char)
=	O
next	long
;	O
pos	long
++	O
;	O
continue	O
;	O
}	O
pos	long
++	O
;	O
next	long
++	O
;	O
}	O
free	(*(void))->(void)
(	O
iclass_path	*(char)
)	O
;	O
return	O
id	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_parse_classpath_items	(*(char),*(*(char)),*(*(char)),*(*(char)),*(long))->(long)
(	O
EPChar	*(char)
id	long
,	O
EPChar	*(char)
*	O
classname	*(*(char))
,	O
EPChar	*(char)
*	O
apoint1	*(*(char))
,	O
EPChar	*(char)
*	O
apoint2	*(*(char))
,	O
EPSint32	*(long)
op	*(long)
)	O
{	O
EPChar	*(char)
p_ap	*(char)
,	O
p_ap_sep	*(char)
;	O
*	O
classname	*(*(char))
=	O
id	long
;	O
*	O
apoint1	*(*(char))
=	O
*	O
apoint2	*(*(char))
=	O
NULL	O
;	O
*	O
op	*(long)
=	O
EDMA_CP_OP_ADD	int
;	O
if	O
(	O
(	O
p_ap	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
id	long
,	O
'@'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
*	O
p_ap	*(char)
=	O
0	int
;	O
p_ap	*(char)
++	O
;	O
switch	O
(	O
p_ap	*(char)
[	O
0	int
]	O
)	O
{	O
case	O
'!'	O
:	O
{	O
*	O
op	*(long)
=	O
EDMA_CP_OP_OVERWRITE	int
;	O
*	O
p_ap	*(char)
=	O
0	int
;	O
p_ap	*(char)
++	O
;	O
break	O
;	O
}	O
case	O
'*'	O
:	O
{	O
*	O
op	*(long)
=	O
EDMA_CP_OP_VERTICAL_INSERT	int
;	O
*	O
p_ap	*(char)
=	O
0	int
;	O
p_ap	*(char)
++	O
;	O
break	O
;	O
}	O
case	O
'-'	O
:	O
{	O
*	O
op	*(long)
=	O
EDMA_CP_OP_HORIZONTAL_INSERT	int
;	O
*	O
p_ap	*(char)
=	O
0	int
;	O
p_ap	*(char)
++	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
p_ap_sep	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p_ap	*(char)
,	O
'|'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
*	O
apoint2	*(*(char))
=	O
strdup	(*(char))->(*(char))
(	O
p_ap_sep	*(char)
+	O
1	int
)	O
;	O
*	O
p_ap_sep	*(char)
=	O
0	int
;	O
}	O
*	O
apoint1	*(*(char))
=	O
strdup	(*(char))->(*(char))
(	O
p_ap	*(char)
)	O
;	O
}	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_query_subclass_ap	(long,*(char),*(long),*(long))->(long)
(	O
OBJID	long
id	long
,	O
EPChar	*(char)
anchor_point	*(char)
,	O
OBJID	long
*	O
obj	*(long)
,	O
CLASSID	long
*	O
cid	long
)	O
{	O
if	O
(	O
!	O
edma_check_obj_id	(long,*(char))->(long)
(	O
id	long
,	O
"edma_query_subclass_ap"	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
anchor_point	*(char)
==	O
NULL	O
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_query_subclass_ap] No anchot point provided"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
_edma_query_subclass_ap	(long,*(char),*(long),*(long))->(long)
(	O
id	long
,	O
anchor_point	*(char)
,	O
obj	*(long)
,	O
cid	long
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_query_subclass_ap	(long,*(char),*(long),*(long))->(long)
(	O
OBJID	long
id	long
,	O
EPChar	*(char)
anchor_point	*(char)
,	O
OBJID	long
*	O
obj	*(long)
,	O
CLASSID	long
*	O
cid	long
)	O
{	O
ESint32	long
i	long
,	O
n	long
;	O
n	long
=	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
*	O
obj	*(long)
=	O
-	O
1	int
;	O
*	O
cid	long
=	O
-	O
1	int
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[_edma_query_subclass_ap] Object %d hasn't subobjects"	*(char)
,	O
id	long
)	O
;	O
}	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_downlink_by_name	(long,*(char))->(long)
(	O
id	long
,	O
anchor_point	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
*	O
obj	*(long)
=	O
-	O
1	int
;	O
*	O
cid	long
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
obj	*(long)
=	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
;	O
*	O
cid	long
=	O
gObj	O
[	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
]	O
->	O
IdClass	long
;	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_query_superclass_ap	(long,*(char),*(long),*(long))->(long)
(	O
OBJID	long
id	long
,	O
EPChar	*(char)
anchor_point	*(char)
,	O
OBJID	long
*	O
obj	*(long)
,	O
CLASSID	long
*	O
cid	long
)	O
{	O
if	O
(	O
!	O
edma_check_obj_id	(long,*(char))->(long)
(	O
id	long
,	O
"edma_query_superclass_ap"	*(char)
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
anchor_point	*(char)
==	O
NULL	O
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_query_superclass_ap] No anchot point provided"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
_edma_query_superclass_ap	(long,*(char),*(long),*(long))->(long)
(	O
id	long
,	O
anchor_point	*(char)
,	O
obj	*(long)
,	O
cid	long
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_query_superclass_ap	(long,*(char),*(long),*(long))->(long)
(	O
OBJID	long
id	long
,	O
EPChar	*(char)
anchor_point	*(char)
,	O
OBJID	long
*	O
obj	*(long)
,	O
CLASSID	long
*	O
cid	long
)	O
{	O
ESint32	long
i	long
,	O
n	long
;	O
n	long
=	O
gObj	O
[	O
id	long
]	O
->	O
nUpTable	long
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
*	O
obj	*(long)
=	O
-	O
1	int
;	O
*	O
cid	long
=	O
-	O
1	int
;	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[_edma_query_superclass_ap] Object %d hasn't subobjects"	*(char)
,	O
id	long
)	O
;	O
}	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_uplink_by_name	(long,*(char))->(long)
(	O
id	long
,	O
anchor_point	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
*	O
obj	*(long)
=	O
-	O
1	int
;	O
*	O
cid	long
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
obj	*(long)
=	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
;	O
*	O
cid	long
=	O
gObj	O
[	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Obj	long
]	O
->	O
IdClass	long
;	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_rename_superclass_ap	(long,*(char),*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
old_name	*(char)
,	O
EPChar	*(char)
new_name	*(char)
)	O
{	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
ESint32	long
i	long
;	O
if	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_rename_superclass_ap"	*(char)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
old_name	*(char)
==	O
0	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_rename_superclass_ap] No 'OldName' provided for"	*(char)
" object %ld"	*(char)
,	O
IdObj	long
)	O
;	O
if	O
(	O
new_name	*(char)
==	O
NULL	O
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_rename_superclass_ap] No 'NewName' provided for"	*(char)
" object %ld"	*(char)
,	O
IdObj	long
)	O
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_uplink_by_name	(long,*(char))->(long)
(	O
IdObj	long
,	O
old_name	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_rename_superclass_ap] '%s' anchor point doesn't exist "	*(char)
"in object %ld"	*(char)
,	O
old_name	*(char)
,	O
IdObj	long
)	O
;	O
}	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	long
,	O
new_name	*(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_rename_subclass_ap	(long,*(char),*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
old_name	*(char)
,	O
EPChar	*(char)
new_name	*(char)
)	O
{	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
ESint32	long
i	long
;	O
if	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_rename_subclass_ap"	*(char)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
old_name	*(char)
==	O
0	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_rename_subclass_ap] No OldName provided for"	*(char)
" object %ld"	*(char)
,	O
IdObj	long
)	O
;	O
if	O
(	O
new_name	*(char)
==	O
0	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_rename_subclass_ap] No NewName provided for"	*(char)
" object %ld"	*(char)
,	O
IdObj	long
)	O
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_downlink_by_name	(long,*(char))->(long)
(	O
IdObj	long
,	O
old_name	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_rename_subclass_ap] %s anchor point "	*(char)
"doesn't exist in object %ld"	*(char)
,	O
old_name	*(char)
,	O
IdObj	long
)	O
;	O
}	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
i	long
]	O
.	O
Id	long
,	O
new_name	*(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_remove_superclass_ap	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
anchor_point	*(char)
)	O
{	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
ESint32	long
i	long
,	O
indx1	long
,	O
indx2	long
;	O
if	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_remove_superclass_ap"	*(char)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
anchor_point	*(char)
==	O
NULL	O
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_remove_superclass_ap] No anchot point provided"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_uplink_by_name	(long,*(char))->(long)
(	O
IdObj	long
,	O
anchor_point	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_remove_superclass_ap] %s anchor point "	*(char)
"doesn't exist in object %ld"	*(char)
,	O
anchor_point	*(char)
,	O
IdObj	long
)	O
;	O
}	O
indx1	long
=	O
i	long
;	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
indx1	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
(	O
indx2	long
=	O
_edma_locate_downlink_by_pobj	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))->(long)
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_remove_superclass_ap] %s anchor point "	*(char)
"doesn't exist in superobject %ld"	*(char)
,	O
anchor_point	*(char)
,	O
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
)	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
+	O
indx1	long
,	O
0	int
,	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
)	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
+	O
indx2	long
,	O
0	int
,	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
)	O
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
--	O
;	O
if	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
==	O
0	int
)	O
{	O
edma_pfree	(long,*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
=	O
NULL	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
=	O
0	int
;	O
}	O
else	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
+	O
indx1	long
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
+	O
(	O
indx1	long
+	O
1	int
)	O
,	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
*	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
-	O
indx1	long
)	O
)	O
;	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
--	O
;	O
if	O
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
<	O
0	int
)	O
{	O
edma_pfree	(long,*(void))->(void)
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
SysObj	struct(long,long,long,long,long)
.	O
hDownTable	long
,	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
=	O
NULL	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hDownTable	long
=	O
0	int
;	O
}	O
else	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
+	O
indx2	long
,	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
+	O
(	O
indx2	long
+	O
1	int
)	O
,	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
*	O
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
-	O
indx2	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_remove_subclass_ap	(long,*(char))->(long)
(	O
OBJID	long
IdObj	long
,	O
EPChar	*(char)
anchor_point	*(char)
)	O
{	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
;	O
ESint32	long
i	long
,	O
indx1	long
,	O
indx2	long
;	O
if	O
(	O
edma_check_obj_id	(long,*(char))->(long)
(	O
IdObj	long
,	O
"edma_remove_subclass_ap"	*(char)
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
anchor_point	*(char)
==	O
NULL	O
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_remove_subclass_ap] No anchot point provided"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
indx1	long
=	O
indx2	long
=	O
0	int
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_downlink_by_name	(long,*(char))->(long)
(	O
IdObj	long
,	O
anchor_point	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_remove_subclass_ap] %s anchor point "	*(char)
"doesn't exist in object %ld"	*(char)
,	O
anchor_point	*(char)
,	O
IdObj	long
)	O
;	O
}	O
indx1	long
=	O
i	long
;	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
=	O
gObj	O
[	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
indx1	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
(	O
indx2	long
=	O
_edma_locate_uplink_by_pobj	(*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))),*(struct(*(void),*(struct(char,long,array(char),*`,*`,*`)),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long)))))->(long)
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	(*(char))->(long)
(	O
"[edma_remove_subclass_ap] %s anchor point "	*(char)
"doesn't exist in superobject %ld"	*(char)
,	O
anchor_point	*(char)
,	O
(	O
POBJ	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
)	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
IdObj	long
)	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
+	O
indx1	long
,	O
0	int
,	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
)	O
;	O
memset	(*(void),int,int)->(*(void))
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
+	O
indx2	long
,	O
0	int
,	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
)	O
;	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
--	O
;	O
if	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
==	O
0	int
)	O
{	O
edma_pfree	(long,*(void))->(void)
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hDownTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
=	O
NULL	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hDownTable	long
=	O
0	int
;	O
}	O
else	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
+	O
indx1	long
,	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
DownTable	*(struct(long,array(char),long,long))
+	O
(	O
indx1	long
+	O
1	int
)	O
,	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
*	O
(	O
pObj	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nDownTable	long
-	O
indx1	long
)	O
)	O
;	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
--	O
;	O
if	O
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
==	O
0	int
)	O
{	O
edma_pfree	(long,*(void))->(void)
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
,	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
=	O
NULL	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
=	O
0	int
;	O
}	O
else	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
+	O
indx2	long
,	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
UpTable	*(struct(long,array(char),long,long))
+	O
(	O
indx2	long
+	O
1	int
)	O
,	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
*	O
(	O
pObj_father	*(struct(*(void),*(struct(char,long,array(char),*(()->(long)),*(void),*(struct`))),long,char,char,long,long,long,*(char),long,long,long,struct(long,long,long,long,long),long,long,long,long,long,*(struct(long,array(char),long,long)),long,*(struct(long,array(char),long,long))))
->	O
nUpTable	long
-	O
indx2	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_add_super_ap	(long,*(char),long,long,long)->(long)
(	O
OBJID	long
id	long
,	O
EPChar	*(char)
apoint	*(char)
,	O
CLASSID	long
cid	long
,	O
OBJID	long
superid	long
,	O
ESint32	long
flags	long
)	O
{	O
ESint32	long
n	long
;	O
if	O
(	O
apoint	*(char)
)	O
{	O
if	O
(	O
_edma_locate_uplink_by_name	(long,*(char))->(long)
(	O
id	long
,	O
apoint	*(char)
)	O
!=	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_add_super_ap] Anchor point %s "	*(char)
"already exists on object %ld [%s]"	*(char)
,	O
apoint	*(char)
,	O
id	long
,	O
gClass	O
[	O
gObj	O
[	O
id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
n	long
=	O
gObj	O
[	O
id	long
]	O
->	O
nUpTable	long
;	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
=	O
edma_prealloc	(long,long)->(long)
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
,	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
*	O
(	O
n	long
+	O
1	int
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_add_super_ap] Can't realloc "	*(char)
"object superclass table. Not enough memory"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
=	O
edma_pget	(long)->(*(void))
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_add_superobject] Can't realloc "	*(char)
"object superclass table. Not enough memory"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
gObj	O
[	O
id	long
]	O
->	O
nUpTable	long
=	O
n	long
+	O
1	int
;	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
n	long
]	O
.	O
IdClass	long
=	O
cid	long
;	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
n	long
]	O
.	O
Obj	long
=	O
superid	long
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
n	long
]	O
.	O
Id	long
,	O
apoint	*(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_add_sub_ap	(long,*(char),long,long,long)->(long)
(	O
OBJID	long
id	long
,	O
EPChar	*(char)
apoint	*(char)
,	O
CLASSID	long
cid	long
,	O
OBJID	long
subid	long
,	O
ESint32	long
flags	long
)	O
{	O
ESint32	long
n	long
;	O
if	O
(	O
apoint	*(char)
)	O
{	O
if	O
(	O
_edma_locate_downlink_by_name	(long,*(char))->(long)
(	O
id	long
,	O
apoint	*(char)
)	O
!=	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_add_sub_ap] Anchor point %s "	*(char)
"already exists on object %ld [%s]"	*(char)
,	O
apoint	*(char)
,	O
id	long
,	O
gClass	O
[	O
gObj	O
[	O
id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
n	long
=	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
;	O
if	O
(	O
n	long
<	O
0	int
)	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_add_sub_ap] Number of entries in downlink table is < 0: %d"	*(char)
,	O
n	long
)	O
;	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hDownTable	long
=	O
edma_prealloc	(long,long)->(long)
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hDownTable	long
,	O
sizeof	O
(	O
SC_ID	struct(long,array(char),long,long)
)	O
*	O
(	O
n	long
+	O
1	int
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_add_sub_ap] Can't realloc "	*(char)
"object subclass table. Not enough memory"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
=	O
edma_pget	(long)->(*(void))
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hDownTable	long
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_add_superobject] Can't realloc "	*(char)
"object subclass table. Not enough memory"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
=	O
n	long
+	O
1	int
;	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
n	long
]	O
.	O
IdClass	long
=	O
cid	long
;	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
n	long
]	O
.	O
Obj	long
=	O
subid	long
;	O
strncpy	(*(char),*(char),int)->(*(char))
(	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
n	long
]	O
.	O
Id	long
,	O
apoint	*(char)
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
OBJID	long
EDMAPROC	O
edma_set_super_ap	(long,*(char),long)->(long)
(	O
OBJID	long
id	long
,	O
EPChar	*(char)
apoint	*(char)
,	O
OBJID	long
new_id	long
)	O
{	O
ESint32	long
indx	long
,	O
temp_indx	long
;	O
OBJID	long
old_id	long
;	O
if	O
(	O
!	O
apoint	*(char)
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_set_super_ap] Invalid anchor point (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
indx	long
=	O
_edma_locate_uplink_by_name	(long,*(char))->(long)
(	O
id	long
,	O
apoint	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_set_super_ap] Anchor point %s "	*(char)
"doesn't exist on object %ld [%s]"	*(char)
,	O
apoint	*(char)
,	O
id	long
,	O
gClass	O
[	O
gObj	O
[	O
id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
old_id	long
=	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
indx	long
]	O
.	O
Obj	long
;	O
if	O
(	O
(	O
edma_cast_obj	(long,*(char))->(long)
(	O
new_id	long
,	O
gClass	O
[	O
gObj	O
[	O
old_id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_set_super_ap] New object type doesn't match Anchor Point Type"	*(char)
)	O
;	O
}	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
indx	long
]	O
.	O
IdClass	long
=	O
gObj	O
[	O
new_id	long
]	O
->	O
IdClass	long
;	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
[	O
indx	long
]	O
.	O
Obj	long
=	O
new_id	long
;	O
if	O
(	O
(	O
temp_indx	long
=	O
_edma_locate_downlink_by_obj	(long,long)->(long)
(	O
old_id	long
,	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[WARNNING] SuperObject %d bad linkage to object %d. No anchor point found"	*(char)
,	O
old_id	long
,	O
id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
gObj	O
[	O
old_id	long
]	O
->	O
nDownTable	long
>	O
1	int
)	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
gObj	O
[	O
old_id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
+	O
temp_indx	long
,	O
gObj	O
[	O
old_id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
+	O
temp_indx	long
+	O
1	int
,	O
gObj	O
[	O
old_id	long
]	O
->	O
nDownTable	long
-	O
temp_indx	long
)	O
;	O
gObj	O
[	O
old_id	long
]	O
->	O
nDownTable	long
--	O
;	O
if	O
(	O
gObj	O
[	O
old_id	long
]	O
->	O
nDownTable	long
<=	O
0	int
)	O
{	O
edma_pfree	(long,*(void))->(void)
(	O
gObj	O
[	O
old_id	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hDownTable	long
,	O
gObj	O
[	O
old_id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
)	O
;	O
}	O
return	O
old_id	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_set_sub_ap	(long,*(char),long)->(long)
(	O
OBJID	long
id	long
,	O
EPChar	*(char)
apoint	*(char)
,	O
OBJID	long
new_id	long
)	O
{	O
ESint32	long
indx	long
,	O
temp_indx	long
;	O
OBJID	long
old_id	long
;	O
if	O
(	O
!	O
apoint	*(char)
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"%s"	*(char)
,	O
"[edma_set_sub_ap] Invalid anchor point (NULL)"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
indx	long
=	O
_edma_locate_downlink_by_name	(long,*(char))->(long)
(	O
id	long
,	O
apoint	*(char)
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_set_sub_ap] Anchor point %s "	*(char)
"doesn't exists on object %ld [%s]"	*(char)
,	O
apoint	*(char)
,	O
id	long
,	O
gClass	O
[	O
gObj	O
[	O
id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
old_id	long
=	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
indx	long
]	O
.	O
Obj	long
;	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
indx	long
]	O
.	O
IdClass	long
=	O
gObj	O
[	O
new_id	long
]	O
->	O
IdClass	long
;	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	*(struct(long,array(char),long,long))
[	O
indx	long
]	O
.	O
Obj	long
=	O
new_id	long
;	O
if	O
(	O
(	O
temp_indx	long
=	O
_edma_locate_uplink_by_obj	(long,long)->(long)
(	O
old_id	long
,	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	(*(char))->(long)
(	O
"[edma_set_sub_ap] ** WARNNING** SuperObject %d bad linkage to object %d. "	*(char)
"No anchor point found"	*(char)
,	O
old_id	long
,	O
id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
memcpy	(*(void),*(void),int)->(*(void))
(	O
gObj	O
[	O
old_id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
+	O
temp_indx	long
,	O
gObj	O
[	O
old_id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
+	O
temp_indx	long
+	O
1	int
,	O
gObj	O
[	O
old_id	long
]	O
->	O
nUpTable	long
-	O
temp_indx	long
)	O
;	O
gObj	O
[	O
old_id	long
]	O
->	O
nUpTable	long
--	O
;	O
if	O
(	O
gObj	O
[	O
old_id	long
]	O
->	O
nUpTable	long
<=	O
0	int
)	O
{	O
edma_pfree	(long,*(void))->(void)
(	O
gObj	O
[	O
old_id	long
]	O
->	O
SysObj	struct(long,long,long,long,long)
.	O
hUpTable	long
,	O
gObj	O
[	O
old_id	long
]	O
->	O
UpTable	*(struct(long,array(char),long,long))
)	O
;	O
}	O
return	O
old_id	long
;	O
}	O
