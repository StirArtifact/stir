struct	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
{	O
struct	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
const	O
*	O
parent	*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
}	O
;	O
static	O
struct	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
stats_base	struct(*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
static	O
int	O
show_help	int
;	O
static	O
int	O
show_version	int
;	O
static	O
int	O
suppress_errors	int
;	O
static	O
int	O
color_option	int
;	O
static	O
int	O
only_matching	int
;	O
static	O
int	O
align_tabs	int
;	O
static	O
const	O
char	O
*	O
group_separator	*(char)
=	O
SEP_STR_GROUP	*(char)
;	O
static	O
const	O
char	O
*	O
selected_match_color	*(char)
=	O
"01;31"	*(char)
;	O
static	O
const	O
char	O
*	O
context_match_color	*(char)
=	O
"01;31"	*(char)
;	O
static	O
const	O
char	O
*	O
filename_color	*(char)
=	O
"35"	*(char)
;	O
static	O
const	O
char	O
*	O
line_num_color	*(char)
=	O
"32"	*(char)
;	O
static	O
const	O
char	O
*	O
byte_num_color	*(char)
=	O
"32"	*(char)
;	O
static	O
const	O
char	O
*	O
sep_color	*(char)
=	O
"36"	*(char)
;	O
static	O
const	O
char	O
*	O
selected_line_color	*(char)
=	O
""	*(char)
;	O
static	O
const	O
char	O
*	O
context_line_color	*(char)
=	O
""	*(char)
;	O
static	O
const	O
char	O
*	O
sgr_start	*(char)
=	O
"\33[%sm\33[K"	*(char)
;	O
static	O
const	O
char	O
*	O
sgr_end	*(char)
=	O
"\33[m\33[K"	*(char)
;	O
struct	O
color_cap	struct(*(char),*(*(char)),*(()->(*(char))))
{	O
const	O
char	O
*	O
name	*(char)
;	O
const	O
char	O
*	O
*	O
var	*(*(char))
;	O
const	O
char	O
*	O
(	O
*	O
fct	*(()->(*(char)))
)	O
(	O
void	O
)	O
;	O
}	O
;	O
static	O
const	O
char	O
*	O
color_cap_mt_fct	()->(*(char))
(	O
void	O
)	O
{	O
context_match_color	*(char)
=	O
selected_match_color	*(char)
;	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
color_cap_rv_fct	()->(*(char))
(	O
void	O
)	O
{	O
color_option	int
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
static	O
const	O
char	O
*	O
color_cap_ne_fct	()->(*(char))
(	O
void	O
)	O
{	O
sgr_start	*(char)
=	O
"\33[%sm"	*(char)
;	O
sgr_end	*(char)
=	O
"\33[m"	*(char)
;	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
color_cap	struct(*(char),*(*(char)),*(()->(*(char))))
color_dict	array(struct(*(char),*(*(char)),*(()->(*(char)))))
[	O
]	O
=	O
{	O
{	O
"mt"	*(char)
,	O
&	O
selected_match_color	*(char)
,	O
color_cap_mt_fct	()->(*(char))
}	O
,	O
{	O
"ms"	*(char)
,	O
&	O
selected_match_color	*(char)
,	O
NULL	O
}	O
,	O
{	O
"mc"	*(char)
,	O
&	O
context_match_color	*(char)
,	O
NULL	O
}	O
,	O
{	O
"fn"	*(char)
,	O
&	O
filename_color	*(char)
,	O
NULL	O
}	O
,	O
{	O
"ln"	*(char)
,	O
&	O
line_num_color	*(char)
,	O
NULL	O
}	O
,	O
{	O
"bn"	*(char)
,	O
&	O
byte_num_color	*(char)
,	O
NULL	O
}	O
,	O
{	O
"se"	*(char)
,	O
&	O
sep_color	*(char)
,	O
NULL	O
}	O
,	O
{	O
"sl"	*(char)
,	O
&	O
selected_line_color	*(char)
,	O
NULL	O
}	O
,	O
{	O
"cx"	*(char)
,	O
&	O
context_line_color	*(char)
,	O
NULL	O
}	O
,	O
{	O
"rv"	*(char)
,	O
NULL	O
,	O
color_cap_rv_fct	()->(*(char))
}	O
,	O
{	O
"ne"	*(char)
,	O
NULL	O
,	O
color_cap_ne_fct	()->(*(char))
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
exclude	O
*	O
excluded_patterns	*(struct)
;	O
static	O
struct	O
exclude	O
*	O
included_patterns	*(struct)
;	O
static	O
struct	O
exclude	O
*	O
excluded_directory_patterns	*(struct)
;	O
static	O
char	O
const	O
short_options	array(char)
[	O
]	O
=	O
"0123456789A:B:C:D:EFGHIPTUVX:abcd:e:f:hiKLlm:noqRrsuvwxyZz"	*(char)
;	O
enum	O
{	O
BINARY_FILES_OPTION	int
=	O
CHAR_MAX	O
+	O
1	int
,	O
COLOR_OPTION	int
,	O
INCLUDE_OPTION	int
,	O
EXCLUDE_OPTION	int
,	O
EXCLUDE_FROM_OPTION	int
,	O
LINE_BUFFERED_OPTION	int
,	O
LABEL_OPTION	int
,	O
EXCLUDE_DIRECTORY_OPTION	int
,	O
GROUP_SEPARATOR_OPTION	int
,	O
MMAP_OPTION	int
}	O
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
const	O
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"basic-regexp"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'G'	O
}	O
,	O
{	O
"extended-regexp"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'E'	O
}	O
,	O
{	O
"fixed-regexp"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
{	O
"fixed-strings"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
{	O
"perl-regexp"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"after-context"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'A'	O
}	O
,	O
{	O
"before-context"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'B'	O
}	O
,	O
{	O
"binary-files"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
BINARY_FILES_OPTION	int
}	O
,	O
{	O
"byte-offset"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'b'	O
}	O
,	O
{	O
"context"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'C'	O
}	O
,	O
{	O
"color"	*(char)
,	O
optional_argument	int
,	O
NULL	O
,	O
COLOR_OPTION	int
}	O
,	O
{	O
"colour"	*(char)
,	O
optional_argument	int
,	O
NULL	O
,	O
COLOR_OPTION	int
}	O
,	O
{	O
"count"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"devices"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"directories"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"exclude"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
EXCLUDE_OPTION	int
}	O
,	O
{	O
"exclude-from"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
EXCLUDE_FROM_OPTION	int
}	O
,	O
{	O
"exclude-dir"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
EXCLUDE_DIRECTORY_OPTION	int
}	O
,	O
{	O
"file"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'f'	O
}	O
,	O
{	O
"files-with-matches"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"files-without-match"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'L'	O
}	O
,	O
{	O
"group-separator"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
GROUP_SEPARATOR_OPTION	int
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
&	O
show_help	int
,	O
1	int
}	O
,	O
{	O
"include"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
INCLUDE_OPTION	int
}	O
,	O
{	O
"ignore-case"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"initial-tab"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'T'	O
}	O
,	O
{	O
"label"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
LABEL_OPTION	int
}	O
,	O
{	O
"line-buffered"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
LINE_BUFFERED_OPTION	int
}	O
,	O
{	O
"line-number"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"line-regexp"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"max-count"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'm'	O
}	O
,	O
{	O
"mmap"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
MMAP_OPTION	int
}	O
,	O
{	O
"no-filename"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"no-group-separator"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
GROUP_SEPARATOR_OPTION	int
}	O
,	O
{	O
"no-messages"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"null"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'Z'	O
}	O
,	O
{	O
"null-data"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'z'	O
}	O
,	O
{	O
"only-matching"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"quiet"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
{	O
"recursive"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"recursive"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"regexp"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"invert-match"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"silent"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
{	O
"text"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"binary"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'U'	O
}	O
,	O
{	O
"unix-byte-offsets"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'u'	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
"with-filename"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'H'	O
}	O
,	O
{	O
"word-regexp"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
int	O
match_icase	int
;	O
int	O
match_words	int
;	O
int	O
match_lines	int
;	O
unsigned	O
char	O
eolbyte	char
;	O
static	O
char	O
const	O
*	O
filename	*(char)
;	O
static	O
int	O
errseen	int
;	O
enum	O
directories_type	enum(int,int,int)
{	O
READ_DIRECTORIES	int
=	O
2	int
,	O
RECURSE_DIRECTORIES	int
,	O
SKIP_DIRECTORIES	int
}	O
;	O
static	O
char	O
const	O
*	O
const	O
directories_args	array(*(char))
[	O
]	O
=	O
{	O
"read"	*(char)
,	O
"recurse"	*(char)
,	O
"skip"	*(char)
,	O
NULL	O
}	O
;	O
static	O
enum	O
directories_type	enum(int,int,int)
const	O
directories_types	array(enum(int,int,int))
[	O
]	O
=	O
{	O
READ_DIRECTORIES	int
,	O
RECURSE_DIRECTORIES	int
,	O
SKIP_DIRECTORIES	int
}	O
;	O
ARGMATCH_VERIFY	O
(	O
directories_args	array(*(char))
,	O
directories_types	array(enum(int,int,int))
)	O
;	O
static	O
enum	O
directories_type	enum(int,int,int)
directories	enum(int,int,int)
=	O
READ_DIRECTORIES	int
;	O
static	O
enum	O
{	O
READ_DEVICES	int
,	O
SKIP_DEVICES	int
}	O
devices	enum(int,int)
=	O
READ_DEVICES	int
;	O
static	O
int	O
grepdir	(*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
char	O
const	O
*	O
,	O
struct	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
const	O
*	O
)	O
;	O
static	O
compile_fp_t	*((*(char),long)->(void))
compile	*((*(char),long)->(void))
;	O
static	O
execute_fp_t	*((*(char),long,*(long),*(char))->(long))
execute	*((*(char),long,*(long),*(char))->(long))
;	O
static	O
void	O
suppressible_error	(*(char),int)->(void)
(	O
char	O
const	O
*	O
mesg	*(char)
,	O
int	O
errnum	int
)	O
{	O
if	O
(	O
!	O
suppress_errors	int
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errnum	int
,	O
"%s"	*(char)
,	O
mesg	*(char)
)	O
;	O
errseen	int
=	O
1	int
;	O
}	O
static	O
void	O
context_length_arg	(*(char),*(int))->(void)
(	O
char	O
const	O
*	O
str	*(char)
,	O
int	O
*	O
out	*(int)
)	O
{	O
uintmax_t	long
value	*(char)
;	O
if	O
(	O
!	O
(	O
xstrtoumax	(*(char),*(*(char)),int,*(long),*(char))->(enum(int,int,int,int,int))
(	O
str	*(char)
,	O
0	int
,	O
10	int
,	O
&	O
value	*(char)
,	O
""	*(char)
)	O
==	O
LONGINT_OK	int
&&	O
0	int
<=	O
(	O
*	O
out	*(int)
=	O
value	*(char)
)	O
&&	O
*	O
out	*(int)
==	O
value	*(char)
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
"%s: %s"	*(char)
,	O
str	*(char)
,	O
_	O
(	O
"invalid context length argument"	*(char)
)	O
)	O
;	O
}	O
}	O
static	O
char	O
*	O
buffer	*(char)
;	O
static	O
size_t	long
bufalloc	long
;	O
static	O
int	O
bufdesc	int
;	O
static	O
char	O
*	O
bufbeg	*(char)
;	O
static	O
char	O
*	O
buflim	*(char)
;	O
static	O
size_t	long
pagesize	long
;	O
static	O
off_t	long
bufoffset	long
;	O
static	O
off_t	long
after_last_match	long
;	O
static	O
int	O
reset	(int,*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
int	O
fd	int
,	O
char	O
const	O
*	O
file	*(char)
,	O
struct	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
if	O
(	O
!	O
pagesize	long
)	O
{	O
pagesize	long
=	O
getpagesize	()->(int)
(	O
)	O
;	O
if	O
(	O
pagesize	long
==	O
0	int
||	O
2	int
*	O
pagesize	long
+	O
1	int
<=	O
pagesize	long
)	O
abort	()->(void)
(	O
)	O
;	O
bufalloc	long
=	O
ALIGN_TO	O
(	O
INITIAL_BUFSIZE	int
,	O
pagesize	long
)	O
+	O
pagesize	long
+	O
1	int
;	O
buffer	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
bufalloc	long
)	O
;	O
}	O
bufbeg	*(char)
=	O
buflim	*(char)
=	O
ALIGN_TO	O
(	O
buffer	*(char)
+	O
1	int
,	O
pagesize	long
)	O
;	O
bufbeg	*(char)
[	O
-	O
1	int
]	O
=	O
eolbyte	char
;	O
bufdesc	int
=	O
fd	int
;	O
if	O
(	O
S_ISREG	O
(	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
file	*(char)
)	O
bufoffset	long
=	O
0	int
;	O
else	O
{	O
bufoffset	long
=	O
lseek	(int,long,int)->(long)
(	O
fd	int
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
if	O
(	O
bufoffset	long
<	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"lseek failed"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
fillbuf	(long,*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
size_t	long
save	long
,	O
struct	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
const	O
*	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
size_t	long
fillsize	long
=	O
0	int
;	O
int	O
cc	int
=	O
1	int
;	O
char	O
*	O
readbuf	*(char)
;	O
size_t	long
readsize	long
;	O
size_t	long
saved_offset	long
=	O
buflim	*(char)
-	O
save	long
-	O
buffer	*(char)
;	O
if	O
(	O
pagesize	long
<=	O
buffer	*(char)
+	O
bufalloc	long
-	O
buflim	*(char)
)	O
{	O
readbuf	*(char)
=	O
buflim	*(char)
;	O
bufbeg	*(char)
=	O
buflim	*(char)
-	O
save	long
;	O
}	O
else	O
{	O
size_t	long
minsize	long
=	O
save	long
+	O
pagesize	long
;	O
size_t	long
newsize	long
;	O
size_t	long
newalloc	long
;	O
char	O
*	O
newbuf	*(char)
;	O
for	O
(	O
newsize	long
=	O
bufalloc	long
-	O
pagesize	long
-	O
1	int
;	O
newsize	long
<	O
minsize	long
;	O
newsize	long
*=	O
2	int
)	O
if	O
(	O
newsize	long
*	O
2	int
<	O
newsize	long
||	O
newsize	long
*	O
2	int
+	O
pagesize	long
+	O
1	int
<	O
newsize	long
*	O
2	int
)	O
xalloc_die	()->(void)
(	O
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
off_t	long
to_be_read	long
=	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
-	O
bufoffset	long
;	O
off_t	long
maxsize_off	long
=	O
save	long
+	O
to_be_read	long
;	O
if	O
(	O
0	int
<=	O
to_be_read	long
&&	O
to_be_read	long
<=	O
maxsize_off	long
&&	O
maxsize_off	long
==	O
(	O
size_t	long
)	O
maxsize_off	long
&&	O
minsize	long
<=	O
(	O
size_t	long
)	O
maxsize_off	long
&&	O
(	O
size_t	long
)	O
maxsize_off	long
<	O
newsize	long
)	O
newsize	long
=	O
maxsize_off	long
;	O
}	O
newalloc	long
=	O
newsize	long
+	O
pagesize	long
+	O
1	int
;	O
newbuf	*(char)
=	O
bufalloc	long
<	O
newalloc	long
?	O
xmalloc	(long)->(*(void))
(	O
bufalloc	long
=	O
newalloc	long
)	O
:	O
buffer	*(char)
;	O
readbuf	*(char)
=	O
ALIGN_TO	O
(	O
newbuf	*(char)
+	O
1	int
+	O
save	long
,	O
pagesize	long
)	O
;	O
bufbeg	*(char)
=	O
readbuf	*(char)
-	O
save	long
;	O
memmove	(*(void),*(void),long)->(*(void))
(	O
bufbeg	*(char)
,	O
buffer	*(char)
+	O
saved_offset	long
,	O
save	long
)	O
;	O
bufbeg	*(char)
[	O
-	O
1	int
]	O
=	O
eolbyte	char
;	O
if	O
(	O
newbuf	*(char)
!=	O
buffer	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
buffer	*(char)
)	O
;	O
buffer	*(char)
=	O
newbuf	*(char)
;	O
}	O
}	O
readsize	long
=	O
buffer	*(char)
+	O
bufalloc	long
-	O
readbuf	*(char)
;	O
readsize	long
-=	O
readsize	long
%	O
pagesize	long
;	O
if	O
(	O
!	O
fillsize	long
)	O
{	O
ssize_t	long
bytesread	long
;	O
while	O
(	O
(	O
bytesread	long
=	O
read	*((*(void),*(char),long)->(long))
(	O
bufdesc	int
,	O
readbuf	*(char)
,	O
readsize	long
)	O
)	O
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
bytesread	long
<	O
0	int
)	O
cc	int
=	O
0	int
;	O
else	O
fillsize	long
=	O
bytesread	long
;	O
}	O
bufoffset	long
+=	O
fillsize	long
;	O
buflim	*(char)
=	O
readbuf	*(char)
+	O
fillsize	long
;	O
return	O
cc	int
;	O
}	O
static	O
enum	O
{	O
BINARY_BINARY_FILES	int
,	O
TEXT_BINARY_FILES	int
,	O
WITHOUT_MATCH_BINARY_FILES	int
}	O
binary_files	enum(int,int,int)
;	O
static	O
int	O
filename_mask	int
;	O
static	O
int	O
out_quiet	int
;	O
static	O
int	O
out_invert	int
;	O
static	O
int	O
out_file	int
;	O
static	O
int	O
out_line	int
;	O
static	O
int	O
out_byte	int
;	O
static	O
int	O
out_before	int
;	O
static	O
int	O
out_after	int
;	O
static	O
int	O
count_matches	int
;	O
static	O
int	O
list_files	int
;	O
static	O
int	O
no_filenames	int
;	O
static	O
off_t	long
max_count	long
;	O
static	O
int	O
line_buffered	int
;	O
static	O
char	O
*	O
label	*(char)
=	O
NULL	O
;	O
static	O
uintmax_t	long
totalcc	long
;	O
static	O
char	O
const	O
*	O
lastnl	*(char)
;	O
static	O
char	O
const	O
*	O
lastout	*(char)
;	O
static	O
uintmax_t	long
totalnl	long
;	O
static	O
off_t	long
outleft	long
;	O
static	O
int	O
pending	int
;	O
static	O
int	O
done_on_match	int
;	O
static	O
int	O
exit_on_match	int
;	O
static	O
uintmax_t	long
add_count	(long,long)->(long)
(	O
uintmax_t	long
a	long
,	O
uintmax_t	long
b	long
)	O
{	O
uintmax_t	long
sum	long
=	O
a	long
+	O
b	long
;	O
if	O
(	O
sum	long
<	O
a	long
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"input is too large to count"	*(char)
)	O
)	O
;	O
return	O
sum	long
;	O
}	O
static	O
void	O
nlscan	(*(char))->(void)
(	O
char	O
const	O
*	O
lim	*(char)
)	O
{	O
size_t	long
newlines	long
=	O
0	int
;	O
char	O
const	O
*	O
beg	*(char)
;	O
for	O
(	O
beg	*(char)
=	O
lastnl	*(char)
;	O
beg	*(char)
<	O
lim	*(char)
;	O
beg	*(char)
++	O
)	O
{	O
beg	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
beg	*(char)
,	O
eolbyte	char
,	O
lim	*(char)
-	O
beg	*(char)
)	O
;	O
if	O
(	O
!	O
beg	*(char)
)	O
break	O
;	O
newlines	long
++	O
;	O
}	O
totalnl	long
=	O
add_count	(long,long)->(long)
(	O
totalnl	long
,	O
newlines	long
)	O
;	O
lastnl	*(char)
=	O
lim	*(char)
;	O
}	O
static	O
void	O
print_filename	()->(void)
(	O
void	O
)	O
{	O
PR_SGR_START_IF	O
(	O
filename_color	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
filename	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
PR_SGR_END_IF	O
(	O
filename_color	*(char)
)	O
;	O
}	O
static	O
void	O
print_sep	(char)->(void)
(	O
char	O
sep	char
)	O
{	O
PR_SGR_START_IF	O
(	O
sep_color	*(char)
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
sep	char
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
PR_SGR_END_IF	O
(	O
sep_color	*(char)
)	O
;	O
}	O
static	O
void	O
print_offset	(long,int,*(char))->(void)
(	O
uintmax_t	long
pos	long
,	O
int	O
min_width	int
,	O
const	O
char	O
*	O
color	*(char)
)	O
{	O
char	O
buf	array(char)
[	O
sizeof	O
pos	long
*	O
CHAR_BIT	O
]	O
;	O
char	O
*	O
p	*(void)
=	O
buf	array(char)
+	O
sizeof	O
buf	array(char)
;	O
do	O
{	O
*	O
--	O
p	*(void)
=	O
'0'	O
+	O
pos	long
%	O
10	int
;	O
--	O
min_width	int
;	O
}	O
while	O
(	O
(	O
pos	long
/=	O
10	int
)	O
!=	O
0	int
)	O
;	O
if	O
(	O
align_tabs	int
)	O
while	O
(	O
--	O
min_width	int
>=	O
0	int
)	O
*	O
--	O
p	*(void)
=	O
' '	O
;	O
PR_SGR_START_IF	O
(	O
color	*(char)
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
p	*(void)
,	O
1	int
,	O
buf	array(char)
+	O
sizeof	O
buf	array(char)
-	O
p	*(void)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
PR_SGR_END_IF	O
(	O
color	*(char)
)	O
;	O
}	O
static	O
void	O
print_line_head	(*(char),*(char),int)->(void)
(	O
char	O
const	O
*	O
beg	*(char)
,	O
char	O
const	O
*	O
lim	*(char)
,	O
int	O
sep	char
)	O
{	O
int	O
pending_sep	int
=	O
0	int
;	O
if	O
(	O
out_file	int
)	O
{	O
print_filename	()->(void)
(	O
)	O
;	O
if	O
(	O
filename_mask	int
)	O
pending_sep	int
=	O
1	int
;	O
else	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
0	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
out_line	int
)	O
{	O
if	O
(	O
lastnl	*(char)
<	O
lim	*(char)
)	O
{	O
nlscan	(*(char))->(void)
(	O
beg	*(char)
)	O
;	O
totalnl	long
=	O
add_count	(long,long)->(long)
(	O
totalnl	long
,	O
1	int
)	O
;	O
lastnl	*(char)
=	O
lim	*(char)
;	O
}	O
if	O
(	O
pending_sep	int
)	O
print_sep	(char)->(void)
(	O
sep	char
)	O
;	O
print_offset	(long,int,*(char))->(void)
(	O
totalnl	long
,	O
4	int
,	O
line_num_color	*(char)
)	O
;	O
pending_sep	int
=	O
1	int
;	O
}	O
if	O
(	O
out_byte	int
)	O
{	O
uintmax_t	long
pos	long
=	O
add_count	(long,long)->(long)
(	O
totalcc	long
,	O
beg	*(char)
-	O
bufbeg	*(char)
)	O
;	O
if	O
(	O
pending_sep	int
)	O
print_sep	(char)->(void)
(	O
sep	char
)	O
;	O
print_offset	(long,int,*(char))->(void)
(	O
pos	long
,	O
6	int
,	O
byte_num_color	*(char)
)	O
;	O
pending_sep	int
=	O
1	int
;	O
}	O
if	O
(	O
pending_sep	int
)	O
{	O
if	O
(	O
align_tabs	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\t\b"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
print_sep	(char)->(void)
(	O
sep	char
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
print_line_middle	(*(char),*(char),*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
beg	*(char)
,	O
const	O
char	O
*	O
lim	*(char)
,	O
const	O
char	O
*	O
line_color	*(char)
,	O
const	O
char	O
*	O
match_color	*(char)
)	O
{	O
size_t	long
match_size	long
;	O
size_t	long
match_offset	long
;	O
const	O
char	O
*	O
cur	*(char)
=	O
beg	*(char)
;	O
const	O
char	O
*	O
mid	*(char)
=	O
NULL	O
;	O
while	O
(	O
cur	*(char)
<	O
lim	*(char)
&&	O
(	O
(	O
match_offset	long
=	O
execute	*((*(char),long,*(long),*(char))->(long))
(	O
beg	*(char)
,	O
lim	*(char)
-	O
beg	*(char)
,	O
&	O
match_size	long
,	O
beg	*(char)
+	O
(	O
cur	*(char)
-	O
beg	*(char)
)	O
)	O
)	O
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
)	O
{	O
char	O
const	O
*	O
b	long
=	O
beg	*(char)
+	O
match_offset	long
;	O
if	O
(	O
b	long
==	O
lim	*(char)
)	O
break	O
;	O
if	O
(	O
match_size	long
==	O
0	int
)	O
{	O
match_size	long
=	O
1	int
;	O
if	O
(	O
!	O
mid	*(char)
)	O
mid	*(char)
=	O
cur	*(char)
;	O
}	O
else	O
{	O
if	O
(	O
only_matching	int
)	O
print_line_head	(*(char),*(char),int)->(void)
(	O
b	long
,	O
lim	*(char)
,	O
out_invert	int
?	O
SEP_CHAR_REJECTED	char
:	O
SEP_CHAR_SELECTED	char
)	O
;	O
else	O
{	O
PR_SGR_START	O
(	O
line_color	*(char)
)	O
;	O
if	O
(	O
mid	*(char)
)	O
{	O
cur	*(char)
=	O
mid	*(char)
;	O
mid	*(char)
=	O
NULL	O
;	O
}	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
cur	*(char)
,	O
sizeof	O
(	O
char	O
)	O
,	O
b	long
-	O
cur	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
PR_SGR_START_IF	O
(	O
match_color	*(char)
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
b	long
,	O
sizeof	O
(	O
char	O
)	O
,	O
match_size	long
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
PR_SGR_END_IF	O
(	O
match_color	*(char)
)	O
;	O
if	O
(	O
only_matching	int
)	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
"\n"	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
cur	*(char)
=	O
b	long
+	O
match_size	long
;	O
}	O
if	O
(	O
only_matching	int
)	O
cur	*(char)
=	O
lim	*(char)
;	O
else	O
if	O
(	O
mid	*(char)
)	O
cur	*(char)
=	O
mid	*(char)
;	O
return	O
cur	*(char)
;	O
}	O
static	O
const	O
char	O
*	O
print_line_tail	(*(char),*(char),*(char))->(*(char))
(	O
const	O
char	O
*	O
beg	*(char)
,	O
const	O
char	O
*	O
lim	*(char)
,	O
const	O
char	O
*	O
line_color	*(char)
)	O
{	O
size_t	long
eol_size	long
;	O
size_t	long
tail_size	long
;	O
eol_size	long
=	O
(	O
lim	*(char)
>	O
beg	*(char)
&&	O
lim	*(char)
[	O
-	O
1	int
]	O
==	O
eolbyte	char
)	O
;	O
eol_size	long
+=	O
(	O
lim	*(char)
-	O
eol_size	long
>	O
beg	*(char)
&&	O
lim	*(char)
[	O
-	O
(	O
1	int
+	O
eol_size	long
)	O
]	O
==	O
'\r'	O
)	O
;	O
tail_size	long
=	O
lim	*(char)
-	O
eol_size	long
-	O
beg	*(char)
;	O
if	O
(	O
tail_size	long
>	O
0	int
)	O
{	O
PR_SGR_START	O
(	O
line_color	*(char)
)	O
;	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
beg	*(char)
,	O
1	int
,	O
tail_size	long
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
beg	*(char)
+=	O
tail_size	long
;	O
PR_SGR_END	O
(	O
line_color	*(char)
)	O
;	O
}	O
return	O
beg	*(char)
;	O
}	O
static	O
void	O
prline	(*(char),*(char),int)->(void)
(	O
char	O
const	O
*	O
beg	*(char)
,	O
char	O
const	O
*	O
lim	*(char)
,	O
int	O
sep	char
)	O
{	O
int	O
matching	int
;	O
const	O
char	O
*	O
line_color	*(char)
;	O
const	O
char	O
*	O
match_color	*(char)
;	O
if	O
(	O
!	O
only_matching	int
)	O
print_line_head	(*(char),*(char),int)->(void)
(	O
beg	*(char)
,	O
lim	*(char)
,	O
sep	char
)	O
;	O
matching	int
=	O
(	O
sep	char
==	O
SEP_CHAR_SELECTED	char
)	O
^	O
!	O
!	O
out_invert	int
;	O
if	O
(	O
color_option	int
)	O
{	O
line_color	*(char)
=	O
(	O
(	O
sep	char
==	O
SEP_CHAR_SELECTED	char
)	O
^	O
(	O
out_invert	int
&&	O
(	O
color_option	int
<	O
0	int
)	O
)	O
)	O
?	O
selected_line_color	*(char)
:	O
context_line_color	*(char)
;	O
match_color	*(char)
=	O
(	O
sep	char
==	O
SEP_CHAR_SELECTED	char
)	O
?	O
selected_match_color	*(char)
:	O
context_match_color	*(char)
;	O
}	O
else	O
line_color	*(char)
=	O
match_color	*(char)
=	O
NULL	O
;	O
if	O
(	O
(	O
only_matching	int
&&	O
matching	int
)	O
||	O
(	O
color_option	int
&&	O
(	O
*	O
line_color	*(char)
||	O
*	O
match_color	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
matching	int
&&	O
(	O
only_matching	int
||	O
*	O
match_color	*(char)
)	O
)	O
beg	*(char)
=	O
print_line_middle	(*(char),*(char),*(char),*(char))->(*(char))
(	O
beg	*(char)
,	O
lim	*(char)
,	O
line_color	*(char)
,	O
match_color	*(char)
)	O
;	O
if	O
(	O
!	O
only_matching	int
&&	O
*	O
line_color	*(char)
)	O
beg	*(char)
=	O
print_line_tail	(*(char),*(char),*(char))->(*(char))
(	O
beg	*(char)
,	O
lim	*(char)
,	O
line_color	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
only_matching	int
&&	O
lim	*(char)
>	O
beg	*(char)
)	O
fwrite	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
beg	*(char)
,	O
1	int
,	O
lim	*(char)
-	O
beg	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"writing output"	*(char)
)	O
)	O
;	O
lastout	*(char)
=	O
lim	*(char)
;	O
if	O
(	O
line_buffered	int
)	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
prpending	(*(char))->(void)
(	O
char	O
const	O
*	O
lim	*(char)
)	O
{	O
if	O
(	O
!	O
lastout	*(char)
)	O
lastout	*(char)
=	O
bufbeg	*(char)
;	O
while	O
(	O
pending	int
>	O
0	int
&&	O
lastout	*(char)
<	O
lim	*(char)
)	O
{	O
char	O
const	O
*	O
nl	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
lastout	*(char)
,	O
eolbyte	char
,	O
lim	*(char)
-	O
lastout	*(char)
)	O
;	O
size_t	long
match_size	long
;	O
--	O
pending	int
;	O
if	O
(	O
outleft	long
||	O
(	O
(	O
execute	*((*(char),long,*(long),*(char))->(long))
(	O
lastout	*(char)
,	O
nl	*(char)
+	O
1	int
-	O
lastout	*(char)
,	O
&	O
match_size	long
,	O
NULL	O
)	O
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
==	O
!	O
out_invert	int
)	O
)	O
prline	(*(char),*(char),int)->(void)
(	O
lastout	*(char)
,	O
nl	*(char)
+	O
1	int
,	O
SEP_CHAR_REJECTED	char
)	O
;	O
else	O
pending	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
prtext	(*(char),*(char),*(int))->(void)
(	O
char	O
const	O
*	O
beg	*(char)
,	O
char	O
const	O
*	O
lim	*(char)
,	O
int	O
*	O
nlinesp	*(int)
)	O
{	O
static	O
int	O
used	int
;	O
char	O
const	O
*	O
bp	*(char)
,	O
*	O
p	*(void)
;	O
char	O
eol	char
=	O
eolbyte	char
;	O
int	O
i	int
,	O
n	long
;	O
if	O
(	O
!	O
out_quiet	int
&&	O
pending	int
>	O
0	int
)	O
prpending	(*(char))->(void)
(	O
beg	*(char)
)	O
;	O
p	*(void)
=	O
beg	*(char)
;	O
if	O
(	O
!	O
out_quiet	int
)	O
{	O
bp	*(char)
=	O
lastout	*(char)
?	O
lastout	*(char)
:	O
bufbeg	*(char)
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
out_before	int
;	O
++	O
i	int
)	O
if	O
(	O
p	*(void)
>	O
bp	*(char)
)	O
do	O
--	O
p	*(void)
;	O
while	O
(	O
p	*(void)
[	O
-	O
1	int
]	O
!=	O
eol	char
)	O
;	O
if	O
(	O
(	O
out_before	int
||	O
out_after	int
)	O
&&	O
used	int
&&	O
p	*(void)
!=	O
lastout	*(char)
&&	O
group_separator	*(char)
)	O
{	O
PR_SGR_START_IF	O
(	O
sep_color	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
group_separator	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
PR_SGR_END_IF	O
(	O
sep_color	*(char)
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
while	O
(	O
p	*(void)
<	O
beg	*(char)
)	O
{	O
char	O
const	O
*	O
nl	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
p	*(void)
,	O
eol	char
,	O
beg	*(char)
-	O
p	*(void)
)	O
;	O
nl	*(char)
++	O
;	O
prline	(*(char),*(char),int)->(void)
(	O
p	*(void)
,	O
nl	*(char)
,	O
SEP_CHAR_REJECTED	char
)	O
;	O
p	*(void)
=	O
nl	*(char)
;	O
}	O
}	O
if	O
(	O
nlinesp	*(int)
)	O
{	O
for	O
(	O
n	long
=	O
0	int
;	O
p	*(void)
<	O
lim	*(char)
&&	O
n	long
<	O
outleft	long
;	O
n	long
++	O
)	O
{	O
char	O
const	O
*	O
nl	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
p	*(void)
,	O
eol	char
,	O
lim	*(char)
-	O
p	*(void)
)	O
;	O
nl	*(char)
++	O
;	O
if	O
(	O
!	O
out_quiet	int
)	O
prline	(*(char),*(char),int)->(void)
(	O
p	*(void)
,	O
nl	*(char)
,	O
SEP_CHAR_SELECTED	char
)	O
;	O
p	*(void)
=	O
nl	*(char)
;	O
}	O
*	O
nlinesp	*(int)
=	O
n	long
;	O
after_last_match	long
=	O
bufoffset	long
-	O
(	O
buflim	*(char)
-	O
p	*(void)
)	O
;	O
}	O
else	O
if	O
(	O
!	O
out_quiet	int
)	O
prline	(*(char),*(char),int)->(void)
(	O
beg	*(char)
,	O
lim	*(char)
,	O
SEP_CHAR_SELECTED	char
)	O
;	O
pending	int
=	O
out_quiet	int
?	O
0	int
:	O
out_after	int
;	O
used	int
=	O
1	int
;	O
}	O
static	O
size_t	long
do_execute	(*(char),long,*(long),*(char))->(long)
(	O
char	O
const	O
*	O
buf	array(char)
,	O
size_t	long
size	long
,	O
size_t	long
*	O
match_size	long
,	O
char	O
const	O
*	O
start_ptr	*(char)
)	O
{	O
size_t	long
result	long
;	O
const	O
char	O
*	O
line_next	*(char)
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
!	O
match_icase	int
)	O
return	O
execute	*((*(char),long,*(long),*(char))->(long))
(	O
buf	array(char)
,	O
size	long
,	O
match_size	long
,	O
start_ptr	*(char)
)	O
;	O
for	O
(	O
line_next	*(char)
=	O
buf	array(char)
;	O
line_next	*(char)
<	O
buf	array(char)
+	O
size	long
;	O
)	O
{	O
const	O
char	O
*	O
line_buf	*(char)
=	O
line_next	*(char)
;	O
const	O
char	O
*	O
line_end	*(char)
=	O
memchr	(*(void),int,long)->(*(void))
(	O
line_buf	*(char)
,	O
eolbyte	char
,	O
(	O
buf	array(char)
+	O
size	long
)	O
-	O
line_buf	*(char)
)	O
;	O
if	O
(	O
line_end	*(char)
==	O
NULL	O
)	O
line_next	*(char)
=	O
line_end	*(char)
=	O
buf	array(char)
+	O
size	long
;	O
else	O
line_next	*(char)
=	O
line_end	*(char)
+	O
1	int
;	O
if	O
(	O
start_ptr	*(char)
&&	O
start_ptr	*(char)
>=	O
line_end	*(char)
)	O
continue	O
;	O
result	long
=	O
execute	*((*(char),long,*(long),*(char))->(long))
(	O
line_buf	*(char)
,	O
line_next	*(char)
-	O
line_buf	*(char)
,	O
match_size	long
,	O
start_ptr	*(char)
)	O
;	O
if	O
(	O
result	long
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
return	O
(	O
line_buf	*(char)
-	O
buf	array(char)
)	O
+	O
result	long
;	O
}	O
return	O
(	O
size_t	long
)	O
-	O
1	int
;	O
}	O
static	O
int	O
grepbuf	(*(char),*(char))->(int)
(	O
char	O
const	O
*	O
beg	*(char)
,	O
char	O
const	O
*	O
lim	*(char)
)	O
{	O
int	O
nlines	int
,	O
n	long
;	O
char	O
const	O
*	O
p	*(void)
;	O
size_t	long
match_offset	long
;	O
size_t	long
match_size	long
;	O
nlines	int
=	O
0	int
;	O
p	*(void)
=	O
beg	*(char)
;	O
while	O
(	O
(	O
match_offset	long
=	O
do_execute	(*(char),long,*(long),*(char))->(long)
(	O
p	*(void)
,	O
lim	*(char)
-	O
p	*(void)
,	O
&	O
match_size	long
,	O
NULL	O
)	O
)	O
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
{	O
char	O
const	O
*	O
b	long
=	O
p	*(void)
+	O
match_offset	long
;	O
char	O
const	O
*	O
endp	*(char)
=	O
b	long
+	O
match_size	long
;	O
if	O
(	O
b	long
==	O
lim	*(char)
)	O
break	O
;	O
if	O
(	O
!	O
out_invert	int
)	O
{	O
prtext	(*(char),*(char),*(int))->(void)
(	O
b	long
,	O
endp	*(char)
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
nlines	int
++	O
;	O
outleft	long
--	O
;	O
if	O
(	O
!	O
outleft	long
||	O
done_on_match	int
)	O
{	O
if	O
(	O
exit_on_match	int
)	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
after_last_match	long
=	O
bufoffset	long
-	O
(	O
buflim	*(char)
-	O
endp	*(char)
)	O
;	O
return	O
nlines	int
;	O
}	O
}	O
else	O
if	O
(	O
p	*(void)
<	O
b	long
)	O
{	O
prtext	(*(char),*(char),*(int))->(void)
(	O
p	*(void)
,	O
b	long
,	O
&	O
n	long
)	O
;	O
nlines	int
+=	O
n	long
;	O
outleft	long
-=	O
n	long
;	O
if	O
(	O
!	O
outleft	long
)	O
return	O
nlines	int
;	O
}	O
p	*(void)
=	O
endp	*(char)
;	O
}	O
if	O
(	O
out_invert	int
&&	O
p	*(void)
<	O
lim	*(char)
)	O
{	O
prtext	(*(char),*(char),*(int))->(void)
(	O
p	*(void)
,	O
lim	*(char)
,	O
&	O
n	long
)	O
;	O
nlines	int
+=	O
n	long
;	O
outleft	long
-=	O
n	long
;	O
}	O
return	O
nlines	int
;	O
}	O
static	O
int	O
grep	(int,*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
int	O
fd	int
,	O
char	O
const	O
*	O
file	*(char)
,	O
struct	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
int	O
nlines	int
,	O
i	int
;	O
int	O
not_text	int
;	O
size_t	long
residue	long
,	O
save	long
;	O
char	O
oldc	char
;	O
char	O
*	O
beg	*(char)
;	O
char	O
*	O
lim	*(char)
;	O
char	O
eol	char
=	O
eolbyte	char
;	O
if	O
(	O
!	O
reset	(int,*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
fd	int
,	O
file	*(char)
,	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
)	O
return	O
0	int
;	O
if	O
(	O
file	*(char)
&&	O
directories	enum(int,int,int)
==	O
RECURSE_DIRECTORIES	int
&&	O
S_ISDIR	O
(	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
close	*((*(void))->(int))
(	O
fd	int
)	O
!=	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
file	*(char)
)	O
;	O
return	O
grepdir	(*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
file	*(char)
,	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
-	O
2	int
;	O
}	O
totalcc	long
=	O
0	int
;	O
lastout	*(char)
=	O
0	int
;	O
totalnl	long
=	O
0	int
;	O
outleft	long
=	O
max_count	long
;	O
after_last_match	long
=	O
0	int
;	O
pending	int
=	O
0	int
;	O
nlines	int
=	O
0	int
;	O
residue	long
=	O
0	int
;	O
save	long
=	O
0	int
;	O
if	O
(	O
!	O
fillbuf	(long,*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
save	long
,	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
)	O
{	O
if	O
(	O
!	O
is_EISDIR	O
(	O
errno	O
,	O
file	*(char)
)	O
)	O
suppressible_error	(*(char),int)->(void)
(	O
filename	*(char)
,	O
errno	O
)	O
;	O
return	O
0	int
;	O
}	O
not_text	int
=	O
(	O
(	O
(	O
binary_files	enum(int,int,int)
==	O
BINARY_BINARY_FILES	int
&&	O
!	O
out_quiet	int
)	O
||	O
binary_files	enum(int,int,int)
==	O
WITHOUT_MATCH_BINARY_FILES	int
)	O
&&	O
memchr	(*(void),int,long)->(*(void))
(	O
bufbeg	*(char)
,	O
eol	char
?	O
'\0'	O
:	O
'\200'	O
,	O
buflim	*(char)
-	O
bufbeg	*(char)
)	O
)	O
;	O
if	O
(	O
not_text	int
&&	O
binary_files	enum(int,int,int)
==	O
WITHOUT_MATCH_BINARY_FILES	int
)	O
return	O
0	int
;	O
done_on_match	int
+=	O
not_text	int
;	O
out_quiet	int
+=	O
not_text	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
lastnl	*(char)
=	O
bufbeg	*(char)
;	O
if	O
(	O
lastout	*(char)
)	O
lastout	*(char)
=	O
bufbeg	*(char)
;	O
beg	*(char)
=	O
bufbeg	*(char)
+	O
save	long
;	O
if	O
(	O
beg	*(char)
==	O
buflim	*(char)
)	O
break	O
;	O
oldc	char
=	O
beg	*(char)
[	O
-	O
1	int
]	O
;	O
beg	*(char)
[	O
-	O
1	int
]	O
=	O
eol	char
;	O
for	O
(	O
lim	*(char)
=	O
buflim	*(char)
;	O
lim	*(char)
[	O
-	O
1	int
]	O
!=	O
eol	char
;	O
lim	*(char)
--	O
)	O
continue	O
;	O
beg	*(char)
[	O
-	O
1	int
]	O
=	O
oldc	char
;	O
if	O
(	O
lim	*(char)
==	O
beg	*(char)
)	O
lim	*(char)
=	O
beg	*(char)
-	O
residue	long
;	O
beg	*(char)
-=	O
residue	long
;	O
residue	long
=	O
buflim	*(char)
-	O
lim	*(char)
;	O
if	O
(	O
beg	*(char)
<	O
lim	*(char)
)	O
{	O
if	O
(	O
outleft	long
)	O
nlines	int
+=	O
grepbuf	(*(char),*(char))->(int)
(	O
beg	*(char)
,	O
lim	*(char)
)	O
;	O
if	O
(	O
pending	int
)	O
prpending	(*(char))->(void)
(	O
lim	*(char)
)	O
;	O
if	O
(	O
(	O
!	O
outleft	long
&&	O
!	O
pending	int
)	O
||	O
(	O
nlines	int
&&	O
done_on_match	int
&&	O
!	O
out_invert	int
)	O
)	O
goto	O
finish_grep	O
;	O
}	O
i	int
=	O
0	int
;	O
beg	*(char)
=	O
lim	*(char)
;	O
while	O
(	O
i	int
<	O
out_before	int
&&	O
beg	*(char)
>	O
bufbeg	*(char)
&&	O
beg	*(char)
!=	O
lastout	*(char)
)	O
{	O
++	O
i	int
;	O
do	O
--	O
beg	*(char)
;	O
while	O
(	O
beg	*(char)
[	O
-	O
1	int
]	O
!=	O
eol	char
)	O
;	O
}	O
if	O
(	O
beg	*(char)
!=	O
lastout	*(char)
)	O
lastout	*(char)
=	O
0	int
;	O
save	long
=	O
residue	long
+	O
lim	*(char)
-	O
beg	*(char)
;	O
if	O
(	O
out_byte	int
)	O
totalcc	long
=	O
add_count	(long,long)->(long)
(	O
totalcc	long
,	O
buflim	*(char)
-	O
bufbeg	*(char)
-	O
save	long
)	O
;	O
if	O
(	O
out_line	int
)	O
nlscan	(*(char))->(void)
(	O
beg	*(char)
)	O
;	O
if	O
(	O
!	O
fillbuf	(long,*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
save	long
,	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
)	O
{	O
if	O
(	O
!	O
is_EISDIR	O
(	O
errno	O
,	O
file	*(char)
)	O
)	O
suppressible_error	(*(char),int)->(void)
(	O
filename	*(char)
,	O
errno	O
)	O
;	O
goto	O
finish_grep	O
;	O
}	O
}	O
if	O
(	O
residue	long
)	O
{	O
*	O
buflim	*(char)
++	O
=	O
eol	char
;	O
if	O
(	O
outleft	long
)	O
nlines	int
+=	O
grepbuf	(*(char),*(char))->(int)
(	O
bufbeg	*(char)
+	O
save	long
-	O
residue	long
,	O
buflim	*(char)
)	O
;	O
if	O
(	O
pending	int
)	O
prpending	(*(char))->(void)
(	O
buflim	*(char)
)	O
;	O
}	O
finish_grep	O
:	O
done_on_match	int
-=	O
not_text	int
;	O
out_quiet	int
-=	O
not_text	int
;	O
if	O
(	O
(	O
not_text	int
&	O
~	O
out_quiet	int
)	O
&&	O
nlines	int
!=	O
0	int
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Binary file %s matches\n"	*(char)
)	O
,	O
filename	*(char)
)	O
;	O
return	O
nlines	int
;	O
}	O
static	O
int	O
grepfile	(*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
char	O
const	O
*	O
file	*(char)
,	O
struct	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
*	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
int	O
desc	int
;	O
int	O
count	int
;	O
int	O
status	int
;	O
if	O
(	O
!	O
file	*(char)
)	O
{	O
desc	int
=	O
0	int
;	O
filename	*(char)
=	O
label	*(char)
?	O
label	*(char)
:	O
_	O
(	O
"(standard input)"	*(char)
)	O
;	O
}	O
else	O
{	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
file	*(char)
,	O
&	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
{	O
suppressible_error	(*(char),int)->(void)
(	O
file	*(char)
,	O
errno	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
directories	enum(int,int,int)
==	O
SKIP_DIRECTORIES	int
&&	O
S_ISDIR	O
(	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
devices	enum(int,int)
==	O
SKIP_DEVICES	int
&&	O
(	O
S_ISCHR	O
(	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
||	O
S_ISBLK	O
(	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
||	O
S_ISSOCK	O
(	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
||	O
S_ISFIFO	O
(	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
)	O
return	O
1	int
;	O
while	O
(	O
(	O
desc	int
=	O
open	(*(char),int)->(int)
(	O
file	*(char)
,	O
O_RDONLY	int
)	O
)	O
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
desc	int
<	O
0	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
if	O
(	O
is_EISDIR	O
(	O
e	int
,	O
file	*(char)
)	O
&&	O
directories	enum(int,int,int)
==	O
RECURSE_DIRECTORIES	int
)	O
{	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
file	*(char)
,	O
&	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
file	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
return	O
grepdir	(*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
file	*(char)
,	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
}	O
if	O
(	O
!	O
suppress_errors	int
)	O
{	O
if	O
(	O
directories	enum(int,int,int)
==	O
SKIP_DIRECTORIES	int
)	O
switch	O
(	O
e	int
)	O
{	O
case	O
EISDIR	int
:	O
return	O
1	int
;	O
case	O
EACCES	int
:	O
if	O
(	O
isdir	(*(char))->(int)
(	O
file	*(char)
)	O
)	O
return	O
1	int
;	O
break	O
;	O
}	O
}	O
suppressible_error	(*(char),int)->(void)
(	O
file	*(char)
,	O
e	int
)	O
;	O
return	O
1	int
;	O
}	O
filename	*(char)
=	O
file	*(char)
;	O
}	O
if	O
(	O
!	O
isatty	(int)->(int)
(	O
desc	int
)	O
)	O
SET_BINARY	O
(	O
desc	int
)	O
;	O
count	int
=	O
grep	(int,*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
desc	int
,	O
file	*(char)
,	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
if	O
(	O
count	int
<	O
0	int
)	O
status	int
=	O
count	int
+	O
2	int
;	O
else	O
{	O
if	O
(	O
count_matches	int
)	O
{	O
if	O
(	O
out_file	int
)	O
{	O
print_filename	()->(void)
(	O
)	O
;	O
if	O
(	O
filename_mask	int
)	O
print_sep	(char)->(void)
(	O
SEP_CHAR_SELECTED	char
)	O
;	O
else	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
0	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
printf	(*(char))->(int)
(	O
"%d\n"	*(char)
,	O
count	int
)	O
;	O
}	O
status	int
=	O
!	O
count	int
;	O
if	O
(	O
list_files	int
==	O
1	int
-	O
2	int
*	O
status	int
)	O
{	O
print_filename	()->(void)
(	O
)	O
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
&	O
filename_mask	int
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
if	O
(	O
!	O
file	*(char)
)	O
{	O
off_t	long
required_offset	long
=	O
outleft	long
?	O
bufoffset	long
:	O
after_last_match	long
;	O
if	O
(	O
required_offset	long
!=	O
bufoffset	long
&&	O
lseek	(int,long,int)->(long)
(	O
desc	int
,	O
required_offset	long
,	O
SEEK_SET	int
)	O
<	O
0	int
&&	O
S_ISREG	O
(	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
filename	*(char)
)	O
;	O
}	O
else	O
while	O
(	O
close	*((*(void))->(int))
(	O
desc	int
)	O
!=	O
0	int
)	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
file	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
grepdir	(*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
char	O
const	O
*	O
dir	*(char)
,	O
struct	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
const	O
*	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
{	O
struct	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
const	O
*	O
ancestor	*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))
;	O
char	O
*	O
name_space	*(char)
;	O
int	O
status	int
=	O
1	int
;	O
if	O
(	O
excluded_directory_patterns	*(struct)
&&	O
excluded_file_name	(*(struct),*(char))->(bool)
(	O
excluded_directory_patterns	*(struct)
,	O
dir	*(char)
)	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
)	O
for	O
(	O
ancestor	*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))
=	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
(	O
ancestor	*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))
=	O
ancestor	*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))
->	O
parent	*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))
)	O
!=	O
0	int
;	O
)	O
if	O
(	O
ancestor	*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
==	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_ino	long
&&	O
ancestor	*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
==	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_dev	long
)	O
{	O
if	O
(	O
!	O
suppress_errors	int
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: %s: %s"	*(char)
)	O
,	O
dir	*(char)
,	O
_	O
(	O
"recursive directory loop"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
name_space	*(char)
=	O
savedir	(*(char),long,*(struct),*(struct),*(struct))->(*(char))
(	O
dir	*(char)
,	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
->	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_size	long
,	O
included_patterns	*(struct)
,	O
excluded_patterns	*(struct)
,	O
excluded_directory_patterns	*(struct)
)	O
;	O
if	O
(	O
!	O
name_space	*(char)
)	O
{	O
if	O
(	O
errno	O
)	O
suppressible_error	(*(char),int)->(void)
(	O
dir	*(char)
,	O
errno	O
)	O
;	O
else	O
xalloc_die	()->(void)
(	O
)	O
;	O
}	O
else	O
{	O
size_t	long
dirlen	long
=	O
strlen	(*(char))->(long)
(	O
dir	*(char)
)	O
;	O
int	O
needs_slash	int
=	O
!	O
(	O
dirlen	long
==	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
dir	*(char)
)	O
||	O
ISSLASH	O
(	O
dir	*(char)
[	O
dirlen	long
-	O
1	int
]	O
)	O
)	O
;	O
char	O
*	O
file	*(char)
=	O
NULL	O
;	O
char	O
const	O
*	O
namep	*(char)
=	O
name_space	*(char)
;	O
struct	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
child	struct(*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
child	struct(*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
.	O
parent	*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))
=	O
stats	struct(*(struct(*(struct(*(struct`),struct(long,long,long,int,int,int,int,long,long,long,long,struct`,struct`,struct`,array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
out_file	int
+=	O
!	O
no_filenames	int
;	O
while	O
(	O
*	O
namep	*(char)
)	O
{	O
size_t	long
namelen	long
=	O
strlen	(*(char))->(long)
(	O
namep	*(char)
)	O
;	O
file	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
file	*(char)
,	O
dirlen	long
+	O
1	int
+	O
namelen	long
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
file	*(char)
,	O
dir	*(char)
)	O
;	O
file	*(char)
[	O
dirlen	long
]	O
=	O
'/'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
file	*(char)
+	O
dirlen	long
+	O
needs_slash	int
,	O
namep	*(char)
)	O
;	O
namep	*(char)
+=	O
namelen	long
+	O
1	int
;	O
status	int
&=	O
grepfile	(*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
file	*(char)
,	O
&	O
child	struct(*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
}	O
out_file	int
-=	O
!	O
no_filenames	int
;	O
free	(*(void))->(void)
(	O
file	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name_space	*(char)
)	O
;	O
}	O
return	O
status	int
;	O
}	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
void	O
usage	(int)->(void)
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Usage: %s [OPTION]... PATTERN [FILE]...\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION]... PATTERN [FILE]...\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Search for PATTERN in each FILE or standard input.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
gettext	(*(char))->(*(char))
(	O
before_options	array(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Example: %s -i 'hello world' menu.h main.c\n\nRegexp selection and interpretation:\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
if	O
(	O
matchers	array(struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long))))
[	O
1	int
]	O
.	O
name	*(char)
)	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -E, --extended-regexp     PATTERN is an extended regular expression (ERE)\n  -F, --fixed-strings       PATTERN is a set of newline-separated fixed strings\n  -G, --basic-regexp        PATTERN is a basic regular expression (BRE)\n  -P, --perl-regexp         PATTERN is a Perl regular expression\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -e, --regexp=PATTERN      use PATTERN for matching\n  -f, --file=FILE           obtain PATTERN from FILE\n  -i, --ignore-case         ignore case distinctions\n  -w, --word-regexp         force PATTERN to match only whole words\n  -x, --line-regexp         force PATTERN to match only whole lines\n  -z, --null-data           a data line ends in 0 byte, not newline\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nMiscellaneous:\n  -s, --no-messages         suppress error messages\n  -v, --invert-match        select non-matching lines\n  -V, --version             print version information and exit\n      --help                display this help and exit\n      --mmap                ignored for backwards compatibility\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nOutput control:\n  -m, --max-count=NUM       stop after NUM matches\n  -b, --byte-offset         print the byte offset with output lines\n  -n, --line-number         print line number with output lines\n      --line-buffered       flush output on every line\n  -H, --with-filename       print the filename for each match\n  -h, --no-filename         suppress the prefixing filename on output\n      --label=LABEL         print LABEL as filename for standard input\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -o, --only-matching       show only the part of a line matching PATTERN\n  -q, --quiet, --silent     suppress all normal output\n      --binary-files=TYPE   assume that binary files are TYPE;\n                            TYPE is `binary', `text', or `without-match'\n  -a, --text                equivalent to --binary-files=text\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -I                        equivalent to --binary-files=without-match\n  -d, --directories=ACTION  how to handle directories;\n                            ACTION is `read', `recurse', or `skip'\n  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;\n                            ACTION is `read' or `skip'\n  -R, -r, --recursive       equivalent to --directories=recurse\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --include=FILE_PATTERN  search only files that match FILE_PATTERN\n      --exclude=FILE_PATTERN  skip files and directories matching FILE_PATTERN\n      --exclude-from=FILE   skip files matching any file pattern from FILE\n      --exclude-dir=PATTERN  directories that match PATTERN will be skipped.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -L, --files-without-match  print only names of FILEs containing no match\n  -l, --files-with-matches  print only names of FILEs containing matches\n  -c, --count               print only a count of matching lines per FILE\n  -T, --initial-tab         make tabs line up (if needed)\n  -Z, --null                print 0 byte after FILE name\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nContext control:\n  -B, --before-context=NUM  print NUM lines of leading context\n  -A, --after-context=NUM   print NUM lines of trailing context\n  -C, --context=NUM         print NUM lines of output context\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -NUM                      same as --context=NUM\n      --color[=WHEN],\n      --colour[=WHEN]       use markers to highlight the matching strings;\n                            WHEN is `always', `never', or `auto'\n  -U, --binary              do not strip CR characters at EOL (MSDOS)\n  -u, --unix-byte-offsets   report offsets as if CRs were not there (MSDOS)\n\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
_	O
(	O
after_options	array(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"With no FILE, or when FILE is -, read standard input.  If less than two FILEs\nare given, assume -h.  Exit status is 0 if any line was selected, 1 otherwise;\nif any error occurs and -q was not given, the exit status is 2.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nReport bugs to: %s\n"	*(char)
)	O
,	O
PACKAGE_BUGREPORT	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"GNU Grep home page: <%s>\n"	*(char)
)	O
,	O
"http://www.gnu.org/software/grep/"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"General help using GNU software: <http://www.gnu.org/gethelp/>\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
static	O
void	O
setmatcher	(*(char))->(void)
(	O
char	O
const	O
*	O
m	*(char)
)	O
{	O
static	O
char	O
const	O
*	O
matcher	struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long)))
;	O
unsigned	O
int	O
i	int
;	O
if	O
(	O
!	O
m	*(char)
)	O
{	O
compile	*((*(char),long)->(void))
=	O
matchers	array(struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long))))
[	O
0	int
]	O
.	O
compile	*((*(char),long)->(void))
;	O
execute	*((*(char),long,*(long),*(char))->(long))
=	O
matchers	array(struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long))))
[	O
0	int
]	O
.	O
execute	*((*(char),long,*(long),*(char))->(long))
;	O
if	O
(	O
!	O
matchers	array(struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long))))
[	O
1	int
]	O
.	O
name	*(char)
)	O
matcher	struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long)))
=	O
matchers	array(struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long))))
[	O
0	int
]	O
.	O
name	*(char)
;	O
}	O
else	O
if	O
(	O
matcher	struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long)))
)	O
{	O
if	O
(	O
matcher	struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long)))
&&	O
STREQ	O
(	O
matcher	struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long)))
,	O
m	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
!	O
matchers	array(struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long))))
[	O
1	int
]	O
.	O
name	*(char)
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"%s can only use the %s pattern syntax"	*(char)
)	O
,	O
program_name	*(char)
,	O
matcher	struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long)))
)	O
;	O
else	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"conflicting matchers specified"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
matchers	array(struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long))))
[	O
i	int
]	O
.	O
name	*(char)
;	O
i	int
++	O
)	O
if	O
(	O
STREQ	O
(	O
m	*(char)
,	O
matchers	array(struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long))))
[	O
i	int
]	O
.	O
name	*(char)
)	O
)	O
{	O
compile	*((*(char),long)->(void))
=	O
matchers	array(struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long))))
[	O
i	int
]	O
.	O
compile	*((*(char),long)->(void))
;	O
execute	*((*(char),long,*(long),*(char))->(long))
=	O
matchers	array(struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long))))
[	O
i	int
]	O
.	O
execute	*((*(char),long,*(long),*(char))->(long))
;	O
matcher	struct(*(char),*((*(char),long)->(void)),*((*(char),long,*(long),*(char))->(long)))
=	O
m	*(char)
;	O
return	O
;	O
}	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"invalid matcher %s"	*(char)
)	O
,	O
m	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
set_limits	()->(void)
(	O
void	O
)	O
{	O
}	O
static	O
int	O
prepend_args	(*(char),*(char),*(*(char)))->(int)
(	O
char	O
const	O
*	O
options	int
,	O
char	O
*	O
buf	array(char)
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
char	O
const	O
*	O
o	*(char)
=	O
options	int
;	O
char	O
*	O
b	long
=	O
buf	array(char)
;	O
int	O
n	long
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
c_isspace	(int)->(bool)
(	O
(	O
unsigned	O
char	O
)	O
*	O
o	*(char)
)	O
)	O
o	*(char)
++	O
;	O
if	O
(	O
!	O
*	O
o	*(char)
)	O
return	O
n	long
;	O
if	O
(	O
argv	*(*(char))
)	O
argv	*(*(char))
[	O
n	long
]	O
=	O
b	long
;	O
n	long
++	O
;	O
do	O
if	O
(	O
(	O
*	O
b	long
++	O
=	O
*	O
o	*(char)
++	O
)	O
==	O
'\\'	O
&&	O
*	O
o	*(char)
)	O
b	long
[	O
-	O
1	int
]	O
=	O
*	O
o	*(char)
++	O
;	O
while	O
(	O
*	O
o	*(char)
&&	O
!	O
c_isspace	(int)->(bool)
(	O
(	O
unsigned	O
char	O
)	O
*	O
o	*(char)
)	O
)	O
;	O
*	O
b	long
++	O
=	O
'\0'	O
;	O
}	O
}	O
static	O
void	O
prepend_default_options	(*(char),*(int),*(*(*(char))))->(void)
(	O
char	O
const	O
*	O
options	int
,	O
int	O
*	O
pargc	*(int)
,	O
char	O
*	O
*	O
*	O
pargv	*(*(*(char)))
)	O
{	O
if	O
(	O
options	int
&&	O
*	O
options	int
)	O
{	O
char	O
*	O
buf	array(char)
=	O
xmalloc	(long)->(*(void))
(	O
strlen	(*(char))->(long)
(	O
options	int
)	O
+	O
1	int
)	O
;	O
int	O
prepended	int
=	O
prepend_args	(*(char),*(char),*(*(char)))->(int)
(	O
options	int
,	O
buf	array(char)
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
int	O
argc	int
=	O
*	O
pargc	*(int)
;	O
char	O
*	O
const	O
*	O
argv	*(*(char))
=	O
*	O
pargv	*(*(*(char)))
;	O
char	O
*	O
*	O
pp	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
(	O
prepended	int
+	O
argc	int
+	O
1	int
)	O
*	O
sizeof	O
*	O
pp	*(*(char))
)	O
;	O
*	O
pargc	*(int)
=	O
prepended	int
+	O
argc	int
;	O
*	O
pargv	*(*(*(char)))
=	O
pp	*(*(char))
;	O
*	O
pp	*(*(char))
++	O
=	O
*	O
argv	*(*(char))
++	O
;	O
pp	*(*(char))
+=	O
prepend_args	(*(char),*(char),*(*(char)))->(int)
(	O
options	int
,	O
buf	array(char)
,	O
pp	*(*(char))
)	O
;	O
while	O
(	O
(	O
*	O
pp	*(*(char))
++	O
=	O
*	O
argv	*(*(char))
++	O
)	O
)	O
continue	O
;	O
}	O
}	O
static	O
int	O
get_nondigit_option	(int,*(*(char)),*(int))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
const	O
*	O
argv	*(*(char))
,	O
int	O
*	O
default_context	*(int)
)	O
{	O
static	O
int	O
prev_digit_optind	int
=	O
-	O
1	int
;	O
int	O
opt	int
,	O
this_digit_optind	int
,	O
was_digit	int
;	O
char	O
buf	array(char)
[	O
sizeof	O
(	O
uintmax_t	long
)	O
*	O
CHAR_BIT	O
+	O
4	int
]	O
;	O
char	O
*	O
p	*(void)
=	O
buf	array(char)
;	O
was_digit	int
=	O
0	int
;	O
this_digit_optind	int
=	O
optind	int
;	O
while	O
(	O
opt	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
(	O
char	O
*	O
*	O
)	O
argv	*(*(char))
,	O
short_options	array(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
NULL	O
)	O
,	O
'0'	O
<=	O
opt	int
&&	O
opt	int
<=	O
'9'	O
)	O
{	O
if	O
(	O
prev_digit_optind	int
!=	O
this_digit_optind	int
||	O
!	O
was_digit	int
)	O
{	O
p	*(void)
=	O
buf	array(char)
;	O
}	O
else	O
{	O
p	*(void)
-=	O
buf	array(char)
[	O
0	int
]	O
==	O
'0'	O
;	O
}	O
if	O
(	O
p	*(void)
==	O
buf	array(char)
+	O
sizeof	O
buf	array(char)
-	O
4	int
)	O
{	O
strcpy	(*(char),*(char))->(*(char))
(	O
p	*(void)
,	O
"..."	*(char)
)	O
;	O
p	*(void)
+=	O
3	int
;	O
break	O
;	O
}	O
*	O
p	*(void)
++	O
=	O
opt	int
;	O
was_digit	int
=	O
1	int
;	O
prev_digit_optind	int
=	O
this_digit_optind	int
;	O
this_digit_optind	int
=	O
optind	int
;	O
}	O
if	O
(	O
p	*(void)
!=	O
buf	array(char)
)	O
{	O
*	O
p	*(void)
=	O
'\0'	O
;	O
context_length_arg	(*(char),*(int))->(void)
(	O
buf	array(char)
,	O
default_context	*(int)
)	O
;	O
}	O
return	O
opt	int
;	O
}	O
static	O
void	O
parse_grep_colors	()->(void)
(	O
void	O
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
char	O
*	O
q	*(char)
;	O
char	O
*	O
name	*(char)
;	O
char	O
*	O
val	array(int)
;	O
p	*(void)
=	O
getenv	(*(char))->(*(char))
(	O
"GREP_COLORS"	*(char)
)	O
;	O
if	O
(	O
p	*(void)
==	O
NULL	O
||	O
*	O
p	*(void)
==	O
'\0'	O
)	O
return	O
;	O
q	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
p	*(void)
)	O
;	O
name	*(char)
=	O
q	*(char)
;	O
val	array(int)
=	O
NULL	O
;	O
for	O
(	O
;	O
;	O
)	O
if	O
(	O
*	O
q	*(char)
==	O
':'	O
||	O
*	O
q	*(char)
==	O
'\0'	O
)	O
{	O
char	O
c	int
=	O
*	O
q	*(char)
;	O
struct	O
color_cap	struct(*(char),*(*(char)),*(()->(*(char))))
*	O
cap	*(struct(*(char),*(*(char)),*(()->(*(char)))))
;	O
*	O
q	*(char)
++	O
=	O
'\0'	O
;	O
for	O
(	O
cap	*(struct(*(char),*(*(char)),*(()->(*(char)))))
=	O
color_dict	array(struct(*(char),*(*(char)),*(()->(*(char)))))
;	O
cap	*(struct(*(char),*(*(char)),*(()->(*(char)))))
->	O
name	*(char)
;	O
cap	*(struct(*(char),*(*(char)),*(()->(*(char)))))
++	O
)	O
if	O
(	O
STREQ	O
(	O
cap	*(struct(*(char),*(*(char)),*(()->(*(char)))))
->	O
name	*(char)
,	O
name	*(char)
)	O
)	O
break	O
;	O
if	O
(	O
cap	*(struct(*(char),*(*(char)),*(()->(*(char)))))
->	O
name	*(char)
)	O
{	O
if	O
(	O
cap	*(struct(*(char),*(*(char)),*(()->(*(char)))))
->	O
var	*(*(char))
)	O
{	O
if	O
(	O
val	array(int)
)	O
*	O
(	O
cap	*(struct(*(char),*(*(char)),*(()->(*(char)))))
->	O
var	*(*(char))
)	O
=	O
val	array(int)
;	O
else	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"in GREP_COLORS=\"%s\", the \"%s\" capacity "	*(char)
"needs a value (\"=...\"); skipped"	*(char)
)	O
,	O
p	*(void)
,	O
name	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
val	array(int)
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"in GREP_COLORS=\"%s\", the \"%s\" capacity "	*(char)
"is boolean and cannot take a value (\"=%s\"); skipped"	*(char)
)	O
,	O
p	*(void)
,	O
name	*(char)
,	O
val	array(int)
)	O
;	O
}	O
if	O
(	O
cap	*(struct(*(char),*(*(char)),*(()->(*(char)))))
->	O
fct	*(()->(*(char)))
)	O
{	O
const	O
char	O
*	O
err_str	*(char)
=	O
cap	*(struct(*(char),*(*(char)),*(()->(*(char)))))
->	O
fct	*(()->(*(char)))
(	O
)	O
;	O
if	O
(	O
err_str	*(char)
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"in GREP_COLORS=\"%s\", the \"%s\" capacity %s"	*(char)
)	O
,	O
p	*(void)
,	O
name	*(char)
,	O
err_str	*(char)
)	O
;	O
}	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
return	O
;	O
name	*(char)
=	O
q	*(char)
;	O
val	array(int)
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
*	O
q	*(char)
==	O
'='	O
)	O
{	O
if	O
(	O
q	*(char)
==	O
name	*(char)
||	O
val	array(int)
)	O
goto	O
ill_formed	O
;	O
*	O
q	*(char)
++	O
=	O
'\0'	O
;	O
val	array(int)
=	O
q	*(char)
;	O
}	O
else	O
if	O
(	O
val	array(int)
==	O
NULL	O
)	O
q	*(char)
++	O
;	O
else	O
if	O
(	O
*	O
q	*(char)
==	O
';'	O
||	O
(	O
*	O
q	*(char)
>=	O
'0'	O
&&	O
*	O
q	*(char)
<=	O
'9'	O
)	O
)	O
q	*(char)
++	O
;	O
else	O
goto	O
ill_formed	O
;	O
ill_formed	O
:	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"stopped processing of ill-formed GREP_COLORS=\"%s\" "	*(char)
"at remaining substring \"%s\""	*(char)
)	O
,	O
p	*(void)
,	O
q	*(char)
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
char	O
*	O
keys	*(char)
;	O
size_t	long
keycc	long
,	O
oldcc	long
,	O
keyalloc	long
;	O
int	O
with_filenames	int
;	O
int	O
opt	int
,	O
cc	int
,	O
status	int
;	O
int	O
default_context	*(int)
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
exit_failure	int
=	O
EXIT_TROUBLE	int
;	O
initialize_main	O
(	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
program_name	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
keys	*(char)
=	O
NULL	O
;	O
keycc	long
=	O
0	int
;	O
with_filenames	int
=	O
0	int
;	O
eolbyte	char
=	O
'\n'	O
;	O
filename_mask	int
=	O
~	O
0	int
;	O
max_count	long
=	O
TYPE_MAXIMUM	O
(	O
off_t	long
)	O
;	O
out_after	int
=	O
out_before	int
=	O
-	O
1	int
;	O
default_context	*(int)
=	O
0	int
;	O
only_matching	int
=	O
0	int
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	*(char)
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
exit_failure	int
=	O
EXIT_TROUBLE	int
;	O
atexit	(*(()->(void)))->(int)
(	O
close_stdout	()->(void)
)	O
;	O
prepend_default_options	(*(char),*(int),*(*(*(char))))->(void)
(	O
getenv	(*(char))->(*(char))
(	O
"GREP_OPTIONS"	*(char)
)	O
,	O
&	O
argc	int
,	O
&	O
argv	*(*(char))
)	O
;	O
setmatcher	(*(char))->(void)
(	O
NULL	O
)	O
;	O
while	O
(	O
(	O
opt	int
=	O
get_nondigit_option	(int,*(*(char)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
&	O
default_context	*(int)
)	O
)	O
!=	O
-	O
1	int
)	O
switch	O
(	O
opt	int
)	O
{	O
case	O
'A'	O
:	O
context_length_arg	(*(char),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
out_after	int
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
context_length_arg	(*(char),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
out_before	int
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
context_length_arg	(*(char),*(int))->(void)
(	O
optarg	*(char)
,	O
&	O
default_context	*(int)
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
STREQ	O
(	O
optarg	*(char)
,	O
"read"	*(char)
)	O
)	O
devices	enum(int,int)
=	O
READ_DEVICES	int
;	O
else	O
if	O
(	O
STREQ	O
(	O
optarg	*(char)
,	O
"skip"	*(char)
)	O
)	O
devices	enum(int,int)
=	O
SKIP_DEVICES	int
;	O
else	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"unknown devices method"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
setmatcher	(*(char))->(void)
(	O
"egrep"	*(char)
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
setmatcher	(*(char))->(void)
(	O
"fgrep"	*(char)
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
setmatcher	(*(char))->(void)
(	O
"perl"	*(char)
)	O
;	O
break	O
;	O
case	O
'G'	O
:	O
setmatcher	(*(char))->(void)
(	O
"grep"	*(char)
)	O
;	O
break	O
;	O
case	O
'X'	O
:	O
setmatcher	(*(char))->(void)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'H'	O
:	O
with_filenames	int
=	O
1	int
;	O
no_filenames	int
=	O
0	int
;	O
break	O
;	O
case	O
'I'	O
:	O
binary_files	enum(int,int,int)
=	O
WITHOUT_MATCH_BINARY_FILES	int
;	O
break	O
;	O
case	O
'T'	O
:	O
align_tabs	int
=	O
1	int
;	O
break	O
;	O
case	O
'U'	O
:	O
break	O
;	O
case	O
'u'	O
:	O
break	O
;	O
case	O
'V'	O
:	O
show_version	int
=	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
binary_files	enum(int,int,int)
=	O
TEXT_BINARY_FILES	int
;	O
break	O
;	O
case	O
'b'	O
:	O
out_byte	int
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
count_matches	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
directories	enum(int,int,int)
=	O
XARGMATCH	O
(	O
"--directories"	*(char)
,	O
optarg	*(char)
,	O
directories_args	array(*(char))
,	O
directories_types	array(enum(int,int,int))
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
cc	int
=	O
strlen	(*(char))->(long)
(	O
optarg	*(char)
)	O
;	O
keys	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
keys	*(char)
,	O
keycc	long
+	O
cc	int
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
&	O
keys	*(char)
[	O
keycc	long
]	O
,	O
optarg	*(char)
)	O
;	O
keycc	long
+=	O
cc	int
;	O
keys	*(char)
[	O
keycc	long
++	O
]	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
STREQ	O
(	O
optarg	*(char)
,	O
"-"	*(char)
)	O
?	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
:	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
optarg	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
!	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
optarg	*(char)
)	O
;	O
for	O
(	O
keyalloc	long
=	O
1	int
;	O
keyalloc	long
<=	O
keycc	long
+	O
1	int
;	O
keyalloc	long
*=	O
2	int
)	O
;	O
keys	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
keys	*(char)
,	O
keyalloc	long
)	O
;	O
oldcc	long
=	O
keycc	long
;	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
&&	O
(	O
cc	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
keys	*(char)
+	O
keycc	long
,	O
1	int
,	O
keyalloc	long
-	O
1	int
-	O
keycc	long
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
>	O
0	int
)	O
{	O
keycc	long
+=	O
cc	int
;	O
if	O
(	O
keycc	long
==	O
keyalloc	long
-	O
1	int
)	O
keys	*(char)
=	O
xrealloc	(*(void),long)->(*(void))
(	O
keys	*(char)
,	O
keyalloc	long
*=	O
2	int
)	O
;	O
}	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
oldcc	long
!=	O
keycc	long
&&	O
keys	*(char)
[	O
keycc	long
-	O
1	int
]	O
!=	O
'\n'	O
)	O
keys	*(char)
[	O
keycc	long
++	O
]	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
'h'	O
:	O
with_filenames	int
=	O
0	int
;	O
no_filenames	int
=	O
1	int
;	O
break	O
;	O
case	O
'i'	O
:	O
case	O
'y'	O
:	O
match_icase	int
=	O
1	int
;	O
break	O
;	O
case	O
'L'	O
:	O
list_files	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
list_files	int
=	O
1	int
;	O
break	O
;	O
case	O
'm'	O
:	O
{	O
uintmax_t	long
value	*(char)
;	O
switch	O
(	O
xstrtoumax	(*(char),*(*(char)),int,*(long),*(char))->(enum(int,int,int,int,int))
(	O
optarg	*(char)
,	O
0	int
,	O
10	int
,	O
&	O
value	*(char)
,	O
""	*(char)
)	O
)	O
{	O
case	O
LONGINT_OK	int
:	O
max_count	long
=	O
value	*(char)
;	O
if	O
(	O
0	int
<=	O
max_count	long
&&	O
max_count	long
==	O
value	*(char)
)	O
break	O
;	O
case	O
LONGINT_OVERFLOW	int
:	O
max_count	long
=	O
TYPE_MAXIMUM	O
(	O
off_t	long
)	O
;	O
break	O
;	O
default	O
:	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"invalid max count"	*(char)
)	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'n'	O
:	O
out_line	int
=	O
1	int
;	O
break	O
;	O
case	O
'o'	O
:	O
only_matching	int
=	O
1	int
;	O
break	O
;	O
case	O
'q'	O
:	O
exit_on_match	int
=	O
1	int
;	O
exit_failure	int
=	O
0	int
;	O
break	O
;	O
case	O
'R'	O
:	O
case	O
'r'	O
:	O
directories	enum(int,int,int)
=	O
RECURSE_DIRECTORIES	int
;	O
break	O
;	O
case	O
's'	O
:	O
suppress_errors	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
out_invert	int
=	O
1	int
;	O
break	O
;	O
case	O
'w'	O
:	O
match_words	int
=	O
1	int
;	O
break	O
;	O
case	O
'x'	O
:	O
match_lines	int
=	O
1	int
;	O
break	O
;	O
case	O
'Z'	O
:	O
filename_mask	int
=	O
0	int
;	O
break	O
;	O
case	O
'z'	O
:	O
eolbyte	char
=	O
'\0'	O
;	O
break	O
;	O
case	O
BINARY_FILES_OPTION	int
:	O
if	O
(	O
STREQ	O
(	O
optarg	*(char)
,	O
"binary"	*(char)
)	O
)	O
binary_files	enum(int,int,int)
=	O
BINARY_BINARY_FILES	int
;	O
else	O
if	O
(	O
STREQ	O
(	O
optarg	*(char)
,	O
"text"	*(char)
)	O
)	O
binary_files	enum(int,int,int)
=	O
TEXT_BINARY_FILES	int
;	O
else	O
if	O
(	O
STREQ	O
(	O
optarg	*(char)
,	O
"without-match"	*(char)
)	O
)	O
binary_files	enum(int,int,int)
=	O
WITHOUT_MATCH_BINARY_FILES	int
;	O
else	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
0	int
,	O
_	O
(	O
"unknown binary-files type"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
COLOR_OPTION	int
:	O
if	O
(	O
optarg	*(char)
)	O
{	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"always"	*(char)
)	O
||	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"yes"	*(char)
)	O
||	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"force"	*(char)
)	O
)	O
color_option	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"never"	*(char)
)	O
||	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"no"	*(char)
)	O
||	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"none"	*(char)
)	O
)	O
color_option	int
=	O
0	int
;	O
else	O
if	O
(	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"auto"	*(char)
)	O
||	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"tty"	*(char)
)	O
||	O
!	O
strcasecmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"if-tty"	*(char)
)	O
)	O
color_option	int
=	O
2	int
;	O
else	O
show_help	int
=	O
1	int
;	O
}	O
else	O
color_option	int
=	O
2	int
;	O
if	O
(	O
color_option	int
==	O
2	int
)	O
{	O
char	O
const	O
*	O
t	*(char)
;	O
if	O
(	O
isatty	(int)->(int)
(	O
STDOUT_FILENO	int
)	O
&&	O
(	O
t	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"TERM"	*(char)
)	O
)	O
&&	O
!	O
STREQ	O
(	O
t	*(char)
,	O
"dumb"	*(char)
)	O
)	O
color_option	int
=	O
1	int
;	O
else	O
color_option	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
EXCLUDE_OPTION	int
:	O
if	O
(	O
!	O
excluded_patterns	*(struct)
)	O
excluded_patterns	*(struct)
=	O
new_exclude	()->(*(struct))
(	O
)	O
;	O
add_exclude	(*(struct),*(char),int)->(void)
(	O
excluded_patterns	*(struct)
,	O
optarg	*(char)
,	O
EXCLUDE_WILDCARDS	O
)	O
;	O
break	O
;	O
case	O
EXCLUDE_FROM_OPTION	int
:	O
if	O
(	O
!	O
excluded_patterns	*(struct)
)	O
excluded_patterns	*(struct)
=	O
new_exclude	()->(*(struct))
(	O
)	O
;	O
if	O
(	O
add_exclude_file	(*((*(struct),*(char),int)->(void)),*(struct),*(char),int,char)->(int)
(	O
add_exclude	(*(struct),*(char),int)->(void)
,	O
excluded_patterns	*(struct)
,	O
optarg	*(char)
,	O
EXCLUDE_WILDCARDS	O
,	O
'\n'	O
)	O
!=	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_TROUBLE	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
optarg	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
EXCLUDE_DIRECTORY_OPTION	int
:	O
if	O
(	O
!	O
excluded_directory_patterns	*(struct)
)	O
excluded_directory_patterns	*(struct)
=	O
new_exclude	()->(*(struct))
(	O
)	O
;	O
add_exclude	(*(struct),*(char),int)->(void)
(	O
excluded_directory_patterns	*(struct)
,	O
optarg	*(char)
,	O
EXCLUDE_WILDCARDS	O
)	O
;	O
break	O
;	O
case	O
INCLUDE_OPTION	int
:	O
if	O
(	O
!	O
included_patterns	*(struct)
)	O
included_patterns	*(struct)
=	O
new_exclude	()->(*(struct))
(	O
)	O
;	O
add_exclude	(*(struct),*(char),int)->(void)
(	O
included_patterns	*(struct)
,	O
optarg	*(char)
,	O
EXCLUDE_WILDCARDS	O
|	O
EXCLUDE_INCLUDE	O
)	O
;	O
break	O
;	O
case	O
GROUP_SEPARATOR_OPTION	int
:	O
group_separator	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
LINE_BUFFERED_OPTION	int
:	O
line_buffered	int
=	O
1	int
;	O
break	O
;	O
case	O
LABEL_OPTION	int
:	O
label	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
MMAP_OPTION	int
:	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
usage	(int)->(void)
(	O
EXIT_TROUBLE	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
exit_on_match	int
)	O
list_files	int
=	O
0	int
;	O
if	O
(	O
exit_on_match	int
|	O
list_files	int
)	O
{	O
count_matches	int
=	O
0	int
;	O
done_on_match	int
=	O
1	int
;	O
}	O
out_quiet	int
=	O
count_matches	int
|	O
done_on_match	int
;	O
if	O
(	O
out_after	int
<	O
0	int
)	O
out_after	int
=	O
default_context	*(int)
;	O
if	O
(	O
out_before	int
<	O
0	int
)	O
out_before	int
=	O
default_context	*(int)
;	O
if	O
(	O
color_option	int
)	O
{	O
char	O
*	O
userval	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"GREP_COLOR"	*(char)
)	O
;	O
if	O
(	O
userval	*(char)
!=	O
NULL	O
&&	O
*	O
userval	*(char)
!=	O
'\0'	O
)	O
selected_match_color	*(char)
=	O
context_match_color	*(char)
=	O
userval	*(char)
;	O
parse_grep_colors	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
show_version	int
)	O
{	O
version_etc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),*(char))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
program_name	*(char)
,	O
PACKAGE_NAME	*(char)
,	O
VERSION	*(char)
,	O
AUTHORS	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
show_help	int
)	O
usage	(int)->(void)
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
keys	*(char)
)	O
{	O
if	O
(	O
keycc	long
==	O
0	int
)	O
{	O
out_invert	int
^=	O
1	int
;	O
match_lines	int
=	O
match_words	int
=	O
0	int
;	O
}	O
else	O
--	O
keycc	long
;	O
}	O
else	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
keycc	long
=	O
strlen	(*(char))->(long)
(	O
argv	*(*(char))
[	O
optind	int
]	O
)	O
;	O
keys	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
keycc	long
+	O
1	int
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
keys	*(char)
,	O
argv	*(*(char))
[	O
optind	int
++	O
]	O
)	O
;	O
}	O
else	O
usage	(int)->(void)
(	O
EXIT_TROUBLE	int
)	O
;	O
set_limits	()->(void)
(	O
)	O
;	O
compile	*((*(char),long)->(void))
(	O
keys	*(char)
,	O
keycc	long
)	O
;	O
free	(*(void))->(void)
(	O
keys	*(char)
)	O
;	O
if	O
(	O
(	O
argc	int
-	O
optind	int
>	O
1	int
&&	O
!	O
no_filenames	int
)	O
||	O
with_filenames	int
)	O
out_file	int
=	O
1	int
;	O
if	O
(	O
!	O
isatty	(int)->(int)
(	O
1	int
)	O
)	O
SET_BINARY	O
(	O
1	int
)	O
;	O
if	O
(	O
max_count	long
==	O
0	int
)	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
status	int
=	O
1	int
;	O
do	O
{	O
char	O
*	O
file	*(char)
=	O
argv	*(*(char))
[	O
optind	int
]	O
;	O
if	O
(	O
(	O
included_patterns	*(struct)
||	O
excluded_patterns	*(struct)
)	O
&&	O
!	O
isdir	(*(char))->(int)
(	O
file	*(char)
)	O
)	O
{	O
if	O
(	O
included_patterns	*(struct)
&&	O
excluded_file_name	(*(struct),*(char))->(bool)
(	O
included_patterns	*(struct)
,	O
file	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
excluded_patterns	*(struct)
&&	O
excluded_file_name	(*(struct),*(char))->(bool)
(	O
excluded_patterns	*(struct)
,	O
file	*(char)
)	O
)	O
continue	O
;	O
}	O
status	int
&=	O
grepfile	(*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
STREQ	O
(	O
file	*(char)
,	O
"-"	*(char)
)	O
?	O
(	O
char	O
*	O
)	O
NULL	O
:	O
file	*(char)
,	O
&	O
stats_base	struct(*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
}	O
while	O
(	O
++	O
optind	int
<	O
argc	int
)	O
;	O
}	O
else	O
status	int
=	O
grepfile	(*(char),*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))))->(int)
(	O
(	O
char	O
*	O
)	O
NULL	O
,	O
&	O
stats_base	struct(*(struct(*(struct(*`,struct`)),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))),struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
exit	(int)->(void)
(	O
errseen	int
?	O
EXIT_TROUBLE	int
:	O
status	int
)	O
;	O
}	O
