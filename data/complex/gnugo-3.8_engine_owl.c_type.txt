struct	O
local_owl_data	O
{	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
boundary	O
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
cumulative_goal	O
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
neighbors	int
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
escape_values	O
[	O
BOARDMAX	O
]	O
;	O
int	O
color	int
;	O
struct	O
eye_data	struct(int,int,int,int,struct(char,char,char,char),char,char,char)
my_eye	O
[	O
BOARDMAX	O
]	O
;	O
struct	O
half_eye_data	struct(float,char,int,array(int),int,array(int))
half_eye	array(struct(float,char,int,array(int),int,array(int)))
[	O
BOARDMAX	O
]	O
;	O
int	O
lunch	int
[	O
MAX_LUNCHES	O
]	O
;	O
int	O
lunch_attack_code	O
[	O
MAX_LUNCHES	O
]	O
;	O
int	O
lunch_attack_point	O
[	O
MAX_LUNCHES	O
]	O
;	O
int	O
lunch_defend_code	O
[	O
MAX_LUNCHES	O
]	O
;	O
int	O
lunch_defense_point	O
[	O
MAX_LUNCHES	O
]	O
;	O
signed	O
char	O
inessential	int
[	O
BOARDMAX	O
]	O
;	O
int	O
lunches_are_current	O
;	O
signed	O
char	O
safe_move_cache	O
[	O
BOARDMAX	O
]	O
;	O
struct	O
local_owl_data	O
*	O
restore_from	O
;	O
}	O
;	O
static	O
int	O
result_certain	O
;	O
static	O
int	O
local_owl_node_counter	O
;	O
static	O
int	O
global_owl_node_counter	O
=	O
0	int
;	O
static	O
struct	O
local_owl_data	O
*	O
current_owl_data	O
;	O
static	O
struct	O
local_owl_data	O
*	O
other_owl_data	O
;	O
static	O
int	O
goal_worms_computed	O
=	O
0	int
;	O
static	O
int	O
owl_goal_worm	O
[	O
MAX_GOAL_WORMS	O
]	O
;	O
enum	O
same_dragon_value	O
{	O
SAME_DRAGON_NOT_CONNECTED	O
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
SAME_DRAGON_CONNECTED	O
,	O
SAME_DRAGON_ALL_CONNECTED	O
}	O
;	O
struct	O
matched_pattern_data	O
;	O
struct	O
owl_move_data	O
{	O
int	O
pos	int
;	O
int	O
value	*(char)
;	O
const	O
char	O
*	O
name	short
;	O
enum	O
same_dragon_value	O
same_dragon	(int,int)->(int)
;	O
int	O
lunch	int
;	O
int	O
escape	O
;	O
int	O
defense_pos	O
;	O
int	O
cuts	O
[	O
MAX_CUTS	O
]	O
;	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
;	O
}	O
;	O
struct	O
matched_pattern_data	O
{	O
int	O
move	*(int)
;	O
int	O
value	*(char)
;	O
int	O
ll	O
;	O
int	O
anchor	int
;	O
int	O
bdist	O
;	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
;	O
int	O
next_pattern_index	O
;	O
}	O
;	O
struct	O
matched_patterns_list_data	O
{	O
int	O
initialized	O
;	O
int	O
counter	O
;	O
int	O
used	O
;	O
int	O
list_size	O
;	O
struct	O
matched_pattern_data	O
*	O
pattern_list	O
;	O
int	O
first_pattern_index	O
[	O
BOARDMAX	O
]	O
;	O
int	O
heap_num_patterns	O
;	O
struct	O
matched_pattern_data	O
*	O
*	O
pattern_heap	O
;	O
}	O
;	O
void	O
dump_pattern_list	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
;	O
static	O
int	O
do_owl_attack	O
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
*	O
wormid	O
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
escape	O
)	O
;	O
static	O
int	O
do_owl_defend	O
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
*	O
wormid	O
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
escape	O
)	O
;	O
static	O
void	O
owl_shapes	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
,	O
struct	O
owl_move_data	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
,	O
int	O
color	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
struct	O
pattern_db	O
*	O
type	char
)	O
;	O
static	O
void	O
collect_owl_shapes_callbacks	O
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
pattern_db	O
,	O
int	O
ll	O
,	O
void	O
*	O
data	*(void)
)	O
;	O
static	O
void	O
pattern_list_prepare	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
;	O
static	O
void	O
pattern_list_build_heap	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
;	O
static	O
void	O
pattern_list_pop_heap_once	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
;	O
static	O
void	O
pattern_list_sink_heap_top_element	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
;	O
static	O
int	O
get_next_move_from_list	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
,	O
int	O
color	int
,	O
struct	O
owl_move_data	O
*	O
moves	array(int)
,	O
int	O
cutoff	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
void	O
init_pattern_list	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
;	O
static	O
void	O
close_pattern_list	O
(	O
int	O
color	int
,	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
;	O
static	O
void	O
owl_shapes_callback	O
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
pattern_db	O
,	O
int	O
ll	O
,	O
void	O
*	O
data	*(void)
)	O
;	O
static	O
void	O
owl_add_move	O
(	O
struct	O
owl_move_data	O
*	O
moves	array(int)
,	O
int	O
move	*(int)
,	O
int	O
value	*(char)
,	O
const	O
char	O
*	O
reason	O
,	O
enum	O
same_dragon_value	O
same_dragon	(int,int)->(int)
,	O
int	O
lunch	int
,	O
int	O
escape	O
,	O
int	O
defense_pos	O
,	O
int	O
max_moves	O
,	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
)	O
;	O
static	O
void	O
owl_determine_life	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
struct	O
local_owl_data	O
*	O
second_owl	O
,	O
int	O
does_attack	(int,int)->(int)
,	O
struct	O
owl_move_data	O
*	O
moves	array(int)
,	O
struct	O
eyevalue	struct(char,char,char,char)
*	O
probable_eyes	O
,	O
int	O
*	O
eyemin	O
,	O
int	O
*	O
eyemax	O
)	O
;	O
static	O
void	O
owl_find_relevant_eyespaces	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
mw	O
[	O
BOARDMAX	O
]	O
,	O
int	O
mz	O
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
int	O
owl_estimate_life	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
struct	O
local_owl_data	O
*	O
second_owl	O
,	O
struct	O
owl_move_data	O
vital_moves	O
[	O
MAX_MOVES	O
]	O
,	O
const	O
char	O
*	O
*	O
live_reason	O
,	O
int	O
does_attack	(int,int)->(int)
,	O
struct	O
eyevalue	struct(char,char,char,char)
*	O
probable_eyes	O
,	O
int	O
*	O
eyemin	O
,	O
int	O
*	O
eyemax	O
)	O
;	O
static	O
int	O
modify_stupid_eye_vital_point	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
*	O
vital_point	O
,	O
int	O
is_attack_point	O
)	O
;	O
static	O
int	O
modify_eyefilling_move	O
(	O
int	O
*	O
move	*(int)
,	O
int	O
color	int
)	O
;	O
static	O
int	O
estimate_lunch_half_eye_bonus	O
(	O
int	O
lunch	int
,	O
struct	O
half_eye_data	struct(float,char,int,array(int),int,array(int))
half_eye	array(struct(float,char,int,array(int),int,array(int)))
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
owl_mark_dragon	O
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
new_dragons	O
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
owl_mark_worm	O
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
void	O
owl_mark_boundary	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
void	O
owl_update_goal	O
(	O
int	O
pos	int
,	O
enum	O
same_dragon_value	O
same_dragon	(int,int)->(int)
,	O
int	O
lunch	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
semeai_call	O
,	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
)	O
;	O
static	O
void	O
owl_test_cuts	O
(	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
color	int
,	O
int	O
cuts	O
[	O
MAX_CUTS	O
]	O
)	O
;	O
static	O
void	O
componentdump	O
(	O
const	O
signed	O
char	O
component	O
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
void	O
owl_update_boundary_marks	O
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
void	O
owl_find_lunches	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
int	O
improve_lunch_attack	O
(	O
int	O
lunch	int
,	O
int	O
attack_point	*(int)
)	O
;	O
static	O
int	O
improve_lunch_defense	O
(	O
int	O
lunch	int
,	O
int	O
defense_point	*(int)
)	O
;	O
static	O
void	O
owl_make_domains	O
(	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
)	O
;	O
static	O
int	O
owl_safe_move	O
(	O
int	O
move	*(int)
,	O
int	O
color	int
)	O
;	O
static	O
void	O
sniff_lunch	O
(	O
int	O
lunch	int
,	O
int	O
*	O
min	*(int)
,	O
int	O
*	O
probable	*(int)
,	O
int	O
*	O
max	*(int)
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
void	O
eat_lunch_escape_bonus	O
(	O
int	O
lunch	int
,	O
int	O
*	O
min	*(int)
,	O
int	O
*	O
probable	*(int)
,	O
int	O
*	O
max	*(int)
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
int	O
select_new_goal_origin	O
(	O
int	O
origin	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
void	O
compute_owl_escape_values	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
int	O
owl_escape_route	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
void	O
do_owl_analyze_semeai	O
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
,	O
int	O
*	O
resulta	*(int)
,	O
int	O
*	O
resultb	*(int)
,	O
int	O
*	O
move	*(int)
,	O
int	O
pass	O
,	O
int	O
owl_phase	O
)	O
;	O
static	O
int	O
semeai_trymove_and_recurse	O
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
,	O
int	O
owl_phase	O
,	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
int	O
ko_allowed	O
,	O
int	O
move_value	*(float)
,	O
const	O
char	O
*	O
move_name	O
,	O
enum	O
same_dragon_value	O
same_dragon	(int,int)->(int)
,	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
,	O
int	O
lunch	int
,	O
int	O
*	O
semeai_move	*(int)
,	O
int	O
*	O
this_resulta	O
,	O
int	O
*	O
this_resultb	O
)	O
;	O
static	O
void	O
semeai_add_sgf_comment	O
(	O
int	O
value	*(char)
,	O
int	O
owl_phase	O
)	O
;	O
static	O
int	O
semeai_trust_tactical_attack	O
(	O
int	O
str	int
)	O
;	O
static	O
int	O
semeai_propose_eyespace_filling_move	O
(	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
)	O
;	O
static	O
void	O
semeai_review_owl_moves	O
(	O
struct	O
owl_move_data	O
owl_moves	O
[	O
MAX_MOVES	O
]	O
,	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
,	O
int	O
color	int
,	O
int	O
*	O
safe_outside_liberty_found	O
,	O
int	O
*	O
safe_common_liberty_found	O
,	O
int	O
*	O
riskless_move_found	O
,	O
signed	O
char	O
mw	O
[	O
BOARDMAX	O
]	O
,	O
struct	O
owl_move_data	O
semeai_moves	O
[	O
MAX_SEMEAI_MOVES	O
]	O
,	O
int	O
guess_same_dragon	O
,	O
int	O
value_bonus	O
,	O
int	O
*	O
critical_semeai_worms	O
)	O
;	O
static	O
int	O
semeai_move_value	O
(	O
int	O
move	*(int)
,	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
,	O
int	O
raw_value	O
,	O
int	O
*	O
critical_semeai_worms	O
)	O
;	O
static	O
int	O
semeai_is_riskless_move	O
(	O
int	O
move	*(int)
,	O
struct	O
local_owl_data	O
*	O
owla	O
)	O
;	O
static	O
void	O
remove_eye_filling_moves	O
(	O
struct	O
local_owl_data	O
*	O
our_owl	O
,	O
struct	O
owl_move_data	O
*	O
moves	array(int)
)	O
;	O
static	O
int	O
find_semeai_backfilling_move	O
(	O
int	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
,	O
int	O
liberty	O
)	O
;	O
static	O
int	O
liberty_of_goal	O
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
int	O
second_liberty_of_goal	O
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
;	O
static	O
int	O
matches_found	O
;	O
static	O
signed	O
char	O
found_matches	O
[	O
BOARDMAX	O
]	O
;	O
static	O
void	O
reduced_init_owl	O
(	O
struct	O
local_owl_data	O
*	O
*	O
owl	int
,	O
int	O
at_bottom_of_stack	O
)	O
;	O
static	O
void	O
init_owl	O
(	O
struct	O
local_owl_data	O
*	O
*	O
owl	int
,	O
int	O
target1	int
,	O
int	O
target2	int
,	O
int	O
move	*(int)
,	O
int	O
use_stack	O
,	O
int	O
new_dragons	O
[	O
BOARDMAX	O
]	O
)	O
;	O
static	O
struct	O
local_owl_data	O
*	O
owl_stack	O
[	O
2	int
*	O
MAXSTACK	O
]	O
;	O
static	O
int	O
owl_stack_size	O
=	O
0	int
;	O
static	O
int	O
owl_stack_pointer	O
=	O
0	int
;	O
static	O
void	O
check_owl_stack_size	O
(	O
void	O
)	O
;	O
static	O
void	O
push_owl	O
(	O
struct	O
local_owl_data	O
*	O
*	O
owl	int
)	O
;	O
static	O
void	O
do_push_owl	O
(	O
struct	O
local_owl_data	O
*	O
*	O
owl	int
)	O
;	O
static	O
void	O
pop_owl	O
(	O
struct	O
local_owl_data	O
*	O
*	O
owl	int
)	O
;	O
static	O
int	O
list_goal_worms	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
goal_worm	O
[	O
MAX_GOAL_WORMS	O
]	O
)	O
;	O
static	O
int	O
dragon_goal_worms	O
[	O
MAX_DRAGONS	O
]	O
[	O
MAX_GOAL_WORMS	O
]	O
;	O
static	O
void	O
prepare_goal_list	O
(	O
int	O
str	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
list	O
[	O
MAX_GOAL_WORMS	O
]	O
,	O
int	O
*	O
flag	O
,	O
int	O
*	O
kworm	int
,	O
int	O
do_list	O
)	O
;	O
static	O
void	O
finish_goal_list	O
(	O
int	O
*	O
flag	O
,	O
int	O
*	O
wpos	O
,	O
int	O
list	O
[	O
MAX_GOAL_WORMS	O
]	O
,	O
int	O
index	(*(char),int)->(*(char))
)	O
;	O
static	O
int	O
s_worms	O
=	O
0	int
;	O
static	O
int	O
semeai_worms	O
[	O
MAX_SEMEAI_WORMS	O
]	O
;	O
static	O
int	O
important_semeai_worms	O
[	O
MAX_SEMEAI_WORMS	O
]	O
;	O
static	O
int	O
prefer_ko	O
;	O
static	O
int	O
include_semeai_worms_in_eyespace	O
=	O
0	int
;	O
static	O
void	O
clear_cut_list	O
(	O
int	O
cuts	O
[	O
MAX_CUTS	O
]	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_CUTS	O
;	O
i	int
++	O
)	O
cuts	O
[	O
i	int
]	O
=	O
NO_MOVE	O
;	O
}	O
void	O
owl_analyze_semeai	(int,int,*(int),*(int),*(int),int,*(int))->(void)
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
*	O
resulta	*(int)
,	O
int	O
*	O
resultb	*(int)
,	O
int	O
*	O
semeai_move	*(int)
,	O
int	O
owl	int
,	O
int	O
*	O
semeai_result_certain	*(int)
)	O
{	O
owl_analyze_semeai_after_move	(int,int,int,int,*(int),*(int),*(int),int,*(int),int)->(void)
(	O
PASS_MOVE	O
,	O
EMPTY	int
,	O
apos	int
,	O
bpos	int
,	O
resulta	*(int)
,	O
resultb	*(int)
,	O
semeai_move	*(int)
,	O
owl	int
,	O
semeai_result_certain	*(int)
,	O
0	int
)	O
;	O
}	O
void	O
owl_analyze_semeai_after_move	(int,int,int,int,*(int),*(int),*(int),int,*(int),int)->(void)
(	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
*	O
resulta	*(int)
,	O
int	O
*	O
resultb	*(int)
,	O
int	O
*	O
semeai_move	*(int)
,	O
int	O
owl	int
,	O
int	O
*	O
semeai_result_certain	*(int)
,	O
int	O
recompute_dragons	int
)	O
{	O
signed	O
char	O
ms	O
[	O
BOARDMAX	O
]	O
;	O
int	O
w1	int
,	O
w2	int
;	O
int	O
str	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
int	O
dummy_resulta	O
;	O
int	O
dummy_resultb	O
;	O
int	O
dummy_semeai_move	O
;	O
double	O
start	O
=	O
0.0	int
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
int	O
nodes_used	O
;	O
int	O
new_dragons	O
[	O
BOARDMAX	O
]	O
;	O
struct	O
local_owl_data	O
*	O
owla	O
;	O
struct	O
local_owl_data	O
*	O
owlb	O
;	O
Hash_data	struct(array(long))
goal_hash	*(struct(array(long)))
;	O
if	O
(	O
!	O
resulta	*(int)
)	O
resulta	*(int)
=	O
&	O
dummy_resulta	O
;	O
if	O
(	O
!	O
resultb	*(int)
)	O
resultb	*(int)
=	O
&	O
dummy_resultb	O
;	O
if	O
(	O
!	O
semeai_move	*(int)
)	O
semeai_move	*(int)
=	O
&	O
dummy_semeai_move	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	O
)	O
start	O
=	O
gg_cputime	O
(	O
)	O
;	O
if	O
(	O
recompute_dragons	int
)	O
{	O
if	O
(	O
tryko	(int,int,*(char))->(int)
(	O
move	*(int)
,	O
color	int
,	O
"Recompute dragons for semeai."	*(char)
)	O
)	O
{	O
compute_new_dragons	(array(int))->(void)
(	O
new_dragons	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
recompute_dragons	int
=	O
0	int
;	O
}	O
s_worms	O
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
ms	O
,	O
0	int
,	O
sizeof	O
(	O
ms	O
)	O
)	O
;	O
for	O
(	O
w1	int
=	O
first_worm_in_dragon	(int)->(int)
(	O
apos	int
)	O
;	O
w1	int
!=	O
NO_MOVE	O
;	O
w1	int
=	O
next_worm_in_dragon	(int)->(int)
(	O
w1	int
)	O
)	O
{	O
for	O
(	O
w2	int
=	O
first_worm_in_dragon	(int)->(int)
(	O
bpos	int
)	O
;	O
w2	int
!=	O
NO_MOVE	O
;	O
w2	int
=	O
next_worm_in_dragon	(int)->(int)
(	O
w2	int
)	O
)	O
{	O
if	O
(	O
adjacent_strings	(int,int)->(int)
(	O
w1	int
,	O
w2	int
)	O
||	O
have_common_lib	(int,int,*(int))->(int)
(	O
w1	int
,	O
w2	int
,	O
NULL	O
)	O
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
w1	int
,	O
ms	O
,	O
1	int
)	O
;	O
mark_string	(int,array(char),char)->(void)
(	O
w2	int
,	O
ms	O
,	O
1	int
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
&&	O
ms	O
[	O
str	int
]	O
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
str	int
]	O
.	O
origin	int
==	O
str	int
)	O
{	O
int	O
adj	array(int)
;	O
int	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
k	int
;	O
int	O
adjacent_to_outside	O
=	O
0	int
;	O
adj	array(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
str	int
,	O
adjs	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj	array(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
is_same_dragon	(int,int)->(int)
(	O
adjs	O
[	O
k	int
]	O
,	O
apos	int
)	O
&&	O
!	O
is_same_dragon	(int,int)->(int)
(	O
adjs	O
[	O
k	int
]	O
,	O
bpos	int
)	O
&&	O
dragon	int
[	O
adjs	O
[	O
k	int
]	O
]	O
.	O
crude_status	(int)->(enum)
==	O
ALIVE	int
)	O
adjacent_to_outside	O
=	O
1	int
;	O
}	O
if	O
(	O
(	O
adjacent_to_outside	O
||	O
countstones	(int)->(int)
(	O
str	int
)	O
>	O
6	int
)	O
&&	O
s_worms	O
<	O
MAX_SEMEAI_WORMS	O
)	O
{	O
important_semeai_worms	O
[	O
s_worms	O
]	O
=	O
1	int
;	O
semeai_worms	O
[	O
s_worms	O
++	O
]	O
=	O
str	int
;	O
DEBUG	O
(	O
DEBUG_SEMEAI	O
,	O
"important semeai worm: %1m\n"	*(char)
,	O
str	int
)	O
;	O
}	O
else	O
if	O
(	O
owl_substantial	(int)->(int)
(	O
str	int
)	O
&&	O
s_worms	O
<	O
MAX_SEMEAI_WORMS	O
)	O
{	O
important_semeai_worms	O
[	O
s_worms	O
]	O
=	O
0	int
;	O
semeai_worms	O
[	O
s_worms	O
++	O
]	O
=	O
str	int
;	O
DEBUG	O
(	O
DEBUG_SEMEAI	O
,	O
"semeai worm: %1m\n"	*(char)
,	O
str	int
)	O
;	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
bpos	int
]	O
)	O
,	O
apos	int
)	O
;	O
count_variations	int
=	O
1	int
;	O
if	O
(	O
move	*(int)
==	O
PASS_MOVE	O
)	O
DEBUG	O
(	O
DEBUG_SEMEAI	O
,	O
"owl_analyze_semeai: %1m vs. %1m\n"	*(char)
,	O
apos	int
,	O
bpos	int
)	O
;	O
else	O
DEBUG	O
(	O
DEBUG_SEMEAI	O
,	O
"owl_analyze_semeai_after_move %C %1m: %1m vs. %1m\n"	*(char)
,	O
color	int
,	O
move	*(int)
,	O
apos	int
,	O
bpos	int
)	O
;	O
if	O
(	O
owl	int
)	O
{	O
if	O
(	O
recompute_dragons	int
)	O
{	O
init_owl	O
(	O
&	O
owla	O
,	O
apos	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
new_dragons	O
)	O
;	O
init_owl	O
(	O
&	O
owlb	O
,	O
bpos	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
0	int
,	O
new_dragons	O
)	O
;	O
}	O
else	O
{	O
init_owl	O
(	O
&	O
owla	O
,	O
apos	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
init_owl	O
(	O
&	O
owlb	O
,	O
bpos	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NULL	O
)	O
;	O
}	O
owl_make_domains	O
(	O
owla	O
,	O
owlb	O
)	O
;	O
}	O
else	O
{	O
reduced_init_owl	O
(	O
&	O
owla	O
,	O
1	int
)	O
;	O
reduced_init_owl	O
(	O
&	O
owlb	O
,	O
0	int
)	O
;	O
local_owl_node_counter	O
=	O
0	int
;	O
owl_mark_worm	O
(	O
apos	int
,	O
NO_MOVE	O
,	O
owla	O
)	O
;	O
owl_mark_worm	O
(	O
bpos	int
,	O
NO_MOVE	O
,	O
owlb	O
)	O
;	O
}	O
result_certain	O
=	O
1	int
;	O
{	O
Hash_data	struct(array(long))
temp	O
=	O
goal_to_hashvalue	(*(char))->(struct(array(long)))
(	O
owla	O
->	O
goal	*(char)
)	O
;	O
goal_hash	*(struct(array(long)))
=	O
goal_to_hashvalue	(*(char))->(struct(array(long)))
(	O
owlb	O
->	O
goal	*(char)
)	O
;	O
hashdata_xor	O
(	O
goal_hash	*(struct(array(long)))
,	O
temp	O
)	O
;	O
}	O
if	O
(	O
owl	int
&&	O
search_persistent_semeai_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),*(int),*(int),*(int),*(int))->(int)
(	O
ANALYZE_SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
move	*(int)
,	O
color	int
,	O
&	O
goal_hash	*(struct(array(long)))
,	O
resulta	*(int)
,	O
resultb	*(int)
,	O
semeai_move	*(int)
,	O
semeai_result_certain	*(int)
)	O
)	O
{	O
if	O
(	O
move	*(int)
==	O
PASS_MOVE	O
)	O
{	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"analyze_semeai %1m vs. %1m, result %d %d %1m (cached)\n"	*(char)
,	O
apos	int
,	O
bpos	int
,	O
*	O
resulta	*(int)
,	O
*	O
resultb	*(int)
,	O
*	O
semeai_move	*(int)
)	O
;	O
}	O
else	O
{	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"analyze_semeai_after_move %C %1m: %1m vs. %1m, result %d %d %1m (cached)\n"	*(char)
,	O
color	int
,	O
move	*(int)
,	O
apos	int
,	O
bpos	int
,	O
*	O
resulta	*(int)
,	O
*	O
resultb	*(int)
,	O
*	O
semeai_move	*(int)
)	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
dragon	int
[	O
apos	int
]	O
.	O
size	int
<=	O
5	int
&&	O
dragon	int
[	O
bpos	int
]	O
.	O
size	int
>	O
3	int
*	O
dragon	int
[	O
apos	int
]	O
.	O
size	int
)	O
prefer_ko	O
=	O
board	*(char)
[	O
apos	int
]	O
;	O
else	O
if	O
(	O
dragon	int
[	O
bpos	int
]	O
.	O
size	int
<=	O
5	int
&&	O
dragon	int
[	O
apos	int
]	O
.	O
size	int
>	O
3	int
*	O
dragon	int
[	O
bpos	int
]	O
.	O
size	int
)	O
prefer_ko	O
=	O
board	*(char)
[	O
bpos	int
]	O
;	O
else	O
prefer_ko	O
=	O
EMPTY	int
;	O
if	O
(	O
move	*(int)
==	O
PASS_MOVE	O
)	O
do_owl_analyze_semeai	O
(	O
apos	int
,	O
bpos	int
,	O
owla	O
,	O
owlb	O
,	O
resulta	*(int)
,	O
resultb	*(int)
,	O
semeai_move	*(int)
,	O
0	int
,	O
owl	int
)	O
;	O
else	O
{	O
semeai_trymove_and_recurse	O
(	O
bpos	int
,	O
apos	int
,	O
owlb	O
,	O
owla	O
,	O
owl	int
,	O
move	*(int)
,	O
color	int
,	O
1	int
,	O
0	int
,	O
"mandatory move"	*(char)
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
NULL	O
,	O
NO_MOVE	O
,	O
semeai_move	*(int)
,	O
resultb	*(int)
,	O
resulta	*(int)
)	O
;	O
*	O
resulta	*(int)
=	O
REVERSE_RESULT	O
(	O
*	O
resulta	*(int)
)	O
;	O
*	O
resultb	*(int)
=	O
REVERSE_RESULT	O
(	O
*	O
resultb	*(int)
)	O
;	O
}	O
nodes_used	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
if	O
(	O
move	*(int)
==	O
PASS_MOVE	O
)	O
{	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"analyze_semeai %1m vs. %1m, result %d %d %1m (%d, %d nodes, %f seconds)\n"	*(char)
,	O
apos	int
,	O
bpos	int
,	O
*	O
resulta	*(int)
,	O
*	O
resultb	*(int)
,	O
*	O
semeai_move	*(int)
,	O
local_owl_node_counter	O
,	O
nodes_used	O
,	O
gg_cputime	O
(	O
)	O
-	O
start	O
)	O
;	O
}	O
else	O
{	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"analyze_semeai_after_move %C %1m: %1m vs. %1m, result %d %d %1m (%d, %d nodes, %f seconds)\n"	*(char)
,	O
color	int
,	O
move	*(int)
,	O
apos	int
,	O
bpos	int
,	O
*	O
resulta	*(int)
,	O
*	O
resultb	*(int)
,	O
*	O
semeai_move	*(int)
,	O
local_owl_node_counter	O
,	O
nodes_used	O
,	O
gg_cputime	O
(	O
)	O
-	O
start	O
)	O
;	O
}	O
if	O
(	O
semeai_result_certain	*(int)
)	O
*	O
semeai_result_certain	*(int)
=	O
result_certain	O
;	O
if	O
(	O
owl	int
)	O
store_persistent_semeai_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,*(struct(array(long))),int,int,int,int,int,array(char),array(char))->(void)
(	O
ANALYZE_SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
move	*(int)
,	O
color	int
,	O
&	O
goal_hash	*(struct(array(long)))
,	O
*	O
resulta	*(int)
,	O
*	O
resultb	*(int)
,	O
*	O
semeai_move	*(int)
,	O
result_certain	O
,	O
nodes_used	O
,	O
owla	O
->	O
goal	*(char)
,	O
owlb	O
->	O
goal	*(char)
)	O
;	O
}	O
static	O
void	O
do_owl_analyze_semeai	O
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
,	O
int	O
*	O
resulta	*(int)
,	O
int	O
*	O
resultb	*(int)
,	O
int	O
*	O
move	*(int)
,	O
int	O
pass	O
,	O
int	O
owl_phase	O
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
apos	int
]	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
struct	O
owl_move_data	O
vital_defensive_moves	O
[	O
MAX_MOVES	O
]	O
;	O
struct	O
owl_move_data	O
vital_offensive_moves	O
[	O
MAX_MOVES	O
]	O
;	O
struct	O
owl_move_data	O
shape_defensive_moves	O
[	O
MAX_MOVES	O
]	O
;	O
struct	O
owl_move_data	O
shape_offensive_moves	O
[	O
MAX_MOVES	O
]	O
;	O
struct	O
matched_patterns_list_data	O
shape_offensive_patterns	O
;	O
struct	O
matched_patterns_list_data	O
shape_defensive_patterns	O
;	O
struct	O
owl_move_data	O
moves	array(int)
[	O
MAX_SEMEAI_MOVES	O
]	O
;	O
struct	O
owl_move_data	O
outside_liberty	O
;	O
struct	O
owl_move_data	O
common_liberty	O
;	O
struct	O
owl_move_data	O
backfill_outside_liberty	O
;	O
struct	O
owl_move_data	O
backfill_common_liberty	O
;	O
int	O
safe_outside_liberty_found	O
=	O
0	int
;	O
int	O
safe_common_liberty_found	O
=	O
0	int
;	O
int	O
riskless_move_found	O
=	O
0	int
;	O
signed	O
char	O
mw	O
[	O
BOARDMAX	O
]	O
;	O
int	O
k	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
int	O
move_value	*(float)
;	O
int	O
best_resulta	O
=	O
0	int
;	O
int	O
best_resultb	O
=	O
0	int
;	O
int	O
best_move	O
=	O
0	int
;	O
const	O
char	O
*	O
best_move_name	O
=	O
NULL	O
;	O
int	O
this_resulta	O
=	O
-	O
1	int
;	O
int	O
this_resultb	O
=	O
-	O
1	int
;	O
int	O
xpos	O
;	O
int	O
value1	O
;	O
int	O
value2	O
;	O
int	O
this_variation_number	O
=	O
count_variations	int
-	O
1	int
;	O
int	O
you_look_alive	O
=	O
0	int
;	O
int	O
I_look_alive	O
=	O
0	int
;	O
int	O
dummy_move	O
;	O
int	O
tested_moves	O
;	O
int	O
critical_semeai_worms	O
[	O
MAX_SEMEAI_WORMS	O
]	O
;	O
int	O
sworm	O
;	O
int	O
we_might_be_inessential	O
;	O
struct	O
eyevalue	struct(char,char,char,char)
probable_eyes_a	O
;	O
struct	O
eyevalue	struct(char,char,char,char)
probable_eyes_b	O
;	O
struct	O
eyevalue	struct(char,char,char,char)
dummy_eyes	O
;	O
int	O
I_have_more_eyes	O
;	O
SETUP_TRACE_INFO2	O
(	O
"do_owl_analyze_semeai"	*(char)
,	O
apos	int
,	O
bpos	int
)	O
;	O
if	O
(	O
!	O
move	*(int)
)	O
move	*(int)
=	O
&	O
dummy_move	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
owla	O
->	O
color	int
,	O
apos	int
)	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
owlb	O
->	O
color	int
,	O
bpos	int
)	O
;	O
apos	int
=	O
find_origin	(int)->(int)
(	O
apos	int
)	O
;	O
bpos	int
=	O
find_origin	(int)->(int)
(	O
bpos	int
)	O
;	O
if	O
(	O
stackp	int
<=	O
semeai_branch_depth	int
&&	O
owl_phase	O
&&	O
tt_get	O
(	O
&	O
ttable	O
,	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
value1	O
,	O
&	O
value2	O
,	O
&	O
xpos	O
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT2	O
(	O
value1	O
,	O
value2	O
,	O
xpos	O
)	O
;	O
*	O
move	*(int)
=	O
xpos	O
;	O
*	O
resulta	*(int)
=	O
value1	O
;	O
*	O
resultb	*(int)
=	O
value2	O
;	O
TRACE	O
(	O
"%oVariation %d: %1m %1m %s %s %1m (cached) "	*(char)
,	O
this_variation_number	O
,	O
apos	int
,	O
bpos	int
,	O
result_to_string	(int)->(*(char))
(	O
*	O
resulta	*(int)
)	O
,	O
result_to_string	(int)->(*(char))
(	O
*	O
resultb	*(int)
)	O
,	O
*	O
move	*(int)
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
xpos	O
,	O
*	O
resulta	*(int)
,	O
*	O
resultb	*(int)
,	O
"cached"	*(char)
)	O
;	O
return	O
;	O
}	O
global_owl_node_counter	O
++	O
;	O
local_owl_node_counter	O
++	O
;	O
shape_offensive_patterns	O
.	O
initialized	O
=	O
0	int
;	O
shape_defensive_patterns	O
.	O
initialized	O
=	O
0	int
;	O
outside_liberty	O
.	O
pos	int
=	O
NO_MOVE	O
;	O
common_liberty	O
.	O
pos	int
=	O
NO_MOVE	O
;	O
backfill_outside_liberty	O
.	O
pos	int
=	O
NO_MOVE	O
;	O
backfill_common_liberty	O
.	O
pos	int
=	O
NO_MOVE	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_SEMEAI_MOVES	O
;	O
k	int
++	O
)	O
{	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
=	O
0	int
;	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
=	O
-	O
1	int
;	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
=	O
NULL	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_CONNECTED	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
lunch	int
=	O
NO_MOVE	O
;	O
clear_cut_list	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
cuts	O
)	O
;	O
}	O
ASSERT1	O
(	O
other	O
==	O
board	*(char)
[	O
bpos	int
]	O
,	O
bpos	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mw	O
,	O
0	int
,	O
sizeof	O
(	O
mw	O
)	O
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
{	O
int	O
upos	O
;	O
for	O
(	O
sworm	O
=	O
0	int
;	O
sworm	O
<	O
s_worms	O
;	O
sworm	O
++	O
)	O
{	O
critical_semeai_worms	O
[	O
sworm	O
]	O
=	O
0	int
;	O
if	O
(	O
board	*(char)
[	O
semeai_worms	O
[	O
sworm	O
]	O
]	O
==	O
other	O
)	O
{	O
int	O
acode	int
=	O
attack	(int,*(int))->(int)
(	O
semeai_worms	O
[	O
sworm	O
]	O
,	O
&	O
upos	O
)	O
;	O
if	O
(	O
acode	int
==	O
WIN	O
&&	O
semeai_trust_tactical_attack	O
(	O
semeai_worms	O
[	O
sworm	O
]	O
)	O
&&	O
important_semeai_worms	O
[	O
sworm	O
]	O
)	O
{	O
*	O
resulta	*(int)
=	O
WIN	O
;	O
*	O
resultb	*(int)
=	O
WIN	O
;	O
*	O
move	*(int)
=	O
upos	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
SGFTRACE_SEMEAI	O
(	O
upos	O
,	O
WIN	O
,	O
WIN	O
,	O
"tactical win found"	*(char)
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
upos	O
,	O
WIN	O
,	O
WIN	O
)	O
;	O
}	O
else	O
if	O
(	O
acode	int
!=	O
0	int
&&	O
find_defense	(int,*(int))->(int)
(	O
semeai_worms	O
[	O
sworm	O
]	O
,	O
NULL	O
)	O
)	O
{	O
critical_semeai_worms	O
[	O
sworm	O
]	O
=	O
1	int
;	O
owl_add_move	O
(	O
moves	array(int)
,	O
upos	O
,	O
105	int
,	O
"attack semeai worm"	*(char)
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	O
,	O
NULL	O
)	O
;	O
TRACE	O
(	O
"Added %1m %d (-1)\n"	*(char)
,	O
upos	O
,	O
105	int
)	O
;	O
}	O
else	O
if	O
(	O
acode	int
==	O
WIN	O
&&	O
important_semeai_worms	O
[	O
sworm	O
]	O
)	O
{	O
owl_add_move	O
(	O
moves	array(int)
,	O
upos	O
,	O
100	int
,	O
"attack semeai worm"	*(char)
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	O
,	O
NULL	O
)	O
;	O
TRACE	O
(	O
"Added %1m %d (-1)\n"	*(char)
,	O
upos	O
,	O
100	int
)	O
;	O
}	O
}	O
}	O
we_might_be_inessential	O
=	O
1	int
;	O
for	O
(	O
sworm	O
=	O
0	int
;	O
sworm	O
<	O
s_worms	O
;	O
sworm	O
++	O
)	O
if	O
(	O
board	*(char)
[	O
semeai_worms	O
[	O
sworm	O
]	O
]	O
==	O
color	int
)	O
{	O
if	O
(	O
important_semeai_worms	O
[	O
sworm	O
]	O
)	O
we_might_be_inessential	O
=	O
0	int
;	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
semeai_worms	O
[	O
sworm	O
]	O
,	O
NULL	O
)	O
&&	O
find_defense	(int,*(int))->(int)
(	O
semeai_worms	O
[	O
sworm	O
]	O
,	O
&	O
upos	O
)	O
)	O
{	O
critical_semeai_worms	O
[	O
sworm	O
]	O
=	O
1	int
;	O
owl_add_move	O
(	O
moves	array(int)
,	O
upos	O
,	O
85	int
,	O
"defend semeai worm"	*(char)
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	O
,	O
NULL	O
)	O
;	O
TRACE	O
(	O
"Added %1m %d (0)\n"	*(char)
,	O
upos	O
,	O
85	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
owl_phase	O
)	O
{	O
set_eyevalue	(*(struct(char,char,char,char)),int,int,int,int)->(void)
(	O
&	O
probable_eyes_a	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
set_eyevalue	(*(struct(char,char,char,char)),int,int,int,int)->(void)
(	O
&	O
probable_eyes_b	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
I_have_more_eyes	O
=	O
0	int
;	O
}	O
else	O
{	O
int	O
eyemin_a	O
;	O
int	O
eyemin_b	O
;	O
int	O
eyemax_a	O
;	O
int	O
eyemax_b	O
;	O
const	O
char	O
*	O
live_reasona	O
;	O
const	O
char	O
*	O
live_reasonb	O
;	O
owl_find_lunches	O
(	O
owla	O
)	O
;	O
owl_find_lunches	O
(	O
owlb	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_LUNCHES	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
owla	O
->	O
lunch	int
[	O
k	int
]	O
!=	O
NO_MOVE	O
&&	O
owlb	O
->	O
goal	*(char)
[	O
owla	O
->	O
lunch	int
[	O
k	int
]	O
]	O
)	O
{	O
owla	O
->	O
lunch	int
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_LUNCHES	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
owlb	O
->	O
lunch	int
[	O
k	int
]	O
!=	O
NO_MOVE	O
&&	O
owla	O
->	O
goal	*(char)
[	O
owlb	O
->	O
lunch	int
[	O
k	int
]	O
]	O
)	O
{	O
owlb	O
->	O
lunch	int
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
}	O
}	O
if	O
(	O
owl_estimate_life	O
(	O
owla	O
,	O
owlb	O
,	O
vital_defensive_moves	O
,	O
&	O
live_reasona	O
,	O
0	int
,	O
&	O
probable_eyes_a	O
,	O
&	O
eyemin_a	O
,	O
&	O
eyemax_a	O
)	O
)	O
I_look_alive	O
=	O
1	int
;	O
else	O
if	O
(	O
stackp	int
>	O
2	int
&&	O
owl_escape_route	O
(	O
owla	O
)	O
>=	O
5	int
)	O
{	O
live_reasona	O
=	O
"escaped"	*(char)
;	O
I_look_alive	O
=	O
1	int
;	O
}	O
if	O
(	O
owl_estimate_life	O
(	O
owlb	O
,	O
owla	O
,	O
vital_offensive_moves	O
,	O
&	O
live_reasonb	O
,	O
1	int
,	O
&	O
probable_eyes_b	O
,	O
&	O
eyemin_b	O
,	O
&	O
eyemax_b	O
)	O
)	O
you_look_alive	O
=	O
1	int
;	O
else	O
if	O
(	O
stackp	int
>	O
2	int
&&	O
owl_escape_route	O
(	O
owlb	O
)	O
>=	O
5	int
)	O
{	O
live_reasonb	O
=	O
"escaped"	*(char)
;	O
you_look_alive	O
=	O
1	int
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
gprintf	(*(char))->(int)
(	O
"probable_eyes_a: %s eyemin: %d eyemax: %d"	*(char)
,	O
eyevalue_to_string	(*(struct(char,char,char,char)))->(*(char))
(	O
&	O
probable_eyes_a	O
)	O
,	O
eyemin_a	O
,	O
eyemax_a	O
)	O
;	O
if	O
(	O
I_look_alive	O
)	O
gprintf	(*(char))->(int)
(	O
"%o I look alive (%s)"	*(char)
,	O
live_reasona	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%o\n"	*(char)
)	O
;	O
gprintf	(*(char))->(int)
(	O
"probable_eyes_b: %s eyemin: %d eyemax: %d"	*(char)
,	O
eyevalue_to_string	(*(struct(char,char,char,char)))->(*(char))
(	O
&	O
probable_eyes_b	O
)	O
,	O
eyemin_b	O
,	O
eyemax_b	O
)	O
;	O
if	O
(	O
you_look_alive	O
)	O
gprintf	(*(char))->(int)
(	O
"%o you look alive(%s)"	*(char)
,	O
live_reasonb	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%o\n"	*(char)
)	O
;	O
}	O
if	O
(	O
I_look_alive	O
&&	O
you_look_alive	O
)	O
{	O
*	O
resulta	*(int)
=	O
WIN	O
;	O
*	O
resultb	*(int)
=	O
0	int
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
TRACE	O
(	O
"Both live\n"	*(char)
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
0	int
,	O
"Both live"	*(char)
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
PASS_MOVE	O
,	O
WIN	O
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
I_look_alive	O
)	O
{	O
owl_shapes	O
(	O
&	O
shape_defensive_patterns	O
,	O
shape_defensive_moves	O
,	O
color	int
,	O
owla	O
,	O
&	O
owl_defendpat_db	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	O
-	O
1	int
;	O
k	int
++	O
)	O
if	O
(	O
!	O
get_next_move_from_list	O
(	O
&	O
shape_defensive_patterns	O
,	O
color	int
,	O
shape_defensive_moves	O
,	O
1	int
,	O
owla	O
)	O
)	O
break	O
;	O
}	O
else	O
shape_defensive_moves	O
[	O
0	int
]	O
.	O
pos	int
=	O
NO_MOVE	O
;	O
if	O
(	O
!	O
you_look_alive	O
)	O
{	O
owl_shapes	O
(	O
&	O
shape_offensive_patterns	O
,	O
shape_offensive_moves	O
,	O
color	int
,	O
owlb	O
,	O
&	O
owl_attackpat_db	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	O
-	O
1	int
;	O
k	int
++	O
)	O
if	O
(	O
!	O
get_next_move_from_list	O
(	O
&	O
shape_offensive_patterns	O
,	O
color	int
,	O
shape_offensive_moves	O
,	O
1	int
,	O
owlb	O
)	O
)	O
break	O
;	O
}	O
else	O
shape_offensive_moves	O
[	O
0	int
]	O
.	O
pos	int
=	O
NO_MOVE	O
;	O
if	O
(	O
eyemax_a	O
>	O
0	int
)	O
{	O
remove_eye_filling_moves	O
(	O
owla	O
,	O
vital_defensive_moves	O
)	O
;	O
remove_eye_filling_moves	O
(	O
owla	O
,	O
vital_offensive_moves	O
)	O
;	O
remove_eye_filling_moves	O
(	O
owla	O
,	O
shape_defensive_moves	O
)	O
;	O
remove_eye_filling_moves	O
(	O
owla	O
,	O
shape_offensive_moves	O
)	O
;	O
}	O
if	O
(	O
!	O
I_look_alive	O
)	O
{	O
semeai_review_owl_moves	O
(	O
vital_defensive_moves	O
,	O
owla	O
,	O
owlb	O
,	O
color	int
,	O
&	O
safe_outside_liberty_found	O
,	O
&	O
safe_common_liberty_found	O
,	O
&	O
riskless_move_found	O
,	O
mw	O
,	O
moves	array(int)
,	O
0	int
,	O
30	int
,	O
critical_semeai_worms	O
)	O
;	O
semeai_review_owl_moves	O
(	O
shape_defensive_moves	O
,	O
owla	O
,	O
owlb	O
,	O
color	int
,	O
&	O
safe_outside_liberty_found	O
,	O
&	O
safe_common_liberty_found	O
,	O
&	O
riskless_move_found	O
,	O
mw	O
,	O
moves	array(int)
,	O
0	int
,	O
0	int
,	O
critical_semeai_worms	O
)	O
;	O
}	O
if	O
(	O
!	O
you_look_alive	O
)	O
{	O
semeai_review_owl_moves	O
(	O
vital_offensive_moves	O
,	O
owla	O
,	O
owlb	O
,	O
color	int
,	O
&	O
safe_outside_liberty_found	O
,	O
&	O
safe_common_liberty_found	O
,	O
&	O
riskless_move_found	O
,	O
mw	O
,	O
moves	array(int)
,	O
1	int
,	O
30	int
,	O
critical_semeai_worms	O
)	O
;	O
semeai_review_owl_moves	O
(	O
shape_offensive_moves	O
,	O
owla	O
,	O
owlb	O
,	O
color	int
,	O
&	O
safe_outside_liberty_found	O
,	O
&	O
safe_common_liberty_found	O
,	O
&	O
riskless_move_found	O
,	O
mw	O
,	O
moves	array(int)
,	O
1	int
,	O
0	int
,	O
critical_semeai_worms	O
)	O
;	O
}	O
if	O
(	O
moves	array(int)
[	O
0	int
]	O
.	O
pos	int
==	O
NO_MOVE	O
||	O
we_might_be_inessential	O
)	O
{	O
include_semeai_worms_in_eyespace	O
=	O
1	int
;	O
if	O
(	O
!	O
owl_estimate_life	O
(	O
owlb	O
,	O
owla	O
,	O
vital_offensive_moves	O
,	O
&	O
live_reasonb	O
,	O
1	int
,	O
&	O
dummy_eyes	O
,	O
&	O
eyemin_b	O
,	O
&	O
eyemax_b	O
)	O
)	O
semeai_review_owl_moves	O
(	O
vital_offensive_moves	O
,	O
owla	O
,	O
owlb	O
,	O
color	int
,	O
&	O
safe_outside_liberty_found	O
,	O
&	O
safe_common_liberty_found	O
,	O
&	O
riskless_move_found	O
,	O
mw	O
,	O
moves	array(int)
,	O
1	int
,	O
30	int
,	O
critical_semeai_worms	O
)	O
;	O
include_semeai_worms_in_eyespace	O
=	O
0	int
;	O
}	O
if	O
(	O
eyemin_a	O
==	O
eyemax_a	O
)	O
I_have_more_eyes	O
=	O
(	O
eyemin_a	O
>	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_b	O
)	O
)	O
;	O
else	O
{	O
if	O
(	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_a	O
)	O
==	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_a	O
)	O
)	O
I_have_more_eyes	O
=	O
(	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_a	O
)	O
>	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_b	O
)	O
)	O
;	O
else	O
I_have_more_eyes	O
=	O
(	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_a	O
)	O
>	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_b	O
)	O
)	O
;	O
}	O
if	O
(	O
get_level	()->(int)
(	O
)	O
<	O
8	int
)	O
{	O
if	O
(	O
moves	array(int)
[	O
0	int
]	O
.	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
if	O
(	O
owl_phase	O
==	O
1	int
)	O
owl_phase	O
=	O
2	int
;	O
else	O
if	O
(	O
owl_phase	O
==	O
2	int
)	O
owl_phase	O
=	O
0	int
;	O
}	O
else	O
owl_phase	O
=	O
1	int
;	O
}	O
}	O
if	O
(	O
1	int
&&	O
verbose	int
)	O
{	O
showboard	(int)->(void)
(	O
0	int
)	O
;	O
goaldump	(array(char))->(void)
(	O
owla	O
->	O
goal	*(char)
)	O
;	O
goaldump	(array(char))->(void)
(	O
owlb	O
->	O
goal	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
you_look_alive	O
&&	O
!	O
safe_outside_liberty_found	O
&&	O
(	O
moves	array(int)
[	O
0	int
]	O
.	O
value	*(char)
<	O
110	int
||	O
I_have_more_eyes	O
)	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
!	O
mw	O
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
liberty_of_goal	O
(	O
pos	int
,	O
owlb	O
)	O
)	O
{	O
if	O
(	O
!	O
liberty_of_goal	O
(	O
pos	int
,	O
owla	O
)	O
)	O
{	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
==	O
WIN	O
)	O
{	O
safe_outside_liberty_found	O
=	O
1	int
;	O
outside_liberty	O
.	O
pos	int
=	O
pos	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
backfill_outside_liberty	O
.	O
pos	int
==	O
NO_MOVE	O
)	O
backfill_outside_liberty	O
.	O
pos	int
=	O
find_semeai_backfilling_move	O
(	O
bpos	int
,	O
pos	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
pos	int
,	O
color	int
)	O
==	O
WIN	O
)	O
{	O
safe_common_liberty_found	O
=	O
1	int
;	O
common_liberty	O
.	O
pos	int
=	O
pos	int
;	O
}	O
else	O
if	O
(	O
backfill_common_liberty	O
.	O
pos	int
==	O
NO_MOVE	O
)	O
backfill_common_liberty	O
.	O
pos	int
=	O
find_semeai_backfilling_move	O
(	O
bpos	int
,	O
pos	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
you_look_alive	O
)	O
{	O
if	O
(	O
safe_outside_liberty_found	O
&&	O
outside_liberty	O
.	O
pos	int
!=	O
NO_MOVE	O
)	O
{	O
move_value	*(float)
=	O
semeai_move_value	O
(	O
outside_liberty	O
.	O
pos	int
,	O
owla	O
,	O
owlb	O
,	O
50	int
,	O
critical_semeai_worms	O
)	O
;	O
owl_add_move	O
(	O
moves	array(int)
,	O
outside_liberty	O
.	O
pos	int
,	O
move_value	*(float)
,	O
"safe outside liberty"	*(char)
,	O
SAME_DRAGON_NOT_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	O
,	O
NULL	O
)	O
;	O
riskless_move_found	O
=	O
1	int
;	O
TRACE	O
(	O
"Added %1m %d (5)\n"	*(char)
,	O
outside_liberty	O
.	O
pos	int
,	O
move_value	*(float)
)	O
;	O
}	O
else	O
if	O
(	O
backfill_outside_liberty	O
.	O
pos	int
!=	O
NO_MOVE	O
)	O
{	O
move_value	*(float)
=	O
semeai_move_value	O
(	O
backfill_outside_liberty	O
.	O
pos	int
,	O
owla	O
,	O
owlb	O
,	O
50	int
,	O
critical_semeai_worms	O
)	O
;	O
owl_add_move	O
(	O
moves	array(int)
,	O
backfill_outside_liberty	O
.	O
pos	int
,	O
move_value	*(float)
,	O
"backfilling move"	*(char)
,	O
SAME_DRAGON_NOT_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	O
,	O
NULL	O
)	O
;	O
riskless_move_found	O
=	O
1	int
;	O
TRACE	O
(	O
"Added %1m %d (6)\n"	*(char)
,	O
backfill_outside_liberty	O
.	O
pos	int
,	O
move_value	*(float)
)	O
;	O
}	O
else	O
if	O
(	O
safe_common_liberty_found	O
&&	O
common_liberty	O
.	O
pos	int
!=	O
NO_MOVE	O
)	O
{	O
move_value	*(float)
=	O
semeai_move_value	O
(	O
common_liberty	O
.	O
pos	int
,	O
owla	O
,	O
owlb	O
,	O
10	int
,	O
critical_semeai_worms	O
)	O
;	O
owl_add_move	O
(	O
moves	array(int)
,	O
common_liberty	O
.	O
pos	int
,	O
move_value	*(float)
,	O
"safe common liberty"	*(char)
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	O
,	O
NULL	O
)	O
;	O
if	O
(	O
semeai_is_riskless_move	O
(	O
common_liberty	O
.	O
pos	int
,	O
owla	O
)	O
)	O
riskless_move_found	O
=	O
1	int
;	O
TRACE	O
(	O
"Added %1m %d (7)\n"	*(char)
,	O
common_liberty	O
.	O
pos	int
,	O
move_value	*(float)
)	O
;	O
}	O
else	O
if	O
(	O
backfill_common_liberty	O
.	O
pos	int
!=	O
NO_MOVE	O
)	O
{	O
move_value	*(float)
=	O
semeai_move_value	O
(	O
backfill_common_liberty	O
.	O
pos	int
,	O
owla	O
,	O
owlb	O
,	O
10	int
,	O
critical_semeai_worms	O
)	O
;	O
owl_add_move	O
(	O
moves	array(int)
,	O
backfill_common_liberty	O
.	O
pos	int
,	O
move_value	*(float)
,	O
"backfilling move"	*(char)
,	O
SAME_DRAGON_NOT_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	O
,	O
NULL	O
)	O
;	O
if	O
(	O
semeai_is_riskless_move	O
(	O
backfill_common_liberty	O
.	O
pos	int
,	O
owla	O
)	O
)	O
riskless_move_found	O
=	O
1	int
;	O
TRACE	O
(	O
"Added %1m %d (6)\n"	*(char)
,	O
backfill_common_liberty	O
.	O
pos	int
,	O
move_value	*(float)
)	O
;	O
}	O
}	O
if	O
(	O
moves	array(int)
[	O
0	int
]	O
.	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
if	O
(	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_b	O
)	O
==	O
1	int
)	O
{	O
int	O
move	*(int)
=	O
semeai_propose_eyespace_filling_move	O
(	O
owla	O
,	O
owlb	O
)	O
;	O
if	O
(	O
move	*(int)
)	O
{	O
owl_add_move	O
(	O
moves	array(int)
,	O
move	*(int)
,	O
70	int
,	O
"eyespace filling"	*(char)
,	O
SAME_DRAGON_NOT_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	O
,	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
moves	array(int)
[	O
0	int
]	O
.	O
pos	int
==	O
NO_MOVE	O
)	O
TRACE	O
(	O
"No move found\n"	*(char)
)	O
;	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
tested_moves	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_SEMEAI_MOVES	O
;	O
k	int
++	O
)	O
{	O
int	O
mpos	O
=	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
;	O
if	O
(	O
mpos	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
tested_moves	O
>	O
2	int
||	O
(	O
stackp	int
>	O
semeai_branch_depth2	int
&&	O
tested_moves	O
>	O
1	int
)	O
||	O
(	O
stackp	int
>	O
semeai_branch_depth	int
&&	O
tested_moves	O
>	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
allpats	int
)	O
break	O
;	O
else	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
mpos	O
,	O
color	int
,	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
,	O
apos	int
)	O
)	O
{	O
semeai_add_sgf_comment	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
,	O
owl_phase	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
count_variations	int
>=	O
semeai_node_limit	int
||	O
stackp	int
>=	O
MAX_SEMEAI_DEPTH	O
)	O
continue	O
;	O
if	O
(	O
semeai_trymove_and_recurse	O
(	O
apos	int
,	O
bpos	int
,	O
owla	O
,	O
owlb	O
,	O
owl_phase	O
,	O
mpos	O
,	O
color	int
,	O
best_resulta	O
==	O
0	int
||	O
best_resultb	O
==	O
0	int
,	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
,	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
,	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
,	O
moves	array(int)
[	O
k	int
]	O
.	O
pattern_data	O
,	O
moves	array(int)
[	O
k	int
]	O
.	O
lunch	int
,	O
NULL	O
,	O
&	O
this_resulta	O
,	O
&	O
this_resultb	O
)	O
)	O
{	O
tested_moves	O
++	O
;	O
if	O
(	O
this_resultb	O
==	O
WIN	O
&&	O
this_resulta	O
==	O
WIN	O
)	O
{	O
*	O
resulta	*(int)
=	O
WIN	O
;	O
*	O
resultb	*(int)
=	O
WIN	O
;	O
*	O
move	*(int)
=	O
mpos	O
;	O
TRACE	O
(	O
"After %1m I (%C) am alive, you are dead\n"	*(char)
,	O
mpos	O
,	O
color	int
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
mpos	O
,	O
WIN	O
,	O
WIN	O
,	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
)	O
;	O
close_pattern_list	O
(	O
color	int
,	O
&	O
shape_defensive_patterns	O
)	O
;	O
close_pattern_list	O
(	O
color	int
,	O
&	O
shape_offensive_patterns	O
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
mpos	O
,	O
WIN	O
,	O
WIN	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
prefer_ko	O
!=	O
color	int
&&	O
(	O
this_resulta	O
>	O
best_resulta	O
||	O
(	O
this_resulta	O
==	O
best_resulta	O
&&	O
this_resultb	O
>	O
best_resultb	O
)	O
)	O
)	O
||	O
(	O
prefer_ko	O
==	O
color	int
&&	O
(	O
this_resultb	O
>	O
best_resultb	O
||	O
(	O
this_resultb	O
==	O
best_resultb	O
&&	O
this_resulta	O
>	O
best_resulta	O
)	O
)	O
)	O
)	O
{	O
best_resulta	O
=	O
this_resulta	O
;	O
best_resultb	O
=	O
this_resultb	O
;	O
best_move	O
=	O
mpos	O
;	O
best_move_name	O
=	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
;	O
}	O
}	O
}	O
close_pattern_list	O
(	O
color	int
,	O
&	O
shape_defensive_patterns	O
)	O
;	O
close_pattern_list	O
(	O
color	int
,	O
&	O
shape_offensive_patterns	O
)	O
;	O
if	O
(	O
best_resulta	O
==	O
0	int
&&	O
best_resultb	O
==	O
0	int
&&	O
you_look_alive	O
)	O
{	O
*	O
resulta	*(int)
=	O
0	int
;	O
*	O
resultb	*(int)
=	O
0	int
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
0	int
,	O
"You live, I die"	*(char)
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
PASS_MOVE	O
,	O
0	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
best_resulta	O
==	O
0	int
&&	O
best_resultb	O
==	O
0	int
&&	O
!	O
riskless_move_found	O
)	O
{	O
const	O
char	O
*	O
live_reasona	O
;	O
int	O
eyemin_a	O
;	O
int	O
eyemax_a	O
;	O
for	O
(	O
sworm	O
=	O
0	int
;	O
sworm	O
<	O
s_worms	O
;	O
sworm	O
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
semeai_worms	O
[	O
sworm	O
]	O
]	O
==	O
other	O
)	O
{	O
if	O
(	O
important_semeai_worms	O
[	O
sworm	O
]	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
sworm	O
==	O
s_worms	O
)	O
{	O
include_semeai_worms_in_eyespace	O
=	O
1	int
;	O
if	O
(	O
!	O
owl_estimate_life	O
(	O
owla	O
,	O
owlb	O
,	O
vital_defensive_moves	O
,	O
&	O
live_reasona	O
,	O
0	int
,	O
&	O
dummy_eyes	O
,	O
&	O
eyemin_a	O
,	O
&	O
eyemax_a	O
)	O
&&	O
eyemax_a	O
<	O
2	int
)	O
{	O
include_semeai_worms_in_eyespace	O
=	O
0	int
;	O
*	O
resulta	*(int)
=	O
0	int
;	O
*	O
resultb	*(int)
=	O
0	int
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
0	int
,	O
"You live, I die - 2"	*(char)
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
PASS_MOVE	O
,	O
0	int
,	O
0	int
)	O
;	O
}	O
include_semeai_worms_in_eyespace	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
best_resulta	O
==	O
0	int
&&	O
best_resultb	O
==	O
0	int
&&	O
!	O
riskless_move_found	O
)	O
{	O
if	O
(	O
pass	O
)	O
{	O
if	O
(	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_a	O
)	O
<	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_b	O
)	O
)	O
{	O
*	O
resulta	*(int)
=	O
0	int
;	O
*	O
resultb	*(int)
=	O
0	int
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
TRACE	O
(	O
"You have more eyes.\n"	*(char)
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	O
,	O
0	int
,	O
0	int
,	O
"You have more eyes"	*(char)
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
PASS_MOVE	O
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_b	O
)	O
<	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes_a	O
)	O
)	O
{	O
*	O
resulta	*(int)
=	O
WIN	O
;	O
*	O
resultb	*(int)
=	O
WIN	O
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
TRACE	O
(	O
"I have more eyes\n"	*(char)
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
WIN	O
,	O
"I have more eyes"	*(char)
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
PASS_MOVE	O
,	O
WIN	O
,	O
WIN	O
)	O
;	O
}	O
else	O
{	O
*	O
resulta	*(int)
=	O
WIN	O
;	O
*	O
resultb	*(int)
=	O
0	int
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
TRACE	O
(	O
"Seki\n"	*(char)
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	O
,	O
WIN	O
,	O
0	int
,	O
"Seki"	*(char)
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
PASS_MOVE	O
,	O
WIN	O
,	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
do_owl_analyze_semeai	O
(	O
bpos	int
,	O
apos	int
,	O
owlb	O
,	O
owla	O
,	O
resultb	*(int)
,	O
resulta	*(int)
,	O
NULL	O
,	O
1	int
,	O
owl_phase	O
)	O
;	O
*	O
resulta	*(int)
=	O
REVERSE_RESULT	O
(	O
*	O
resulta	*(int)
)	O
;	O
*	O
resultb	*(int)
=	O
REVERSE_RESULT	O
(	O
*	O
resultb	*(int)
)	O
;	O
TRACE	O
(	O
"No move found\n"	*(char)
)	O
;	O
SGFTRACE_SEMEAI	O
(	O
PASS_MOVE	O
,	O
*	O
resulta	*(int)
,	O
*	O
resultb	*(int)
,	O
"No move found"	*(char)
)	O
;	O
*	O
move	*(int)
=	O
PASS_MOVE	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
PASS_MOVE	O
,	O
*	O
resulta	*(int)
,	O
*	O
resultb	*(int)
)	O
;	O
}	O
}	O
if	O
(	O
!	O
pass	O
&&	O
k	int
==	O
1	int
)	O
{	O
if	O
(	O
(	O
best_resulta	O
==	O
WIN	O
&&	O
best_resultb	O
==	O
0	int
&&	O
best_move	O
!=	O
NO_MOVE	O
&&	O
best_move	O
==	O
common_liberty	O
.	O
pos	int
)	O
||	O
(	O
best_resulta	O
==	O
KO_B	O
&&	O
best_resultb	O
==	O
KO_B	O
&&	O
is_ko	(int,int,*(int))->(int)
(	O
best_move	O
,	O
owla	O
->	O
color	int
,	O
NULL	O
)	O
)	O
)	O
{	O
do_owl_analyze_semeai	O
(	O
bpos	int
,	O
apos	int
,	O
owlb	O
,	O
owla	O
,	O
&	O
this_resultb	O
,	O
&	O
this_resulta	O
,	O
NULL	O
,	O
1	int
,	O
owl_phase	O
)	O
;	O
if	O
(	O
REVERSE_RESULT	O
(	O
this_resulta	O
)	O
>=	O
best_resulta	O
&&	O
REVERSE_RESULT	O
(	O
this_resultb	O
)	O
>=	O
best_resultb	O
)	O
{	O
best_move	O
=	O
PASS_MOVE	O
;	O
best_resulta	O
=	O
REVERSE_RESULT	O
(	O
this_resulta	O
)	O
;	O
best_resultb	O
=	O
REVERSE_RESULT	O
(	O
this_resultb	O
)	O
;	O
best_move_name	O
=	O
"Pass"	*(char)
;	O
}	O
}	O
}	O
*	O
resulta	*(int)
=	O
best_resulta	O
;	O
*	O
resultb	*(int)
=	O
best_resultb	O
;	O
if	O
(	O
best_resulta	O
==	O
0	int
)	O
best_move	O
=	O
PASS_MOVE	O
;	O
*	O
move	*(int)
=	O
best_move	O
;	O
SGFTRACE_SEMEAI	O
(	O
best_move	O
,	O
best_resulta	O
,	O
best_resultb	O
,	O
best_move_name	O
)	O
;	O
READ_RETURN_SEMEAI	O
(	O
SEMEAI	int
,	O
apos	int
,	O
bpos	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
best_move	O
,	O
best_resulta	O
,	O
best_resultb	O
)	O
;	O
}	O
static	O
int	O
semeai_trymove_and_recurse	O
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
,	O
int	O
owl_phase	O
,	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
int	O
ko_allowed	O
,	O
int	O
move_value	*(float)
,	O
const	O
char	O
*	O
move_name	O
,	O
enum	O
same_dragon_value	O
same_dragon	(int,int)->(int)
,	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
,	O
int	O
lunch	int
,	O
int	O
*	O
semeai_move	*(int)
,	O
int	O
*	O
this_resulta	O
,	O
int	O
*	O
this_resultb	O
)	O
{	O
int	O
ko_move	O
=	O
0	int
;	O
gg_assert	O
(	O
this_resulta	O
!=	O
NULL	O
&&	O
this_resultb	O
!=	O
NULL	O
)	O
;	O
*	O
this_resulta	O
=	O
0	int
;	O
*	O
this_resultb	O
=	O
0	int
;	O
if	O
(	O
!	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
move_name	O
,	O
apos	int
,	O
&	O
ko_move	O
,	O
ko_allowed	O
)	O
)	O
{	O
int	O
kpos	O
;	O
if	O
(	O
is_ko	(int,int,*(int))->(int)
(	O
move	*(int)
,	O
color	int
,	O
&	O
kpos	O
)	O
)	O
{	O
int	O
libs	*(int)
[	O
MAX_LIBERTIES	O
]	O
;	O
int	O
n	int
;	O
int	O
nlib	O
;	O
int	O
sworm	O
;	O
int	O
worm_color	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
for	O
(	O
sworm	O
=	O
0	int
;	O
sworm	O
<	O
s_worms	O
;	O
sworm	O
++	O
)	O
{	O
worm_color	O
=	O
board	*(char)
[	O
semeai_worms	O
[	O
sworm	O
]	O
]	O
;	O
if	O
(	O
worm_color	O
==	O
color	int
)	O
{	O
nlib	O
=	O
findlib	(int,int,*(int))->(int)
(	O
semeai_worms	O
[	O
sworm	O
]	O
,	O
MAX_LIBERTIES	O
,	O
libs	*(int)
)	O
;	O
if	O
(	O
nlib	O
>	O
MAX_LIBERTIES	O
)	O
return	O
0	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
nlib	O
;	O
n	int
++	O
)	O
if	O
(	O
is_ko	(int,int,*(int))->(int)
(	O
libs	*(int)
[	O
n	int
]	O
,	O
other	O
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
DIAGONAL_NEIGHBORS	O
(	O
libs	*(int)
[	O
n	int
]	O
,	O
kpos	O
)	O
)	O
return	O
0	int
;	O
*	O
this_resulta	O
=	O
WIN	O
;	O
*	O
this_resultb	O
=	O
WIN	O
;	O
}	O
}	O
else	O
if	O
(	O
worm_color	O
==	O
other	O
)	O
{	O
if	O
(	O
countlib	(int)->(int)
(	O
semeai_worms	O
[	O
sworm	O
]	O
)	O
>	O
2	int
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
*	O
this_resulta	O
==	O
WIN	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
semeai_add_sgf_comment	O
(	O
move_value	*(float)
,	O
owl_phase	O
)	O
;	O
TRACE	O
(	O
"Trying %C %1m. Current stack: "	*(char)
,	O
color	int
,	O
move	*(int)
)	O
;	O
if	O
(	O
verbose	int
)	O
{	O
dump_stack	()->(void)
(	O
)	O
;	O
goaldump	(array(char))->(void)
(	O
owla	O
->	O
goal	*(char)
)	O
;	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
goaldump	(array(char))->(void)
(	O
owlb	O
->	O
goal	*(char)
)	O
;	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
TRACE	O
(	O
"%s, value %d, same_dragon %d\n"	*(char)
,	O
move_name	O
,	O
move_value	*(float)
,	O
same_dragon	(int,int)->(int)
)	O
;	O
push_owl	O
(	O
&	O
owla	O
)	O
;	O
push_owl	O
(	O
&	O
owlb	O
)	O
;	O
if	O
(	O
owla	O
->	O
color	int
==	O
color	int
)	O
{	O
owl_update_goal	O
(	O
move	*(int)
,	O
same_dragon	(int,int)->(int)
,	O
lunch	int
,	O
owla	O
,	O
1	int
,	O
pattern_data	O
)	O
;	O
owl_update_boundary_marks	O
(	O
move	*(int)
,	O
owlb	O
)	O
;	O
}	O
else	O
{	O
owl_update_goal	O
(	O
move	*(int)
,	O
same_dragon	(int,int)->(int)
,	O
lunch	int
,	O
owlb	O
,	O
1	int
,	O
pattern_data	O
)	O
;	O
owl_update_boundary_marks	O
(	O
move	*(int)
,	O
owla	O
)	O
;	O
}	O
mark_goal_in_sgf	(array(char))->(void)
(	O
owla	O
->	O
goal	*(char)
)	O
;	O
mark_goal_in_sgf	(array(char))->(void)
(	O
owlb	O
->	O
goal	*(char)
)	O
;	O
if	O
(	O
board	*(char)
[	O
bpos	int
]	O
==	O
EMPTY	int
)	O
{	O
*	O
this_resulta	O
=	O
REVERSE_RESULT	O
(	O
do_owl_attack	O
(	O
apos	int
,	O
semeai_move	*(int)
,	O
NULL	O
,	O
owla	O
,	O
0	int
)	O
)	O
;	O
*	O
this_resultb	O
=	O
*	O
this_resulta	O
;	O
}	O
else	O
{	O
do_owl_analyze_semeai	O
(	O
bpos	int
,	O
apos	int
,	O
owlb	O
,	O
owla	O
,	O
this_resultb	O
,	O
this_resulta	O
,	O
semeai_move	*(int)
,	O
0	int
,	O
owl_phase	O
)	O
;	O
*	O
this_resulta	O
=	O
REVERSE_RESULT	O
(	O
*	O
this_resulta	O
)	O
;	O
*	O
this_resultb	O
=	O
REVERSE_RESULT	O
(	O
*	O
this_resultb	O
)	O
;	O
}	O
pop_owl	O
(	O
&	O
owlb	O
)	O
;	O
pop_owl	O
(	O
&	O
owla	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
ko_move	O
)	O
{	O
if	O
(	O
*	O
this_resulta	O
!=	O
0	int
)	O
*	O
this_resulta	O
=	O
KO_B	O
;	O
if	O
(	O
*	O
this_resultb	O
!=	O
0	int
)	O
*	O
this_resultb	O
=	O
KO_B	O
;	O
}	O
if	O
(	O
count_variations	int
>=	O
semeai_node_limit	int
)	O
{	O
TRACE	O
(	O
"Out of nodes, claiming win.\n"	*(char)
)	O
;	O
result_certain	O
=	O
0	int
;	O
*	O
this_resulta	O
=	O
WIN	O
;	O
*	O
this_resultb	O
=	O
WIN	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
semeai_add_sgf_comment	O
(	O
int	O
value	*(char)
,	O
int	O
owl_phase	O
)	O
{	O
char	O
buf	*(char)
[	O
100	int
]	O
;	O
if	O
(	O
!	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
return	O
;	O
if	O
(	O
owl_phase	O
)	O
gg_snprintf	O
(	O
buf	*(char)
,	O
100	int
,	O
"value %d, owl_phase"	*(char)
,	O
value	*(char)
)	O
;	O
else	O
gg_snprintf	O
(	O
buf	*(char)
,	O
100	int
,	O
"value %d"	*(char)
,	O
value	*(char)
)	O
;	O
sgftreeAddComment	(*(struct(*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(char))->(void)
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
,	O
buf	*(char)
)	O
;	O
}	O
static	O
int	O
semeai_trust_tactical_attack	O
(	O
int	O
str	int
)	O
{	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
3	int
]	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
;	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
3	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
liberties	*(int)
>	O
2	int
)	O
return	O
0	int
;	O
if	O
(	O
liberties	*(int)
<	O
2	int
)	O
return	O
1	int
;	O
if	O
(	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
other	O
)	O
||	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
1	int
]	O
,	O
other	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
semeai_is_riskless_move	O
(	O
int	O
move	*(int)
,	O
struct	O
local_owl_data	O
*	O
owla	O
)	O
{	O
int	O
k	int
;	O
int	O
liberties	*(int)
=	O
accuratelib	(int,int,int,*(int))->(int)
(	O
move	*(int)
,	O
owla	O
->	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
liberty_of_goal	O
(	O
move	*(int)
,	O
owla	O
)	O
)	O
return	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
owla	O
->	O
color	int
&&	O
owla	O
->	O
goal	*(char)
[	O
pos	int
]	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
>	O
liberties	*(int)
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
semeai_review_owl_moves	O
(	O
struct	O
owl_move_data	O
owl_moves	O
[	O
MAX_MOVES	O
]	O
,	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
,	O
int	O
color	int
,	O
int	O
*	O
safe_outside_liberty_found	O
,	O
int	O
*	O
safe_common_liberty_found	O
,	O
int	O
*	O
riskless_move_found	O
,	O
signed	O
char	O
mw	O
[	O
BOARDMAX	O
]	O
,	O
struct	O
owl_move_data	O
semeai_moves	O
[	O
MAX_SEMEAI_MOVES	O
]	O
,	O
int	O
guess_same_dragon	O
,	O
int	O
value_bonus	O
,	O
int	O
*	O
critical_semeai_worms	O
)	O
{	O
int	O
move	*(int)
;	O
int	O
move_value	*(float)
;	O
enum	O
same_dragon_value	O
same_dragon	(int,int)->(int)
;	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
=	O
NULL	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	O
-	O
1	int
;	O
k	int
++	O
)	O
{	O
move	*(int)
=	O
owl_moves	O
[	O
k	int
]	O
.	O
pos	int
;	O
if	O
(	O
move	*(int)
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
owl_moves	O
[	O
k	int
]	O
.	O
value	*(char)
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
liberty_of_goal	O
(	O
move	*(int)
,	O
owlb	O
)	O
&&	O
safe_move	(int,int)->(int)
(	O
move	*(int)
,	O
color	int
)	O
)	O
{	O
if	O
(	O
!	O
liberty_of_goal	O
(	O
move	*(int)
,	O
owla	O
)	O
)	O
*	O
safe_outside_liberty_found	O
=	O
1	int
;	O
else	O
*	O
safe_common_liberty_found	O
=	O
1	int
;	O
}	O
if	O
(	O
is_legal	(int,int)->(int)
(	O
move	*(int)
,	O
color	int
)	O
&&	O
!	O
is_ko	(int,int,*(int))->(int)
(	O
move	*(int)
,	O
color	int
,	O
NULL	O
)	O
&&	O
semeai_is_riskless_move	O
(	O
move	*(int)
,	O
owla	O
)	O
)	O
*	O
riskless_move_found	O
=	O
1	int
;	O
if	O
(	O
guess_same_dragon	O
)	O
{	O
if	O
(	O
liberty_of_goal	O
(	O
move	*(int)
,	O
owla	O
)	O
||	O
second_liberty_of_goal	O
(	O
move	*(int)
,	O
owla	O
)	O
)	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_MAYBE_CONNECTED	O
;	O
else	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_NOT_CONNECTED	O
;	O
}	O
else	O
{	O
same_dragon	(int,int)->(int)
=	O
owl_moves	O
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
;	O
pattern_data	O
=	O
owl_moves	O
[	O
k	int
]	O
.	O
pattern_data	O
;	O
}	O
mw	O
[	O
move	*(int)
]	O
=	O
1	int
;	O
move_value	*(float)
=	O
(	O
semeai_move_value	O
(	O
move	*(int)
,	O
owla	O
,	O
owlb	O
,	O
owl_moves	O
[	O
k	int
]	O
.	O
value	*(char)
,	O
critical_semeai_worms	O
)	O
+	O
value_bonus	O
)	O
;	O
owl_add_move	O
(	O
semeai_moves	O
,	O
move	*(int)
,	O
move_value	*(float)
,	O
owl_moves	O
[	O
k	int
]	O
.	O
name	short
,	O
same_dragon	(int,int)->(int)
,	O
NO_MOVE	O
,	O
owl_moves	O
[	O
k	int
]	O
.	O
escape	O
,	O
NO_MOVE	O
,	O
MAX_SEMEAI_MOVES	O
,	O
pattern_data	O
)	O
;	O
TRACE	O
(	O
"Added %1m %d\n"	*(char)
,	O
move	*(int)
,	O
move_value	*(float)
)	O
;	O
}	O
}	O
static	O
int	O
semeai_propose_eyespace_filling_move	O
(	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
)	O
{	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
owlb	O
->	O
color	int
)	O
;	O
int	O
pos	int
;	O
int	O
mw	O
[	O
BOARDMAX	O
]	O
;	O
int	O
mz	O
[	O
BOARDMAX	O
]	O
;	O
owl_find_relevant_eyespaces	O
(	O
owlb	O
,	O
mw	O
,	O
mz	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
owla	O
->	O
goal	*(char)
[	O
pos	int
]	O
)	O
mw	O
[	O
owlb	O
->	O
my_eye	O
[	O
pos	int
]	O
.	O
origin	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
origin	int
=	O
owlb	O
->	O
my_eye	O
[	O
pos	int
]	O
.	O
origin	int
;	O
if	O
(	O
mw	O
[	O
origin	int
]	O
>	O
1	int
&&	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
owlb	O
->	O
my_eye	O
[	O
origin	int
]	O
.	O
value	*(char)
)	O
==	O
1	int
)	O
{	O
int	O
good_move	O
=	O
0	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
pos	int
,	O
color	int
,	O
"eyespace_filling"	*(char)
,	O
NO_MOVE	O
)	O
)	O
{	O
struct	O
eyevalue	struct(char,char,char,char)
new_value	O
;	O
int	O
dummy_attack	O
;	O
int	O
dummy_defense	O
;	O
compute_eyes	(int,*(struct(char,char,char,char)),*(int),*(int),array(struct(int,int,int,int,struct(char,char,char,char),char,char,char)),array(struct(float,char,int,array(int),int,array(int))),int)->(void)
(	O
origin	int
,	O
&	O
new_value	O
,	O
&	O
dummy_attack	O
,	O
&	O
dummy_defense	O
,	O
owlb	O
->	O
my_eye	O
,	O
owlb	O
->	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
,	O
0	int
)	O
;	O
if	O
(	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
new_value	O
)	O
<=	O
1	int
)	O
good_move	O
=	O
1	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
if	O
(	O
good_move	O
)	O
return	O
pos	int
;	O
}	O
}	O
}	O
return	O
NO_MOVE	O
;	O
}	O
static	O
int	O
semeai_move_value	O
(	O
int	O
move	*(int)
,	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
,	O
int	O
raw_value	O
,	O
int	O
*	O
critical_semeai_worms	O
)	O
{	O
int	O
pos	int
;	O
int	O
net	O
=	O
0	int
;	O
int	O
color	int
=	O
owla	O
->	O
color	int
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
int	O
k	int
;	O
int	O
bonus	O
=	O
0	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
move	*(int)
]	O
==	O
EMPTY	int
,	O
move	*(int)
)	O
;	O
verbose	int
=	O
0	int
;	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
move	*(int)
,	O
color	int
)	O
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
pos	int
==	O
find_origin	(int)->(int)
(	O
pos	int
)	O
)	O
{	O
int	O
count_lib	O
=	O
-	O
1	int
;	O
if	O
(	O
owla	O
->	O
goal	*(char)
[	O
pos	int
]	O
)	O
{	O
count_lib	O
=	O
countlib	(int)->(int)
(	O
pos	int
)	O
;	O
net	O
-=	O
75	int
*	O
count_lib	O
;	O
}	O
if	O
(	O
owlb	O
->	O
goal	*(char)
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
count_lib	O
<	O
0	int
)	O
count_lib	O
=	O
countlib	(int)->(int)
(	O
pos	int
)	O
;	O
net	O
+=	O
100	int
*	O
count_lib	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
NULL	O
,	O
0	int
)	O
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
return	O
0	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
pos	int
==	O
find_origin	(int)->(int)
(	O
pos	int
)	O
)	O
{	O
int	O
count_lib	O
=	O
-	O
1	int
;	O
if	O
(	O
owla	O
->	O
goal	*(char)
[	O
pos	int
]	O
||	O
(	O
pos	int
==	O
move	*(int)
&&	O
liberty_of_goal	O
(	O
move	*(int)
,	O
owla	O
)	O
)	O
)	O
{	O
count_lib	O
=	O
countlib	(int)->(int)
(	O
pos	int
)	O
;	O
net	O
+=	O
75	int
*	O
count_lib	O
;	O
}	O
if	O
(	O
owlb	O
->	O
goal	*(char)
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
count_lib	O
<	O
0	int
)	O
count_lib	O
=	O
countlib	(int)->(int)
(	O
pos	int
)	O
;	O
net	O
-=	O
100	int
*	O
count_lib	O
;	O
}	O
}	O
}	O
increase_depth_values	()->(void)
(	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
s_worms	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
critical_semeai_worms	O
[	O
k	int
]	O
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
semeai_worms	O
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
!	O
attack	(int,*(int))->(int)
(	O
semeai_worms	O
[	O
k	int
]	O
,	O
NULL	O
)	O
)	O
bonus	O
+=	O
50	int
;	O
else	O
if	O
(	O
board	*(char)
[	O
semeai_worms	O
[	O
k	int
]	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
!	O
find_defense	(int,*(int))->(int)
(	O
semeai_worms	O
[	O
k	int
]	O
,	O
NULL	O
)	O
)	O
bonus	O
+=	O
50	int
;	O
}	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
verbose	int
=	O
save_verbose	int
;	O
if	O
(	O
net	O
<	O
0	int
)	O
net	O
=	O
0	int
;	O
net	O
/=	O
25	int
;	O
net	O
*=	O
3	int
;	O
return	O
raw_value	O
+	O
net	O
+	O
bonus	O
;	O
}	O
static	O
void	O
remove_eye_filling_moves	O
(	O
struct	O
local_owl_data	O
*	O
our_owl	O
,	O
struct	O
owl_move_data	O
*	O
moves	array(int)
)	O
{	O
int	O
k	int
;	O
int	O
color	int
=	O
our_owl	O
->	O
color	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
==	O
NO_MOVE	O
)	O
break	O
;	O
else	O
{	O
struct	O
eye_data	struct(int,int,int,int,struct(char,char,char,char),char,char,char)
*	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
&	O
our_owl	O
->	O
my_eye	O
[	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
]	O
;	O
if	O
(	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
->	O
color	int
==	O
color	int
&&	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
->	O
msize	int
==	O
0	int
&&	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
->	O
neighbors	int
<=	O
1	int
&&	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
->	O
esize	int
!=	O
1	int
&&	O
our_owl	O
->	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
[	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
]	O
.	O
type	char
!=	O
HALF_EYE	O
&&	O
!	O
has_neighbor	(int,int)->(int)
(	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
=	O
0	int
;	O
}	O
}	O
}	O
static	O
int	O
liberty_of_goal	O
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
)	O
&&	O
owl	int
->	O
goal	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
second_liberty_of_goal	O
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
liberty_of_goal	O
(	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
,	O
owl	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
find_semeai_backfilling_move	O
(	O
int	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
,	O
int	O
liberty	O
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
]	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
result	int
=	O
NO_MOVE	O
;	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
liberty	O
,	O
other	O
)	O
==	O
WIN	O
)	O
return	O
liberty	O
;	O
if	O
(	O
is_self_atari	(int,int)->(int)
(	O
liberty	O
,	O
other	O
)	O
)	O
{	O
int	O
fill	O
;	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
liberty	O
,	O
other	O
,	O
1	int
,	O
&	O
fill	O
)	O
>	O
0	int
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
fill	O
,	O
other	O
,	O
"find_semeai_backfilling_move"	*(char)
,	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
)	O
)	O
{	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
liberty	O
,	O
other	O
)	O
)	O
result	int
=	O
fill	O
;	O
else	O
if	O
(	O
board	*(char)
[	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
]	O
!=	O
EMPTY	int
)	O
result	int
=	O
find_semeai_backfilling_move	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
,	O
liberty	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
ON_BOARD	O
(	O
result	int
)	O
&&	O
safe_move	(int,int)->(int)
(	O
result	int
,	O
other	O
)	O
)	O
return	O
result	int
;	O
else	O
return	O
NO_MOVE	O
;	O
}	O
static	O
int	O
reading_limit_reached	O
(	O
const	O
char	O
*	O
*	O
live_reason	O
,	O
int	O
this_variation_number	O
)	O
{	O
if	O
(	O
stackp	int
>	O
owl_reading_depth	int
)	O
{	O
TRACE	O
(	O
"%oVariation %d: ALIVE (maximum reading depth reached)\n"	*(char)
,	O
this_variation_number	O
)	O
;	O
*	O
live_reason	O
=	O
"max reading depth reached"	*(char)
;	O
return	O
1	int
;	O
}	O
if	O
(	O
local_owl_node_counter	O
>=	O
owl_node_limit	int
)	O
{	O
result_certain	O
=	O
0	int
;	O
TRACE	O
(	O
"%oVariation %d: ALIVE (owl node limit reached)\n"	*(char)
,	O
this_variation_number	O
)	O
;	O
*	O
live_reason	O
=	O
"owl node limit reached"	*(char)
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
clear_owl_move_data	O
(	O
struct	O
owl_move_data	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	O
;	O
k	int
++	O
)	O
{	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
=	O
NO_MOVE	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
=	O
-	O
1	int
;	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
=	O
NULL	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_CONNECTED	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
escape	O
=	O
0	int
;	O
moves	array(int)
[	O
k	int
]	O
.	O
lunch	int
=	O
NO_MOVE	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
pattern_data	O
=	O
NULL	O
;	O
clear_cut_list	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
cuts	O
)	O
;	O
}	O
}	O
static	O
void	O
set_single_owl_move	O
(	O
struct	O
owl_move_data	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
,	O
int	O
pos	int
,	O
const	O
char	O
*	O
name	short
)	O
{	O
moves	array(int)
[	O
0	int
]	O
.	O
pos	int
=	O
pos	int
;	O
moves	array(int)
[	O
0	int
]	O
.	O
value	*(char)
=	O
25	int
;	O
moves	array(int)
[	O
0	int
]	O
.	O
name	short
=	O
name	short
;	O
moves	array(int)
[	O
0	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_MAYBE_CONNECTED	O
;	O
moves	array(int)
[	O
0	int
]	O
.	O
escape	O
=	O
0	int
;	O
moves	array(int)
[	O
0	int
]	O
.	O
lunch	int
=	O
NO_MOVE	O
;	O
moves	array(int)
[	O
0	int
]	O
.	O
pattern_data	O
=	O
NULL	O
;	O
clear_cut_list	O
(	O
moves	array(int)
[	O
0	int
]	O
.	O
cuts	O
)	O
;	O
moves	array(int)
[	O
1	int
]	O
.	O
value	*(char)
=	O
0	int
;	O
}	O
int	O
owl_attack	(int,*(int),*(int),*(int))->(int)
(	O
int	O
target	int
,	O
int	O
*	O
attack_point	*(int)
,	O
int	O
*	O
certain	*(int)
,	O
int	O
*	O
kworm	int
)	O
{	O
int	O
result	int
;	O
struct	O
local_owl_data	O
*	O
owl	int
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
double	O
start	O
=	O
0.0	int
;	O
int	O
tactical_nodes	int
;	O
int	O
move	*(int)
=	O
NO_MOVE	O
;	O
int	O
wpos	O
=	O
NO_MOVE	O
;	O
int	O
wid	O
=	O
MAX_GOAL_WORMS	O
;	O
result_certain	O
=	O
1	int
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
{	O
if	O
(	O
attack_point	*(int)
)	O
*	O
attack_point	*(int)
=	O
NO_MOVE	O
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
NO_MOVE	O
;	O
if	O
(	O
certain	*(int)
)	O
*	O
certain	*(int)
=	O
1	int
;	O
return	O
1	int
;	O
}	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_ATTACK	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
attack_point	*(int)
,	O
kworm	int
,	O
certain	*(int)
)	O
)	O
return	O
result	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	O
)	O
start	O
=	O
gg_cputime	O
(	O
)	O
;	O
TRACE	O
(	O
"owl_attack %1m\n"	*(char)
,	O
target	int
)	O
;	O
init_owl	O
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
owl_make_domains	O
(	O
owl	int
,	O
NULL	O
)	O
;	O
prepare_goal_list	O
(	O
target	int
,	O
owl	int
,	O
owl_goal_worm	O
,	O
&	O
goal_worms_computed	O
,	O
kworm	int
,	O
1	int
)	O
;	O
result	int
=	O
do_owl_attack	O
(	O
target	int
,	O
&	O
move	*(int)
,	O
&	O
wid	O
,	O
owl	int
,	O
0	int
)	O
;	O
finish_goal_list	O
(	O
&	O
goal_worms_computed	O
,	O
&	O
wpos	O
,	O
owl_goal_worm	O
,	O
wid	O
)	O
;	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"owl_attack %1m, result %d %1m (%d, %d nodes, %f seconds)\n"	*(char)
,	O
target	int
,	O
result	int
,	O
move	*(int)
,	O
local_owl_node_counter	O
,	O
tactical_nodes	int
,	O
gg_cputime	O
(	O
)	O
-	O
start	O
)	O
;	O
store_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,array(char),int)->(void)
(	O
OWL_ATTACK	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
result	int
,	O
move	*(int)
,	O
wpos	O
,	O
result_certain	O
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	*(char)
,	O
board	*(char)
[	O
target	int
]	O
)	O
;	O
if	O
(	O
attack_point	*(int)
)	O
*	O
attack_point	*(int)
=	O
move	*(int)
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
wpos	O
;	O
if	O
(	O
certain	*(int)
)	O
*	O
certain	*(int)
=	O
result_certain	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
do_owl_attack	O
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
*	O
wormid	O
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
escape	O
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
struct	O
owl_move_data	O
vital_moves	O
[	O
MAX_MOVES	O
]	O
;	O
struct	O
owl_move_data	O
shape_moves	O
[	O
MAX_MOVES	O
]	O
;	O
struct	O
owl_move_data	O
*	O
moves	array(int)
;	O
struct	O
matched_patterns_list_data	O
shape_patterns	O
;	O
signed	O
char	O
mw	O
[	O
BOARDMAX	O
]	O
;	O
int	O
number_tried_moves	O
=	O
0	int
;	O
int	O
pass	O
;	O
int	O
k	int
;	O
int	O
savemove	O
=	O
0	int
;	O
int	O
saveworm	O
=	O
MAX_GOAL_WORMS	O
;	O
int	O
savecode	O
=	O
0	int
;	O
int	O
eyemin	O
=	O
-	O
1	int
;	O
int	O
eyemax	O
=	O
-	O
1	int
;	O
struct	O
eyevalue	struct(char,char,char,char)
probable_eyes	O
;	O
const	O
char	O
*	O
live_reason	O
;	O
int	O
move_cutoff	O
;	O
int	O
xpos	O
;	O
int	O
value1	O
;	O
int	O
value2	O
;	O
int	O
this_variation_number	O
=	O
count_variations	int
-	O
1	int
;	O
SETUP_TRACE_INFO	O
(	O
"owl_attack"	*(char)
,	O
str	int
)	O
;	O
shape_patterns	O
.	O
initialized	O
=	O
0	int
;	O
str	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
tt_get	O
(	O
&	O
ttable	O
,	O
OWL_ATTACK	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
value1	O
,	O
&	O
value2	O
,	O
&	O
xpos	O
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
value1	O
,	O
xpos	O
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
xpos	O
;	O
if	O
(	O
value1	O
==	O
GAIN	O
)	O
{	O
if	O
(	O
wormid	O
)	O
{	O
if	O
(	O
goal_worms_computed	O
)	O
*	O
wormid	O
=	O
value2	O
;	O
else	O
*	O
wormid	O
=	O
MAX_GOAL_WORMS	O
;	O
}	O
}	O
if	O
(	O
value1	O
==	O
WIN	O
)	O
TRACE	O
(	O
"%oVariation %d: DEAD (cached)\n"	*(char)
,	O
this_variation_number	O
)	O
;	O
else	O
TRACE	O
(	O
"%oVariation %d: ALIVE (cached)\n"	*(char)
,	O
this_variation_number	O
)	O
;	O
SGFTRACE	O
(	O
xpos	O
,	O
value1	O
,	O
"cached"	*(char)
)	O
;	O
return	O
value1	O
;	O
}	O
if	O
(	O
reading_limit_reached	O
(	O
&	O
live_reason	O
,	O
this_variation_number	O
)	O
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
live_reason	O
)	O
;	O
READ_RETURN	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
0	int
,	O
0	int
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
mw	O
,	O
0	int
,	O
sizeof	O
(	O
mw	O
)	O
)	O
;	O
global_owl_node_counter	O
++	O
;	O
local_owl_node_counter	O
++	O
;	O
current_owl_data	O
=	O
owl	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
owl	int
->	O
safe_move_cache	O
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
safe_move_cache	O
)	O
)	O
;	O
if	O
(	O
owl_estimate_life	O
(	O
owl	int
,	O
NULL	O
,	O
vital_moves	O
,	O
&	O
live_reason	O
,	O
1	int
,	O
&	O
probable_eyes	O
,	O
&	O
eyemin	O
,	O
&	O
eyemax	O
)	O
)	O
{	O
int	O
acode	int
=	O
0	int
;	O
int	O
mpos	O
=	O
NO_MOVE	O
;	O
if	O
(	O
experimental_owl_ext	int
&&	O
goal_worms_computed	O
)	O
{	O
int	O
size	int
=	O
0	int
;	O
saveworm	O
=	O
MAX_GOAL_WORMS	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_GOAL_WORMS	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
owl_goal_worm	O
[	O
k	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
board	*(char)
[	O
owl_goal_worm	O
[	O
k	int
]	O
]	O
==	O
EMPTY	int
||	O
countlib	(int)->(int)
(	O
owl_goal_worm	O
[	O
k	int
]	O
)	O
>	O
1	int
)	O
continue	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
owl_goal_worm	O
[	O
k	int
]	O
]	O
.	O
size	int
>	O
size	int
)	O
{	O
saveworm	O
=	O
k	int
;	O
size	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
owl_goal_worm	O
[	O
k	int
]	O
]	O
.	O
size	int
;	O
}	O
}	O
if	O
(	O
saveworm	O
!=	O
MAX_GOAL_WORMS	O
&&	O
size	int
>=	O
3	int
)	O
{	O
acode	int
=	O
GAIN	O
;	O
findlib	(int,int,*(int))->(int)
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
owl_goal_worm	O
[	O
saveworm	O
]	O
]	O
.	O
origin	int
,	O
1	int
,	O
&	O
mpos	O
)	O
;	O
}	O
}	O
SGFTRACE	O
(	O
0	int
,	O
acode	int
,	O
live_reason	O
)	O
;	O
TRACE	O
(	O
"%oVariation %d: ALIVE (%s)\n"	*(char)
,	O
this_variation_number	O
,	O
live_reason	O
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
)	O
{	O
READ_RETURN	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
wormid	O
)	O
*	O
wormid	O
=	O
saveworm	O
;	O
READ_RETURN2	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
mpos	O
,	O
acode	int
,	O
saveworm	O
)	O
;	O
}	O
}	O
for	O
(	O
pass	O
=	O
0	int
;	O
pass	O
<	O
6	int
;	O
pass	O
++	O
)	O
{	O
moves	array(int)
=	O
NULL	O
;	O
move_cutoff	O
=	O
1	int
;	O
current_owl_data	O
=	O
owl	int
;	O
switch	O
(	O
pass	O
)	O
{	O
case	O
1	int
:	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
number_tried_moves	O
>	O
0	int
)	O
continue	O
;	O
owl_shapes	O
(	O
&	O
shape_patterns	O
,	O
shape_moves	O
,	O
other	O
,	O
owl	int
,	O
&	O
owl_attackpat_db	O
)	O
;	O
moves	array(int)
=	O
shape_moves	O
;	O
break	O
;	O
case	O
0	int
:	O
case	O
2	int
:	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
number_tried_moves	O
>	O
0	int
)	O
continue	O
;	O
moves	array(int)
=	O
vital_moves	O
;	O
if	O
(	O
pass	O
==	O
0	int
||	O
stackp	int
>	O
owl_distrust_depth	int
)	O
{	O
if	O
(	O
stackp	int
==	O
0	int
)	O
move_cutoff	O
=	O
70	int
;	O
else	O
move_cutoff	O
=	O
45	int
;	O
}	O
if	O
(	O
eyemax	O
<	O
2	int
&&	O
stackp	int
>	O
2	int
)	O
move_cutoff	O
=	O
99	int
;	O
break	O
;	O
case	O
3	int
:	O
case	O
5	int
:	O
{	O
int	O
apos	int
;	O
int	O
result	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
result	int
=	O
attack	(int,*(int))->(int)
(	O
str	int
,	O
&	O
apos	int
)	O
;	O
if	O
(	O
result	int
==	O
WIN	O
||	O
(	O
result	int
!=	O
0	int
&&	O
(	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes	O
)	O
>=	O
2	int
||	O
pass	O
==	O
5	int
)	O
)	O
)	O
{	O
set_single_owl_move	O
(	O
shape_moves	O
,	O
apos	int
,	O
"tactical attack"	*(char)
)	O
;	O
moves	array(int)
=	O
shape_moves	O
;	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
}	O
break	O
;	O
case	O
4	int
:	O
if	O
(	O
number_tried_moves	O
==	O
0	int
)	O
{	O
int	O
dpos	O
;	O
int	O
dcode	int
=	O
do_owl_defend	O
(	O
str	int
,	O
&	O
dpos	O
,	O
NULL	O
,	O
owl	int
,	O
escape	O
)	O
;	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
TRACE	O
(	O
"%oVariation %d: DEAD (no defense)\n"	*(char)
,	O
this_variation_number	O
)	O
;	O
SGFTRACE	O
(	O
0	int
,	O
WIN	O
,	O
"no defense"	*(char)
)	O
;	O
close_pattern_list	O
(	O
other	O
,	O
&	O
shape_patterns	O
)	O
;	O
READ_RETURN	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
0	int
,	O
WIN	O
)	O
;	O
}	O
else	O
if	O
(	O
dpos	O
!=	O
NO_MOVE	O
)	O
{	O
const	O
char	O
*	O
name	short
=	O
"defense move"	*(char)
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
is_suicide	(int,int)->(int)
(	O
dpos	O
,	O
other	O
)	O
||	O
send_two_return_one	(int,int)->(int)
(	O
dpos	O
,	O
other	O
)	O
)	O
{	O
int	O
dpos2	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
dpos	O
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
other	O
&&	O
find_defense	(int,*(int))->(int)
(	O
dpos	O
+	O
delta	array(int)
[	O
k	int
]	O
,	O
&	O
dpos2	O
)	O
)	O
{	O
dpos	O
=	O
dpos2	O
;	O
name	short
=	O
"defense move (backfill)"	*(char)
;	O
break	O
;	O
}	O
}	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
if	O
(	O
dpos	O
!=	O
NO_MOVE	O
)	O
{	O
set_single_owl_move	O
(	O
shape_moves	O
,	O
dpos	O
,	O
name	short
)	O
;	O
moves	array(int)
=	O
shape_moves	O
;	O
}	O
}	O
}	O
break	O
;	O
}	O
if	O
(	O
!	O
moves	array(int)
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	O
;	O
k	int
++	O
)	O
{	O
int	O
mpos	O
;	O
int	O
ko_move	O
=	O
-	O
1	int
;	O
int	O
origin	int
=	O
NO_MOVE	O
;	O
int	O
captured	O
;	O
int	O
wid	O
=	O
MAX_GOAL_WORMS	O
;	O
int	O
dcode	int
;	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
k	int
>	O
0	int
)	O
break	O
;	O
current_owl_data	O
=	O
owl	int
;	O
if	O
(	O
pass	O
==	O
1	int
)	O
{	O
if	O
(	O
!	O
get_next_move_from_list	O
(	O
&	O
shape_patterns	O
,	O
other	O
,	O
shape_moves	O
,	O
move_cutoff	O
,	O
owl	int
)	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
<	O
move_cutoff	O
)	O
break	O
;	O
mpos	O
=	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
;	O
ASSERT_ON_BOARD1	O
(	O
mpos	O
)	O
;	O
if	O
(	O
mw	O
[	O
mpos	O
]	O
)	O
continue	O
;	O
captured	O
=	O
(	O
color	int
==	O
WHITE	int
?	O
white_captured	int
:	O
black_captured	int
)	O
;	O
if	O
(	O
!	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
mpos	O
,	O
other	O
,	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
,	O
str	int
,	O
&	O
ko_move	O
,	O
savecode	O
==	O
0	int
)	O
)	O
continue	O
;	O
captured	O
=	O
(	O
color	int
==	O
WHITE	int
?	O
white_captured	int
:	O
black_captured	int
)	O
-	O
captured	O
;	O
TRACE	O
(	O
"Trying %C %1m. Escape = %d. Current stack: "	*(char)
,	O
other	O
,	O
mpos	O
,	O
escape	O
)	O
;	O
if	O
(	O
verbose	int
)	O
dump_stack	()->(void)
(	O
)	O
;	O
push_owl	O
(	O
&	O
owl	int
)	O
;	O
mw	O
[	O
mpos	O
]	O
=	O
1	int
;	O
number_tried_moves	O
++	O
;	O
owl_update_boundary_marks	O
(	O
mpos	O
,	O
owl	int
)	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
)	O
origin	int
=	O
str	int
;	O
else	O
origin	int
=	O
select_new_goal_origin	O
(	O
NO_MOVE	O
,	O
owl	int
)	O
;	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
cuts	O
[	O
0	int
]	O
!=	O
NO_MOVE	O
&&	O
origin	int
!=	O
NO_MOVE	O
)	O
{	O
owl_test_cuts	O
(	O
owl	int
->	O
goal	*(char)
,	O
owl	int
->	O
color	int
,	O
moves	array(int)
[	O
k	int
]	O
.	O
cuts	O
)	O
;	O
if	O
(	O
!	O
owl	int
->	O
goal	*(char)
[	O
origin	int
]	O
)	O
origin	int
=	O
select_new_goal_origin	O
(	O
origin	int
,	O
owl	int
)	O
;	O
}	O
mark_goal_in_sgf	(array(char))->(void)
(	O
owl	int
->	O
goal	*(char)
)	O
;	O
if	O
(	O
origin	int
==	O
NO_MOVE	O
)	O
dcode	int
=	O
0	int
;	O
else	O
dcode	int
=	O
do_owl_defend	O
(	O
origin	int
,	O
NULL	O
,	O
&	O
wid	O
,	O
owl	int
,	O
escape	O
)	O
;	O
if	O
(	O
!	O
ko_move	O
)	O
{	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
pop_owl	O
(	O
&	O
owl	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
const	O
char	O
*	O
wintxt	O
;	O
char	O
winstr	O
[	O
192	int
]	O
;	O
if	O
(	O
origin	int
==	O
NO_MOVE	O
)	O
wintxt	O
=	O
"all original stones captured"	*(char)
;	O
else	O
wintxt	O
=	O
"attack effective"	*(char)
;	O
sprintf	(*(char),*(char))->(int)
(	O
winstr	O
,	O
"%s)\n  (%d variations"	*(char)
,	O
wintxt	O
,	O
count_variations	int
-	O
this_variation_number	O
)	O
;	O
SGFTRACE	O
(	O
mpos	O
,	O
WIN	O
,	O
winstr	O
)	O
;	O
}	O
close_pattern_list	O
(	O
other	O
,	O
&	O
shape_patterns	O
)	O
;	O
READ_RETURN	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
mpos	O
,	O
WIN	O
)	O
;	O
}	O
else	O
if	O
(	O
experimental_owl_ext	int
&&	O
dcode	int
==	O
LOSS	O
)	O
{	O
if	O
(	O
saveworm	O
==	O
MAX_GOAL_WORMS	O
||	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
owl_goal_worm	O
[	O
wid	O
]	O
]	O
.	O
size	int
>	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
owl_goal_worm	O
[	O
saveworm	O
]	O
]	O
.	O
size	int
)	O
saveworm	O
=	O
wid	O
;	O
}	O
else	O
if	O
(	O
experimental_owl_ext	int
&&	O
goal_worms_computed	O
&&	O
captured	O
>=	O
3	int
)	O
{	O
int	O
w	int
=	O
MAX_GOAL_WORMS	O
;	O
int	O
size	int
=	O
0	int
;	O
int	O
l	O
;	O
for	O
(	O
l	O
=	O
0	int
;	O
l	O
<	O
MAX_GOAL_WORMS	O
;	O
l	O
++	O
)	O
{	O
if	O
(	O
owl_goal_worm	O
[	O
l	O
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
board	*(char)
[	O
owl_goal_worm	O
[	O
l	O
]	O
]	O
==	O
EMPTY	int
)	O
if	O
(	O
size	int
==	O
0	int
||	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
owl_goal_worm	O
[	O
l	O
]	O
]	O
.	O
size	int
>	O
size	int
)	O
{	O
w	int
=	O
l	O
;	O
size	int
=	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
owl_goal_worm	O
[	O
l	O
]	O
]	O
.	O
size	int
;	O
}	O
}	O
if	O
(	O
w	int
!=	O
MAX_GOAL_WORMS	O
)	O
{	O
if	O
(	O
GAIN	O
>	O
savecode	O
)	O
{	O
dcode	int
=	O
LOSS	O
;	O
saveworm	O
=	O
w	int
;	O
}	O
else	O
if	O
(	O
GAIN	O
==	O
savecode	O
)	O
{	O
int	O
wpos	O
=	O
owl_goal_worm	O
[	O
saveworm	O
]	O
;	O
if	O
(	O
size	int
>	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
wpos	O
]	O
.	O
size	int
)	O
saveworm	O
=	O
w	int
;	O
}	O
}	O
}	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	O
,	O
savemove	O
,	O
dcode	int
,	O
mpos	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
dcode	int
!=	O
WIN	O
)	O
{	O
if	O
(	O
mpos	O
==	O
0	int
)	O
{	O
SGFTRACE	O
(	O
mpos	O
,	O
KO_B	O
,	O
"all original stones captured with ko"	*(char)
)	O
;	O
}	O
else	O
{	O
SGFTRACE	O
(	O
mpos	O
,	O
KO_B	O
,	O
"attack effective - ko"	*(char)
)	O
;	O
}	O
savemove	O
=	O
mpos	O
;	O
savecode	O
=	O
KO_B	O
;	O
number_tried_moves	O
--	O
;	O
}	O
}	O
pop_owl	O
(	O
&	O
owl	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
close_pattern_list	O
(	O
other	O
,	O
&	O
shape_patterns	O
)	O
;	O
if	O
(	O
savecode	O
)	O
{	O
if	O
(	O
savecode	O
==	O
GAIN	O
)	O
{	O
SGFTRACE	O
(	O
savemove	O
,	O
savecode	O
,	O
"attack effective (gain) - E"	*(char)
)	O
;	O
if	O
(	O
wormid	O
)	O
*	O
wormid	O
=	O
saveworm	O
;	O
READ_RETURN2	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
savemove	O
,	O
savecode	O
,	O
saveworm	O
)	O
;	O
}	O
else	O
{	O
SGFTRACE	O
(	O
savemove	O
,	O
savecode	O
,	O
"attack effective (ko) - E"	*(char)
)	O
;	O
READ_RETURN	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
savemove	O
,	O
savecode	O
)	O
;	O
}	O
}	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
char	O
winstr	O
[	O
128	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
winstr	O
,	O
"attack failed)\n  (%d variations"	*(char)
,	O
count_variations	int
-	O
this_variation_number	O
)	O
;	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
winstr	O
)	O
;	O
}	O
READ_RETURN0	O
(	O
OWL_ATTACK	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
)	O
;	O
}	O
int	O
owl_threaten_attack	(int,*(int),*(int))->(int)
(	O
int	O
target	int
,	O
int	O
*	O
attack1	*(int)
,	O
int	O
*	O
attack2	*(int)
)	O
{	O
struct	O
owl_move_data	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
;	O
int	O
k	int
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
target	int
]	O
)	O
;	O
struct	O
local_owl_data	O
*	O
owl	int
;	O
int	O
result	int
=	O
0	int
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
signed	O
char	O
saved_boundary	O
[	O
BOARDMAX	O
]	O
;	O
double	O
start	O
=	O
0.0	int
;	O
int	O
tactical_nodes	int
;	O
int	O
move	*(int)
=	O
0	int
;	O
int	O
move2	*(int)
=	O
0	int
;	O
struct	O
matched_patterns_list_data	O
shape_patterns	O
;	O
shape_patterns	O
.	O
initialized	O
=	O
0	int
;	O
result_certain	O
=	O
1	int
;	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_THREATEN_ATTACK	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
attack1	*(int)
,	O
attack2	*(int)
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	O
)	O
start	O
=	O
gg_cputime	O
(	O
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
TRACE	O
(	O
"owl_threaten_attack %1m\n"	*(char)
,	O
target	int
)	O
;	O
init_owl	O
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
saved_boundary	O
,	O
owl	int
->	O
boundary	O
,	O
sizeof	O
(	O
saved_boundary	O
)	O
)	O
;	O
owl_make_domains	O
(	O
owl	int
,	O
NULL	O
)	O
;	O
owl_shapes	O
(	O
&	O
shape_patterns	O
,	O
moves	array(int)
,	O
other	O
,	O
owl	int
,	O
&	O
owl_attackpat_db	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	O
;	O
k	int
++	O
)	O
{	O
current_owl_data	O
=	O
owl	int
;	O
if	O
(	O
!	O
get_next_move_from_list	O
(	O
&	O
shape_patterns	O
,	O
other	O
,	O
moves	array(int)
,	O
1	int
,	O
owl	int
)	O
)	O
break	O
;	O
else	O
{	O
int	O
mpos	O
=	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
;	O
if	O
(	O
mpos	O
!=	O
NO_MOVE	O
&&	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
>	O
0	int
)	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
mpos	O
,	O
other	O
,	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
,	O
target	int
)	O
)	O
{	O
int	O
pos	int
;	O
int	O
origin	int
=	O
NO_MOVE	O
;	O
owl	int
->	O
lunches_are_current	O
=	O
0	int
;	O
owl_update_boundary_marks	O
(	O
mpos	O
,	O
owl	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
target	int
]	O
==	O
EMPTY	int
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
==	O
1	int
)	O
{	O
origin	int
=	O
find_origin	(int)->(int)
(	O
pos	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
origin	int
==	O
NO_MOVE	O
||	O
do_owl_attack	O
(	O
origin	int
,	O
NULL	O
,	O
NULL	O
,	O
owl	int
,	O
0	int
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
result	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
do_owl_attack	O
(	O
target	int
,	O
&	O
move2	*(int)
,	O
NULL	O
,	O
owl	int
,	O
0	int
)	O
==	O
WIN	O
)	O
{	O
move	*(int)
=	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
;	O
popgo	()->(void)
(	O
)	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
result	int
=	O
1	int
;	O
break	O
;	O
}	O
popgo	()->(void)
(	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
owl	int
->	O
boundary	O
,	O
saved_boundary	O
,	O
sizeof	O
(	O
saved_boundary	O
)	O
)	O
;	O
}	O
}	O
}	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"owl_threaten_attack %1m %1m %1m, result %d (%d, %d nodes, %f seconds)\n"	*(char)
,	O
target	int
,	O
move	*(int)
,	O
move2	*(int)
,	O
result	int
,	O
local_owl_node_counter	O
,	O
tactical_nodes	int
,	O
gg_cputime	O
(	O
)	O
-	O
start	O
)	O
;	O
store_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,array(char),int)->(void)
(	O
OWL_THREATEN_ATTACK	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
result	int
,	O
move	*(int)
,	O
move2	*(int)
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	*(char)
,	O
board	*(char)
[	O
target	int
]	O
)	O
;	O
if	O
(	O
attack1	*(int)
)	O
*	O
attack1	*(int)
=	O
move	*(int)
;	O
if	O
(	O
attack2	*(int)
)	O
*	O
attack2	*(int)
=	O
move2	*(int)
;	O
close_pattern_list	O
(	O
other	O
,	O
&	O
shape_patterns	O
)	O
;	O
return	O
result	int
;	O
}	O
int	O
owl_defend	(int,*(int),*(int),*(int))->(int)
(	O
int	O
target	int
,	O
int	O
*	O
defense_point	*(int)
,	O
int	O
*	O
certain	*(int)
,	O
int	O
*	O
kworm	int
)	O
{	O
int	O
result	int
;	O
static	O
struct	O
local_owl_data	O
*	O
owl	int
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
double	O
start	O
=	O
0.0	int
;	O
int	O
tactical_nodes	int
;	O
int	O
move	*(int)
=	O
NO_MOVE	O
;	O
int	O
wpos	O
=	O
NO_MOVE	O
;	O
int	O
wid	O
=	O
MAX_GOAL_WORMS	O
;	O
result_certain	O
=	O
1	int
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
return	O
0	int
;	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_DEFEND	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
defense_point	*(int)
,	O
kworm	int
,	O
certain	*(int)
)	O
)	O
return	O
result	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	O
)	O
start	O
=	O
gg_cputime	O
(	O
)	O
;	O
TRACE	O
(	O
"owl_defend %1m\n"	*(char)
,	O
target	int
)	O
;	O
init_owl	O
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
owl_make_domains	O
(	O
owl	int
,	O
NULL	O
)	O
;	O
prepare_goal_list	O
(	O
target	int
,	O
owl	int
,	O
owl_goal_worm	O
,	O
&	O
goal_worms_computed	O
,	O
kworm	int
,	O
1	int
)	O
;	O
result	int
=	O
do_owl_defend	O
(	O
target	int
,	O
&	O
move	*(int)
,	O
&	O
wid	O
,	O
owl	int
,	O
0	int
)	O
;	O
finish_goal_list	O
(	O
&	O
goal_worms_computed	O
,	O
&	O
wpos	O
,	O
owl_goal_worm	O
,	O
wid	O
)	O
;	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"owl_defend %1m, result %d %1m (%d, %d nodes, %f seconds)\n"	*(char)
,	O
target	int
,	O
result	int
,	O
move	*(int)
,	O
local_owl_node_counter	O
,	O
tactical_nodes	int
,	O
gg_cputime	O
(	O
)	O
-	O
start	O
)	O
;	O
store_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,array(char),int)->(void)
(	O
OWL_DEFEND	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
result	int
,	O
move	*(int)
,	O
wpos	O
,	O
result_certain	O
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	*(char)
,	O
board	*(char)
[	O
target	int
]	O
)	O
;	O
if	O
(	O
defense_point	*(int)
)	O
*	O
defense_point	*(int)
=	O
move	*(int)
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
wpos	O
;	O
if	O
(	O
certain	*(int)
)	O
*	O
certain	*(int)
=	O
result_certain	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
do_owl_defend	O
(	O
int	O
str	int
,	O
int	O
*	O
move	*(int)
,	O
int	O
*	O
wormid	O
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
escape	O
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
str	int
]	O
;	O
struct	O
owl_move_data	O
shape_moves	O
[	O
MAX_MOVES	O
]	O
;	O
struct	O
owl_move_data	O
vital_moves	O
[	O
MAX_MOVES	O
]	O
;	O
struct	O
owl_move_data	O
*	O
moves	array(int)
;	O
struct	O
matched_patterns_list_data	O
shape_patterns	O
;	O
signed	O
char	O
mw	O
[	O
BOARDMAX	O
]	O
;	O
int	O
number_tried_moves	O
=	O
0	int
;	O
int	O
pass	O
;	O
int	O
k	int
;	O
int	O
savemove	O
=	O
0	int
;	O
int	O
saveworm	O
=	O
MAX_GOAL_WORMS	O
;	O
int	O
savecode	O
=	O
0	int
;	O
int	O
eyemin	O
=	O
-	O
1	int
;	O
int	O
eyemax	O
=	O
-	O
1	int
;	O
struct	O
eyevalue	struct(char,char,char,char)
probable_eyes	O
;	O
int	O
escape_route	float
;	O
const	O
char	O
*	O
live_reason	O
;	O
int	O
move_cutoff	O
;	O
int	O
xpos	O
;	O
int	O
value1	O
;	O
int	O
value2	O
;	O
int	O
this_variation_number	O
=	O
count_variations	int
-	O
1	int
;	O
SETUP_TRACE_INFO	O
(	O
"owl_defend"	*(char)
,	O
str	int
)	O
;	O
shape_patterns	O
.	O
initialized	O
=	O
0	int
;	O
str	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
if	O
(	O
tt_get	O
(	O
&	O
ttable	O
,	O
OWL_DEFEND	int
,	O
str	int
,	O
NO_MOVE	O
,	O
depth	int
-	O
stackp	int
,	O
NULL	O
,	O
&	O
value1	O
,	O
&	O
value2	O
,	O
&	O
xpos	O
)	O
==	O
2	int
)	O
{	O
TRACE_CACHED_RESULT	O
(	O
value1	O
,	O
xpos	O
)	O
;	O
if	O
(	O
move	*(int)
)	O
*	O
move	*(int)
=	O
xpos	O
;	O
if	O
(	O
value1	O
==	O
LOSS	O
)	O
{	O
if	O
(	O
wormid	O
)	O
{	O
if	O
(	O
goal_worms_computed	O
)	O
*	O
wormid	O
=	O
value2	O
;	O
else	O
*	O
wormid	O
=	O
MAX_GOAL_WORMS	O
;	O
}	O
}	O
if	O
(	O
value1	O
==	O
WIN	O
||	O
value1	O
==	O
LOSS	O
)	O
TRACE	O
(	O
"%oVariation %d: ALIVE (cached)\n"	*(char)
,	O
this_variation_number	O
)	O
;	O
else	O
TRACE	O
(	O
"%oVariation %d: DEAD (cached)\n"	*(char)
,	O
this_variation_number	O
)	O
;	O
SGFTRACE	O
(	O
xpos	O
,	O
value1	O
,	O
"cached"	*(char)
)	O
;	O
return	O
value1	O
;	O
}	O
escape_route	float
=	O
owl_escape_route	O
(	O
owl	int
)	O
;	O
if	O
(	O
stackp	int
>	O
2	int
&&	O
escape_route	float
>=	O
5	int
)	O
{	O
TRACE	O
(	O
"%oVariation %d: ALIVE (escaped)\n"	*(char)
,	O
this_variation_number	O
)	O
;	O
SGFTRACE	O
(	O
0	int
,	O
WIN	O
,	O
"escaped"	*(char)
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
0	int
,	O
WIN	O
)	O
;	O
}	O
if	O
(	O
reading_limit_reached	O
(	O
&	O
live_reason	O
,	O
this_variation_number	O
)	O
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
WIN	O
,	O
live_reason	O
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
0	int
,	O
WIN	O
)	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
mw	O
,	O
0	int
,	O
sizeof	O
(	O
mw	O
)	O
)	O
;	O
local_owl_node_counter	O
++	O
;	O
global_owl_node_counter	O
++	O
;	O
current_owl_data	O
=	O
owl	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
owl	int
->	O
safe_move_cache	O
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
safe_move_cache	O
)	O
)	O
;	O
if	O
(	O
escape	O
<	O
MAX_ESCAPE	O
)	O
{	O
if	O
(	O
owl_estimate_life	O
(	O
owl	int
,	O
NULL	O
,	O
vital_moves	O
,	O
&	O
live_reason	O
,	O
0	int
,	O
&	O
probable_eyes	O
,	O
&	O
eyemin	O
,	O
&	O
eyemax	O
)	O
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
WIN	O
,	O
live_reason	O
)	O
;	O
TRACE	O
(	O
"%oVariation %d: ALIVE (%s)\n"	*(char)
,	O
this_variation_number	O
,	O
live_reason	O
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
0	int
,	O
WIN	O
)	O
;	O
}	O
}	O
else	O
{	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
owl	int
->	O
my_eye	O
,	O
owl	int
->	O
restore_from	O
->	O
my_eye	O
,	O
sizeof	O
(	O
owl	int
->	O
my_eye	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
owl	int
->	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
,	O
owl	int
->	O
restore_from	O
->	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
,	O
sizeof	O
(	O
owl	int
->	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
)	O
)	O
;	O
vital_moves	O
[	O
0	int
]	O
.	O
pos	int
=	O
0	int
;	O
vital_moves	O
[	O
0	int
]	O
.	O
value	*(char)
=	O
-	O
1	int
;	O
set_eyevalue	(*(struct(char,char,char,char)),int,int,int,int)->(void)
(	O
&	O
probable_eyes	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
for	O
(	O
pass	O
=	O
0	int
;	O
pass	O
<	O
4	int
;	O
pass	O
++	O
)	O
{	O
moves	array(int)
=	O
NULL	O
;	O
move_cutoff	O
=	O
1	int
;	O
current_owl_data	O
=	O
owl	int
;	O
switch	O
(	O
pass	O
)	O
{	O
case	O
1	int
:	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
number_tried_moves	O
>	O
0	int
)	O
continue	O
;	O
owl_shapes	O
(	O
&	O
shape_patterns	O
,	O
shape_moves	O
,	O
color	int
,	O
owl	int
,	O
&	O
owl_defendpat_db	O
)	O
;	O
moves	array(int)
=	O
shape_moves	O
;	O
break	O
;	O
case	O
0	int
:	O
case	O
2	int
:	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
number_tried_moves	O
>	O
0	int
)	O
continue	O
;	O
moves	array(int)
=	O
vital_moves	O
;	O
if	O
(	O
pass	O
==	O
0	int
||	O
stackp	int
>	O
owl_distrust_depth	int
)	O
{	O
if	O
(	O
stackp	int
==	O
0	int
)	O
move_cutoff	O
=	O
70	int
;	O
else	O
if	O
(	O
eyemin	O
+	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes	O
)	O
>	O
3	int
)	O
move_cutoff	O
=	O
25	int
;	O
else	O
if	O
(	O
eyemin	O
+	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes	O
)	O
>=	O
3	int
)	O
move_cutoff	O
=	O
35	int
;	O
else	O
move_cutoff	O
=	O
45	int
;	O
}	O
if	O
(	O
eyemax	O
<	O
2	int
&&	O
stackp	int
>	O
2	int
)	O
move_cutoff	O
=	O
99	int
;	O
break	O
;	O
case	O
3	int
:	O
{	O
int	O
goalcount	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
BOARDMIN	O
;	O
k	int
<	O
BOARDMAX	O
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
k	int
)	O
)	O
goalcount	O
+=	O
owl	int
->	O
goal	*(char)
[	O
k	int
]	O
;	O
if	O
(	O
goalcount	O
<	O
5	int
)	O
{	O
int	O
dpos	O
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
attack_and_defend	(int,*(int),*(int),*(int),*(int))->(int)
(	O
str	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
dpos	O
)	O
&&	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
dpos	O
,	O
color	int
,	O
2	int
,	O
NULL	O
)	O
>	O
1	int
||	O
does_capture_something	(int,int)->(int)
(	O
dpos	O
,	O
color	int
)	O
)	O
)	O
{	O
TRACE	O
(	O
"Found tactical defense for %1m at %1m.\n"	*(char)
,	O
str	int
,	O
dpos	O
)	O
;	O
set_single_owl_move	O
(	O
shape_moves	O
,	O
dpos	O
,	O
"tactical_defense"	*(char)
)	O
;	O
moves	array(int)
=	O
shape_moves	O
;	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
}	O
if	O
(	O
!	O
moves	array(int)
)	O
continue	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	O
;	O
k	int
++	O
)	O
{	O
int	O
mpos	O
;	O
int	O
ko_move	O
=	O
-	O
1	int
;	O
int	O
new_escape	O
;	O
int	O
wid	O
=	O
MAX_GOAL_WORMS	O
;	O
if	O
(	O
stackp	int
>	O
owl_branch_depth	int
&&	O
k	int
>	O
0	int
)	O
break	O
;	O
current_owl_data	O
=	O
owl	int
;	O
if	O
(	O
pass	O
==	O
1	int
)	O
{	O
if	O
(	O
!	O
get_next_move_from_list	O
(	O
&	O
shape_patterns	O
,	O
color	int
,	O
shape_moves	O
,	O
move_cutoff	O
,	O
owl	int
)	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
<	O
move_cutoff	O
)	O
break	O
;	O
mpos	O
=	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
;	O
modify_eyefilling_move	O
(	O
&	O
mpos	O
,	O
color	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
mpos	O
)	O
;	O
if	O
(	O
mw	O
[	O
mpos	O
]	O
)	O
continue	O
;	O
if	O
(	O
!	O
komaster_trymove	(int,int,*(char),int,*(int),int)->(int)
(	O
mpos	O
,	O
color	int
,	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
,	O
str	int
,	O
&	O
ko_move	O
,	O
savecode	O
==	O
0	int
)	O
)	O
continue	O
;	O
new_escape	O
=	O
escape	O
;	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
escape	O
)	O
new_escape	O
++	O
;	O
TRACE	O
(	O
"Trying %C %1m. Escape = %d. Current stack: "	*(char)
,	O
color	int
,	O
mpos	O
,	O
escape	O
)	O
;	O
if	O
(	O
verbose	int
)	O
dump_stack	()->(void)
(	O
)	O
;	O
push_owl	O
(	O
&	O
owl	int
)	O
;	O
mw	O
[	O
mpos	O
]	O
=	O
1	int
;	O
number_tried_moves	O
++	O
;	O
owl_update_goal	O
(	O
mpos	O
,	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
,	O
moves	array(int)
[	O
k	int
]	O
.	O
lunch	int
,	O
owl	int
,	O
0	int
,	O
moves	array(int)
[	O
k	int
]	O
.	O
pattern_data	O
)	O
;	O
mark_goal_in_sgf	(array(char))->(void)
(	O
owl	int
->	O
goal	*(char)
)	O
;	O
if	O
(	O
!	O
ko_move	O
)	O
{	O
int	O
acode	int
=	O
do_owl_attack	O
(	O
str	int
,	O
NULL	O
,	O
&	O
wid	O
,	O
owl	int
,	O
new_escape	O
)	O
;	O
if	O
(	O
!	O
acode	int
)	O
{	O
pop_owl	O
(	O
&	O
owl	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
char	O
winstr	O
[	O
192	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
winstr	O
,	O
"defense effective)\n  (%d variations"	*(char)
,	O
count_variations	int
-	O
this_variation_number	O
)	O
;	O
SGFTRACE	O
(	O
mpos	O
,	O
WIN	O
,	O
winstr	O
)	O
;	O
}	O
close_pattern_list	O
(	O
color	int
,	O
&	O
shape_patterns	O
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
mpos	O
,	O
WIN	O
)	O
;	O
}	O
if	O
(	O
acode	int
==	O
GAIN	O
)	O
saveworm	O
=	O
wid	O
;	O
UPDATE_SAVED_KO_RESULT	O
(	O
savecode	O
,	O
savemove	O
,	O
acode	int
,	O
mpos	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
do_owl_attack	O
(	O
str	int
,	O
NULL	O
,	O
NULL	O
,	O
owl	int
,	O
new_escape	O
)	O
!=	O
WIN	O
)	O
{	O
savemove	O
=	O
mpos	O
;	O
savecode	O
=	O
KO_B	O
;	O
}	O
}	O
pop_owl	O
(	O
&	O
owl	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
}	O
close_pattern_list	O
(	O
color	int
,	O
&	O
shape_patterns	O
)	O
;	O
if	O
(	O
savecode	O
)	O
{	O
if	O
(	O
savecode	O
==	O
LOSS	O
)	O
{	O
SGFTRACE	O
(	O
savemove	O
,	O
savecode	O
,	O
"defense effective (loss) - B"	*(char)
)	O
;	O
if	O
(	O
wormid	O
)	O
*	O
wormid	O
=	O
saveworm	O
;	O
READ_RETURN2	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
savemove	O
,	O
savecode	O
,	O
saveworm	O
)	O
;	O
}	O
else	O
{	O
SGFTRACE	O
(	O
savemove	O
,	O
savecode	O
,	O
"defense effective (ko) - B"	*(char)
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
savemove	O
,	O
savecode	O
)	O
;	O
}	O
}	O
if	O
(	O
number_tried_moves	O
==	O
0	int
&&	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
probable_eyes	O
)	O
>=	O
2	int
)	O
{	O
SGFTRACE	O
(	O
0	int
,	O
WIN	O
,	O
"genus probably >= 2"	*(char)
)	O
;	O
READ_RETURN	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
,	O
move	*(int)
,	O
0	int
,	O
WIN	O
)	O
;	O
}	O
if	O
(	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
char	O
winstr	O
[	O
196	int
]	O
;	O
int	O
print_genus	O
=	O
eyemin	O
==	O
1	int
?	O
1	int
:	O
0	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
winstr	O
,	O
"defense failed - genus %d)\n  (%d variations"	*(char)
,	O
print_genus	O
,	O
count_variations	int
-	O
this_variation_number	O
)	O
;	O
SGFTRACE	O
(	O
0	int
,	O
0	int
,	O
winstr	O
)	O
;	O
}	O
READ_RETURN0	O
(	O
OWL_DEFEND	int
,	O
str	int
,	O
depth	int
-	O
stackp	int
)	O
;	O
}	O
int	O
owl_threaten_defense	(int,*(int),*(int))->(int)
(	O
int	O
target	int
,	O
int	O
*	O
defend1	*(int)
,	O
int	O
*	O
defend2	*(int)
)	O
{	O
struct	O
owl_move_data	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
;	O
int	O
k	int
;	O
int	O
color	int
=	O
board	*(char)
[	O
target	int
]	O
;	O
int	O
result	int
=	O
0	int
;	O
struct	O
local_owl_data	O
*	O
owl	int
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
signed	O
char	O
saved_goal	O
[	O
BOARDMAX	O
]	O
;	O
double	O
start	O
=	O
0.0	int
;	O
int	O
tactical_nodes	int
;	O
int	O
move	*(int)
=	O
0	int
;	O
int	O
move2	*(int)
=	O
0	int
;	O
struct	O
matched_patterns_list_data	O
shape_patterns	O
;	O
shape_patterns	O
.	O
initialized	O
=	O
0	int
;	O
result_certain	O
=	O
1	int
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
return	O
0	int
;	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_THREATEN_DEFENSE	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
defend1	*(int)
,	O
defend2	*(int)
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	O
)	O
start	O
=	O
gg_cputime	O
(	O
)	O
;	O
TRACE	O
(	O
"owl_threaten_defense %1m\n"	*(char)
,	O
target	int
)	O
;	O
init_owl	O
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
saved_goal	O
,	O
owl	int
->	O
goal	*(char)
,	O
sizeof	O
(	O
saved_goal	O
)	O
)	O
;	O
owl_make_domains	O
(	O
owl	int
,	O
NULL	O
)	O
;	O
owl_shapes	O
(	O
&	O
shape_patterns	O
,	O
moves	array(int)
,	O
color	int
,	O
owl	int
,	O
&	O
owl_defendpat_db	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	O
;	O
k	int
++	O
)	O
{	O
current_owl_data	O
=	O
owl	int
;	O
if	O
(	O
!	O
get_next_move_from_list	O
(	O
&	O
shape_patterns	O
,	O
color	int
,	O
moves	array(int)
,	O
1	int
,	O
owl	int
)	O
)	O
break	O
;	O
else	O
{	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
!=	O
NO_MOVE	O
&&	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
>	O
0	int
)	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
,	O
color	int
,	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
,	O
target	int
)	O
)	O
{	O
owl	int
->	O
lunches_are_current	O
=	O
0	int
;	O
owl_update_goal	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
,	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
,	O
moves	array(int)
[	O
k	int
]	O
.	O
lunch	int
,	O
owl	int
,	O
0	int
,	O
moves	array(int)
[	O
k	int
]	O
.	O
pattern_data	O
)	O
;	O
if	O
(	O
do_owl_defend	O
(	O
target	int
,	O
&	O
move2	*(int)
,	O
NULL	O
,	O
owl	int
,	O
0	int
)	O
==	O
WIN	O
)	O
{	O
move	*(int)
=	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
;	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
move2	*(int)
!=	O
NO_MOVE	O
&&	O
IS_STONE	O
(	O
board	*(char)
[	O
move2	*(int)
]	O
)	O
)	O
move2	*(int)
=	O
NO_MOVE	O
;	O
result	int
=	O
WIN	O
;	O
break	O
;	O
}	O
else	O
popgo	()->(void)
(	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
owl	int
->	O
goal	*(char)
,	O
saved_goal	O
,	O
sizeof	O
(	O
saved_goal	O
)	O
)	O
;	O
}	O
}	O
}	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"owl_threaten_defense %1m %1m %1m, result %d (%d, %d nodes, %f seconds)\n"	*(char)
,	O
target	int
,	O
move	*(int)
,	O
move2	*(int)
,	O
result	int
,	O
local_owl_node_counter	O
,	O
tactical_nodes	int
,	O
gg_cputime	O
(	O
)	O
-	O
start	O
)	O
;	O
store_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,array(char),int)->(void)
(	O
OWL_THREATEN_DEFENSE	int
,	O
target	int
,	O
0	int
,	O
0	int
,	O
result	int
,	O
move	*(int)
,	O
move2	*(int)
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	*(char)
,	O
board	*(char)
[	O
target	int
]	O
)	O
;	O
if	O
(	O
defend1	*(int)
)	O
*	O
defend1	*(int)
=	O
move	*(int)
;	O
if	O
(	O
defend2	*(int)
)	O
*	O
defend2	*(int)
=	O
move2	*(int)
;	O
close_pattern_list	O
(	O
color	int
,	O
&	O
shape_patterns	O
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
owl_estimate_life	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
struct	O
local_owl_data	O
*	O
second_owl	O
,	O
struct	O
owl_move_data	O
vital_moves	O
[	O
MAX_MOVES	O
]	O
,	O
const	O
char	O
*	O
*	O
live_reason	O
,	O
int	O
does_attack	(int,int)->(int)
,	O
struct	O
eyevalue	struct(char,char,char,char)
*	O
probable_eyes	O
,	O
int	O
*	O
eyemin	O
,	O
int	O
*	O
eyemax	O
)	O
{	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
struct	O
owl_move_data	O
dummy_moves	O
[	O
MAX_MOVES	O
]	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
owl_determine_life	O
(	O
owl	int
,	O
second_owl	O
,	O
does_attack	(int,int)->(int)
,	O
vital_moves	O
,	O
probable_eyes	O
,	O
eyemin	O
,	O
eyemax	O
)	O
;	O
matches_found	O
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
found_matches	O
,	O
0	int
,	O
sizeof	O
(	O
found_matches	O
)	O
)	O
;	O
if	O
(	O
get_level	()->(int)
(	O
)	O
>=	O
8	int
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
owl	int
->	O
safe_move_cache	O
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
safe_move_cache	O
)	O
)	O
;	O
if	O
(	O
!	O
does_attack	(int,int)->(int)
)	O
{	O
clear_owl_move_data	O
(	O
dummy_moves	O
)	O
;	O
matchpat	(*((int,int,*(struct),int,*(void))->(void)),int,*(struct),*(void),array(char))->(void)
(	O
owl_shapes_callback	O
,	O
other	O
,	O
&	O
owl_vital_apat_db	O
,	O
dummy_moves	O
,	O
owl	int
->	O
goal	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
probable_eyes	O
)	O
>=	O
2	int
)	O
matchpat	(*((int,int,*(struct),int,*(void))->(void)),int,*(struct),*(void),array(char))->(void)
(	O
owl_shapes_callback	O
,	O
other	O
,	O
&	O
owl_vital_apat_db	O
,	O
vital_moves	O
,	O
owl	int
->	O
goal	*(char)
)	O
;	O
}	O
if	O
(	O
(	O
debug	int
&	O
DEBUG_EYES	O
)	O
&&	O
(	O
debug	int
&	O
DEBUG_OWL	O
)	O
)	O
gprintf	(*(char))->(int)
(	O
"owl: eyemin=%d matches_found=%d\n"	*(char)
,	O
*	O
eyemin	O
,	O
matches_found	O
)	O
;	O
if	O
(	O
*	O
eyemin	O
>=	O
matches_found	O
)	O
*	O
eyemin	O
-=	O
matches_found	O
;	O
else	O
*	O
eyemin	O
=	O
0	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
if	O
(	O
*	O
eyemin	O
>=	O
2	int
||	O
(	O
*	O
eyemin	O
==	O
1	int
&&	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
probable_eyes	O
)	O
>=	O
4	int
)	O
||	O
(	O
stackp	int
>	O
owl_distrust_depth	int
&&	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
probable_eyes	O
)	O
>=	O
2	int
&&	O
!	O
matches_found	O
)	O
)	O
{	O
if	O
(	O
*	O
eyemin	O
>=	O
2	int
)	O
*	O
live_reason	O
=	O
"2 or more secure eyes"	*(char)
;	O
else	O
if	O
(	O
*	O
eyemin	O
==	O
1	int
&&	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
probable_eyes	O
)	O
>=	O
4	int
)	O
*	O
live_reason	O
=	O
"1 secure eye, likely >= 4"	*(char)
;	O
else	O
if	O
(	O
stackp	int
>	O
owl_distrust_depth	int
&&	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
probable_eyes	O
)	O
>=	O
2	int
&&	O
!	O
matches_found	O
)	O
*	O
live_reason	O
=	O
"getting deep, looks lively"	*(char)
;	O
else	O
gg_assert	O
(	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
does_attack	(int,int)->(int)
&&	O
(	O
*	O
eyemin	O
+	O
matches_found	O
>=	O
2	int
||	O
(	O
*	O
eyemin	O
+	O
matches_found	O
==	O
1	int
&&	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
probable_eyes	O
)	O
>=	O
4	int
)	O
||	O
(	O
stackp	int
>	O
owl_distrust_depth	int
&&	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
probable_eyes	O
)	O
>=	O
2	int
)	O
)	O
)	O
{	O
owl_add_move	O
(	O
vital_moves	O
,	O
dummy_moves	O
[	O
0	int
]	O
.	O
defense_pos	O
,	O
dummy_moves	O
[	O
0	int
]	O
.	O
value	*(char)
,	O
dummy_moves	O
[	O
0	int
]	O
.	O
name	short
,	O
SAME_DRAGON_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	O
,	O
NULL	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
owl_determine_life	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
struct	O
local_owl_data	O
*	O
second_owl	O
,	O
int	O
does_attack	(int,int)->(int)
,	O
struct	O
owl_move_data	O
*	O
moves	array(int)
,	O
struct	O
eyevalue	struct(char,char,char,char)
*	O
probable_eyes	O
,	O
int	O
*	O
eyemin	O
,	O
int	O
*	O
eyemax	O
)	O
{	O
int	O
color	int
=	O
owl	int
->	O
color	int
;	O
struct	O
eye_data	struct(int,int,int,int,struct(char,char,char,char),char,char,char)
*	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
owl	int
->	O
my_eye	O
;	O
int	O
mw	O
[	O
BOARDMAX	O
]	O
;	O
int	O
mz	O
[	O
BOARDMAX	O
]	O
;	O
int	O
vital_values	O
[	O
BOARDMAX	O
]	O
;	O
int	O
dummy_eyemin	O
=	O
0	int
;	O
int	O
dummy_eyemax	O
=	O
0	int
;	O
struct	O
eyevalue	struct(char,char,char,char)
eyevalue	struct(char,char,char,char)
;	O
struct	O
eyevalue	struct(char,char,char,char)
eyevalue_list	O
[	O
BOARDMAX	O
/	O
2	int
]	O
;	O
int	O
eyes_attack_points	O
[	O
BOARDMAX	O
/	O
2	int
]	O
;	O
int	O
pessimistic_min	*(int)
;	O
int	O
attack_point	*(int)
;	O
int	O
defense_point	*(int)
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
lunch	int
;	O
int	O
num_eyes	O
=	O
0	int
;	O
int	O
num_lunches	O
=	O
0	int
;	O
int	O
save_debug	O
=	O
debug	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
vital_values	O
,	O
0	int
,	O
sizeof	O
(	O
vital_values	O
)	O
)	O
;	O
if	O
(	O
!	O
eyemin	O
)	O
eyemin	O
=	O
&	O
dummy_eyemin	O
;	O
if	O
(	O
!	O
eyemax	O
)	O
eyemax	O
=	O
&	O
dummy_eyemax	O
;	O
*	O
eyemin	O
=	O
0	int
;	O
*	O
eyemax	O
=	O
0	int
;	O
if	O
(	O
!	O
(	O
debug	int
&	O
DEBUG_OWL	O
)	O
)	O
debug	int
&=	O
~	O
DEBUG_EYES	O
;	O
clear_owl_move_data	O
(	O
moves	array(int)
)	O
;	O
if	O
(	O
!	O
owl	int
->	O
lunches_are_current	O
)	O
owl_find_lunches	O
(	O
owl	int
)	O
;	O
if	O
(	O
0	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_LUNCHES	O
;	O
k	int
++	O
)	O
if	O
(	O
owl	int
->	O
lunch	int
[	O
k	int
]	O
!=	O
NO_MOVE	O
)	O
gprintf	(*(char))->(int)
(	O
"owl lunch %1m, attack %1m, defend %1m\n"	*(char)
,	O
owl	int
->	O
lunch	int
[	O
k	int
]	O
,	O
owl	int
->	O
lunch_attack_point	O
[	O
k	int
]	O
,	O
owl	int
->	O
lunch_defense_point	O
[	O
k	int
]	O
)	O
;	O
}	O
owl_make_domains	O
(	O
owl	int
,	O
second_owl	O
)	O
;	O
owl_find_relevant_eyespaces	O
(	O
owl	int
,	O
mw	O
,	O
mz	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
owl	int
->	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
[	O
pos	int
]	O
.	O
type	char
=	O
0	int
;	O
owl	int
->	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
[	O
pos	int
]	O
.	O
value	*(char)
=	O
10.0	int
;	O
}	O
}	O
find_half_and_false_eyes	(int,array(struct(int,int,int,int,struct(char,char,char,char),char,char,char)),array(struct(float,char,int,array(int),int,array(int))),array(int))->(void)
(	O
color	int
,	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
,	O
owl	int
->	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
,	O
mw	O
)	O
;	O
partition_eyespaces	(array(struct(int,int,int,int,struct(char,char,char,char),char,char,char)),int)->(void)
(	O
owl	int
->	O
my_eye	O
,	O
owl	int
->	O
color	int
)	O
;	O
owl_find_relevant_eyespaces	O
(	O
owl	int
,	O
mw	O
,	O
mz	O
)	O
;	O
set_eyevalue	(*(struct(char,char,char,char)),int,int,int,int)->(void)
(	O
probable_eyes	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
mw	O
[	O
pos	int
]	O
>	O
1	int
)	O
{	O
int	O
value	*(char)
=	O
0	int
;	O
const	O
char	O
*	O
reason	O
=	O
""	*(char)
;	O
compute_eyes_pessimistic	(int,*(struct(char,char,char,char)),*(int),*(int),*(int),array(struct(int,int,int,int,struct(char,char,char,char),char,char,char)),array(struct(float,char,int,array(int),int,array(int))))->(void)
(	O
pos	int
,	O
&	O
eyevalue	struct(char,char,char,char)
,	O
&	O
pessimistic_min	*(int)
,	O
&	O
attack_point	*(int)
,	O
&	O
defense_point	*(int)
,	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
,	O
owl	int
->	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
)	O
;	O
if	O
(	O
mw	O
[	O
pos	int
]	O
<	O
mz	O
[	O
pos	int
]	O
||	O
(	O
mw	O
[	O
pos	int
]	O
<	O
3	int
*	O
mz	O
[	O
pos	int
]	O
&&	O
mz	O
[	O
pos	int
]	O
>	O
5	int
)	O
)	O
pessimistic_min	*(int)
=	O
0	int
;	O
eyes_attack_points	O
[	O
num_eyes	O
]	O
=	O
NO_MOVE	O
;	O
eyevalue_list	O
[	O
num_eyes	O
]	O
=	O
eyevalue	struct(char,char,char,char)
;	O
*	O
eyemin	O
+=	O
pessimistic_min	*(int)
;	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
pos	int
]	O
.	O
value	*(char)
=	O
eyevalue	struct(char,char,char,char)
;	O
if	O
(	O
eye_move_urgency	(*(struct(char,char,char,char)))->(int)
(	O
&	O
eyevalue	struct(char,char,char,char)
)	O
)	O
{	O
value	*(char)
=	O
50	int
;	O
if	O
(	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
eyevalue	struct(char,char,char,char)
)	O
-	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
eyevalue	struct(char,char,char,char)
)	O
==	O
2	int
)	O
value	*(char)
=	O
70	int
;	O
else	O
if	O
(	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
eyevalue	struct(char,char,char,char)
)	O
-	O
pessimistic_min	*(int)
==	O
2	int
)	O
value	*(char)
=	O
60	int
;	O
reason	O
=	O
"vital move"	*(char)
;	O
}	O
else	O
if	O
(	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
eyevalue	struct(char,char,char,char)
)	O
!=	O
pessimistic_min	*(int)
)	O
{	O
if	O
(	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
eyevalue	struct(char,char,char,char)
)	O
-	O
pessimistic_min	*(int)
==	O
2	int
)	O
value	*(char)
=	O
40	int
;	O
else	O
value	*(char)
=	O
30	int
;	O
reason	O
=	O
"marginal eye space"	*(char)
;	O
}	O
if	O
(	O
value	*(char)
>	O
0	int
)	O
{	O
if	O
(	O
does_attack	(int,int)->(int)
&&	O
attack_point	*(int)
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
vital_values	O
[	O
attack_point	*(int)
]	O
>	O
0	int
)	O
{	O
value	*(char)
+=	O
vital_values	O
[	O
attack_point	*(int)
]	O
;	O
if	O
(	O
value	*(char)
>	O
98	int
)	O
value	*(char)
=	O
98	int
;	O
}	O
TRACE	O
(	O
"%s at %1m, score %d (eye at %1m, value %s, pessimistic_min %d)\n"	*(char)
,	O
reason	O
,	O
attack_point	*(int)
,	O
value	*(char)
,	O
pos	int
,	O
eyevalue_to_string	(*(struct(char,char,char,char)))->(*(char))
(	O
&	O
eyevalue	struct(char,char,char,char)
)	O
,	O
pessimistic_min	*(int)
)	O
;	O
if	O
(	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
attack_point	*(int)
]	O
.	O
marginal	char
&&	O
modify_stupid_eye_vital_point	O
(	O
owl	int
,	O
&	O
attack_point	*(int)
,	O
1	int
)	O
)	O
TRACE	O
(	O
"vital point looked stupid, moved it to %1m\n"	*(char)
,	O
attack_point	*(int)
)	O
;	O
if	O
(	O
attack_point	*(int)
!=	O
NO_MOVE	O
)	O
{	O
owl_add_move	O
(	O
moves	array(int)
,	O
attack_point	*(int)
,	O
value	*(char)
,	O
reason	O
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	O
,	O
NULL	O
)	O
;	O
vital_values	O
[	O
attack_point	*(int)
]	O
=	O
value	*(char)
;	O
eyes_attack_points	O
[	O
num_eyes	O
]	O
=	O
attack_point	*(int)
;	O
}	O
}	O
else	O
if	O
(	O
!	O
does_attack	(int,int)->(int)
&&	O
defense_point	*(int)
!=	O
NO_MOVE	O
&&	O
board	*(char)
[	O
defense_point	*(int)
]	O
==	O
EMPTY	int
&&	O
(	O
!	O
liberty_of_goal	O
(	O
defense_point	*(int)
,	O
owl	int
)	O
||	O
!	O
is_self_atari	(int,int)->(int)
(	O
defense_point	*(int)
,	O
color	int
)	O
||	O
is_ko	(int,int,*(int))->(int)
(	O
defense_point	*(int)
,	O
color	int
,	O
NULL	O
)	O
||	O
safe_move	(int,int)->(int)
(	O
defense_point	*(int)
,	O
color	int
)	O
!=	O
0	int
)	O
)	O
{	O
if	O
(	O
vital_values	O
[	O
defense_point	*(int)
]	O
>	O
0	int
)	O
{	O
value	*(char)
+=	O
vital_values	O
[	O
defense_point	*(int)
]	O
;	O
if	O
(	O
value	*(char)
>	O
98	int
)	O
value	*(char)
=	O
98	int
;	O
}	O
TRACE	O
(	O
"%s at %1m, score %d (eye at %1m, value %s, pessimistic_min %d)\n"	*(char)
,	O
reason	O
,	O
defense_point	*(int)
,	O
value	*(char)
,	O
pos	int
,	O
eyevalue_to_string	(*(struct(char,char,char,char)))->(*(char))
(	O
&	O
eyevalue	struct(char,char,char,char)
)	O
,	O
pessimistic_min	*(int)
)	O
;	O
if	O
(	O
(	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
defense_point	*(int)
]	O
.	O
marginal	char
||	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
defense_point	*(int)
]	O
.	O
origin	int
!=	O
pos	int
)	O
&&	O
modify_stupid_eye_vital_point	O
(	O
owl	int
,	O
&	O
defense_point	*(int)
,	O
0	int
)	O
)	O
TRACE	O
(	O
"vital point looked stupid, moved it to %1m\n"	*(char)
,	O
defense_point	*(int)
)	O
;	O
if	O
(	O
defense_point	*(int)
!=	O
NO_MOVE	O
)	O
{	O
owl_add_move	O
(	O
moves	array(int)
,	O
defense_point	*(int)
,	O
value	*(char)
,	O
reason	O
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	O
,	O
NULL	O
)	O
;	O
vital_values	O
[	O
defense_point	*(int)
]	O
=	O
value	*(char)
;	O
}	O
}	O
}	O
num_eyes	O
++	O
;	O
}	O
}	O
{	O
for	O
(	O
lunch	int
=	O
0	int
;	O
(	O
lunch	int
<	O
MAX_LUNCHES	O
)	O
;	O
lunch	int
++	O
)	O
if	O
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
!=	O
NO_MOVE	O
&&	O
owl	int
->	O
lunch_defense_point	O
[	O
lunch	int
]	O
!=	O
NO_MOVE	O
)	O
{	O
int	O
value	*(char)
=	O
0	int
;	O
int	O
lunch_min	O
;	O
int	O
lunch_probable	O
;	O
int	O
lunch_max	O
;	O
struct	O
eyevalue	struct(char,char,char,char)
e	*(struct(char,char,char,char))
;	O
sniff_lunch	O
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
&	O
lunch_min	O
,	O
&	O
lunch_probable	O
,	O
&	O
lunch_max	O
,	O
owl	int
)	O
;	O
set_eyevalue	(*(struct(char,char,char,char)),int,int,int,int)->(void)
(	O
&	O
e	*(struct(char,char,char,char))
,	O
0	int
,	O
0	int
,	O
lunch_probable	O
,	O
lunch_probable	O
)	O
;	O
*	O
eyemax	O
+=	O
lunch_max	O
;	O
if	O
(	O
lunch_probable	O
==	O
0	int
)	O
{	O
if	O
(	O
countstones	(int)->(int)
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
)	O
==	O
1	int
)	O
continue	O
;	O
value	*(char)
=	O
20	int
;	O
}	O
else	O
if	O
(	O
lunch_probable	O
==	O
1	int
&&	O
lunch_max	O
==	O
1	int
)	O
value	*(char)
=	O
60	int
+	O
countstones	(int)->(int)
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
)	O
;	O
else	O
if	O
(	O
lunch_probable	O
==	O
1	int
&&	O
lunch_max	O
==	O
2	int
)	O
value	*(char)
=	O
70	int
+	O
countstones	(int)->(int)
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
)	O
;	O
else	O
value	*(char)
=	O
75	int
+	O
countstones	(int)->(int)
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
)	O
;	O
if	O
(	O
owl	int
->	O
lunch_attack_code	O
[	O
lunch	int
]	O
!=	O
WIN	O
)	O
value	*(char)
-=	O
10	int
;	O
if	O
(	O
does_attack	(int,int)->(int)
)	O
{	O
defense_point	*(int)
=	O
improve_lunch_defense	O
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
owl	int
->	O
lunch_defense_point	O
[	O
lunch	int
]	O
)	O
;	O
if	O
(	O
vital_values	O
[	O
defense_point	*(int)
]	O
)	O
{	O
int	O
ne	O
;	O
for	O
(	O
ne	O
=	O
0	int
;	O
ne	O
<	O
num_eyes	O
-	O
num_lunches	O
;	O
ne	O
++	O
)	O
if	O
(	O
eyes_attack_points	O
[	O
ne	O
]	O
==	O
defense_point	*(int)
)	O
break	O
;	O
gg_assert	O
(	O
ne	O
<	O
num_eyes	O
-	O
num_lunches	O
)	O
;	O
add_eyevalues	(*(struct(char,char,char,char)),*(struct(char,char,char,char)),*(struct(char,char,char,char)))->(void)
(	O
&	O
eyevalue_list	O
[	O
ne	O
]	O
,	O
&	O
e	*(struct(char,char,char,char))
,	O
&	O
eyevalue_list	O
[	O
ne	O
]	O
)	O
;	O
eyevalue_list	O
[	O
ne	O
]	O
.	O
a	char
=	O
0	int
;	O
eyevalue_list	O
[	O
ne	O
]	O
.	O
b	char
=	O
0	int
;	O
}	O
else	O
{	O
num_lunches	O
++	O
;	O
eyevalue_list	O
[	O
num_eyes	O
++	O
]	O
=	O
e	*(struct(char,char,char,char))
;	O
}	O
TRACE	O
(	O
"save lunch at %1m with %1m, score %d, probable eye %d, max eye %d\n"	*(char)
,	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
defense_point	*(int)
,	O
value	*(char)
,	O
lunch_probable	O
,	O
lunch_max	O
)	O
;	O
owl_add_move	O
(	O
moves	array(int)
,	O
defense_point	*(int)
,	O
value	*(char)
,	O
"save lunch"	*(char)
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	O
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
attack_point	*(int)
=	O
improve_lunch_attack	O
(	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
owl	int
->	O
lunch_attack_point	O
[	O
lunch	int
]	O
)	O
;	O
TRACE	O
(	O
"eat lunch at %1m with %1m, score %d, probable eye %d, max eye %d\n"	*(char)
,	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
attack_point	*(int)
,	O
value	*(char)
,	O
lunch_probable	O
,	O
lunch_max	O
)	O
;	O
if	O
(	O
owl	int
->	O
lunch_attack_code	O
[	O
lunch	int
]	O
==	O
WIN	O
||	O
is_illegal_ko_capture	(int,int)->(int)
(	O
attack_point	*(int)
,	O
owl	int
->	O
color	int
)	O
)	O
owl_add_move	O
(	O
moves	array(int)
,	O
attack_point	*(int)
,	O
value	*(char)
,	O
"eat lunch"	*(char)
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
owl	int
->	O
lunch	int
[	O
lunch	int
]	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	O
,	O
NULL	O
)	O
;	O
else	O
owl_add_move	O
(	O
moves	array(int)
,	O
attack_point	*(int)
,	O
value	*(char)
,	O
"eat lunch"	*(char)
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
NO_MOVE	O
,	O
0	int
,	O
NO_MOVE	O
,	O
MAX_MOVES	O
,	O
NULL	O
)	O
;	O
num_lunches	O
++	O
;	O
eyevalue_list	O
[	O
num_eyes	O
++	O
]	O
=	O
e	*(struct(char,char,char,char))
;	O
}	O
}	O
}	O
{	O
int	O
ne	O
;	O
for	O
(	O
ne	O
=	O
0	int
;	O
ne	O
<	O
num_eyes	O
-	O
num_lunches	O
;	O
ne	O
++	O
)	O
add_eyevalues	(*(struct(char,char,char,char)),*(struct(char,char,char,char)),*(struct(char,char,char,char)))->(void)
(	O
probable_eyes	O
,	O
&	O
eyevalue_list	O
[	O
ne	O
]	O
,	O
probable_eyes	O
)	O
;	O
*	O
eyemax	O
+=	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
probable_eyes	O
)	O
;	O
if	O
(	O
num_eyes	O
-	O
num_lunches	O
>	O
1	int
&&	O
max_eye_threat	(*(struct(char,char,char,char)))->(int)
(	O
probable_eyes	O
)	O
>	O
1	int
)	O
*	O
eyemax	O
+=	O
1	int
;	O
for	O
(	O
;	O
ne	O
<	O
num_eyes	O
;	O
ne	O
++	O
)	O
add_eyevalues	(*(struct(char,char,char,char)),*(struct(char,char,char,char)),*(struct(char,char,char,char)))->(void)
(	O
probable_eyes	O
,	O
&	O
eyevalue_list	O
[	O
ne	O
]	O
,	O
probable_eyes	O
)	O
;	O
}	O
debug	int
=	O
save_debug	O
;	O
}	O
static	O
void	O
owl_find_relevant_eyespaces	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
mw	O
[	O
BOARDMAX	O
]	O
,	O
int	O
mz	O
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
eye_color	int
;	O
int	O
k	int
;	O
struct	O
eye_data	struct(int,int,int,int,struct(char,char,char,char),char,char,char)
*	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
owl	int
->	O
my_eye	O
;	O
if	O
(	O
owl	int
->	O
color	int
==	O
WHITE	int
)	O
eye_color	int
=	O
WHITE	int
;	O
else	O
eye_color	int
=	O
BLACK	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
mw	O
,	O
0	int
,	O
BOARDMAX	O
*	O
sizeof	O
(	O
mw	O
[	O
0	int
]	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mz	O
,	O
0	int
,	O
BOARDMAX	O
*	O
sizeof	O
(	O
mz	O
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
owl	int
->	O
color	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
pos2	int
]	O
.	O
color	int
==	O
eye_color	int
&&	O
!	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
pos2	int
]	O
.	O
marginal	char
)	O
{	O
if	O
(	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
)	O
mw	O
[	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
pos2	int
]	O
.	O
origin	int
]	O
++	O
;	O
else	O
mz	O
[	O
eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
[	O
pos2	int
]	O
.	O
origin	int
]	O
++	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
int	O
modify_stupid_eye_vital_point	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
*	O
vital_point	O
,	O
int	O
is_attack_point	O
)	O
{	O
int	O
up	O
;	O
int	O
right	O
;	O
int	O
k	int
;	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
up	O
=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
*	O
vital_point	O
-	O
up	O
)	O
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
*	O
vital_point	O
+	O
up	O
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
right	O
=	O
delta	array(int)
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
*	O
vital_point	O
+	O
right	O
]	O
!=	O
EMPTY	int
||	O
board	*(char)
[	O
*	O
vital_point	O
-	O
right	O
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
*	O
vital_point	O
+	O
2	int
*	O
up	O
]	O
!=	O
EMPTY	int
||	O
board	*(char)
[	O
*	O
vital_point	O
+	O
up	O
+	O
right	O
]	O
!=	O
EMPTY	int
||	O
board	*(char)
[	O
*	O
vital_point	O
+	O
up	O
-	O
right	O
]	O
!=	O
EMPTY	int
)	O
{	O
*	O
vital_point	O
+=	O
up	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
is_attack_point	O
)	O
{	O
if	O
(	O
approxlib	(int,int,int,*(int))->(int)
(	O
*	O
vital_point	O
,	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
,	O
1	int
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
for	O
(	O
k	int
=	O
4	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
*	O
vital_point	O
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
==	O
1	int
)	O
{	O
findlib	(int,int,*(int))->(int)
(	O
pos	int
,	O
1	int
,	O
vital_point	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
is_attack_point	O
&&	O
does_capture_something	(int,int)->(int)
(	O
*	O
vital_point	O
,	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
)	O
&&	O
accuratelib	(int,int,int,*(int))->(int)
(	O
*	O
vital_point	O
,	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
,	O
2	int
,	O
libs	*(int)
)	O
==	O
1	int
&&	O
!	O
attack	(int,*(int))->(int)
(	O
libs	*(int)
[	O
0	int
]	O
,	O
NULL	O
)	O
)	O
{	O
*	O
vital_point	O
=	O
NO_MOVE	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
modify_eyefilling_move	O
(	O
int	O
*	O
move	*(int)
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
r	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
*	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
)	O
&&	O
board	*(char)
[	O
*	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
]	O
!=	O
color	int
)	O
return	O
0	int
;	O
for	O
(	O
r	O
=	O
4	int
;	O
r	O
<	O
8	int
;	O
r	O
++	O
)	O
if	O
(	O
board	*(char)
[	O
*	O
move	*(int)
+	O
delta	array(int)
[	O
r	O
]	O
]	O
==	O
other	O
&&	O
countlib	(int)->(int)
(	O
*	O
move	*(int)
+	O
delta	array(int)
[	O
r	O
]	O
)	O
==	O
1	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
*	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
countlib	(int)->(int)
(	O
*	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
)	O
==	O
1	int
&&	O
!	O
adjacent_strings	(int,int)->(int)
(	O
*	O
move	*(int)
+	O
delta	array(int)
[	O
r	O
]	O
,	O
*	O
move	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
)	O
)	O
break	O
;	O
if	O
(	O
k	int
==	O
4	int
)	O
{	O
int	O
new_move	O
;	O
findlib	(int,int,*(int))->(int)
(	O
*	O
move	*(int)
+	O
delta	array(int)
[	O
r	O
]	O
,	O
1	int
,	O
&	O
new_move	O
)	O
;	O
TRACE	O
(	O
"Changing eyefilling move at %1m to capture at %1m.\n"	*(char)
,	O
*	O
move	*(int)
,	O
new_move	O
)	O
;	O
*	O
move	*(int)
=	O
new_move	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
owl_shapes	O
(	O
struct	O
matched_patterns_list_data	O
*	O
pattern_list	O
,	O
struct	O
owl_move_data	O
moves	array(int)
[	O
MAX_MOVES	O
]	O
,	O
int	O
color	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
struct	O
pattern_db	O
*	O
type	char
)	O
{	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
current_owl_data	O
=	O
owl	int
;	O
clear_owl_move_data	O
(	O
moves	array(int)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
owl	int
->	O
safe_move_cache	O
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
safe_move_cache	O
)	O
)	O
;	O
init_pattern_list	O
(	O
pattern_list	O
)	O
;	O
matchpat	(*((int,int,*(struct),int,*(void))->(void)),int,*(struct),*(void),array(char))->(void)
(	O
collect_owl_shapes_callbacks	O
,	O
color	int
,	O
type	char
,	O
pattern_list	O
,	O
owl	int
->	O
goal	*(char)
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
}	O
static	O
int	O
check_pattern_hard	O
(	O
int	O
move	*(int)
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
,	O
int	O
ll	O
)	O
{	O
int	O
constraint_checked	O
=	O
0	int
;	O
int	O
safe_move_checked	O
=	O
0	int
;	O
if	O
(	O
!	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_s	O
)	O
)	O
if	O
(	O
current_owl_data	O
->	O
safe_move_cache	O
[	O
move	*(int)
]	O
)	O
{	O
if	O
(	O
current_owl_data	O
->	O
safe_move_cache	O
[	O
move	*(int)
]	O
==	O
1	int
)	O
return	O
0	int
;	O
else	O
safe_move_checked	O
=	O
1	int
;	O
}	O
if	O
(	O
(	O
pattern	*(struct)
->	O
autohelper_flag	O
&	O
HAVE_CONSTRAINT	O
)	O
&&	O
pattern	*(struct)
->	O
constraint_cost	O
<	O
0.45	int
)	O
{	O
if	O
(	O
!	O
pattern	*(struct)
->	O
autohelper	O
(	O
ll	O
,	O
move	*(int)
,	O
color	int
,	O
0	int
)	O
)	O
return	O
0	int
;	O
constraint_checked	O
=	O
1	int
;	O
}	O
if	O
(	O
!	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_s	O
)	O
&&	O
!	O
safe_move_checked	O
)	O
{	O
if	O
(	O
!	O
owl_safe_move	O
(	O
move	*(int)
,	O
color	int
)	O
)	O
{	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"  move at %1m wasn't safe, discarded\n"	*(char)
,	O
move	*(int)
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
is_legal	(int,int)->(int)
(	O
move	*(int)
,	O
color	int
)	O
)	O
{	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"  move at %1m wasn't legal, discarded\n"	*(char)
,	O
move	*(int)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_n	O
)	O
{	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
move	*(int)
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"  opponent can't play safely at %1m, move discarded\n"	*(char)
,	O
move	*(int)
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
(	O
pattern	*(struct)
->	O
autohelper_flag	O
&	O
HAVE_CONSTRAINT	O
)	O
&&	O
!	O
constraint_checked	O
)	O
if	O
(	O
!	O
pattern	*(struct)
->	O
autohelper	O
(	O
ll	O
,	O
move	*(int)
,	O
color	int
,	O
0	int
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
init_pattern_list	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
{	O
gg_assert	O
(	O
!	O
list	O
->	O
initialized	O
)	O
;	O
list	O
->	O
counter	O
=	O
0	int
;	O
list	O
->	O
used	O
=	O
0	int
;	O
list	O
->	O
pattern_list	O
=	O
malloc	(long)->(*(void))
(	O
200	int
*	O
sizeof	O
(	O
list	O
->	O
pattern_list	O
[	O
0	int
]	O
)	O
)	O
;	O
list	O
->	O
list_size	O
=	O
200	int
;	O
gg_assert	O
(	O
list	O
->	O
pattern_list	O
!=	O
NULL	O
)	O
;	O
list	O
->	O
pattern_heap	O
=	O
NULL	O
;	O
if	O
(	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"List at %x has new array at %x\n"	*(char)
,	O
list	O
,	O
list	O
->	O
pattern_list	O
)	O
;	O
list	O
->	O
initialized	O
=	O
1	int
;	O
}	O
static	O
void	O
close_pattern_list	O
(	O
int	O
color	int
,	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
{	O
if	O
(	O
list	O
->	O
initialized	O
)	O
{	O
if	O
(	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"%d patterns matched, %d patterns checked\n"	*(char)
,	O
list	O
->	O
counter	O
,	O
list	O
->	O
used	O
)	O
;	O
if	O
(	O
0	int
)	O
gprintf	(*(char))->(int)
(	O
"Pattern list at %x freed for list at %x\n"	*(char)
,	O
list	O
->	O
pattern_list	O
,	O
list	O
)	O
;	O
if	O
(	O
allpats	int
&&	O
verbose	int
)	O
{	O
int	O
i	int
;	O
int	O
found_one	O
=	O
0	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
!	O
current_owl_data	O
->	O
lunches_are_current	O
)	O
owl_find_lunches	O
(	O
current_owl_data	O
)	O
;	O
if	O
(	O
!	O
list	O
->	O
pattern_heap	O
)	O
pattern_list_build_heap	O
(	O
list	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	O
->	O
heap_num_patterns	O
;	O
i	int
++	O
)	O
if	O
(	O
check_pattern_hard	O
(	O
list	O
->	O
pattern_heap	O
[	O
i	int
]	O
->	O
move	*(int)
,	O
color	int
,	O
list	O
->	O
pattern_heap	O
[	O
i	int
]	O
->	O
pattern	*(struct)
,	O
list	O
->	O
pattern_heap	O
[	O
i	int
]	O
->	O
ll	O
)	O
)	O
{	O
if	O
(	O
!	O
found_one	O
)	O
{	O
TRACE	O
(	O
"Remaining valid (but unused) patterns at stack: "	*(char)
)	O
;	O
dump_stack	()->(void)
(	O
)	O
;	O
found_one	O
=	O
1	int
;	O
}	O
TRACE	O
(	O
"Pattern %s found at %1m with value %d\n"	*(char)
,	O
list	O
->	O
pattern_heap	O
[	O
i	int
]	O
->	O
pattern	*(struct)
->	O
name	short
,	O
list	O
->	O
pattern_heap	O
[	O
i	int
]	O
->	O
move	*(int)
,	O
(	O
int	O
)	O
list	O
->	O
pattern_heap	O
[	O
i	int
]	O
->	O
pattern	*(struct)
->	O
value	*(char)
)	O
;	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
}	O
free	(*(void))->(void)
(	O
list	O
->	O
pattern_list	O
)	O
;	O
free	(*(void))->(void)
(	O
list	O
->	O
pattern_heap	O
)	O
;	O
}	O
list	O
->	O
counter	O
=	O
-	O
1	int
;	O
}	O
void	O
dump_pattern_list	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
{	O
int	O
i	int
;	O
struct	O
matched_pattern_data	O
*	O
matched_pattern	O
;	O
if	O
(	O
!	O
list	O
->	O
initialized	O
)	O
return	O
;	O
gprintf	(*(char))->(int)
(	O
"%oList size %d. %d Patterns in list, %d have been used."	*(char)
,	O
list	O
->	O
list_size	O
,	O
list	O
->	O
counter	O
,	O
list	O
->	O
used	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	O
->	O
counter	O
;	O
i	int
++	O
)	O
{	O
matched_pattern	O
=	O
&	O
list	O
->	O
pattern_list	O
[	O
i	int
]	O
;	O
gprintf	(*(char))->(int)
(	O
"%o\n  Pattern %s (orient. %d) at %1m, value %f."	*(char)
,	O
matched_pattern	O
->	O
pattern	*(struct)
->	O
name	short
,	O
matched_pattern	O
->	O
ll	O
,	O
matched_pattern	O
->	O
move	*(int)
,	O
matched_pattern	O
->	O
pattern	*(struct)
->	O
value	*(char)
)	O
;	O
if	O
(	O
matched_pattern	O
->	O
next_pattern_index	O
!=	O
-	O
1	int
)	O
gprintf	(*(char))->(int)
(	O
"%o * "	*(char)
)	O
;	O
}	O
gprintf	(*(char))->(int)
(	O
"%o\n"	*(char)
)	O
;	O
gprintf	(*(char))->(int)
(	O
"%oCurrent heap ordering: \n"	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	O
->	O
heap_num_patterns	O
;	O
i	int
++	O
)	O
{	O
matched_pattern	O
=	O
list	O
->	O
pattern_heap	O
[	O
i	int
]	O
;	O
gprintf	(*(char))->(int)
(	O
"%o %s (%1m), %f; "	*(char)
,	O
matched_pattern	O
->	O
pattern	*(struct)
->	O
name	short
,	O
matched_pattern	O
->	O
move	*(int)
,	O
matched_pattern	O
->	O
pattern	*(struct)
->	O
value	*(char)
)	O
;	O
}	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
collect_owl_shapes_callbacks	O
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
,	O
int	O
ll	O
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
matched_patterns_list_data	O
*	O
matched_patterns	O
=	O
data	*(void)
;	O
struct	O
matched_pattern_data	O
*	O
next_pattern	O
;	O
UNUSED	O
(	O
color	int
)	O
;	O
if	O
(	O
matched_patterns	O
->	O
counter	O
>=	O
matched_patterns	O
->	O
list_size	O
)	O
{	O
matched_patterns	O
->	O
list_size	O
+=	O
100	int
;	O
matched_patterns	O
->	O
pattern_list	O
=	O
realloc	(*(void),long)->(*(void))
(	O
matched_patterns	O
->	O
pattern_list	O
,	O
matched_patterns	O
->	O
list_size	O
*	O
sizeof	O
(	O
matched_patterns	O
->	O
pattern_list	O
[	O
0	int
]	O
)	O
)	O
;	O
}	O
next_pattern	O
=	O
&	O
matched_patterns	O
->	O
pattern_list	O
[	O
matched_patterns	O
->	O
counter	O
]	O
;	O
next_pattern	O
->	O
move	*(int)
=	O
AFFINE_TRANSFORM	O
(	O
pattern	*(struct)
->	O
move_offset	O
,	O
ll	O
,	O
anchor	int
)	O
;	O
next_pattern	O
->	O
value	*(char)
=	O
pattern	*(struct)
->	O
value	*(char)
;	O
next_pattern	O
->	O
ll	O
=	O
ll	O
;	O
next_pattern	O
->	O
anchor	int
=	O
anchor	int
;	O
next_pattern	O
->	O
pattern	*(struct)
=	O
pattern	*(struct)
;	O
next_pattern	O
->	O
next_pattern_index	O
=	O
-	O
1	int
;	O
matched_patterns	O
->	O
counter	O
++	O
;	O
}	O
static	O
int	O
valuate_combinable_pattern_chain	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
,	O
int	O
pos	int
)	O
{	O
int	O
pattern_index	O
=	O
list	O
->	O
first_pattern_index	O
[	O
pos	int
]	O
;	O
int	O
num_capture_threats	O
=	O
0	int
;	O
int	O
capture_threats	O
[	O
MAX_STORED_REASONS	O
]	O
;	O
int	O
num_eye_threats	O
=	O
0	int
;	O
int	O
eye_threats	O
[	O
MAX_STORED_REASONS	O
]	O
;	O
int	O
num_reverse_sente	O
=	O
0	int
;	O
int	O
reverse_sente_against	O
[	O
MAX_STORED_REASONS	O
]	O
;	O
int	O
num_move_reasons	O
;	O
float	O
full_value	O
=	O
0.0	int
;	O
ASSERT1	O
(	O
pattern_index	O
!=	O
-	O
1	int
,	O
pos	int
)	O
;	O
do	O
{	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
=	O
(	O
list	O
->	O
pattern_list	O
+	O
pattern_index	O
)	O
;	O
struct	O
pattern_attribute	O
*	O
attribute	O
;	O
if	O
(	O
pattern_data	O
->	O
pattern	*(struct)
)	O
{	O
for	O
(	O
attribute	O
=	O
pattern_data	O
->	O
pattern	*(struct)
->	O
attributes	O
;	O
attribute	O
->	O
type	char
!=	O
LAST_ATTRIBUTE	O
;	O
attribute	O
++	O
)	O
{	O
int	O
k	int
;	O
int	O
target	int
=	O
AFFINE_TRANSFORM	O
(	O
attribute	O
->	O
offset	O
,	O
pattern_data	O
->	O
ll	O
,	O
pattern_data	O
->	O
move	*(int)
)	O
;	O
switch	O
(	O
attribute	O
->	O
type	char
)	O
{	O
case	O
THREATENS_TO_CAPTURE	O
:	O
if	O
(	O
num_capture_threats	O
<	O
MAX_STORED_REASONS	O
)	O
{	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
target	int
]	O
)	O
,	O
target	int
)	O
;	O
target	int
=	O
find_origin	(int)->(int)
(	O
target	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_capture_threats	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
capture_threats	O
[	O
k	int
]	O
==	O
target	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
num_capture_threats	O
)	O
{	O
capture_threats	O
[	O
num_capture_threats	O
++	O
]	O
=	O
target	int
;	O
full_value	O
+=	O
pattern_data	O
->	O
pattern	*(struct)
->	O
value	*(char)
;	O
}	O
}	O
break	O
;	O
case	O
THREATENS_EYE	O
:	O
if	O
(	O
num_eye_threats	O
<	O
MAX_STORED_REASONS	O
)	O
{	O
target	int
=	O
current_owl_data	O
->	O
my_eye	O
[	O
target	int
]	O
.	O
origin	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_eye_threats	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
eye_threats	O
[	O
k	int
]	O
==	O
target	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
num_eye_threats	O
)	O
{	O
eye_threats	O
[	O
num_eye_threats	O
++	O
]	O
=	O
target	int
;	O
full_value	O
+=	O
pattern_data	O
->	O
pattern	*(struct)
->	O
value	*(char)
;	O
}	O
}	O
break	O
;	O
case	O
REVERSE_SENTE	O
:	O
if	O
(	O
num_reverse_sente	O
<	O
MAX_STORED_REASONS	O
)	O
{	O
ASSERT1	O
(	O
board	*(char)
[	O
target	int
]	O
==	O
EMPTY	int
,	O
target	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_reverse_sente	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
reverse_sente_against	O
[	O
k	int
]	O
==	O
target	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
num_reverse_sente	O
)	O
{	O
reverse_sente_against	O
[	O
num_reverse_sente	O
++	O
]	O
=	O
target	int
;	O
full_value	O
+=	O
pattern_data	O
->	O
pattern	*(struct)
->	O
value	*(char)
;	O
}	O
}	O
break	O
;	O
default	O
:	O
gg_assert	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
pattern_index	O
=	O
pattern_data	O
->	O
next_pattern_index	O
;	O
}	O
while	O
(	O
pattern_index	O
>=	O
0	int
)	O
;	O
num_move_reasons	O
=	O
num_capture_threats	O
+	O
num_eye_threats	O
+	O
num_reverse_sente	O
;	O
if	O
(	O
num_move_reasons	O
<=	O
1	int
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
num_move_reasons	O
==	O
2	int
)	O
return	O
gg_min	O
(	O
gg_normalize_float2int	O
(	O
full_value	O
,	O
1.0	int
)	O
,	O
75	int
)	O
;	O
if	O
(	O
num_move_reasons	O
==	O
3	int
)	O
return	O
gg_min	O
(	O
gg_normalize_float2int	O
(	O
full_value	O
*	O
0.85	int
,	O
1.0	int
)	O
,	O
90	int
)	O
;	O
return	O
gg_min	O
(	O
gg_normalize_float2int	O
(	O
full_value	O
*	O
0.75	int
,	O
1.0	int
)	O
,	O
99	int
)	O
;	O
}	O
static	O
int	O
bdist	O
(	O
int	O
move	*(int)
)	O
{	O
int	O
idist	O
=	O
2	int
*	O
I	O
(	O
move	*(int)
)	O
-	O
board_size	int
+	O
1	int
;	O
int	O
jdist	O
=	O
2	int
*	O
J	O
(	O
move	*(int)
)	O
-	O
board_size	int
+	O
1	int
;	O
return	O
idist	O
*	O
idist	O
+	O
jdist	O
*	O
jdist	O
;	O
}	O
static	O
void	O
pattern_list_prepare	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
list	O
->	O
heap_num_patterns	O
=	O
0	int
;	O
if	O
(	O
list	O
->	O
counter	O
>	O
0	int
)	O
{	O
list	O
->	O
pattern_heap	O
=	O
malloc	(long)->(*(void))
(	O
list	O
->	O
counter	O
*	O
sizeof	O
(	O
*	O
(	O
list	O
->	O
pattern_heap	O
)	O
)	O
)	O
;	O
gg_assert	O
(	O
list	O
->	O
pattern_heap	O
!=	O
NULL	O
)	O
;	O
}	O
else	O
{	O
list	O
->	O
pattern_heap	O
=	O
NULL	O
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
list	O
->	O
first_pattern_index	O
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
list	O
->	O
counter	O
;	O
k	int
++	O
)	O
{	O
int	O
move	*(int)
=	O
list	O
->	O
pattern_list	O
[	O
k	int
]	O
.	O
move	*(int)
;	O
list	O
->	O
pattern_list	O
[	O
k	int
]	O
.	O
bdist	O
=	O
bdist	O
(	O
move	*(int)
)	O
;	O
if	O
(	O
!	O
(	O
list	O
->	O
pattern_list	O
[	O
k	int
]	O
.	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_c	O
)	O
)	O
list	O
->	O
pattern_heap	O
[	O
list	O
->	O
heap_num_patterns	O
++	O
]	O
=	O
&	O
list	O
->	O
pattern_list	O
[	O
k	int
]	O
;	O
else	O
{	O
list	O
->	O
pattern_list	O
[	O
k	int
]	O
.	O
next_pattern_index	O
=	O
list	O
->	O
first_pattern_index	O
[	O
move	*(int)
]	O
;	O
list	O
->	O
first_pattern_index	O
[	O
move	*(int)
]	O
=	O
k	int
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
list	O
->	O
first_pattern_index	O
[	O
pos	int
]	O
!=	O
-	O
1	int
)	O
{	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
=	O
&	O
list	O
->	O
pattern_list	O
[	O
list	O
->	O
first_pattern_index	O
[	O
pos	int
]	O
]	O
;	O
pattern_data	O
->	O
value	*(char)
=	O
valuate_combinable_pattern_chain	O
(	O
list	O
,	O
pos	int
)	O
;	O
list	O
->	O
pattern_heap	O
[	O
list	O
->	O
heap_num_patterns	O
++	O
]	O
=	O
pattern_data	O
;	O
}	O
}	O
if	O
(	O
list	O
->	O
heap_num_patterns	O
>	O
0	int
)	O
pattern_list_build_heap	O
(	O
list	O
)	O
;	O
}	O
static	O
void	O
pattern_list_build_heap	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
{	O
int	O
k	int
;	O
int	O
limit	O
=	O
list	O
->	O
heap_num_patterns	O
/	O
2	int
;	O
for	O
(	O
k	int
=	O
limit	O
;	O
--	O
k	int
>=	O
0	int
;	O
)	O
{	O
int	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
=	O
list	O
->	O
pattern_heap	O
[	O
k	int
]	O
;	O
for	O
(	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
k	int
;	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
<	O
limit	O
;	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
2	int
*	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
;	O
if	O
(	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
<	O
list	O
->	O
heap_num_patterns	O
&&	O
BETTER_PATTERN	O
(	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
]	O
,	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
)	O
)	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
++	O
;	O
if	O
(	O
BETTER_PATTERN	O
(	O
pattern_data	O
,	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
)	O
)	O
break	O
;	O
list	O
->	O
pattern_heap	O
[	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
=	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
;	O
}	O
list	O
->	O
pattern_heap	O
[	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
=	O
pattern_data	O
;	O
}	O
}	O
static	O
void	O
pattern_list_pop_heap_once	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
{	O
int	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
list	O
->	O
heap_num_patterns	O
--	O
;	O
for	O
(	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
0	int
;	O
2	int
*	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
<	O
list	O
->	O
heap_num_patterns	O
;	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
2	int
*	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
;	O
if	O
(	O
BETTER_PATTERN	O
(	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
]	O
,	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
)	O
)	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
++	O
;	O
if	O
(	O
BETTER_PATTERN	O
(	O
list	O
->	O
pattern_heap	O
[	O
list	O
->	O
heap_num_patterns	O
]	O
,	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
)	O
)	O
break	O
;	O
list	O
->	O
pattern_heap	O
[	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
=	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
;	O
}	O
list	O
->	O
pattern_heap	O
[	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
=	O
list	O
->	O
pattern_heap	O
[	O
list	O
->	O
heap_num_patterns	O
]	O
;	O
}	O
static	O
void	O
pattern_list_sink_heap_top_element	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
)	O
{	O
int	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
struct	O
matched_pattern_data	O
*	O
heap_top_element	O
=	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
;	O
for	O
(	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
0	int
;	O
2	int
*	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
<	O
list	O
->	O
heap_num_patterns	O
;	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
)	O
{	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
2	int
*	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
;	O
if	O
(	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
<	O
list	O
->	O
heap_num_patterns	O
&&	O
BETTER_PATTERN	O
(	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
+	O
1	int
]	O
,	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
)	O
)	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
++	O
;	O
if	O
(	O
BETTER_PATTERN	O
(	O
heap_top_element	O
,	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
)	O
)	O
break	O
;	O
list	O
->	O
pattern_heap	O
[	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
=	O
list	O
->	O
pattern_heap	O
[	O
child	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
;	O
}	O
list	O
->	O
pattern_heap	O
[	O
parent	*(struct(*(struct(*(struct`),short,*(char))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
]	O
=	O
heap_top_element	O
;	O
}	O
static	O
void	O
generate_cut_list	O
(	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
,	O
int	O
ll	O
,	O
int	O
anchor	int
,	O
int	O
cuts	O
[	O
MAX_CUTS	O
]	O
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
int	O
k	int
;	O
int	O
num	int
=	O
0	int
;	O
signed	O
char	O
mark	char
[	O
BOARDMAX	O
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mark	char
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	*(struct)
->	O
patlen	O
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	*(struct)
->	O
patn	O
[	O
k	int
]	O
.	O
offset	O
,	O
ll	O
,	O
anchor	int
)	O
;	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
)	O
continue	O
;	O
pos	int
=	O
find_origin	(int)->(int)
(	O
pos	int
)	O
;	O
if	O
(	O
!	O
mark	char
[	O
pos	int
]	O
&&	O
board	*(char)
[	O
pos	int
]	O
==	O
owl	int
->	O
color	int
&&	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
)	O
{	O
cuts	O
[	O
num	int
++	O
]	O
=	O
pos	int
;	O
mark	char
[	O
pos	int
]	O
=	O
1	int
;	O
if	O
(	O
num	int
==	O
MAX_CUTS	O
)	O
return	O
;	O
}	O
}	O
if	O
(	O
num	int
==	O
1	int
)	O
cuts	O
[	O
0	int
]	O
=	O
NO_MOVE	O
;	O
else	O
if	O
(	O
(	O
debug	int
&	O
DEBUG_SPLIT_OWL	O
)	O
&&	O
num	int
>	O
1	int
)	O
gprintf	(*(char))->(int)
(	O
"Move provokes %d cuts, among them %1m and %1m.\n"	*(char)
,	O
num	int
,	O
cuts	O
[	O
0	int
]	O
,	O
cuts	O
[	O
1	int
]	O
)	O
;	O
}	O
static	O
int	O
get_next_move_from_list	O
(	O
struct	O
matched_patterns_list_data	O
*	O
list	O
,	O
int	O
color	int
,	O
struct	O
owl_move_data	O
*	O
moves	array(int)
,	O
int	O
cutoff	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
int	O
move_found	O
=	O
0	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
!	O
list	O
->	O
pattern_heap	O
)	O
pattern_list_prepare	O
(	O
list	O
)	O
;	O
while	O
(	O
list	O
->	O
heap_num_patterns	O
>	O
0	int
)	O
{	O
int	O
k	int
;	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
;	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
;	O
int	O
move	*(int)
;	O
int	O
value	*(char)
;	O
int	O
ll	O
;	O
int	O
anchor	int
;	O
int	O
next_pattern_index	O
;	O
if	O
(	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
->	O
value	*(char)
<	O
cutoff	int
)	O
break	O
;	O
pattern_data	O
=	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
;	O
pattern	*(struct)
=	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
->	O
pattern	*(struct)
;	O
move	*(int)
=	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
->	O
move	*(int)
;	O
value	*(char)
=	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
->	O
value	*(char)
;	O
ll	O
=	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
->	O
ll	O
;	O
anchor	int
=	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
->	O
anchor	int
;	O
next_pattern_index	O
=	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
->	O
next_pattern_index	O
;	O
list	O
->	O
used	O
++	O
;	O
ASSERT_ON_BOARD1	O
(	O
move	*(int)
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
==	O
move	*(int)
||	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
<=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
==	O
move	*(int)
)	O
{	O
pattern_list_pop_heap_once	O
(	O
list	O
)	O
;	O
continue	O
;	O
}	O
gg_assert	O
(	O
k	int
<	O
MAX_MOVES	O
)	O
;	O
if	O
(	O
pattern	*(struct)
==	O
NULL	O
||	O
check_pattern_hard	O
(	O
move	*(int)
,	O
color	int
,	O
pattern	*(struct)
,	O
ll	O
)	O
)	O
{	O
if	O
(	O
next_pattern_index	O
==	O
-	O
1	int
)	O
{	O
pattern_list_pop_heap_once	O
(	O
list	O
)	O
;	O
}	O
else	O
{	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
=	O
list	O
->	O
pattern_list	O
+	O
next_pattern_index	O
;	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
->	O
value	*(char)
=	O
value	*(char)
;	O
continue	O
;	O
}	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
=	O
move	*(int)
;	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
=	O
value	*(char)
;	O
clear_cut_list	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
cuts	O
)	O
;	O
move_found	O
=	O
1	int
;	O
if	O
(	O
pattern	*(struct)
&&	O
!	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_c	O
)	O
)	O
{	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
=	O
pattern	*(struct)
->	O
name	short
;	O
TRACE	O
(	O
"Pattern %s found at %1m with value %d\n"	*(char)
,	O
pattern	*(struct)
->	O
name	short
,	O
move	*(int)
,	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
)	O
;	O
if	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_C	O
)	O
{	O
DEBUG	O
(	O
DEBUG_SPLIT_OWL	O
,	O
"Generating cut list for move at %1m.\n"	*(char)
,	O
move	*(int)
)	O
;	O
generate_cut_list	O
(	O
pattern	*(struct)
,	O
ll	O
,	O
anchor	int
,	O
moves	array(int)
[	O
k	int
]	O
.	O
cuts	O
,	O
owl	int
)	O
;	O
}	O
if	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_B	O
)	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_NOT_CONNECTED	O
;	O
else	O
if	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_a	O
)	O
{	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_ALL_CONNECTED	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
pattern_data	O
=	O
pattern_data	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_b	O
)	O
)	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_CONNECTED	O
;	O
else	O
{	O
int	O
i	int
;	O
enum	O
same_dragon_value	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_MAYBE_CONNECTED	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
list	O
->	O
heap_num_patterns	O
;	O
i	int
++	O
)	O
{	O
pattern_data	O
=	O
list	O
->	O
pattern_heap	O
[	O
i	int
]	O
;	O
if	O
(	O
pattern_data	O
->	O
pattern	*(struct)
&&	O
pattern_data	O
->	O
move	*(int)
==	O
move	*(int)
&&	O
(	O
(	O
pattern_data	O
->	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_B	O
)	O
||	O
!	O
(	O
pattern_data	O
->	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_b	O
)	O
)	O
)	O
{	O
if	O
(	O
check_pattern_hard	O
(	O
move	*(int)
,	O
color	int
,	O
pattern_data	O
->	O
pattern	*(struct)
,	O
pattern_data	O
->	O
ll	O
)	O
)	O
{	O
TRACE	O
(	O
"Additionally pattern %s found at %1m\n"	*(char)
,	O
pattern_data	O
->	O
pattern	*(struct)
->	O
name	short
,	O
move	*(int)
)	O
;	O
if	O
(	O
pattern_data	O
->	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_B	O
)	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_NOT_CONNECTED	O
;	O
else	O
if	O
(	O
pattern_data	O
->	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_a	O
)	O
{	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_ALL_CONNECTED	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
pattern_data	O
=	O
pattern_data	O
;	O
}	O
else	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_CONNECTED	O
;	O
break	O
;	O
}	O
}	O
}	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
same_dragon	(int,int)->(int)
;	O
}	O
}	O
else	O
{	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
=	O
"Pattern combination"	*(char)
;	O
if	O
(	O
verbose	int
)	O
{	O
}	O
if	O
(	O
pattern	*(struct)
&&	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_B	O
)	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_NOT_CONNECTED	O
;	O
else	O
if	O
(	O
pattern	*(struct)
&&	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_a	O
)	O
{	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_ALL_CONNECTED	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
pattern_data	O
=	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
;	O
}	O
else	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_CONNECTED	O
;	O
}	O
if	O
(	O
pattern	*(struct)
&&	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_E	O
)	O
moves	array(int)
[	O
k	int
]	O
.	O
escape	O
=	O
1	int
;	O
else	O
moves	array(int)
[	O
k	int
]	O
.	O
escape	O
=	O
0	int
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_c	O
)	O
)	O
{	O
pattern_list_pop_heap_once	O
(	O
list	O
)	O
;	O
}	O
else	O
{	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
->	O
pattern	*(struct)
=	O
NULL	O
;	O
if	O
(	O
next_pattern_index	O
!=	O
-	O
1	int
)	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
=	O
list	O
->	O
pattern_list	O
+	O
next_pattern_index	O
;	O
list	O
->	O
pattern_heap	O
[	O
0	int
]	O
->	O
value	*(char)
=	O
valuate_combinable_pattern_chain	O
(	O
list	O
,	O
move	*(int)
)	O
;	O
pattern_list_sink_heap_top_element	O
(	O
list	O
)	O
;	O
}	O
}	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
return	O
move_found	O
;	O
}	O
static	O
void	O
owl_shapes_callback	O
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	*(struct)
*	O
pattern	*(struct)
,	O
int	O
ll	O
,	O
void	O
*	O
data	*(void)
)	O
{	O
int	O
tval	O
;	O
int	O
move	*(int)
;	O
struct	O
owl_move_data	O
*	O
moves	array(int)
=	O
data	*(void)
;	O
enum	O
same_dragon_value	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_MAYBE_CONNECTED	O
;	O
int	O
escape	O
=	O
0	int
;	O
int	O
defense_pos	O
;	O
move	*(int)
=	O
AFFINE_TRANSFORM	O
(	O
pattern	*(struct)
->	O
move_offset	O
,	O
ll	O
,	O
anchor	int
)	O
;	O
if	O
(	O
!	O
allpats	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_MOVES	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
==	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
==	O
move	*(int)
)	O
{	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
>=	O
pattern	*(struct)
->	O
value	*(char)
)	O
return	O
;	O
else	O
break	O
;	O
}	O
}	O
if	O
(	O
k	int
==	O
MAX_MOVES	O
&&	O
moves	array(int)
[	O
MAX_MOVES	O
-	O
1	int
]	O
.	O
value	*(char)
>=	O
pattern	*(struct)
->	O
value	*(char)
)	O
return	O
;	O
}	O
if	O
(	O
!	O
check_pattern_hard	O
(	O
move	*(int)
,	O
color	int
,	O
pattern	*(struct)
,	O
ll	O
)	O
)	O
return	O
;	O
if	O
(	O
pattern	*(struct)
->	O
helper	*((*(struct),int)->(void))
)	O
{	O
gg_assert	O
(	O
0	int
)	O
;	O
DEBUG	O
(	O
DEBUG_HELPER	O
,	O
"  asking helper to consider '%s'+%d at %1m\n"	*(char)
,	O
pattern	*(struct)
->	O
name	short
,	O
ll	O
,	O
move	*(int)
)	O
;	O
tval	O
=	O
pattern	*(struct)
->	O
helper	*((*(struct),int)->(void))
(	O
pattern	*(struct)
,	O
ll	O
,	O
move	*(int)
,	O
color	int
)	O
;	O
if	O
(	O
tval	O
>	O
0	int
)	O
{	O
DEBUG	O
(	O
DEBUG_HELPER	O
,	O
"helper likes pattern '%s' value %d at %1m\n"	*(char)
,	O
pattern	*(struct)
->	O
name	short
,	O
tval	O
,	O
move	*(int)
)	O
;	O
}	O
else	O
{	O
DEBUG	O
(	O
DEBUG_HELPER	O
,	O
"  helper does not like pattern '%s' at %1m\n"	*(char)
,	O
pattern	*(struct)
->	O
name	short
,	O
move	*(int)
)	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
tval	O
=	O
(	O
int	O
)	O
pattern	*(struct)
->	O
value	*(char)
;	O
}	O
TRACE	O
(	O
"Pattern %s found at %1m with value %d\n"	*(char)
,	O
pattern	*(struct)
->	O
name	short
,	O
move	*(int)
,	O
tval	O
)	O
;	O
if	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_B	O
)	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_NOT_CONNECTED	O
;	O
else	O
if	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_b	O
)	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_MAYBE_CONNECTED	O
;	O
else	O
if	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_a	O
)	O
{	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_ALL_CONNECTED	O
;	O
gg_assert	O
(	O
0	int
)	O
;	O
}	O
else	O
same_dragon	(int,int)->(int)
=	O
SAME_DRAGON_CONNECTED	O
;	O
if	O
(	O
pattern	*(struct)
->	O
class	O
&	O
CLASS_E	O
)	O
escape	O
=	O
1	int
;	O
else	O
escape	O
=	O
0	int
;	O
{	O
int	O
k	int
;	O
defense_pos	O
=	O
move	*(int)
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	*(struct)
->	O
patlen	O
;	O
k	int
++	O
)	O
if	O
(	O
pattern	*(struct)
->	O
patn	O
[	O
k	int
]	O
.	O
att	O
==	O
ATT_not	O
)	O
defense_pos	O
=	O
AFFINE_TRANSFORM	O
(	O
pattern	*(struct)
->	O
patn	O
[	O
k	int
]	O
.	O
offset	O
,	O
ll	O
,	O
anchor	int
)	O
;	O
}	O
owl_add_move	O
(	O
moves	array(int)
,	O
move	*(int)
,	O
tval	O
,	O
pattern	*(struct)
->	O
name	short
,	O
same_dragon	(int,int)->(int)
,	O
NO_MOVE	O
,	O
escape	O
,	O
defense_pos	O
,	O
MAX_MOVES	O
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
owl_add_move	O
(	O
struct	O
owl_move_data	O
*	O
moves	array(int)
,	O
int	O
move	*(int)
,	O
int	O
value	*(char)
,	O
const	O
char	O
*	O
reason	O
,	O
enum	O
same_dragon_value	O
same_dragon	(int,int)->(int)
,	O
int	O
lunch	int
,	O
int	O
escape	O
,	O
int	O
defense_pos	O
,	O
int	O
max_moves	O
,	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
)	O
{	O
int	O
k	int
;	O
if	O
(	O
!	O
found_matches	O
[	O
move	*(int)
]	O
)	O
{	O
found_matches	O
[	O
move	*(int)
]	O
=	O
1	int
;	O
matches_found	O
++	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
max_moves	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
==	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
==	O
move	*(int)
)	O
{	O
if	O
(	O
same_dragon	(int,int)->(int)
>	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
)	O
{	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
same_dragon	(int,int)->(int)
;	O
moves	array(int)
[	O
k	int
]	O
.	O
pattern_data	O
=	O
pattern_data	O
;	O
}	O
if	O
(	O
!	O
moves	array(int)
[	O
k	int
]	O
.	O
escape	O
)	O
escape	O
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
k	int
<	O
max_moves	O
&&	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
>=	O
value	*(char)
)	O
return	O
;	O
for	O
(	O
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
if	O
(	O
k	int
==	O
0	int
||	O
value	*(char)
<=	O
moves	array(int)
[	O
k	int
-	O
1	int
]	O
.	O
value	*(char)
)	O
{	O
if	O
(	O
k	int
<	O
max_moves	O
)	O
{	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
=	O
move	*(int)
;	O
moves	array(int)
[	O
k	int
]	O
.	O
value	*(char)
=	O
value	*(char)
;	O
moves	array(int)
[	O
k	int
]	O
.	O
name	short
=	O
reason	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
same_dragon	(int,int)->(int)
=	O
same_dragon	(int,int)->(int)
;	O
moves	array(int)
[	O
k	int
]	O
.	O
pattern_data	O
=	O
pattern_data	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
lunch	int
=	O
lunch	int
;	O
moves	array(int)
[	O
k	int
]	O
.	O
escape	O
=	O
escape	O
;	O
moves	array(int)
[	O
k	int
]	O
.	O
defense_pos	O
=	O
defense_pos	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
k	int
<	O
max_moves	O
)	O
moves	array(int)
[	O
k	int
]	O
=	O
moves	array(int)
[	O
k	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
int	O
l	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
max_moves	O
;	O
k	int
++	O
)	O
for	O
(	O
l	O
=	O
k	int
+	O
1	int
;	O
l	O
<	O
max_moves	O
;	O
l	O
++	O
)	O
gg_assert	O
(	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
==	O
0	int
||	O
moves	array(int)
[	O
k	int
]	O
.	O
pos	int
!=	O
moves	array(int)
[	O
l	O
]	O
.	O
pos	int
)	O
;	O
}	O
}	O
static	O
void	O
owl_mark_dragon	O
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
new_dragons	O
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
color	int
=	O
board	*(char)
[	O
apos	int
]	O
;	O
ASSERT1	O
(	O
bpos	int
==	O
NO_MOVE	O
||	O
board	*(char)
[	O
bpos	int
]	O
==	O
color	int
,	O
bpos	int
)	O
;	O
if	O
(	O
new_dragons	O
==	O
NULL	O
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
is_same_dragon	(int,int)->(int)
(	O
pos	int
,	O
apos	int
)	O
||	O
is_same_dragon	(int,int)->(int)
(	O
pos	int
,	O
bpos	int
)	O
)	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
=	O
1	int
;	O
else	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
&&	O
(	O
new_dragons	O
[	O
pos	int
]	O
==	O
new_dragons	O
[	O
apos	int
]	O
||	O
new_dragons	O
[	O
pos	int
]	O
==	O
new_dragons	O
[	O
bpos	int
]	O
)	O
)	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
=	O
1	int
;	O
else	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
owl	int
->	O
cumulative_goal	O
,	O
owl	int
->	O
goal	*(char)
,	O
sizeof	O
(	O
owl	int
->	O
goal	*(char)
)	O
)	O
;	O
owl	int
->	O
color	int
=	O
color	int
;	O
owl_mark_boundary	O
(	O
owl	int
)	O
;	O
}	O
static	O
void	O
owl_mark_worm	O
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
int	O
pos	int
;	O
int	O
color	int
=	O
board	*(char)
[	O
apos	int
]	O
;	O
ASSERT1	O
(	O
bpos	int
==	O
NO_MOVE	O
||	O
board	*(char)
[	O
bpos	int
]	O
==	O
color	int
,	O
bpos	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
is_same_worm	(int,int)->(int)
(	O
pos	int
,	O
apos	int
)	O
||	O
is_same_worm	(int,int)->(int)
(	O
pos	int
,	O
bpos	int
)	O
)	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
=	O
1	int
;	O
else	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
owl	int
->	O
color	int
=	O
color	int
;	O
}	O
static	O
void	O
owl_mark_boundary	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
color	int
=	O
owl	int
->	O
color	int
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
owl	int
->	O
boundary	O
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
boundary	O
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
owl	int
->	O
neighbors	int
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
neighbors	int
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
board	*(char)
[	O
pos	int
+	O
2	int
*	O
delta	array(int)
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
!	O
owl	int
->	O
neighbors	int
[	O
pos	int
+	O
2	int
*	O
delta	array(int)
[	O
k	int
]	O
]	O
)	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
+	O
2	int
*	O
delta	array(int)
[	O
k	int
]	O
,	O
owl	int
->	O
neighbors	int
,	O
1	int
)	O
;	O
}	O
for	O
(	O
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
==	O
color	int
&&	O
!	O
owl	int
->	O
neighbors	int
[	O
pos2	int
]	O
&&	O
(	O
board	*(char)
[	O
SOUTH	O
(	O
gg_min	O
(	O
pos	int
,	O
pos2	int
)	O
)	O
]	O
==	O
EMPTY	int
||	O
board	*(char)
[	O
NORTH	O
(	O
gg_max	O
(	O
pos	int
,	O
pos2	int
)	O
)	O
]	O
==	O
EMPTY	int
)	O
)	O
mark_string	(int,array(char),char)->(void)
(	O
pos2	int
,	O
owl	int
->	O
neighbors	int
,	O
1	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	O
&&	O
!	O
owl	int
->	O
boundary	O
[	O
pos	int
]	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
)	O
&&	O
(	O
owl	int
->	O
goal	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
||	O
owl	int
->	O
neighbors	int
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
)	O
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
,	O
owl	int
->	O
boundary	O
,	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
owl	int
->	O
boundary	O
[	O
pos	int
]	O
==	O
1	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
==	O
color	int
&&	O
!	O
owl	int
->	O
goal	*(char)
[	O
pos2	int
]	O
&&	O
!	O
owl	int
->	O
neighbors	int
[	O
pos2	int
]	O
&&	O
(	O
(	O
dragon	int
[	O
pos2	int
]	O
.	O
crude_status	(int)->(enum)
!=	O
DEAD	int
&&	O
countstones	(int)->(int)
(	O
pos2	int
)	O
>	O
2	int
)	O
||	O
dragon	int
[	O
pos2	int
]	O
.	O
crude_status	(int)->(enum)
==	O
ALIVE	int
)	O
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
,	O
owl	int
->	O
boundary	O
,	O
2	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
other	O
&&	O
owl	int
->	O
boundary	O
[	O
pos	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
attack_codes	array(int)
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
pos	int
]	O
.	O
size	int
!=	O
dragon	int
[	O
pos	int
]	O
.	O
size	int
)	O
continue	O
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
id	int
==	O
-	O
1	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DRAGON2	O
(	O
pos	int
)	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
adjacent	array(int)
[	O
k	int
]	O
;	O
int	O
apos	int
=	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
d	int
]	O
.	O
origin	int
;	O
if	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
color	int
&&	O
!	O
owl	int
->	O
goal	*(char)
[	O
apos	int
]	O
)	O
{	O
owl	int
->	O
boundary	O
[	O
pos	int
]	O
=	O
2	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
owl_update_goal	O
(	O
int	O
pos	int
,	O
enum	O
same_dragon_value	O
same_dragon	(int,int)->(int)
,	O
int	O
lunch	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
semeai_call	O
,	O
struct	O
matched_pattern_data	O
*	O
pattern_data	O
)	O
{	O
int	O
stones	*(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
num_stones	int
;	O
int	O
k	int
;	O
int	O
do_add	O
=	O
1	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
if	O
(	O
same_dragon	(int,int)->(int)
==	O
SAME_DRAGON_NOT_CONNECTED	O
)	O
num_stones	int
=	O
findstones	(int,int,*(int))->(int)
(	O
pos	int
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
stones	*(int)
)	O
;	O
else	O
if	O
(	O
semeai_call	O
)	O
find_superstring_conservative	(int,*(int),*(int))->(void)
(	O
pos	int
,	O
&	O
num_stones	int
,	O
stones	*(int)
)	O
;	O
else	O
find_superstring	(int,*(int),*(int))->(void)
(	O
pos	int
,	O
&	O
num_stones	int
,	O
stones	*(int)
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
if	O
(	O
same_dragon	(int,int)->(int)
<=	O
SAME_DRAGON_MAYBE_CONNECTED	O
)	O
{	O
do_add	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_stones	int
;	O
k	int
++	O
)	O
if	O
(	O
owl	int
->	O
goal	*(char)
[	O
stones	*(int)
[	O
k	int
]	O
]	O
!=	O
0	int
)	O
{	O
do_add	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
do_add	O
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_stones	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
owl	int
->	O
goal	*(char)
[	O
stones	*(int)
[	O
k	int
]	O
]	O
==	O
0	int
)	O
{	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"Added %1m to goal.\n"	*(char)
,	O
stones	*(int)
[	O
k	int
]	O
)	O
;	O
owl	int
->	O
goal	*(char)
[	O
stones	*(int)
[	O
k	int
]	O
]	O
=	O
2	int
;	O
owl	int
->	O
cumulative_goal	O
[	O
stones	*(int)
[	O
k	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
semeai_call	O
&&	O
lunch	int
!=	O
NO_MOVE	O
&&	O
board	*(char)
[	O
lunch	int
]	O
!=	O
EMPTY	int
)	O
{	O
int	O
adj	array(int)
,	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
k	int
;	O
adj	array(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
lunch	int
,	O
adjs	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj	array(int)
;	O
k	int
++	O
)	O
if	O
(	O
!	O
owl	int
->	O
goal	*(char)
[	O
adjs	O
[	O
k	int
]	O
]	O
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
adjs	O
[	O
k	int
]	O
,	O
owl	int
->	O
goal	*(char)
,	O
2	int
)	O
;	O
mark_string	(int,array(char),char)->(void)
(	O
adjs	O
[	O
k	int
]	O
,	O
owl	int
->	O
cumulative_goal	O
,	O
2	int
)	O
;	O
}	O
}	O
if	O
(	O
same_dragon	(int,int)->(int)
==	O
SAME_DRAGON_ALL_CONNECTED	O
)	O
{	O
gg_assert	O
(	O
pattern_data	O
!=	O
NULL	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern_data	O
->	O
pattern	*(struct)
->	O
patlen	O
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
;	O
if	O
(	O
pattern_data	O
->	O
pattern	*(struct)
->	O
patn	O
[	O
k	int
]	O
.	O
att	O
!=	O
ATT_O	O
)	O
continue	O
;	O
pos2	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern_data	O
->	O
pattern	*(struct)
->	O
patn	O
[	O
k	int
]	O
.	O
offset	O
,	O
pattern_data	O
->	O
ll	O
,	O
pattern_data	O
->	O
anchor	int
)	O
;	O
if	O
(	O
!	O
owl	int
->	O
goal	*(char)
[	O
pos2	int
]	O
)	O
owl_update_goal	O
(	O
pos2	int
,	O
SAME_DRAGON_CONNECTED	O
,	O
NO_MOVE	O
,	O
owl	int
,	O
semeai_call	O
,	O
pattern_data	O
)	O
;	O
}	O
}	O
if	O
(	O
1	int
&&	O
verbose	int
)	O
goaldump	(array(char))->(void)
(	O
owl	int
->	O
goal	*(char)
)	O
;	O
}	O
static	O
int	O
connected_components	O
(	O
signed	O
char	O
graph	O
[	O
MAX_CUTS	O
]	O
[	O
MAX_CUTS	O
]	O
,	O
int	O
graph_size	O
,	O
signed	O
char	O
component	O
[	O
MAX_CUTS	O
]	O
)	O
{	O
int	O
num_components	O
=	O
0	int
;	O
int	O
k	int
,	O
j	int
;	O
if	O
(	O
graph_size	O
<=	O
0	int
)	O
return	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
component	O
,	O
-	O
1	int
,	O
MAX_CUTS	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
found_one	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
graph_size	O
;	O
k	int
++	O
)	O
if	O
(	O
component	O
[	O
k	int
]	O
==	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
k	int
==	O
graph_size	O
)	O
break	O
;	O
component	O
[	O
k	int
]	O
=	O
num_components	O
;	O
do	O
{	O
found_one	O
=	O
0	int
;	O
for	O
(	O
j	int
=	O
k	int
+	O
1	int
;	O
j	int
<	O
graph_size	O
;	O
j	int
++	O
)	O
if	O
(	O
graph	O
[	O
k	int
]	O
[	O
j	int
]	O
&&	O
component	O
[	O
j	int
]	O
==	O
-	O
1	int
)	O
{	O
component	O
[	O
j	int
]	O
=	O
num_components	O
;	O
found_one	O
=	O
1	int
;	O
}	O
}	O
while	O
(	O
found_one	O
)	O
;	O
num_components	O
++	O
;	O
}	O
gg_assert	O
(	O
num_components	O
>	O
0	int
)	O
;	O
return	O
num_components	O
;	O
}	O
static	O
void	O
owl_test_cuts	O
(	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
,	O
int	O
color	int
,	O
int	O
cuts	O
[	O
MAX_CUTS	O
]	O
)	O
{	O
int	O
k	int
,	O
j	int
;	O
signed	O
char	O
connected	O
[	O
MAX_CUTS	O
]	O
[	O
MAX_CUTS	O
]	O
;	O
int	O
num_cuts	O
;	O
int	O
found_cut	O
=	O
0	int
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
connected	O
,	O
1	int
,	O
MAX_CUTS	O
*	O
MAX_CUTS	O
)	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_SPLIT_OWL	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
"Called for this goal: "	*(char)
)	O
;	O
goaldump	(array(char))->(void)
(	O
goal	*(char)
)	O
;	O
gprintf	(*(char))->(int)
(	O
"At this position:\n"	*(char)
)	O
;	O
showboard	(int)->(void)
(	O
0	int
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_CUTS	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
cuts	O
[	O
k	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
board	*(char)
[	O
cuts	O
[	O
k	int
]	O
]	O
==	O
EMPTY	int
)	O
{	O
for	O
(	O
j	int
=	O
k	int
+	O
1	int
;	O
j	int
<	O
MAX_CUTS	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
cuts	O
[	O
j	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
cuts	O
[	O
j	int
-	O
1	int
]	O
=	O
cuts	O
[	O
j	int
]	O
;	O
}	O
cuts	O
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
k	int
--	O
;	O
}	O
}	O
num_cuts	O
=	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_cuts	O
;	O
k	int
++	O
)	O
{	O
ASSERT1	O
(	O
board	*(char)
[	O
cuts	O
[	O
k	int
]	O
]	O
==	O
color	int
,	O
cuts	O
[	O
k	int
]	O
)	O
;	O
for	O
(	O
j	int
=	O
k	int
+	O
1	int
;	O
j	int
<	O
num_cuts	O
;	O
j	int
++	O
)	O
if	O
(	O
fast_disconnect	(int,int,*(int))->(int)
(	O
cuts	O
[	O
k	int
]	O
,	O
cuts	O
[	O
j	int
]	O
,	O
NULL	O
)	O
==	O
WIN	O
)	O
{	O
found_cut	O
=	O
1	int
;	O
connected	O
[	O
k	int
]	O
[	O
j	int
]	O
=	O
0	int
;	O
connected	O
[	O
j	int
]	O
[	O
k	int
]	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
found_cut	O
)	O
{	O
signed	O
char	O
component	O
[	O
MAX_CUTS	O
]	O
;	O
signed	O
char	O
component2	O
[	O
BOARDMAX	O
]	O
;	O
int	O
component_size	O
[	O
MAX_CUTS	O
]	O
;	O
int	O
num_components	O
;	O
int	O
biggest_component	O
=	O
-	O
1	int
;	O
struct	O
connection_data	O
*	O
conn_data	O
;	O
int	O
c_id	O
;	O
int	O
pos	int
;	O
num_components	O
=	O
connected_components	O
(	O
connected	O
,	O
num_cuts	O
,	O
component	O
)	O
;	O
if	O
(	O
num_components	O
<=	O
1	int
)	O
{	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
return	O
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
component2	O
,	O
-	O
1	int
,	O
BOARDMAX	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
component_size	O
,	O
0	int
,	O
sizeof	O
(	O
int	O
)	O
*	O
num_components	O
)	O
;	O
conn_data	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
connection_data	O
)	O
*	O
num_components	O
)	O
;	O
for	O
(	O
c_id	O
=	O
0	int
;	O
c_id	O
<	O
num_components	O
;	O
c_id	O
++	O
)	O
{	O
signed	O
char	O
this_goal	O
[	O
BOARDMAX	O
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
this_goal	O
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_cuts	O
;	O
k	int
++	O
)	O
if	O
(	O
component	O
[	O
k	int
]	O
==	O
c_id	O
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
cuts	O
[	O
k	int
]	O
,	O
this_goal	O
,	O
1	int
)	O
;	O
mark_string	(int,array(char),char)->(void)
(	O
cuts	O
[	O
k	int
]	O
,	O
component2	O
,	O
(	O
signed	O
char	O
)	O
c_id	O
)	O
;	O
}	O
init_connection_data	O
(	O
color	int
,	O
this_goal	O
,	O
NO_MOVE	O
,	O
FP	O
(	O
3.01	int
)	O
,	O
conn_data	O
+	O
c_id	O
,	O
1	int
)	O
;	O
spread_connection_distances	O
(	O
color	int
,	O
conn_data	O
+	O
c_id	O
)	O
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
closest_dist	O
=	O
HUGE_CONNECTION_DISTANCE	O
;	O
int	O
closest_component	O
=	O
-	O
1	int
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
!=	O
color	int
||	O
!	O
goal	*(char)
[	O
pos	int
]	O
)	O
continue	O
;	O
if	O
(	O
pos	int
!=	O
find_origin	(int)->(int)
(	O
pos	int
)	O
)	O
continue	O
;	O
for	O
(	O
c_id	O
=	O
0	int
;	O
c_id	O
<	O
num_components	O
;	O
c_id	O
++	O
)	O
{	O
if	O
(	O
conn_data	O
[	O
c_id	O
]	O
.	O
distances	O
[	O
pos	int
]	O
<	O
closest_dist	O
)	O
{	O
closest_dist	O
=	O
conn_data	O
[	O
c_id	O
]	O
.	O
distances	O
[	O
pos	int
]	O
;	O
closest_component	O
=	O
c_id	O
;	O
}	O
}	O
if	O
(	O
closest_component	O
!=	O
-	O
1	int
)	O
{	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
,	O
component2	O
,	O
(	O
signed	O
char	O
)	O
closest_component	O
)	O
;	O
component_size	O
[	O
closest_component	O
]	O
+=	O
countstones	(int)->(int)
(	O
pos	int
)	O
;	O
}	O
}	O
{	O
int	O
biggest_size	O
=	O
0	int
;	O
for	O
(	O
c_id	O
=	O
0	int
;	O
c_id	O
<	O
num_components	O
;	O
c_id	O
++	O
)	O
if	O
(	O
component_size	O
[	O
c_id	O
]	O
>	O
biggest_size	O
)	O
{	O
biggest_size	O
=	O
component_size	O
[	O
c_id	O
]	O
;	O
biggest_component	O
=	O
c_id	O
;	O
}	O
gg_assert	O
(	O
biggest_component	O
!=	O
-	O
1	int
)	O
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
component2	O
[	O
pos	int
]	O
!=	O
biggest_component	O
)	O
goal	*(char)
[	O
pos	int
]	O
=	O
0	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_SPLIT_OWL	O
)	O
{	O
gprintf	(*(char))->(int)
(	O
"Split dragon. Biggest component is %d (of %d).\n"	*(char)
,	O
biggest_component	O
,	O
num_components	O
)	O
;	O
showboard	(int)->(void)
(	O
0	int
)	O
;	O
componentdump	O
(	O
component2	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
conn_data	O
)	O
;	O
}	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
}	O
static	O
void	O
owl_update_boundary_marks	O
(	O
int	O
pos	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
signed	O
char	O
boundary_mark	O
=	O
0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
owl	int
->	O
boundary	O
[	O
pos2	int
]	O
>	O
boundary_mark	O
)	O
boundary_mark	O
=	O
owl	int
->	O
boundary	O
[	O
pos2	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
==	O
owl	int
->	O
color	int
&&	O
dragon	int
[	O
pos2	int
]	O
.	O
color	int
==	O
owl	int
->	O
color	int
&&	O
dragon	int
[	O
pos2	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
&&	O
!	O
owl	int
->	O
goal	*(char)
[	O
pos2	int
]	O
&&	O
!	O
owl	int
->	O
neighbors	int
[	O
pos2	int
]	O
)	O
boundary_mark	O
=	O
2	int
;	O
}	O
mark_string	(int,array(char),char)->(void)
(	O
pos	int
,	O
owl	int
->	O
boundary	O
,	O
boundary_mark	O
)	O
;	O
}	O
void	O
goaldump	(array(char))->(void)
(	O
const	O
signed	O
char	O
goal	*(char)
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
goal	*(char)
[	O
pos	int
]	O
)	O
gprintf	(*(char))->(int)
(	O
"%o%1m (%d)  "	*(char)
,	O
pos	int
,	O
(	O
int	O
)	O
goal	*(char)
[	O
pos	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
void	O
componentdump	O
(	O
const	O
signed	O
char	O
component	O
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
component	O
[	O
pos	int
]	O
!=	O
-	O
1	int
)	O
gprintf	(*(char))->(int)
(	O
"%o%1m (%d)  "	*(char)
,	O
pos	int
,	O
(	O
int	O
)	O
component	O
[	O
pos	int
]	O
)	O
;	O
gprintf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
static	O
void	O
test_owl_attack_move	O
(	O
int	O
pos	int
,	O
int	O
dr	int
,	O
int	O
kworm	int
,	O
int	O
acode	int
)	O
{	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
dr	int
]	O
)	O
;	O
if	O
(	O
DRAGON2	O
(	O
dr	int
)	O
.	O
semeais	int
==	O
0	int
||	O
DRAGON2	O
(	O
dr	int
)	O
.	O
semeai_defense_point	int
==	O
NO_MOVE	O
||	O
(	O
DRAGON2	O
(	O
dr	int
)	O
.	O
semeais	int
==	O
1	int
&&	O
semeai_move_reason_known	(int,int)->(int)
(	O
pos	int
,	O
dr	int
)	O
)	O
||	O
acode	int
==	O
GAIN	O
)	O
{	O
add_owl_attack_move	(int,int,int,int)->(void)
(	O
pos	int
,	O
dr	int
,	O
kworm	int
,	O
acode	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m attacks %1m (%s) at move %d\n"	*(char)
,	O
pos	int
,	O
dr	int
,	O
result_to_string	(int)->(*(char))
(	O
DRAGON2	O
(	O
dr	int
)	O
.	O
owl_attack_code	int
)	O
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
int	O
dr2	int
=	O
DRAGON2	O
(	O
dr	int
)	O
.	O
semeai_defense_target	int
;	O
int	O
semeai_result	O
,	O
certain	*(int)
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
owl_analyze_semeai_after_move	(int,int,int,int,*(int),*(int),*(int),int,*(int),int)->(void)
(	O
pos	int
,	O
color	int
,	O
dr	int
,	O
dr2	int
,	O
&	O
semeai_result	O
,	O
NULL	O
,	O
NULL	O
,	O
1	int
,	O
&	O
certain	*(int)
,	O
0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
if	O
(	O
certain	*(int)
>=	O
DRAGON2	O
(	O
dr	int
)	O
.	O
semeai_defense_certain	int
&&	O
(	O
semeai_result	O
>=	O
REVERSE_RESULT	O
(	O
acode	int
)	O
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m ineffective owl attack on %1m (can live in semeai with %1m)\n"	*(char)
,	O
pos	int
,	O
dr	int
,	O
dr2	int
)	O
;	O
add_strategical_attack_move	(int,int)->(void)
(	O
pos	int
,	O
dr	int
)	O
;	O
}	O
else	O
{	O
add_owl_attack_move	(int,int,int,int)->(void)
(	O
pos	int
,	O
dr	int
,	O
kworm	int
,	O
acode	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m attacks %1m (%s) at move %d\n"	*(char)
,	O
pos	int
,	O
dr	int
,	O
result_to_string	(int)->(*(char))
(	O
DRAGON2	O
(	O
dr	int
)	O
.	O
owl_attack_code	int
)	O
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
owl_reasons	(int)->(void)
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
||	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
!=	O
pos	int
)	O
continue	O
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CRITICAL	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
==	O
LOSS	O
)	O
{	O
add_loss_move	(int,int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_kworm	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m defends %1m with loss at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
add_owl_defense_move	(int,int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m defends %1m at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
int	O
move	*(int)
=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
effective_size	float
<	O
8	int
)	O
{	O
int	O
largest	O
=	O
0	int
;	O
int	O
k	int
;	O
int	O
bpos	int
=	O
NO_MOVE	O
;	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
safe	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DRAGON2	O
(	O
pos	int
)	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
adjacent	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
DRAGON	O
(	O
d	int
)	O
.	O
color	int
==	O
color	int
)	O
{	O
if	O
(	O
DRAGON	O
(	O
d	int
)	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
)	O
{	O
safe	O
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
DRAGON	O
(	O
d	int
)	O
.	O
size	int
>	O
largest	O
)	O
{	O
bpos	int
=	O
dragon2	*(struct(int,array(int),int,int,int,float,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),float,float,float,int,struct(char,char,char,char),int,int,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,int,int,int))
[	O
d	int
]	O
.	O
origin	int
;	O
largest	O
=	O
DRAGON	O
(	O
d	int
)	O
.	O
size	int
;	O
}	O
}	O
}	O
if	O
(	O
bpos	int
==	O
NO_MOVE	O
)	O
safe	O
=	O
1	int
;	O
if	O
(	O
!	O
safe	O
&&	O
owl_does_defend	(int,int,*(int))->(int)
(	O
move	*(int)
,	O
bpos	int
,	O
&	O
kworm	int
)	O
!=	O
WIN	O
)	O
{	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m attacks %1m at move %d, but the attacker dies.\n"	*(char)
,	O
move	*(int)
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
DRAGON2	O
(	O
pos	int
)	O
.	O
safety	int
=	O
INESSENTIAL	int
;	O
continue	O
;	O
}	O
}	O
test_owl_attack_move	O
(	O
move	*(int)
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_kworm	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_code	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_threat_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CAN_THREATEN_DEFENSE	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
!=	O
NO_MOVE	O
)	O
{	O
add_owl_defense_threat_move	(int,int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
WIN	O
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m threatens to defend %1m at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_defense_point	int
!=	O
NO_MOVE	O
&&	O
is_legal	(int,int)->(int)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_defense_point	int
,	O
color	int
)	O
)	O
{	O
add_owl_defense_threat_move	(int,int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_defense_point	int
,	O
pos	int
,	O
WIN	O
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m threatens to defend %1m at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_threat_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CAN_THREATEN_DEFENSE	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
!=	O
NO_MOVE	O
)	O
{	O
add_owl_prevent_threat_move	(int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m prevents a threat against %1m at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_threat_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
CAN_THREATEN_ATTACK	int
)	O
{	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
!=	O
NO_MOVE	O
)	O
{	O
add_owl_attack_threat_move	(int,int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
WIN	O
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m threatens %1m at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_attack_point	int
!=	O
NO_MOVE	O
&&	O
is_legal	(int,int)->(int)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_attack_point	int
,	O
color	int
)	O
)	O
{	O
add_owl_attack_threat_move	(int,int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_attack_point	int
,	O
pos	int
,	O
WIN	O
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m threatens %1m at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_second_attack_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
!=	O
NO_MOVE	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_code	int
==	O
GAIN	O
)	O
{	O
add_owl_attack_move	(int,int,int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_kworm	int
,	O
GAIN	O
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m attacks %1m with gain at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
!=	O
NO_MOVE	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
==	O
LOSS	O
)	O
{	O
add_loss_move	(int,int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_kworm	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m defends %1m with loss at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
!=	O
NO_MOVE	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_code	int
==	O
GAIN	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
==	O
WIN	O
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
!=	O
NO_MOVE	O
)	O
{	O
add_owl_defense_move	(int,int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m defends %1m against possible loss at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
!	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_certain	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_certain	int
&&	O
ON_BOARD	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
)	O
)	O
{	O
add_owl_uncertain_defense_move	(int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m defends the uncertain dragon at %1m at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
&&	O
board	*(char)
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
!	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_certain	int
&&	O
ON_BOARD	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
)	O
)	O
{	O
add_owl_uncertain_defense_move	(int,int)->(void)
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL	O
,	O
"owl: %1m might defend the uncertain dragon at %1m at move %d\n"	*(char)
,	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
,	O
pos	int
,	O
movenum	int
+	O
1	int
)	O
;	O
}	O
}	O
}	O
int	O
owl_does_defend	(int,int,*(int))->(int)
(	O
int	O
move	*(int)
,	O
int	O
target	int
,	O
int	O
*	O
kworm	int
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
target	int
]	O
;	O
int	O
result	int
=	O
0	int
;	O
struct	O
local_owl_data	O
*	O
owl	int
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
int	O
tactical_nodes	int
;	O
int	O
origin	int
;	O
int	O
acode	int
;	O
int	O
wpos	O
=	O
NO_MOVE	O
;	O
int	O
wid	O
=	O
MAX_GOAL_WORMS	O
;	O
double	O
start	O
=	O
0.0	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	O
)	O
start	O
=	O
gg_cputime	O
(	O
)	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
return	O
0	int
;	O
origin	int
=	O
dragon	int
[	O
target	int
]	O
.	O
origin	int
;	O
TRACE	O
(	O
"owl_does_defend %1m %1m(%1m)\n"	*(char)
,	O
move	*(int)
,	O
target	int
,	O
origin	int
)	O
;	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_DOES_DEFEND	int
,	O
move	*(int)
,	O
target	int
,	O
0	int
,	O
&	O
result	int
,	O
kworm	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
"owl_does_defend"	*(char)
,	O
target	int
)	O
)	O
{	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_ATTACK	int
,	O
origin	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
NULL	O
,	O
kworm	int
,	O
NULL	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
return	O
REVERSE_RESULT	O
(	O
result	int
)	O
;	O
}	O
init_owl	O
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
move	*(int)
,	O
1	int
,	O
NULL	O
)	O
;	O
prepare_goal_list	O
(	O
target	int
,	O
owl	int
,	O
owl_goal_worm	O
,	O
&	O
goal_worms_computed	O
,	O
kworm	int
,	O
0	int
)	O
;	O
acode	int
=	O
do_owl_attack	O
(	O
target	int
,	O
NULL	O
,	O
&	O
wid	O
,	O
owl	int
,	O
0	int
)	O
;	O
finish_goal_list	O
(	O
&	O
goal_worms_computed	O
,	O
&	O
wpos	O
,	O
owl_goal_worm	O
,	O
wid	O
)	O
;	O
result	int
=	O
REVERSE_RESULT	O
(	O
acode	int
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
return	O
0	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"owl_does_defend %1m %1m(%1m), result %d (%d, %d nodes, %f seconds)\n"	*(char)
,	O
move	*(int)
,	O
target	int
,	O
origin	int
,	O
result	int
,	O
local_owl_node_counter	O
,	O
tactical_nodes	int
,	O
gg_cputime	O
(	O
)	O
-	O
start	O
)	O
;	O
store_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,array(char),int)->(void)
(	O
OWL_DOES_DEFEND	int
,	O
move	*(int)
,	O
target	int
,	O
0	int
,	O
result	int
,	O
wpos	O
,	O
0	int
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	*(char)
,	O
board	*(char)
[	O
target	int
]	O
)	O
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
wpos	O
;	O
return	O
result	int
;	O
}	O
int	O
owl_confirm_safety	(int,int,*(int),*(int))->(int)
(	O
int	O
move	*(int)
,	O
int	O
target	int
,	O
int	O
*	O
defense_point	*(int)
,	O
int	O
*	O
kworm	int
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
target	int
]	O
;	O
int	O
result	int
=	O
0	int
;	O
struct	O
local_owl_data	O
*	O
owl	int
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
int	O
tactical_nodes	int
;	O
int	O
origin	int
;	O
int	O
defense	O
=	O
0	int
;	O
double	O
start	O
=	O
0.0	int
;	O
int	O
acode	int
;	O
int	O
wpos	O
=	O
NO_MOVE	O
;	O
int	O
wid	O
=	O
MAX_GOAL_WORMS	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	O
)	O
start	O
=	O
gg_cputime	O
(	O
)	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
return	O
0	int
;	O
origin	int
=	O
dragon	int
[	O
target	int
]	O
.	O
origin	int
;	O
TRACE	O
(	O
"owl_confirm_safety %1m %1m(%1m)\n"	*(char)
,	O
move	*(int)
,	O
target	int
,	O
origin	int
)	O
;	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_CONFIRM_SAFETY	int
,	O
move	*(int)
,	O
target	int
,	O
0	int
,	O
&	O
result	int
,	O
defense_point	*(int)
,	O
kworm	int
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
"owl_confirm_safety"	*(char)
,	O
target	int
)	O
)	O
{	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_ATTACK	int
,	O
origin	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
defense_point	*(int)
,	O
kworm	int
,	O
NULL	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
if	O
(	O
result	int
==	O
0	int
)	O
return	O
WIN	O
;	O
else	O
if	O
(	O
result	int
==	O
GAIN	O
)	O
return	O
LOSS	O
;	O
else	O
return	O
0	int
;	O
}	O
init_owl	O
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
move	*(int)
,	O
1	int
,	O
NULL	O
)	O
;	O
prepare_goal_list	O
(	O
target	int
,	O
owl	int
,	O
owl_goal_worm	O
,	O
&	O
goal_worms_computed	O
,	O
kworm	int
,	O
0	int
)	O
;	O
acode	int
=	O
do_owl_attack	O
(	O
target	int
,	O
&	O
defense	O
,	O
&	O
wid	O
,	O
owl	int
,	O
0	int
)	O
;	O
finish_goal_list	O
(	O
&	O
goal_worms_computed	O
,	O
&	O
wpos	O
,	O
owl_goal_worm	O
,	O
wid	O
)	O
;	O
if	O
(	O
acode	int
==	O
0	int
)	O
result	int
=	O
WIN	O
;	O
else	O
if	O
(	O
acode	int
==	O
GAIN	O
)	O
result	int
=	O
LOSS	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
return	O
0	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"owl_confirm_safety %1m %1m(%1m), result %d %1m (%d, %d nodes, %f seconds)\n"	*(char)
,	O
move	*(int)
,	O
target	int
,	O
origin	int
,	O
result	int
,	O
defense	O
,	O
local_owl_node_counter	O
,	O
tactical_nodes	int
,	O
gg_cputime	O
(	O
)	O
-	O
start	O
)	O
;	O
store_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,array(char),int)->(void)
(	O
OWL_CONFIRM_SAFETY	int
,	O
move	*(int)
,	O
target	int
,	O
0	int
,	O
result	int
,	O
defense	O
,	O
wpos	O
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	*(char)
,	O
board	*(char)
[	O
target	int
]	O
)	O
;	O
if	O
(	O
defense_point	*(int)
)	O
*	O
defense_point	*(int)
=	O
defense	O
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
wpos	O
;	O
return	O
result	int
;	O
}	O
int	O
owl_does_attack	(int,int,*(int))->(int)
(	O
int	O
move	*(int)
,	O
int	O
target	int
,	O
int	O
*	O
kworm	int
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
target	int
]	O
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
result	int
=	O
0	int
;	O
struct	O
local_owl_data	O
*	O
owl	int
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
int	O
tactical_nodes	int
;	O
int	O
origin	int
;	O
int	O
dcode	int
;	O
int	O
wpos	O
=	O
NO_MOVE	O
;	O
int	O
wid	O
=	O
MAX_GOAL_WORMS	O
;	O
double	O
start	O
=	O
0.0	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	O
)	O
start	O
=	O
gg_cputime	O
(	O
)	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target	int
]	O
.	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
)	O
return	O
0	int
;	O
origin	int
=	O
dragon	int
[	O
target	int
]	O
.	O
origin	int
;	O
TRACE	O
(	O
"owl_does_attack %1m %1m(%1m)\n"	*(char)
,	O
move	*(int)
,	O
target	int
,	O
origin	int
)	O
;	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_DOES_ATTACK	int
,	O
move	*(int)
,	O
target	int
,	O
0	int
,	O
&	O
result	int
,	O
kworm	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
init_owl	O
(	O
&	O
owl	int
,	O
target	int
,	O
NO_MOVE	O
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
other	O
,	O
"owl_does_attack"	*(char)
,	O
target	int
)	O
)	O
{	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_DEFEND	int
,	O
origin	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
NULL	O
,	O
kworm	int
,	O
NULL	O
)	O
)	O
{	O
popgo	()->(void)
(	O
)	O
;	O
return	O
REVERSE_RESULT	O
(	O
result	int
)	O
;	O
}	O
owl_update_boundary_marks	O
(	O
move	*(int)
,	O
owl	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
target	int
]	O
==	O
EMPTY	int
)	O
dcode	int
=	O
0	int
;	O
else	O
{	O
prepare_goal_list	O
(	O
target	int
,	O
owl	int
,	O
owl_goal_worm	O
,	O
&	O
goal_worms_computed	O
,	O
kworm	int
,	O
0	int
)	O
;	O
dcode	int
=	O
do_owl_defend	O
(	O
target	int
,	O
NULL	O
,	O
&	O
wid	O
,	O
owl	int
,	O
0	int
)	O
;	O
finish_goal_list	O
(	O
&	O
goal_worms_computed	O
,	O
&	O
wpos	O
,	O
owl_goal_worm	O
,	O
wid	O
)	O
;	O
}	O
result	int
=	O
REVERSE_RESULT	O
(	O
dcode	int
)	O
;	O
owl	int
->	O
lunches_are_current	O
=	O
0	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
else	O
return	O
0	int
;	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"owl_does_attack %1m %1m(%1m), result %d (%d, %d nodes, %f seconds)\n"	*(char)
,	O
move	*(int)
,	O
target	int
,	O
origin	int
,	O
result	int
,	O
local_owl_node_counter	O
,	O
tactical_nodes	int
,	O
gg_cputime	O
(	O
)	O
-	O
start	O
)	O
;	O
store_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,array(char),int)->(void)
(	O
OWL_DOES_ATTACK	int
,	O
move	*(int)
,	O
target	int
,	O
0	int
,	O
result	int
,	O
wpos	O
,	O
0	int
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	*(char)
,	O
board	*(char)
[	O
target	int
]	O
)	O
;	O
if	O
(	O
kworm	int
)	O
*	O
kworm	int
=	O
wpos	O
;	O
return	O
result	int
;	O
}	O
int	O
owl_connection_defends	(int,int,int)->(int)
(	O
int	O
move	*(int)
,	O
int	O
target1	int
,	O
int	O
target2	int
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
target1	int
]	O
;	O
int	O
result	int
=	O
0	int
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
int	O
tactical_nodes	int
;	O
double	O
start	O
=	O
0.0	int
;	O
struct	O
local_owl_data	O
*	O
owl	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	O
)	O
start	O
=	O
gg_cputime	O
(	O
)	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
target2	int
]	O
==	O
color	int
,	O
target2	int
)	O
;	O
TRACE	O
(	O
"owl_connection_defends %1m %1m %1m\n"	*(char)
,	O
move	*(int)
,	O
target1	int
,	O
target2	int
)	O
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target1	int
]	O
.	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
return	O
0	int
;	O
if	O
(	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
target2	int
]	O
.	O
unconditional_status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
DEAD	int
)	O
return	O
0	int
;	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_CONNECTION_DEFENDS	int
,	O
move	*(int)
,	O
target1	int
,	O
target2	int
,	O
&	O
result	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
init_owl	O
(	O
&	O
owl	int
,	O
target1	int
,	O
target2	int
,	O
NO_MOVE	O
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
"owl_connection_defends"	*(char)
,	O
target1	int
)	O
)	O
{	O
owl_update_goal	O
(	O
move	*(int)
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
NO_MOVE	O
,	O
owl	int
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
do_owl_attack	O
(	O
move	*(int)
,	O
NULL	O
,	O
NULL	O
,	O
owl	int
,	O
0	int
)	O
)	O
result	int
=	O
WIN	O
;	O
owl	int
->	O
lunches_are_current	O
=	O
0	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"owl_conn_defends %1m %1m %1m, result %d (%d, %d nodes, %f seconds)\n"	*(char)
,	O
move	*(int)
,	O
target1	int
,	O
target2	int
,	O
result	int
,	O
local_owl_node_counter	O
,	O
tactical_nodes	int
,	O
gg_cputime	O
(	O
)	O
-	O
start	O
)	O
;	O
store_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,array(char),int)->(void)
(	O
OWL_CONNECTION_DEFENDS	int
,	O
move	*(int)
,	O
target1	int
,	O
target2	int
,	O
result	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	*(char)
,	O
color	int
)	O
;	O
return	O
result	int
;	O
}	O
static	O
void	O
owl_find_lunches	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
lunches	O
=	O
0	int
;	O
int	O
prevlunch	O
;	O
int	O
lunch	int
;	O
int	O
acode	int
;	O
int	O
apos	int
;	O
int	O
dcode	int
;	O
int	O
dpos	O
;	O
int	O
color	int
=	O
owl	int
->	O
color	int
;	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
signed	O
char	O
already_checked	O
[	O
BOARDMAX	O
]	O
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
for	O
(	O
prevlunch	O
=	O
0	int
;	O
prevlunch	O
<	O
MAX_LUNCHES	O
;	O
prevlunch	O
++	O
)	O
owl	int
->	O
lunch	int
[	O
prevlunch	O
]	O
=	O
NO_MOVE	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
owl	int
->	O
inessential	int
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
inessential	int
)	O
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
already_checked	O
,	O
0	int
,	O
sizeof	O
(	O
already_checked	O
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
k	int
<	O
4	int
&&	O
board	*(char)
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
pos2	int
+=	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos2	int
]	O
!=	O
other	O
)	O
continue	O
;	O
lunch	int
=	O
find_origin	(int)->(int)
(	O
pos2	int
)	O
;	O
if	O
(	O
already_checked	O
[	O
lunch	int
]	O
)	O
continue	O
;	O
already_checked	O
[	O
lunch	int
]	O
=	O
1	int
;	O
attack_and_defend	(int,*(int),*(int),*(int),*(int))->(int)
(	O
lunch	int
,	O
&	O
acode	int
,	O
&	O
apos	int
,	O
&	O
dcode	int
,	O
&	O
dpos	O
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
owl	int
->	O
lunch	int
[	O
lunches	O
]	O
=	O
lunch	int
;	O
owl	int
->	O
lunch_attack_code	O
[	O
lunches	O
]	O
=	O
acode	int
;	O
owl	int
->	O
lunch_attack_point	O
[	O
lunches	O
]	O
=	O
apos	int
;	O
owl	int
->	O
lunch_defend_code	O
[	O
lunches	O
]	O
=	O
dcode	int
;	O
ASSERT1	O
(	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
,	O
lunch	int
)	O
;	O
if	O
(	O
dcode	int
!=	O
0	int
)	O
{	O
owl	int
->	O
lunch_defense_point	O
[	O
lunches	O
]	O
=	O
dpos	O
;	O
ASSERT1	O
(	O
board	*(char)
[	O
dpos	O
]	O
==	O
EMPTY	int
,	O
lunch	int
)	O
;	O
}	O
else	O
owl	int
->	O
lunch_defense_point	O
[	O
lunches	O
]	O
=	O
NO_MOVE	O
;	O
lunches	O
++	O
;	O
if	O
(	O
lunches	O
==	O
MAX_LUNCHES	O
)	O
{	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
owl	int
->	O
lunches_are_current	O
=	O
1	int
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
owl	int
->	O
inessential	int
[	O
lunch	int
]	O
)	O
{	O
int	O
adj	array(int)
;	O
int	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
num_stones	int
;	O
int	O
stones	*(int)
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
liberties	*(int)
;	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
r	O
;	O
int	O
essential	O
=	O
0	int
;	O
int	O
superstring	O
[	O
BOARDMAX	O
]	O
;	O
adj	array(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
lunch	int
,	O
adjs	O
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
adj	array(int)
;	O
r	O
++	O
)	O
{	O
if	O
(	O
!	O
owl	int
->	O
goal	*(char)
[	O
adjs	O
[	O
r	O
]	O
]	O
||	O
attack	(int,*(int))->(int)
(	O
adjs	O
[	O
r	O
]	O
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
essential	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
essential	O
)	O
continue	O
;	O
find_superstring_stones_and_liberties	(int,*(int),*(int),*(int),*(int),int)->(void)
(	O
lunch	int
,	O
&	O
num_stones	int
,	O
stones	*(int)
,	O
&	O
liberties	*(int)
,	O
libs	*(int)
,	O
0	int
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
superstring	O
,	O
0	int
,	O
sizeof	O
(	O
superstring	O
)	O
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
num_stones	int
;	O
r	O
++	O
)	O
superstring	O
[	O
stones	*(int)
[	O
r	O
]	O
]	O
=	O
1	int
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
liberties	*(int)
;	O
r	O
++	O
)	O
{	O
int	O
bpos	int
=	O
libs	*(int)
[	O
r	O
]	O
;	O
int	O
goal_found	O
=	O
0	int
;	O
int	O
s	O
;	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
4	int
;	O
s	O
++	O
)	O
{	O
int	O
cpos	int
=	O
bpos	int
+	O
delta	array(int)
[	O
s	O
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
cpos	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	*(char)
[	O
cpos	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
attack	(int,*(int))->(int)
(	O
cpos	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
essential	O
=	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
owl	int
->	O
goal	*(char)
[	O
cpos	int
]	O
)	O
goal_found	O
=	O
1	int
;	O
else	O
{	O
essential	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
board	*(char)
[	O
cpos	int
]	O
==	O
other	O
&&	O
!	O
superstring	O
[	O
cpos	int
]	O
)	O
{	O
essential	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
goal_found	O
)	O
{	O
int	O
off_board	O
=	O
0	int
;	O
int	O
diagonal_goal	O
=	O
0	int
;	O
for	O
(	O
s	O
=	O
4	int
;	O
s	O
<	O
8	int
;	O
s	O
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
bpos	int
+	O
delta	array(int)
[	O
s	O
]	O
)	O
)	O
off_board	O
++	O
;	O
else	O
if	O
(	O
owl	int
->	O
goal	*(char)
[	O
bpos	int
+	O
delta	array(int)
[	O
s	O
]	O
]	O
)	O
diagonal_goal	O
++	O
;	O
}	O
if	O
(	O
diagonal_goal	O
+	O
(	O
off_board	O
>=	O
2	int
)	O
<	O
2	int
)	O
essential	O
=	O
1	int
;	O
else	O
{	O
for	O
(	O
s	O
=	O
0	int
;	O
s	O
<	O
4	int
;	O
s	O
++	O
)	O
{	O
if	O
(	O
board	*(char)
[	O
bpos	int
+	O
delta	array(int)
[	O
s	O
]	O
]	O
==	O
EMPTY	int
)	O
{	O
essential	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
essential	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
essential	O
)	O
{	O
TRACE	O
(	O
"Inessential string found at %1m.\n"	*(char)
,	O
lunch	int
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
num_stones	int
;	O
r	O
++	O
)	O
owl	int
->	O
inessential	int
[	O
stones	*(int)
[	O
r	O
]	O
]	O
=	O
1	int
;	O
}	O
}	O
}	O
}	O
}	O
owl	int
->	O
lunches_are_current	O
=	O
1	int
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
}	O
static	O
int	O
improve_lunch_attack	O
(	O
int	O
lunch	int
,	O
int	O
attack_point	*(int)
)	O
{	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
lunch	int
]	O
)	O
;	O
int	O
defense_point	*(int)
;	O
int	O
k	int
;	O
if	O
(	O
safe_move	(int,int)->(int)
(	O
attack_point	*(int)
,	O
color	int
)	O
)	O
{	O
if	O
(	O
is_edge_vertex	(int)->(int)
(	O
lunch	int
)	O
&&	O
is_edge_vertex	(int)->(int)
(	O
attack_point	*(int)
)	O
&&	O
neighbor_of_string	(int,int)->(int)
(	O
attack_point	*(int)
,	O
lunch	int
)	O
)	O
{	O
int	O
stones	*(int)
=	O
countstones	(int)->(int)
(	O
lunch	int
)	O
;	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
if	O
(	O
stones	*(int)
==	O
1	int
||	O
(	O
stones	*(int)
==	O
2	int
&&	O
findlib	(int,int,*(int))->(int)
(	O
lunch	int
,	O
2	int
,	O
libs	*(int)
)	O
==	O
2	int
&&	O
is_edge_vertex	(int)->(int)
(	O
libs	*(int)
[	O
0	int
]	O
)	O
&&	O
is_edge_vertex	(int)->(int)
(	O
libs	*(int)
[	O
1	int
]	O
)	O
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
apos	int
=	O
attack_point	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
attack_point	*(int)
-	O
delta	array(int)
[	O
k	int
]	O
)	O
&&	O
board	*(char)
[	O
apos	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
does_attack	(int,int)->(int)
(	O
apos	int
,	O
lunch	int
)	O
&&	O
safe_move	(int,int)->(int)
(	O
apos	int
,	O
color	int
)	O
)	O
return	O
apos	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
return	O
attack_point	*(int)
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
attack_point	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
color	int
&&	O
attack	(int,*(int))->(int)
(	O
pos	int
,	O
NULL	O
)	O
&&	O
find_defense	(int,*(int))->(int)
(	O
pos	int
,	O
&	O
defense_point	*(int)
)	O
&&	O
defense_point	*(int)
!=	O
NO_MOVE	O
&&	O
does_attack	(int,int)->(int)
(	O
defense_point	*(int)
,	O
lunch	int
)	O
)	O
{	O
TRACE	O
(	O
"Moved attack of lunch %1m from %1m to %1m.\n"	*(char)
,	O
lunch	int
,	O
attack_point	*(int)
,	O
defense_point	*(int)
)	O
;	O
return	O
defense_point	*(int)
;	O
}	O
}	O
return	O
attack_point	*(int)
;	O
}	O
static	O
int	O
improve_lunch_defense	O
(	O
int	O
lunch	int
,	O
int	O
defense_point	*(int)
)	O
{	O
int	O
color	int
=	O
board	*(char)
[	O
lunch	int
]	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
defense_point	*(int)
+	O
delta	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
countlib	(int)->(int)
(	O
pos	int
)	O
==	O
2	int
)	O
{	O
int	O
libs	*(int)
[	O
2	int
]	O
;	O
int	O
pos2	int
;	O
findlib	(int,int,*(int))->(int)
(	O
pos	int
,	O
2	int
,	O
libs	*(int)
)	O
;	O
if	O
(	O
libs	*(int)
[	O
0	int
]	O
==	O
defense_point	*(int)
)	O
pos2	int
=	O
libs	*(int)
[	O
1	int
]	O
;	O
else	O
pos2	int
=	O
libs	*(int)
[	O
0	int
]	O
;	O
if	O
(	O
accuratelib	(int,int,int,*(int))->(int)
(	O
pos2	int
,	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
>	O
accuratelib	(int,int,int,*(int))->(int)
(	O
defense_point	*(int)
,	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
&&	O
does_defend	(int,int)->(int)
(	O
pos2	int
,	O
lunch	int
)	O
)	O
{	O
TRACE	O
(	O
"Moved defense of lunch %1m from %1m to %1m.\n"	*(char)
,	O
lunch	int
,	O
defense_point	*(int)
,	O
pos2	int
)	O
;	O
return	O
pos2	int
;	O
}	O
}	O
}	O
return	O
defense_point	*(int)
;	O
}	O
static	O
void	O
owl_make_domains	O
(	O
struct	O
local_owl_data	O
*	O
owla	O
,	O
struct	O
local_owl_data	O
*	O
owlb	O
)	O
{	O
struct	O
eye_data	struct(int,int,int,int,struct(char,char,char,char),char,char,char)
*	O
black_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
NULL	O
;	O
struct	O
eye_data	struct(int,int,int,int,struct(char,char,char,char),char,char,char)
*	O
white_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
NULL	O
;	O
current_owl_data	O
=	O
owla	O
;	O
other_owl_data	O
=	O
owlb	O
;	O
if	O
(	O
!	O
owla	O
->	O
lunches_are_current	O
)	O
owl_find_lunches	O
(	O
owla	O
)	O
;	O
if	O
(	O
owla	O
->	O
color	int
==	O
BLACK	int
)	O
black_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
owla	O
->	O
my_eye	O
;	O
else	O
white_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
owla	O
->	O
my_eye	O
;	O
if	O
(	O
owlb	O
)	O
{	O
gg_assert	O
(	O
owla	O
->	O
color	int
==	O
OTHER_COLOR	O
(	O
owlb	O
->	O
color	int
)	O
)	O
;	O
if	O
(	O
!	O
owlb	O
->	O
lunches_are_current	O
)	O
owl_find_lunches	O
(	O
owlb	O
)	O
;	O
if	O
(	O
owlb	O
->	O
color	int
==	O
BLACK	int
)	O
black_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
owlb	O
->	O
my_eye	O
;	O
else	O
white_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
=	O
owlb	O
->	O
my_eye	O
;	O
}	O
make_domains	(array(struct(int,int,int,int,struct(char,char,char,char),char,char,char)),array(struct(int,int,int,int,struct(char,char,char,char),char,char,char)),int)->(void)
(	O
black_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
,	O
white_eye	array(struct(int,int,int,int,struct(char,char,char,char),char,char,char))
,	O
1	int
)	O
;	O
}	O
int	O
owl_lively	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
int	O
lunch	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
return	O
0	int
;	O
origin	int
=	O
find_origin	(int)->(int)
(	O
pos	int
)	O
;	O
if	O
(	O
other_owl_data	O
)	O
{	O
if	O
(	O
include_semeai_worms_in_eyespace	O
&&	O
other_owl_data	O
->	O
goal	*(char)
[	O
pos	int
]	O
)	O
return	O
0	int
;	O
if	O
(	O
other_owl_data	O
->	O
goal	*(char)
[	O
pos	int
]	O
&&	O
!	O
semeai_trust_tactical_attack	O
(	O
pos	int
)	O
)	O
return	O
1	int
;	O
for	O
(	O
lunch	int
=	O
0	int
;	O
lunch	int
<	O
MAX_LUNCHES	O
;	O
lunch	int
++	O
)	O
if	O
(	O
other_owl_data	O
->	O
lunch	int
[	O
lunch	int
]	O
==	O
origin	int
&&	O
other_owl_data	O
->	O
lunch_defense_point	O
[	O
lunch	int
]	O
==	O
NO_MOVE	O
)	O
return	O
0	int
;	O
}	O
if	O
(	O
current_owl_data	O
->	O
inessential	int
[	O
origin	int
]	O
)	O
return	O
0	int
;	O
for	O
(	O
lunch	int
=	O
0	int
;	O
lunch	int
<	O
MAX_LUNCHES	O
;	O
lunch	int
++	O
)	O
if	O
(	O
current_owl_data	O
->	O
lunch	int
[	O
lunch	int
]	O
==	O
origin	int
&&	O
current_owl_data	O
->	O
lunch_defense_point	O
[	O
lunch	int
]	O
==	O
NO_MOVE	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
owl_safe_move	O
(	O
int	O
move	*(int)
,	O
int	O
color	int
)	O
{	O
int	O
acode	int
,	O
safe	O
=	O
0	int
;	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
move	*(int)
,	O
color	int
,	O
"owl_safe_move"	*(char)
,	O
0	int
)	O
)	O
{	O
acode	int
=	O
attack	(int,*(int))->(int)
(	O
move	*(int)
,	O
NULL	O
)	O
;	O
if	O
(	O
acode	int
!=	O
WIN	O
)	O
safe	O
=	O
1	int
;	O
else	O
safe	O
=	O
0	int
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
current_owl_data	O
->	O
safe_move_cache	O
[	O
move	*(int)
]	O
=	O
safe	O
+	O
1	int
;	O
return	O
safe	O
;	O
}	O
int	O
owl_substantial	(int)->(int)
(	O
int	O
str	int
)	O
{	O
int	O
k	int
;	O
int	O
libs	*(int)
[	O
MAX_SUBSTANTIAL_LIBS	O
+	O
1	int
]	O
;	O
int	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
str	int
,	O
MAX_SUBSTANTIAL_LIBS	O
+	O
1	int
,	O
libs	*(int)
)	O
;	O
int	O
reading_nodes_when_called	O
=	O
get_reading_node_counter	()->(int)
(	O
)	O
;	O
int	O
tactical_nodes	int
;	O
int	O
result	int
;	O
double	O
start	O
=	O
0.0	int
;	O
struct	O
local_owl_data	O
*	O
owl	int
;	O
int	O
num_moves	int
=	O
0	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_OWL_PERFORMANCE	O
)	O
start	O
=	O
gg_cputime	O
(	O
)	O
;	O
reduced_init_owl	O
(	O
&	O
owl	int
,	O
1	int
)	O
;	O
owl	int
->	O
color	int
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
str	int
]	O
)	O
;	O
local_owl_node_counter	O
=	O
0	int
;	O
if	O
(	O
countstones	(int)->(int)
(	O
str	int
)	O
>	O
6	int
)	O
return	O
1	int
;	O
if	O
(	O
liberties	*(int)
>	O
MAX_SUBSTANTIAL_LIBS	O
)	O
return	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
owl	int
->	O
goal	*(char)
,	O
0	int
,	O
sizeof	O
(	O
owl	int
->	O
goal	*(char)
)	O
)	O
;	O
{	O
int	O
adjs	O
[	O
MAXCHAIN	int
]	O
;	O
int	O
adj	array(int)
;	O
adj	array(int)
=	O
chainlinks	(int,array(int))->(int)
(	O
str	int
,	O
adjs	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
adj	array(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
dragon	int
[	O
adjs	O
[	O
k	int
]	O
]	O
.	O
status	enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int)
==	O
ALIVE	int
)	O
return	O
1	int
;	O
mark_dragon	(int,array(char),char)->(void)
(	O
adjs	O
[	O
k	int
]	O
,	O
owl	int
->	O
goal	*(char)
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
search_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,*(int),*(int),*(int),*(int))->(int)
(	O
OWL_SUBSTANTIAL	int
,	O
str	int
,	O
0	int
,	O
0	int
,	O
&	O
result	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
return	O
result	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	*(int)
;	O
k	int
++	O
)	O
{	O
if	O
(	O
trymove	(int,int,*(char),int)->(int)
(	O
libs	*(int)
[	O
k	int
]	O
,	O
owl	int
->	O
color	int
,	O
NULL	O
,	O
0	int
)	O
)	O
{	O
if	O
(	O
get_level	()->(int)
(	O
)	O
>=	O
8	int
)	O
increase_depth_values	()->(void)
(	O
)	O
;	O
owl	int
->	O
goal	*(char)
[	O
libs	*(int)
[	O
k	int
]	O
]	O
=	O
1	int
;	O
num_moves	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
k	int
<	O
liberties	*(int)
-	O
1	int
&&	O
trymove	(int,int,*(char),int)->(int)
(	O
libs	*(int)
[	O
k	int
+	O
1	int
]	O
,	O
owl	int
->	O
color	int
,	O
NULL	O
,	O
0	int
)	O
)	O
{	O
if	O
(	O
get_level	()->(int)
(	O
)	O
>=	O
8	int
)	O
increase_depth_values	()->(void)
(	O
)	O
;	O
owl	int
->	O
goal	*(char)
[	O
libs	*(int)
[	O
k	int
+	O
1	int
]	O
]	O
=	O
1	int
;	O
libs	*(int)
[	O
k	int
+	O
1	int
]	O
=	O
libs	*(int)
[	O
k	int
]	O
;	O
num_moves	int
++	O
;	O
}	O
else	O
{	O
while	O
(	O
num_moves	int
--	O
>	O
0	int
)	O
{	O
if	O
(	O
get_level	()->(int)
(	O
)	O
>=	O
8	int
)	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
}	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
owl	int
->	O
cumulative_goal	O
,	O
owl	int
->	O
goal	*(char)
,	O
BOARDMAX	O
)	O
;	O
compute_owl_escape_values	O
(	O
owl	int
)	O
;	O
owl_mark_boundary	O
(	O
owl	int
)	O
;	O
owl	int
->	O
lunches_are_current	O
=	O
0	int
;	O
if	O
(	O
do_owl_attack	O
(	O
libs	*(int)
[	O
0	int
]	O
,	O
NULL	O
,	O
NULL	O
,	O
owl	int
,	O
0	int
)	O
)	O
result	int
=	O
0	int
;	O
else	O
result	int
=	O
1	int
;	O
while	O
(	O
num_moves	int
--	O
>	O
0	int
)	O
{	O
if	O
(	O
get_level	()->(int)
(	O
)	O
>=	O
8	int
)	O
decrease_depth_values	()->(void)
(	O
)	O
;	O
popgo	()->(void)
(	O
)	O
;	O
}	O
tactical_nodes	int
=	O
get_reading_node_counter	()->(int)
(	O
)	O
-	O
reading_nodes_when_called	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	O
,	O
"owl_substantial %1m, result %d (%d, %d nodes, %f seconds)\n"	*(char)
,	O
str	int
,	O
result	int
,	O
local_owl_node_counter	O
,	O
tactical_nodes	int
,	O
gg_cputime	O
(	O
)	O
-	O
start	O
)	O
;	O
store_persistent_owl_cache	(enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),int,int,int,int,int,int,int,int,array(char),int)->(void)
(	O
OWL_SUBSTANTIAL	int
,	O
str	int
,	O
0	int
,	O
0	int
,	O
result	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
tactical_nodes	int
,	O
owl	int
->	O
goal	*(char)
,	O
owl	int
->	O
color	int
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
one_two_point	O
(	O
int	O
pos	int
)	O
{	O
int	O
i	int
=	O
I	O
(	O
pos	int
)	O
;	O
int	O
j	int
=	O
J	O
(	O
pos	int
)	O
;	O
if	O
(	O
(	O
i	int
==	O
0	int
||	O
i	int
==	O
board_size	int
-	O
1	int
||	O
j	int
==	O
0	int
||	O
j	int
==	O
board_size	int
-	O
1	int
)	O
&&	O
(	O
i	int
==	O
1	int
||	O
i	int
==	O
board_size	int
-	O
2	int
||	O
j	int
==	O
1	int
||	O
j	int
==	O
board_size	int
-	O
2	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
sniff_lunch	O
(	O
int	O
lunch	int
,	O
int	O
*	O
min	*(int)
,	O
int	O
*	O
probable	*(int)
,	O
int	O
*	O
max	*(int)
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
lunch	int
]	O
)	O
;	O
int	O
libs	*(int)
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	*(int)
;	O
int	O
r	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
lunch	int
]	O
)	O
,	O
lunch	int
)	O
;	O
if	O
(	O
owl	int
->	O
boundary	O
[	O
lunch	int
]	O
==	O
2	int
)	O
{	O
*	O
min	*(int)
=	O
2	int
;	O
*	O
probable	*(int)
=	O
2	int
;	O
*	O
max	*(int)
=	O
2	int
;	O
return	O
;	O
}	O
liberties	*(int)
=	O
findlib	(int,int,*(int))->(int)
(	O
lunch	int
,	O
MAXLIBS	O
,	O
libs	*(int)
)	O
;	O
for	O
(	O
r	O
=	O
0	int
;	O
r	O
<	O
liberties	*(int)
;	O
r	O
++	O
)	O
{	O
if	O
(	O
owl	int
->	O
escape_values	O
[	O
libs	*(int)
[	O
r	O
]	O
]	O
>	O
0	int
&&	O
!	O
is_self_atari	(int,int)->(int)
(	O
libs	*(int)
[	O
r	O
]	O
,	O
other	O
)	O
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
libs	*(int)
[	O
r	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
)	O
&&	O
owl	int
->	O
goal	*(char)
[	O
libs	*(int)
[	O
r	O
]	O
+	O
delta	array(int)
[	O
k	int
]	O
]	O
)	O
break	O
;	O
if	O
(	O
k	int
==	O
8	int
)	O
{	O
*	O
min	*(int)
=	O
2	int
;	O
*	O
probable	*(int)
=	O
2	int
;	O
*	O
max	*(int)
=	O
2	int
;	O
return	O
;	O
}	O
}	O
}	O
estimate_lunch_eye_value	(int,*(int),*(int),*(int),int)->(void)
(	O
lunch	int
,	O
min	*(int)
,	O
probable	*(int)
,	O
max	*(int)
,	O
1	int
)	O
;	O
if	O
(	O
*	O
min	*(int)
<	O
2	int
)	O
{	O
int	O
bonus	O
=	O
estimate_lunch_half_eye_bonus	O
(	O
lunch	int
,	O
owl	int
->	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
)	O
;	O
*	O
min	*(int)
+=	O
bonus	O
/	O
2	int
;	O
*	O
probable	*(int)
+=	O
bonus	O
;	O
*	O
max	*(int)
+=	O
(	O
bonus	O
+	O
1	int
)	O
/	O
2	int
;	O
}	O
if	O
(	O
*	O
probable	*(int)
<	O
2	int
)	O
eat_lunch_escape_bonus	O
(	O
lunch	int
,	O
min	*(int)
,	O
probable	*(int)
,	O
max	*(int)
,	O
owl	int
)	O
;	O
}	O
static	O
int	O
estimate_lunch_half_eye_bonus	O
(	O
int	O
lunch	int
,	O
struct	O
half_eye_data	struct(float,char,int,array(int),int,array(int))
half_eye	array(struct(float,char,int,array(int),int,array(int)))
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
stones	*(int)
[	O
10	int
]	O
;	O
int	O
k	int
;	O
int	O
size	int
=	O
findstones	(int,int,*(int))->(int)
(	O
lunch	int
,	O
10	int
,	O
stones	*(int)
)	O
;	O
int	O
half_eyes	O
=	O
0	int
;	O
ASSERT1	O
(	O
size	int
<	O
10	int
,	O
lunch	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
size	int
;	O
k	int
++	O
)	O
{	O
int	O
stone	O
=	O
stones	*(int)
[	O
k	int
]	O
;	O
int	O
d	int
;	O
for	O
(	O
d	int
=	O
4	int
;	O
d	int
<	O
8	int
;	O
d	int
++	O
)	O
{	O
int	O
pos	int
=	O
stone	O
+	O
delta	array(int)
[	O
d	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
(	O
is_halfeye	(array(struct(float,char,int,array(int),int,array(int))),int)->(int)
(	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
,	O
pos	int
)	O
||	O
is_false_eye	(array(struct(float,char,int,array(int),int,array(int))),int)->(int)
(	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
,	O
pos	int
)	O
)	O
)	O
half_eyes	O
++	O
;	O
}	O
}	O
return	O
half_eyes	O
;	O
}	O
void	O
estimate_lunch_eye_value	(int,*(int),*(int),*(int),int)->(void)
(	O
int	O
lunch	int
,	O
int	O
*	O
min	*(int)
,	O
int	O
*	O
probable	*(int)
,	O
int	O
*	O
max	*(int)
,	O
int	O
appreciate_one_two_lunches	int
)	O
{	O
int	O
other	O
=	O
OTHER_COLOR	O
(	O
board	*(char)
[	O
lunch	int
]	O
)	O
;	O
int	O
size	int
=	O
countstones	(int)->(int)
(	O
lunch	int
)	O
;	O
if	O
(	O
size	int
>	O
6	int
)	O
{	O
*	O
min	*(int)
=	O
2	int
;	O
*	O
probable	*(int)
=	O
2	int
;	O
*	O
max	*(int)
=	O
2	int
;	O
}	O
else	O
if	O
(	O
size	int
>	O
4	int
)	O
{	O
*	O
min	*(int)
=	O
1	int
;	O
*	O
probable	*(int)
=	O
2	int
;	O
*	O
max	*(int)
=	O
2	int
;	O
}	O
else	O
if	O
(	O
size	int
>	O
2	int
)	O
{	O
*	O
min	*(int)
=	O
0	int
;	O
*	O
probable	*(int)
=	O
1	int
;	O
*	O
max	*(int)
=	O
2	int
;	O
}	O
else	O
if	O
(	O
size	int
==	O
2	int
)	O
{	O
int	O
stones	*(int)
[	O
2	int
]	O
;	O
findstones	(int,int,*(int))->(int)
(	O
lunch	int
,	O
2	int
,	O
stones	*(int)
)	O
;	O
if	O
(	O
(	O
obvious_false_eye	(int,int)->(int)
(	O
stones	*(int)
[	O
0	int
]	O
,	O
other	O
)	O
||	O
obvious_false_eye	(int,int)->(int)
(	O
stones	*(int)
[	O
1	int
]	O
,	O
other	O
)	O
)	O
&&	O
(	O
!	O
appreciate_one_two_lunches	int
||	O
!	O
(	O
one_two_point	O
(	O
stones	*(int)
[	O
0	int
]	O
)	O
||	O
one_two_point	O
(	O
stones	*(int)
[	O
1	int
]	O
)	O
)	O
)	O
)	O
{	O
*	O
min	*(int)
=	O
0	int
;	O
*	O
probable	*(int)
=	O
0	int
;	O
*	O
max	*(int)
=	O
0	int
;	O
}	O
else	O
{	O
*	O
min	*(int)
=	O
0	int
;	O
*	O
probable	*(int)
=	O
1	int
;	O
*	O
max	*(int)
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
size	int
==	O
1	int
)	O
{	O
if	O
(	O
!	O
obvious_false_eye	(int,int)->(int)
(	O
lunch	int
,	O
other	O
)	O
)	O
{	O
*	O
min	*(int)
=	O
0	int
;	O
*	O
probable	*(int)
=	O
1	int
;	O
*	O
max	*(int)
=	O
1	int
;	O
}	O
else	O
{	O
*	O
min	*(int)
=	O
0	int
;	O
*	O
probable	*(int)
=	O
0	int
;	O
*	O
max	*(int)
=	O
0	int
;	O
}	O
}	O
}	O
static	O
void	O
eat_lunch_escape_bonus	O
(	O
int	O
lunch	int
,	O
int	O
*	O
min	*(int)
,	O
int	O
*	O
probable	*(int)
,	O
int	O
*	O
max	*(int)
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
int	O
adjacent	array(int)
[	O
MAXCHAIN	int
]	O
;	O
int	O
neighbors	int
;	O
int	O
adjoins	O
=	O
0	int
;	O
int	O
n	int
;	O
UNUSED	O
(	O
min	*(int)
)	O
;	O
if	O
(	O
is_ko_point	(int)->(int)
(	O
lunch	int
)	O
)	O
return	O
;	O
neighbors	int
=	O
chainlinks	(int,array(int))->(int)
(	O
lunch	int
,	O
adjacent	array(int)
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
neighbors	int
;	O
n	int
++	O
)	O
adjoins	O
|=	O
!	O
owl	int
->	O
goal	*(char)
[	O
adjacent	array(int)
[	O
n	int
]	O
]	O
;	O
if	O
(	O
adjoins	O
)	O
{	O
int	O
before	O
,	O
after	O
;	O
before	O
=	O
dragon_escape	(array(char),int,array(char))->(int)
(	O
owl	int
->	O
goal	*(char)
,	O
owl	int
->	O
color	int
,	O
owl	int
->	O
escape_values	O
)	O
;	O
if	O
(	O
before	O
<	O
5	int
)	O
{	O
signed	O
char	O
new_goal	O
[	O
BOARDMAX	O
]	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_goal	O
,	O
owl	int
->	O
goal	*(char)
,	O
sizeof	O
(	O
new_goal	O
)	O
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
neighbors	int
;	O
n	int
++	O
)	O
if	O
(	O
!	O
owl	int
->	O
goal	*(char)
[	O
adjacent	array(int)
[	O
n	int
]	O
]	O
)	O
mark_string	(int,array(char),char)->(void)
(	O
adjacent	array(int)
[	O
n	int
]	O
,	O
new_goal	O
,	O
2	int
)	O
;	O
after	O
=	O
dragon_escape	(array(char),int,array(char))->(int)
(	O
new_goal	O
,	O
owl	int
->	O
color	int
,	O
owl	int
->	O
escape_values	O
)	O
;	O
if	O
(	O
after	O
-	O
before	O
>=	O
3	int
)	O
{	O
if	O
(	O
after	O
>=	O
8	int
||	O
(	O
before	O
==	O
0	int
&&	O
after	O
>=	O
5	int
)	O
)	O
{	O
*	O
probable	*(int)
=	O
2	int
;	O
*	O
max	*(int)
=	O
2	int
;	O
}	O
else	O
if	O
(	O
*	O
max	*(int)
<	O
2	int
)	O
(	O
*	O
max	*(int)
)	O
++	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
select_new_goal_origin	O
(	O
int	O
origin	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
owl	int
->	O
color	int
&&	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
==	O
1	int
)	O
return	O
find_origin	(int)->(int)
(	O
pos	int
)	O
;	O
return	O
origin	int
;	O
}	O
int	O
owl_topological_eye	(int,int)->(int)
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
float	O
value	*(char)
;	O
UNUSED	O
(	O
color	int
)	O
;	O
value	*(char)
=	O
current_owl_data	O
->	O
half_eye	array(struct(float,char,int,array(int),int,array(int)))
[	O
pos	int
]	O
.	O
value	*(char)
;	O
if	O
(	O
value	*(char)
>	O
2.0	int
&&	O
value	*(char)
<	O
4.0	int
)	O
return	O
3	int
;	O
else	O
if	O
(	O
value	*(char)
<=	O
2.0	int
)	O
return	O
(	O
int	O
)	O
(	O
value	*(char)
+	O
0.99	int
)	O
;	O
else	O
return	O
(	O
int	O
)	O
value	*(char)
;	O
}	O
int	O
vital_chain	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
min	*(int)
;	O
int	O
probable	*(int)
;	O
int	O
max	*(int)
;	O
sniff_lunch	O
(	O
pos	int
,	O
&	O
min	*(int)
,	O
&	O
probable	*(int)
,	O
&	O
max	*(int)
,	O
current_owl_data	O
)	O
;	O
return	O
max	*(int)
;	O
}	O
static	O
void	O
compute_owl_escape_values	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
int	O
pos	int
;	O
int	O
m	int
,	O
n	int
;	O
signed	O
char	O
safe_stones	array(char)
[	O
BOARDMAX	O
]	O
;	O
SGFTree	struct(*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))),*(struct(*(struct(*`,short,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)),*(struct(*`,*`,*`,*`)))))
*	O
save_sgf_dumptree	O
=	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
int	O
save_count_variations	O
=	O
count_variations	int
;	O
signed	O
char	O
mx	array(char)
[	O
BOARDMAX	O
]	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
mx	array(char)
,	O
0	int
,	O
sizeof	O
(	O
mx	array(char)
)	O
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
NULL	O
;	O
count_variations	int
=	O
0	int
;	O
get_lively_stones	(int,array(char))->(void)
(	O
OTHER_COLOR	O
(	O
owl	int
->	O
color	int
)	O
,	O
safe_stones	array(char)
)	O
;	O
sgf_dumptree	*(struct(*(struct(*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(struct`),*(struct`),*(struct`),*(struct`)))))
=	O
save_sgf_dumptree	O
;	O
count_variations	int
=	O
save_count_variations	O
;	O
compute_escape_influence	(int,array(char),array(char),array(float),array(char))->(void)
(	O
owl	int
->	O
color	int
,	O
safe_stones	array(char)
,	O
NULL	O
,	O
NULL	O
,	O
owl	int
->	O
escape_values	O
)	O
;	O
DEBUG	O
(	O
DEBUG_ESCAPE	O
,	O
"Owl escape values:\n"	*(char)
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
{	O
pos	int
=	O
POS	O
(	O
m	int
,	O
n	int
)	O
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
color	int
==	O
owl	int
->	O
color	int
&&	O
!	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
crude_status	(int)->(enum)
==	O
ALIVE	int
)	O
owl	int
->	O
escape_values	O
[	O
pos	int
]	O
=	O
6	int
;	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
crude_status	(int)->(enum)
==	O
UNKNOWN	int
)	O
{	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
moyo_size	int
>	O
5	int
)	O
owl	int
->	O
escape_values	O
[	O
pos	int
]	O
=	O
4	int
;	O
else	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
escape_route	float
>	O
5	int
)	O
{	O
if	O
(	O
mx	array(char)
[	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
]	O
)	O
owl	int
->	O
escape_values	O
[	O
pos	int
]	O
=	O
owl	int
->	O
escape_values	O
[	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
]	O
;	O
else	O
{	O
int	O
pos2	int
;	O
signed	O
char	O
escape_values	O
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
dragon_stones	O
[	O
BOARDMAX	O
]	O
;	O
compute_escape_influence	(int,array(char),array(char),array(float),array(char))->(void)
(	O
owl	int
->	O
color	int
,	O
safe_stones	array(char)
,	O
owl	int
->	O
goal	*(char)
,	O
NULL	O
,	O
escape_values	O
)	O
;	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
)	O
dragon_stones	O
[	O
pos2	int
]	O
=	O
is_same_dragon	(int,int)->(int)
(	O
pos2	int
,	O
pos	int
)	O
;	O
}	O
if	O
(	O
dragon_escape	(array(char),int,array(char))->(int)
(	O
dragon_stones	O
,	O
owl	int
->	O
color	int
,	O
escape_values	O
)	O
>	O
5	int
)	O
owl	int
->	O
escape_values	O
[	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
]	O
=	O
4	int
;	O
mx	array(char)
[	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
]	O
=	O
1	int
;	O
}	O
}	O
}	O
}	O
DEBUG	O
(	O
DEBUG_ESCAPE	O
,	O
"%o%d"	*(char)
,	O
owl	int
->	O
escape_values	O
[	O
pos	int
]	O
)	O
;	O
}	O
DEBUG	O
(	O
DEBUG_ESCAPE	O
,	O
"%o\n"	*(char)
)	O
;	O
}	O
}	O
int	O
owl_escape_value	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
current_owl_data	O
->	O
goal	*(char)
[	O
pos	int
]	O
)	O
return	O
-	O
10	int
;	O
if	O
(	O
board	*(char)
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
)	O
&&	O
current_owl_data	O
->	O
goal	*(char)
[	O
pos	int
+	O
delta	array(int)
[	O
k	int
]	O
]	O
)	O
return	O
-	O
10	int
;	O
return	O
current_owl_data	O
->	O
escape_values	O
[	O
pos	int
]	O
;	O
}	O
int	O
owl_goal_dragon	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
return	O
current_owl_data	O
->	O
goal	*(char)
[	O
pos	int
]	O
!=	O
0	int
;	O
}	O
int	O
owl_eyespace	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
origin	int
=	O
current_owl_data	O
->	O
my_eye	O
[	O
pos	int
]	O
.	O
origin	int
;	O
return	O
(	O
ON_BOARD	O
(	O
origin	int
)	O
&&	O
(	O
current_owl_data	O
->	O
my_eye	O
[	O
origin	int
]	O
.	O
color	int
==	O
current_owl_data	O
->	O
color	int
)	O
&&	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
current_owl_data	O
->	O
my_eye	O
[	O
origin	int
]	O
.	O
value	*(char)
)	O
>	O
0	int
)	O
;	O
}	O
int	O
owl_big_eyespace	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
origin	int
=	O
current_owl_data	O
->	O
my_eye	O
[	O
pos	int
]	O
.	O
origin	int
;	O
return	O
(	O
ON_BOARD	O
(	O
origin	int
)	O
&&	O
(	O
current_owl_data	O
->	O
my_eye	O
[	O
origin	int
]	O
.	O
color	int
==	O
current_owl_data	O
->	O
color	int
)	O
&&	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
current_owl_data	O
->	O
my_eye	O
[	O
origin	int
]	O
.	O
value	*(char)
)	O
>=	O
2	int
)	O
;	O
}	O
int	O
owl_mineye	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
origin	int
=	O
current_owl_data	O
->	O
my_eye	O
[	O
pos	int
]	O
.	O
origin	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
origin	int
)	O
||	O
(	O
current_owl_data	O
->	O
my_eye	O
[	O
origin	int
]	O
.	O
color	int
!=	O
current_owl_data	O
->	O
color	int
)	O
)	O
return	O
0	int
;	O
return	O
min_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
current_owl_data	O
->	O
my_eye	O
[	O
origin	int
]	O
.	O
value	*(char)
)	O
;	O
}	O
int	O
owl_maxeye	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
origin	int
=	O
current_owl_data	O
->	O
my_eye	O
[	O
pos	int
]	O
.	O
origin	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
origin	int
)	O
||	O
(	O
current_owl_data	O
->	O
my_eye	O
[	O
origin	int
]	O
.	O
color	int
!=	O
current_owl_data	O
->	O
color	int
)	O
)	O
return	O
0	int
;	O
return	O
max_eyes	(*(struct(char,char,char,char)))->(int)
(	O
&	O
current_owl_data	O
->	O
my_eye	O
[	O
origin	int
]	O
.	O
value	*(char)
)	O
;	O
}	O
int	O
owl_proper_eye	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
return	O
(	O
(	O
current_owl_data	O
->	O
my_eye	O
[	O
pos	int
]	O
.	O
color	int
==	O
current_owl_data	O
->	O
color	int
)	O
&&	O
!	O
current_owl_data	O
->	O
my_eye	O
[	O
pos	int
]	O
.	O
marginal	char
)	O
;	O
}	O
int	O
owl_eye_size	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
origin	int
=	O
current_owl_data	O
->	O
my_eye	O
[	O
pos	int
]	O
.	O
origin	int
;	O
return	O
current_owl_data	O
->	O
my_eye	O
[	O
origin	int
]	O
.	O
esize	int
-	O
current_owl_data	O
->	O
my_eye	O
[	O
origin	int
]	O
.	O
msize	int
;	O
}	O
int	O
owl_lunch	(int)->(int)
(	O
int	O
str	int
)	O
{	O
int	O
k	int
;	O
int	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
str	int
)	O
;	O
ASSERT1	O
(	O
current_owl_data	O
->	O
lunches_are_current	O
,	O
str	int
)	O
;	O
origin	int
=	O
find_origin	(int)->(int)
(	O
str	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_LUNCHES	O
;	O
k	int
++	O
)	O
{	O
if	O
(	O
current_owl_data	O
->	O
lunch	int
[	O
k	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
if	O
(	O
current_owl_data	O
->	O
lunch	int
[	O
k	int
]	O
==	O
origin	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
owl_strong_dragon	(int)->(int)
(	O
int	O
pos	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	*(char)
[	O
pos	int
]	O
)	O
,	O
pos	int
)	O
;	O
return	O
(	O
!	O
current_owl_data	O
->	O
goal	*(char)
[	O
pos	int
]	O
&&	O
dragon	int
[	O
pos	int
]	O
.	O
color	int
==	O
board	*(char)
[	O
pos	int
]	O
&&	O
dragon	int
[	O
pos	int
]	O
.	O
crude_status	(int)->(enum)
==	O
ALIVE	int
)	O
;	O
}	O
static	O
int	O
owl_escape_route	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
)	O
{	O
signed	O
char	O
modified_escape	O
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
modified_escape	O
,	O
owl	int
->	O
escape_values	O
,	O
sizeof	O
(	O
modified_escape	O
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
owl	int
->	O
cumulative_goal	O
[	O
pos	int
]	O
)	O
modified_escape	O
[	O
pos	int
]	O
=	O
0	int
;	O
return	O
dragon_escape	(array(char),int,array(char))->(int)
(	O
owl	int
->	O
goal	*(char)
,	O
owl	int
->	O
color	int
,	O
modified_escape	O
)	O
;	O
}	O
static	O
void	O
reduced_init_owl	O
(	O
struct	O
local_owl_data	O
*	O
*	O
owl	int
,	O
int	O
at_bottom_of_stack	O
)	O
{	O
if	O
(	O
at_bottom_of_stack	O
)	O
owl_stack_pointer	O
=	O
0	int
;	O
else	O
owl_stack_pointer	O
++	O
;	O
check_owl_stack_size	O
(	O
)	O
;	O
*	O
owl	int
=	O
owl_stack	O
[	O
owl_stack_pointer	O
]	O
;	O
VALGRIND_MAKE_WRITABLE	O
(	O
*	O
owl	int
,	O
sizeof	O
(	O
struct	O
local_owl_data	O
)	O
)	O
;	O
}	O
static	O
void	O
init_owl	O
(	O
struct	O
local_owl_data	O
*	O
*	O
owl	int
,	O
int	O
target1	int
,	O
int	O
target2	int
,	O
int	O
move	*(int)
,	O
int	O
at_bottom_of_stack	O
,	O
int	O
new_dragons	O
[	O
BOARDMAX	O
]	O
)	O
{	O
reduced_init_owl	O
(	O
owl	int
,	O
at_bottom_of_stack	O
)	O
;	O
local_owl_node_counter	O
=	O
0	int
;	O
(	O
*	O
owl	int
)	O
->	O
lunches_are_current	O
=	O
0	int
;	O
owl_mark_dragon	O
(	O
target1	int
,	O
target2	int
,	O
*	O
owl	int
,	O
new_dragons	O
)	O
;	O
if	O
(	O
move	*(int)
!=	O
NO_MOVE	O
)	O
owl_update_goal	O
(	O
move	*(int)
,	O
SAME_DRAGON_MAYBE_CONNECTED	O
,	O
NO_MOVE	O
,	O
*	O
owl	int
,	O
0	int
,	O
NULL	O
)	O
;	O
compute_owl_escape_values	O
(	O
*	O
owl	int
)	O
;	O
}	O
static	O
void	O
check_owl_stack_size	O
(	O
void	O
)	O
{	O
while	O
(	O
owl_stack_size	O
<=	O
owl_stack_pointer	O
)	O
{	O
owl_stack	O
[	O
owl_stack_size	O
]	O
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
owl_stack	O
[	O
0	int
]	O
)	O
)	O
;	O
gg_assert	O
(	O
owl_stack	O
[	O
owl_stack_size	O
]	O
!=	O
NULL	O
)	O
;	O
owl_stack_size	O
++	O
;	O
}	O
}	O
static	O
void	O
do_push_owl	O
(	O
struct	O
local_owl_data	O
*	O
*	O
owl	int
)	O
{	O
struct	O
local_owl_data	O
*	O
new_owl	O
=	O
owl_stack	O
[	O
owl_stack_pointer	O
]	O
;	O
VALGRIND_MAKE_WRITABLE	O
(	O
new_owl	O
,	O
sizeof	O
(	O
struct	O
local_owl_data	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_owl	O
->	O
goal	*(char)
,	O
(	O
*	O
owl	int
)	O
->	O
goal	*(char)
,	O
sizeof	O
(	O
new_owl	O
->	O
goal	*(char)
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_owl	O
->	O
cumulative_goal	O
,	O
(	O
*	O
owl	int
)	O
->	O
cumulative_goal	O
,	O
sizeof	O
(	O
new_owl	O
->	O
cumulative_goal	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_owl	O
->	O
boundary	O
,	O
(	O
*	O
owl	int
)	O
->	O
boundary	O
,	O
sizeof	O
(	O
new_owl	O
->	O
boundary	O
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_owl	O
->	O
neighbors	int
,	O
(	O
*	O
owl	int
)	O
->	O
neighbors	int
,	O
sizeof	O
(	O
new_owl	O
->	O
neighbors	int
)	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
new_owl	O
->	O
escape_values	O
,	O
(	O
*	O
owl	int
)	O
->	O
escape_values	O
,	O
sizeof	O
(	O
new_owl	O
->	O
escape_values	O
)	O
)	O
;	O
new_owl	O
->	O
color	int
=	O
(	O
*	O
owl	int
)	O
->	O
color	int
;	O
new_owl	O
->	O
lunches_are_current	O
=	O
0	int
;	O
new_owl	O
->	O
restore_from	O
=	O
*	O
owl	int
;	O
*	O
owl	int
=	O
new_owl	O
;	O
}	O
static	O
void	O
push_owl	O
(	O
struct	O
local_owl_data	O
*	O
*	O
owl	int
)	O
{	O
owl_stack_pointer	O
++	O
;	O
check_owl_stack_size	O
(	O
)	O
;	O
do_push_owl	O
(	O
owl	int
)	O
;	O
}	O
static	O
void	O
pop_owl	O
(	O
struct	O
local_owl_data	O
*	O
*	O
owl	int
)	O
{	O
*	O
owl	int
=	O
(	O
*	O
owl	int
)	O
->	O
restore_from	O
;	O
owl_stack_pointer	O
--	O
;	O
}	O
static	O
int	O
list_goal_worms	O
(	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
goal_worm	O
[	O
MAX_GOAL_WORMS	O
]	O
)	O
{	O
int	O
pos	int
,	O
k	int
;	O
int	O
w	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_GOAL_WORMS	O
;	O
k	int
++	O
)	O
goal_worm	O
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
&&	O
w	int
<	O
MAX_GOAL_WORMS	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
board	*(char)
[	O
pos	int
]	O
&&	O
owl	int
->	O
goal	*(char)
[	O
pos	int
]	O
==	O
1	int
)	O
{	O
int	O
origin	int
=	O
find_origin	(int)->(int)
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
w	int
;	O
k	int
++	O
)	O
if	O
(	O
goal_worm	O
[	O
k	int
]	O
==	O
origin	int
)	O
break	O
;	O
if	O
(	O
k	int
==	O
w	int
)	O
goal_worm	O
[	O
w	int
++	O
]	O
=	O
pos	int
;	O
}	O
}	O
if	O
(	O
1	int
&&	O
(	O
w	int
>	O
0	int
)	O
&&	O
(	O
w	int
<	O
MAX_GOAL_WORMS	O
)	O
)	O
{	O
pos	int
=	O
goal_worm	O
[	O
0	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DRAGON2	O
(	O
pos	int
)	O
.	O
neighbors	int
&&	O
w	int
<	O
MAX_GOAL_WORMS	O
;	O
k	int
++	O
)	O
{	O
int	O
ii	O
;	O
int	O
d	int
=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
adjacent	array(int)
[	O
k	int
]	O
;	O
if	O
(	O
DRAGON	O
(	O
d	int
)	O
.	O
color	int
!=	O
owl	int
->	O
color	int
)	O
continue	O
;	O
for	O
(	O
ii	O
=	O
BOARDMIN	O
;	O
ii	O
<	O
BOARDMAX	O
&&	O
w	int
<	O
MAX_GOAL_WORMS	O
;	O
ii	O
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	O
)	O
&&	O
board	*(char)
[	O
ii	O
]	O
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ii	O
]	O
.	O
origin	int
==	O
ii	O
&&	O
worm	array(struct(int,int,float,int,int,int,int,int,int,int,int,int,int,int,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),array(int),array(int),array(int),array(int),array(int),array(int),array(int),array(int)))
[	O
ii	O
]	O
.	O
size	int
>=	O
3	int
&&	O
dragon	int
[	O
ii	O
]	O
.	O
id	int
==	O
d	int
)	O
goal_worm	O
[	O
w	int
++	O
]	O
=	O
ii	O
;	O
}	O
}	O
return	O
w	int
;	O
}	O
static	O
void	O
prepare_goal_list	O
(	O
int	O
str	int
,	O
struct	O
local_owl_data	O
*	O
owl	int
,	O
int	O
list	O
[	O
MAX_GOAL_WORMS	O
]	O
,	O
int	O
*	O
flag	O
,	O
int	O
*	O
kworm	int
,	O
int	O
do_list	O
)	O
{	O
gg_assert	O
(	O
flag	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
kworm	int
)	O
{	O
if	O
(	O
do_list	O
)	O
list_goal_worms	O
(	O
owl	int
,	O
list	O
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
dragon_goal_worms	O
[	O
dragon	int
[	O
str	int
]	O
.	O
id	int
]	O
,	O
list	O
,	O
sizeof	O
(	O
dragon_goal_worms	O
[	O
dragon	int
[	O
str	int
]	O
.	O
id	int
]	O
)	O
)	O
;	O
*	O
flag	O
=	O
1	int
;	O
}	O
else	O
*	O
flag	O
=	O
0	int
;	O
}	O
static	O
void	O
finish_goal_list	O
(	O
int	O
*	O
flag	O
,	O
int	O
*	O
wpos	O
,	O
int	O
list	O
[	O
MAX_GOAL_WORMS	O
]	O
,	O
int	O
index	(*(char),int)->(*(char))
)	O
{	O
gg_assert	O
(	O
flag	O
!=	O
NULL	O
)	O
;	O
gg_assert	O
(	O
wpos	O
!=	O
NULL	O
)	O
;	O
*	O
flag	O
=	O
0	int
;	O
if	O
(	O
index	(*(char),int)->(*(char))
==	O
MAX_GOAL_WORMS	O
)	O
*	O
wpos	O
=	O
NO_MOVE	O
;	O
else	O
*	O
wpos	O
=	O
list	O
[	O
index	(*(char),int)->(*(char))
]	O
;	O
}	O
void	O
reset_owl_node_counter	()->(void)
(	O
)	O
{	O
global_owl_node_counter	O
=	O
0	int
;	O
}	O
int	O
get_owl_node_counter	()->(int)
(	O
)	O
{	O
return	O
global_owl_node_counter	O
;	O
}	O
