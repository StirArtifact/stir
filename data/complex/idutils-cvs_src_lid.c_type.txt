typedef	O
void	O
(	O
*	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
;	O
typedef	O
int	O
(	O
*	O
query_func_t	*((*(char),*((*(char),*(*`))->(void)))->(int))
)	O
(	O
char	O
const	O
*	O
arg	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
;	O
enum	O
delimiter_style	enum(int,int,int,int)
{	O
ds_bogus	int
,	O
ds_contextual	int
,	O
ds_word	int
,	O
ds_substring	int
}	O
;	O
enum	O
pattern_style	enum(int,int,int,int)
{	O
ps_bogus	int
,	O
ps_contextual	int
,	O
ps_literal	int
,	O
ps_regexp	int
}	O
;	O
enum	O
key_style	enum(int,int,int,int)
{	O
ks_bogus	int
,	O
ks_none	int
,	O
ks_token	int
,	O
ks_pattern	int
}	O
;	O
enum	O
result_style	enum(int,int,int,int,int)
{	O
rs_bogus	int
,	O
rs_none	int
,	O
rs_filenames	int
,	O
rs_grep	int
,	O
rs_edit	int
}	O
;	O
enum	O
radix	enum(int,int,int,int)
{	O
radix_oct	int
=	O
1	int
,	O
radix_dec	int
=	O
2	int
,	O
radix_hex	int
=	O
4	int
,	O
radix_all	int
=	O
radix_dec	int
|	O
radix_oct	int
|	O
radix_hex	int
}	O
;	O
void	O
usage	()->(void)
(	O
void	O
)	O
;	O
static	O
void	O
help_me	()->(void)
(	O
void	O
)	O
;	O
void	O
lower_caseify	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
;	O
enum	O
key_style	enum(int,int,int,int)
parse_key_style	(*(char))->(enum(int,int,int,int))
(	O
char	O
const	O
*	O
arg	*(char)
)	O
;	O
enum	O
result_style	enum(int,int,int,int,int)
parse_result_style	(*(char))->(enum(int,int,int,int,int))
(	O
char	O
const	O
*	O
arg	*(char)
)	O
;	O
query_func_t	*((*(char),*((*(char),*(*`))->(void)))->(int))
get_query_func	(*(char))->(*((*(char),*((*`,*`)->(void)))->(int)))
(	O
char	O
*	O
pattern	*(char)
)	O
;	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
get_report_func	()->(*((*(char),*(*(struct`)))->(void)))
(	O
void	O
)	O
;	O
void	O
report_filenames	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
;	O
void	O
report_grep	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
;	O
void	O
report_edit	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
;	O
void	O
report_nothing	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
;	O
int	O
vector_cardinality	(*(void))->(int)
(	O
void	O
*	O
vector	*(void)
)	O
;	O
int	O
search_flinkv	(*(*(struct(union(*`,long),char,array(char)))))->(int)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
;	O
int	O
query_literal_word	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
char	O
const	O
*	O
pattern	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
;	O
int	O
query_literal_prefix	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
char	O
const	O
*	O
pattern	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
;	O
int	O
query_regexp	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
char	O
const	O
*	O
pattern_0	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
;	O
char	O
const	O
*	O
add_regexp_word_delimiters	(*(char))->(*(char))
(	O
char	O
const	O
*	O
pattern_0	*(char)
)	O
;	O
int	O
query_number	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
char	O
const	O
*	O
pattern	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
;	O
int	O
query_ambiguous_prefix	(int,*((*(char),*(*(struct`)))->(void)))->(int)
(	O
unsigned	O
int	O
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
;	O
int	O
query_literal_substring	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
char	O
const	O
*	O
pattern	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
;	O
void	O
parse_frequency_arg	(*(char))->(void)
(	O
char	O
const	O
*	O
arg	*(char)
)	O
;	O
int	O
desired_frequency	(*(char))->(int)
(	O
char	O
const	O
*	O
tok	*(char)
)	O
;	O
char	O
*	O
strcasestr	(*(char),*(char))->(*(char))
(	O
char	O
const	O
*	O
s1	*(char)
,	O
char	O
const	O
*	O
s2	*(char)
)	O
;	O
char	O
const	O
*	O
file_regexp	(*(char),*(char),*(char))->(*(char))
(	O
char	O
const	O
*	O
name_0	*(char)
,	O
char	O
const	O
*	O
left_delimit	*(char)
,	O
char	O
const	O
*	O
right_delimit	*(char)
)	O
;	O
off_t	long
query_binary_search	(*(char))->(long)
(	O
char	O
const	O
*	O
token	*(char)
)	O
;	O
int	O
is_regexp	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
;	O
int	O
has_left_delimiter	(*(char))->(int)
(	O
char	O
const	O
*	O
pattern	*(char)
)	O
;	O
int	O
has_right_delimiter	(*(char))->(int)
(	O
char	O
const	O
*	O
pattern	*(char)
)	O
;	O
int	O
file_name_wildcard	(*(char),*(char))->(int)
(	O
char	O
const	O
*	O
re	*(char)
,	O
char	O
const	O
*	O
fn	*(char)
)	O
;	O
int	O
word_match	(*(char),*(char))->(int)
(	O
char	O
const	O
*	O
name_0	*(char)
,	O
char	O
const	O
*	O
line	*(char)
)	O
;	O
int	O
get_radix	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
;	O
int	O
is_number	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
;	O
int	O
stoi	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
;	O
int	O
otoi	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
;	O
int	O
dtoi	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
;	O
int	O
xtoi	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
;	O
unsigned	O
char	O
*	O
tree8_to_bits	(*(char),*(char))->(*(char))
(	O
unsigned	O
char	O
*	O
bits_vec	*(char)
,	O
unsigned	O
char	O
const	O
*	O
hits_tree8	*(char)
)	O
;	O
void	O
tree8_to_bits_1	(*(*(char)),*(*(char)),int)->(void)
(	O
unsigned	O
char	O
*	O
*	O
bits_vec	*(char)
,	O
unsigned	O
char	O
const	O
*	O
*	O
hits_tree8	*(char)
,	O
int	O
level	int
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
tree8_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
unsigned	O
char	O
const	O
*	O
hits_tree8	*(char)
)	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
bits_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
unsigned	O
char	O
const	O
*	O
bits_vec	*(char)
)	O
;	O
void	O
savetty	()->(void)
(	O
void	O
)	O
;	O
void	O
restoretty	()->(void)
(	O
void	O
)	O
;	O
void	O
linetty	()->(void)
(	O
void	O
)	O
;	O
void	O
chartty	()->(void)
(	O
void	O
)	O
;	O
char	O
anchor_dir	array(char)
[	O
BUFSIZ	int
]	O
;	O
int	O
tree8_levels	int
;	O
unsigned	O
int	O
bits_vec_size	int
;	O
struct	O
idhead	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct(*`,*`,array(char))))),*((*(void),*(struct(*`,*`,array(char))))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))))
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
;	O
char	O
*	O
hits_buf_1	*(char)
;	O
char	O
*	O
hits_buf_2	*(char)
;	O
unsigned	O
char	O
*	O
bits_vec	*(char)
;	O
char	O
const	O
*	O
program_name	*(char)
;	O
static	O
int	O
show_help	int
;	O
static	O
int	O
show_version	int
;	O
int	O
radix_flag	int
=	O
radix_all	int
;	O
int	O
ignore_case_flag	int
=	O
0	int
;	O
enum	O
delimiter_style	enum(int,int,int,int)
delimiter_style	enum(int,int,int,int)
=	O
ds_contextual	int
;	O
enum	O
pattern_style	enum(int,int,int,int)
pattern_style	enum(int,int,int,int)
=	O
ps_contextual	int
;	O
enum	O
key_style	enum(int,int,int,int)
key_style	enum(int,int,int,int)
=	O
ks_token	int
;	O
enum	O
result_style	enum(int,int,int,int,int)
result_style	enum(int,int,int,int,int)
=	O
rs_filenames	int
;	O
enum	O
separator_style	enum(int,int,int,int,int)
separator_style	enum(int,int,int,int,int)
=	O
ss_contextual	int
;	O
unsigned	O
int	O
ambiguous_prefix_length	int
=	O
0	int
;	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_function	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
;	O
query_func_t	*((*(char),*((*(char),*(*`))->(void)))->(int))
query_function	*((*(char),*((*(char),*(*`))->(void)))->(int))
;	O
unsigned	O
int	O
frequency_low	int
=	O
1	int
;	O
unsigned	O
int	O
frequency_high	int
=	O
USHRT_MAX	O
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
cw_dlink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
members_0	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
const	O
long_options	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"file"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"frequency"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"ambiguous"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"key"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"result"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'R'	O
}	O
,	O
{	O
"separator"	*(char)
,	O
required_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"ignore-case"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"literal"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"regexp"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"word"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'w'	O
}	O
,	O
{	O
"substring"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"hex"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"decimal"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"octal"	*(char)
,	O
no_argument	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
&	O
show_help	int
,	O
1	int
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
&	O
show_version	int
,	O
1	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
void	O
usage	()->(void)
(	O
void	O
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
static	O
void	O
help_me	()->(void)
(	O
void	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION]... PATTERN...\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Query ID database and report results.\nBy default, output consists of multiple lines, each line containing the\nmatched identifier followed by the list of file names in which it occurs.\n\n  -f, --file=FILE       file name of ID database\n\n  -i, --ignore-case     match PATTERN case insensitively\n  -l, --literal         match PATTERN as a literal string\n  -r, --regexp          match PATTERN as a regular expression\n  -w, --word            match PATTERN as a delimited word\n  -s, --substring       match PATTERN as a substring\n            Note: If PATTERN contains extended regular expression meta-\n            characters, it is interpreted as a regular expression substring.\n            Otherwise, PATTERN is interpreted as a literal word.\n\n  -k, --key=STYLE       STYLE is one of `token', `pattern' or `none'\n  -R, --result=STYLE    STYLE is one of `filenames', `grep', `edit' or `none'\n  -S, --separator=STYLE STYLE is one of `braces', `space' or `newline' and\n                        only applies to file names when `--result=filenames'\n            The above STYLE options control how query results are presented.\n            Defaults are --key=token --result=filenames --separator=%s\n\n  -F, --frequency=FREQ  find tokens that occur FREQ times, where FREQ\n                        is a range expressed as `N..M'.  If N is omitted, it\n                        defaults to 1, if M is omitted it defaults to MAX_USHRT\n  -a, --ambiguous=LEN   find tokens whose names are ambiguous for LEN chars\n\n  -x, --hex             only find numbers expressed as hexadecimal\n  -d, --decimal         only find numbers expressed as decimal\n  -o, --octal           only find numbers expressed as octal\n            By default, searches match numbers of any radix.\n\n      --help            display this help and exit\n      --version         output version information and exit\n"	*(char)
)	O
,	O
(	O
separator_style	enum(int,int,int,int,int)
==	O
ss_braces	int
?	O
_	O
(	O
"braces"	*(char)
)	O
:	O
_	O
(	O
"space"	*(char)
)	O
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"\nReport bugs to "	*(char)
PACKAGE_BUGREPORT	*(char)
"\n\n"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
program_name	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_name	*(char)
=	O
0	int
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"f:F:a:k:R:S:ilrwsxdo"	*(char)
,	O
long_options	array(struct(*(char),int,*(int),int))
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'f'	O
:	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_name	*(char)
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'F'	O
:	O
parse_frequency_arg	(*(char))->(void)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
ambiguous_prefix_length	int
=	O
stoi	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
key_style	enum(int,int,int,int)
=	O
parse_key_style	(*(char))->(enum(int,int,int,int))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
result_style	enum(int,int,int,int,int)
=	O
parse_result_style	(*(char))->(enum(int,int,int,int,int))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
separator_style	enum(int,int,int,int,int)
=	O
parse_separator_style	(*(char))->(enum(int,int,int,int,int))
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
ignore_case_flag	int
=	O
REG_ICASE	O
;	O
break	O
;	O
case	O
'l'	O
:	O
pattern_style	enum(int,int,int,int)
=	O
ps_literal	int
;	O
break	O
;	O
case	O
'r'	O
:	O
pattern_style	enum(int,int,int,int)
=	O
ps_regexp	int
;	O
break	O
;	O
case	O
'e'	O
:	O
pattern_style	enum(int,int,int,int)
=	O
ps_regexp	int
;	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"notice: use of `-e' is deprecated, use `-r' instead"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
'w'	O
:	O
delimiter_style	enum(int,int,int,int)
=	O
ds_word	int
;	O
break	O
;	O
case	O
's'	O
:	O
delimiter_style	enum(int,int,int,int)
=	O
ds_substring	int
;	O
break	O
;	O
case	O
'x'	O
:	O
radix_flag	int
|=	O
radix_hex	int
;	O
break	O
;	O
case	O
'd'	O
:	O
radix_flag	int
|=	O
radix_dec	int
;	O
break	O
;	O
case	O
'o'	O
:	O
radix_flag	int
|=	O
radix_oct	int
;	O
break	O
;	O
default	O
:	O
usage	()->(void)
(	O
)	O
;	O
}	O
}	O
if	O
(	O
show_version	int
)	O
{	O
printf	(*(char))->(int)
(	O
"%s - %s\n"	*(char)
,	O
program_name	*(char)
,	O
PACKAGE_VERSION	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
show_help	int
)	O
help_me	()->(void)
(	O
)	O
;	O
if	O
(	O
separator_style	enum(int,int,int,int,int)
==	O
ss_contextual	int
)	O
{	O
if	O
(	O
isatty	(int)->(int)
(	O
STDOUT_FILENO	int
)	O
)	O
separator_style	enum(int,int,int,int,int)
=	O
DEFAULT_SEPARATOR_STYLE	O
;	O
else	O
if	O
(	O
key_style	enum(int,int,int,int)
==	O
ks_none	int
)	O
separator_style	enum(int,int,int,int,int)
=	O
ss_newline	int
;	O
else	O
separator_style	enum(int,int,int,int,int)
=	O
ss_space	int
;	O
}	O
argc	int
-=	O
optind	int
;	O
argv	*(*(char))
+=	O
optind	int
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
static	O
char	O
dot	array(char)
[	O
]	O
=	O
"."	*(char)
;	O
static	O
char	O
*	O
dotp	*(char)
=	O
dot	array(char)
;	O
argc	int
=	O
1	int
;	O
argv	*(*(char))
=	O
&	O
dotp	*(char)
;	O
}	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_name	*(char)
=	O
locate_id_file_name	(*(char))->(*(char))
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_name	*(char)
)	O
;	O
if	O
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_name	*(char)
==	O
0	int
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't locate `ID'"	*(char)
)	O
)	O
;	O
init_idh_obstacks	(*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))))->(void)
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
init_idh_tables	(*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))))->(void)
(	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
cw_dlink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
=	O
get_current_dir_link	()->(*(struct(union(*(struct`),long),char,array(char))))
(	O
)	O
;	O
members_0	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
read_id_file	(*(char),*(struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),struct(*(*`),long,long,long,long,long,long,int,*((*`)->(long)),*((*`)->(long)),*((*`,*`)->(int))),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),int,*((*`,long)->(*`)),*((*`,*`)->(void)),*(void),int,int,int),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))))))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_file_name	*(char)
,	O
&	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
)	O
;	O
bits_vec_size	int
=	O
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_files	long
+	O
7	int
)	O
/	O
4	int
;	O
tree8_levels	int
=	O
tree8_count_levels	(int)->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_files	long
)	O
;	O
hits_buf_1	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_buf_size	long
)	O
;	O
hits_buf_2	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_buf_size	long
)	O
;	O
bits_vec	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
bits_vec_size	int
)	O
;	O
report_function	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
=	O
get_report_func	()->(*((*(char),*(*(struct`)))->(void)))
(	O
)	O
;	O
if	O
(	O
ambiguous_prefix_length	int
)	O
{	O
if	O
(	O
!	O
query_ambiguous_prefix	(int,*((*(char),*(*(struct`)))->(void)))->(int)
(	O
ambiguous_prefix_length	int
,	O
report_function	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"All identifiers are non-ambiguous within the first %d characters\n"	*(char)
)	O
,	O
ambiguous_prefix_length	int
)	O
;	O
}	O
else	O
{	O
while	O
(	O
argc	int
)	O
{	O
char	O
*	O
pattern	*(char)
=	O
(	O
argc	int
--	O
,	O
*	O
argv	*(*(char))
++	O
)	O
;	O
if	O
(	O
ignore_case_flag	int
)	O
lower_caseify	(*(char))->(void)
(	O
pattern	*(char)
)	O
;	O
query_function	*((*(char),*((*(char),*(*`))->(void)))->(int))
=	O
get_query_func	(*(char))->(*((*(char),*((*`,*`)->(void)))->(int)))
(	O
pattern	*(char)
)	O
;	O
(	O
*	O
query_function	*((*(char),*((*(char),*(*`))->(void)))->(int))
)	O
(	O
pattern	*(char)
,	O
report_function	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
;	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
void	O
lower_caseify	(*(char))->(void)
(	O
char	O
*	O
str	*(char)
)	O
{	O
while	O
(	O
*	O
str	*(char)
)	O
{	O
*	O
str	*(char)
=	O
TOLOWER	O
(	O
*	O
str	*(char)
)	O
;	O
str	*(char)
++	O
;	O
}	O
}	O
enum	O
key_style	enum(int,int,int,int)
parse_key_style	(*(char))->(enum(int,int,int,int))
(	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	*(char)
,	O
"none"	*(char)
,	O
ks_none	int
)	O
;	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	*(char)
,	O
"token"	*(char)
,	O
ks_token	int
)	O
;	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	*(char)
,	O
"pattern"	*(char)
,	O
ks_pattern	int
)	O
;	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"invalid `--key' style: `%s'"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
usage	()->(void)
(	O
)	O
;	O
return	O
ks_bogus	int
;	O
}	O
enum	O
result_style	enum(int,int,int,int,int)
parse_result_style	(*(char))->(enum(int,int,int,int,int))
(	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	*(char)
,	O
"none"	*(char)
,	O
rs_none	int
)	O
;	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	*(char)
,	O
"filenames"	*(char)
,	O
rs_filenames	int
)	O
;	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	*(char)
,	O
"grep"	*(char)
,	O
rs_grep	int
)	O
;	O
MAYBE_RETURN_PREFIX_MATCH	O
(	O
arg	*(char)
,	O
"edit"	*(char)
,	O
rs_edit	int
)	O
;	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"invalid `--result' style: `%s'"	*(char)
)	O
,	O
arg	*(char)
)	O
;	O
usage	()->(void)
(	O
)	O
;	O
return	O
rs_bogus	int
;	O
}	O
query_func_t	*((*(char),*((*(char),*(*`))->(void)))->(int))
get_query_func	(*(char))->(*((*(char),*((*`,*`)->(void)))->(int)))
(	O
char	O
*	O
pattern	*(char)
)	O
{	O
switch	O
(	O
pattern_style	enum(int,int,int,int)
)	O
{	O
case	O
ps_regexp	int
:	O
return	O
query_regexp	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
;	O
case	O
ps_literal	int
:	O
if	O
(	O
delimiter_style	enum(int,int,int,int)
==	O
ds_substring	int
)	O
return	O
query_literal_substring	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
;	O
else	O
return	O
query_literal_word	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
;	O
default	O
:	O
if	O
(	O
is_regexp	(*(char))->(int)
(	O
pattern	*(char)
)	O
)	O
return	O
query_regexp	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
;	O
else	O
if	O
(	O
has_left_delimiter	(*(char))->(int)
(	O
pattern	*(char)
)	O
)	O
return	O
query_literal_prefix	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
;	O
else	O
if	O
(	O
delimiter_style	enum(int,int,int,int)
==	O
ds_substring	int
)	O
return	O
query_literal_substring	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
;	O
else	O
if	O
(	O
is_number	(*(char))->(int)
(	O
pattern	*(char)
)	O
)	O
return	O
query_number	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
;	O
else	O
if	O
(	O
delimiter_style	enum(int,int,int,int)
==	O
ds_word	int
)	O
return	O
query_literal_word	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
;	O
else	O
return	O
query_literal_word	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
;	O
}	O
}	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
get_report_func	()->(*((*(char),*(*(struct`)))->(void)))
(	O
void	O
)	O
{	O
switch	O
(	O
result_style	enum(int,int,int,int,int)
)	O
{	O
case	O
rs_filenames	int
:	O
return	O
report_filenames	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
;	O
case	O
rs_grep	int
:	O
return	O
report_grep	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
;	O
case	O
rs_edit	int
:	O
return	O
report_edit	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
;	O
default	O
:	O
return	O
report_nothing	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
;	O
}	O
}	O
void	O
report_filenames	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
{	O
if	O
(	O
name	*(char)
&&	O
key_style	enum(int,int,int,int)
!=	O
ks_none	int
)	O
printf	(*(char))->(int)
(	O
"%-14s "	*(char)
,	O
name	*(char)
)	O
;	O
print_filenames	(*(*(struct(union(*`,long),char,array(char)))),enum(int,int,int,int,int))->(void)
(	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
,	O
separator_style	enum(int,int,int,int,int)
)	O
;	O
}	O
void	O
report_grep	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
{	O
char	O
line	*(char)
[	O
1	int
<<	O
020	int
]	O
;	O
char	O
const	O
*	O
pattern	*(char)
=	O
0	int
;	O
regex_t	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
compiled	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
char	O
*	O
file_name	*(char)
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
if	O
(	O
key_style	enum(int,int,int,int)
==	O
ks_pattern	int
)	O
{	O
pattern	*(char)
=	O
file_regexp	(*(char),*(char),*(char))->(*(char))
(	O
name	*(char)
,	O
"[^a-zA-Z0-9_\300-\377]_*"	*(char)
,	O
"[^a-zA-Z0-9_\300-\377]"	*(char)
)	O
;	O
if	O
(	O
pattern	*(char)
)	O
{	O
int	O
regcomp_errno	int
=	O
regcomp	O
(	O
&	O
compiled	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
pattern	*(char)
,	O
ignore_case_flag	int
|	O
REG_EXTENDED	int
)	O
;	O
if	O
(	O
regcomp_errno	int
)	O
{	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
;	O
regerror	O
(	O
regcomp_errno	int
,	O
&	O
compiled	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
0	int
,	O
"%s"	*(char)
,	O
buf	*(char)
)	O
;	O
}	O
}	O
}	O
line	*(char)
[	O
0	int
]	O
=	O
' '	O
;	O
while	O
(	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
{	O
int	O
line_number	int
=	O
0	int
;	O
FILE	struct
*	O
source_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
maybe_relative_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
file_name	*(char)
,	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
++	O
,	O
cw_dlink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
source_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
file_name	*(char)
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
source_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"can't open `%s'"	*(char)
,	O
file_name	*(char)
)	O
;	O
continue	O
;	O
}	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
line	*(char)
+	O
1	int
,	O
sizeof	O
(	O
line	*(char)
)	O
-	O
1	int
,	O
source_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
line_number	int
++	O
;	O
if	O
(	O
pattern	*(char)
)	O
{	O
int	O
regexec_errno	int
=	O
regexec	O
(	O
&	O
compiled	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
line	*(char)
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
regexec_errno	int
==	O
REG_ESPACE	O
)	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
0	int
,	O
"can't match regular-expression: memory exhausted"	*(char)
)	O
;	O
else	O
if	O
(	O
regexec_errno	int
)	O
continue	O
;	O
}	O
else	O
if	O
(	O
word_match	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
line	*(char)
)	O
)	O
printf	(*(char))->(int)
(	O
"%s:%d:%s"	*(char)
,	O
file_name	*(char)
,	O
line_number	int
,	O
line	*(char)
+	O
1	int
)	O
;	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
source_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
}	O
static	O
char	O
*	O
*	O
get_editor_argv	(*(char),*(int))->(*(*(char)))
(	O
char	O
*	O
fullstring	*(char)
,	O
int	O
*	O
argc	int
)	O
{	O
int	O
i	int
;	O
char	O
*	O
mark	*(char)
;	O
char	O
*	O
*	O
argv	*(*(char))
;	O
static	O
int	O
already_called	int
;	O
assert	O
(	O
already_called	int
==	O
0	int
)	O
;	O
*	O
argc	int
=	O
1	int
;	O
mark	*(char)
=	O
fullstring	*(char)
;	O
while	O
(	O
(	O
mark	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
mark	*(char)
,	O
' '	O
)	O
)	O
)	O
{	O
(	O
*	O
argc	int
)	O
++	O
;	O
mark	*(char)
+=	O
strspn	(*(char),*(char))->(long)
(	O
mark	*(char)
,	O
" "	*(char)
)	O
;	O
}	O
argv	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
*	O
argc	int
+	O
1	int
)	O
)	O
;	O
fullstring	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
fullstring	*(char)
)	O
;	O
argv	*(*(char))
[	O
0	int
]	O
=	O
strtok	(*(char),*(char))->(*(char))
(	O
fullstring	*(char)
,	O
" "	*(char)
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
(	O
*	O
argc	int
+	O
1	int
)	O
;	O
i	int
++	O
)	O
{	O
argv	*(*(char))
[	O
i	int
]	O
=	O
strtok	(*(char),*(char))->(*(char))
(	O
NULL	O
,	O
" "	*(char)
)	O
;	O
}	O
already_called	int
=	O
1	int
;	O
return	O
argv	*(*(char))
;	O
}	O
void	O
report_edit	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
{	O
static	O
char	O
*	O
editor	*(char)
;	O
static	O
char	O
*	O
*	O
editor_argv	*(*(char))
;	O
static	O
int	O
editor_argc	int
;	O
static	O
char	O
const	O
*	O
eid_arg	*(char)
;	O
static	O
char	O
const	O
*	O
eid_right_del	*(char)
;	O
static	O
char	O
const	O
*	O
eid_left_del	*(char)
;	O
char	O
regexp_buf	array(char)
[	O
BUFSIZ	int
]	O
;	O
char	O
ed_arg_buffer	array(char)
[	O
BUFSIZ	int
]	O
;	O
char	O
const	O
*	O
pattern	*(char)
;	O
int	O
c	int
;	O
int	O
skip	int
;	O
if	O
(	O
!	O
editor	*(char)
)	O
if	O
(	O
!	O
(	O
editor	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"VISUAL"	*(char)
)	O
)	O
)	O
if	O
(	O
!	O
(	O
editor	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"EDITOR"	*(char)
)	O
)	O
)	O
editor	*(char)
=	O
"vi"	*(char)
;	O
if	O
(	O
!	O
editor_argv	*(*(char))
)	O
editor_argv	*(*(char))
=	O
get_editor_argv	(*(char),*(int))->(*(*(char)))
(	O
editor	*(char)
,	O
&	O
editor_argc	int
)	O
;	O
if	O
(	O
!	O
eid_arg	*(char)
)	O
{	O
int	O
using_vi	int
;	O
using_vi	int
=	O
strequ	O
(	O
"vi"	*(char)
,	O
base_name	(*(char))->(*(char))
(	O
editor	*(char)
)	O
)	O
||	O
strequ	O
(	O
"vim"	*(char)
,	O
base_name	(*(char))->(*(char))
(	O
editor	*(char)
)	O
)	O
;	O
eid_arg	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"EIDARG"	*(char)
)	O
;	O
if	O
(	O
!	O
eid_arg	*(char)
)	O
eid_arg	*(char)
=	O
(	O
using_vi	int
?	O
"+1;/%s/"	*(char)
:	O
""	*(char)
)	O
;	O
eid_left_del	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"EIDLDEL"	*(char)
)	O
;	O
if	O
(	O
eid_left_del	*(char)
==	O
0	int
)	O
eid_left_del	*(char)
=	O
(	O
using_vi	int
?	O
"\\<"	*(char)
:	O
""	*(char)
)	O
;	O
eid_right_del	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"EIDRDEL"	*(char)
)	O
;	O
if	O
(	O
eid_right_del	*(char)
==	O
0	int
)	O
eid_right_del	*(char)
=	O
(	O
using_vi	int
?	O
"\\>"	*(char)
:	O
""	*(char)
)	O
;	O
}	O
report_filenames	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
(	O
name	*(char)
,	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
;	O
savetty	()->(void)
(	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"edit? [y1-9^S/nq] "	*(char)
)	O
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
chartty	()->(void)
(	O
)	O
;	O
c	int
=	O
(	O
getchar	()->(int)
(	O
)	O
&	O
0177	int
)	O
;	O
restoretty	()->(void)
(	O
)	O
;	O
switch	O
(	O
TOLOWER	O
(	O
c	int
)	O
)	O
{	O
case	O
'/'	O
:	O
case	O
(	O
's'	O
&	O
037	int
)	O
:	O
putchar	(int)->(int)
(	O
'/'	O
)	O
;	O
skip	int
=	O
search_flinkv	(*(*(struct(union(*`,long),char,array(char)))))->(int)
(	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
;	O
if	O
(	O
skip	int
<	O
0	int
)	O
continue	O
;	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
+=	O
skip	int
;	O
goto	O
editit	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
putchar	(int)->(int)
(	O
c	int
)	O
;	O
skip	int
=	O
c	int
-	O
'0'	O
;	O
break	O
;	O
case	O
'y'	O
:	O
putchar	(int)->(int)
(	O
c	int
)	O
;	O
skip	int
=	O
0	int
;	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
'\r'	O
:	O
putchar	(int)->(int)
(	O
'y'	O
)	O
;	O
skip	int
=	O
0	int
;	O
break	O
;	O
case	O
'q'	O
:	O
putchar	(int)->(int)
(	O
c	int
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
case	O
'n'	O
:	O
putchar	(int)->(int)
(	O
c	int
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
return	O
;	O
default	O
:	O
putchar	(int)->(int)
(	O
c	int
)	O
;	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
continue	O
;	O
}	O
putchar	(int)->(int)
(	O
'\n'	O
)	O
;	O
while	O
(	O
skip	int
--	O
)	O
if	O
(	O
*	O
++	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
==	O
0	int
)	O
continue	O
;	O
break	O
;	O
}	O
editit	O
:	O
if	O
(	O
key_style	enum(int,int,int,int)
==	O
ks_pattern	int
)	O
pattern	*(char)
=	O
file_regexp	(*(char),*(char),*(char))->(*(char))
(	O
name	*(char)
,	O
eid_left_del	*(char)
,	O
eid_right_del	*(char)
)	O
;	O
else	O
pattern	*(char)
=	O
0	int
;	O
if	O
(	O
pattern	*(char)
==	O
0	int
)	O
{	O
pattern	*(char)
=	O
regexp_buf	array(char)
;	O
sprintf	(*(char),*(char))->(int)
(	O
regexp_buf	array(char)
,	O
"%s%s%s"	*(char)
,	O
eid_left_del	*(char)
,	O
name	*(char)
,	O
eid_right_del	*(char)
)	O
;	O
}	O
switch	O
(	O
fork	()->(int)
(	O
)	O
)	O
{	O
case	O
-	O
1	int
:	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't fork"	*(char)
)	O
)	O
;	O
break	O
;	O
case	O
0	int
:	O
{	O
int	O
i	int
;	O
char	O
*	O
*	O
argv	*(*(char))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
editor_argc	int
+	O
2	int
+	O
vector_cardinality	(*(void))->(int)
(	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
editor_argc	int
;	O
i	int
++	O
)	O
argv	*(*(char))
[	O
i	int
]	O
=	O
editor_argv	*(*(char))
[	O
i	int
]	O
;	O
if	O
(	O
*	O
eid_arg	*(char)
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
ed_arg_buffer	array(char)
,	O
eid_arg	*(char)
,	O
pattern	*(char)
)	O
;	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
ed_arg_buffer	array(char)
;	O
}	O
while	O
(	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
argv	*(*(char))
[	O
i	int
++	O
]	O
=	O
maybe_relative_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
0	int
,	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
++	O
,	O
cw_dlink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
argv	*(*(char))
[	O
i	int
]	O
=	O
0	int
;	O
execvp	(*(char),array(*(char)))->(int)
(	O
editor_argv	*(*(char))
[	O
0	int
]	O
,	O
argv	*(*(char))
)	O
;	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't exec `%s'"	*(char)
)	O
,	O
editor_argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
}	O
default	O
:	O
{	O
void	O
(	O
*	O
oldint	*((int)->(void))
)	O
(	O
int	O
)	O
=	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
SIG_IGN	O
)	O
;	O
void	O
(	O
*	O
oldquit	*((int)->(void))
)	O
(	O
int	O
)	O
=	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGQUIT	int
,	O
SIG_IGN	O
)	O
;	O
while	O
(	O
wait	(*(int))->(int)
(	O
0	int
)	O
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGINT	int
,	O
oldint	*((int)->(void))
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGQUIT	int
,	O
oldquit	*((int)->(void))
)	O
;	O
}	O
break	O
;	O
}	O
}	O
void	O
report_nothing	(*(char),*(*(struct(union(*`,long),char,array(char)))))->(void)
(	O
char	O
const	O
*	O
name	*(char)
,	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
{	O
if	O
(	O
key_style	enum(int,int,int,int)
!=	O
ks_none	int
)	O
puts	(*(char))->(int)
(	O
name	*(char)
)	O
;	O
}	O
int	O
vector_cardinality	(*(void))->(int)
(	O
void	O
*	O
vector	*(void)
)	O
{	O
void	O
*	O
*	O
v	*(*(void))
=	O
(	O
void	O
*	O
*	O
)	O
vector	*(void)
;	O
int	O
count	int
=	O
0	int
;	O
while	O
(	O
*	O
v	*(*(void))
++	O
)	O
count	int
++	O
;	O
return	O
count	int
;	O
}	O
int	O
search_flinkv	(*(*(struct(union(*`,long),char,array(char)))))->(int)
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
)	O
{	O
char	O
pattern	*(char)
[	O
BUFSIZ	int
]	O
;	O
unsigned	O
int	O
count	int
;	O
char	O
*	O
file_name	*(char)
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
char	O
*	O
eol	*(char)
;	O
if	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
pattern	*(char)
,	O
sizeof	O
(	O
pattern	*(char)
)	O
,	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
0	int
)	O
return	O
-	O
1	int
;	O
eol	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
pattern	*(char)
,	O
'\n'	O
)	O
;	O
if	O
(	O
eol	*(char)
)	O
*	O
eol	*(char)
=	O
0	int
;	O
for	O
(	O
count	int
=	O
0	int
;	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
count	int
++	O
,	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
++	O
)	O
{	O
maybe_relative_file_name	(*(char),*(struct(union(*(struct`),long),char,array(char))),*(struct(union(*(struct`),long),char,array(char))))->(*(char))
(	O
file_name	*(char)
,	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
,	O
cw_dlink	*(struct(union(*(struct(union`,char,array(char))),long),char,array(char)))
)	O
;	O
if	O
(	O
strcasestr	(*(char),*(char))->(*(char))
(	O
file_name	*(char)
,	O
pattern	*(char)
)	O
)	O
return	O
count	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
query_literal_word	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
char	O
const	O
*	O
arg	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
{	O
if	O
(	O
ignore_case_flag	int
)	O
return	O
query_literal_substring	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
arg	*(char)
,	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
;	O
if	O
(	O
query_binary_search	(*(char))->(long)
(	O
arg	*(char)
)	O
==	O
0	int
)	O
return	O
0	int
;	O
gets_past_00	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
hits_buf_1	*(char)
,	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
assert	O
(	O
*	O
hits_buf_1	*(char)
)	O
;	O
if	O
(	O
!	O
desired_frequency	(*(char))->(int)
(	O
hits_buf_1	*(char)
)	O
)	O
return	O
0	int
;	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
hits_buf_1	*(char)
,	O
tree8_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
token_hits_addr	(*(char))->(*(char))
(	O
hits_buf_1	*(char)
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
query_literal_prefix	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
char	O
const	O
*	O
arg	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
{	O
int	O
count	int
;	O
unsigned	O
int	O
length	int
;	O
if	O
(	O
ignore_case_flag	int
)	O
return	O
query_regexp	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
arg	*(char)
,	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
;	O
if	O
(	O
query_binary_search	(*(char))->(long)
(	O
++	O
arg	*(char)
)	O
==	O
0	int
)	O
return	O
0	int
;	O
length	int
=	O
strlen	(*(char))->(long)
(	O
arg	*(char)
)	O
;	O
count	int
=	O
0	int
;	O
if	O
(	O
key_style	enum(int,int,int,int)
!=	O
ks_token	int
)	O
memset	(*(void),int,long)->(*(void))
(	O
bits_vec	*(char)
,	O
0	int
,	O
bits_vec_size	int
)	O
;	O
while	O
(	O
gets_past_00	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
hits_buf_1	*(char)
,	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
>	O
0	int
)	O
{	O
assert	O
(	O
*	O
hits_buf_1	*(char)
)	O
;	O
if	O
(	O
!	O
desired_frequency	(*(char))->(int)
(	O
hits_buf_1	*(char)
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
strnequ	O
(	O
arg	*(char)
,	O
hits_buf_1	*(char)
,	O
length	int
)	O
)	O
break	O
;	O
if	O
(	O
key_style	enum(int,int,int,int)
==	O
ks_token	int
)	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
hits_buf_1	*(char)
,	O
tree8_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
token_hits_addr	(*(char))->(*(char))
(	O
hits_buf_1	*(char)
)	O
)	O
)	O
;	O
else	O
tree8_to_bits	(*(char),*(char))->(*(char))
(	O
bits_vec	*(char)
,	O
token_hits_addr	(*(char))->(*(char))
(	O
hits_buf_1	*(char)
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
key_style	enum(int,int,int,int)
!=	O
ks_token	int
&&	O
count	int
)	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
--	O
arg	*(char)
,	O
bits_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
bits_vec	*(char)
)	O
)	O
;	O
return	O
count	int
;	O
}	O
int	O
query_regexp	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
char	O
const	O
*	O
pattern_0	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
{	O
int	O
count	int
;	O
regex_t	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
compiled	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
int	O
regcomp_errno	int
;	O
char	O
const	O
*	O
pattern	*(char)
=	O
pattern_0	*(char)
;	O
if	O
(	O
delimiter_style	enum(int,int,int,int)
==	O
ds_word	int
)	O
pattern	*(char)
=	O
add_regexp_word_delimiters	(*(char))->(*(char))
(	O
pattern	*(char)
)	O
;	O
regcomp_errno	int
=	O
regcomp	O
(	O
&	O
compiled	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
pattern	*(char)
,	O
ignore_case_flag	int
|	O
REG_EXTENDED	int
)	O
;	O
if	O
(	O
regcomp_errno	int
)	O
{	O
char	O
buf	*(char)
[	O
BUFSIZ	int
]	O
;	O
regerror	O
(	O
regcomp_errno	int
,	O
&	O
compiled	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
buf	*(char)
,	O
sizeof	O
(	O
buf	*(char)
)	O
)	O
;	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
0	int
,	O
"%s"	*(char)
,	O
buf	*(char)
)	O
;	O
}	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_tokens_offset	long
,	O
SEEK_SET	int
)	O
;	O
count	int
=	O
0	int
;	O
if	O
(	O
key_style	enum(int,int,int,int)
!=	O
ks_token	int
)	O
memset	(*(void),int,long)->(*(void))
(	O
bits_vec	*(char)
,	O
0	int
,	O
bits_vec_size	int
)	O
;	O
while	O
(	O
gets_past_00	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
hits_buf_1	*(char)
,	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
>	O
0	int
)	O
{	O
int	O
regexec_errno	int
;	O
assert	O
(	O
*	O
hits_buf_1	*(char)
)	O
;	O
if	O
(	O
!	O
desired_frequency	(*(char))->(int)
(	O
hits_buf_1	*(char)
)	O
)	O
continue	O
;	O
regexec_errno	int
=	O
regexec	O
(	O
&	O
compiled	struct(*(char),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
hits_buf_1	*(char)
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
regexec_errno	int
==	O
REG_ESPACE	O
)	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"can't match regular-expression: memory exhausted"	*(char)
)	O
)	O
;	O
else	O
if	O
(	O
regexec_errno	int
)	O
continue	O
;	O
if	O
(	O
key_style	enum(int,int,int,int)
==	O
ks_token	int
)	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
hits_buf_1	*(char)
,	O
tree8_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
token_hits_addr	(*(char))->(*(char))
(	O
hits_buf_1	*(char)
)	O
)	O
)	O
;	O
else	O
tree8_to_bits	(*(char),*(char))->(*(char))
(	O
bits_vec	*(char)
,	O
token_hits_addr	(*(char))->(*(char))
(	O
hits_buf_1	*(char)
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
key_style	enum(int,int,int,int)
!=	O
ks_token	int
&&	O
count	int
)	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
pattern	*(char)
,	O
bits_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
bits_vec	*(char)
)	O
)	O
;	O
if	O
(	O
pattern	*(char)
!=	O
pattern_0	*(char)
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
pattern	*(char)
)	O
;	O
return	O
count	int
;	O
}	O
char	O
const	O
*	O
add_regexp_word_delimiters	(*(char))->(*(char))
(	O
char	O
const	O
*	O
pattern_0	*(char)
)	O
{	O
int	O
length	int
=	O
strlen	(*(char))->(long)
(	O
pattern_0	*(char)
)	O
;	O
int	O
has_left	int
=	O
has_left_delimiter	(*(char))->(int)
(	O
pattern_0	*(char)
)	O
;	O
int	O
has_right	int
=	O
has_right_delimiter	(*(char))->(int)
(	O
&	O
pattern_0	*(char)
[	O
length	int
]	O
)	O
;	O
if	O
(	O
has_left	int
&&	O
has_right	int
)	O
return	O
pattern_0	*(char)
;	O
else	O
{	O
char	O
*	O
pattern	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
length	int
+	O
4	int
)	O
;	O
if	O
(	O
has_left	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
pattern	*(char)
,	O
pattern_0	*(char)
)	O
;	O
else	O
{	O
length	int
+=	O
2	int
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
pattern	*(char)
,	O
"\\<"	*(char)
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
pattern	*(char)
+	O
2	int
,	O
pattern_0	*(char)
)	O
;	O
}	O
if	O
(	O
!	O
has_right	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
pattern	*(char)
+	O
length	int
,	O
"\\>"	*(char)
)	O
;	O
return	O
pattern	*(char)
;	O
}	O
}	O
int	O
query_number	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
char	O
const	O
*	O
arg	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
{	O
int	O
count	int
;	O
int	O
radix	enum(int,int,int,int)
;	O
int	O
val	int
;	O
int	O
hit_digits	int
=	O
0	int
;	O
radix	enum(int,int,int,int)
=	O
(	O
val	int
=	O
stoi	(*(char))->(int)
(	O
arg	*(char)
)	O
)	O
?	O
radix_all	int
:	O
get_radix	(*(char))->(int)
(	O
arg	*(char)
)	O
;	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_tokens_offset	long
,	O
SEEK_SET	int
)	O
;	O
count	int
=	O
0	int
;	O
if	O
(	O
key_style	enum(int,int,int,int)
!=	O
ks_token	int
)	O
memset	(*(void),int,long)->(*(void))
(	O
bits_vec	*(char)
,	O
0	int
,	O
bits_vec_size	int
)	O
;	O
while	O
(	O
gets_past_00	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
hits_buf_1	*(char)
,	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
>	O
0	int
)	O
{	O
if	O
(	O
hit_digits	int
)	O
{	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
*	O
hits_buf_1	*(char)
)	O
)	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
hits_buf_1	*(char)
)	O
)	O
hit_digits	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
(	O
(	O
radix_flag	int
?	O
radix_flag	int
:	O
radix	enum(int,int,int,int)
)	O
&	O
get_radix	(*(char))->(int)
(	O
hits_buf_1	*(char)
)	O
)	O
||	O
stoi	(*(char))->(int)
(	O
hits_buf_1	*(char)
)	O
!=	O
val	int
)	O
continue	O
;	O
if	O
(	O
key_style	enum(int,int,int,int)
==	O
ks_token	int
)	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
hits_buf_1	*(char)
,	O
tree8_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
token_hits_addr	(*(char))->(*(char))
(	O
hits_buf_1	*(char)
)	O
)	O
)	O
;	O
else	O
tree8_to_bits	(*(char),*(char))->(*(char))
(	O
bits_vec	*(char)
,	O
token_hits_addr	(*(char))->(*(char))
(	O
hits_buf_1	*(char)
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
key_style	enum(int,int,int,int)
!=	O
ks_token	int
&&	O
count	int
)	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
arg	*(char)
,	O
bits_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
bits_vec	*(char)
)	O
)	O
;	O
return	O
count	int
;	O
}	O
int	O
query_ambiguous_prefix	(int,*((*(char),*(*(struct`)))->(void)))->(int)
(	O
unsigned	O
int	O
limit	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
{	O
char	O
*	O
old	*(char)
=	O
hits_buf_1	*(char)
;	O
char	O
*	O
new	*(char)
=	O
hits_buf_2	*(char)
;	O
int	O
consecutive	int
=	O
0	int
;	O
int	O
count	int
=	O
0	int
;	O
char	O
name	*(char)
[	O
1024	int
]	O
;	O
if	O
(	O
limit	*(char)
<=	O
1	int
)	O
usage	()->(void)
(	O
)	O
;	O
assert	O
(	O
limit	*(char)
<	O
sizeof	O
(	O
name	*(char)
)	O
)	O
;	O
name	*(char)
[	O
0	int
]	O
=	O
'^'	O
;	O
*	O
new	*(char)
=	O
'\0'	O
;	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_tokens_offset	long
,	O
SEEK_SET	int
)	O
;	O
while	O
(	O
gets_past_00	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
old	*(char)
,	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
>	O
0	int
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
if	O
(	O
!	O
(	O
token_flags	(*(char))->(int)
(	O
old	*(char)
)	O
&	O
TOK_NAME	int
)	O
)	O
continue	O
;	O
tmp	*(char)
=	O
old	*(char)
;	O
old	*(char)
=	O
new	*(char)
;	O
new	*(char)
=	O
tmp	*(char)
;	O
if	O
(	O
!	O
strnequ	O
(	O
new	*(char)
,	O
old	*(char)
,	O
limit	*(char)
)	O
)	O
{	O
if	O
(	O
consecutive	int
&&	O
key_style	enum(int,int,int,int)
!=	O
ks_token	int
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
&	O
name	*(char)
[	O
1	int
]	O
,	O
old	*(char)
,	O
limit	*(char)
)	O
;	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
name	*(char)
,	O
bits_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
bits_vec	*(char)
)	O
)	O
;	O
}	O
consecutive	int
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
consecutive	int
++	O
)	O
{	O
if	O
(	O
key_style	enum(int,int,int,int)
!=	O
ks_token	int
)	O
tree8_to_bits	(*(char),*(char))->(*(char))
(	O
bits_vec	*(char)
,	O
token_hits_addr	(*(char))->(*(char))
(	O
old	*(char)
)	O
)	O
;	O
else	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
old	*(char)
,	O
tree8_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
token_hits_addr	(*(char))->(*(char))
(	O
old	*(char)
)	O
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
key_style	enum(int,int,int,int)
==	O
ks_token	int
)	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
new	*(char)
,	O
tree8_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
token_hits_addr	(*(char))->(*(char))
(	O
new	*(char)
)	O
)	O
)	O
;	O
else	O
tree8_to_bits	(*(char),*(char))->(*(char))
(	O
bits_vec	*(char)
,	O
token_hits_addr	(*(char))->(*(char))
(	O
new	*(char)
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
consecutive	int
&&	O
key_style	enum(int,int,int,int)
!=	O
ks_token	int
)	O
{	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
&	O
name	*(char)
[	O
1	int
]	O
,	O
new	*(char)
,	O
limit	*(char)
)	O
;	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
name	*(char)
,	O
bits_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
bits_vec	*(char)
)	O
)	O
;	O
}	O
return	O
count	int
;	O
}	O
int	O
query_literal_substring	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
(	O
char	O
const	O
*	O
arg	*(char)
,	O
report_func_t	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
{	O
int	O
count	int
;	O
int	O
arg_length	int
=	O
0	int
;	O
char	O
*	O
(	O
*	O
strstr_func	*((*(char),*(char))->(*(char)))
)	O
(	O
char	O
const	O
*	O
,	O
char	O
const	O
*	O
)	O
;	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_tokens_offset	long
,	O
SEEK_SET	int
)	O
;	O
if	O
(	O
delimiter_style	enum(int,int,int,int)
==	O
ds_word	int
)	O
arg_length	int
=	O
strlen	(*(char))->(long)
(	O
arg	*(char)
)	O
;	O
count	int
=	O
0	int
;	O
if	O
(	O
key_style	enum(int,int,int,int)
!=	O
ks_token	int
)	O
memset	(*(void),int,long)->(*(void))
(	O
bits_vec	*(char)
,	O
0	int
,	O
bits_vec_size	int
)	O
;	O
strstr_func	*((*(char),*(char))->(*(char)))
=	O
(	O
ignore_case_flag	int
?	O
strcasestr	(*(char),*(char))->(*(char))
:	O
strstr	(*(char),*(char))->(*(char))
)	O
;	O
while	O
(	O
gets_past_00	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
hits_buf_1	*(char)
,	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
>	O
0	int
)	O
{	O
char	O
*	O
match	*(char)
;	O
assert	O
(	O
*	O
hits_buf_1	*(char)
)	O
;	O
if	O
(	O
!	O
desired_frequency	(*(char))->(int)
(	O
hits_buf_1	*(char)
)	O
)	O
continue	O
;	O
match	*(char)
=	O
(	O
*	O
strstr_func	*((*(char),*(char))->(*(char)))
)	O
(	O
hits_buf_1	*(char)
,	O
arg	*(char)
)	O
;	O
if	O
(	O
match	*(char)
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
delimiter_style	enum(int,int,int,int)
==	O
ds_word	int
&&	O
(	O
match	*(char)
>	O
hits_buf_1	*(char)
||	O
strlen	(*(char))->(long)
(	O
hits_buf_1	*(char)
)	O
>	O
arg_length	int
)	O
)	O
continue	O
;	O
if	O
(	O
key_style	enum(int,int,int,int)
==	O
ks_token	int
)	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
hits_buf_1	*(char)
,	O
tree8_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
token_hits_addr	(*(char))->(*(char))
(	O
hits_buf_1	*(char)
)	O
)	O
)	O
;	O
else	O
tree8_to_bits	(*(char),*(char))->(*(char))
(	O
bits_vec	*(char)
,	O
token_hits_addr	(*(char))->(*(char))
(	O
hits_buf_1	*(char)
)	O
)	O
;	O
count	int
++	O
;	O
}	O
if	O
(	O
key_style	enum(int,int,int,int)
!=	O
ks_token	int
&&	O
count	int
)	O
(	O
*	O
report_func	*((*(char),*(*(struct(union`,char,array(char)))))->(void))
)	O
(	O
arg	*(char)
,	O
bits_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
bits_vec	*(char)
)	O
)	O
;	O
return	O
count	int
;	O
}	O
void	O
parse_frequency_arg	(*(char))->(void)
(	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
if	O
(	O
strnequ	O
(	O
arg	*(char)
,	O
".."	*(char)
,	O
2	int
)	O
)	O
frequency_low	int
=	O
1	int
;	O
else	O
{	O
frequency_low	int
=	O
atoi	(*(char))->(int)
(	O
arg	*(char)
)	O
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
arg	*(char)
)	O
)	O
arg	*(char)
++	O
;	O
if	O
(	O
strnequ	O
(	O
arg	*(char)
,	O
".."	*(char)
,	O
2	int
)	O
)	O
arg	*(char)
+=	O
2	int
;	O
}	O
if	O
(	O
*	O
arg	*(char)
)	O
frequency_high	int
=	O
atoi	(*(char))->(int)
(	O
arg	*(char)
)	O
;	O
else	O
if	O
(	O
strnequ	O
(	O
&	O
arg	*(char)
[	O
-	O
1	int
]	O
,	O
".."	*(char)
,	O
2	int
)	O
)	O
frequency_high	int
=	O
USHRT_MAX	O
;	O
else	O
frequency_high	int
=	O
frequency_low	int
;	O
if	O
(	O
frequency_low	int
>	O
frequency_high	int
)	O
{	O
unsigned	O
int	O
tmp	*(char)
=	O
frequency_low	int
;	O
frequency_low	int
=	O
frequency_high	int
;	O
frequency_high	int
=	O
tmp	*(char)
;	O
}	O
}	O
int	O
desired_frequency	(*(char))->(int)
(	O
char	O
const	O
*	O
tok	*(char)
)	O
{	O
unsigned	O
int	O
count	int
=	O
token_count	(*(char))->(short)
(	O
tok	*(char)
)	O
;	O
return	O
(	O
frequency_low	int
<=	O
count	int
&&	O
count	int
<=	O
frequency_high	int
)	O
;	O
}	O
char	O
*	O
strcasestr	(*(char),*(char))->(*(char))
(	O
char	O
const	O
*	O
s1	*(char)
,	O
char	O
const	O
*	O
s2	*(char)
)	O
{	O
char	O
const	O
*	O
s1p	*(char)
;	O
char	O
const	O
*	O
s2p	*(char)
;	O
char	O
const	O
*	O
s1last	*(char)
;	O
for	O
(	O
s1last	*(char)
=	O
&	O
s1	*(char)
[	O
strlen	(*(char))->(long)
(	O
s1	*(char)
)	O
-	O
strlen	(*(char))->(long)
(	O
s2	*(char)
)	O
]	O
;	O
s1	*(char)
<=	O
s1last	*(char)
;	O
s1	*(char)
++	O
)	O
for	O
(	O
s1p	*(char)
=	O
s1	*(char)
,	O
s2p	*(char)
=	O
s2	*(char)
;	O
TOLOWER	O
(	O
*	O
s1p	*(char)
)	O
==	O
TOLOWER	O
(	O
*	O
s2p	*(char)
)	O
;	O
s1p	*(char)
++	O
)	O
if	O
(	O
*	O
++	O
s2p	*(char)
==	O
'\0'	O
)	O
return	O
(	O
char	O
*	O
)	O
s1	*(char)
;	O
return	O
0	int
;	O
}	O
char	O
const	O
*	O
file_regexp	(*(char),*(char),*(char))->(*(char))
(	O
char	O
const	O
*	O
name_0	*(char)
,	O
char	O
const	O
*	O
left_delimit	*(char)
,	O
char	O
const	O
*	O
right_delimit	*(char)
)	O
{	O
static	O
char	O
pat_buf	array(char)
[	O
BUFSIZ	int
]	O
;	O
char	O
*	O
name	*(char)
=	O
(	O
char	O
*	O
)	O
name_0	*(char)
;	O
if	O
(	O
query_function	*((*(char),*((*(char),*(*`))->(void)))->(int))
==	O
query_number	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
&&	O
key_style	enum(int,int,int,int)
==	O
ks_pattern	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
pat_buf	array(char)
,	O
"%s0*[Xx]*0*%d[Ll]*%s"	*(char)
,	O
left_delimit	*(char)
,	O
stoi	(*(char))->(int)
(	O
name	*(char)
)	O
,	O
right_delimit	*(char)
)	O
;	O
return	O
pat_buf	array(char)
;	O
}	O
if	O
(	O
!	O
is_regexp	(*(char))->(int)
(	O
name	*(char)
)	O
&&	O
name	*(char)
[	O
0	int
]	O
!=	O
'^'	O
)	O
return	O
0	int
;	O
if	O
(	O
name	*(char)
[	O
0	int
]	O
==	O
'^'	O
)	O
name_0	*(char)
++	O
;	O
else	O
left_delimit	*(char)
=	O
""	*(char)
;	O
while	O
(	O
*	O
++	O
name	*(char)
)	O
;	O
if	O
(	O
*	O
--	O
name	*(char)
==	O
'$'	O
)	O
*	O
name	*(char)
=	O
'\0'	O
;	O
else	O
right_delimit	*(char)
=	O
""	*(char)
;	O
sprintf	(*(char),*(char))->(int)
(	O
pat_buf	array(char)
,	O
"%s%s%s"	*(char)
,	O
left_delimit	*(char)
,	O
name_0	*(char)
,	O
right_delimit	*(char)
)	O
;	O
return	O
pat_buf	array(char)
;	O
}	O
off_t	long
query_binary_search	(*(char))->(long)
(	O
char	O
const	O
*	O
token_0	*(char)
)	O
{	O
off_t	long
offset	long
=	O
0	int
;	O
off_t	long
start	*(long)
=	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_tokens_offset	long
-	O
2	int
;	O
off_t	long
end	*(long)
=	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_end_offset	long
;	O
off_t	long
anchor_offset	long
=	O
0	int
;	O
int	O
order	int
=	O
-	O
1	int
;	O
while	O
(	O
start	*(long)
<	O
end	*(long)
)	O
{	O
int	O
c	int
;	O
int	O
incr	int
=	O
1	int
;	O
char	O
const	O
*	O
token	*(char)
;	O
offset	long
=	O
start	*(long)
+	O
(	O
end	*(long)
-	O
start	*(long)
)	O
/	O
2	int
;	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
offset	long
,	O
SEEK_SET	int
)	O
;	O
offset	long
+=	O
skip_past_00	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
offset	long
>=	O
end	*(long)
)	O
{	O
offset	long
=	O
start	*(long)
+	O
2	int
;	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
offset	long
,	O
SEEK_SET	int
)	O
;	O
}	O
token	*(char)
=	O
token_0	*(char)
;	O
while	O
(	O
*	O
token	*(char)
==	O
(	O
c	int
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
&&	O
*	O
token	*(char)
&&	O
c	int
)	O
{	O
token	*(char)
++	O
;	O
incr	int
++	O
;	O
}	O
if	O
(	O
c	int
&&	O
!	O
*	O
token	*(char)
&&	O
query_function	*((*(char),*((*(char),*(*`))->(void)))->(int))
==	O
query_literal_prefix	(*(char),*((*(char),*(*(struct`)))->(void)))->(int)
)	O
anchor_offset	long
=	O
offset	long
;	O
order	int
=	O
*	O
token	*(char)
-	O
c	int
;	O
if	O
(	O
order	int
<	O
0	int
)	O
end	*(long)
=	O
offset	long
-	O
2	int
;	O
else	O
if	O
(	O
order	int
>	O
0	int
)	O
start	*(long)
=	O
offset	long
+	O
incr	int
+	O
skip_past_00	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
-	O
2	int
;	O
else	O
break	O
;	O
}	O
if	O
(	O
order	int
)	O
{	O
if	O
(	O
anchor_offset	long
)	O
offset	long
=	O
anchor_offset	long
;	O
else	O
return	O
0	int
;	O
}	O
fseek	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,int)->(int)
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_FILE	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
offset	long
,	O
SEEK_SET	int
)	O
;	O
return	O
offset	long
;	O
}	O
int	O
is_regexp	(*(char))->(int)
(	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
backslash	int
=	O
0	int
;	O
if	O
(	O
*	O
name	*(char)
==	O
'^'	O
)	O
name	*(char)
++	O
;	O
else	O
if	O
(	O
strnequ	O
(	O
name	*(char)
,	O
"\\<"	*(char)
,	O
2	int
)	O
)	O
name	*(char)
+=	O
2	int
;	O
while	O
(	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
*	O
name	*(char)
==	O
'\\'	O
)	O
{	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"<>"	*(char)
,	O
name	*(char)
[	O
1	int
]	O
)	O
)	O
return	O
1	int
;	O
name	*(char)
++	O
,	O
backslash	int
++	O
;	O
}	O
else	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
"[]().*+^$"	*(char)
,	O
*	O
name	*(char)
)	O
)	O
return	O
1	int
;	O
name	*(char)
++	O
;	O
}	O
if	O
(	O
backslash	int
)	O
while	O
(	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
*	O
name	*(char)
==	O
'\\'	O
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
name	*(char)
,	O
name	*(char)
+	O
1	int
)	O
;	O
name	*(char)
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
has_left_delimiter	(*(char))->(int)
(	O
char	O
const	O
*	O
pattern	*(char)
)	O
{	O
return	O
(	O
*	O
pattern	*(char)
==	O
'^'	O
||	O
strnequ	O
(	O
pattern	*(char)
,	O
"\\<"	*(char)
,	O
2	int
)	O
)	O
;	O
}	O
int	O
has_right_delimiter	(*(char))->(int)
(	O
char	O
const	O
*	O
pattern	*(char)
)	O
{	O
return	O
(	O
pattern	*(char)
[	O
-	O
1	int
]	O
==	O
'$'	O
||	O
strequ	O
(	O
pattern	*(char)
-	O
2	int
,	O
"\\>"	*(char)
)	O
)	O
;	O
}	O
int	O
file_name_wildcard	(*(char),*(char))->(int)
(	O
char	O
const	O
*	O
pattern	*(char)
,	O
char	O
const	O
*	O
fn	*(char)
)	O
{	O
int	O
c	int
;	O
int	O
i	int
;	O
char	O
set	array(char)
[	O
256	int
]	O
;	O
int	O
revset	int
;	O
while	O
(	O
(	O
c	int
=	O
*	O
pattern	*(char)
++	O
)	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
c	int
==	O
'*'	O
)	O
{	O
if	O
(	O
*	O
pattern	*(char)
==	O
'\0'	O
)	O
return	O
1	int
;	O
while	O
(	O
*	O
fn	*(char)
!=	O
'\0'	O
)	O
{	O
if	O
(	O
file_name_wildcard	(*(char),*(char))->(int)
(	O
pattern	*(char)
,	O
fn	*(char)
)	O
)	O
return	O
1	int
;	O
++	O
fn	*(char)
;	O
}	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'?'	O
)	O
{	O
if	O
(	O
*	O
fn	*(char)
++	O
==	O
'\0'	O
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'['	O
)	O
{	O
c	int
=	O
*	O
pattern	*(char)
++	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
set	array(char)
,	O
0	int
,	O
256	int
)	O
;	O
if	O
(	O
c	int
==	O
'!'	O
)	O
{	O
revset	int
=	O
1	int
;	O
c	int
=	O
*	O
pattern	*(char)
++	O
;	O
}	O
else	O
revset	int
=	O
0	int
;	O
while	O
(	O
c	int
!=	O
']'	O
)	O
{	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
c	int
=	O
*	O
pattern	*(char)
++	O
;	O
set	array(char)
[	O
c	int
]	O
=	O
1	int
;	O
if	O
(	O
(	O
*	O
pattern	*(char)
==	O
'-'	O
)	O
&&	O
(	O
*	O
(	O
pattern	*(char)
+	O
1	int
)	O
!=	O
']'	O
)	O
)	O
{	O
pattern	*(char)
+=	O
1	int
;	O
while	O
(	O
++	O
c	int
<=	O
*	O
pattern	*(char)
)	O
set	array(char)
[	O
c	int
]	O
=	O
1	int
;	O
++	O
pattern	*(char)
;	O
}	O
c	int
=	O
*	O
pattern	*(char)
++	O
;	O
}	O
if	O
(	O
revset	int
)	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
256	int
;	O
++	O
i	int
)	O
set	array(char)
[	O
i	int
]	O
=	O
!	O
set	array(char)
[	O
i	int
]	O
;	O
if	O
(	O
!	O
set	array(char)
[	O
(	O
int	O
)	O
*	O
fn	*(char)
++	O
]	O
)	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
c	int
=	O
*	O
pattern	*(char)
++	O
;	O
if	O
(	O
c	int
!=	O
*	O
fn	*(char)
++	O
)	O
return	O
0	int
;	O
}	O
}	O
return	O
(	O
*	O
fn	*(char)
==	O
'\0'	O
)	O
;	O
}	O
int	O
word_match	(*(char),*(char))->(int)
(	O
char	O
const	O
*	O
name_0	*(char)
,	O
char	O
const	O
*	O
line	*(char)
)	O
{	O
char	O
const	O
*	O
name	*(char)
=	O
name_0	*(char)
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
*	O
line	*(char)
!=	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
*	O
line	*(char)
==	O
'\0'	O
||	O
*	O
line	*(char)
==	O
'\n'	O
)	O
return	O
0	int
;	O
line	*(char)
++	O
;	O
}	O
if	O
(	O
IS_ALNUM	O
(	O
line	*(char)
[	O
-	O
1	int
]	O
)	O
)	O
{	O
line	*(char)
++	O
;	O
continue	O
;	O
}	O
while	O
(	O
*	O
++	O
name	*(char)
==	O
*	O
++	O
line	*(char)
)	O
;	O
if	O
(	O
*	O
name	*(char)
==	O
'\0'	O
&&	O
!	O
IS_ALNUM	O
(	O
*	O
line	*(char)
)	O
)	O
return	O
1	int
;	O
name	*(char)
=	O
name_0	*(char)
;	O
}	O
}	O
int	O
get_radix	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
!	O
isdigit	(int)->(int)
(	O
*	O
str	*(char)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
*	O
str	*(char)
!=	O
'0'	O
)	O
return	O
radix_dec	int
;	O
str	*(char)
++	O
;	O
if	O
(	O
*	O
str	*(char)
==	O
'x'	O
||	O
*	O
str	*(char)
==	O
'X'	O
)	O
return	O
radix_hex	int
;	O
while	O
(	O
*	O
str	*(char)
&&	O
*	O
str	*(char)
==	O
'0'	O
)	O
str	*(char)
++	O
;	O
return	O
(	O
*	O
str	*(char)
?	O
radix_oct	int
:	O
(	O
radix_oct	int
|	O
radix_dec	int
)	O
)	O
;	O
}	O
int	O
is_number	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
str	*(char)
[	O
0	int
]	O
==	O
'0'	O
&&	O
(	O
str	*(char)
[	O
1	int
]	O
==	O
'x'	O
||	O
str	*(char)
[	O
1	int
]	O
==	O
'X'	O
)	O
)	O
{	O
str	*(char)
+=	O
2	int
;	O
str	*(char)
+=	O
strspn	(*(char),*(char))->(long)
(	O
str	*(char)
,	O
"0123456789aAbBcCdDeEfF"	*(char)
)	O
;	O
}	O
else	O
{	O
size_t	long
offn	long
;	O
str	*(char)
+=	O
(	O
offn	long
=	O
strspn	(*(char),*(char))->(long)
(	O
str	*(char)
,	O
"0123456789"	*(char)
)	O
)	O
;	O
if	O
(	O
offn	long
)	O
str	*(char)
+=	O
strspn	(*(char),*(char))->(long)
(	O
str	*(char)
,	O
"uUlL"	*(char)
)	O
;	O
}	O
return	O
(	O
*	O
str	*(char)
==	O
'\0'	O
)	O
;	O
}	O
int	O
stoi	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
{	O
switch	O
(	O
get_radix	(*(char))->(int)
(	O
str	*(char)
)	O
)	O
{	O
case	O
radix_dec	int
:	O
return	O
(	O
dtoi	(*(char))->(int)
(	O
str	*(char)
)	O
)	O
;	O
case	O
radix_oct	int
:	O
return	O
(	O
otoi	(*(char))->(int)
(	O
&	O
str	*(char)
[	O
1	int
]	O
)	O
)	O
;	O
case	O
radix_hex	int
:	O
return	O
(	O
xtoi	(*(char))->(int)
(	O
&	O
str	*(char)
[	O
2	int
]	O
)	O
)	O
;	O
case	O
radix_dec	int
|	O
radix_oct	int
:	O
return	O
0	int
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
int	O
otoi	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
{	O
int	O
n	long
=	O
0	int
;	O
while	O
(	O
*	O
str	*(char)
>=	O
'0'	O
&&	O
*	O
str	*(char)
<=	O
'7'	O
)	O
{	O
n	long
*=	O
010	int
;	O
n	long
+=	O
*	O
str	*(char)
++	O
-	O
'0'	O
;	O
}	O
while	O
(	O
*	O
str	*(char)
&&	O
strchr	(*(char),int)->(*(char))
(	O
"uUlL"	*(char)
,	O
*	O
str	*(char)
)	O
)	O
str	*(char)
++	O
;	O
return	O
(	O
*	O
str	*(char)
?	O
-	O
1	int
:	O
n	long
)	O
;	O
}	O
int	O
dtoi	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
{	O
int	O
n	long
=	O
0	int
;	O
while	O
(	O
isdigit	(int)->(int)
(	O
*	O
str	*(char)
)	O
)	O
{	O
n	long
*=	O
10	int
;	O
n	long
+=	O
*	O
str	*(char)
++	O
-	O
'0'	O
;	O
}	O
while	O
(	O
*	O
str	*(char)
&&	O
strchr	(*(char),int)->(*(char))
(	O
"uUlL"	*(char)
,	O
*	O
str	*(char)
)	O
)	O
str	*(char)
++	O
;	O
return	O
(	O
*	O
str	*(char)
?	O
-	O
1	int
:	O
n	long
)	O
;	O
}	O
int	O
xtoi	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
{	O
int	O
n	long
=	O
0	int
;	O
while	O
(	O
isxdigit	(int)->(int)
(	O
*	O
str	*(char)
)	O
)	O
{	O
n	long
*=	O
0x10	int
;	O
if	O
(	O
isdigit	(int)->(int)
(	O
*	O
str	*(char)
)	O
)	O
n	long
+=	O
*	O
str	*(char)
++	O
-	O
'0'	O
;	O
else	O
if	O
(	O
islower	(int)->(int)
(	O
*	O
str	*(char)
)	O
)	O
n	long
+=	O
0xa	int
+	O
*	O
str	*(char)
++	O
-	O
'a'	O
;	O
else	O
n	long
+=	O
0xA	int
+	O
*	O
str	*(char)
++	O
-	O
'A'	O
;	O
}	O
while	O
(	O
*	O
str	*(char)
&&	O
strchr	(*(char),int)->(*(char))
(	O
"uUlL"	*(char)
,	O
*	O
str	*(char)
)	O
)	O
str	*(char)
++	O
;	O
return	O
(	O
*	O
str	*(char)
?	O
-	O
1	int
:	O
n	long
)	O
;	O
}	O
unsigned	O
char	O
*	O
tree8_to_bits	(*(char),*(char))->(*(char))
(	O
unsigned	O
char	O
*	O
bv_0	*(char)
,	O
unsigned	O
char	O
const	O
*	O
hits_tree8	*(char)
)	O
{	O
unsigned	O
char	O
*	O
bv	*(char)
=	O
bv_0	*(char)
;	O
tree8_to_bits_1	(*(*(char)),*(*(char)),int)->(void)
(	O
&	O
bv	*(char)
,	O
&	O
hits_tree8	*(char)
,	O
tree8_levels	int
)	O
;	O
return	O
bv_0	*(char)
;	O
}	O
void	O
tree8_to_bits_1	(*(*(char)),*(*(char)),int)->(void)
(	O
unsigned	O
char	O
*	O
*	O
bv	*(char)
,	O
unsigned	O
char	O
const	O
*	O
*	O
hits_tree8	*(char)
,	O
int	O
level	int
)	O
{	O
int	O
hits	int
=	O
*	O
(	O
*	O
hits_tree8	*(char)
)	O
++	O
;	O
if	O
(	O
--	O
level	int
)	O
{	O
int	O
incr	int
=	O
1	int
<<	O
(	O
(	O
level	int
-	O
1	int
)	O
*	O
3	int
)	O
;	O
int	O
bit	int
;	O
for	O
(	O
bit	int
=	O
1	int
;	O
bit	int
&	O
0xff	int
;	O
bit	int
<<=	O
1	int
)	O
{	O
if	O
(	O
bit	int
&	O
hits	int
)	O
tree8_to_bits_1	(*(*(char)),*(*(char)),int)->(void)
(	O
bv	*(char)
,	O
hits_tree8	*(char)
,	O
level	int
)	O
;	O
else	O
*	O
bv	*(char)
+=	O
incr	int
;	O
}	O
}	O
else	O
*	O
(	O
*	O
bv	*(char)
)	O
++	O
|=	O
hits	int
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
bits_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
unsigned	O
char	O
const	O
*	O
bv	*(char)
)	O
{	O
int	O
const	O
reserved_flinkv_slots	int
=	O
3	int
;	O
static	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv_0	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
members	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
members_0	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
end	*(long)
=	O
&	O
members_0	*(*(struct(union(*(struct`),long),char,array(char))))
[	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_files	long
]	O
;	O
if	O
(	O
flinkv_0	*(*(struct(union(*(struct`),long),char,array(char))))
==	O
0	int
)	O
flinkv_0	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
)	O
*	O
(	O
idh	struct(array(char),char,short,long,long,long,long,long,long,long,long,short,short,*(char),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),struct(*(*(void)),long,long,long,long,long,long,int,*((*(void))->(long)),*((*(void))->(long)),*((*(void),*(void))->(int))),struct(long,*(struct(*(char),*(struct`),array(char))),*(char),*(char),*(char),union(long,*(void)),int,*((*(void),long)->(*(struct`))),*((*(void),*(struct`))->(void)),*(void),int,int,int),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
.	O
idh_files	long
+	O
reserved_flinkv_slots	int
+	O
2	int
)	O
)	O
;	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
&	O
flinkv_0	*(*(struct(union(*(struct`),long),char,array(char))))
[	O
reserved_flinkv_slots	int
]	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
hits	int
;	O
int	O
bit	int
;	O
while	O
(	O
*	O
bv	*(char)
==	O
0	int
)	O
{	O
bv	*(char)
++	O
;	O
members	*(*(struct(union(*(struct`),long),char,array(char))))
+=	O
8	int
;	O
if	O
(	O
members	*(*(struct(union(*(struct`),long),char,array(char))))
>=	O
end	*(long)
)	O
goto	O
out	O
;	O
}	O
hits	int
=	O
*	O
bv	*(char)
++	O
;	O
for	O
(	O
bit	int
=	O
1	int
;	O
bit	int
&	O
0xff	int
;	O
bit	int
<<=	O
1	int
)	O
{	O
if	O
(	O
bit	int
&	O
hits	int
)	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
++	O
=	O
*	O
members	*(*(struct(union(*(struct`),long),char,array(char))))
;	O
if	O
(	O
++	O
members	*(*(struct(union(*(struct`),long),char,array(char))))
>=	O
end	*(long)
)	O
goto	O
out	O
;	O
}	O
}	O
out	O
:	O
*	O
flinkv	*(*(struct(union(*(struct`),long),char,array(char))))
=	O
0	int
;	O
return	O
&	O
flinkv_0	*(*(struct(union(*(struct`),long),char,array(char))))
[	O
reserved_flinkv_slots	int
]	O
;	O
}	O
struct	O
file_link	struct(union(*(struct(union(*(struct`),long),char,array(char))),long),char,array(char))
*	O
*	O
tree8_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
unsigned	O
char	O
const	O
*	O
hits_tree8	*(char)
)	O
{	O
memset	(*(void),int,long)->(*(void))
(	O
bits_vec	*(char)
,	O
0	int
,	O
bits_vec_size	int
)	O
;	O
return	O
bits_to_flinkv	(*(char))->(*(*(struct(union(*`,long),char,array(char)))))
(	O
tree8_to_bits	(*(char),*(char))->(*(char))
(	O
bits_vec	*(char)
,	O
hits_tree8	*(char)
)	O
)	O
;	O
}	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
linemode	struct(int,int,int,int,char,array(char),int,int)
;	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
charmode	struct(int,int,int,int,char,array(char),int,int)
;	O
struct	O
termios	struct(int,int,int,int,char,array(char),int,int)
savemode	struct(int,int,int,int,char,array(char),int,int)
;	O
void	O
savetty	()->(void)
(	O
void	O
)	O
{	O
GET_TTY_MODES	O
(	O
&	O
savemode	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
charmode	struct(int,int,int,int,char,array(char),int,int)
=	O
linemode	struct(int,int,int,int,char,array(char),int,int)
=	O
savemode	struct(int,int,int,int,char,array(char),int,int)
;	O
charmode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	int
&=	O
~	O
(	O
ECHO	int
|	O
ICANON	int
|	O
ISIG	int
)	O
;	O
charmode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VMIN	int
]	O
=	O
1	int
;	O
charmode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VTIME	int
]	O
=	O
0	int
;	O
linemode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_lflag	int
|=	O
(	O
ECHO	int
|	O
ICANON	int
|	O
ISIG	int
)	O
;	O
linemode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VEOF	int
]	O
=	O
'd'	O
&	O
037	int
;	O
linemode	struct(int,int,int,int,char,array(char),int,int)
.	O
c_cc	array(char)
[	O
VEOL	int
]	O
=	O
0377	int
;	O
}	O
void	O
restoretty	()->(void)
(	O
void	O
)	O
{	O
SET_TTY_MODES	O
(	O
&	O
savemode	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
}	O
void	O
linetty	()->(void)
(	O
void	O
)	O
{	O
SET_TTY_MODES	O
(	O
&	O
linemode	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
}	O
void	O
chartty	()->(void)
(	O
void	O
)	O
{	O
SET_TTY_MODES	O
(	O
&	O
charmode	struct(int,int,int,int,char,array(char),int,int)
)	O
;	O
}	O
