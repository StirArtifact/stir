struct	O
faFileHeader	struct(int,int)
{	O
unsigned	O
int	O
magic	int
;	O
unsigned	O
int	O
firstFree	int
;	O
}	O
;	O
struct	O
faHeader	struct(int,int,int,int)
{	O
unsigned	O
int	O
size	long
;	O
unsigned	O
int	O
freeNext	int
;	O
unsigned	O
int	O
freePrev	int
;	O
unsigned	O
int	O
isFree	int
;	O
}	O
;	O
struct	O
faFooter	struct(int,int)
{	O
unsigned	O
int	O
size	long
;	O
unsigned	O
int	O
isFree	int
;	O
}	O
;	O
FD_t	*(struct)
fadOpen	(*(char),int,int)->(*(struct))
(	O
const	O
char	O
*	O
path	*(char)
,	O
int	O
flags	int
,	O
int	O
perms	int
)	O
{	O
struct	O
faFileHeader	struct(int,int)
newHdr	struct(int,int)
;	O
FD_t	*(struct)
fd	*(struct)
;	O
if	O
(	O
flags	int
&	O
O_WRONLY	int
)	O
return	O
NULL	O
;	O
fd	*(struct)
=	O
ufdio	*(struct(*((*(void),*(char),long)->(long)),*((*(void),*(char),long)->(long)),*((*(void),long,int)->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),int)->(*(struct`))),*((*(struct`),*(char),*(char),int)->(*(struct`))),*((*(char),*(char),int)->(*(struct`))),*((*(void))->(int)),*((*(char),int,int)->(*(struct`))),*((*(char),*(char))->(*(struct`))),*((*(struct`))->(*(void))),*((*(struct`))->(int)),*((*(char),int)->(int)),*((*(char))->(int)),*((*(char))->(int)),*((*(char),*(char))->(int)),*((*(char))->(int))))
->	O
_open	*((*(char),int,int)->(*(struct)))
(	O
path	*(char)
,	O
flags	int
,	O
perms	int
)	O
;	O
if	O
(	O
Ferror	(*(struct))->(int)
(	O
fd	*(struct)
)	O
)	O
return	O
NULL	O
;	O
fdSetIo	(*(struct),*(struct(*((*`,*`,long)->(long)),*((*`,*`,long)->(long)),*((*`,long,int)->(int)),*((*`)->(int)),*((*`,*`,*`,int)->(*`)),*((*`,*`,*`,int)->(*`)),*((*`,*`,int)->(*`)),*((*`)->(int)),*((*`,int,int)->(*`)),*((*`,*`)->(*`)),*((*`)->(*`)),*((*`)->(int)),*((*`,int)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`,*`)->(int)),*((*`)->(int)))))->(void)
(	O
fd	*(struct)
,	O
fadio	*(struct(*((*(void),*(char),long)->(long)),*((*(void),*(char),long)->(long)),*((*(void),long,int)->(int)),*((*(void))->(int)),*((*(void),*(char),*(char),int)->(*(struct`))),*((*(struct`),*(char),*(char),int)->(*(struct`))),*((*(char),*(char),int)->(*(struct`))),*((*(void))->(int)),*((*(char),int,int)->(*(struct`))),*((*(char),*(char))->(*(struct`))),*((*(struct`))->(*(void))),*((*(struct`))->(int)),*((*(char),int)->(int)),*((*(char))->(int)),*((*(char))->(int)),*((*(char),*(char))->(int)),*((*(char))->(int))))
)	O
;	O
fadSetFirstFree	(*(struct),int)->(void)
(	O
fd	*(struct)
,	O
0	int
)	O
;	O
fadSetFileSize	(*(struct),long)->(void)
(	O
fd	*(struct)
,	O
Fseek	(*(struct),long,int)->(int)
(	O
fd	*(struct)
,	O
0	int
,	O
SEEK_END	int
)	O
)	O
;	O
if	O
(	O
fadGetFileSize	(*(struct))->(long)
(	O
fd	*(struct)
)	O
==	O
0	int
)	O
{	O
newHdr	struct(int,int)
.	O
magic	int
=	O
FA_MAGIC	int
;	O
newHdr	struct(int,int)
.	O
firstFree	int
=	O
0	int
;	O
if	O
(	O
Fwrite	(*(void),long,long,*(struct))->(long)
(	O
&	O
newHdr	struct(int,int)
,	O
sizeof	O
(	O
char	O
)	O
,	O
sizeof	O
(	O
newHdr	struct(int,int)
)	O
,	O
fd	*(struct)
)	O
!=	O
sizeof	O
(	O
newHdr	struct(int,int)
)	O
)	O
{	O
Fclose	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
fadSetFirstFree	(*(struct),int)->(void)
(	O
fd	*(struct)
,	O
0	int
)	O
;	O
fadSetFileSize	(*(struct),long)->(void)
(	O
fd	*(struct)
,	O
sizeof	O
(	O
newHdr	struct(int,int)
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
newHdr	struct(int,int)
,	O
sizeof	O
(	O
newHdr	struct(int,int)
)	O
,	O
0	int
)	O
!=	O
sizeof	O
(	O
newHdr	struct(int,int)
)	O
)	O
{	O
Fclose	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
newHdr	struct(int,int)
.	O
magic	int
!=	O
FA_MAGIC	int
)	O
{	O
Fclose	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
fadSetFirstFree	(*(struct),int)->(void)
(	O
fd	*(struct)
,	O
newHdr	struct(int,int)
.	O
firstFree	int
)	O
;	O
fadSetFileSize	(*(struct),long)->(void)
(	O
fd	*(struct)
,	O
Fseek	(*(struct),long,int)->(int)
(	O
fd	*(struct)
,	O
0	int
,	O
SEEK_END	int
)	O
)	O
;	O
if	O
(	O
fadGetFileSize	(*(struct))->(long)
(	O
fd	*(struct)
)	O
<	O
0	int
)	O
{	O
Fclose	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
return	O
fd	*(struct)
;	O
}	O
unsigned	O
int	O
fadAlloc	(*(struct),int)->(int)
(	O
FD_t	*(struct)
fd	*(struct)
,	O
unsigned	O
int	O
size	long
)	O
{	O
unsigned	O
int	O
nextFreeBlock	int
;	O
unsigned	O
int	O
newBlockOffset	int
;	O
unsigned	O
int	O
footerOffset	int
;	O
int	O
failed	int
=	O
0	int
;	O
struct	O
faFileHeader	struct(int,int)
faHeader	struct(int,int,int,int)
;	O
struct	O
faHeader	struct(int,int,int,int)
header	struct(int,int,int,int)
,	O
origHeader	struct(int,int,int,int)
;	O
struct	O
faHeader	struct(int,int,int,int)
*	O
restoreHeader	*(struct(int,int,int,int))
=	O
NULL	O
;	O
struct	O
faHeader	struct(int,int,int,int)
nextFreeHeader	struct(int,int,int,int)
,	O
origNextFreeHeader	struct(int,int,int,int)
;	O
struct	O
faHeader	struct(int,int,int,int)
*	O
restoreNextHeader	*(struct(int,int,int,int))
=	O
NULL	O
;	O
struct	O
faHeader	struct(int,int,int,int)
prevFreeHeader	struct(int,int,int,int)
,	O
origPrevFreeHeader	struct(int,int,int,int)
;	O
struct	O
faHeader	struct(int,int,int,int)
*	O
restorePrevHeader	*(struct(int,int,int,int))
=	O
NULL	O
;	O
struct	O
faFooter	struct(int,int)
footer	struct(int,int)
,	O
origFooter	struct(int,int)
;	O
struct	O
faFooter	struct(int,int)
*	O
restoreFooter	*(struct(int,int))
=	O
NULL	O
;	O
int	O
updateHeader	int
=	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
header	struct(int,int,int,int)
,	O
0	int
,	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
)	O
;	O
size	long
+=	O
sizeof	O
(	O
struct	O
faHeader	struct(int,int,int,int)
)	O
+	O
sizeof	O
(	O
struct	O
faFooter	struct(int,int)
)	O
;	O
(	O
size	long
%	O
64	int
)	O
?	O
size	long
+=	O
(	O
64	int
-	O
(	O
size	long
%	O
64	int
)	O
)	O
:	O
0	int
;	O
nextFreeBlock	int
=	O
fadGetFirstFree	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
newBlockOffset	int
=	O
0	int
;	O
while	O
(	O
nextFreeBlock	int
&&	O
!	O
newBlockOffset	int
)	O
{	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
header	struct(int,int,int,int)
,	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
,	O
nextFreeBlock	int
)	O
!=	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
header	struct(int,int,int,int)
.	O
isFree	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"free list corrupt (%u)- please run\n"	*(char)
"\t\"rpm --rebuilddb\"\n"	*(char)
"More information is available from http://www.rpm.org "	*(char)
"or the rpm-list@redhat.com mailing list\n"	*(char)
"if \"rpm --rebuilddb\" fails to correct the problem.\n"	*(char)
)	O
,	O
nextFreeBlock	int
)	O
;	O
exit	(int)->(void)
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
header	struct(int,int,int,int)
.	O
size	long
>=	O
size	long
)	O
{	O
newBlockOffset	int
=	O
nextFreeBlock	int
;	O
}	O
else	O
{	O
nextFreeBlock	int
=	O
header	struct(int,int,int,int)
.	O
freeNext	int
;	O
}	O
}	O
if	O
(	O
newBlockOffset	int
)	O
{	O
origHeader	struct(int,int,int,int)
=	O
header	struct(int,int,int,int)
;	O
footerOffset	int
=	O
newBlockOffset	int
+	O
header	struct(int,int,int,int)
.	O
size	long
-	O
sizeof	O
(	O
footer	struct(int,int)
)	O
;	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
footer	struct(int,int)
,	O
sizeof	O
(	O
footer	struct(int,int)
)	O
,	O
footerOffset	int
)	O
!=	O
sizeof	O
(	O
footer	struct(int,int)
)	O
)	O
return	O
0	int
;	O
origFooter	struct(int,int)
=	O
footer	struct(int,int)
;	O
footer	struct(int,int)
.	O
isFree	int
=	O
header	struct(int,int,int,int)
.	O
isFree	int
=	O
0	int
;	O
if	O
(	O
newBlockOffset	int
==	O
fadGetFirstFree	(*(struct))->(int)
(	O
fd	*(struct)
)	O
)	O
{	O
faHeader	struct(int,int,int,int)
.	O
magic	int
=	O
FA_MAGIC	int
;	O
faHeader	struct(int,int,int,int)
.	O
firstFree	int
=	O
header	struct(int,int,int,int)
.	O
freeNext	int
;	O
fadSetFirstFree	(*(struct),int)->(void)
(	O
fd	*(struct)
,	O
header	struct(int,int,int,int)
.	O
freeNext	int
)	O
;	O
updateHeader	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
prevFreeHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
prevFreeHeader	struct(int,int,int,int)
)	O
,	O
header	struct(int,int,int,int)
.	O
freePrev	int
)	O
!=	O
sizeof	O
(	O
prevFreeHeader	struct(int,int,int,int)
)	O
)	O
return	O
0	int
;	O
origPrevFreeHeader	struct(int,int,int,int)
=	O
prevFreeHeader	struct(int,int,int,int)
;	O
prevFreeHeader	struct(int,int,int,int)
.	O
freeNext	int
=	O
header	struct(int,int,int,int)
.	O
freeNext	int
;	O
}	O
if	O
(	O
header	struct(int,int,int,int)
.	O
freeNext	int
)	O
{	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
nextFreeHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
nextFreeHeader	struct(int,int,int,int)
)	O
,	O
header	struct(int,int,int,int)
.	O
freeNext	int
)	O
!=	O
sizeof	O
(	O
nextFreeHeader	struct(int,int,int,int)
)	O
)	O
return	O
0	int
;	O
origNextFreeHeader	struct(int,int,int,int)
=	O
nextFreeHeader	struct(int,int,int,int)
;	O
nextFreeHeader	struct(int,int,int,int)
.	O
freePrev	int
=	O
header	struct(int,int,int,int)
.	O
freePrev	int
;	O
}	O
if	O
(	O
updateHeader	int
)	O
{	O
if	O
(	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
faHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
faHeader	struct(int,int,int,int)
)	O
,	O
0	int
)	O
!=	O
sizeof	O
(	O
faHeader	struct(int,int,int,int)
)	O
)	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
prevFreeHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
prevFreeHeader	struct(int,int,int,int)
)	O
,	O
header	struct(int,int,int,int)
.	O
freePrev	int
)	O
!=	O
sizeof	O
(	O
prevFreeHeader	struct(int,int,int,int)
)	O
)	O
return	O
0	int
;	O
restorePrevHeader	*(struct(int,int,int,int))
=	O
&	O
origPrevFreeHeader	struct(int,int,int,int)
;	O
}	O
if	O
(	O
header	struct(int,int,int,int)
.	O
freeNext	int
)	O
{	O
if	O
(	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
nextFreeHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
nextFreeHeader	struct(int,int,int,int)
)	O
,	O
header	struct(int,int,int,int)
.	O
freeNext	int
)	O
!=	O
sizeof	O
(	O
nextFreeHeader	struct(int,int,int,int)
)	O
)	O
return	O
0	int
;	O
restoreNextHeader	*(struct(int,int,int,int))
=	O
&	O
origNextFreeHeader	struct(int,int,int,int)
;	O
}	O
if	O
(	O
!	O
failed	int
)	O
{	O
if	O
(	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
header	struct(int,int,int,int)
,	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
,	O
newBlockOffset	int
)	O
!=	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
)	O
{	O
failed	int
=	O
1	int
;	O
restoreHeader	*(struct(int,int,int,int))
=	O
&	O
origHeader	struct(int,int,int,int)
;	O
}	O
}	O
if	O
(	O
!	O
failed	int
)	O
{	O
if	O
(	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
footer	struct(int,int)
,	O
sizeof	O
(	O
footer	struct(int,int)
)	O
,	O
footerOffset	int
)	O
!=	O
sizeof	O
(	O
footer	struct(int,int)
)	O
)	O
{	O
failed	int
=	O
1	int
;	O
restoreFooter	*(struct(int,int))
=	O
&	O
origFooter	struct(int,int)
;	O
}	O
}	O
if	O
(	O
failed	int
)	O
{	O
if	O
(	O
updateHeader	int
)	O
{	O
faHeader	struct(int,int,int,int)
.	O
firstFree	int
=	O
newBlockOffset	int
;	O
fadSetFirstFree	(*(struct),int)->(void)
(	O
fd	*(struct)
,	O
newBlockOffset	int
)	O
;	O
(	O
void	O
)	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
faHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
faHeader	struct(int,int,int,int)
)	O
,	O
0	int
)	O
;	O
}	O
if	O
(	O
restorePrevHeader	*(struct(int,int,int,int))
)	O
(	O
void	O
)	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
restorePrevHeader	*(struct(int,int,int,int))
,	O
sizeof	O
(	O
*	O
restorePrevHeader	*(struct(int,int,int,int))
)	O
,	O
header	struct(int,int,int,int)
.	O
freePrev	int
)	O
;	O
if	O
(	O
restoreNextHeader	*(struct(int,int,int,int))
)	O
(	O
void	O
)	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
restoreNextHeader	*(struct(int,int,int,int))
,	O
sizeof	O
(	O
*	O
restoreNextHeader	*(struct(int,int,int,int))
)	O
,	O
header	struct(int,int,int,int)
.	O
freeNext	int
)	O
;	O
if	O
(	O
restoreHeader	*(struct(int,int,int,int))
)	O
(	O
void	O
)	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
restoreHeader	*(struct(int,int,int,int))
,	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
,	O
newBlockOffset	int
)	O
;	O
if	O
(	O
restoreFooter	*(struct(int,int))
)	O
(	O
void	O
)	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
restoreFooter	*(struct(int,int))
,	O
sizeof	O
(	O
footer	struct(int,int)
)	O
,	O
footerOffset	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
char	O
*	O
space	*(char)
;	O
newBlockOffset	int
=	O
fadGetFileSize	(*(struct))->(long)
(	O
fd	*(struct)
)	O
;	O
footerOffset	int
=	O
newBlockOffset	int
+	O
size	long
-	O
sizeof	O
(	O
footer	struct(int,int)
)	O
;	O
space	*(char)
=	O
alloca	(long)->(*(void))
(	O
size	long
)	O
;	O
if	O
(	O
space	*(char)
==	O
NULL	O
)	O
return	O
0	int
;	O
memset	(*(void),int,long)->(*(void))
(	O
space	*(char)
,	O
0	int
,	O
size	long
)	O
;	O
footer	struct(int,int)
.	O
isFree	int
=	O
header	struct(int,int,int,int)
.	O
isFree	int
=	O
0	int
;	O
footer	struct(int,int)
.	O
size	long
=	O
header	struct(int,int,int,int)
.	O
size	long
=	O
size	long
;	O
header	struct(int,int,int,int)
.	O
freePrev	int
=	O
header	struct(int,int,int,int)
.	O
freeNext	int
=	O
0	int
;	O
if	O
(	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
space	*(char)
,	O
size	long
,	O
newBlockOffset	int
)	O
!=	O
size	long
)	O
return	O
0	int
;	O
if	O
(	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
header	struct(int,int,int,int)
,	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
,	O
newBlockOffset	int
)	O
!=	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
footer	struct(int,int)
,	O
sizeof	O
(	O
footer	struct(int,int)
)	O
,	O
footerOffset	int
)	O
!=	O
sizeof	O
(	O
footer	struct(int,int)
)	O
)	O
return	O
0	int
;	O
fadSetFileSize	(*(struct),long)->(void)
(	O
fd	*(struct)
,	O
fadGetFileSize	(*(struct))->(long)
(	O
fd	*(struct)
)	O
+	O
size	long
)	O
;	O
}	O
return	O
newBlockOffset	int
+	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
;	O
}	O
void	O
fadFree	(*(struct),int)->(void)
(	O
FD_t	*(struct)
fd	*(struct)
,	O
unsigned	O
int	O
offset	long
)	O
{	O
struct	O
faHeader	struct(int,int,int,int)
header	struct(int,int,int,int)
;	O
struct	O
faFooter	struct(int,int)
footer	struct(int,int)
;	O
int	O
footerOffset	int
;	O
int	O
prevFreeOffset	int
,	O
nextFreeOffset	int
;	O
struct	O
faHeader	struct(int,int,int,int)
prevFreeHeader	struct(int,int,int,int)
,	O
nextFreeHeader	struct(int,int,int,int)
;	O
struct	O
faFileHeader	struct(int,int)
faHeader	struct(int,int,int,int)
;	O
offset	long
-=	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
;	O
prevFreeOffset	int
=	O
fadGetFirstFree	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
if	O
(	O
!	O
prevFreeOffset	int
||	O
(	O
prevFreeOffset	int
>	O
offset	long
)	O
)	O
{	O
nextFreeOffset	int
=	O
fadGetFirstFree	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
prevFreeOffset	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
prevFreeHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
prevFreeHeader	struct(int,int,int,int)
)	O
,	O
prevFreeOffset	int
)	O
!=	O
sizeof	O
(	O
prevFreeHeader	struct(int,int,int,int)
)	O
)	O
return	O
;	O
while	O
(	O
prevFreeHeader	struct(int,int,int,int)
.	O
freeNext	int
&&	O
prevFreeHeader	struct(int,int,int,int)
.	O
freeNext	int
<	O
offset	long
)	O
{	O
prevFreeOffset	int
=	O
prevFreeHeader	struct(int,int,int,int)
.	O
freeNext	int
;	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
prevFreeHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
prevFreeHeader	struct(int,int,int,int)
)	O
,	O
prevFreeOffset	int
)	O
!=	O
sizeof	O
(	O
prevFreeHeader	struct(int,int,int,int)
)	O
)	O
return	O
;	O
}	O
nextFreeOffset	int
=	O
prevFreeHeader	struct(int,int,int,int)
.	O
freeNext	int
;	O
}	O
if	O
(	O
nextFreeOffset	int
)	O
{	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
nextFreeHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
nextFreeHeader	struct(int,int,int,int)
)	O
,	O
nextFreeOffset	int
)	O
!=	O
sizeof	O
(	O
nextFreeHeader	struct(int,int,int,int)
)	O
)	O
return	O
;	O
}	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
header	struct(int,int,int,int)
,	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
,	O
offset	long
)	O
!=	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
)	O
return	O
;	O
footerOffset	int
=	O
offset	long
+	O
header	struct(int,int,int,int)
.	O
size	long
-	O
sizeof	O
(	O
footer	struct(int,int)
)	O
;	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
footer	struct(int,int)
,	O
sizeof	O
(	O
footer	struct(int,int)
)	O
,	O
footerOffset	int
)	O
!=	O
sizeof	O
(	O
footer	struct(int,int)
)	O
)	O
return	O
;	O
header	struct(int,int,int,int)
.	O
isFree	int
=	O
1	int
;	O
header	struct(int,int,int,int)
.	O
freeNext	int
=	O
nextFreeOffset	int
;	O
header	struct(int,int,int,int)
.	O
freePrev	int
=	O
prevFreeOffset	int
;	O
footer	struct(int,int)
.	O
isFree	int
=	O
1	int
;	O
(	O
void	O
)	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
header	struct(int,int,int,int)
,	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
,	O
offset	long
)	O
;	O
(	O
void	O
)	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
footer	struct(int,int)
,	O
sizeof	O
(	O
footer	struct(int,int)
)	O
,	O
footerOffset	int
)	O
;	O
if	O
(	O
nextFreeOffset	int
)	O
{	O
nextFreeHeader	struct(int,int,int,int)
.	O
freePrev	int
=	O
offset	long
;	O
if	O
(	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
nextFreeHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
nextFreeHeader	struct(int,int,int,int)
)	O
,	O
nextFreeOffset	int
)	O
!=	O
sizeof	O
(	O
nextFreeHeader	struct(int,int,int,int)
)	O
)	O
return	O
;	O
}	O
if	O
(	O
prevFreeOffset	int
)	O
{	O
prevFreeHeader	struct(int,int,int,int)
.	O
freeNext	int
=	O
offset	long
;	O
if	O
(	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
prevFreeHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
prevFreeHeader	struct(int,int,int,int)
)	O
,	O
prevFreeOffset	int
)	O
!=	O
sizeof	O
(	O
prevFreeHeader	struct(int,int,int,int)
)	O
)	O
return	O
;	O
}	O
else	O
{	O
fadSetFirstFree	(*(struct),int)->(void)
(	O
fd	*(struct)
,	O
offset	long
)	O
;	O
faHeader	struct(int,int,int,int)
.	O
magic	int
=	O
FA_MAGIC	int
;	O
faHeader	struct(int,int,int,int)
.	O
firstFree	int
=	O
fadGetFirstFree	(*(struct))->(int)
(	O
fd	*(struct)
)	O
;	O
if	O
(	O
Pwrite	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
faHeader	struct(int,int,int,int)
,	O
sizeof	O
(	O
faHeader	struct(int,int,int,int)
)	O
,	O
0	int
)	O
!=	O
sizeof	O
(	O
faHeader	struct(int,int,int,int)
)	O
)	O
return	O
;	O
}	O
}	O
int	O
fadFirstOffset	(*(struct))->(int)
(	O
FD_t	*(struct)
fd	*(struct)
)	O
{	O
return	O
fadNextOffset	(*(struct),int)->(int)
(	O
fd	*(struct)
,	O
0	int
)	O
;	O
}	O
int	O
fadNextOffset	(*(struct),int)->(int)
(	O
FD_t	*(struct)
fd	*(struct)
,	O
unsigned	O
int	O
lastOffset	int
)	O
{	O
struct	O
faHeader	struct(int,int,int,int)
header	struct(int,int,int,int)
;	O
int	O
offset	long
;	O
offset	long
=	O
(	O
lastOffset	int
)	O
?	O
(	O
lastOffset	int
-	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
)	O
:	O
sizeof	O
(	O
struct	O
faFileHeader	struct(int,int)
)	O
;	O
if	O
(	O
offset	long
>=	O
fadGetFileSize	(*(struct))->(long)
(	O
fd	*(struct)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
header	struct(int,int,int,int)
,	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
,	O
offset	long
)	O
!=	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
lastOffset	int
&&	O
!	O
header	struct(int,int,int,int)
.	O
isFree	int
)	O
return	O
(	O
offset	long
+	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
)	O
;	O
do	O
{	O
offset	long
+=	O
header	struct(int,int,int,int)
.	O
size	long
;	O
if	O
(	O
Pread	(*(struct),*(void),long,long)->(long)
(	O
fd	*(struct)
,	O
&	O
header	struct(int,int,int,int)
,	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
,	O
offset	long
)	O
!=	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
header	struct(int,int,int,int)
.	O
isFree	int
)	O
break	O
;	O
}	O
while	O
(	O
offset	long
<	O
fadGetFileSize	(*(struct))->(long)
(	O
fd	*(struct)
)	O
&&	O
header	struct(int,int,int,int)
.	O
isFree	int
)	O
;	O
if	O
(	O
offset	long
<	O
fadGetFileSize	(*(struct))->(long)
(	O
fd	*(struct)
)	O
)	O
{	O
offset	long
+=	O
sizeof	O
(	O
header	struct(int,int,int,int)
)	O
;	O
if	O
(	O
offset	long
<=	O
lastOffset	int
)	O
return	O
-	O
1	int
;	O
return	O
offset	long
;	O
}	O
else	O
return	O
0	int
;	O
}	O
