static	O
int	O
fatal_signals	array(int)
[	O
]	O
=	O
{	O
SIGINT	int
,	O
SIGTERM	int
,	O
SIGHUP	int
,	O
SIGPIPE	int
,	O
SIGXCPU	int
,	O
SIGXFSZ	int
,	O
0	int
}	O
;	O
static	O
void	O
init_fatal_signals	()->(void)
(	O
void	O
)	O
{	O
static	O
bool	bool
fatal_signals_initialized	bool
=	O
false	int
;	O
if	O
(	O
!	O
fatal_signals_initialized	bool
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_fatal_signals	O
;	O
i	long
++	O
)	O
{	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
if	O
(	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
fatal_signals	array(int)
[	O
i	long
]	O
,	O
NULL	O
,	O
&	O
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
>=	O
0	int
&&	O
get_handler	(*(struct(union(*((int)->(void)),*((int,*`,*`)->(void))),struct(array(long)),int,*(()->(void)))))->(*((int)->(void)))
(	O
&	O
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
==	O
SIG_IGN	O
)	O
fatal_signals	array(int)
[	O
i	long
]	O
=	O
-	O
1	int
;	O
}	O
fatal_signals_initialized	bool
=	O
true	int
;	O
}	O
}	O
typedef	O
void	O
(	O
*	O
action_t	*(()->(void))
)	O
(	O
void	O
)	O
;	O
typedef	O
struct	O
{	O
volatile	O
action_t	*(()->(void))
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
}	O
actions_entry_t	struct(*(()->(void)))
;	O
static	O
actions_entry_t	struct(*(()->(void)))
static_actions	array(struct(*(()->(void))))
[	O
32	int
]	O
;	O
static	O
actions_entry_t	struct(*(()->(void)))
*	O
volatile	O
actions	*(struct(*(()->(void))))
=	O
static_actions	array(struct(*(()->(void))))
;	O
static	O
sig_atomic_t	int
volatile	O
actions_count	int
=	O
0	int
;	O
static	O
size_t	long
actions_allocated	long
=	O
SIZEOF	O
(	O
static_actions	array(struct(*(()->(void))))
)	O
;	O
static	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
saved_sigactions	array(struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void))))
[	O
64	int
]	O
;	O
static	O
void	O
uninstall_handlers	()->(void)
(	O
void	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_fatal_signals	O
;	O
i	long
++	O
)	O
if	O
(	O
fatal_signals	array(int)
[	O
i	long
]	O
>=	O
0	int
)	O
{	O
int	O
sig	int
=	O
fatal_signals	array(int)
[	O
i	long
]	O
;	O
if	O
(	O
saved_sigactions	array(struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void))))
[	O
sig	int
]	O
.	O
sa_handler	*((int)->(void))
==	O
SIG_IGN	O
)	O
saved_sigactions	array(struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void))))
[	O
sig	int
]	O
.	O
sa_handler	*((int)->(void))
=	O
SIG_DFL	O
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
sig	int
,	O
&	O
saved_sigactions	array(struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void))))
[	O
sig	int
]	O
,	O
NULL	O
)	O
;	O
}	O
}	O
static	O
void	O
fatal_signal_handler	(int)->(void)
(	O
int	O
sig	int
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
action_t	*(()->(void))
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
size_t	long
n	long
=	O
actions_count	int
;	O
if	O
(	O
n	long
==	O
0	int
)	O
break	O
;	O
n	long
--	O
;	O
actions_count	int
=	O
n	long
;	O
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
=	O
actions	*(struct(*(()->(void))))
[	O
n	long
]	O
.	O
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
)	O
;	O
}	O
uninstall_handlers	()->(void)
(	O
)	O
;	O
raise	(int)->(int)
(	O
sig	int
)	O
;	O
}	O
static	O
void	O
install_handlers	()->(void)
(	O
void	O
)	O
{	O
size_t	long
i	long
;	O
struct	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_handler	*((int)->(void))
=	O
&	O
fatal_signal_handler	(int)->(void)
;	O
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_flags	int
=	O
SA_NODEFER	int
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
.	O
sa_mask	struct(array(long))
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_fatal_signals	O
;	O
i	long
++	O
)	O
if	O
(	O
fatal_signals	array(int)
[	O
i	long
]	O
>=	O
0	int
)	O
{	O
int	O
sig	int
=	O
fatal_signals	array(int)
[	O
i	long
]	O
;	O
if	O
(	O
!	O
(	O
sig	int
<	O
sizeof	O
(	O
saved_sigactions	array(struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void))))
)	O
/	O
sizeof	O
(	O
saved_sigactions	array(struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void))))
[	O
0	int
]	O
)	O
)	O
)	O
abort	()->(void)
(	O
)	O
;	O
sigaction	struct(union(*((int)->(void)),*((int,*(struct(int,int,int,int,union`)),*(void))->(void))),struct(array(long)),int,*(()->(void)))
(	O
sig	int
,	O
&	O
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
,	O
&	O
saved_sigactions	array(struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void))))
[	O
sig	int
]	O
)	O
;	O
}	O
}	O
void	O
at_fatal_signal	(*(()->(void)))->(void)
(	O
action_t	*(()->(void))
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
)	O
{	O
static	O
bool	bool
cleanup_initialized	bool
=	O
false	int
;	O
if	O
(	O
!	O
cleanup_initialized	bool
)	O
{	O
init_fatal_signals	()->(void)
(	O
)	O
;	O
install_handlers	()->(void)
(	O
)	O
;	O
cleanup_initialized	bool
=	O
true	int
;	O
}	O
if	O
(	O
actions_count	int
==	O
actions_allocated	long
)	O
{	O
actions_entry_t	struct(*(()->(void)))
*	O
old_actions	*(struct(*(()->(void))))
=	O
actions	*(struct(*(()->(void))))
;	O
size_t	long
old_actions_allocated	long
=	O
actions_allocated	long
;	O
size_t	long
new_actions_allocated	long
=	O
2	int
*	O
actions_allocated	long
;	O
actions_entry_t	struct(*(()->(void)))
*	O
new_actions	*(struct(*(()->(void))))
=	O
XNMALLOC	O
(	O
new_actions_allocated	long
,	O
actions_entry_t	struct(*(()->(void)))
)	O
;	O
size_t	long
k	long
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
old_actions_allocated	long
;	O
k	long
++	O
)	O
new_actions	*(struct(*(()->(void))))
[	O
k	long
]	O
=	O
old_actions	*(struct(*(()->(void))))
[	O
k	long
]	O
;	O
actions	*(struct(*(()->(void))))
=	O
new_actions	*(struct(*(()->(void))))
;	O
actions_allocated	long
=	O
new_actions_allocated	long
;	O
if	O
(	O
old_actions	*(struct(*(()->(void))))
!=	O
static_actions	array(struct(*(()->(void))))
)	O
free	(*(void))->(void)
(	O
old_actions	*(struct(*(()->(void))))
)	O
;	O
}	O
actions	*(struct(*(()->(void))))
[	O
actions_count	int
]	O
.	O
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
=	O
action	struct(union(*((int)->(void)),*((int,*(struct`),*(void))->(void))),struct(array(long)),int,*(()->(void)))
;	O
actions_count	int
++	O
;	O
}	O
static	O
sigset_t	struct(array(long))
fatal_signal_set	struct(array(long))
;	O
static	O
void	O
init_fatal_signal_set	()->(void)
(	O
void	O
)	O
{	O
static	O
bool	bool
fatal_signal_set_initialized	bool
=	O
false	int
;	O
if	O
(	O
!	O
fatal_signal_set_initialized	bool
)	O
{	O
size_t	long
i	long
;	O
init_fatal_signals	()->(void)
(	O
)	O
;	O
sigemptyset	(*(struct(array(long))))->(int)
(	O
&	O
fatal_signal_set	struct(array(long))
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_fatal_signals	O
;	O
i	long
++	O
)	O
if	O
(	O
fatal_signals	array(int)
[	O
i	long
]	O
>=	O
0	int
)	O
sigaddset	(*(struct(array(long))),int)->(int)
(	O
&	O
fatal_signal_set	struct(array(long))
,	O
fatal_signals	array(int)
[	O
i	long
]	O
)	O
;	O
fatal_signal_set_initialized	bool
=	O
true	int
;	O
}	O
}	O
void	O
block_fatal_signals	()->(void)
(	O
void	O
)	O
{	O
init_fatal_signal_set	()->(void)
(	O
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_BLOCK	int
,	O
&	O
fatal_signal_set	struct(array(long))
,	O
NULL	O
)	O
;	O
}	O
void	O
unblock_fatal_signals	()->(void)
(	O
void	O
)	O
{	O
init_fatal_signal_set	()->(void)
(	O
)	O
;	O
sigprocmask	(int,*(struct(array(long))),*(struct(array(long))))->(int)
(	O
SIG_UNBLOCK	int
,	O
&	O
fatal_signal_set	struct(array(long))
,	O
NULL	O
)	O
;	O
}	O
