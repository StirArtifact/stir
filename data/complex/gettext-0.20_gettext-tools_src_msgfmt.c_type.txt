static	O
int	O
exit_status	O
;	O
static	O
bool	bool
include_fuzzies	O
=	O
false	O
;	O
static	O
bool	bool
include_untranslated	O
=	O
false	O
;	O
static	O
const	O
char	O
*	O
output_file_name	O
;	O
static	O
bool	bool
java_mode	O
;	O
static	O
bool	bool
assume_java2	bool
;	O
static	O
const	O
char	O
*	O
java_resource_name	O
;	O
static	O
const	O
char	O
*	O
java_locale_name	O
;	O
static	O
const	O
char	O
*	O
java_class_directory	O
;	O
static	O
bool	bool
java_output_source	O
;	O
static	O
bool	bool
csharp_mode	O
;	O
static	O
const	O
char	O
*	O
csharp_resource_name	O
;	O
static	O
const	O
char	O
*	O
csharp_locale_name	O
;	O
static	O
const	O
char	O
*	O
csharp_base_directory	O
;	O
static	O
bool	bool
csharp_resources_mode	O
;	O
static	O
bool	bool
tcl_mode	O
;	O
static	O
const	O
char	O
*	O
tcl_locale_name	O
;	O
static	O
const	O
char	O
*	O
tcl_base_directory	O
;	O
static	O
bool	bool
qt_mode	O
;	O
static	O
bool	bool
desktop_mode	O
;	O
static	O
const	O
char	O
*	O
desktop_locale_name	O
;	O
static	O
const	O
char	O
*	O
desktop_template_name	O
;	O
static	O
const	O
char	O
*	O
desktop_base_directory	O
;	O
static	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
desktop_keywords	O
;	O
static	O
bool	bool
desktop_default_keywords	O
=	O
true	O
;	O
static	O
bool	bool
xml_mode	O
;	O
static	O
const	O
char	O
*	O
xml_locale_name	O
;	O
static	O
const	O
char	O
*	O
xml_template_name	O
;	O
static	O
const	O
char	O
*	O
xml_base_directory	O
;	O
static	O
const	O
char	O
*	O
xml_language	O
;	O
static	O
its_rule_list_ty	struct
*	O
xml_its_rules	O
;	O
struct	O
msg_domain	O
{	O
message_list_ty	struct
*	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
;	O
const	O
char	O
*	O
domain_name	*(char)
;	O
const	O
char	O
*	O
file_name	*(char)
;	O
struct	O
msg_domain	O
*	O
next	*(struct(int,struct(int,int,int,int,int,int),*(struct(int,struct(int,int,int,int,int,int),*(struct`)))))
;	O
}	O
;	O
static	O
struct	O
msg_domain	O
*	O
domain_list	O
;	O
static	O
struct	O
msg_domain	O
*	O
current_domain	O
;	O
int	O
verbose	int
=	O
0	int
;	O
static	O
bool	bool
check_format_strings	O
=	O
false	O
;	O
static	O
bool	bool
check_header	O
=	O
false	O
;	O
static	O
bool	bool
check_domain	O
=	O
false	O
;	O
static	O
bool	bool
check_compatibility	O
=	O
false	O
;	O
static	O
bool	bool
check_accelerators	O
=	O
false	O
;	O
static	O
char	O
accelerator_char	O
=	O
'&'	O
;	O
static	O
int	O
msgs_translated	O
;	O
static	O
int	O
msgs_untranslated	O
;	O
static	O
int	O
msgs_fuzzy	O
;	O
static	O
int	O
do_statistics	O
;	O
static	O
const	O
struct	O
option	struct(*(char),int,*(int),int)
long_options	O
[	O
]	O
=	O
{	O
{	O
"alignment"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"check"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"check-accelerators"	*(char)
,	O
optional_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
1	int
}	O
,	O
{	O
"check-compatibility"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'C'	O
}	O
,	O
{	O
"check-domain"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
2	int
}	O
,	O
{	O
"check-format"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
3	int
}	O
,	O
{	O
"check-header"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
4	int
}	O
,	O
{	O
"csharp"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
10	int
}	O
,	O
{	O
"csharp-resources"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
11	int
}	O
,	O
{	O
"desktop"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
15	int
}	O
,	O
{	O
"directory"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"endianness"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
13	int
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"java"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'j'	O
}	O
,	O
{	O
"java2"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
5	int
}	O
,	O
{	O
"keyword"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'k'	O
}	O
,	O
{	O
"language"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'L'	O
}	O
,	O
{	O
"locale"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"no-hash"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
6	int
}	O
,	O
{	O
"output-file"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"properties-input"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"qt"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
9	int
}	O
,	O
{	O
"resource"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"source"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
14	int
}	O
,	O
{	O
"statistics"	*(char)
,	O
no_argument	O
,	O
&	O
do_statistics	O
,	O
1	int
}	O
,	O
{	O
"strict"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'S'	O
}	O
,	O
{	O
"stringtable-input"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
8	int
}	O
,	O
{	O
"tcl"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
7	int
}	O
,	O
{	O
"template"	*(char)
,	O
required_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
16	int
}	O
,	O
{	O
"use-fuzzy"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'f'	O
}	O
,	O
{	O
"use-untranslated"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
12	int
}	O
,	O
{	O
"verbose"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
"xml"	*(char)
,	O
no_argument	O
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	O
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
const	O
char	O
*	O
add_mo_suffix	O
(	O
const	O
char	O
*	O
)	O
;	O
static	O
struct	O
msg_domain	O
*	O
new_domain	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
file_name	*(char)
)	O
;	O
static	O
bool	bool
is_nonobsolete	O
(	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
;	O
static	O
void	O
read_catalog_file_msgfmt	O
(	O
char	O
*	O
filename	*(char)
,	O
catalog_input_format_ty	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
)	O
;	O
static	O
int	O
msgfmt_desktop_bulk	O
(	O
const	O
char	O
*	O
directory	*(char)
,	O
const	O
char	O
*	O
template_file_name	*(char)
,	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
const	O
char	O
*	O
file_name	*(char)
)	O
;	O
static	O
int	O
msgfmt_xml_bulk	O
(	O
const	O
char	O
*	O
directory	*(char)
,	O
const	O
char	O
*	O
template_file_name	*(char)
,	O
its_rule_list_ty	struct
*	O
its_rules	*(struct)
,	O
const	O
char	O
*	O
file_name	*(char)
)	O
;	O
int	O
main	O
(	O
int	O
argc	O
,	O
char	O
*	O
argv	O
[	O
]	O
)	O
{	O
int	O
opt	O
;	O
bool	bool
do_help	O
=	O
false	O
;	O
bool	bool
do_version	O
=	O
false	O
;	O
bool	bool
strict_uniforum	O
=	O
false	O
;	O
catalog_input_format_ty	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
=	O
&	O
input_format_po	struct(*((*(struct(*`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char))->(void)),bool)
;	O
int	O
arg_i	O
;	O
const	O
char	O
*	O
canon_encoding	*(char)
;	O
struct	O
msg_domain	O
*	O
domain	*(char)
;	O
alignment	long
=	O
DEFAULT_OUTPUT_ALIGNMENT	O
;	O
byteswap	bool
=	O
0	int
^	O
ENDIANNESS	O
;	O
set_program_name	(*(char))->(void)
(	O
argv	O
[	O
0	int
]	O
)	O
;	O
error_print_progname	*(()->(void))
=	O
maybe_print_progname	()->(void)
;	O
error_one_per_line	int
=	O
1	int
;	O
exit_status	O
=	O
EXIT_SUCCESS	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	O
(	O
PACKAGE	O
,	O
relocate	O
(	O
LOCALEDIR	O
)	O
)	O
;	O
bindtextdomain	O
(	O
"bison-runtime"	*(char)
,	O
relocate	O
(	O
BISON_LOCALEDIR	O
)	O
)	O
;	O
textdomain	O
(	O
PACKAGE	O
)	O
;	O
atexit	(*(()->(void)))->(int)
(	O
close_stdout	()->(void)
)	O
;	O
while	O
(	O
(	O
opt	O
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	O
,	O
argv	O
,	O
"a:cCd:D:fhjl:L:o:Pr:vVx"	*(char)
,	O
long_options	O
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
opt	O
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'a'	O
:	O
{	O
char	O
*	O
endp	O
;	O
size_t	long
new_align	O
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
optarg	*(char)
,	O
&	O
endp	O
,	O
0	int
)	O
;	O
if	O
(	O
endp	O
!=	O
optarg	*(char)
)	O
alignment	long
=	O
new_align	O
;	O
}	O
break	O
;	O
case	O
'c'	O
:	O
check_domain	O
=	O
true	O
;	O
check_format_strings	O
=	O
true	O
;	O
check_header	O
=	O
true	O
;	O
break	O
;	O
case	O
'C'	O
:	O
check_compatibility	O
=	O
true	O
;	O
break	O
;	O
case	O
'd'	O
:	O
java_class_directory	O
=	O
optarg	*(char)
;	O
csharp_base_directory	O
=	O
optarg	*(char)
;	O
tcl_base_directory	O
=	O
optarg	*(char)
;	O
desktop_base_directory	O
=	O
optarg	*(char)
;	O
xml_base_directory	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'D'	O
:	O
dir_list_append	(*(char))->(void)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
include_fuzzies	O
=	O
true	O
;	O
break	O
;	O
case	O
'h'	O
:	O
do_help	O
=	O
true	O
;	O
break	O
;	O
case	O
'j'	O
:	O
java_mode	O
=	O
true	O
;	O
break	O
;	O
case	O
'k'	O
:	O
if	O
(	O
optarg	*(char)
==	O
NULL	O
)	O
desktop_default_keywords	O
=	O
false	O
;	O
else	O
{	O
if	O
(	O
desktop_keywords	O
.	O
table	*(struct)
==	O
NULL	O
)	O
{	O
hash_init	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),long)->(int)
(	O
&	O
desktop_keywords	O
,	O
100	int
)	O
;	O
desktop_default_keywords	O
=	O
false	O
;	O
}	O
desktop_add_keyword	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(char),bool)->(void)
(	O
&	O
desktop_keywords	O
,	O
optarg	*(char)
,	O
false	O
)	O
;	O
}	O
break	O
;	O
case	O
'l'	O
:	O
java_locale_name	O
=	O
optarg	*(char)
;	O
csharp_locale_name	O
=	O
optarg	*(char)
;	O
tcl_locale_name	O
=	O
optarg	*(char)
;	O
desktop_locale_name	O
=	O
optarg	*(char)
;	O
xml_locale_name	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'L'	O
:	O
xml_language	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'o'	O
:	O
output_file_name	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'P'	O
:	O
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
=	O
&	O
input_format_properties	struct(*((*(struct(*`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char))->(void)),bool)
;	O
break	O
;	O
case	O
'r'	O
:	O
java_resource_name	O
=	O
optarg	*(char)
;	O
csharp_resource_name	O
=	O
optarg	*(char)
;	O
break	O
;	O
case	O
'S'	O
:	O
strict_uniforum	O
=	O
true	O
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
++	O
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	O
=	O
true	O
;	O
break	O
;	O
case	O
'x'	O
:	O
xml_mode	O
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
1	int
:	O
check_accelerators	O
=	O
true	O
;	O
if	O
(	O
optarg	*(char)
!=	O
NULL	O
)	O
{	O
if	O
(	O
optarg	*(char)
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
ispunct	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
optarg	*(char)
[	O
0	int
]	O
)	O
&&	O
optarg	*(char)
[	O
1	int
]	O
==	O
'\0'	O
)	O
accelerator_char	O
=	O
optarg	*(char)
[	O
0	int
]	O
;	O
else	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"the argument to %s should be a single punctuation character"	*(char)
)	O
,	O
"--check-accelerators"	*(char)
)	O
;	O
}	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
2	int
:	O
check_domain	O
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
3	int
:	O
check_format_strings	O
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
4	int
:	O
check_header	O
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
5	int
:	O
java_mode	O
=	O
true	O
;	O
assume_java2	bool
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
6	int
:	O
no_hash_table	bool
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
7	int
:	O
tcl_mode	O
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
8	int
:	O
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
=	O
&	O
input_format_stringtable	struct(*((*(struct(*`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char))->(void)),bool)
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
9	int
:	O
qt_mode	O
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
10	int
:	O
csharp_mode	O
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
11	int
:	O
csharp_resources_mode	O
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
12	int
:	O
include_untranslated	O
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
13	int
:	O
{	O
int	O
endianness	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"big"	*(char)
)	O
==	O
0	int
)	O
endianness	O
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
optarg	*(char)
,	O
"little"	*(char)
)	O
==	O
0	int
)	O
endianness	O
=	O
0	int
;	O
else	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid endianness: %s"	*(char)
)	O
,	O
optarg	*(char)
)	O
;	O
byteswap	bool
=	O
endianness	O
^	O
ENDIANNESS	O
;	O
}	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
14	int
:	O
java_output_source	O
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
15	int
:	O
desktop_mode	O
=	O
true	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
16	int
:	O
desktop_template_name	O
=	O
optarg	*(char)
;	O
xml_template_name	O
=	O
optarg	*(char)
;	O
break	O
;	O
default	O
:	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
do_version	O
)	O
{	O
printf	(*(char))->(int)
(	O
"%s (GNU %s) %s\n"	*(char)
,	O
basename	(*(char))->(*(char))
(	O
program_name	*(char)
)	O
,	O
PACKAGE	O
,	O
VERSION	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	*(char)
)	O
,	O
"1995-2019"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Written by %s.\n"	*(char)
)	O
,	O
proper_name	(*(char))->(*(char))
(	O
"Ulrich Drepper"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
EXIT_SUCCESS	O
)	O
;	O
}	O
if	O
(	O
do_help	O
)	O
usage	O
(	O
EXIT_SUCCESS	O
)	O
;	O
if	O
(	O
optind	int
>=	O
argc	O
&&	O
!	O
(	O
desktop_mode	O
&&	O
desktop_base_directory	O
)	O
&&	O
!	O
(	O
xml_mode	O
&&	O
xml_base_directory	O
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"no input file given"	*(char)
)	O
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
optind	int
<	O
argc	O
&&	O
(	O
(	O
desktop_mode	O
&&	O
desktop_base_directory	O
)	O
||	O
(	O
xml_mode	O
&&	O
xml_base_directory	O
)	O
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"no input file should be given if %s and %s are specified"	*(char)
)	O
,	O
desktop_mode	O
?	O
"--desktop"	*(char)
:	O
"--xml"	*(char)
,	O
"-d"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
{	O
unsigned	O
int	O
modes	int
=	O
(	O
java_mode	O
?	O
1	int
:	O
0	int
)	O
|	O
(	O
csharp_mode	O
?	O
2	int
:	O
0	int
)	O
|	O
(	O
csharp_resources_mode	O
?	O
4	int
:	O
0	int
)	O
|	O
(	O
tcl_mode	O
?	O
8	int
:	O
0	int
)	O
|	O
(	O
qt_mode	O
?	O
16	int
:	O
0	int
)	O
|	O
(	O
desktop_mode	O
?	O
32	int
:	O
0	int
)	O
|	O
(	O
xml_mode	O
?	O
64	int
:	O
0	int
)	O
;	O
static	O
const	O
char	O
*	O
mode_options	O
[	O
]	O
=	O
{	O
"--java"	*(char)
,	O
"--csharp"	*(char)
,	O
"--csharp-resources"	*(char)
,	O
"--tcl"	*(char)
,	O
"--qt"	*(char)
,	O
"--desktop"	*(char)
,	O
"--xml"	*(char)
}	O
;	O
if	O
(	O
modes	int
&	O
(	O
modes	int
-	O
1	int
)	O
)	O
{	O
const	O
char	O
*	O
first_option	O
;	O
const	O
char	O
*	O
second_option	O
;	O
unsigned	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
;	O
i	long
++	O
)	O
if	O
(	O
modes	int
&	O
(	O
1	int
<<	O
i	long
)	O
)	O
break	O
;	O
first_option	O
=	O
mode_options	O
[	O
i	long
]	O
;	O
for	O
(	O
i	long
=	O
i	long
+	O
1	int
;	O
;	O
i	long
++	O
)	O
if	O
(	O
modes	int
&	O
(	O
1	int
<<	O
i	long
)	O
)	O
break	O
;	O
second_option	O
=	O
mode_options	O
[	O
i	long
]	O
;	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	*(char)
)	O
,	O
first_option	O
,	O
second_option	O
)	O
;	O
}	O
}	O
if	O
(	O
java_mode	O
)	O
{	O
if	O
(	O
output_file_name	O
!=	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	*(char)
)	O
,	O
"--java"	*(char)
,	O
"--output-file"	*(char)
)	O
;	O
}	O
if	O
(	O
java_class_directory	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-d directory\" specification"	*(char)
)	O
,	O
"--java"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
csharp_mode	O
)	O
{	O
if	O
(	O
output_file_name	O
!=	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	*(char)
)	O
,	O
"--csharp"	*(char)
,	O
"--output-file"	*(char)
)	O
;	O
}	O
if	O
(	O
csharp_locale_name	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-l locale\" specification"	*(char)
)	O
,	O
"--csharp"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
csharp_base_directory	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-d directory\" specification"	*(char)
)	O
,	O
"--csharp"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
tcl_mode	O
)	O
{	O
if	O
(	O
output_file_name	O
!=	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	*(char)
)	O
,	O
"--tcl"	*(char)
,	O
"--output-file"	*(char)
)	O
;	O
}	O
if	O
(	O
tcl_locale_name	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-l locale\" specification"	*(char)
)	O
,	O
"--tcl"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
tcl_base_directory	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-d directory\" specification"	*(char)
)	O
,	O
"--tcl"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
desktop_mode	O
)	O
{	O
if	O
(	O
desktop_template_name	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s requires a \"--template template\" specification"	*(char)
)	O
,	O
"--desktop"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
output_file_name	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-o file\" specification"	*(char)
)	O
,	O
"--desktop"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
desktop_base_directory	O
!=	O
NULL	O
&&	O
desktop_locale_name	O
!=	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive in %s"	*(char)
)	O
,	O
"-d"	*(char)
,	O
"-l"	*(char)
,	O
"--desktop"	*(char)
)	O
;	O
if	O
(	O
desktop_base_directory	O
==	O
NULL	O
&&	O
desktop_locale_name	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-l locale\" specification"	*(char)
)	O
,	O
"--desktop"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
xml_mode	O
)	O
{	O
if	O
(	O
xml_template_name	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s requires a \"--template template\" specification"	*(char)
)	O
,	O
"--xml"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
output_file_name	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-o file\" specification"	*(char)
)	O
,	O
"--xml"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
xml_base_directory	O
!=	O
NULL	O
&&	O
xml_locale_name	O
!=	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive in %s"	*(char)
)	O
,	O
"-d"	*(char)
,	O
"-l"	*(char)
,	O
"--xml"	*(char)
)	O
;	O
if	O
(	O
xml_base_directory	O
==	O
NULL	O
&&	O
xml_locale_name	O
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s requires a \"-l locale\" specification"	*(char)
)	O
,	O
"--xml"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
java_resource_name	O
!=	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s is only valid with %s or %s"	*(char)
)	O
,	O
"--resource"	*(char)
,	O
"--java"	*(char)
,	O
"--csharp"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
java_locale_name	O
!=	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s is only valid with %s, %s or %s"	*(char)
)	O
,	O
"--locale"	*(char)
,	O
"--java"	*(char)
,	O
"--csharp"	*(char)
,	O
"--tcl"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
java_class_directory	O
!=	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s is only valid with %s, %s or %s"	*(char)
)	O
,	O
"-d"	*(char)
,	O
"--java"	*(char)
,	O
"--csharp"	*(char)
,	O
"--tcl"	*(char)
)	O
;	O
usage	O
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
if	O
(	O
desktop_mode	O
&&	O
desktop_default_keywords	O
)	O
{	O
if	O
(	O
desktop_keywords	O
.	O
table	*(struct)
==	O
NULL	O
)	O
hash_init	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),long)->(int)
(	O
&	O
desktop_keywords	O
,	O
100	int
)	O
;	O
desktop_add_default_keywords	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))->(void)
(	O
&	O
desktop_keywords	O
)	O
;	O
}	O
if	O
(	O
desktop_mode	O
&&	O
desktop_base_directory	O
)	O
{	O
exit_status	O
=	O
msgfmt_desktop_bulk	O
(	O
desktop_base_directory	O
,	O
desktop_template_name	O
,	O
&	O
desktop_keywords	O
,	O
output_file_name	O
)	O
;	O
if	O
(	O
desktop_keywords	O
.	O
table	*(struct)
!=	O
NULL	O
)	O
hash_destroy	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))->(int)
(	O
&	O
desktop_keywords	O
)	O
;	O
exit	(int)->(void)
(	O
exit_status	O
)	O
;	O
}	O
if	O
(	O
xml_mode	O
)	O
{	O
char	O
*	O
*	O
its_dirs	O
;	O
char	O
*	O
*	O
dirs	O
;	O
locating_rule_list_ty	O
*	O
its_locating_rules	O
;	O
const	O
char	O
*	O
its_basename	O
;	O
its_dirs	O
=	O
get_search_path	O
(	O
"its"	*(char)
)	O
;	O
its_locating_rules	O
=	O
locating_rule_list_alloc	O
(	O
)	O
;	O
for	O
(	O
dirs	O
=	O
its_dirs	O
;	O
*	O
dirs	O
!=	O
NULL	O
;	O
dirs	O
++	O
)	O
locating_rule_list_add_from_directory	O
(	O
its_locating_rules	O
,	O
*	O
dirs	O
)	O
;	O
its_basename	O
=	O
locating_rule_list_locate	O
(	O
its_locating_rules	O
,	O
xml_template_name	O
,	O
xml_language	O
)	O
;	O
if	O
(	O
its_basename	O
!=	O
NULL	O
)	O
{	O
size_t	long
j	O
;	O
xml_its_rules	O
=	O
its_rule_list_alloc	()->(*(struct))
(	O
)	O
;	O
for	O
(	O
j	O
=	O
0	int
;	O
its_dirs	O
[	O
j	O
]	O
!=	O
NULL	O
;	O
j	O
++	O
)	O
{	O
char	O
*	O
its_filename	O
=	O
xconcatenated_filename	O
(	O
its_dirs	O
[	O
j	O
]	O
,	O
its_basename	O
,	O
NULL	O
)	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	O
;	O
bool	bool
ok	O
=	O
false	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
its_filename	O
,	O
&	O
statbuf	O
)	O
==	O
0	int
)	O
ok	O
=	O
its_rule_list_add_from_file	(*(struct),*(char))->(bool)
(	O
xml_its_rules	O
,	O
its_filename	O
)	O
;	O
free	(*(void))->(void)
(	O
its_filename	O
)	O
;	O
if	O
(	O
ok	O
)	O
break	O
;	O
}	O
if	O
(	O
its_dirs	O
[	O
j	O
]	O
==	O
NULL	O
)	O
{	O
its_rule_list_free	(*(struct))->(void)
(	O
xml_its_rules	O
)	O
;	O
xml_its_rules	O
=	O
NULL	O
;	O
}	O
}	O
locating_rule_list_free	O
(	O
its_locating_rules	O
)	O
;	O
for	O
(	O
dirs	O
=	O
its_dirs	O
;	O
*	O
dirs	O
!=	O
NULL	O
;	O
dirs	O
++	O
)	O
free	(*(void))->(void)
(	O
*	O
dirs	O
)	O
;	O
free	(*(void))->(void)
(	O
its_dirs	O
)	O
;	O
if	O
(	O
xml_its_rules	O
==	O
NULL	O
)	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"cannot locate ITS rules for %s"	*(char)
)	O
,	O
xml_template_name	O
)	O
;	O
}	O
if	O
(	O
xml_mode	O
&&	O
xml_base_directory	O
)	O
{	O
exit_status	O
=	O
msgfmt_xml_bulk	O
(	O
xml_base_directory	O
,	O
xml_template_name	O
,	O
xml_its_rules	O
,	O
output_file_name	O
)	O
;	O
exit	(int)->(void)
(	O
exit_status	O
)	O
;	O
}	O
if	O
(	O
output_file_name	O
!=	O
NULL	O
)	O
current_domain	O
=	O
new_domain	O
(	O
output_file_name	O
,	O
strict_uniforum	O
&&	O
!	O
csharp_resources_mode	O
&&	O
!	O
qt_mode	O
?	O
add_mo_suffix	O
(	O
output_file_name	O
)	O
:	O
output_file_name	O
)	O
;	O
for	O
(	O
arg_i	O
=	O
optind	int
;	O
arg_i	O
<	O
argc	O
;	O
arg_i	O
++	O
)	O
{	O
if	O
(	O
output_file_name	O
==	O
NULL	O
)	O
current_domain	O
=	O
NULL	O
;	O
read_catalog_file_msgfmt	O
(	O
argv	O
[	O
arg_i	O
]	O
,	O
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
)	O
;	O
}	O
canon_encoding	*(char)
=	O
(	O
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
->	O
produces_utf8	bool
?	O
po_charset_utf8	*(char)
:	O
NULL	O
)	O
;	O
for	O
(	O
domain	*(char)
=	O
domain_list	O
;	O
domain	*(char)
!=	O
NULL	O
;	O
domain	*(char)
=	O
domain	*(char)
->	O
next	*(struct(int,struct(int,int,int,int,int,int),*(struct(int,struct(int,int,int,int,int,int),*(struct`)))))
)	O
message_list_remove_if_not	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*((*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`)))->(bool)))->(void)
(	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
is_nonobsolete	O
)	O
;	O
{	O
int	O
nerrors	O
=	O
0	int
;	O
for	O
(	O
domain	*(char)
=	O
domain_list	O
;	O
domain	*(char)
!=	O
NULL	O
;	O
domain	*(char)
=	O
domain	*(char)
->	O
next	*(struct(int,struct(int,int,int,int,int,int),*(struct(int,struct(int,int,int,int,int,int),*(struct`)))))
)	O
nerrors	O
+=	O
check_message_list	O
(	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
0	int
,	O
0	int
,	O
1	int
,	O
check_format_strings	O
,	O
check_header	O
,	O
check_compatibility	O
,	O
check_accelerators	O
,	O
accelerator_char	O
)	O
;	O
if	O
(	O
nerrors	O
>	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
ngettext	O
(	O
"found %d fatal error"	*(char)
,	O
"found %d fatal errors"	*(char)
,	O
nerrors	O
)	O
,	O
nerrors	O
)	O
;	O
exit_status	O
=	O
EXIT_FAILURE	int
;	O
}	O
}	O
for	O
(	O
domain	*(char)
=	O
domain_list	O
;	O
domain	*(char)
!=	O
NULL	O
;	O
domain	*(char)
=	O
domain	*(char)
->	O
next	*(struct(int,struct(int,int,int,int,int,int),*(struct(int,struct(int,int,int,int,int,int),*(struct`)))))
)	O
{	O
if	O
(	O
java_mode	O
)	O
{	O
if	O
(	O
msgdomain_write_java	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char),*(char),*(char),bool,bool)->(int)
(	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
canon_encoding	*(char)
,	O
java_resource_name	O
,	O
java_locale_name	O
,	O
java_class_directory	O
,	O
assume_java2	bool
,	O
java_output_source	O
)	O
)	O
exit_status	O
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
csharp_mode	O
)	O
{	O
if	O
(	O
msgdomain_write_csharp	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char),*(char),*(char))->(int)
(	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
canon_encoding	*(char)
,	O
csharp_resource_name	O
,	O
csharp_locale_name	O
,	O
csharp_base_directory	O
)	O
)	O
exit_status	O
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
csharp_resources_mode	O
)	O
{	O
if	O
(	O
msgdomain_write_csharp_resources	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char),*(char))->(int)
(	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
canon_encoding	*(char)
,	O
domain	*(char)
->	O
domain_name	*(char)
,	O
domain	*(char)
->	O
file_name	*(char)
)	O
)	O
exit_status	O
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
tcl_mode	O
)	O
{	O
if	O
(	O
msgdomain_write_tcl	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char),*(char))->(int)
(	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
canon_encoding	*(char)
,	O
tcl_locale_name	O
,	O
tcl_base_directory	O
)	O
)	O
exit_status	O
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
qt_mode	O
)	O
{	O
if	O
(	O
msgdomain_write_qt	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char),*(char))->(int)
(	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
canon_encoding	*(char)
,	O
domain	*(char)
->	O
domain_name	*(char)
,	O
domain	*(char)
->	O
file_name	*(char)
)	O
)	O
exit_status	O
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
desktop_mode	O
)	O
{	O
if	O
(	O
msgdomain_write_desktop	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char),*(char),*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(char))->(int)
(	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
canon_encoding	*(char)
,	O
desktop_locale_name	O
,	O
desktop_template_name	O
,	O
&	O
desktop_keywords	O
,	O
domain	*(char)
->	O
file_name	*(char)
)	O
)	O
exit_status	O
=	O
EXIT_FAILURE	int
;	O
if	O
(	O
desktop_keywords	O
.	O
table	*(struct)
!=	O
NULL	O
)	O
hash_destroy	(*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))->(int)
(	O
&	O
desktop_keywords	O
)	O
;	O
}	O
else	O
if	O
(	O
xml_mode	O
)	O
{	O
if	O
(	O
msgdomain_write_xml	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char),*(char),*(struct),*(char))->(int)
(	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
canon_encoding	*(char)
,	O
xml_locale_name	O
,	O
xml_template_name	O
,	O
xml_its_rules	O
,	O
domain	*(char)
->	O
file_name	*(char)
)	O
)	O
exit_status	O
=	O
EXIT_FAILURE	int
;	O
}	O
else	O
{	O
if	O
(	O
msgdomain_write_mo	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*(char),*(char))->(int)
(	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
domain	*(char)
->	O
domain_name	*(char)
,	O
domain	*(char)
->	O
file_name	*(char)
)	O
)	O
exit_status	O
=	O
EXIT_FAILURE	int
;	O
}	O
message_list_free	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),int)->(void)
(	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
0	int
)	O
;	O
}	O
if	O
(	O
verbose	int
||	O
do_statistics	O
)	O
{	O
if	O
(	O
do_statistics	O
+	O
verbose	int
>=	O
2	int
&&	O
optind	int
<	O
argc	O
)	O
{	O
char	O
*	O
all_input_file_names	O
;	O
{	O
string_list_ty	struct
input_file_names	O
;	O
string_list_init	(*(struct(*(*(char)),long,long)))->(void)
(	O
&	O
input_file_names	O
)	O
;	O
;	O
for	O
(	O
arg_i	O
=	O
optind	int
;	O
arg_i	O
<	O
argc	O
;	O
arg_i	O
++	O
)	O
string_list_append	(*(struct(*(*(char)),long,long)),*(char))->(void)
(	O
&	O
input_file_names	O
,	O
argv	O
[	O
arg_i	O
]	O
)	O
;	O
all_input_file_names	O
=	O
string_list_join	(*(struct(*(*(char)),long,long)),*(char),char,bool)->(*(char))
(	O
&	O
input_file_names	O
,	O
", "	*(char)
,	O
'\0'	O
,	O
false	O
)	O
;	O
string_list_destroy	(*(struct(*(*(char)),long,long)))->(void)
(	O
&	O
input_file_names	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"%s: "	*(char)
)	O
,	O
all_input_file_names	O
)	O
;	O
free	(*(void))->(void)
(	O
all_input_file_names	O
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ngettext	O
(	O
"%d translated message"	*(char)
,	O
"%d translated messages"	*(char)
,	O
msgs_translated	O
)	O
,	O
msgs_translated	O
)	O
;	O
if	O
(	O
msgs_fuzzy	O
>	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ngettext	O
(	O
", %d fuzzy translation"	*(char)
,	O
", %d fuzzy translations"	*(char)
,	O
msgs_fuzzy	O
)	O
,	O
msgs_fuzzy	O
)	O
;	O
if	O
(	O
msgs_untranslated	O
>	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
ngettext	O
(	O
", %d untranslated message"	*(char)
,	O
", %d untranslated messages"	*(char)
,	O
msgs_untranslated	O
)	O
,	O
msgs_untranslated	O
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
".\n"	*(char)
,	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
exit	(int)->(void)
(	O
exit_status	O
)	O
;	O
}	O
static	O
void	O
usage	O
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	O
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Usage: %s [OPTION] filename.po ...\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Generate binary message catalog from textual translation description.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Mandatory arguments to long options are mandatory for short options too.\nSimilarly for optional arguments.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Input file location:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  filename.po ...             input files\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -D, --directory=DIRECTORY   add DIRECTORY to list for input files search\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"If input file is -, standard input is read.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Operation mode:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -j, --java                  Java mode: generate a Java ResourceBundle class\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --java2                 like --java, and assume Java2 (JDK 1.2 or higher)\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --csharp                C# mode: generate a .NET .dll file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --csharp-resources      C# resources mode: generate a .NET .resources file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --tcl                   Tcl mode: generate a tcl/msgcat .msg file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --qt                    Qt mode: generate a Qt .qm file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --desktop               Desktop Entry mode: generate a .desktop file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --xml                   XML mode: generate XML file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Output file location:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -o, --output-file=FILE      write output to specified file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --strict                enable strict Uniforum mode\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"If output file is -, output is written to standard output.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Output file location in Java mode:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -r, --resource=RESOURCE     resource name\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -l, --locale=LOCALE         locale name, either language or language_COUNTRY\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --source                produce a .java file, instead of a .class file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -d DIRECTORY                base directory of classes directory hierarchy\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"The class name is determined by appending the locale name to the resource name,\nseparated with an underscore.  The -d option is mandatory.  The class is\nwritten under the specified directory.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Output file location in C# mode:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -r, --resource=RESOURCE     resource name\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -l, --locale=LOCALE         locale name, either language or language_COUNTRY\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -d DIRECTORY                base directory for locale dependent .dll files\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"The -l and -d options are mandatory.  The .dll file is written in a\nsubdirectory of the specified directory whose name depends on the locale.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Output file location in Tcl mode:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -l, --locale=LOCALE         locale name, either language or language_COUNTRY\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -d DIRECTORY                base directory of .msg message catalogs\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"The -l and -d options are mandatory.  The .msg file is written in the\nspecified directory.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Desktop Entry mode options:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -l, --locale=LOCALE         locale name, either language or language_COUNTRY\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -o, --output-file=FILE      write output to specified file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  --template=TEMPLATE         a .desktop file used as a template\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -d DIRECTORY                base directory of .po files\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -kWORD, --keyword=WORD      look for WORD as an additional keyword\n  -k, --keyword               do not to use default keywords\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"The -l, -o, and --template options are mandatory.  If -D is specified, input\nfiles are read from the directory instead of the command line arguments.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"XML mode options:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -l, --locale=LOCALE         locale name, either language or language_COUNTRY\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -L, --language=NAME         recognise the specified XML language\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -o, --output-file=FILE      write output to specified file\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  --template=TEMPLATE         an XML file used as a template\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -d DIRECTORY                base directory of .po files\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"The -l, -o, and --template options are mandatory.  If -D is specified, input\nfiles are read from the directory instead of the command line arguments.\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Input file syntax:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -P, --properties-input      input files are in Java .properties syntax\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --stringtable-input     input files are in NeXTstep/GNUstep .strings\n                              syntax\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Input file interpretation:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -c, --check                 perform all the checks implied by\n                                --check-format, --check-header, --check-domain\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --check-format          check language dependent format strings\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --check-header          verify presence and contents of the header entry\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --check-domain          check for conflicts between domain directives\n                                and the --output-file option\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -C, --check-compatibility   check that GNU msgfmt behaves like X/Open msgfmt\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --check-accelerators[=CHAR]  check presence of keyboard accelerators for\n                                menu items\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -f, --use-fuzzy             use fuzzy entries in output\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Output details:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -a, --alignment=NUMBER      align strings to NUMBER bytes (default: %d)\n"	*(char)
)	O
,	O
DEFAULT_OUTPUT_ALIGNMENT	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --endianness=BYTEORDER  write out 32-bit numbers in the given byte order\n                                (big or little, default depends on platform)\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --no-hash               binary file will not include the hash table\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Informative output:\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -h, --help                  display this help and exit\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -V, --version               output version information and exit\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"      --statistics            print statistics about translations\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"  -v, --verbose               increase verbosity level\n"	*(char)
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	*(char)
)	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
exit	(int)->(void)
(	O
status	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
add_mo_suffix	O
(	O
const	O
char	O
*	O
fname	O
)	O
{	O
size_t	long
len	O
;	O
char	O
*	O
result	*(*(void))
;	O
len	O
=	O
strlen	(*(char))->(long)
(	O
fname	O
)	O
;	O
if	O
(	O
len	O
>	O
3	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
fname	O
+	O
len	O
-	O
3	int
,	O
".mo"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
return	O
fname	O
;	O
if	O
(	O
len	O
>	O
4	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
fname	O
+	O
len	O
-	O
4	int
,	O
".gmo"	*(char)
,	O
4	int
)	O
==	O
0	int
)	O
return	O
fname	O
;	O
result	*(*(void))
=	O
XNMALLOC	O
(	O
len	O
+	O
4	int
,	O
char	O
)	O
;	O
stpcpy	(*(char),*(char))->(*(char))
(	O
stpcpy	(*(char),*(char))->(*(char))
(	O
result	*(*(void))
,	O
fname	O
)	O
,	O
".mo"	*(char)
)	O
;	O
return	O
result	*(*(void))
;	O
}	O
static	O
struct	O
msg_domain	O
*	O
new_domain	O
(	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
file_name	*(char)
)	O
{	O
struct	O
msg_domain	O
*	O
*	O
p_dom	O
=	O
&	O
domain_list	O
;	O
while	O
(	O
*	O
p_dom	O
!=	O
NULL	O
&&	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
(	O
*	O
p_dom	O
)	O
->	O
domain_name	*(char)
)	O
!=	O
0	int
)	O
p_dom	O
=	O
&	O
(	O
*	O
p_dom	O
)	O
->	O
next	*(struct(int,struct(int,int,int,int,int,int),*(struct(int,struct(int,int,int,int,int,int),*(struct`)))))
;	O
if	O
(	O
*	O
p_dom	O
==	O
NULL	O
)	O
{	O
struct	O
msg_domain	O
*	O
domain	*(char)
;	O
domain	*(char)
=	O
XMALLOC	O
(	O
struct	O
msg_domain	O
)	O
;	O
domain	*(char)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
=	O
message_list_alloc	(bool)->(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))))
(	O
true	O
)	O
;	O
domain	*(char)
->	O
domain_name	*(char)
=	O
name	*(char)
;	O
domain	*(char)
->	O
file_name	*(char)
=	O
file_name	*(char)
;	O
domain	*(char)
->	O
next	*(struct(int,struct(int,int,int,int,int,int),*(struct(int,struct(int,int,int,int,int,int),*(struct`)))))
=	O
NULL	O
;	O
*	O
p_dom	O
=	O
domain	*(char)
;	O
}	O
return	O
*	O
p_dom	O
;	O
}	O
static	O
bool	bool
is_nonobsolete	O
(	O
const	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
{	O
return	O
!	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
obsolete	bool
;	O
}	O
typedef	O
struct	O
msgfmt_catalog_reader_ty	O
msgfmt_catalog_reader_ty	O
;	O
struct	O
msgfmt_catalog_reader_ty	O
{	O
DEFAULT_CATALOG_READER_TY	O
bool	bool
has_header_entry	O
;	O
}	O
;	O
static	O
void	O
msgfmt_constructor	O
(	O
abstract_catalog_reader_ty	struct
*	O
that	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))))))
)	O
{	O
msgfmt_catalog_reader_ty	O
*	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
=	O
(	O
msgfmt_catalog_reader_ty	O
*	O
)	O
that	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))))))
;	O
default_constructor	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
that	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))))))
)	O
;	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
->	O
has_header_entry	O
=	O
false	O
;	O
}	O
static	O
void	O
msgfmt_parse_debrief	O
(	O
abstract_catalog_reader_ty	struct
*	O
that	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))))))
)	O
{	O
msgfmt_catalog_reader_ty	O
*	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
=	O
(	O
msgfmt_catalog_reader_ty	O
*	O
)	O
that	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))))))
;	O
default_parse_debrief	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
that	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))))))
)	O
;	O
if	O
(	O
check_header	O
)	O
{	O
if	O
(	O
!	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
->	O
has_header_entry	O
)	O
{	O
multiline_error	(*(char),*(char))->(void)
(	O
xasprintf	(*(char))->(*(char))
(	O
"%s: "	*(char)
,	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
->	O
file_name	*(char)
)	O
,	O
xasprintf	(*(char))->(*(char))
(	O
_	O
(	O
"warning: PO file header missing or invalid\n"	*(char)
)	O
)	O
)	O
;	O
multiline_error	(*(char),*(char))->(void)
(	O
NULL	O
,	O
xasprintf	(*(char))->(*(char))
(	O
_	O
(	O
"warning: charset conversion will not work\n"	*(char)
)	O
)	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
msgfmt_set_domain	O
(	O
default_catalog_reader_ty	struct
*	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
,	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
!	O
java_mode	O
&&	O
!	O
csharp_mode	O
&&	O
!	O
csharp_resources_mode	O
&&	O
!	O
tcl_mode	O
&&	O
!	O
qt_mode	O
&&	O
!	O
desktop_mode	O
&&	O
!	O
xml_mode	O
&&	O
output_file_name	O
==	O
NULL	O
)	O
{	O
size_t	long
correct	O
;	O
correct	O
=	O
strcspn	(*(char),*(char))->(long)
(	O
name	*(char)
,	O
INVALID_PATH_CHAR	O
)	O
;	O
if	O
(	O
name	*(char)
[	O
correct	O
]	O
!=	O
'\0'	O
)	O
{	O
exit_status	O
=	O
EXIT_FAILURE	int
;	O
if	O
(	O
correct	O
==	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"domain name \"%s\" not suitable as file name"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
else	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"domain name \"%s\" not suitable as file name: will use prefix"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
name	*(char)
[	O
correct	O
]	O
=	O
'\0'	O
;	O
}	O
current_domain	O
=	O
new_domain	O
(	O
name	*(char)
,	O
add_mo_suffix	O
(	O
name	*(char)
)	O
)	O
;	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
->	O
domain	*(char)
=	O
current_domain	O
->	O
domain_name	*(char)
;	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
=	O
current_domain	O
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
;	O
}	O
else	O
{	O
if	O
(	O
check_domain	O
)	O
po_gram_error_at_line	(*(struct(*(char),long)),*(char))->(void)
(	O
&	O
gram_pos	struct(*(char),long)
,	O
_	O
(	O
"'domain %s' directive ignored"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
msgfmt_add_message	O
(	O
default_catalog_reader_ty	struct
*	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
,	O
char	O
*	O
msgctxt	*(char)
,	O
char	O
*	O
msgid	*(char)
,	O
lex_pos_ty	struct
*	O
msgid_pos	*(struct(*(char),long))
,	O
char	O
*	O
msgid_plural	*(char)
,	O
char	O
*	O
msgstr	*(char)
,	O
size_t	long
msgstr_len	long
,	O
lex_pos_ty	struct
*	O
msgstr_pos	*(struct(*(char),long))
,	O
char	O
*	O
prev_msgctxt	*(char)
,	O
char	O
*	O
prev_msgid	*(char)
,	O
char	O
*	O
prev_msgid_plural	*(char)
,	O
bool	bool
force_fuzzy	bool
,	O
bool	bool
obsolete	bool
)	O
{	O
if	O
(	O
current_domain	O
==	O
NULL	O
)	O
{	O
current_domain	O
=	O
new_domain	O
(	O
MESSAGE_DOMAIN_DEFAULT	O
,	O
add_mo_suffix	O
(	O
MESSAGE_DOMAIN_DEFAULT	O
)	O
)	O
;	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
->	O
domain	*(char)
=	O
current_domain	O
->	O
domain_name	*(char)
;	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
=	O
current_domain	O
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
;	O
}	O
default_add_message	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),bool,bool,bool,bool,*(char),*(struct(*`,long,long,bool,*`)),*(char),*(struct(*`,long,long,bool,struct`)),*(struct(*`,long,long)),*(struct(*`,long,long)),long,*(struct(*`,long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)))),*(char),*(char),*(struct(*(char),long)),*(char),*(char),long,*(struct(*(char),long)),*(char),*(char),*(char),bool,bool)->(void)
(	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
,	O
msgctxt	*(char)
,	O
msgid	*(char)
,	O
msgid_pos	*(struct(*(char),long))
,	O
msgid_plural	*(char)
,	O
msgstr	*(char)
,	O
msgstr_len	long
,	O
msgstr_pos	*(struct(*(char),long))
,	O
prev_msgctxt	*(char)
,	O
prev_msgid	*(char)
,	O
prev_msgid_plural	*(char)
,	O
force_fuzzy	bool
,	O
obsolete	bool
)	O
;	O
}	O
static	O
void	O
msgfmt_frob_new_message	O
(	O
default_catalog_reader_ty	struct
*	O
that	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))))))
,	O
message_ty	struct
*	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
,	O
const	O
lex_pos_ty	struct
*	O
msgid_pos	*(struct(*(char),long))
,	O
const	O
lex_pos_ty	struct
*	O
msgstr_pos	*(struct(*(char),long))
)	O
{	O
msgfmt_catalog_reader_ty	O
*	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
=	O
(	O
msgfmt_catalog_reader_ty	O
*	O
)	O
that	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))))))
;	O
if	O
(	O
!	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
obsolete	bool
)	O
{	O
if	O
(	O
(	O
!	O
include_untranslated	O
&&	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
||	O
(	O
!	O
include_fuzzies	O
&&	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
is_fuzzy	bool
&&	O
!	O
is_header	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
)	O
)	O
{	O
if	O
(	O
check_compatibility	O
)	O
{	O
error_with_progname	bool
=	O
false	O
;	O
error_at_line	(int,int,*(char),int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
pos	struct(*(char),long)
.	O
file_name	*(char)
,	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
pos	struct(*(char),long)
.	O
line_number	long
,	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
[	O
0	int
]	O
==	O
'\0'	O
?	O
_	O
(	O
"empty 'msgstr' entry ignored"	*(char)
)	O
:	O
_	O
(	O
"fuzzy 'msgstr' entry ignored"	*(char)
)	O
)	O
)	O
;	O
error_with_progname	bool
=	O
true	O
;	O
}	O
if	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
msgstr	*(char)
[	O
0	int
]	O
==	O
'\0'	O
)	O
++	O
msgs_untranslated	O
;	O
else	O
++	O
msgs_fuzzy	O
;	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
obsolete	bool
=	O
true	O
;	O
}	O
else	O
{	O
if	O
(	O
is_header	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
)	O
)	O
{	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
->	O
has_header_entry	O
=	O
true	O
;	O
}	O
else	O
if	O
(	O
mp	*(struct(*(char),*(char),*(char),*(char),long,struct(*(char),long),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct(*(char),*(char),*(char),*(char),long,struct(*`,long),*(struct`),*(struct`),long,*(struct`),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*(char),*(char),*(char),bool,int,*(struct`),int,*(struct`))),int,*(struct(*(char),long,*(char),*(struct`),*(struct`),*(char)))))
->	O
is_fuzzy	bool
)	O
++	O
msgs_fuzzy	O
;	O
else	O
++	O
msgs_translated	O
;	O
}	O
}	O
}	O
static	O
void	O
msgfmt_comment_special	O
(	O
abstract_catalog_reader_ty	struct
*	O
that	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))))))
,	O
const	O
char	O
*	O
s	*(char)
)	O
{	O
msgfmt_catalog_reader_ty	O
*	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
=	O
(	O
msgfmt_catalog_reader_ty	O
*	O
)	O
that	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))))))
;	O
default_comment_special	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
(	O
that	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))))))
,	O
s	*(char)
)	O
;	O
if	O
(	O
this	*(struct(*(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void)))),bool,bool,bool,bool,*(char),*(struct(*(*`),long,long,bool,*(char))),*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`))),*(struct(*(*`),long,long)),*(struct(*(*`),long,long)),long,*(struct(*(char),long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int))))
->	O
is_fuzzy	bool
)	O
{	O
static	O
bool	bool
warned	O
=	O
false	O
;	O
if	O
(	O
!	O
include_fuzzies	O
&&	O
check_compatibility	O
&&	O
!	O
warned	O
)	O
{	O
warned	O
=	O
true	O
;	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s: warning: source file contains fuzzy translation"	*(char)
)	O
,	O
gram_pos	struct(*(char),long)
.	O
file_name	*(char)
)	O
;	O
}	O
}	O
}	O
static	O
default_catalog_reader_class_ty	struct
msgfmt_methods	O
=	O
{	O
{	O
sizeof	O
(	O
msgfmt_catalog_reader_ty	O
)	O
,	O
msgfmt_constructor	O
,	O
default_destructor	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
,	O
default_parse_brief	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
,	O
msgfmt_parse_debrief	O
,	O
default_directive_domain	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
,	O
default_directive_message	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))),*(char),*(char),*(struct(*(char),long)),*(char),*(char),long,*(struct(*(char),long)),*(char),*(char),*(char),bool,bool)->(void)
,	O
default_comment	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
,	O
default_comment_dot	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))),*(char))->(void)
,	O
default_comment_filepos	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))),*(char),long)->(void)
,	O
msgfmt_comment_special	O
}	O
,	O
msgfmt_set_domain	O
,	O
msgfmt_add_message	O
,	O
msgfmt_frob_new_message	O
}	O
;	O
static	O
void	O
read_catalog_file_msgfmt	O
(	O
char	O
*	O
filename	*(char)
,	O
catalog_input_format_ty	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
)	O
{	O
char	O
*	O
real_filename	*(char)
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
open_catalog_file	(*(char),*(*(char)),bool)->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
&	O
real_filename	*(char)
,	O
true	O
)	O
;	O
default_catalog_reader_ty	struct
*	O
pop	*(struct)
;	O
pop	*(struct)
=	O
default_catalog_reader_alloc	(*(struct(struct(long,*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`,long)->(void)),*((*`,*`)->(void))),*((*`,*`)->(void)),*((*`,*`,*`,*`,*`,*`,long,*`,*`,*`,*`,bool,bool)->(void)),*((*`,*`,*`,*`)->(void)))))->(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)),bool,bool,bool,bool,*(char),*(struct(*`,long,long,bool,*`)),*(char),*(struct(*`,long,long,bool,struct`)),*(struct(*`,long,long)),*(struct(*`,long,long)),long,*(struct(*`,long)),bool,array(enum(int,int,int,int,int,int)),struct(int,int),enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)))))
(	O
&	O
msgfmt_methods	O
)	O
;	O
pop	*(struct)
->	O
handle_comments	bool
=	O
false	O
;	O
pop	*(struct)
->	O
allow_domain_directives	bool
=	O
true	O
;	O
pop	*(struct)
->	O
allow_duplicates	bool
=	O
false	O
;	O
pop	*(struct)
->	O
allow_duplicates_if_same_msgstr	bool
=	O
false	O
;	O
pop	*(struct)
->	O
file_name	*(char)
=	O
real_filename	*(char)
;	O
pop	*(struct)
->	O
mdlp	*(struct(*(*(struct(*`,*`))),long,long,bool,*(char)))
=	O
NULL	O
;	O
pop	*(struct)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
=	O
NULL	O
;	O
if	O
(	O
current_domain	O
!=	O
NULL	O
)	O
{	O
pop	*(struct)
->	O
domain	*(char)
=	O
current_domain	O
->	O
domain_name	*(char)
;	O
pop	*(struct)
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
=	O
current_domain	O
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
;	O
}	O
po_lex_pass_obsolete_entries	(bool)->(void)
(	O
true	O
)	O
;	O
catalog_reader_parse	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),*(char),*(struct(*((*`,*`,*`,*`)->(void)),bool)))->(void)
(	O
(	O
abstract_catalog_reader_ty	struct
*	O
)	O
pop	*(struct)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
real_filename	*(char)
,	O
filename	*(char)
,	O
input_syntax	*(struct(*((*(struct`),*(struct`),*(char),*(char))->(void)),bool))
)	O
;	O
catalog_reader_free	(*(struct(*(struct(long,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`)))))->(void)
(	O
(	O
abstract_catalog_reader_ty	struct
*	O
)	O
pop	*(struct)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
!=	O
stdin	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
static	O
void	O
add_languages	O
(	O
string_list_ty	struct
*	O
languages	O
,	O
string_list_ty	struct
*	O
desired_languages	O
,	O
const	O
char	O
*	O
line	long
,	O
size_t	long
length	O
)	O
{	O
char	O
*	O
start	O
;	O
for	O
(	O
start	O
=	O
(	O
char	O
*	O
)	O
line	long
;	O
start	O
-	O
line	long
<	O
length	O
;	O
)	O
{	O
char	O
*	O
p	*(void)
;	O
while	O
(	O
*	O
start	O
==	O
' '	O
||	O
*	O
start	O
==	O
'\t'	O
)	O
start	O
++	O
;	O
p	*(void)
=	O
start	O
;	O
while	O
(	O
*	O
p	*(void)
!=	O
'\0'	O
&&	O
*	O
p	*(void)
!=	O
' '	O
&&	O
*	O
p	*(void)
!=	O
'\t'	O
)	O
p	*(void)
++	O
;	O
*	O
p	*(void)
=	O
'\0'	O
;	O
if	O
(	O
desired_languages	O
==	O
NULL	O
||	O
string_list_member	(*(struct(*(*(char)),long,long)),*(char))->(bool)
(	O
desired_languages	O
,	O
start	O
)	O
)	O
string_list_append_unique	(*(struct(*(*(char)),long,long)),*(char))->(void)
(	O
languages	O
,	O
start	O
)	O
;	O
start	O
=	O
p	*(void)
+	O
1	int
;	O
}	O
}	O
static	O
void	O
get_languages	O
(	O
string_list_ty	struct
*	O
languages	O
,	O
const	O
char	O
*	O
directory	*(char)
)	O
{	O
char	O
*	O
envval	O
;	O
string_list_ty	struct
real_desired_languages	O
,	O
*	O
desired_languages	O
=	O
NULL	O
;	O
char	O
*	O
linguas_file_name	O
=	O
NULL	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
statbuf	O
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
size_t	long
line_len	O
=	O
0	int
;	O
char	O
*	O
line_buf	O
=	O
NULL	O
;	O
envval	O
=	O
getenv	(*(char))->(*(char))
(	O
"LINGUAS"	*(char)
)	O
;	O
if	O
(	O
envval	O
)	O
{	O
string_list_init	(*(struct(*(*(char)),long,long)))->(void)
(	O
&	O
real_desired_languages	O
)	O
;	O
add_languages	O
(	O
&	O
real_desired_languages	O
,	O
NULL	O
,	O
envval	O
,	O
strlen	(*(char))->(long)
(	O
envval	O
)	O
)	O
;	O
desired_languages	O
=	O
&	O
real_desired_languages	O
;	O
}	O
linguas_file_name	O
=	O
xconcatenated_filename	O
(	O
directory	*(char)
,	O
"LINGUAS"	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
linguas_file_name	O
,	O
&	O
statbuf	O
)	O
<	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s does not exist"	*(char)
)	O
,	O
linguas_file_name	O
)	O
;	O
goto	O
out	O
;	O
}	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
linguas_file_name	O
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
==	O
NULL	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_SUCCESS	O
,	O
0	int
,	O
_	O
(	O
"%s exists but cannot read"	*(char)
)	O
,	O
linguas_file_name	O
)	O
;	O
goto	O
out	O
;	O
}	O
while	O
(	O
!	O
feof	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
int	O
len	O
=	O
getline	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
line_buf	O
,	O
&	O
line_len	O
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
len	O
<	O
0	int
)	O
break	O
;	O
if	O
(	O
len	O
>	O
0	int
&&	O
line_buf	O
[	O
len	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
line_buf	O
[	O
--	O
len	O
]	O
=	O
'\0'	O
;	O
while	O
(	O
len	O
>	O
0	int
&&	O
(	O
line_buf	O
[	O
len	O
-	O
1	int
]	O
==	O
' '	O
||	O
line_buf	O
[	O
len	O
-	O
1	int
]	O
==	O
'\t'	O
||	O
line_buf	O
[	O
len	O
-	O
1	int
]	O
==	O
'\r'	O
)	O
)	O
line_buf	O
[	O
--	O
len	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
line_buf	O
==	O
'\0'	O
||	O
*	O
line_buf	O
==	O
'#'	O
)	O
continue	O
;	O
add_languages	O
(	O
languages	O
,	O
desired_languages	O
,	O
line_buf	O
,	O
len	O
)	O
;	O
}	O
free	(*(void))->(void)
(	O
line_buf	O
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
out	O
:	O
if	O
(	O
desired_languages	O
!=	O
NULL	O
)	O
string_list_destroy	(*(struct(*(*(char)),long,long)))->(void)
(	O
desired_languages	O
)	O
;	O
free	(*(void))->(void)
(	O
linguas_file_name	O
)	O
;	O
}	O
static	O
void	O
msgfmt_operand_list_init	O
(	O
msgfmt_operand_list_ty	struct
*	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
)	O
{	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
items	*(struct(*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`)))))
=	O
NULL	O
;	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
nitems	long
=	O
0	int
;	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
nitems_max	long
=	O
0	int
;	O
}	O
static	O
void	O
msgfmt_operand_list_destroy	O
(	O
msgfmt_operand_list_ty	struct
*	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
nitems	long
;	O
i	long
++	O
)	O
{	O
free	(*(void))->(void)
(	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
items	*(struct(*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`)))))
[	O
i	long
]	O
.	O
language	*(char)
)	O
;	O
message_list_free	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),int)->(void)
(	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
items	*(struct(*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`)))))
[	O
i	long
]	O
.	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
0	int
)	O
;	O
}	O
free	(*(void))->(void)
(	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
items	*(struct(*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`)))))
)	O
;	O
}	O
static	O
void	O
msgfmt_operand_list_append	O
(	O
msgfmt_operand_list_ty	struct
*	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
,	O
const	O
char	O
*	O
language	*(char)
,	O
message_list_ty	struct
*	O
messages	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
)	O
{	O
msgfmt_operand_ty	struct
*	O
operand	O
;	O
if	O
(	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
nitems	long
==	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
nitems_max	long
)	O
{	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
nitems_max	long
=	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
nitems_max	long
*	O
2	int
+	O
1	int
;	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
items	*(struct(*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`)))))
=	O
xrealloc	(*(void),long)->(*(void))
(	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
items	*(struct(*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`)))))
,	O
sizeof	O
(	O
msgfmt_operand_ty	struct
)	O
*	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
nitems_max	long
)	O
;	O
}	O
operand	O
=	O
&	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
items	*(struct(*(char),*(struct(*(*`),long,long,bool,struct(long,long,*`,*`,struct`)))))
[	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
->	O
nitems	long
++	O
]	O
;	O
operand	O
->	O
language	*(char)
=	O
xstrdup	(*(char))->(*(char))
(	O
language	*(char)
)	O
;	O
operand	O
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
=	O
messages	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
;	O
}	O
static	O
int	O
msgfmt_operand_list_add_from_directory	O
(	O
msgfmt_operand_list_ty	struct
*	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
,	O
const	O
char	O
*	O
directory	*(char)
)	O
{	O
string_list_ty	struct
languages	O
;	O
void	O
*	O
saved_dir_list	O
;	O
int	O
retval	O
=	O
0	int
;	O
size_t	long
i	long
;	O
string_list_init	(*(struct(*(*(char)),long,long)))->(void)
(	O
&	O
languages	O
)	O
;	O
get_languages	O
(	O
&	O
languages	O
,	O
directory	*(char)
)	O
;	O
if	O
(	O
languages	O
.	O
nitems	long
==	O
0	int
)	O
return	O
0	int
;	O
saved_dir_list	O
=	O
dir_list_save_reset	()->(*(void))
(	O
)	O
;	O
dir_list_append	(*(char))->(void)
(	O
directory	*(char)
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
languages	O
.	O
nitems	long
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
language	*(char)
=	O
languages	O
.	O
item	*(*(char))
[	O
i	long
]	O
;	O
message_list_ty	struct
*	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
;	O
char	O
*	O
input_file_name	O
;	O
int	O
nerrors	O
;	O
current_domain	O
=	O
new_domain	O
(	O
MESSAGE_DOMAIN_DEFAULT	O
,	O
add_mo_suffix	O
(	O
MESSAGE_DOMAIN_DEFAULT	O
)	O
)	O
;	O
input_file_name	O
=	O
xconcatenated_filename	O
(	O
""	*(char)
,	O
language	*(char)
,	O
".po"	*(char)
)	O
;	O
read_catalog_file_msgfmt	O
(	O
input_file_name	O
,	O
&	O
input_format_po	struct(*((*(struct(*`)),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),*(char))->(void)),bool)
)	O
;	O
free	(*(void))->(void)
(	O
input_file_name	O
)	O
;	O
assert	O
(	O
current_domain	O
==	O
domain_list	O
&&	O
domain_list	O
->	O
next	*(struct(int,struct(int,int,int,int,int,int),*(struct(int,struct(int,int,int,int,int,int),*(struct`)))))
==	O
NULL	O
)	O
;	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
=	O
current_domain	O
->	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
;	O
free	(*(void))->(void)
(	O
current_domain	O
)	O
;	O
current_domain	O
=	O
domain_list	O
=	O
NULL	O
;	O
message_list_remove_if_not	(*(struct(*(*(struct`)),long,long,bool,struct(long,long,*(struct`),*(struct`),struct(long,*`,*`,*`,*`,union`,long,union`,union`,*`,int,int,int)))),*((*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`)))->(bool)))->(void)
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
is_nonobsolete	O
)	O
;	O
nerrors	O
=	O
check_message_list	O
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
0	int
,	O
0	int
,	O
1	int
,	O
check_format_strings	O
,	O
check_header	O
,	O
check_compatibility	O
,	O
check_accelerators	O
,	O
accelerator_char	O
)	O
;	O
retval	O
+=	O
nerrors	O
;	O
if	O
(	O
nerrors	O
>	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
ngettext	O
(	O
"found %d fatal error"	*(char)
,	O
"found %d fatal errors"	*(char)
,	O
nerrors	O
)	O
,	O
nerrors	O
)	O
;	O
continue	O
;	O
}	O
iconv_message_list	O
(	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
,	O
NULL	O
,	O
po_charset_utf8	*(char)
,	O
NULL	O
)	O
;	O
msgfmt_operand_list_append	O
(	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
,	O
language	*(char)
,	O
mlp	*(struct(*(*(struct(*`,*`,*`,*`,long,struct`,*`,*`,long,*`,bool,array(enum(int,int,int,int,int,int)),struct`,enum(int,int,int,int,int,int),array(enum(int,int,int,int,int,int)),*`,*`,*`,bool,int,*`,int,*`))),long,long,bool,struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))))
)	O
;	O
}	O
string_list_destroy	(*(struct(*(*(char)),long,long)))->(void)
(	O
&	O
languages	O
)	O
;	O
dir_list_restore	(*(void))->(void)
(	O
saved_dir_list	O
)	O
;	O
return	O
retval	O
;	O
}	O
static	O
int	O
msgfmt_desktop_bulk	O
(	O
const	O
char	O
*	O
directory	*(char)
,	O
const	O
char	O
*	O
template_file_name	*(char)
,	O
hash_table	struct(long,long,*(struct),*(struct),struct(long,*(struct(*(char),*(struct(*`,*`,array(char))),array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*(void))),*((*(void),long)->(*(void)))),union(*((*(void))->(void)),*((*(void),*(void))->(void))),*(void),int,int,int))
*	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
const	O
char	O
*	O
file_name	*(char)
)	O
{	O
msgfmt_operand_list_ty	struct
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
;	O
int	O
nerrors	O
,	O
status	int
;	O
msgfmt_operand_list_init	O
(	O
&	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
)	O
;	O
nerrors	O
=	O
msgfmt_operand_list_add_from_directory	O
(	O
&	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
,	O
directory	*(char)
)	O
;	O
if	O
(	O
nerrors	O
>	O
0	int
)	O
{	O
msgfmt_operand_list_destroy	O
(	O
&	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
)	O
;	O
return	O
1	int
;	O
}	O
status	int
=	O
msgdomain_write_desktop_bulk	(*(struct(*(struct(*`,*`)),long,long)),*(char),*(struct(long,long,*(struct),*(struct),struct(long,*(struct`),*(char),*(char),*(char),union(long,*`),long,union(*`,*`),union(*`,*`),*(void),int,int,int))),*(char))->(int)
(	O
&	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
,	O
template_file_name	*(char)
,	O
keywords	*(struct(long,long,*(struct),*(struct),struct(long,*(struct(*`,*`,array(char))),*(char),*(char),*(char),union(long,*(void)),long,union(*((long)->(*`)),*((*`,long)->(*`))),union(*((*`)->(void)),*((*`,*`)->(void))),*(void),int,int,int)))
,	O
file_name	*(char)
)	O
;	O
msgfmt_operand_list_destroy	O
(	O
&	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
msgfmt_xml_bulk	O
(	O
const	O
char	O
*	O
directory	*(char)
,	O
const	O
char	O
*	O
template_file_name	*(char)
,	O
its_rule_list_ty	struct
*	O
its_rules	*(struct)
,	O
const	O
char	O
*	O
file_name	*(char)
)	O
{	O
msgfmt_operand_list_ty	struct
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
;	O
int	O
nerrors	O
,	O
status	int
;	O
msgfmt_operand_list_init	O
(	O
&	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
)	O
;	O
nerrors	O
=	O
msgfmt_operand_list_add_from_directory	O
(	O
&	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
,	O
directory	*(char)
)	O
;	O
if	O
(	O
nerrors	O
>	O
0	int
)	O
{	O
msgfmt_operand_list_destroy	O
(	O
&	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
)	O
;	O
return	O
1	int
;	O
}	O
status	int
=	O
msgdomain_write_xml_bulk	(*(struct(*(struct(*`,*`)),long,long)),*(char),*(struct),*(char))->(int)
(	O
&	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
,	O
template_file_name	*(char)
,	O
its_rules	*(struct)
,	O
file_name	*(char)
)	O
;	O
msgfmt_operand_list_destroy	O
(	O
&	O
operands	*(struct(*(struct(*(char),*(struct`))),long,long))
)	O
;	O
return	O
status	int
;	O
}	O
