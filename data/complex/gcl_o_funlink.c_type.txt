static	O
int	O
clean_link_array	(*(int),*(int))->(int)
(	O
object	(*(int))->(int)
*	O
,	O
object	(*(int))->(int)
*	O
)	O
;	O
object	(*(int))->(int)
sScdefn	int
;	O
typedef	O
object	(*(int))->(int)
(	O
*	O
object_func	*(int)
)	O
(	O
)	O
;	O
static	O
int	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
void	O
*	O
,	O
object	(*(int))->(int)
)	O
;	O
object	(*(int))->(int)
sLAlink_arrayA	(*(int))->(int)
;	O
int	O
Rset	int
=	O
0	int
;	O
DEFVAR	()->(int)
(	O
"*LINK-LIST*"	*(char)
,	O
sSAlink_listA	O
,	O
SI	O
,	O
0	int
,	O
""	*(char)
)	O
;	O
static	O
inline	O
void	O
append_link_list	((*(int))->(int),int)->(void)
(	O
object	(*(int))->(int)
sym	(*(int))->(int)
,	O
int	O
n	int
)	O
{	O
object	(*(int))->(int)
x	(*(int))->(int)
;	O
int	O
i	int
;	O
if	O
(	O
!	O
Rset	int
||	O
!	O
sSAlink_listA	O
->	O
s	O
.	O
s_dbind	O
)	O
return	O
;	O
for	O
(	O
x	(*(int))->(int)
=	O
sSAlink_listA	O
->	O
s	O
.	O
s_dbind	O
;	O
x	(*(int))->(int)
!=	O
Cnil	O
&&	O
x	(*(int))->(int)
->	O
c	O
.	O
c_car	O
->	O
c	O
.	O
c_car	O
!=	O
sym	(*(int))->(int)
;	O
x	(*(int))->(int)
=	O
x	(*(int))->(int)
->	O
c	O
.	O
c_cdr	O
)	O
;	O
if	O
(	O
x	(*(int))->(int)
==	O
Cnil	O
)	O
sSAlink_listA	O
->	O
s	O
.	O
s_dbind	O
=	O
MMcons	()->(int)
(	O
(	O
x	(*(int))->(int)
=	O
list	()->(int)
(	O
7	int
,	O
sym	(*(int))->(int)
,	O
make_fixnum	()->(int)
(	O
0	int
)	O
,	O
make_fixnum	()->(int)
(	O
0	int
)	O
,	O
make_fixnum	()->(int)
(	O
0	int
)	O
,	O
make_fixnum	()->(int)
(	O
0	int
)	O
,	O
make_fixnum	()->(int)
(	O
0	int
)	O
,	O
make_fixnum	()->(int)
(	O
0	int
)	O
)	O
)	O
,	O
sSAlink_listA	O
->	O
s	O
.	O
s_dbind	O
)	O
;	O
else	O
x	(*(int))->(int)
=	O
x	(*(int))->(int)
->	O
c	O
.	O
c_car	O
;	O
x	(*(int))->(int)
=	O
x	(*(int))->(int)
->	O
c	O
.	O
c_cdr	O
;	O
if	O
(	O
listp	()->(int)
(	O
sym	(*(int))->(int)
->	O
s	O
.	O
s_gfdef	O
)	O
)	O
x	(*(int))->(int)
->	O
c	O
.	O
c_car	O
=	O
one_plus	()->(int)
(	O
x	(*(int))->(int)
->	O
c	O
.	O
c_car	O
)	O
;	O
for	O
(	O
x	(*(int))->(int)
=	O
x	(*(int))->(int)
->	O
c	O
.	O
c_cdr	O
,	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
,	O
x	(*(int))->(int)
=	O
x	(*(int))->(int)
->	O
c	O
.	O
c_cdr	O
)	O
;	O
x	(*(int))->(int)
->	O
c	O
.	O
c_car	O
=	O
one_plus	()->(int)
(	O
x	(*(int))->(int)
->	O
c	O
.	O
c_car	O
)	O
;	O
}	O
void	O
call_or_link	((*(int))->(int),*(*(void)))->(void)
(	O
object	(*(int))->(int)
sym	(*(int))->(int)
,	O
void	O
*	O
*	O
link	*(*(void))
)	O
{	O
object	(*(int))->(int)
fun	(*(int))->(int)
;	O
fun	(*(int))->(int)
=	O
sym	(*(int))->(int)
->	O
s	O
.	O
s_gfdef	O
;	O
if	O
(	O
fun	(*(int))->(int)
==	O
OBJNULL	O
)	O
{	O
FEinvalid_function	()->(int)
(	O
sym	(*(int))->(int)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_cclosure	O
&&	O
(	O
fun	(*(int))->(int)
->	O
cc	O
.	O
cc_turbo	O
)	O
)	O
{	O
if	O
(	O
Rset	int
==	O
0	int
)	O
MMccall	()->(int)
(	O
fun	(*(int))->(int)
)	O
;	O
else	O
fun	(*(int))->(int)
->	O
cf	O
.	O
cf_self	O
(	O
fun	(*(int))->(int)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
Rset	int
==	O
0	int
)	O
funcall	()->(int)
(	O
fun	(*(int))->(int)
)	O
;	O
else	O
if	O
(	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_cfun	O
)	O
{	O
(	O
void	O
)	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
link	*(*(void))
,	O
sLAlink_arrayA	(*(int))->(int)
->	O
s	O
.	O
s_dbind	O
)	O
;	O
(	O
void	O
)	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
*	O
link	*(*(void))
,	O
sLAlink_arrayA	(*(int))->(int)
->	O
s	O
.	O
s_dbind	O
)	O
;	O
*	O
link	*(*(void))
=	O
(	O
void	O
*	O
)	O
(	O
fun	(*(int))->(int)
->	O
cf	O
.	O
cf_self	O
)	O
;	O
(	O
*	O
(	O
void	O
(	O
*	O
)	O
(	O
)	O
)	O
(	O
fun	(*(int))->(int)
->	O
cf	O
.	O
cf_self	O
)	O
)	O
(	O
)	O
;	O
}	O
else	O
{	O
append_link_list	((*(int))->(int),int)->(void)
(	O
sym	(*(int))->(int)
,	O
0	int
)	O
;	O
funcall	()->(int)
(	O
fun	(*(int))->(int)
)	O
;	O
}	O
}	O
void	O
call_or_link_closure	((*(int))->(int),*(*(void)),*(*(void)))->(void)
(	O
object	(*(int))->(int)
sym	(*(int))->(int)
,	O
void	O
*	O
*	O
link	*(*(void))
,	O
void	O
*	O
*	O
ptr	*(*(void))
)	O
{	O
object	(*(int))->(int)
fun	(*(int))->(int)
;	O
fun	(*(int))->(int)
=	O
sym	(*(int))->(int)
->	O
s	O
.	O
s_gfdef	O
;	O
if	O
(	O
fun	(*(int))->(int)
==	O
OBJNULL	O
)	O
{	O
FEinvalid_function	()->(int)
(	O
sym	(*(int))->(int)
)	O
;	O
return	O
;	O
}	O
if	O
(	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_cclosure	O
&&	O
(	O
fun	(*(int))->(int)
->	O
cc	O
.	O
cc_turbo	O
)	O
)	O
{	O
if	O
(	O
Rset	int
)	O
{	O
(	O
void	O
)	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
link	*(*(void))
,	O
sLAlink_arrayA	(*(int))->(int)
->	O
s	O
.	O
s_dbind	O
)	O
;	O
(	O
void	O
)	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
*	O
link	*(*(void))
,	O
sLAlink_arrayA	(*(int))->(int)
->	O
s	O
.	O
s_dbind	O
)	O
;	O
*	O
ptr	*(*(void))
=	O
(	O
void	O
*	O
)	O
fun	(*(int))->(int)
;	O
*	O
link	*(*(void))
=	O
(	O
void	O
*	O
)	O
(	O
fun	(*(int))->(int)
->	O
cf	O
.	O
cf_self	O
)	O
;	O
MMccall	()->(int)
(	O
fun	(*(int))->(int)
)	O
;	O
}	O
else	O
{	O
append_link_list	((*(int))->(int),int)->(void)
(	O
sym	(*(int))->(int)
,	O
1	int
)	O
;	O
MMccall	()->(int)
(	O
fun	(*(int))->(int)
)	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
Rset	int
==	O
0	int
)	O
funcall	()->(int)
(	O
fun	(*(int))->(int)
)	O
;	O
else	O
if	O
(	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_cfun	O
)	O
{	O
(	O
void	O
)	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
link	*(*(void))
,	O
sLAlink_arrayA	(*(int))->(int)
->	O
s	O
.	O
s_dbind	O
)	O
;	O
(	O
void	O
)	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
*	O
link	*(*(void))
,	O
sLAlink_arrayA	(*(int))->(int)
->	O
s	O
.	O
s_dbind	O
)	O
;	O
*	O
link	*(*(void))
=	O
(	O
void	O
*	O
)	O
fun	(*(int))->(int)
->	O
cf	O
.	O
cf_self	O
;	O
(	O
*	O
(	O
void	O
(	O
*	O
)	O
(	O
)	O
)	O
fun	(*(int))->(int)
->	O
cf	O
.	O
cf_self	O
)	O
(	O
)	O
;	O
}	O
else	O
{	O
append_link_list	((*(int))->(int),int)->(void)
(	O
sym	(*(int))->(int)
,	O
2	int
)	O
;	O
funcall	()->(int)
(	O
fun	(*(int))->(int)
)	O
;	O
}	O
}	O
static	O
int	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
void	O
*	O
item	*(void)
,	O
object	(*(int))->(int)
ar	(*(int))->(int)
)	O
{	O
register	O
int	O
ind	int
=	O
ar	(*(int))->(int)
->	O
ust	O
.	O
ust_fillp	O
;	O
AGAIN	O
:	O
if	O
(	O
ind	int
<	O
ar	(*(int))->(int)
->	O
ust	O
.	O
ust_dim	O
)	O
{	O
SET_ITEM	O
(	O
ar	(*(int))->(int)
,	O
ind	int
,	O
item	*(void)
)	O
;	O
ind	int
+=	O
sizeof	O
(	O
void	O
*	O
)	O
;	O
return	O
(	O
ar	(*(int))->(int)
->	O
v	O
.	O
v_fillp	O
=	O
ind	int
)	O
;	O
}	O
else	O
{	O
int	O
newdim	int
=	O
ROUND_UP_PTR	()->(int)
(	O
(	O
2	int
+	O
(	O
int	O
)	O
(	O
1.3	int
*	O
ind	int
)	O
)	O
)	O
;	O
unsigned	O
char	O
*	O
newself	*(char)
;	O
newself	*(char)
=	O
(	O
void	O
*	O
)	O
alloc_relblock	()->(int)
(	O
newdim	int
)	O
;	O
bcopy	(*(void),*(void),long)->(void)
(	O
ar	(*(int))->(int)
->	O
ust	O
.	O
ust_self	O
,	O
newself	*(char)
,	O
ind	int
)	O
;	O
ar	(*(int))->(int)
->	O
ust	O
.	O
ust_dim	O
=	O
newdim	int
;	O
ar	(*(int))->(int)
->	O
ust	O
.	O
ust_self	O
=	O
newself	*(char)
;	O
goto	O
AGAIN	O
;	O
}	O
}	O
static	O
int	O
number_unlinked	int
=	O
0	int
;	O
static	O
void	O
delete_link	(*(void),(*(int))->(int))->(void)
(	O
void	O
*	O
address	*(void)
,	O
object	(*(int))->(int)
link_ar	(*(int))->(int)
)	O
{	O
object	(*(int))->(int)
*	O
ar	(*(int))->(int)
,	O
*	O
ar_end	*((*(int))->(int))
,	O
*	O
p	*((*(int))->(int))
;	O
p	*((*(int))->(int))
=	O
0	int
;	O
ar	(*(int))->(int)
=	O
link_ar	(*(int))->(int)
->	O
v	O
.	O
v_self	O
;	O
ar_end	*((*(int))->(int))
=	O
(	O
object	(*(int))->(int)
*	O
)	O
&	O
(	O
link_ar	(*(int))->(int)
->	O
ust	O
.	O
ust_self	O
[	O
link_ar	(*(int))->(int)
->	O
v	O
.	O
v_fillp	O
]	O
)	O
;	O
while	O
(	O
ar	(*(int))->(int)
<	O
ar_end	*((*(int))->(int))
)	O
{	O
if	O
(	O
*	O
ar	(*(int))->(int)
&&	O
*	O
(	O
(	O
void	O
*	O
*	O
)	O
*	O
ar	(*(int))->(int)
)	O
==	O
address	*(void)
)	O
{	O
p	*((*(int))->(int))
=	O
(	O
object	(*(int))->(int)
*	O
)	O
*	O
ar	(*(int))->(int)
;	O
*	O
ar	(*(int))->(int)
=	O
0	int
;	O
*	O
p	*((*(int))->(int))
=	O
*	O
(	O
ar	(*(int))->(int)
+	O
1	int
)	O
;	O
number_unlinked	int
++	O
;	O
}	O
ar	(*(int))->(int)
=	O
ar	(*(int))->(int)
+	O
2	int
;	O
}	O
if	O
(	O
number_unlinked	int
>	O
40	int
)	O
link_ar	(*(int))->(int)
->	O
v	O
.	O
v_fillp	O
=	O
clean_link_array	(*(int),*(int))->(int)
(	O
link_ar	(*(int))->(int)
->	O
v	O
.	O
v_self	O
,	O
ar_end	*((*(int))->(int))
)	O
;	O
}	O
DEFUN_NEW	()->(int)
(	O
"USE-FAST-LINKS"	*(char)
,	O
object	(*(int))->(int)
,	O
fSuse_fast_links	O
,	O
SI	O
,	O
1	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	(*(int))->(int)
flag	(*(int))->(int)
,	O
...	O
)	O
,	O
"Usage: (use-fast-links {nil,t} &optional fun) turns on or off the fast linking depending on FLAG, so that things will either go faster, or turns it off so that stack information is kept.  If SYMBOL is supplied and FLAG is nil, then this function is deleted from the fast links"	*(char)
)	O
{	O
int	O
n	int
=	O
VFUN_NARGS	O
;	O
object	(*(int))->(int)
sym	(*(int))->(int)
;	O
va_list	O
ap	O
;	O
object	(*(int))->(int)
*	O
p	*((*(int))->(int))
,	O
*	O
ar	(*(int))->(int)
,	O
*	O
ar_end	*((*(int))->(int))
;	O
object	(*(int))->(int)
link_ar	(*(int))->(int)
;	O
object	(*(int))->(int)
fun	(*(int))->(int)
=	O
Cnil	O
;	O
{	O
va_start	O
(	O
ap	O
,	O
flag	(*(int))->(int)
)	O
;	O
if	O
(	O
n	int
>=	O
2	int
)	O
sym	(*(int))->(int)
=	O
va_arg	()->(int)
(	O
ap	O
,	O
object	(*(int))->(int)
)	O
;	O
else	O
goto	O
LDEFAULT2	O
;	O
goto	O
LEND_VARARG	O
;	O
LDEFAULT2	O
:	O
sym	(*(int))->(int)
=	O
Cnil	O
;	O
LEND_VARARG	O
:	O
va_end	O
(	O
ap	O
)	O
;	O
}	O
if	O
(	O
sLAlink_arrayA	(*(int))->(int)
==	O
0	int
)	O
RETURN1	()->(int)
(	O
Cnil	O
)	O
;	O
link_ar	(*(int))->(int)
=	O
sLAlink_arrayA	(*(int))->(int)
->	O
s	O
.	O
s_dbind	O
;	O
if	O
(	O
link_ar	(*(int))->(int)
==	O
Cnil	O
&&	O
flag	(*(int))->(int)
==	O
Cnil	O
)	O
RETURN1	()->(int)
(	O
Cnil	O
)	O
;	O
check_type_array	()->(int)
(	O
&	O
link_ar	(*(int))->(int)
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
link_ar	(*(int))->(int)
)	O
!=	O
t_string	O
)	O
{	O
FEerror	()->(int)
(	O
"*LINK-ARRAY* must be a string"	*(char)
,	O
0	int
)	O
;	O
}	O
ar	(*(int))->(int)
=	O
link_ar	(*(int))->(int)
->	O
v	O
.	O
v_self	O
;	O
ar_end	*((*(int))->(int))
=	O
(	O
object	(*(int))->(int)
*	O
)	O
&	O
(	O
link_ar	(*(int))->(int)
->	O
ust	O
.	O
ust_self	O
[	O
link_ar	(*(int))->(int)
->	O
v	O
.	O
v_fillp	O
]	O
)	O
;	O
switch	O
(	O
n	int
)	O
{	O
case	O
1	int
:	O
if	O
(	O
flag	(*(int))->(int)
==	O
Cnil	O
)	O
{	O
Rset	int
=	O
0	int
;	O
while	O
(	O
ar	(*(int))->(int)
<	O
ar_end	*((*(int))->(int))
)	O
{	O
p	*((*(int))->(int))
=	O
(	O
object	(*(int))->(int)
*	O
)	O
*	O
ar	(*(int))->(int)
;	O
if	O
(	O
p	*((*(int))->(int))
)	O
*	O
p	*((*(int))->(int))
=	O
(	O
ar	(*(int))->(int)
++	O
,	O
*	O
ar	(*(int))->(int)
)	O
;	O
else	O
ar	(*(int))->(int)
++	O
;	O
ar	(*(int))->(int)
++	O
;	O
}	O
link_ar	(*(int))->(int)
->	O
v	O
.	O
v_fillp	O
=	O
0	int
;	O
}	O
else	O
{	O
Rset	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
(	O
type_of	()->(int)
(	O
sym	(*(int))->(int)
)	O
==	O
t_symbol	O
)	O
)	O
fun	(*(int))->(int)
=	O
sym	(*(int))->(int)
->	O
s	O
.	O
s_gfdef	O
;	O
else	O
if	O
(	O
type_of	()->(int)
(	O
sym	(*(int))->(int)
)	O
==	O
t_cclosure	O
)	O
fun	(*(int))->(int)
=	O
sym	(*(int))->(int)
;	O
else	O
{	O
FEerror	()->(int)
(	O
"Second arg: ~a must be symbol or closure"	*(char)
,	O
0	int
,	O
sym	(*(int))->(int)
)	O
;	O
}	O
if	O
(	O
Rset	int
)	O
{	O
if	O
(	O
!	O
fun	(*(int))->(int)
)	O
RETURN1	()->(int)
(	O
Cnil	O
)	O
;	O
switch	O
(	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
)	O
{	O
case	O
t_cfun	O
:	O
case	O
t_sfun	O
:	O
case	O
t_vfun	O
:	O
case	O
t_gfun	O
:	O
case	O
t_cclosure	O
:	O
case	O
t_closure	O
:	O
case	O
t_afun	O
:	O
delete_link	(*(void),(*(int))->(int))->(void)
(	O
fun	(*(int))->(int)
->	O
cf	O
.	O
cf_self	O
,	O
link_ar	(*(int))->(int)
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
FEerror	()->(int)
(	O
"Usage: (use-fast-links {nil,t} &optional fun)"	*(char)
,	O
0	int
)	O
;	O
}	O
RETURN1	()->(int)
(	O
Cnil	O
)	O
;	O
}	O
object	(*(int))->(int)
fSuse_fast_links_2	((*(int))->(int),(*(int))->(int))->(int)
(	O
object	(*(int))->(int)
flag	(*(int))->(int)
,	O
object	(*(int))->(int)
res	(*(int))->(int)
)	O
{	O
VFUN_NARGS	O
=	O
2	int
;	O
return	O
FFN	()->(int)
(	O
fSuse_fast_links	O
)	O
(	O
flag	(*(int))->(int)
,	O
res	(*(int))->(int)
)	O
;	O
}	O
object	(*(int))->(int)
clear_compiler_properties	((*(int))->(int),(*(int))->(int))->(int)
(	O
object	(*(int))->(int)
sym	(*(int))->(int)
,	O
object	(*(int))->(int)
code	(*(int))->(int)
)	O
{	O
object	(*(int))->(int)
tem	(*(int))->(int)
;	O
extern	O
object	(*(int))->(int)
sSclear_compiler_properties	(*(int))->(int)
;	O
if	O
(	O
sSclear_compiler_properties	(*(int))->(int)
&&	O
sSclear_compiler_properties	(*(int))->(int)
->	O
s	O
.	O
s_gfdef	O
!=	O
OBJNULL	O
)	O
if	O
(	O
(	O
sSAinhibit_macro_specialA	O
&&	O
sSAinhibit_macro_specialA	O
->	O
s	O
.	O
s_dbind	O
!=	O
Cnil	O
)	O
||	O
sym	(*(int))->(int)
->	O
s	O
.	O
s_sfdef	O
==	O
NOT_SPECIAL	O
)	O
(	O
void	O
)	O
ifuncall2	()->(int)
(	O
sSclear_compiler_properties	(*(int))->(int)
,	O
sym	(*(int))->(int)
,	O
code	(*(int))->(int)
)	O
;	O
tem	(*(int))->(int)
=	O
getf	()->(int)
(	O
sym	(*(int))->(int)
->	O
s	O
.	O
s_plist	O
,	O
sStraced	O
,	O
Cnil	O
)	O
;	O
VFUN_NARGS	O
=	O
2	int
;	O
FFN	()->(int)
(	O
fSuse_fast_links	O
)	O
(	O
Cnil	O
,	O
sym	(*(int))->(int)
)	O
;	O
return	O
tem	(*(int))->(int)
!=	O
Cnil	O
?	O
tem	(*(int))->(int)
:	O
sym	(*(int))->(int)
;	O
}	O
static	O
int	O
clean_link_array	(*(int),*(int))->(int)
(	O
object	(*(int))->(int)
*	O
ar	(*(int))->(int)
,	O
object	(*(int))->(int)
*	O
ar_end	*((*(int))->(int))
)	O
{	O
int	O
i	int
=	O
0	int
;	O
object	(*(int))->(int)
*	O
orig	*((*(int))->(int))
;	O
orig	*((*(int))->(int))
=	O
ar	(*(int))->(int)
;	O
number_unlinked	int
=	O
0	int
;	O
while	O
(	O
ar	(*(int))->(int)
<	O
ar_end	*((*(int))->(int))
)	O
{	O
if	O
(	O
*	O
ar	(*(int))->(int)
)	O
{	O
orig	*((*(int))->(int))
[	O
i	int
++	O
]	O
=	O
*	O
ar	(*(int))->(int)
++	O
;	O
orig	*((*(int))->(int))
[	O
i	int
++	O
]	O
=	O
*	O
ar	(*(int))->(int)
++	O
;	O
}	O
else	O
ar	(*(int))->(int)
=	O
ar	(*(int))->(int)
+	O
2	int
;	O
}	O
return	O
(	O
i	int
*	O
sizeof	O
(	O
object	(*(int))->(int)
*	O
)	O
)	O
;	O
}	O
static	O
object	(*(int))->(int)
call_proc	((*(int))->(int),*(*(void)),int,int)->(int)
(	O
object	(*(int))->(int)
sym	(*(int))->(int)
,	O
void	O
*	O
*	O
link	*(*(void))
,	O
int	O
argd	int
,	O
va_list	O
ll	int
)	O
{	O
object	(*(int))->(int)
fun	(*(int))->(int)
;	O
int	O
nargs	int
;	O
check_type_sym	()->(int)
(	O
&	O
sym	(*(int))->(int)
)	O
;	O
fun	(*(int))->(int)
=	O
sym	(*(int))->(int)
->	O
s	O
.	O
s_gfdef	O
;	O
if	O
(	O
fun	(*(int))->(int)
&&	O
(	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_sfun	O
||	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_gfun	O
||	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_afun	O
||	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_vfun	O
)	O
&&	O
Rset	int
)	O
{	O
object	(*(int))->(int)
(	O
*	O
fn	*(()->(int))
)	O
(	O
)	O
=	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_self	O
;	O
if	O
(	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_vfun	O
)	O
{	O
nargs	int
=	O
SFUN_NARGS	()->(int)
(	O
argd	int
)	O
;	O
if	O
(	O
nargs	int
<	O
fun	(*(int))->(int)
->	O
vfn	O
.	O
vfn_minargs	O
||	O
nargs	int
>	O
fun	(*(int))->(int)
->	O
vfn	O
.	O
vfn_maxargs	O
||	O
(	O
argd	int
&	O
(	O
SFUN_ARG_TYPE_MASK	O
|	O
SFUN_RETURN_MASK	O
)	O
)	O
)	O
goto	O
WRONG_ARGS	O
;	O
if	O
(	O
(	O
VFUN_NARG_BIT	O
&	O
argd	int
)	O
==	O
0	int
)	O
{	O
VFUN_NARGS	O
=	O
nargs	int
;	O
goto	O
AFTER_LINK	O
;	O
}	O
}	O
else	O
if	O
(	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_afun	O
)	O
{	O
ufixnum	O
at	O
=	O
F_TYPES	O
(	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_argd	O
)	O
>>	O
F_TYPE_WIDTH	O
;	O
ufixnum	O
ma	O
=	O
F_MIN_ARGS	O
(	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
ufixnum	O
xa	O
=	O
F_MAX_ARGS	O
(	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
ufixnum	O
rt	O
=	O
F_RESULT_TYPE	O
(	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
nargs	int
=	O
SFUN_NARGS	()->(int)
(	O
argd	int
)	O
;	O
if	O
(	O
nargs	int
<	O
ma	O
||	O
nargs	int
>	O
xa	O
||	O
(	O
(	O
argd	int
>>	O
8	int
)	O
&	O
0x3	int
)	O
!=	O
rt	O
||	O
(	O
argd	int
>>	O
12	int
)	O
!=	O
at	O
)	O
goto	O
WRONG_ARGS	O
;	O
}	O
else	O
{	O
nargs	int
=	O
SFUN_NARGS	()->(int)
(	O
argd	int
)	O
;	O
if	O
(	O
(	O
argd	int
&	O
(	O
~	O
VFUN_NARG_BIT	O
)	O
)	O
!=	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_argd	O
)	O
goto	O
WRONG_ARGS	O
;	O
}	O
(	O
void	O
)	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
link	*(*(void))
,	O
sLAlink_arrayA	(*(int))->(int)
->	O
s	O
.	O
s_dbind	O
)	O
;	O
(	O
void	O
)	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
*	O
link	*(*(void))
,	O
sLAlink_arrayA	(*(int))->(int)
->	O
s	O
.	O
s_dbind	O
)	O
;	O
*	O
link	*(*(void))
=	O
(	O
void	O
*	O
)	O
fn	*(()->(int))
;	O
AFTER_LINK	O
:	O
{	O
object	(*(int))->(int)
*	O
new	*((*(int))->(int))
;	O
COERCE_VA_LIST	()->(int)
(	O
new	*((*(int))->(int))
,	O
ll	int
,	O
nargs	int
)	O
;	O
return	O
(	O
c_apply_n_fun	()->(int)
(	O
fun	(*(int))->(int)
,	O
nargs	int
,	O
new	*((*(int))->(int))
)	O
)	O
;	O
}	O
}	O
else	O
WRONG_ARGS	O
:	O
{	O
object	(*(int))->(int)
fun	(*(int))->(int)
;	O
register	O
object	(*(int))->(int)
*	O
base	*((*(int))->(int))
;	O
enum	O
ftype	O
result_type	enum
;	O
int	O
i	int
;	O
append_link_list	((*(int))->(int),int)->(void)
(	O
sym	(*(int))->(int)
,	O
3	int
)	O
;	O
fun	(*(int))->(int)
=	O
type_of	()->(int)
(	O
sym	(*(int))->(int)
)	O
==	O
t_symbol	O
?	O
symbol_function	()->(int)
(	O
sym	(*(int))->(int)
)	O
:	O
sym	(*(int))->(int)
;	O
vs_base	O
=	O
base	*((*(int))->(int))
=	O
vs_top	O
;	O
if	O
(	O
fun	(*(int))->(int)
==	O
OBJNULL	O
)	O
FEinvalid_function	()->(int)
(	O
sym	(*(int))->(int)
)	O
;	O
nargs	int
=	O
SFUN_NARGS	()->(int)
(	O
argd	int
)	O
;	O
result_type	enum
=	O
SFUN_RETURN_TYPE	()->(int)
(	O
argd	int
)	O
;	O
SFUN_START_ARG_TYPES	()->(int)
(	O
argd	int
)	O
;	O
if	O
(	O
argd	int
==	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nargs	int
;	O
i	int
++	O
)	O
vs_push	()->(int)
(	O
va_arg	()->(int)
(	O
ll	int
,	O
object	(*(int))->(int)
)	O
)	O
;	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nargs	int
;	O
i	int
++	O
)	O
vs_push	()->(int)
(	O
(	O
(	O
SFUN_NEXT_TYPE	()->(int)
(	O
argd	int
)	O
)	O
==	O
f_object	O
?	O
va_arg	()->(int)
(	O
ll	int
,	O
object	(*(int))->(int)
)	O
:	O
make_fixnum	()->(int)
(	O
va_arg	()->(int)
(	O
ll	int
,	O
fixnum	O
)	O
)	O
)	O
)	O
;	O
vs_check	O
;	O
funcall	()->(int)
(	O
fun	(*(int))->(int)
)	O
;	O
vs_top	O
=	O
base	*((*(int))->(int))
;	O
return	O
(	O
(	O
result_type	enum
==	O
f_object	O
?	O
vs_base	O
[	O
0	int
]	O
:	O
(	O
object	(*(int))->(int)
)	O
fix	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
)	O
;	O
}	O
}	O
object	(*(int))->(int)
call_proc_new	((*(int))->(int),*(*(void)),int,(*(int))->(int),int)->(int)
(	O
object	(*(int))->(int)
sym	(*(int))->(int)
,	O
void	O
*	O
*	O
link	*(*(void))
,	O
int	O
argd	int
,	O
object	(*(int))->(int)
first	(*(int))->(int)
,	O
va_list	O
ll	int
)	O
{	O
object	(*(int))->(int)
fun	(*(int))->(int)
;	O
int	O
nargs	int
;	O
check_type_sym	()->(int)
(	O
&	O
sym	(*(int))->(int)
)	O
;	O
fun	(*(int))->(int)
=	O
sym	(*(int))->(int)
->	O
s	O
.	O
s_gfdef	O
;	O
if	O
(	O
fun	(*(int))->(int)
&&	O
(	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_sfun	O
||	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_gfun	O
||	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_afun	O
||	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_vfun	O
)	O
&&	O
Rset	int
)	O
{	O
object	(*(int))->(int)
(	O
*	O
fn	*(()->(int))
)	O
(	O
)	O
=	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_self	O
;	O
if	O
(	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_vfun	O
)	O
{	O
nargs	int
=	O
SFUN_NARGS	()->(int)
(	O
argd	int
)	O
;	O
if	O
(	O
nargs	int
<	O
fun	(*(int))->(int)
->	O
vfn	O
.	O
vfn_minargs	O
||	O
nargs	int
>	O
fun	(*(int))->(int)
->	O
vfn	O
.	O
vfn_maxargs	O
||	O
(	O
argd	int
&	O
(	O
SFUN_ARG_TYPE_MASK	O
|	O
SFUN_RETURN_MASK	O
)	O
)	O
)	O
goto	O
WRONG_ARGS	O
;	O
if	O
(	O
(	O
VFUN_NARG_BIT	O
&	O
argd	int
)	O
==	O
0	int
)	O
{	O
VFUN_NARGS	O
=	O
nargs	int
;	O
goto	O
AFTER_LINK	O
;	O
}	O
}	O
else	O
if	O
(	O
type_of	()->(int)
(	O
fun	(*(int))->(int)
)	O
==	O
t_afun	O
)	O
{	O
ufixnum	O
at	O
=	O
F_TYPES	O
(	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_argd	O
)	O
>>	O
F_TYPE_WIDTH	O
;	O
ufixnum	O
ma	O
=	O
F_MIN_ARGS	O
(	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
ufixnum	O
xa	O
=	O
F_MAX_ARGS	O
(	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
ufixnum	O
rt	O
=	O
F_RESULT_TYPE	O
(	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_argd	O
)	O
;	O
nargs	int
=	O
SFUN_NARGS	()->(int)
(	O
argd	int
)	O
;	O
if	O
(	O
nargs	int
<	O
ma	O
||	O
nargs	int
>	O
xa	O
||	O
(	O
(	O
argd	int
>>	O
8	int
)	O
&	O
0x3	int
)	O
!=	O
rt	O
||	O
(	O
argd	int
>>	O
12	int
)	O
!=	O
at	O
)	O
goto	O
WRONG_ARGS	O
;	O
}	O
else	O
{	O
nargs	int
=	O
SFUN_NARGS	()->(int)
(	O
argd	int
)	O
;	O
if	O
(	O
(	O
argd	int
&	O
(	O
~	O
VFUN_NARG_BIT	O
)	O
)	O
!=	O
fun	(*(int))->(int)
->	O
sfn	O
.	O
sfn_argd	O
)	O
goto	O
WRONG_ARGS	O
;	O
}	O
(	O
void	O
)	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
link	*(*(void))
,	O
sLAlink_arrayA	(*(int))->(int)
->	O
s	O
.	O
s_dbind	O
)	O
;	O
(	O
void	O
)	O
vpush_extend	(*(void),(*(int))->(int))->(int)
(	O
*	O
link	*(*(void))
,	O
sLAlink_arrayA	(*(int))->(int)
->	O
s	O
.	O
s_dbind	O
)	O
;	O
*	O
link	*(*(void))
=	O
(	O
void	O
*	O
)	O
fn	*(()->(int))
;	O
AFTER_LINK	O
:	O
{	O
object	(*(int))->(int)
*	O
new	*((*(int))->(int))
;	O
COERCE_VA_LIST_NEW	()->(int)
(	O
new	*((*(int))->(int))
,	O
first	(*(int))->(int)
,	O
ll	int
,	O
nargs	int
)	O
;	O
return	O
(	O
c_apply_n_fun	()->(int)
(	O
fun	(*(int))->(int)
,	O
nargs	int
,	O
new	*((*(int))->(int))
)	O
)	O
;	O
}	O
}	O
else	O
WRONG_ARGS	O
:	O
{	O
object	(*(int))->(int)
fun	(*(int))->(int)
;	O
register	O
object	(*(int))->(int)
*	O
base	*((*(int))->(int))
;	O
enum	O
ftype	O
result_type	enum
;	O
int	O
i	int
;	O
append_link_list	((*(int))->(int),int)->(void)
(	O
sym	(*(int))->(int)
,	O
4	int
)	O
;	O
fun	(*(int))->(int)
=	O
type_of	()->(int)
(	O
sym	(*(int))->(int)
)	O
==	O
t_symbol	O
?	O
symbol_function	()->(int)
(	O
sym	(*(int))->(int)
)	O
:	O
sym	(*(int))->(int)
;	O
vs_base	O
=	O
base	*((*(int))->(int))
=	O
vs_top	O
;	O
if	O
(	O
fun	(*(int))->(int)
==	O
OBJNULL	O
)	O
FEinvalid_function	()->(int)
(	O
sym	(*(int))->(int)
)	O
;	O
nargs	int
=	O
SFUN_NARGS	()->(int)
(	O
argd	int
)	O
;	O
result_type	enum
=	O
SFUN_RETURN_TYPE	()->(int)
(	O
argd	int
)	O
;	O
SFUN_START_ARG_TYPES	()->(int)
(	O
argd	int
)	O
;	O
if	O
(	O
argd	int
==	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nargs	int
;	O
i	int
++	O
)	O
vs_push	()->(int)
(	O
i	int
?	O
va_arg	()->(int)
(	O
ll	int
,	O
object	(*(int))->(int)
)	O
:	O
first	(*(int))->(int)
)	O
;	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nargs	int
;	O
i	int
++	O
)	O
{	O
object	(*(int))->(int)
_xx	(*(int))->(int)
;	O
if	O
(	O
SFUN_NEXT_TYPE	()->(int)
(	O
argd	int
)	O
==	O
f_object	O
)	O
_xx	(*(int))->(int)
=	O
i	int
?	O
va_arg	()->(int)
(	O
ll	int
,	O
object	(*(int))->(int)
)	O
:	O
first	(*(int))->(int)
;	O
else	O
{	O
long	O
_yy	long
;	O
_yy	long
=	O
i	int
?	O
va_arg	()->(int)
(	O
ll	int
,	O
fixnum	O
)	O
:	O
(	O
fixnum	O
)	O
first	(*(int))->(int)
;	O
_xx	(*(int))->(int)
=	O
make_fixnum	()->(int)
(	O
_yy	long
)	O
;	O
}	O
vs_push	()->(int)
(	O
_xx	(*(int))->(int)
)	O
;	O
}	O
vs_check	O
;	O
funcall	()->(int)
(	O
fun	(*(int))->(int)
)	O
;	O
vs_top	O
=	O
base	*((*(int))->(int))
;	O
return	O
(	O
(	O
result_type	enum
==	O
f_object	O
?	O
vs_base	O
[	O
0	int
]	O
:	O
(	O
object	(*(int))->(int)
)	O
fix	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
)	O
)	O
;	O
}	O
}	O
object	(*(int))->(int)
call_vproc_new	((*(int))->(int),*(void),(*(int))->(int),int)->(int)
(	O
object	(*(int))->(int)
sym	(*(int))->(int)
,	O
void	O
*	O
link	*(*(void))
,	O
object	(*(int))->(int)
first	(*(int))->(int)
,	O
va_list	O
ll	int
)	O
{	O
return	O
call_proc_new	((*(int))->(int),*(*(void)),int,(*(int))->(int),int)->(int)
(	O
sym	(*(int))->(int)
,	O
link	*(*(void))
,	O
VFUN_NARGS	O
|	O
VFUN_NARG_BIT	O
,	O
first	(*(int))->(int)
,	O
ll	int
)	O
;	O
}	O
static	O
object	(*(int))->(int)
mcall_proc0	((*(int))->(int),*(void),int)->(int)
(	O
object	(*(int))->(int)
sym	(*(int))->(int)
,	O
void	O
*	O
link	*(*(void))
,	O
int	O
argd	int
,	O
...	O
)	O
{	O
object	(*(int))->(int)
res	(*(int))->(int)
;	O
va_list	O
ap	O
;	O
va_start	O
(	O
ap	O
,	O
argd	int
)	O
;	O
res	(*(int))->(int)
=	O
call_proc	((*(int))->(int),*(*(void)),int,int)->(int)
(	O
sym	(*(int))->(int)
,	O
link	*(*(void))
,	O
argd	int
,	O
ap	O
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
return	O
res	(*(int))->(int)
;	O
}	O
object	(*(int))->(int)
call_proc0	((*(int))->(int),*(void))->(int)
(	O
object	(*(int))->(int)
sym	(*(int))->(int)
,	O
void	O
*	O
link	*(*(void))
)	O
{	O
return	O
mcall_proc0	((*(int))->(int),*(void),int)->(int)
(	O
sym	(*(int))->(int)
,	O
link	*(*(void))
,	O
0	int
)	O
;	O
}	O
object	(*(int))->(int)
ifuncall	((*(int))->(int),int)->(int)
(	O
object	(*(int))->(int)
sym	(*(int))->(int)
,	O
int	O
n	int
,	O
...	O
)	O
{	O
va_list	O
ap	O
;	O
int	O
i	int
;	O
object	(*(int))->(int)
*	O
old_vs_base	*((*(int))->(int))
;	O
object	(*(int))->(int)
*	O
old_vs_top	*((*(int))->(int))
;	O
object	(*(int))->(int)
x	(*(int))->(int)
;	O
old_vs_base	*((*(int))->(int))
=	O
vs_base	O
;	O
old_vs_top	*((*(int))->(int))
=	O
vs_top	O
;	O
vs_base	O
=	O
old_vs_top	*((*(int))->(int))
;	O
vs_top	O
=	O
old_vs_top	*((*(int))->(int))
+	O
n	int
;	O
vs_check	O
;	O
va_start	O
(	O
ap	O
,	O
n	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
old_vs_top	*((*(int))->(int))
[	O
i	int
]	O
=	O
va_arg	()->(int)
(	O
ap	O
,	O
object	(*(int))->(int)
)	O
;	O
va_end	O
(	O
ap	O
)	O
;	O
if	O
(	O
type_of	()->(int)
(	O
sym	(*(int))->(int)
->	O
s	O
.	O
s_gfdef	O
)	O
==	O
t_cfun	O
)	O
(	O
*	O
(	O
sym	(*(int))->(int)
->	O
s	O
.	O
s_gfdef	O
)	O
->	O
cf	O
.	O
cf_self	O
)	O
(	O
)	O
;	O
else	O
super_funcall	()->(int)
(	O
sym	(*(int))->(int)
)	O
;	O
x	(*(int))->(int)
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_top	O
=	O
old_vs_top	*((*(int))->(int))
;	O
vs_base	O
=	O
old_vs_base	*((*(int))->(int))
;	O
return	O
(	O
x	(*(int))->(int)
)	O
;	O
}	O
int	O
clear_stack	(*((*(int))->(int)),*((*(int))->(int)))->(int)
(	O
object	(*(int))->(int)
*	O
beg	*((*(int))->(int))
,	O
object	(*(int))->(int)
*	O
limit	*((*(int))->(int))
)	O
{	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
++	O
beg	*((*(int))->(int))
<	O
limit	*((*(int))->(int))
)	O
{	O
if	O
(	O
*	O
beg	*((*(int))->(int))
==	O
0	int
)	O
i	int
++	O
;	O
if	O
(	O
i	int
>	O
FRESH	int
)	O
return	O
0	int
;	O
;	O
*	O
beg	*((*(int))->(int))
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
object	(*(int))->(int)
FFN	()->(int)
(	O
set_mv	int
)	O
(	O
int	O
i	int
,	O
object	(*(int))->(int)
val	(*(int))->(int)
)	O
{	O
if	O
(	O
i	int
>=	O
(	O
sizeof	O
(	O
MVloc	O
)	O
/	O
sizeof	O
(	O
object	(*(int))->(int)
)	O
)	O
)	O
FEerror	()->(int)
(	O
"Bad mv index"	*(char)
,	O
0	int
)	O
;	O
return	O
(	O
MVloc	O
[	O
i	int
]	O
=	O
val	(*(int))->(int)
)	O
;	O
}	O
static	O
object	(*(int))->(int)
FFN	()->(int)
(	O
mv_ref	int
)	O
(	O
unsigned	O
int	O
i	int
)	O
{	O
object	(*(int))->(int)
x	(*(int))->(int)
;	O
if	O
(	O
i	int
>=	O
(	O
sizeof	O
(	O
MVloc	O
)	O
/	O
sizeof	O
(	O
object	(*(int))->(int)
)	O
)	O
)	O
FEerror	()->(int)
(	O
"Bad mv index"	*(char)
,	O
0	int
)	O
;	O
x	(*(int))->(int)
=	O
MVloc	O
[	O
i	int
]	O
;	O
return	O
x	(*(int))->(int)
;	O
}	O
DEF_ORDINARY	()->(int)
(	O
"CDEFN"	*(char)
,	O
sScdefn	int
,	O
SI	O
,	O
""	*(char)
)	O
;	O
DEFVAR	()->(int)
(	O
"*LINK-ARRAY*"	*(char)
,	O
sLAlink_arrayA	(*(int))->(int)
,	O
LISP	O
,	O
Cnil	O
,	O
""	*(char)
)	O
;	O
void	O
gcl_init_links	()->(void)
(	O
void	O
)	O
{	O
make_si_sfun	()->(int)
(	O
"SET-MV"	*(char)
,	O
set_mv	int
,	O
ARGTYPE2	()->(int)
(	O
f_fixnum	O
,	O
f_object	O
)	O
|	O
RESTYPE	()->(int)
(	O
f_object	O
)	O
)	O
;	O
make_si_sfun	()->(int)
(	O
"MV-REF"	*(char)
,	O
mv_ref	int
,	O
ARGTYPE1	()->(int)
(	O
f_fixnum	O
)	O
|	O
RESTYPE	()->(int)
(	O
f_object	O
)	O
)	O
;	O
gcl_init_xdrfuns	()->(int)
(	O
)	O
;	O
}	O
