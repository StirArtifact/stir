G_GNUC_IDN2_ATTRIBUTE_PURE	O
static	O
int	O
_isNFC	(*(int),long)->(int)
(	O
uint32_t	int
*	O
label	*(int)
,	O
size_t	long
len	long
)	O
{	O
int	O
lastCanonicalClass	int
=	O
0	int
;	O
int	O
result	int
=	O
1	int
;	O
size_t	long
it	long
;	O
for	O
(	O
it	long
=	O
0	int
;	O
it	long
<	O
len	long
;	O
it	long
++	O
)	O
{	O
uint32_t	int
ch	int
=	O
label	*(int)
[	O
it	long
]	O
;	O
if	O
(	O
ch	int
>=	O
0x10000	int
)	O
it	long
++	O
;	O
int	O
canonicalClass	int
=	O
uc_combining_class	(int)->(int)
(	O
ch	int
)	O
;	O
if	O
(	O
lastCanonicalClass	int
>	O
canonicalClass	int
&&	O
canonicalClass	int
!=	O
0	int
)	O
return	O
0	int
;	O
NFCQCMap	struct(int,int,char)
*	O
map	*(struct(int,short,int,int,int))
=	O
get_nfcqc_map	(int)->(*(struct(int,int,char)))
(	O
ch	int
)	O
;	O
if	O
(	O
map	*(struct(int,short,int,int,int))
)	O
{	O
if	O
(	O
map	*(struct(int,short,int,int,int))
->	O
check	char
)	O
return	O
0	int
;	O
result	int
=	O
-	O
1	int
;	O
}	O
lastCanonicalClass	int
=	O
canonicalClass	int
;	O
}	O
return	O
result	int
;	O
}	O
int	O
_idn2_u8_to_u32_nfc	(*(char),long,*(*(int)),*(long),int)->(int)
(	O
const	O
uint8_t	char
*	O
src	*(char)
,	O
size_t	long
srclen	long
,	O
uint32_t	int
*	O
*	O
out	*(int)
,	O
size_t	long
*	O
outlen	*(long)
,	O
int	O
nfc	int
)	O
{	O
uint32_t	int
*	O
p	*(int)
;	O
size_t	long
plen	long
;	O
p	*(int)
=	O
u8_to_u32	(*(char),long,*(int),*(long))->(*(int))
(	O
src	*(char)
,	O
srclen	long
,	O
NULL	O
,	O
&	O
plen	long
)	O
;	O
if	O
(	O
p	*(int)
==	O
NULL	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOMEM	int
)	O
return	O
IDN2_MALLOC	int
;	O
return	O
IDN2_ENCODING_ERROR	int
;	O
}	O
if	O
(	O
nfc	int
&&	O
!	O
_isNFC	(*(int),long)->(int)
(	O
p	*(int)
,	O
plen	long
)	O
)	O
{	O
size_t	long
tmplen	long
;	O
uint32_t	int
*	O
tmp	*(int)
=	O
u32_normalize	(*(struct),*(int),long,*(int),*(long))->(*(int))
(	O
UNINORM_NFC	O
,	O
p	*(int)
,	O
plen	long
,	O
NULL	O
,	O
&	O
tmplen	long
)	O
;	O
free	(*(void))->(void)
(	O
p	*(int)
)	O
;	O
if	O
(	O
tmp	*(int)
==	O
NULL	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOMEM	int
)	O
return	O
IDN2_MALLOC	int
;	O
return	O
IDN2_NFC	int
;	O
}	O
p	*(int)
=	O
tmp	*(int)
;	O
plen	long
=	O
tmplen	long
;	O
}	O
*	O
out	*(int)
=	O
p	*(int)
;	O
*	O
outlen	*(long)
=	O
plen	long
;	O
return	O
IDN2_OK	int
;	O
}	O
bool	bool
_idn2_ascii_p	(*(char),long)->(bool)
(	O
const	O
uint8_t	char
*	O
src	*(char)
,	O
size_t	long
srclen	long
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
srclen	long
;	O
i	long
++	O
)	O
if	O
(	O
src	*(char)
[	O
i	long
]	O
>=	O
0x80	int
)	O
return	O
false	int
;	O
return	O
true	int
;	O
}	O
int	O
_idn2_label_test	(int,*(int),long)->(int)
(	O
int	O
what	int
,	O
const	O
uint32_t	int
*	O
label	*(int)
,	O
size_t	long
llen	long
)	O
{	O
if	O
(	O
what	int
&	O
TEST_NFC	int
)	O
{	O
size_t	long
plen	long
;	O
uint32_t	int
*	O
p	*(int)
=	O
u32_normalize	(*(struct),*(int),long,*(int),*(long))->(*(int))
(	O
UNINORM_NFC	O
,	O
label	*(int)
,	O
llen	long
,	O
NULL	O
,	O
&	O
plen	long
)	O
;	O
int	O
ok	int
;	O
if	O
(	O
p	*(int)
==	O
NULL	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOMEM	int
)	O
return	O
IDN2_MALLOC	int
;	O
return	O
IDN2_NFC	int
;	O
}	O
ok	int
=	O
llen	long
==	O
plen	long
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
label	*(int)
,	O
p	*(int)
,	O
plen	long
*	O
sizeof	O
(	O
*	O
label	*(int)
)	O
)	O
==	O
0	int
;	O
free	(*(void))->(void)
(	O
p	*(int)
)	O
;	O
if	O
(	O
!	O
ok	int
)	O
return	O
IDN2_NOT_NFC	int
;	O
}	O
if	O
(	O
what	int
&	O
TEST_2HYPHEN	int
)	O
{	O
if	O
(	O
llen	long
>=	O
4	int
&&	O
label	*(int)
[	O
2	int
]	O
==	O
'-'	O
&&	O
label	*(int)
[	O
3	int
]	O
==	O
'-'	O
)	O
return	O
IDN2_2HYPHEN	int
;	O
}	O
if	O
(	O
what	int
&	O
TEST_HYPHEN_STARTEND	int
)	O
{	O
if	O
(	O
llen	long
>	O
0	int
&&	O
(	O
label	*(int)
[	O
0	int
]	O
==	O
'-'	O
||	O
label	*(int)
[	O
llen	long
-	O
1	int
]	O
==	O
'-'	O
)	O
)	O
return	O
IDN2_HYPHEN_STARTEND	int
;	O
}	O
if	O
(	O
what	int
&	O
TEST_LEADING_COMBINING	int
)	O
{	O
if	O
(	O
llen	long
>	O
0	int
&&	O
uc_is_general_category	(int,struct(int,int,union(*(void),*((int,int)->(bool)))))->(bool)
(	O
label	*(int)
[	O
0	int
]	O
,	O
UC_CATEGORY_M	struct(int,int,union(*(void),*((int,int)->(bool))))
)	O
)	O
return	O
IDN2_LEADING_COMBINING	int
;	O
}	O
if	O
(	O
what	int
&	O
TEST_DISALLOWED	int
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
llen	long
;	O
i	long
++	O
)	O
if	O
(	O
_idn2_disallowed_p	(int)->(int)
(	O
label	*(int)
[	O
i	long
]	O
)	O
)	O
{	O
if	O
(	O
(	O
what	int
&	O
(	O
TEST_TRANSITIONAL	int
|	O
TEST_NONTRANSITIONAL	int
)	O
)	O
&&	O
(	O
what	int
&	O
TEST_ALLOW_STD3_DISALLOWED	int
)	O
)	O
{	O
IDNAMap	struct(int,short,int,int,int)
map	*(struct(int,short,int,int,int))
;	O
get_idna_map	(int,*(struct(int,short,int,int,int)))->(int)
(	O
label	*(int)
[	O
i	long
]	O
,	O
&	O
map	*(struct(int,short,int,int,int))
)	O
;	O
if	O
(	O
map_is	(*(struct(int,short,int,int,int)),int)->(int)
(	O
&	O
map	*(struct(int,short,int,int,int))
,	O
TR46_FLG_DISALLOWED_STD3_VALID	int
)	O
||	O
map_is	(*(struct(int,short,int,int,int)),int)->(int)
(	O
&	O
map	*(struct(int,short,int,int,int))
,	O
TR46_FLG_DISALLOWED_STD3_MAPPED	int
)	O
)	O
continue	O
;	O
}	O
return	O
IDN2_DISALLOWED	int
;	O
}	O
}	O
if	O
(	O
what	int
&	O
TEST_CONTEXTJ	int
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
llen	long
;	O
i	long
++	O
)	O
if	O
(	O
_idn2_contextj_p	(int)->(int)
(	O
label	*(int)
[	O
i	long
]	O
)	O
)	O
return	O
IDN2_CONTEXTJ	int
;	O
}	O
if	O
(	O
what	int
&	O
TEST_CONTEXTJ_RULE	int
)	O
{	O
size_t	long
i	long
;	O
int	O
rc	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
llen	long
;	O
i	long
++	O
)	O
{	O
rc	int
=	O
_idn2_contextj_rule	(*(int),long,long)->(int)
(	O
label	*(int)
,	O
llen	long
,	O
i	long
)	O
;	O
if	O
(	O
rc	int
!=	O
IDN2_OK	int
)	O
return	O
rc	int
;	O
}	O
}	O
if	O
(	O
what	int
&	O
TEST_CONTEXTO	int
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
llen	long
;	O
i	long
++	O
)	O
if	O
(	O
_idn2_contexto_p	(int)->(int)
(	O
label	*(int)
[	O
i	long
]	O
)	O
)	O
return	O
IDN2_CONTEXTO	int
;	O
}	O
if	O
(	O
what	int
&	O
TEST_CONTEXTO_WITH_RULE	int
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
llen	long
;	O
i	long
++	O
)	O
if	O
(	O
_idn2_contexto_p	(int)->(int)
(	O
label	*(int)
[	O
i	long
]	O
)	O
&&	O
!	O
_idn2_contexto_with_rule	(int)->(bool)
(	O
label	*(int)
[	O
i	long
]	O
)	O
)	O
return	O
IDN2_CONTEXTO_NO_RULE	int
;	O
}	O
if	O
(	O
what	int
&	O
TEST_CONTEXTO_RULE	int
)	O
{	O
size_t	long
i	long
;	O
int	O
rc	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
llen	long
;	O
i	long
++	O
)	O
{	O
rc	int
=	O
_idn2_contexto_rule	(*(int),long,long)->(int)
(	O
label	*(int)
,	O
llen	long
,	O
i	long
)	O
;	O
if	O
(	O
rc	int
!=	O
IDN2_OK	int
)	O
return	O
rc	int
;	O
}	O
}	O
if	O
(	O
what	int
&	O
TEST_UNASSIGNED	int
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
llen	long
;	O
i	long
++	O
)	O
if	O
(	O
_idn2_unassigned_p	(int)->(int)
(	O
label	*(int)
[	O
i	long
]	O
)	O
)	O
return	O
IDN2_UNASSIGNED	int
;	O
}	O
if	O
(	O
what	int
&	O
TEST_BIDI	int
)	O
{	O
int	O
rc	int
=	O
_idn2_bidi	(*(int),long)->(int)
(	O
label	*(int)
,	O
llen	long
)	O
;	O
if	O
(	O
rc	int
!=	O
IDN2_OK	int
)	O
return	O
rc	int
;	O
}	O
if	O
(	O
what	int
&	O
(	O
TEST_TRANSITIONAL	int
|	O
TEST_NONTRANSITIONAL	int
)	O
)	O
{	O
size_t	long
i	long
;	O
int	O
transitional	int
=	O
what	int
&	O
TEST_TRANSITIONAL	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
llen	long
;	O
i	long
++	O
)	O
if	O
(	O
label	*(int)
[	O
i	long
]	O
==	O
0x002E	int
)	O
return	O
IDN2_DOT_IN_LABEL	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
llen	long
;	O
i	long
++	O
)	O
{	O
IDNAMap	struct(int,short,int,int,int)
map	*(struct(int,short,int,int,int))
;	O
get_idna_map	(int,*(struct(int,short,int,int,int)))->(int)
(	O
label	*(int)
[	O
i	long
]	O
,	O
&	O
map	*(struct(int,short,int,int,int))
)	O
;	O
if	O
(	O
map_is	(*(struct(int,short,int,int,int)),int)->(int)
(	O
&	O
map	*(struct(int,short,int,int,int))
,	O
TR46_FLG_VALID	int
)	O
||	O
(	O
!	O
transitional	int
&&	O
map_is	(*(struct(int,short,int,int,int)),int)->(int)
(	O
&	O
map	*(struct(int,short,int,int,int))
,	O
TR46_FLG_DEVIATION	int
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
what	int
&	O
TEST_ALLOW_STD3_DISALLOWED	int
&&	O
(	O
map_is	(*(struct(int,short,int,int,int)),int)->(int)
(	O
&	O
map	*(struct(int,short,int,int,int))
,	O
TR46_FLG_DISALLOWED_STD3_VALID	int
)	O
||	O
map_is	(*(struct(int,short,int,int,int)),int)->(int)
(	O
&	O
map	*(struct(int,short,int,int,int))
,	O
TR46_FLG_DISALLOWED_STD3_MAPPED	int
)	O
)	O
)	O
continue	O
;	O
return	O
transitional	int
?	O
IDN2_INVALID_TRANSITIONAL	int
:	O
IDN2_INVALID_NONTRANSITIONAL	int
;	O
}	O
}	O
return	O
IDN2_OK	int
;	O
}	O
