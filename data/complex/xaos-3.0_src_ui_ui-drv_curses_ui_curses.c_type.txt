static	O
int	O
width	float
=	O
640	int
,	O
height	float
=	O
480	int
;	O
static	O
int	O
currentbuff	int
=	O
0	int
;	O
static	O
int	O
ncolors	int
=	O
0	int
;	O
static	O
int	O
buttons	int
,	O
mousex	int
,	O
mousey	int
,	O
keys	int
;	O
static	O
int	O
supportedon	array(int)
[	O
NATTRS	int
]	O
,	O
supportedoff	array(int)
[	O
NATTRS	int
]	O
;	O
static	O
char	O
*	O
buffers	array(*(char))
[	O
4	int
]	O
;	O
static	O
int	O
palette	*(array(char))
;	O
static	O
int	O
resized	int
,	O
iswaiting	int
;	O
static	O
int	O
fontwidth	int
;	O
static	O
int	O
rotation	int
;	O
static	O
jmp_buf	array(struct(array(long),int,struct(array(long))))
buf	array(struct(array(long),int,struct(array(long))))
;	O
static	O
void	O
curses_print	(int,int,*(char))->(void)
(	O
int	O
x	int
,	O
int	O
y	int
,	O
char	O
*	O
text	*(*(char))
)	O
{	O
mvprintw	(int,int,*(char))->(int)
(	O
y	int
/	O
2	int
,	O
x	int
/	O
2	int
,	O
text	*(*(char))
)	O
;	O
}	O
static	O
void	O
curses_refresh	()->(void)
(	O
void	O
)	O
{	O
refresh	()->(int)
(	O
)	O
;	O
}	O
const	O
char	O
*	O
tags	array(*(char))
[	O
NATTRS	int
-	O
1	int
]	O
=	O
{	O
"<FONT COLOR=\"808080\">"	*(char)
,	O
"<B><FONT COLOR=\"ffffff\">"	*(char)
,	O
"<A HREF=A>"	*(char)
,	O
"<B>"	*(char)
,	O
}	O
;	O
const	O
char	O
*	O
endtags	array(*(char))
[	O
NATTRS	int
-	O
1	int
]	O
=	O
{	O
"</FONT>"	*(char)
,	O
"</FONT></B>"	*(char)
,	O
"</A>"	*(char)
,	O
"</B>"	*(char)
,	O
}	O
;	O
char	O
*	O
writetxt	()->(*(char))
(	O
void	O
)	O
{	O
static	O
char	O
name	*(char)
[	O
256	int
]	O
;	O
static	O
int	O
nimage	int
=	O
0	int
;	O
int	O
x	int
,	O
y	int
,	O
c	int
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
FILE	struct
*	O
f	*(struct)
;	O
do	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
"fract%i.txt"	*(char)
,	O
nimage	int
++	O
)	O
;	O
}	O
while	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
name	*(char)
,	O
&	O
sb	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
!=	O
-	O
1	int
)	O
;	O
f	*(struct)
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
name	*(char)
,	O
"wt"	*(char)
)	O
;	O
nodelay	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
FALSE	int
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
0	int
,	O
0	int
,	O
"Select attribute encoding:          "	*(char)
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
1	int
,	O
0	int
,	O
"1 - for more and less               "	*(char)
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
2	int
,	O
0	int
,	O
"2 - html                            "	*(char)
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
3	int
,	O
0	int
,	O
"3 - ansi escape sequences           "	*(char)
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
while	O
(	O
(	O
c	int
=	O
tolower	(int)->(int)
(	O
getch	()->(int)
(	O
)	O
)	O
)	O
<	O
'1'	O
||	O
c	int
>	O
'3'	O
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'1'	O
:	O
for	O
(	O
y	int
=	O
0	int
;	O
y	int
<	O
height	float
;	O
y	int
++	O
)	O
{	O
for	O
(	O
x	int
=	O
0	int
;	O
x	int
<	O
width	float
;	O
x	int
++	O
)	O
{	O
if	O
(	O
buffers	array(*(char))
[	O
3	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
==	O
BOLD	int
||	O
buffers	array(*(char))
[	O
3	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
==	O
BOLDFONT	int
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buffers	array(*(char))
[	O
2	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
,	O
f	*(struct)
)	O
;	O
if	O
(	O
buffers	array(*(char))
[	O
2	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
!=	O
' '	O
)	O
{	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
8	int
,	O
f	*(struct)
)	O
;	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buffers	array(*(char))
[	O
2	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
,	O
f	*(struct)
)	O
;	O
}	O
}	O
else	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buffers	array(*(char))
[	O
2	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
,	O
f	*(struct)
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
f	*(struct)
)	O
;	O
}	O
break	O
;	O
case	O
'3'	O
:	O
{	O
int	O
lastmode	int
=	O
NORMAL	int
,	O
mode	int
;	O
for	O
(	O
y	int
=	O
0	int
;	O
y	int
<	O
height	float
;	O
y	int
++	O
)	O
{	O
for	O
(	O
x	int
=	O
0	int
;	O
x	int
<	O
width	float
;	O
x	int
++	O
)	O
{	O
mode	int
=	O
buffers	array(*(char))
[	O
3	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
;	O
if	O
(	O
mode	int
!=	O
lastmode	int
)	O
{	O
if	O
(	O
lastmode	int
!=	O
NORMAL	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"%c[0;10m"	*(char)
,	O
27	int
)	O
;	O
switch	O
(	O
mode	int
)	O
{	O
case	O
BOLD	int
:	O
case	O
BOLDFONT	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"%c[1m"	*(char)
,	O
27	int
)	O
;	O
break	O
;	O
case	O
REVERSE	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"%c[7m"	*(char)
,	O
27	int
)	O
;	O
break	O
;	O
case	O
DIM	int
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"%c[8m"	*(char)
,	O
27	int
)	O
;	O
break	O
;	O
}	O
lastmode	int
=	O
mode	int
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buffers	array(*(char))
[	O
2	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
,	O
f	*(struct)
)	O
;	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
f	*(struct)
)	O
;	O
}	O
if	O
(	O
lastmode	int
!=	O
NORMAL	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"%c[0;10m"	*(char)
,	O
27	int
)	O
;	O
}	O
break	O
;	O
case	O
'2'	O
:	O
{	O
int	O
lasttag	int
=	O
-	O
1	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"<HTML>\n <HEAD> <TITLE>Fractal generated by XaoS</TITLE>\n</HEAD>\n<BODY BGCOLOR=\"#000000\" TEXT=\"#dddddd\" LINK=\"#FFFFFF\">\n<FONT SIZE=2><PRE>\n"	*(char)
)	O
;	O
for	O
(	O
y	int
=	O
0	int
;	O
y	int
<	O
height	float
;	O
y	int
++	O
)	O
{	O
for	O
(	O
x	int
=	O
0	int
;	O
x	int
<	O
width	float
;	O
x	int
++	O
)	O
{	O
char	O
cc	char
;	O
if	O
(	O
(	O
char	O
)	O
buffers	array(*(char))
[	O
3	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
-	O
1	int
!=	O
lasttag	int
)	O
{	O
if	O
(	O
lasttag	int
>=	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"%s"	*(char)
,	O
endtags	array(*(char))
[	O
lasttag	int
]	O
)	O
;	O
lasttag	int
=	O
(	O
char	O
)	O
buffers	array(*(char))
[	O
3	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
-	O
1	int
;	O
if	O
(	O
lasttag	int
>=	O
0	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"%s"	*(char)
,	O
tags	array(*(char))
[	O
lasttag	int
]	O
)	O
;	O
}	O
cc	char
=	O
buffers	array(*(char))
[	O
2	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
;	O
switch	O
(	O
cc	char
)	O
{	O
case	O
'<'	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"&lt;"	*(char)
)	O
;	O
break	O
;	O
case	O
'>'	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"&gt;"	*(char)
)	O
;	O
break	O
;	O
case	O
'&'	O
:	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"&amp;"	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
buffers	array(*(char))
[	O
2	int
]	O
[	O
y	int
*	O
width	float
+	O
x	int
]	O
,	O
f	*(struct)
)	O
;	O
}	O
}	O
putc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
f	*(struct)
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
f	*(struct)
,	O
"</PRE></FONT></BODY>\n</HTML>\n"	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
curses_print	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
"Saved.\n"	*(char)
)	O
;	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
f	*(struct)
)	O
;	O
return	O
name	*(char)
;	O
}	O
static	O
void	O
curses_display	()->(void)
(	O
void	O
)	O
{	O
int	O
x	int
,	O
y	int
;	O
int	O
nattrs	int
=	O
0	int
;	O
for	O
(	O
y	int
=	O
0	int
;	O
y	int
<	O
NATTRS	int
;	O
y	int
++	O
)	O
nattrs	int
+=	O
supported	array(int)
[	O
y	int
]	O
;	O
for	O
(	O
y	int
=	O
0	int
;	O
y	int
<	O
height	float
;	O
y	int
++	O
)	O
{	O
for	O
(	O
x	int
=	O
0	int
;	O
x	int
<	O
width	float
;	O
x	int
++	O
)	O
{	O
int	O
c1	int
,	O
c2	int
,	O
c3	int
,	O
c4	int
,	O
c	int
=	O
0	int
;	O
int	O
pos	int
=	O
x	int
*	O
2	int
+	O
width	float
*	O
4	int
*	O
y	int
;	O
c1	int
=	O
(	O
unsigned	O
char	O
)	O
(	O
buffers	array(*(char))
[	O
currentbuff	int
]	O
[	O
pos	int
+	O
1	int
]	O
)	O
;	O
c2	int
=	O
(	O
unsigned	O
char	O
)	O
(	O
buffers	array(*(char))
[	O
currentbuff	int
]	O
[	O
pos	int
]	O
)	O
;	O
c3	int
=	O
(	O
unsigned	O
char	O
)	O
(	O
buffers	array(*(char))
[	O
currentbuff	int
]	O
[	O
pos	int
+	O
1	int
+	O
width	float
+	O
width	float
]	O
)	O
;	O
c4	int
=	O
(	O
unsigned	O
char	O
)	O
(	O
buffers	array(*(char))
[	O
currentbuff	int
]	O
[	O
pos	int
+	O
width	float
+	O
width	float
]	O
)	O
;	O
if	O
(	O
c1	int
)	O
c1	int
=	O
(	O
unsigned	O
char	O
)	O
(	O
(	O
int	O
)	O
c1	int
+	O
rotation	int
)	O
;	O
if	O
(	O
c2	int
)	O
c2	int
=	O
(	O
unsigned	O
char	O
)	O
(	O
(	O
int	O
)	O
c2	int
+	O
rotation	int
)	O
;	O
if	O
(	O
c3	int
)	O
c3	int
=	O
(	O
unsigned	O
char	O
)	O
(	O
(	O
int	O
)	O
c3	int
+	O
rotation	int
)	O
;	O
if	O
(	O
c4	int
)	O
c4	int
=	O
(	O
unsigned	O
char	O
)	O
(	O
(	O
int	O
)	O
c4	int
+	O
rotation	int
)	O
;	O
switch	O
(	O
palette	*(array(char))
)	O
{	O
case	O
0	int
:	O
c	int
=	O
(	O
(	O
int	O
)	O
c1	int
&	O
15	int
)	O
*	O
16	int
*	O
16	int
*	O
16	int
+	O
(	O
(	O
int	O
)	O
c2	int
&	O
15	int
)	O
*	O
16	int
*	O
16	int
+	O
(	O
(	O
int	O
)	O
c3	int
&	O
15	int
)	O
*	O
16	int
+	O
(	O
(	O
int	O
)	O
c4	int
&	O
15	int
)	O
;	O
break	O
;	O
case	O
1	int
:	O
c	int
=	O
(	O
(	O
int	O
)	O
c1	int
&	O
1	int
)	O
*	O
16	int
*	O
16	int
*	O
16	int
*	O
15	int
+	O
(	O
(	O
int	O
)	O
c2	int
&	O
1	int
)	O
*	O
16	int
*	O
16	int
*	O
15	int
+	O
(	O
(	O
int	O
)	O
c3	int
&	O
1	int
)	O
*	O
16	int
*	O
15	int
+	O
(	O
(	O
int	O
)	O
c4	int
&	O
1	int
)	O
*	O
15	int
;	O
break	O
;	O
case	O
2	int
:	O
c	int
=	O
min	O
(	O
(	O
(	O
int	O
)	O
c1	int
%	O
5	int
)	O
*	O
16	int
*	O
16	int
*	O
16	int
*	O
4	int
,	O
16	int
*	O
16	int
*	O
16	int
*	O
15	int
)	O
+	O
min	O
(	O
(	O
(	O
int	O
)	O
c2	int
%	O
5	int
)	O
*	O
16	int
*	O
16	int
*	O
4	int
,	O
16	int
*	O
16	int
*	O
15	int
)	O
+	O
min	O
(	O
(	O
(	O
int	O
)	O
c3	int
%	O
5	int
)	O
*	O
16	int
*	O
4	int
,	O
16	int
*	O
15	int
)	O
+	O
min	O
(	O
(	O
(	O
int	O
)	O
c4	int
%	O
5	int
)	O
*	O
4	int
,	O
15	int
)	O
;	O
break	O
;	O
case	O
3	int
:	O
c	int
=	O
(	O
(	O
int	O
)	O
c1	int
&	O
~	O
15	int
)	O
*	O
16	int
*	O
16	int
+	O
(	O
(	O
int	O
)	O
c2	int
&	O
~	O
15	int
)	O
*	O
16	int
+	O
(	O
(	O
int	O
)	O
c3	int
&	O
~	O
15	int
)	O
+	O
(	O
(	O
int	O
)	O
c4	int
&	O
~	O
15	int
)	O
/	O
16	int
;	O
break	O
;	O
case	O
4	int
:	O
c	int
=	O
(	O
(	O
int	O
)	O
c1	int
!=	O
0	int
)	O
*	O
16	int
*	O
16	int
*	O
16	int
*	O
15	int
+	O
(	O
(	O
int	O
)	O
c2	int
!=	O
0	int
)	O
*	O
16	int
*	O
16	int
*	O
15	int
+	O
(	O
(	O
int	O
)	O
c3	int
!=	O
0	int
)	O
*	O
16	int
*	O
15	int
+	O
(	O
(	O
int	O
)	O
c4	int
!=	O
0	int
)	O
*	O
15	int
;	O
break	O
;	O
}	O
if	O
(	O
c	int
>=	O
65534	int
)	O
c	int
=	O
65534	int
;	O
if	O
(	O
c	int
<	O
0	int
)	O
c	int
=	O
0	int
;	O
c	int
=	O
table	*(short)
[	O
c	int
]	O
;	O
if	O
(	O
nattrs	int
!=	O
1	int
)	O
{	O
switch	O
(	O
c	int
/	O
128	int
)	O
{	O
case	O
NORMAL	int
:	O
attrset	(int)->(int)
(	O
A_NORMAL	O
)	O
;	O
break	O
;	O
case	O
REVERSE	int
:	O
attrset	(int)->(int)
(	O
A_REVERSE	O
)	O
;	O
break	O
;	O
case	O
DIM	int
:	O
attrset	(int)->(int)
(	O
A_DIM	O
)	O
;	O
break	O
;	O
case	O
BOLD	int
:	O
attrset	(int)->(int)
(	O
A_BOLD	O
)	O
;	O
break	O
;	O
case	O
BOLDFONT	int
:	O
attrset	(int)->(int)
(	O
A_BOLD	O
)	O
;	O
break	O
;	O
}	O
mvaddch	(int,int,int)->(int)
(	O
y	int
,	O
x	int
,	O
c	int
%	O
128	int
)	O
;	O
}	O
buffers	array(*(char))
[	O
2	int
]	O
[	O
x	int
+	O
y	int
*	O
width	float
]	O
=	O
c	int
%	O
128	int
;	O
buffers	array(*(char))
[	O
3	int
]	O
[	O
x	int
+	O
y	int
*	O
width	float
]	O
=	O
c	int
/	O
128	int
;	O
}	O
if	O
(	O
nattrs	int
==	O
1	int
)	O
{	O
buffers	array(*(char))
[	O
2	int
]	O
[	O
(	O
y	int
+	O
1	int
)	O
*	O
width	float
]	O
=	O
0	int
;	O
switch	O
(	O
buffers	array(*(char))
[	O
3	int
]	O
[	O
0	int
]	O
)	O
{	O
case	O
NORMAL	int
:	O
attrset	(int)->(int)
(	O
A_NORMAL	O
)	O
;	O
break	O
;	O
case	O
REVERSE	int
:	O
attrset	(int)->(int)
(	O
A_REVERSE	O
)	O
;	O
break	O
;	O
case	O
DIM	int
:	O
attrset	(int)->(int)
(	O
A_DIM	O
)	O
;	O
break	O
;	O
case	O
BOLD	int
:	O
attrset	(int)->(int)
(	O
A_BOLD	O
)	O
;	O
break	O
;	O
case	O
BOLDFONT	int
:	O
attrset	(int)->(int)
(	O
A_BOLD	O
)	O
;	O
break	O
;	O
}	O
mvaddstr	(int,int,*(char))->(int)
(	O
y	int
,	O
0	int
,	O
buffers	array(*(char))
[	O
2	int
]	O
+	O
y	int
*	O
width	float
)	O
;	O
}	O
}	O
attrset	(int)->(int)
(	O
A_NORMAL	O
)	O
;	O
move	(int,int)->(int)
(	O
mousey	int
/	O
2	int
,	O
mousex	int
/	O
2	int
)	O
;	O
}	O
static	O
int	O
curses_set_color	(int,int,int,int)->(int)
(	O
int	O
r	int
,	O
int	O
g	int
,	O
int	O
b	int
,	O
int	O
init	*(()->(int))
)	O
{	O
if	O
(	O
init	*(()->(int))
)	O
ncolors	int
=	O
0	int
;	O
if	O
(	O
ncolors	int
>=	O
256	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
rotation	int
=	O
0	int
;	O
return	O
(	O
ncolors	int
++	O
)	O
;	O
}	O
static	O
int	O
getkey	()->(int)
(	O
void	O
)	O
{	O
int	O
key	int
=	O
getch	()->(int)
(	O
)	O
;	O
if	O
(	O
mousey	int
<	O
0	int
)	O
mousey	int
=	O
0	int
;	O
if	O
(	O
mousey	int
>	O
2	int
*	O
height	float
-	O
1	int
)	O
mousey	int
=	O
2	int
*	O
height	float
-	O
1	int
;	O
if	O
(	O
mousex	int
<	O
0	int
)	O
mousex	int
=	O
0	int
;	O
if	O
(	O
mousex	int
>	O
2	int
*	O
width	float
-	O
1	int
)	O
mousex	int
=	O
2	int
*	O
width	float
-	O
1	int
;	O
move	(int,int)->(int)
(	O
mousey	int
/	O
2	int
,	O
mousex	int
/	O
2	int
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
if	O
(	O
resized	int
)	O
ui_resize	()->(void)
(	O
)	O
;	O
if	O
(	O
key	int
==	O
1	int
)	O
mousex	int
-=	O
2	int
;	O
else	O
if	O
(	O
key	int
==	O
4	int
)	O
mousex	int
+=	O
2	int
;	O
else	O
if	O
(	O
key	int
==	O
23	int
)	O
mousey	int
-=	O
2	int
;	O
else	O
if	O
(	O
key	int
==	O
24	int
)	O
mousey	int
+=	O
2	int
;	O
else	O
if	O
(	O
key	int
==	O
18	int
)	O
buttons	int
^=	O
BUTTON1	int
;	O
else	O
if	O
(	O
key	int
==	O
20	int
)	O
buttons	int
^=	O
BUTTON2	int
;	O
else	O
if	O
(	O
key	int
==	O
25	int
)	O
buttons	int
^=	O
BUTTON3	int
;	O
else	O
if	O
(	O
key	int
==	O
'E'	O
)	O
{	O
ui_tbreak	()->(void)
(	O
)	O
;	O
nodelay	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
FALSE	int
)	O
;	O
echo	()->(int)
(	O
)	O
;	O
nocbreak	()->(int)
(	O
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
0	int
,	O
0	int
,	O
"Resolution is:%ix%i. Your coordinates sir:"	*(char)
,	O
width	float
*	O
2	int
,	O
height	float
*	O
2	int
)	O
;	O
scanw	(*(char))->(int)
(	O
"%i,%i"	*(char)
,	O
&	O
mousex	int
,	O
&	O
mousey	int
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
0	int
,	O
0	int
,	O
"Button 1:%i,2:%i,3:%i. Your button mask sir:"	*(char)
,	O
BUTTON1	int
,	O
BUTTON2	int
,	O
BUTTON3	int
)	O
;	O
scanw	(*(char))->(int)
(	O
"%i,%i"	*(char)
,	O
&	O
buttons	int
)	O
;	O
cbreak	()->(int)
(	O
)	O
;	O
noecho	()->(int)
(	O
)	O
;	O
nodelay	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
TRUE	int
)	O
;	O
}	O
else	O
if	O
(	O
key	int
==	O
'G'	O
)	O
{	O
char	O
c	int
;	O
int	O
nones	int
=	O
0	int
;	O
ui_tbreak	()->(void)
(	O
)	O
;	O
nodelay	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
FALSE	int
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
0	int
,	O
0	int
,	O
"May I use normal text?          "	*(char)
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
while	O
(	O
(	O
c	int
=	O
tolower	(int)->(int)
(	O
getch	()->(int)
(	O
)	O
)	O
)	O
!=	O
'y'	O
&&	O
c	int
!=	O
'n'	O
)	O
;	O
nones	int
+=	O
(	O
supported	array(int)
[	O
0	int
]	O
=	O
c	int
==	O
'y'	O
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
1	int
,	O
0	int
,	O
"May I use half bright(dim)?     "	*(char)
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
while	O
(	O
(	O
c	int
=	O
tolower	(int)->(int)
(	O
getch	()->(int)
(	O
)	O
)	O
)	O
!=	O
'y'	O
&&	O
c	int
!=	O
'n'	O
)	O
;	O
nones	int
+=	O
(	O
supported	array(int)
[	O
1	int
]	O
=	O
c	int
==	O
'y'	O
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
2	int
,	O
0	int
,	O
"May I use bold as double bright?"	*(char)
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
while	O
(	O
(	O
c	int
=	O
tolower	(int)->(int)
(	O
getch	()->(int)
(	O
)	O
)	O
)	O
!=	O
'y'	O
&&	O
c	int
!=	O
'n'	O
)	O
;	O
nones	int
+=	O
(	O
supported	array(int)
[	O
2	int
]	O
=	O
c	int
==	O
'y'	O
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
3	int
,	O
0	int
,	O
"May I use bold as bold font?    "	*(char)
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
while	O
(	O
(	O
c	int
=	O
tolower	(int)->(int)
(	O
getch	()->(int)
(	O
)	O
)	O
)	O
!=	O
'y'	O
&&	O
c	int
!=	O
'n'	O
)	O
;	O
nones	int
+=	O
(	O
supported	array(int)
[	O
4	int
]	O
=	O
c	int
==	O
'y'	O
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
4	int
,	O
0	int
,	O
"May I use reversed text?        "	*(char)
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
while	O
(	O
(	O
c	int
=	O
tolower	(int)->(int)
(	O
getch	()->(int)
(	O
)	O
)	O
)	O
!=	O
'y'	O
&&	O
c	int
!=	O
'n'	O
)	O
;	O
nones	int
+=	O
(	O
supported	array(int)
[	O
3	int
]	O
=	O
c	int
==	O
'y'	O
)	O
;	O
mvprintw	(int,int,*(char))->(int)
(	O
5	int
,	O
0	int
,	O
"1=8x16font 2=8x8font            "	*(char)
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
while	O
(	O
(	O
c	int
=	O
tolower	(int)->(int)
(	O
getch	()->(int)
(	O
)	O
)	O
)	O
!=	O
'1'	O
&&	O
c	int
!=	O
'2'	O
)	O
;	O
if	O
(	O
c	int
==	O
'1'	O
)	O
setheight	(int)->(void)
(	O
16	int
)	O
;	O
else	O
setheight	(int)->(void)
(	O
8	int
)	O
;	O
if	O
(	O
!	O
nones	int
)	O
supported	array(int)
[	O
0	int
]	O
=	O
1	int
;	O
if	O
(	O
supported	array(int)
[	O
2	int
]	O
&&	O
supported	array(int)
[	O
4	int
]	O
)	O
supported	array(int)
[	O
4	int
]	O
=	O
0	int
;	O
mvprintw	(int,int,*(char))->(int)
(	O
6	int
,	O
0	int
,	O
"rendering aproximation tables   "	*(char)
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
mktable	()->(void)
(	O
)	O
;	O
curses_display	()->(void)
(	O
)	O
;	O
nodelay	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
TRUE	int
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
key	int
==	O
KEY_LEFT	int
)	O
keys	int
^=	O
1	int
;	O
else	O
if	O
(	O
key	int
==	O
KEY_RIGHT	int
)	O
keys	int
^=	O
2	int
;	O
else	O
if	O
(	O
key	int
==	O
KEY_UP	int
)	O
keys	int
^=	O
4	int
;	O
else	O
if	O
(	O
key	int
==	O
KEY_DOWN	int
)	O
keys	int
^=	O
8	int
;	O
else	O
if	O
(	O
key	int
==	O
12	int
)	O
{	O
wclear	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)))->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
redrawwin	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)))->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
)	O
;	O
curses_display	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
tolower	(int)->(int)
(	O
key	int
)	O
==	O
'T'	O
)	O
writetxt	()->(*(char))
(	O
)	O
;	O
else	O
if	O
(	O
tolower	(int)->(int)
(	O
key	int
)	O
==	O
'p'	O
)	O
{	O
palette	*(array(char))
=	O
(	O
palette	*(array(char))
+	O
1	int
)	O
%	O
NPALETTES	O
;	O
curses_display	()->(void)
(	O
)	O
;	O
}	O
else	O
return	O
(	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
curses_clear	()->(void)
(	O
void	O
)	O
{	O
wclear	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)))->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
)	O
;	O
}	O
static	O
void	O
curses_flip_buffers	()->(void)
(	O
void	O
)	O
{	O
currentbuff	int
^=	O
1	int
;	O
}	O
void	O
curses_free	(*(char),*(char))->(void)
(	O
char	O
*	O
b1	*(char)
,	O
char	O
*	O
b2	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
buffers	array(*(char))
[	O
0	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
buffers	array(*(char))
[	O
1	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
buffers	array(*(char))
[	O
2	int
]	O
)	O
;	O
free	(*(void))->(void)
(	O
buffers	array(*(char))
[	O
3	int
]	O
)	O
;	O
}	O
int	O
curses_alloc	(*(*(char)),*(*(char)))->(int)
(	O
char	O
*	O
*	O
b1	*(char)
,	O
char	O
*	O
*	O
b2	*(char)
)	O
{	O
buffers	array(*(char))
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
width	float
*	O
height	float
*	O
4	int
)	O
;	O
buffers	array(*(char))
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
width	float
*	O
height	float
*	O
4	int
)	O
;	O
buffers	array(*(char))
[	O
2	int
]	O
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
width	float
*	O
height	float
+	O
1	int
)	O
;	O
buffers	array(*(char))
[	O
3	int
]	O
=	O
(	O
char	O
*	O
)	O
malloc	(long)->(*(void))
(	O
width	float
*	O
height	float
+	O
1	int
)	O
;	O
currentbuff	int
=	O
0	int
;	O
*	O
b1	*(char)
=	O
buffers	array(*(char))
[	O
0	int
]	O
;	O
*	O
b2	*(char)
=	O
buffers	array(*(char))
[	O
1	int
]	O
;	O
return	O
width	float
*	O
2	int
;	O
}	O
static	O
void	O
curses_processevents	(int,*(int),*(int),*(int),*(int))->(void)
(	O
volatile	O
int	O
wait	int
,	O
volatile	O
int	O
*	O
x	int
,	O
volatile	O
int	O
*	O
y	int
,	O
volatile	O
int	O
*	O
b	int
,	O
volatile	O
int	O
*	O
k	*(int)
)	O
{	O
volatile	O
int	O
c	int
;	O
if	O
(	O
wait	int
)	O
{	O
nodelay	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
FALSE	int
)	O
;	O
setjmp	(array(struct(array(long),int,struct(array(long)))))->(int)
(	O
buf	array(struct(array(long),int,struct(array(long))))
)	O
;	O
iswaiting	int
=	O
1	int
;	O
if	O
(	O
resized	int
)	O
ui_resize	()->(void)
(	O
)	O
;	O
}	O
else	O
nodelay	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
TRUE	int
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getkey	()->(int)
(	O
)	O
)	O
!=	O
ERR	O
)	O
{	O
if	O
(	O
wait	int
)	O
nodelay	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
TRUE	int
)	O
,	O
wait	int
=	O
0	int
,	O
iswaiting	int
=	O
0	int
;	O
if	O
(	O
ui_key	(int)->(int)
(	O
c	int
)	O
==	O
2	int
)	O
return	O
;	O
}	O
if	O
(	O
wait	int
)	O
nodelay	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
TRUE	int
)	O
,	O
wait	int
=	O
0	int
;	O
*	O
x	int
=	O
0	int
,	O
*	O
y	int
=	O
0	int
,	O
*	O
b	int
=	O
0	int
,	O
*	O
k	*(int)
=	O
0	int
;	O
*	O
x	int
=	O
mousex	int
;	O
*	O
y	int
=	O
mousey	int
;	O
*	O
b	int
=	O
buttons	int
;	O
*	O
k	*(int)
=	O
keys	int
;	O
}	O
static	O
void	O
curses_getmouse	(*(int),*(int),*(int))->(void)
(	O
int	O
*	O
x	int
,	O
int	O
*	O
y	int
,	O
int	O
*	O
b	int
)	O
{	O
*	O
x	int
=	O
0	int
,	O
*	O
y	int
=	O
0	int
,	O
*	O
b	int
=	O
0	int
;	O
*	O
x	int
=	O
mousex	int
;	O
*	O
y	int
=	O
mousey	int
;	O
*	O
b	int
=	O
buttons	int
;	O
}	O
void	O
handler	(int)->(void)
(	O
int	O
i	int
)	O
{	O
resized	int
=	O
1	int
;	O
if	O
(	O
iswaiting	int
)	O
longjmp	(array(struct(array(long),int,struct(array(long)))),int)->(void)
(	O
buf	array(struct(array(long),int,struct(array(long))))
,	O
1	int
)	O
;	O
}	O
int	O
curses_init	()->(int)
(	O
void	O
)	O
{	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
initscr	()->(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)))
(	O
)	O
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
table	*(short)
==	O
NULL	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NATTRS	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
supportedon	array(int)
[	O
i	int
]	O
)	O
supported	array(int)
[	O
i	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
supportedoff	array(int)
[	O
i	int
]	O
)	O
supported	array(int)
[	O
i	int
]	O
=	O
0	int
;	O
else	O
{	O
int	O
a	int
=	O
0	int
;	O
if	O
(	O
i	int
==	O
NORMAL	int
)	O
continue	O
;	O
switch	O
(	O
i	int
)	O
{	O
case	O
DIM	int
:	O
a	int
=	O
A_DIM	O
;	O
break	O
;	O
case	O
BOLD	int
:	O
a	int
=	O
A_BOLD	O
;	O
break	O
;	O
case	O
BOLDFONT	int
:	O
a	int
=	O
A_BOLD	O
;	O
break	O
;	O
case	O
REVERSE	int
:	O
a	int
=	O
A_REVERSE	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
(	O
a	int
)	O
)	O
supported	array(int)
[	O
i	int
]	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
fontwidth	int
==	O
8	int
)	O
setheight	(int)->(void)
(	O
8	int
)	O
;	O
if	O
(	O
fontwidth	int
==	O
16	int
)	O
setheight	(int)->(void)
(	O
16	int
)	O
;	O
printf	(*(char))->(int)
(	O
"Please wait..rendering aproximation table.."	*(char)
)	O
;	O
mktable	()->(void)
(	O
)	O
;	O
printf	(*(char))->(int)
(	O
"ok\n"	*(char)
)	O
;	O
}	O
cbreak	()->(int)
(	O
)	O
;	O
nodelay	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
TRUE	int
)	O
;	O
noecho	()->(int)
(	O
)	O
;	O
nonl	()->(int)
(	O
)	O
;	O
intrflush	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
FALSE	int
)	O
;	O
keypad	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
TRUE	int
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGFPE	int
,	O
SIG_IGN	O
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGWINCH	int
,	O
handler	(int)->(void)
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
void	O
curses_uninitialise	()->(void)
(	O
void	O
)	O
{	O
wclear	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)))->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
)	O
;	O
intrflush	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
TRUE	int
)	O
;	O
keypad	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
FALSE	int
)	O
;	O
nodelay	(*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*`,short,short,int,int,*`,struct`,short)),struct(short,short,short,short,short,short),short)),bool)->(int)
(	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
,	O
FALSE	int
)	O
;	O
signal	(int,*((int)->(void)))->(*((int)->(void)))
(	O
SIGWINCH	int
,	O
SIG_IGN	O
)	O
;	O
nocbreak	()->(int)
(	O
)	O
;	O
echo	()->(int)
(	O
)	O
;	O
nl	()->(int)
(	O
)	O
;	O
refresh	()->(int)
(	O
)	O
;	O
endwin	()->(int)
(	O
)	O
;	O
}	O
static	O
void	O
curses_get_size	(*(int),*(int))->(void)
(	O
int	O
*	O
wi	*(int)
,	O
int	O
*	O
he	*(int)
)	O
{	O
if	O
(	O
resized	int
)	O
curses_uninitialise	()->(void)
(	O
)	O
,	O
curses_init	()->(int)
(	O
)	O
,	O
resized	int
=	O
0	int
;	O
*	O
wi	*(int)
=	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
->	O
_maxx	short
;	O
*	O
he	*(int)
=	O
stdscr	*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct),short,short,int,int,*(struct(short,short,short,short,short,short,short,int,int,bool,bool,bool,bool,bool,bool,bool,bool,bool,int,*(struct`),short,short,int,int,*(struct`),struct(short,short,short,short,short,short),short)),struct(short,short,short,short,short,short),short))
->	O
_maxy	short
;	O
width	float
=	O
*	O
wi	*(int)
;	O
height	float
=	O
*	O
he	*(int)
;	O
*	O
wi	*(int)
*=	O
2	int
;	O
*	O
he	*(int)
*=	O
2	int
;	O
}	O
static	O
char	O
*	O
helptext	array(*(char))
[	O
]	O
=	O
{	O
"(N)CURSES DRIVER VERSION 1.1           "	*(char)
,	O
"============================           "	*(char)
,	O
" This driver used to be one of the     "	*(char)
,	O
" most powerfull drivers for XaoS       "	*(char)
,	O
" It supports all XaoS features:        "	*(char)
,	O
"  o 256 colors                         "	*(char)
,	O
"  o smooth animations                  "	*(char)
,	O
"  o much more                          "	*(char)
,	O
" But currently it is obsoletted by new "	*(char)
,	O
" AA driver. If you like text mode,     "	*(char)
,	O
" please update to AA driver. You should"	*(char)
,	O
" download AA-lib from AA-project       "	*(char)
,	O
" homepage at http://www.ta.jcu.cz/aa   "	*(char)
,	O
" Recompiling of XaoS with AAlib        "	*(char)
,	O
" installed will automatically enable   "	*(char)
,	O
" AA driver (if it is not already in -  "	*(char)
,	O
" try xaos -driver aa)                  "	*(char)
,	O
"                                       "	*(char)
,	O
" This driver was left in XaoS because  "	*(char)
,	O
" there is still many user's without    "	*(char)
,	O
" AAlib installed, but once it will be  "	*(char)
,	O
" removed. It is no longer maitained and"	*(char)
,	O
" updated so it does not conforms latest"	*(char)
,	O
" XaoS driver coding standards (Xdcs)   "	*(char)
,	O
" and should not be fully functional    "	*(char)
,	O
" in recent releases of XaoS.           "	*(char)
,	O
"                                       "	*(char)
,	O
" Use it at your own's risk!            "	*(char)
,	O
"                                       "	*(char)
,	O
" And has also many extended features   "	*(char)
,	O
"  o Doubling of resolution with        "	*(char)
,	O
"     anti-aliasing                     "	*(char)
,	O
"  o Mouse emulation                    "	*(char)
,	O
"     because mouse is still not        "	*(char)
,	O
"     standard in terminals XaoS uses   "	*(char)
,	O
"     its emulation with is yet more    "	*(char)
,	O
"     powerfull than normal mouse.      "	*(char)
,	O
"     Press shift+'E' to try it!        "	*(char)
,	O
"     Also you may move mouse by keys:  "	*(char)
,	O
"      C-w = up                         "	*(char)
,	O
"      C-a = left                       "	*(char)
,	O
"      C-d = right                      "	*(char)
,	O
"      C-x = down                       "	*(char)
,	O
"      C-r = button1 (first pres presses"	*(char)
,	O
"             button, second releases it"	*(char)
,	O
"             Same behaviour is used for"	*(char)
,	O
"             arrows keys, because text "	*(char)
,	O
"             terminals does not sends  "	*(char)
,	O
"             informations about        "	*(char)
,	O
"             releasing of keys.)       "	*(char)
,	O
"      C-t = button2                    "	*(char)
,	O
"      C-y = button3                    "	*(char)
,	O
"  o Special handling of attributes.    "	*(char)
,	O
"     can be configured by shift+'G'    "	*(char)
,	O
"     It will ask you following         "	*(char)
,	O
"     questions:                        "	*(char)
,	O
"     May I use normal text             "	*(char)
,	O
"      Many terminals supports various  "	*(char)
,	O
"      attributes. Using this questions "	*(char)
,	O
"      you may configure XaoS to use    "	*(char)
,	O
"      them. Normal text is text w/o any"	*(char)
,	O
"      special attributes.              "	*(char)
,	O
"     May I use half bright(dim)        "	*(char)
,	O
"      Some terminals supports          "	*(char)
,	O
"      atribute dim for half bright.    "	*(char)
,	O
"      this is untested, because no     "	*(char)
,	O
"      xterm nor linux console does this"	*(char)
,	O
"     May I use bold as double bright   "	*(char)
,	O
"      some terminals(like linux console"	*(char)
,	O
"      makes bold character by lighter  "	*(char)
,	O
"      color.                           "	*(char)
,	O
"     May I use bold as bold font?      "	*(char)
,	O
"      other terminals uses another font"	*(char)
,	O
"      for bold characters(like rvxt)   "	*(char)
,	O
"     May I use reversed text           "	*(char)
,	O
"      This produces good results just  "	*(char)
,	O
"      really hi-res terminals(more than"	*(char)
,	O
"      100x40) Nice with fullscreen     "	*(char)
,	O
"      xterm and tiny font.             "	*(char)
,	O
"     1=8x16font 2=8x8font              "	*(char)
,	O
"      most terminals uses 8x16 font.   "	*(char)
,	O
"      But some terminals with square   "	*(char)
,	O
"      letters(ie vga with 80x50 mode or"	*(char)
,	O
"      xterm with tiny font) uses 8x8   "	*(char)
,	O
"      one. You may try both of them and"	*(char)
,	O
"      use better one.                  "	*(char)
,	O
"  o Mouse support                      "	*(char)
,	O
"     driver also supports mouse        "	*(char)
,	O
"     interface included in ncurses.    "	*(char)
,	O
"     but it is bit buggy, and have some"	*(char)
,	O
"     limitations.                      "	*(char)
,	O
"  o Ascii-art images saving.           "	*(char)
,	O
"     normally XaoS does not support    "	*(char)
,	O
"     saving of ascii arted images and  "	*(char)
,	O
"     uses poor gif file instead.       "	*(char)
,	O
"     press shift+'T' to save images.   "	*(char)
,	O
"  o Uses 65535 bytes long lookup table "	*(char)
,	O
"     to make ultra fast aproximation   "	*(char)
,	O
"     by letters                        "	*(char)
,	O
"  o Specialized palettes for text mode "	*(char)
,	O
"  o Special top speed aproximation     "	*(char)
,	O
"     table renderer that takes         "	*(char)
,	O
"     advantage of attributes and       "	*(char)
,	O
"     supports dithering, antialiasing  "	*(char)
,	O
"     8x8 or 8x16 vga font.             "	*(char)
,	O
"  o Handles resizing on the fly        "	*(char)
,	O
"                                       "	*(char)
,	O
"                                       "	*(char)
,	O
" NCURSES driver was done by Jan Hubicka"	*(char)
,	O
"              (C) 1997                 "	*(char)
,	O
}	O
;	O
static	O
struct	O
params	struct(*(char),int,*(void),*(char))
params	struct(*(char),int,*(void),*(char))
[	O
]	O
=	O
{	O
{	O
"-normal"	*(char)
,	O
P_SWITCH	int
,	O
supportedon	array(int)
+	O
NORMAL	int
,	O
"Enable use of normal text"	*(char)
}	O
,	O
{	O
"-nonormal"	*(char)
,	O
P_SWITCH	int
,	O
supportedoff	array(int)
+	O
NORMAL	int
,	O
"Disable use of normal text"	*(char)
}	O
,	O
{	O
"-dim"	*(char)
,	O
P_SWITCH	int
,	O
supportedon	array(int)
+	O
DIM	int
,	O
"Enable use of dim attribute(hlaf bright)"	*(char)
}	O
,	O
{	O
"-nodim"	*(char)
,	O
P_SWITCH	int
,	O
supportedon	array(int)
+	O
DIM	int
,	O
"Disable use of dim attribute(hlaf bright)"	*(char)
}	O
,	O
{	O
"-bold"	*(char)
,	O
P_SWITCH	int
,	O
supportedon	array(int)
+	O
BOLD	int
,	O
"Enable use of bold attribute(double bright)"	*(char)
}	O
,	O
{	O
"-nobold"	*(char)
,	O
P_SWITCH	int
,	O
supportedon	array(int)
+	O
BOLD	int
,	O
"Disable use of bold attribute(double bright)"	*(char)
}	O
,	O
{	O
"-boldfont"	*(char)
,	O
P_SWITCH	int
,	O
supportedon	array(int)
+	O
BOLDFONT	int
,	O
"Enable use of bold attribute(bold font)"	*(char)
}	O
,	O
{	O
"-noboldfont"	*(char)
,	O
P_SWITCH	int
,	O
supportedon	array(int)
+	O
BOLDFONT	int
,	O
"Disable use of bold attribute(bold font)"	*(char)
}	O
,	O
{	O
"-reverse"	*(char)
,	O
P_SWITCH	int
,	O
supportedon	array(int)
+	O
REVERSE	int
,	O
"Enable use of reversed text"	*(char)
}	O
,	O
{	O
"-noreverse"	*(char)
,	O
P_SWITCH	int
,	O
supportedoff	array(int)
+	O
REVERSE	int
,	O
"Disable use of reversed text"	*(char)
}	O
,	O
{	O
"-fontheight"	*(char)
,	O
P_NUMBER	int
,	O
&	O
fontwidth	int
,	O
"Set font height(8 or 16)"	*(char)
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
struct	O
ui_driver	struct(*(char),*(()->(int)),*((*(int),*(int))->(void)),*((int,*(int),*(int),*(int),*(int))->(void)),*((*(int),*(int),*(int))->(void)),*(()->(void)),*((int,int,int,int)->(int)),*((*(array(char)),int,int)->(void)),*((int,int,*(char))->(void)),*(()->(void)),*((*(*(char)),*(*(char)))->(int)),*((*(char),*(char))->(void)),*(()->(void)),*(()->(void)),*((int)->(void)),*(()->(void)),*(()->(void)),int,int,*(*(char)),int,*(struct(*(char),int,*(void),*(char))),int,float,float,int,int,int,int,int,int)
curses_driver	struct(*(char),*(()->(int)),*((*(int),*(int))->(void)),*((int,*(int),*(int),*(int),*(int))->(void)),*((*(int),*(int),*(int))->(void)),*(()->(void)),*((int,int,int,int)->(int)),*((*(array(char)),int,int)->(void)),*((int,int,*(char))->(void)),*(()->(void)),*((*(*(char)),*(*(char)))->(int)),*((*(char),*(char))->(void)),*(()->(void)),*(()->(void)),*((int)->(void)),*(()->(void)),*(()->(void)),int,int,*(*(char)),int,*(struct(*(char),int,*(void),*(char))),int,float,float,int,int,int,int,int,int)
=	O
{	O
"curses"	*(char)
,	O
curses_init	()->(int)
,	O
curses_get_size	(*(int),*(int))->(void)
,	O
(	O
void	O
(	O
*	O
)	O
(	O
int	O
,	O
int	O
*	O
,	O
int	O
*	O
,	O
int	O
*	O
,	O
int	O
*	O
)	O
)	O
curses_processevents	(int,*(int),*(int),*(int),*(int))->(void)
,	O
curses_getmouse	(*(int),*(int),*(int))->(void)
,	O
curses_uninitialise	()->(void)
,	O
curses_set_color	(int,int,int,int)->(int)
,	O
NULL	O
,	O
curses_print	(int,int,*(char))->(void)
,	O
curses_display	()->(void)
,	O
curses_alloc	(*(*(char)),*(*(char)))->(int)
,	O
curses_free	(*(char),*(char))->(void)
,	O
curses_flip_buffers	()->(void)
,	O
curses_clear	()->(void)
,	O
NULL	O
,	O
NULL	O
,	O
curses_refresh	()->(void)
,	O
2	int
,	O
2	int
,	O
helptext	array(*(char))
,	O
UGLYTEXTSIZE	O
,	O
params	struct(*(char),int,*(void),*(char))
,	O
FULLSCREEN	int
|	O
UPDATE_AFTER_RESIZE	int
|	O
PALETTE_ROTATION	int
|	O
PALETTE_REDISPLAYS	int
,	O
0.0	int
,	O
0.0	int
,	O
0	int
,	O
0	int
,	O
UI_C256	int
,	O
1	int
,	O
254	int
,	O
253	int
}	O
;	O
