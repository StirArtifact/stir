int	O
_rl_vi_last_command	int
=	O
'i'	O
;	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
=	O
0	int
;	O
int	O
_rl_vi_redoing	int
;	O
static	O
int	O
_rl_vi_doing_insert	int
;	O
static	O
const	O
char	O
*	O
const	O
vi_motion	*(char)
=	O
" hl^$0ftFT;,%wbeWBE|`"	*(char)
;	O
static	O
Keymap	*(struct(char,*((int,int)->(int))))
vi_replace_map	*(struct(char,*((int,int)->(int))))
;	O
static	O
int	O
vi_replace_count	int
;	O
static	O
int	O
vi_continued_command	int
;	O
static	O
char	O
*	O
vi_insert_buffer	*(char)
;	O
static	O
int	O
vi_insert_buffer_size	int
;	O
static	O
int	O
_rl_vi_last_repeat	int
=	O
1	int
;	O
static	O
int	O
_rl_vi_last_arg_sign	int
=	O
1	int
;	O
static	O
int	O
_rl_vi_last_motion	int
;	O
static	O
char	O
_rl_vi_last_search_mbchar	array(char)
[	O
MB_LEN_MAX	int
]	O
;	O
static	O
int	O
_rl_vi_last_search_mblen	int
;	O
static	O
int	O
_rl_vi_last_replacement	int
;	O
static	O
int	O
_rl_vi_last_key_before_insert	int
;	O
static	O
const	O
char	O
*	O
const	O
vi_textmod	*(char)
=	O
"_*\\AaIiCcDdPpYyRrSsXx~"	*(char)
;	O
static	O
int	O
vi_mark_chars	array(int)
[	O
'z'	O
-	O
'a'	O
+	O
1	int
]	O
;	O
static	O
void	O
_rl_vi_replace_insert	(int)->(void)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
_rl_vi_save_replace	()->(void)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
_rl_vi_stuff_insert	(int)->(void)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
_rl_vi_save_insert	(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))))->(void)
PARAMS	O
(	O
(	O
UNDO_LIST	struct(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))
*	O
)	O
)	O
;	O
static	O
void	O
vi_save_insert_buffer	(int,int)->(void)
PARAMS	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
_rl_vi_backup	()->(void)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_arg_dispatch	(int)->(int)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
rl_digit_loop1	()->(int)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_set_mark	()->(int)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_goto_mark	()->(int)
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
_rl_vi_append_forward	(int)->(void)
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_callback_getchar	(*(char),int)->(int)
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_callback_set_mark	(*(struct(int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_callback_goto_mark	(*(struct(int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_callback_change_char	(*(struct(int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_callback_char_search	(*(struct(int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
)	O
)	O
;	O
static	O
int	O
rl_domove_read_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
)	O
)	O
;	O
static	O
int	O
rl_domove_motion_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
)	O
)	O
;	O
static	O
int	O
rl_vi_domove_getchar	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
)	O
)	O
;	O
static	O
int	O
vi_change_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
)	O
)	O
;	O
static	O
int	O
vi_delete_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
)	O
)	O
;	O
static	O
int	O
vi_yank_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
)	O
)	O
;	O
static	O
int	O
vidomove_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
)	O
)	O
;	O
void	O
_rl_vi_initialize_line	()->(void)
(	O
)	O
{	O
register	O
int	O
i	int
,	O
n	int
;	O
n	int
=	O
sizeof	O
(	O
vi_mark_chars	array(int)
)	O
/	O
sizeof	O
(	O
vi_mark_chars	array(int)
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
vi_mark_chars	array(int)
[	O
i	int
]	O
=	O
-	O
1	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_VICMDONCE	int
)	O
;	O
}	O
void	O
_rl_vi_reset_last	()->(void)
(	O
)	O
{	O
_rl_vi_last_command	int
=	O
'i'	O
;	O
_rl_vi_last_repeat	int
=	O
1	int
;	O
_rl_vi_last_arg_sign	int
=	O
1	int
;	O
_rl_vi_last_motion	int
=	O
0	int
;	O
}	O
void	O
_rl_vi_set_last	(int,int,int)->(void)
(	O
key	int
,	O
repeat	int
,	O
sign	int
)	O
int	O
key	int
,	O
repeat	int
,	O
sign	int
;	O
{	O
_rl_vi_last_command	int
=	O
key	int
;	O
_rl_vi_last_repeat	int
=	O
repeat	int
;	O
_rl_vi_last_arg_sign	int
=	O
sign	int
;	O
}	O
void	O
rl_vi_start_inserting	(int,int,int)->(void)
(	O
key	int
,	O
repeat	int
,	O
sign	int
)	O
int	O
key	int
,	O
repeat	int
,	O
sign	int
;	O
{	O
_rl_vi_set_last	(int,int,int)->(void)
(	O
key	int
,	O
repeat	int
,	O
sign	int
)	O
;	O
rl_vi_insertion_mode	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
}	O
int	O
_rl_vi_textmod_command	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
return	O
(	O
member	O
(	O
c	int
,	O
vi_textmod	*(char)
)	O
)	O
;	O
}	O
int	O
_rl_vi_motion_command	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
return	O
(	O
member	O
(	O
c	int
,	O
vi_motion	*(char)
)	O
)	O
;	O
}	O
static	O
void	O
_rl_vi_replace_insert	(int)->(void)
(	O
count	int
)	O
int	O
count	int
;	O
{	O
int	O
nchars	int
;	O
nchars	int
=	O
strlen	(*(char))->(long)
(	O
vi_insert_buffer	*(char)
)	O
;	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
while	O
(	O
count	int
--	O
)	O
_rl_replace_text	(*(char),int,int)->(int)
(	O
vi_insert_buffer	*(char)
,	O
rl_point	int
,	O
rl_point	int
+	O
nchars	int
-	O
1	int
)	O
;	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
}	O
static	O
void	O
_rl_vi_stuff_insert	(int)->(void)
(	O
count	int
)	O
int	O
count	int
;	O
{	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
while	O
(	O
count	int
--	O
)	O
rl_insert_text	(*(char))->(int)
(	O
vi_insert_buffer	*(char)
)	O
;	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
}	O
int	O
rl_vi_redo	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
int	O
r	int
;	O
if	O
(	O
rl_explicit_arg	int
==	O
0	int
)	O
{	O
rl_numeric_arg	int
=	O
_rl_vi_last_repeat	int
;	O
rl_arg_sign	int
=	O
_rl_vi_last_arg_sign	int
;	O
}	O
r	int
=	O
0	int
;	O
_rl_vi_redoing	int
=	O
1	int
;	O
if	O
(	O
_rl_vi_last_command	int
==	O
'i'	O
&&	O
vi_insert_buffer	*(char)
&&	O
*	O
vi_insert_buffer	*(char)
)	O
{	O
_rl_vi_stuff_insert	(int)->(void)
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
_rl_vi_backup	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_last_command	int
==	O
'R'	O
&&	O
vi_insert_buffer	*(char)
&&	O
*	O
vi_insert_buffer	*(char)
)	O
{	O
_rl_vi_replace_insert	(int)->(void)
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
_rl_vi_backup	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_last_command	int
==	O
'I'	O
&&	O
vi_insert_buffer	*(char)
&&	O
*	O
vi_insert_buffer	*(char)
)	O
{	O
rl_beg_of_line	(int,int)->(int)
(	O
1	int
,	O
'I'	O
)	O
;	O
_rl_vi_stuff_insert	(int)->(void)
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
_rl_vi_backup	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_last_command	int
==	O
'a'	O
&&	O
vi_insert_buffer	*(char)
&&	O
*	O
vi_insert_buffer	*(char)
)	O
{	O
_rl_vi_append_forward	(int)->(void)
(	O
'a'	O
)	O
;	O
_rl_vi_stuff_insert	(int)->(void)
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
_rl_vi_backup	()->(void)
(	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_last_command	int
==	O
'A'	O
&&	O
vi_insert_buffer	*(char)
&&	O
*	O
vi_insert_buffer	*(char)
)	O
{	O
rl_end_of_line	(int,int)->(int)
(	O
1	int
,	O
'A'	O
)	O
;	O
_rl_vi_stuff_insert	(int)->(void)
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
_rl_vi_backup	()->(void)
(	O
)	O
;	O
}	O
else	O
r	int
=	O
_rl_dispatch	(int,*(struct(char,*((int,int)->(int)))))->(int)
(	O
_rl_vi_last_command	int
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
;	O
_rl_vi_redoing	int
=	O
0	int
;	O
return	O
(	O
r	int
)	O
;	O
}	O
int	O
rl_vi_undo	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_undo_command	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_vi_yank_arg	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_explicit_arg	int
)	O
rl_yank_nth_arg	(int,int)->(int)
(	O
count	int
-	O
1	int
,	O
0	int
)	O
;	O
else	O
rl_yank_nth_arg	(int,int)->(int)
(	O
'$'	O
,	O
0	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_fetch_history	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
int	O
wanted	int
;	O
if	O
(	O
rl_explicit_arg	int
)	O
{	O
wanted	int
=	O
history_base	int
+	O
where_history	()->(int)
(	O
)	O
-	O
count	int
;	O
if	O
(	O
wanted	int
<=	O
0	int
)	O
rl_beginning_of_history	(int,int)->(int)
(	O
0	int
,	O
0	int
)	O
;	O
else	O
rl_get_previous_history	(int,int)->(int)
(	O
wanted	int
,	O
c	int
)	O
;	O
}	O
else	O
rl_beginning_of_history	(int,int)->(int)
(	O
count	int
,	O
0	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_search_again	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'n'	O
:	O
rl_noninc_reverse_search_again	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
rl_noninc_forward_search_again	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
break	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_search	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'?'	O
:	O
_rl_free_saved_history_line	()->(int)
(	O
)	O
;	O
rl_noninc_forward_search	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
break	O
;	O
case	O
'/'	O
:	O
_rl_free_saved_history_line	()->(int)
(	O
)	O
;	O
rl_noninc_reverse_search	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
break	O
;	O
default	O
:	O
rl_ding	()->(int)
(	O
)	O
;	O
break	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_complete	(int,int)->(int)
(	O
ignore	int
,	O
key	int
)	O
int	O
ignore	int
,	O
key	int
;	O
{	O
if	O
(	O
(	O
rl_point	int
<	O
rl_end	int
)	O
&&	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
+	O
1	int
]	O
)	O
)	O
rl_vi_end_word	(int,int)->(int)
(	O
1	int
,	O
'E'	O
)	O
;	O
rl_point	int
++	O
;	O
}	O
if	O
(	O
key	int
==	O
'*'	O
)	O
rl_complete_internal	(int)->(int)
(	O
'*'	O
)	O
;	O
else	O
if	O
(	O
key	int
==	O
'='	O
)	O
rl_complete_internal	(int)->(int)
(	O
'?'	O
)	O
;	O
else	O
if	O
(	O
key	int
==	O
'\\'	O
)	O
rl_complete_internal	(int)->(int)
(	O
TAB	char
)	O
;	O
else	O
rl_complete	(int,int)->(int)
(	O
0	int
,	O
key	int
)	O
;	O
if	O
(	O
key	int
==	O
'*'	O
||	O
key	int
==	O
'\\'	O
)	O
rl_vi_start_inserting	(int,int,int)->(void)
(	O
key	int
,	O
1	int
,	O
rl_arg_sign	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_tilde_expand	(int,int)->(int)
(	O
ignore	int
,	O
key	int
)	O
int	O
ignore	int
,	O
key	int
;	O
{	O
rl_tilde_expand	(int,int)->(int)
(	O
0	int
,	O
key	int
)	O
;	O
rl_vi_start_inserting	(int,int,int)->(void)
(	O
key	int
,	O
1	int
,	O
rl_arg_sign	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_prev_word	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_vi_next_word	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
_rl_uppercase_p	(int)->(int)
(	O
key	int
)	O
)	O
rl_vi_bWord	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
else	O
rl_vi_bword	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_next_word	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_vi_prev_word	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_point	int
>=	O
(	O
rl_end	int
-	O
1	int
)	O
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
_rl_uppercase_p	(int)->(int)
(	O
key	int
)	O
)	O
rl_vi_fWord	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
else	O
rl_vi_fword	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_end_word	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
_rl_uppercase_p	(int)->(int)
(	O
key	int
)	O
)	O
rl_vi_eWord	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
else	O
rl_vi_eword	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_fWord	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
(	O
rl_end	int
-	O
1	int
)	O
)	O
{	O
while	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
rl_point	int
++	O
;	O
while	O
(	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
rl_point	int
++	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_bWord	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
>	O
0	int
)	O
{	O
if	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
while	O
(	O
rl_point	int
>	O
0	int
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
{	O
while	O
(	O
--	O
rl_point	int
>=	O
0	int
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
;	O
rl_point	int
++	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_eWord	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
(	O
rl_end	int
-	O
1	int
)	O
)	O
{	O
if	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
if	O
(	O
rl_point	int
&&	O
rl_point	int
<	O
rl_end	int
)	O
{	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
rl_point	int
--	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_fword	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
(	O
rl_end	int
-	O
1	int
)	O
)	O
{	O
if	O
(	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
{	O
while	O
(	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
rl_point	int
++	O
;	O
}	O
else	O
{	O
while	O
(	O
!	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
rl_point	int
++	O
;	O
}	O
while	O
(	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
rl_point	int
++	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_bword	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
>	O
0	int
)	O
{	O
int	O
last_is_ident	int
;	O
if	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
last_is_ident	int
=	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
-	O
1	int
]	O
)	O
;	O
if	O
(	O
(	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
!	O
last_is_ident	int
)	O
||	O
(	O
!	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
last_is_ident	int
)	O
)	O
rl_point	int
--	O
;	O
while	O
(	O
rl_point	int
>	O
0	int
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
{	O
if	O
(	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
while	O
(	O
--	O
rl_point	int
>=	O
0	int
&&	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
;	O
else	O
while	O
(	O
--	O
rl_point	int
>=	O
0	int
&&	O
!	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
;	O
rl_point	int
++	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_eword	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
rl_end	int
-	O
1	int
)	O
{	O
if	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
if	O
(	O
rl_point	int
<	O
rl_end	int
)	O
{	O
if	O
(	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
while	O
(	O
++	O
rl_point	int
<	O
rl_end	int
&&	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
;	O
else	O
while	O
(	O
++	O
rl_point	int
<	O
rl_end	int
&&	O
!	O
_rl_isident	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
;	O
}	O
rl_point	int
--	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_insert_beg	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_beg_of_line	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
rl_vi_insert_mode	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_rl_vi_append_forward	(int)->(void)
(	O
key	int
)	O
int	O
key	int
;	O
{	O
int	O
point	int
;	O
if	O
(	O
rl_point	int
<	O
rl_end	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
rl_point	int
++	O
;	O
else	O
{	O
point	int
=	O
rl_point	int
;	O
rl_point	int
=	O
_rl_forward_char_internal	(int)->(int)
(	O
1	int
)	O
;	O
if	O
(	O
point	int
==	O
rl_point	int
)	O
rl_point	int
=	O
rl_end	int
;	O
}	O
}	O
}	O
int	O
rl_vi_append_mode	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
_rl_vi_append_forward	(int)->(void)
(	O
key	int
)	O
;	O
rl_vi_start_inserting	(int,int,int)->(void)
(	O
key	int
,	O
1	int
,	O
rl_arg_sign	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_append_eol	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_end_of_line	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
rl_vi_append_mode	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_eof_maybe	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
return	O
(	O
rl_newline	(int,int)->(int)
(	O
1	int
,	O
'\n'	O
)	O
)	O
;	O
}	O
int	O
rl_vi_insertion_mode	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
=	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
;	O
_rl_vi_last_key_before_insert	int
=	O
key	int
;	O
if	O
(	O
_rl_show_mode_in_prompt	int
)	O
_rl_reset_prompt	()->(void)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_insert_mode	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_vi_start_inserting	(int,int,int)->(void)
(	O
key	int
,	O
1	int
,	O
rl_arg_sign	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
vi_save_insert_buffer	(int,int)->(void)
(	O
start	int
,	O
len	int
)	O
int	O
start	int
,	O
len	int
;	O
{	O
if	O
(	O
len	int
>=	O
vi_insert_buffer_size	int
)	O
{	O
vi_insert_buffer_size	int
+=	O
(	O
len	int
+	O
32	int
)	O
-	O
(	O
len	int
%	O
32	int
)	O
;	O
vi_insert_buffer	*(char)
=	O
(	O
char	O
*	O
)	O
xrealloc	(*(void),long)->(*(void))
(	O
vi_insert_buffer	*(char)
,	O
vi_insert_buffer_size	int
)	O
;	O
}	O
strncpy	(*(char),*(char),long)->(*(char))
(	O
vi_insert_buffer	*(char)
,	O
rl_line_buffer	*(char)
+	O
start	int
,	O
len	int
-	O
1	int
)	O
;	O
vi_insert_buffer	*(char)
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
static	O
void	O
_rl_vi_save_replace	()->(void)
(	O
)	O
{	O
int	O
len	int
,	O
start	int
,	O
end	int
;	O
UNDO_LIST	struct(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))
*	O
up	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
up	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
=	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
if	O
(	O
up	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
==	O
0	int
||	O
up	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
->	O
what	enum(int,int,int,int)
!=	O
UNDO_END	int
||	O
vi_replace_count	int
<=	O
0	int
)	O
{	O
if	O
(	O
vi_insert_buffer_size	int
>=	O
1	int
)	O
vi_insert_buffer	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
;	O
}	O
end	int
=	O
rl_point	int
;	O
start	int
=	O
end	int
-	O
vi_replace_count	int
+	O
1	int
;	O
len	int
=	O
vi_replace_count	int
+	O
1	int
;	O
vi_save_insert_buffer	(int,int)->(void)
(	O
start	int
,	O
len	int
)	O
;	O
}	O
static	O
void	O
_rl_vi_save_insert	(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))))->(void)
(	O
up	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
)	O
UNDO_LIST	struct(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))
*	O
up	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
;	O
{	O
int	O
len	int
,	O
start	int
,	O
end	int
;	O
if	O
(	O
up	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
==	O
0	int
||	O
up	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
->	O
what	enum(int,int,int,int)
!=	O
UNDO_INSERT	int
)	O
{	O
if	O
(	O
vi_insert_buffer_size	int
>=	O
1	int
)	O
vi_insert_buffer	*(char)
[	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
;	O
}	O
start	int
=	O
up	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
->	O
start	int
;	O
end	int
=	O
up	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
->	O
end	int
;	O
len	int
=	O
end	int
-	O
start	int
+	O
1	int
;	O
vi_save_insert_buffer	(int,int)->(void)
(	O
start	int
,	O
len	int
)	O
;	O
}	O
void	O
_rl_vi_done_inserting	()->(void)
(	O
)	O
{	O
if	O
(	O
_rl_vi_doing_insert	int
)	O
{	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
_rl_vi_doing_insert	int
=	O
0	int
;	O
if	O
(	O
_rl_vi_last_key_before_insert	int
==	O
'R'	O
)	O
_rl_vi_save_replace	()->(void)
(	O
)	O
;	O
else	O
_rl_vi_save_insert	(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))))->(void)
(	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
->	O
next	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
)	O
;	O
vi_continued_command	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
&&	O
(	O
_rl_vi_last_key_before_insert	int
==	O
'i'	O
||	O
_rl_vi_last_key_before_insert	int
==	O
'a'	O
||	O
_rl_vi_last_key_before_insert	int
==	O
'I'	O
||	O
_rl_vi_last_key_before_insert	int
==	O
'A'	O
)	O
)	O
_rl_vi_save_insert	(*(struct(*(struct(*`,int,int,*`,enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int))))->(void)
(	O
rl_undo_list	*(struct(*(struct(*(struct`),int,int,*(char),enum(int,int,int,int))),int,int,*(char),enum(int,int,int,int)))
)	O
;	O
else	O
if	O
(	O
_rl_vi_last_key_before_insert	int
==	O
'C'	O
)	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
while	O
(	O
_rl_undo_group_level	int
>	O
0	int
)	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
vi_continued_command	int
=	O
0	int
;	O
}	O
}	O
int	O
rl_vi_movement_mode	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
rl_backward_char	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
=	O
vi_movement_keymap	array(struct(char,*((int,int)->(int))))
;	O
_rl_vi_done_inserting	()->(void)
(	O
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_VICMDONCE	int
)	O
==	O
0	int
)	O
rl_free_undo_list	()->(void)
(	O
)	O
;	O
if	O
(	O
_rl_show_mode_in_prompt	int
)	O
_rl_reset_prompt	()->(void)
(	O
)	O
;	O
RL_SETSTATE	O
(	O
RL_STATE_VICMDONCE	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_arg_digit	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
if	O
(	O
c	int
==	O
'0'	O
&&	O
rl_numeric_arg	int
==	O
1	int
&&	O
!	O
rl_explicit_arg	int
)	O
return	O
(	O
rl_beg_of_line	(int,int)->(int)
(	O
1	int
,	O
c	int
)	O
)	O
;	O
else	O
return	O
(	O
rl_digit_argument	(int,int)->(int)
(	O
count	int
,	O
c	int
)	O
)	O
;	O
}	O
static	O
int	O
_rl_vi_change_mbchar_case	(int)->(int)
(	O
count	int
)	O
int	O
count	int
;	O
{	O
wchar_t	int
wc	int
;	O
char	O
mb	array(char)
[	O
MB_LEN_MAX	int
+	O
1	int
]	O
;	O
int	O
mlen	int
,	O
p	int
;	O
size_t	long
m	long
;	O
mbstate_t	struct(int,union(int,array(char)))
ps	struct(int,union(int,array(char)))
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
ps	struct(int,union(int,array(char)))
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct(int,union(int,array(char)))
)	O
)	O
;	O
if	O
(	O
_rl_adjust_point	(*(char),int,*(struct(int,union(int,array(char)))))->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
>	O
0	int
)	O
count	int
--	O
;	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
{	O
m	long
=	O
mbrtowc	(*(int),*(char),long,*(struct(int,union(int,array(char)))))->(long)
(	O
&	O
wc	int
,	O
rl_line_buffer	*(char)
+	O
rl_point	int
,	O
rl_end	int
-	O
rl_point	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
m	long
)	O
)	O
wc	int
=	O
(	O
wchar_t	int
)	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
;	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
m	long
)	O
)	O
wc	int
=	O
L'\0'	O
;	O
if	O
(	O
iswupper	(int)->(int)
(	O
wc	int
)	O
)	O
wc	int
=	O
towlower	(int)->(int)
(	O
wc	int
)	O
;	O
else	O
if	O
(	O
iswlower	(int)->(int)
(	O
wc	int
)	O
)	O
wc	int
=	O
towupper	(int)->(int)
(	O
wc	int
)	O
;	O
else	O
{	O
rl_forward_char	(int,int)->(int)
(	O
1	int
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
wc	int
)	O
{	O
p	int
=	O
rl_point	int
;	O
mlen	int
=	O
wcrtomb	(*(char),int,*(struct(int,union(int,array(char)))))->(long)
(	O
mb	array(char)
,	O
wc	int
,	O
&	O
ps	struct(int,union(int,array(char)))
)	O
;	O
if	O
(	O
mlen	int
>=	O
0	int
)	O
mb	array(char)
[	O
mlen	int
]	O
=	O
'\0'	O
;	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
rl_vi_delete	(int,int)->(int)
(	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
rl_point	int
<	O
p	int
)	O
rl_point	int
++	O
;	O
rl_insert_text	(*(char))->(int)
(	O
mb	array(char)
)	O
;	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
rl_vi_check	()->(int)
(	O
)	O
;	O
}	O
else	O
rl_forward_char	(int,int)->(int)
(	O
1	int
,	O
0	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_vi_change_case	(int,int)->(int)
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
int	O
c	int
,	O
p	int
;	O
if	O
(	O
rl_point	int
>=	O
rl_end	int
)	O
return	O
(	O
0	int
)	O
;	O
c	int
=	O
0	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
return	O
(	O
_rl_vi_change_mbchar_case	(int)->(int)
(	O
count	int
)	O
)	O
;	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
{	O
if	O
(	O
_rl_uppercase_p	(int)->(int)
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
c	int
=	O
_rl_to_lower	(int)->(int)
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
;	O
else	O
if	O
(	O
_rl_lowercase_p	(int)->(int)
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
c	int
=	O
_rl_to_upper	(int)->(int)
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
;	O
else	O
{	O
rl_forward_char	(int,int)->(int)
(	O
1	int
,	O
c	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
)	O
{	O
p	int
=	O
rl_point	int
;	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
rl_vi_delete	(int,int)->(int)
(	O
1	int
,	O
c	int
)	O
;	O
if	O
(	O
rl_point	int
<	O
p	int
)	O
rl_point	int
++	O
;	O
_rl_insert_char	(int,int)->(int)
(	O
1	int
,	O
c	int
)	O
;	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
rl_vi_check	()->(int)
(	O
)	O
;	O
}	O
else	O
rl_forward_char	(int,int)->(int)
(	O
1	int
,	O
c	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_put	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
!	O
_rl_uppercase_p	(int)->(int)
(	O
key	int
)	O
&&	O
(	O
rl_point	int
+	O
1	int
<=	O
rl_end	int
)	O
)	O
rl_point	int
=	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
while	O
(	O
count	int
--	O
)	O
rl_yank	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
rl_backward_char	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_rl_vi_backup	()->(void)
(	O
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_point	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
else	O
rl_point	int
--	O
;	O
}	O
int	O
rl_vi_check	()->(int)
(	O
)	O
{	O
if	O
(	O
rl_point	int
&&	O
rl_point	int
==	O
rl_end	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_point	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
else	O
rl_point	int
--	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_column	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
>	O
rl_end	int
)	O
rl_end_of_line	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
else	O
rl_point	int
=	O
count	int
-	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
_rl_vi_arg_dispatch	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
int	O
key	int
;	O
key	int
=	O
c	int
;	O
if	O
(	O
c	int
>=	O
0	int
&&	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
[	O
c	int
]	O
.	O
type	char
==	O
ISFUNC	int
&&	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
[	O
c	int
]	O
.	O
function	*((int,int)->(int))
==	O
rl_universal_argument	(int,int)->(int)
)	O
{	O
rl_numeric_arg	int
*=	O
4	int
;	O
return	O
1	int
;	O
}	O
c	int
=	O
UNMETA	O
(	O
c	int
)	O
;	O
if	O
(	O
_rl_digit_p	(int)->(int)
(	O
c	int
)	O
)	O
{	O
if	O
(	O
rl_explicit_arg	int
)	O
rl_numeric_arg	int
=	O
(	O
rl_numeric_arg	int
*	O
10	int
)	O
+	O
_rl_digit_value	(int)->(int)
(	O
c	int
)	O
;	O
else	O
rl_numeric_arg	int
=	O
_rl_digit_value	(int)->(int)
(	O
c	int
)	O
;	O
rl_explicit_arg	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
else	O
{	O
rl_clear_message	()->(int)
(	O
)	O
;	O
rl_stuff_char	(int)->(int)
(	O
key	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
static	O
int	O
rl_digit_loop1	()->(int)
(	O
)	O
{	O
int	O
c	int
,	O
r	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
_rl_arg_overflow	()->(int)
(	O
)	O
)	O
return	O
1	int
;	O
c	int
=	O
_rl_arg_getchar	()->(int)
(	O
)	O
;	O
r	int
=	O
_rl_vi_arg_dispatch	(int)->(int)
(	O
c	int
)	O
;	O
if	O
(	O
r	int
<=	O
0	int
)	O
break	O
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_rl_mvcxt_init	(*(struct(int,int,int,int,int,int,int,int,int)),int,int)->(void)
(	O
m	long
,	O
op	int
,	O
key	int
)	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
int	O
op	int
,	O
key	int
;	O
{	O
m	long
->	O
op	int
=	O
op	int
;	O
m	long
->	O
state	*(int)
=	O
m	long
->	O
flags	int
=	O
0	int
;	O
m	long
->	O
ncxt	int
=	O
0	int
;	O
m	long
->	O
numeric_arg	int
=	O
-	O
1	int
;	O
m	long
->	O
start	int
=	O
rl_point	int
;	O
m	long
->	O
end	int
=	O
rl_end	int
;	O
m	long
->	O
key	int
=	O
key	int
;	O
m	long
->	O
motion	int
=	O
-	O
1	int
;	O
}	O
static	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
_rl_mvcxt_alloc	(int,int)->(*(struct(int,int,int,int,int,int,int,int,int)))
(	O
op	int
,	O
key	int
)	O
int	O
op	int
,	O
key	int
;	O
{	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
m	long
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
)	O
)	O
;	O
_rl_mvcxt_init	(*(struct(int,int,int,int,int,int,int,int,int)),int,int)->(void)
(	O
m	long
,	O
op	int
,	O
key	int
)	O
;	O
return	O
m	long
;	O
}	O
static	O
void	O
_rl_mvcxt_dispose	(*(struct(int,int,int,int,int,int,int,int,int)))->(void)
(	O
m	long
)	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
{	O
xfree	(*(void))->(void)
(	O
m	long
)	O
;	O
}	O
static	O
int	O
rl_domove_motion_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
{	O
int	O
c	int
;	O
_rl_vi_last_motion	int
=	O
c	int
=	O
m	long
->	O
motion	int
;	O
rl_line_buffer	*(char)
[	O
rl_end	int
++	O
]	O
=	O
' '	O
;	O
rl_line_buffer	*(char)
[	O
rl_end	int
]	O
=	O
'\0'	O
;	O
_rl_dispatch	(int,*(struct(char,*((int,int)->(int)))))->(int)
(	O
c	int
,	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CHARSEARCH	int
)	O
)	O
return	O
0	int
;	O
else	O
return	O
(	O
_rl_vi_domove_motion_cleanup	(int,*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
c	int
,	O
m	long
)	O
)	O
;	O
}	O
return	O
(	O
_rl_vi_domove_motion_cleanup	(int,*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
c	int
,	O
m	long
)	O
)	O
;	O
}	O
int	O
_rl_vi_domove_motion_cleanup	(int,*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
c	int
,	O
m	long
)	O
int	O
c	int
;	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
{	O
int	O
r	int
;	O
rl_end	int
=	O
m	long
->	O
end	int
;	O
rl_line_buffer	*(char)
[	O
rl_end	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
rl_point	int
>	O
rl_end	int
)	O
rl_point	int
=	O
rl_end	int
;	O
if	O
(	O
rl_mark	int
==	O
rl_point	int
)	O
{	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
_rl_to_upper	(int)->(int)
(	O
c	int
)	O
==	O
'W'	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
&&	O
rl_point	int
>	O
rl_mark	int
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
if	O
(	O
m	long
->	O
key	int
==	O
'c'	O
&&	O
rl_point	int
>=	O
rl_mark	int
&&	O
(	O
_rl_to_upper	(int)->(int)
(	O
c	int
)	O
==	O
'W'	O
)	O
)	O
{	O
while	O
(	O
rl_point	int
>	O
rl_mark	int
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
if	O
(	O
rl_point	int
==	O
rl_mark	int
)	O
rl_point	int
++	O
;	O
else	O
{	O
if	O
(	O
rl_point	int
>=	O
0	int
&&	O
rl_point	int
<	O
(	O
rl_end	int
-	O
1	int
)	O
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
}	O
}	O
if	O
(	O
rl_mark	int
<	O
rl_point	int
)	O
SWAP	O
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
(	O
*	O
rl_redisplay_function	*(()->(void))
)	O
(	O
)	O
;	O
r	int
=	O
vidomove_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
;	O
return	O
(	O
r	int
)	O
;	O
}	O
static	O
int	O
rl_domove_read_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
{	O
int	O
c	int
,	O
save	int
;	O
c	int
=	O
m	long
->	O
motion	int
;	O
if	O
(	O
member	O
(	O
c	int
,	O
vi_motion	*(char)
)	O
)	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
&&	O
RL_VIMOVENUMARG	O
(	O
)	O
)	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
return	O
(	O
rl_domove_motion_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
)	O
;	O
}	O
else	O
if	O
(	O
m	long
->	O
key	int
==	O
c	int
&&	O
(	O
m	long
->	O
key	int
==	O
'd'	O
||	O
m	long
->	O
key	int
==	O
'y'	O
||	O
m	long
->	O
key	int
==	O
'c'	O
)	O
)	O
{	O
rl_mark	int
=	O
rl_end	int
;	O
rl_beg_of_line	(int,int)->(int)
(	O
1	int
,	O
c	int
)	O
;	O
_rl_vi_last_motion	int
=	O
c	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
(	O
vidomove_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_digit_p	(int)->(int)
(	O
c	int
)	O
&&	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
&&	O
RL_VIMOVENUMARG	O
(	O
)	O
)	O
{	O
return	O
(	O
_rl_vi_arg_dispatch	(int)->(int)
(	O
c	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_digit_p	(int)->(int)
(	O
c	int
)	O
&&	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
&&	O
RL_ISSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
&&	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
==	O
0	int
)	O
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
return	O
(	O
_rl_vi_arg_dispatch	(int)->(int)
(	O
c	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_digit_p	(int)->(int)
(	O
c	int
)	O
)	O
{	O
save	int
=	O
rl_numeric_arg	int
;	O
rl_numeric_arg	int
=	O
_rl_digit_value	(int)->(int)
(	O
c	int
)	O
;	O
rl_explicit_arg	int
=	O
1	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
rl_digit_loop1	()->(int)
(	O
)	O
;	O
rl_numeric_arg	int
*=	O
save	int
;	O
c	int
=	O
rl_vi_domove_getchar	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
{	O
m	long
->	O
motion	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
m	long
->	O
motion	int
=	O
c	int
;	O
return	O
(	O
rl_domove_motion_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
)	O
;	O
}	O
else	O
{	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
static	O
int	O
rl_vi_domove_getchar	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
{	O
int	O
c	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
c	int
=	O
rl_read_key	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
return	O
c	int
;	O
}	O
int	O
_rl_vi_domove_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
{	O
int	O
c	int
,	O
r	int
;	O
m	long
->	O
motion	int
=	O
c	int
=	O
rl_vi_domove_getchar	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
1	int
;	O
r	int
=	O
rl_domove_read_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
;	O
return	O
(	O
(	O
r	int
==	O
0	int
)	O
?	O
r	int
:	O
1	int
)	O
;	O
}	O
int	O
rl_vi_domove	(int,*(int))->(int)
(	O
x	int
,	O
ignore	int
)	O
int	O
x	int
,	O
*	O
ignore	int
;	O
{	O
int	O
r	int
;	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
m	long
=	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
;	O
*	O
ignore	int
=	O
m	long
->	O
motion	int
=	O
rl_vi_domove_getchar	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
;	O
if	O
(	O
m	long
->	O
motion	int
<	O
0	int
)	O
{	O
m	long
->	O
motion	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
(	O
rl_domove_read_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
)	O
;	O
}	O
static	O
int	O
vi_delete_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
{	O
if	O
(	O
(	O
(	O
strchr	(*(char),int)->(*(char))
(	O
" l|h^0bBFT`"	*(char)
,	O
m	long
->	O
motion	int
)	O
==	O
0	int
)	O
&&	O
(	O
rl_point	int
>=	O
m	long
->	O
start	int
)	O
)	O
&&	O
(	O
rl_mark	int
<	O
rl_end	int
)	O
)	O
rl_mark	int
++	O
;	O
rl_kill_text	(int,int)->(int)
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_delete_to	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
,	O
r	int
;	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
=	O
_rl_mvcxt_alloc	(int,int)->(*(struct(int,int,int,int,int,int,int,int,int)))
(	O
VIM_DELETE	int
,	O
key	int
)	O
;	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
start	int
=	O
rl_point	int
;	O
rl_mark	int
=	O
rl_point	int
;	O
if	O
(	O
_rl_uppercase_p	(int)->(int)
(	O
key	int
)	O
)	O
{	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
motion	int
=	O
'$'	O
;	O
r	int
=	O
rl_domove_motion_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
&&	O
_rl_vi_last_motion	int
!=	O
'd'	O
)	O
{	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
r	int
=	O
rl_domove_motion_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
rl_mark	int
=	O
rl_end	int
;	O
rl_beg_of_line	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
r	int
=	O
vidomove_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
r	int
=	O
rl_vi_domove	(int,*(int))->(int)
(	O
key	int
,	O
&	O
c	int
)	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
r	int
=	O
-	O
1	int
;	O
}	O
_rl_mvcxt_dispose	(*(struct(int,int,int,int,int,int,int,int,int)))->(void)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
=	O
0	int
;	O
return	O
r	int
;	O
}	O
static	O
int	O
vi_change_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
{	O
if	O
(	O
(	O
(	O
strchr	(*(char),int)->(*(char))
(	O
" l|hwW^0bBFT`"	*(char)
,	O
m	long
->	O
motion	int
)	O
==	O
0	int
)	O
&&	O
(	O
rl_point	int
>=	O
m	long
->	O
start	int
)	O
)	O
&&	O
(	O
rl_mark	int
<	O
rl_end	int
)	O
)	O
rl_mark	int
++	O
;	O
if	O
(	O
(	O
_rl_to_upper	(int)->(int)
(	O
m	long
->	O
motion	int
)	O
==	O
'W'	O
)	O
&&	O
rl_point	int
<	O
m	long
->	O
start	int
)	O
rl_point	int
=	O
m	long
->	O
start	int
;	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
if	O
(	O
vi_insert_buffer	*(char)
&&	O
*	O
vi_insert_buffer	*(char)
)	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
rl_delete_text	(int,int)->(int)
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
if	O
(	O
vi_insert_buffer	*(char)
&&	O
*	O
vi_insert_buffer	*(char)
)	O
{	O
rl_insert_text	(*(char))->(int)
(	O
vi_insert_buffer	*(char)
)	O
;	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
}	O
}	O
else	O
{	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
rl_kill_text	(int,int)->(int)
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
if	O
(	O
_rl_uppercase_p	(int)->(int)
(	O
m	long
->	O
key	int
)	O
==	O
0	int
)	O
_rl_vi_doing_insert	int
=	O
1	int
;	O
rl_vi_start_inserting	(int,int,int)->(void)
(	O
m	long
->	O
key	int
,	O
rl_numeric_arg	int
,	O
rl_arg_sign	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_change_to	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
,	O
r	int
;	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
=	O
_rl_mvcxt_alloc	(int,int)->(*(struct(int,int,int,int,int,int,int,int,int)))
(	O
VIM_CHANGE	int
,	O
key	int
)	O
;	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
start	int
=	O
rl_point	int
;	O
rl_mark	int
=	O
rl_point	int
;	O
if	O
(	O
_rl_uppercase_p	(int)->(int)
(	O
key	int
)	O
)	O
{	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
motion	int
=	O
'$'	O
;	O
r	int
=	O
rl_domove_motion_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
&&	O
_rl_vi_last_motion	int
!=	O
'c'	O
)	O
{	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
r	int
=	O
rl_domove_motion_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
rl_mark	int
=	O
rl_end	int
;	O
rl_beg_of_line	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
r	int
=	O
vidomove_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
r	int
=	O
rl_vi_domove	(int,*(int))->(int)
(	O
key	int
,	O
&	O
c	int
)	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
r	int
=	O
-	O
1	int
;	O
}	O
_rl_mvcxt_dispose	(*(struct(int,int,int,int,int,int,int,int,int)))->(void)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
=	O
0	int
;	O
return	O
r	int
;	O
}	O
static	O
int	O
vi_yank_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
{	O
if	O
(	O
(	O
(	O
strchr	(*(char),int)->(*(char))
(	O
" l|h^0%bBFT`"	*(char)
,	O
m	long
->	O
motion	int
)	O
==	O
0	int
)	O
&&	O
(	O
rl_point	int
>=	O
m	long
->	O
start	int
)	O
)	O
&&	O
(	O
rl_mark	int
<	O
rl_end	int
)	O
)	O
rl_mark	int
++	O
;	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
rl_kill_text	(int,int)->(int)
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
rl_do_undo	()->(int)
(	O
)	O
;	O
rl_point	int
=	O
m	long
->	O
start	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_yank_to	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
,	O
r	int
;	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
=	O
_rl_mvcxt_alloc	(int,int)->(*(struct(int,int,int,int,int,int,int,int,int)))
(	O
VIM_YANK	int
,	O
key	int
)	O
;	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
start	int
=	O
rl_point	int
;	O
rl_mark	int
=	O
rl_point	int
;	O
if	O
(	O
_rl_uppercase_p	(int)->(int)
(	O
key	int
)	O
)	O
{	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
motion	int
=	O
'$'	O
;	O
r	int
=	O
rl_domove_motion_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
&&	O
_rl_vi_last_motion	int
!=	O
'y'	O
)	O
{	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
r	int
=	O
rl_domove_motion_callback	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
rl_mark	int
=	O
rl_end	int
;	O
rl_beg_of_line	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
r	int
=	O
vidomove_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
r	int
=	O
rl_vi_domove	(int,*(int))->(int)
(	O
key	int
,	O
&	O
c	int
)	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
r	int
=	O
-	O
1	int
;	O
}	O
_rl_mvcxt_dispose	(*(struct(int,int,int,int,int,int,int,int,int)))->(void)
(	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
)	O
;	O
_rl_vimvcxt	*(struct(int,int,int,int,int,int,int,int,int))
=	O
0	int
;	O
return	O
r	int
;	O
}	O
static	O
int	O
vidomove_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
_rl_vimotion_cxt	struct(int,int,int,int,int,int,int,int,int)
*	O
m	long
;	O
{	O
int	O
r	int
;	O
switch	O
(	O
m	long
->	O
op	int
)	O
{	O
case	O
VIM_DELETE	int
:	O
r	int
=	O
vi_delete_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
;	O
break	O
;	O
case	O
VIM_CHANGE	int
:	O
r	int
=	O
vi_change_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
;	O
break	O
;	O
case	O
VIM_YANK	int
:	O
r	int
=	O
vi_yank_dispatch	(*(struct(int,int,int,int,int,int,int,int,int)))->(int)
(	O
m	long
)	O
;	O
break	O
;	O
default	O
:	O
_rl_errmsg	(*(char))->(void)
(	O
"vidomove_dispatch: unknown operator %d"	*(char)
,	O
m	long
->	O
op	int
)	O
;	O
r	int
=	O
1	int
;	O
break	O
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
r	int
;	O
}	O
int	O
rl_vi_rubout	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
opoint	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_vi_delete	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
opoint	int
=	O
rl_point	int
;	O
if	O
(	O
count	int
>	O
1	int
&&	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_backward_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
else	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_point	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
else	O
rl_point	int
-=	O
count	int
;	O
if	O
(	O
rl_point	int
<	O
0	int
)	O
rl_point	int
=	O
0	int
;	O
rl_kill_text	(int,int)->(int)
(	O
rl_point	int
,	O
opoint	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_delete	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
end	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_vi_rubout	(int,int)->(int)
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_end	int
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
end	int
=	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
rl_point	int
,	O
count	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
else	O
end	int
=	O
rl_point	int
+	O
count	int
;	O
if	O
(	O
end	int
>=	O
rl_end	int
)	O
end	int
=	O
rl_end	int
;	O
rl_kill_text	(int,int)->(int)
(	O
rl_point	int
,	O
end	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
&&	O
rl_point	int
==	O
rl_end	int
)	O
rl_backward_char	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_unix_word_rubout	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
orig_point	int
;	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
rl_ding	()->(int)
(	O
)	O
;	O
else	O
{	O
orig_point	int
=	O
rl_point	int
;	O
if	O
(	O
count	int
<=	O
0	int
)	O
count	int
=	O
1	int
;	O
while	O
(	O
count	int
--	O
)	O
{	O
if	O
(	O
rl_point	int
>	O
0	int
&&	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
==	O
0	int
)	O
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
while	O
(	O
--	O
rl_point	int
>	O
0	int
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
&&	O
(	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
==	O
0	int
)	O
&&	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
&&	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
while	O
(	O
rl_point	int
&&	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
else	O
if	O
(	O
rl_point	int
>	O
0	int
&&	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
==	O
0	int
)	O
while	O
(	O
rl_point	int
&&	O
(	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
-	O
1	int
]	O
)	O
==	O
0	int
)	O
)	O
rl_point	int
--	O
;	O
}	O
rl_kill_text	(int,int)->(int)
(	O
orig_point	int
,	O
rl_point	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_vi_back_to_indent	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_beg_of_line	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
whitespace	O
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_first_print	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_vi_back_to_indent	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
)	O
;	O
}	O
static	O
int	O
_rl_cs_dir	int
,	O
_rl_cs_orig_dir	int
;	O
static	O
int	O
_rl_vi_callback_char_search	(*(struct(int,int,int)))->(int)
(	O
data	*(void)
)	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
data	*(void)
;	O
{	O
int	O
c	int
;	O
c	int
=	O
_rl_vi_last_search_mblen	int
=	O
_rl_read_mbchar	(*(char),int)->(int)
(	O
_rl_vi_last_search_mbchar	array(char)
,	O
MB_LEN_MAX	int
)	O
;	O
if	O
(	O
c	int
<=	O
0	int
)	O
{	O
RL_UNSETSTATE	O
(	O
RL_STATE_CHARSEARCH	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_CHARSEARCH	int
)	O
;	O
return	O
(	O
_rl_char_search_internal	(int,int,*(char),int)->(int)
(	O
data	*(void)
->	O
count	int
,	O
_rl_cs_dir	int
,	O
_rl_vi_last_search_mbchar	array(char)
,	O
_rl_vi_last_search_mblen	int
)	O
)	O
;	O
}	O
int	O
rl_vi_char_search	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
;	O
static	O
char	O
*	O
target	*(char)
;	O
static	O
int	O
tlen	int
;	O
if	O
(	O
key	int
==	O
';'	O
||	O
key	int
==	O
','	O
)	O
{	O
if	O
(	O
_rl_cs_orig_dir	int
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
_rl_vi_last_search_mblen	int
==	O
0	int
)	O
return	O
1	int
;	O
_rl_cs_dir	int
=	O
(	O
key	int
==	O
';'	O
)	O
?	O
_rl_cs_orig_dir	int
:	O
-	O
_rl_cs_orig_dir	int
;	O
}	O
else	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
't'	O
:	O
_rl_cs_orig_dir	int
=	O
_rl_cs_dir	int
=	O
FTO	int
;	O
break	O
;	O
case	O
'T'	O
:	O
_rl_cs_orig_dir	int
=	O
_rl_cs_dir	int
=	O
BTO	O
;	O
break	O
;	O
case	O
'f'	O
:	O
_rl_cs_orig_dir	int
=	O
_rl_cs_dir	int
=	O
FFIND	int
;	O
break	O
;	O
case	O
'F'	O
:	O
_rl_cs_orig_dir	int
=	O
_rl_cs_dir	int
=	O
BFIND	O
;	O
break	O
;	O
}	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	*(struct(int,int,int))
=	O
_rl_callback_data_alloc	(int)->(*(struct(int,int,int)))
(	O
count	int
)	O
;	O
_rl_callback_data	*(struct(int,int,int))
->	O
i1	int
=	O
_rl_cs_dir	int
;	O
_rl_callback_data	*(struct(int,int,int))
->	O
i2	int
=	O
key	int
;	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
_rl_vi_callback_char_search	(*(struct(int,int,int)))->(int)
;	O
RL_SETSTATE	O
(	O
RL_STATE_CHARSEARCH	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
c	int
=	O
_rl_read_mbchar	(*(char),int)->(int)
(	O
_rl_vi_last_search_mbchar	array(char)
,	O
MB_LEN_MAX	int
)	O
;	O
if	O
(	O
c	int
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
_rl_vi_last_search_mblen	int
=	O
c	int
;	O
}	O
}	O
target	*(char)
=	O
_rl_vi_last_search_mbchar	array(char)
;	O
tlen	int
=	O
_rl_vi_last_search_mblen	int
;	O
return	O
(	O
_rl_char_search_internal	(int,int,*(char),int)->(int)
(	O
count	int
,	O
_rl_cs_dir	int
,	O
target	*(char)
,	O
tlen	int
)	O
)	O
;	O
}	O
int	O
rl_vi_match	(int,int)->(int)
(	O
ignore	int
,	O
key	int
)	O
int	O
ignore	int
,	O
key	int
;	O
{	O
int	O
count	int
=	O
1	int
,	O
brack	int
,	O
pos	int
,	O
tmp	int
,	O
pre	int
;	O
pos	int
=	O
rl_point	int
;	O
if	O
(	O
(	O
brack	int
=	O
rl_vi_bracktype	(int)->(int)
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
while	O
(	O
(	O
brack	int
=	O
rl_vi_bracktype	(int)->(int)
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
pre	int
=	O
rl_point	int
;	O
rl_forward_char	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
if	O
(	O
pre	int
==	O
rl_point	int
)	O
break	O
;	O
}	O
}	O
else	O
while	O
(	O
(	O
brack	int
=	O
rl_vi_bracktype	(int)->(int)
(	O
rl_line_buffer	*(char)
[	O
rl_point	int
]	O
)	O
)	O
==	O
0	int
&&	O
rl_point	int
<	O
rl_end	int
-	O
1	int
)	O
rl_forward_char	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
if	O
(	O
brack	int
<=	O
0	int
)	O
{	O
rl_point	int
=	O
pos	int
;	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
pos	int
=	O
rl_point	int
;	O
if	O
(	O
brack	int
<	O
0	int
)	O
{	O
while	O
(	O
count	int
)	O
{	O
tmp	int
=	O
pos	int
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
pos	int
--	O
;	O
else	O
{	O
pos	int
=	O
_rl_find_prev_mbchar	(*(char),int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
pos	int
,	O
MB_FIND_ANY	int
)	O
;	O
if	O
(	O
tmp	int
==	O
pos	int
)	O
pos	int
--	O
;	O
}	O
if	O
(	O
pos	int
>=	O
0	int
)	O
{	O
int	O
b	int
=	O
rl_vi_bracktype	(int)->(int)
(	O
rl_line_buffer	*(char)
[	O
pos	int
]	O
)	O
;	O
if	O
(	O
b	int
==	O
-	O
brack	int
)	O
count	int
--	O
;	O
else	O
if	O
(	O
b	int
==	O
brack	int
)	O
count	int
++	O
;	O
}	O
else	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
while	O
(	O
count	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
pos	int
++	O
;	O
else	O
pos	int
=	O
_rl_find_next_mbchar	(*(char),int,int,int)->(int)
(	O
rl_line_buffer	*(char)
,	O
pos	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
;	O
if	O
(	O
pos	int
<	O
rl_end	int
)	O
{	O
int	O
b	int
=	O
rl_vi_bracktype	(int)->(int)
(	O
rl_line_buffer	*(char)
[	O
pos	int
]	O
)	O
;	O
if	O
(	O
b	int
==	O
-	O
brack	int
)	O
count	int
--	O
;	O
else	O
if	O
(	O
b	int
==	O
brack	int
)	O
count	int
++	O
;	O
}	O
else	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
rl_point	int
=	O
pos	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_bracktype	(int)->(int)
(	O
c	int
)	O
int	O
c	int
;	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'('	O
:	O
return	O
1	int
;	O
case	O
')'	O
:	O
return	O
-	O
1	int
;	O
case	O
'['	O
:	O
return	O
2	int
;	O
case	O
']'	O
:	O
return	O
-	O
2	int
;	O
case	O
'{'	O
:	O
return	O
3	int
;	O
case	O
'}'	O
:	O
return	O
-	O
3	int
;	O
default	O
:	O
return	O
0	int
;	O
}	O
}	O
static	O
int	O
_rl_vi_change_char	(int,int,*(char))->(int)
(	O
count	int
,	O
c	int
,	O
mb	array(char)
)	O
int	O
count	int
,	O
c	int
;	O
char	O
*	O
mb	array(char)
;	O
{	O
int	O
p	int
;	O
if	O
(	O
c	int
==	O
'\033'	O
||	O
c	int
==	O
CTRL	O
(	O
'C'	O
)	O
)	O
return	O
-	O
1	int
;	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
{	O
p	int
=	O
rl_point	int
;	O
rl_vi_delete	(int,int)->(int)
(	O
1	int
,	O
c	int
)	O
;	O
if	O
(	O
rl_point	int
<	O
p	int
)	O
rl_point	int
++	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_insert_text	(*(char))->(int)
(	O
mb	array(char)
)	O
;	O
else	O
_rl_insert_char	(int,int)->(int)
(	O
1	int
,	O
c	int
)	O
;	O
}	O
rl_backward_char	(int,int)->(int)
(	O
1	int
,	O
c	int
)	O
;	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
_rl_vi_callback_getchar	(*(char),int)->(int)
(	O
mb	array(char)
,	O
mlen	int
)	O
char	O
*	O
mb	array(char)
;	O
int	O
mlen	int
;	O
{	O
int	O
c	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
c	int
=	O
rl_read_key	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
c	int
=	O
_rl_read_mbstring	(int,*(char),int)->(int)
(	O
c	int
,	O
mb	array(char)
,	O
mlen	int
)	O
;	O
return	O
c	int
;	O
}	O
static	O
int	O
_rl_vi_callback_change_char	(*(struct(int,int,int)))->(int)
(	O
data	*(void)
)	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
data	*(void)
;	O
{	O
int	O
c	int
;	O
char	O
mb	array(char)
[	O
MB_LEN_MAX	int
]	O
;	O
_rl_vi_last_replacement	int
=	O
c	int
=	O
_rl_vi_callback_getchar	(*(char),int)->(int)
(	O
mb	array(char)
,	O
MB_LEN_MAX	int
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
return	O
(	O
_rl_vi_change_char	(int,int,*(char))->(int)
(	O
data	*(void)
->	O
count	int
,	O
c	int
,	O
mb	array(char)
)	O
)	O
;	O
}	O
int	O
rl_vi_change_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
;	O
char	O
mb	array(char)
[	O
MB_LEN_MAX	int
]	O
;	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
c	int
=	O
_rl_vi_last_replacement	int
;	O
mb	array(char)
[	O
0	int
]	O
=	O
c	int
;	O
mb	array(char)
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	*(struct(int,int,int))
=	O
_rl_callback_data_alloc	(int)->(*(struct(int,int,int)))
(	O
count	int
)	O
;	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
_rl_vi_callback_change_char	(*(struct(int,int,int)))->(int)
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
_rl_vi_last_replacement	int
=	O
c	int
=	O
_rl_vi_callback_getchar	(*(char),int)->(int)
(	O
mb	array(char)
,	O
MB_LEN_MAX	int
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
(	O
_rl_vi_change_char	(int,int,*(char))->(int)
(	O
count	int
,	O
c	int
,	O
mb	array(char)
)	O
)	O
;	O
}	O
int	O
rl_vi_subst	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
_rl_vi_redoing	int
==	O
0	int
)	O
rl_stuff_char	(int)->(int)
(	O
(	O
key	int
==	O
'S'	O
)	O
?	O
'c'	O
:	O
'l'	O
)	O
;	O
return	O
(	O
rl_vi_change_to	(int,int)->(int)
(	O
count	int
,	O
'c'	O
)	O
)	O
;	O
}	O
int	O
rl_vi_overstrike	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
_rl_vi_doing_insert	int
==	O
0	int
)	O
{	O
_rl_vi_doing_insert	int
=	O
1	int
;	O
rl_begin_undo_group	()->(int)
(	O
)	O
;	O
}	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
_rl_overwrite_char	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
;	O
vi_replace_count	int
+=	O
count	int
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_overstrike_delete	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
i	int
,	O
s	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
vi_replace_count	int
==	O
0	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
break	O
;	O
}	O
s	int
=	O
rl_point	int
;	O
if	O
(	O
rl_do_undo	()->(int)
(	O
)	O
)	O
vi_replace_count	int
--	O
;	O
if	O
(	O
rl_point	int
==	O
s	int
)	O
rl_backward_char	(int,int)->(int)
(	O
1	int
,	O
key	int
)	O
;	O
}	O
if	O
(	O
vi_replace_count	int
==	O
0	int
&&	O
_rl_vi_doing_insert	int
)	O
{	O
rl_end_undo_group	()->(int)
(	O
)	O
;	O
rl_do_undo	()->(int)
(	O
)	O
;	O
_rl_vi_doing_insert	int
=	O
0	int
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_replace	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
i	int
;	O
vi_replace_count	int
=	O
0	int
;	O
if	O
(	O
vi_replace_map	*(struct(char,*((int,int)->(int))))
==	O
0	int
)	O
{	O
vi_replace_map	*(struct(char,*((int,int)->(int))))
=	O
rl_make_bare_keymap	()->(*(struct(char,*((int,int)->(int)))))
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
' '	O
;	O
i	int
++	O
)	O
if	O
(	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
[	O
i	int
]	O
.	O
type	char
==	O
ISFUNC	int
)	O
vi_replace_map	*(struct(char,*((int,int)->(int))))
[	O
i	int
]	O
.	O
function	*((int,int)->(int))
=	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
[	O
i	int
]	O
.	O
function	*((int,int)->(int))
;	O
for	O
(	O
i	int
=	O
' '	O
;	O
i	int
<	O
KEYMAP_SIZE	int
;	O
i	int
++	O
)	O
vi_replace_map	*(struct(char,*((int,int)->(int))))
[	O
i	int
]	O
.	O
function	*((int,int)->(int))
=	O
rl_vi_overstrike	(int,int)->(int)
;	O
vi_replace_map	*(struct(char,*((int,int)->(int))))
[	O
RUBOUT	int
]	O
.	O
function	*((int,int)->(int))
=	O
rl_vi_overstrike_delete	(int,int)->(int)
;	O
vi_replace_map	*(struct(char,*((int,int)->(int))))
[	O
ESC	O
]	O
.	O
function	*((int,int)->(int))
=	O
rl_vi_movement_mode	(int,int)->(int)
;	O
vi_replace_map	*(struct(char,*((int,int)->(int))))
[	O
RETURN	O
]	O
.	O
function	*((int,int)->(int))
=	O
rl_newline	(int,int)->(int)
;	O
vi_replace_map	*(struct(char,*((int,int)->(int))))
[	O
NEWLINE	char
]	O
.	O
function	*((int,int)->(int))
=	O
rl_newline	(int,int)->(int)
;	O
if	O
(	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
[	O
CTRL	O
(	O
'H'	O
)	O
]	O
.	O
type	char
==	O
ISFUNC	int
&&	O
vi_insertion_keymap	array(struct(char,*((int,int)->(int))))
[	O
CTRL	O
(	O
'H'	O
)	O
]	O
.	O
function	*((int,int)->(int))
==	O
rl_rubout	(int,int)->(int)
)	O
vi_replace_map	*(struct(char,*((int,int)->(int))))
[	O
CTRL	O
(	O
'H'	O
)	O
]	O
.	O
function	*((int,int)->(int))
=	O
rl_vi_overstrike_delete	(int,int)->(int)
;	O
}	O
rl_vi_start_inserting	(int,int,int)->(void)
(	O
key	int
,	O
1	int
,	O
rl_arg_sign	int
)	O
;	O
_rl_vi_last_key_before_insert	int
=	O
key	int
;	O
_rl_keymap	*(struct(char,*((int,int)->(int))))
=	O
vi_replace_map	*(struct(char,*((int,int)->(int))))
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
_rl_vi_set_mark	()->(int)
(	O
)	O
{	O
int	O
ch	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
ch	int
=	O
rl_read_key	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
ch	int
<	O
0	int
||	O
ch	int
<	O
'a'	O
||	O
ch	int
>	O
'z'	O
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
ch	int
-=	O
'a'	O
;	O
vi_mark_chars	array(int)
[	O
ch	int
]	O
=	O
rl_point	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_rl_vi_callback_set_mark	(*(struct(int,int,int)))->(int)
(	O
data	*(void)
)	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
data	*(void)
;	O
{	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
return	O
(	O
_rl_vi_set_mark	()->(int)
(	O
)	O
)	O
;	O
}	O
int	O
rl_vi_set_mark	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	*(struct(int,int,int))
=	O
0	int
;	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
_rl_vi_callback_set_mark	(*(struct(int,int,int)))->(int)
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
_rl_vi_set_mark	()->(int)
(	O
)	O
)	O
;	O
}	O
static	O
int	O
_rl_vi_goto_mark	()->(int)
(	O
)	O
{	O
int	O
ch	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
ch	int
=	O
rl_read_key	()->(int)
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
ch	int
==	O
'`'	O
)	O
{	O
rl_point	int
=	O
rl_mark	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
ch	int
<	O
0	int
||	O
ch	int
<	O
'a'	O
||	O
ch	int
>	O
'z'	O
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
ch	int
-=	O
'a'	O
;	O
if	O
(	O
vi_mark_chars	array(int)
[	O
ch	int
]	O
==	O
-	O
1	int
)	O
{	O
rl_ding	()->(int)
(	O
)	O
;	O
return	O
1	int
;	O
}	O
rl_point	int
=	O
vi_mark_chars	array(int)
[	O
ch	int
]	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_rl_vi_callback_goto_mark	(*(struct(int,int,int)))->(int)
(	O
data	*(void)
)	O
_rl_callback_generic_arg	struct(int,int,int)
*	O
data	*(void)
;	O
{	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
return	O
(	O
_rl_vi_goto_mark	()->(int)
(	O
)	O
)	O
;	O
}	O
int	O
rl_vi_goto_mark	(int,int)->(int)
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	*(struct(int,int,int))
=	O
0	int
;	O
_rl_callback_func	*((*(struct(int,int,int)))->(int))
=	O
_rl_vi_callback_goto_mark	(*(struct(int,int,int)))->(int)
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
_rl_vi_goto_mark	()->(int)
(	O
)	O
)	O
;	O
}	O
