static	O
inline	O
ssize_t	long
http_method	(int,*(struct(*(char),int,*(char),int,*(char),*(char))),enum(int,int,int,int,int,int,int),long)->(long)
(	O
int	O
fd	int
,	O
Http_destination	struct(*(char),int,*(char),int,*(char),*(char))
*	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
,	O
Http_method	enum(int,int,int,int,int,int,int)
method	enum(int,int,int,int,int,int,int)
,	O
ssize_t	long
length	long
)	O
{	O
char	O
str	*(*(char))
[	O
1024	int
]	O
;	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
;	O
ssize_t	long
n	long
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"http_method: fd == -1"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
n	long
=	O
0	int
;	O
if	O
(	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
->	O
proxy_name	*(char)
!=	O
NULL	O
)	O
n	long
=	O
sprintf	(*(char),*(char))->(int)
(	O
str	*(*(char))
,	O
"http://%s:%d"	*(char)
,	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
->	O
host_name	*(char)
,	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
->	O
host_port	int
)	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
str	*(*(char))
+	O
n	long
,	O
"/index.html?crap=%ld"	*(char)
,	O
time	(*(long))->(long)
(	O
NULL	O
)	O
)	O
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
=	O
http_create_request	(enum(int,int,int,int,int,int,int),*(char),int,int)->(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
(	O
method	enum(int,int,int,int,int,int,int)
,	O
str	*(*(char))
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
sprintf	(*(char),*(char))->(int)
(	O
str	*(*(char))
,	O
"%s:%d"	*(char)
,	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
->	O
host_name	*(char)
,	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
->	O
host_port	int
)	O
;	O
http_add_header	(*(*(struct(*(char),*(char),*(struct`)))),*(char),*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
(	O
&	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
,	O
"Host"	*(char)
,	O
str	*(*(char))
)	O
;	O
if	O
(	O
length	long
>=	O
0	int
)	O
{	O
sprintf	(*(char),*(char))->(int)
(	O
str	*(*(char))
,	O
"%d"	*(char)
,	O
length	long
)	O
;	O
http_add_header	(*(*(struct(*(char),*(char),*(struct`)))),*(char),*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
(	O
&	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
,	O
"Content-Length"	*(char)
,	O
str	*(*(char))
)	O
;	O
}	O
http_add_header	(*(*(struct(*(char),*(char),*(struct`)))),*(char),*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
(	O
&	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
,	O
"Connection"	*(char)
,	O
"close"	*(char)
)	O
;	O
if	O
(	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
->	O
proxy_authorization	*(char)
)	O
{	O
http_add_header	(*(*(struct(*(char),*(char),*(struct`)))),*(char),*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
(	O
&	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
,	O
"Proxy-Authorization"	*(char)
,	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
->	O
proxy_authorization	*(char)
)	O
;	O
}	O
if	O
(	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
->	O
user_agent	*(char)
)	O
{	O
http_add_header	(*(*(struct(*(char),*(char),*(struct`)))),*(char),*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
(	O
&	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
,	O
"User-Agent"	*(char)
,	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
->	O
user_agent	*(char)
)	O
;	O
}	O
n	long
=	O
http_write_request	(int,*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(long)
(	O
fd	int
,	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
http_destroy_request	(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
ssize_t	long
http_get	(int,*(struct(*(char),int,*(char),int,*(char),*(char))))->(long)
(	O
int	O
fd	int
,	O
Http_destination	struct(*(char),int,*(char),int,*(char),*(char))
*	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
)	O
{	O
return	O
http_method	(int,*(struct(*(char),int,*(char),int,*(char),*(char))),enum(int,int,int,int,int,int,int),long)->(long)
(	O
fd	int
,	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
,	O
HTTP_GET	int
,	O
-	O
1	int
)	O
;	O
}	O
ssize_t	long
http_put	(int,*(struct(*(char),int,*(char),int,*(char),*(char))),long)->(long)
(	O
int	O
fd	int
,	O
Http_destination	struct(*(char),int,*(char),int,*(char),*(char))
*	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
,	O
size_t	long
length	long
)	O
{	O
return	O
http_method	(int,*(struct(*(char),int,*(char),int,*(char),*(char))),enum(int,int,int,int,int,int,int),long)->(long)
(	O
fd	int
,	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
,	O
HTTP_PUT	int
,	O
(	O
ssize_t	long
)	O
length	long
)	O
;	O
}	O
ssize_t	long
http_post	(int,*(struct(*(char),int,*(char),int,*(char),*(char))),long)->(long)
(	O
int	O
fd	int
,	O
Http_destination	struct(*(char),int,*(char),int,*(char),*(char))
*	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
,	O
size_t	long
length	long
)	O
{	O
return	O
http_method	(int,*(struct(*(char),int,*(char),int,*(char),*(char))),enum(int,int,int,int,int,int,int),long)->(long)
(	O
fd	int
,	O
dest	*(struct(*(char),int,*(char),int,*(char),*(char)))
,	O
HTTP_POST	int
,	O
(	O
ssize_t	long
)	O
length	long
)	O
;	O
}	O
int	O
http_error_to_errno	(int)->(int)
(	O
int	O
err	int
)	O
{	O
switch	O
(	O
err	int
)	O
{	O
case	O
-	O
1	int
:	O
return	O
errno	O
;	O
case	O
-	O
200	int
:	O
case	O
-	O
201	int
:	O
case	O
-	O
202	int
:	O
case	O
-	O
203	int
:	O
case	O
-	O
204	int
:	O
case	O
-	O
205	int
:	O
case	O
-	O
206	int
:	O
return	O
0	int
;	O
case	O
-	O
400	int
:	O
log_error	(*(char))->(void)
(	O
"http_error_to_errno: 400 bad request"	*(char)
)	O
;	O
return	O
EIO	int
;	O
case	O
-	O
401	int
:	O
log_error	(*(char))->(void)
(	O
"http_error_to_errno: 401 unauthorized"	*(char)
)	O
;	O
return	O
EACCES	int
;	O
case	O
-	O
403	int
:	O
log_error	(*(char))->(void)
(	O
"http_error_to_errno: 403 forbidden"	*(char)
)	O
;	O
return	O
EACCES	int
;	O
case	O
-	O
404	int
:	O
log_error	(*(char))->(void)
(	O
"http_error_to_errno: 404 not found"	*(char)
)	O
;	O
return	O
ENOENT	int
;	O
case	O
-	O
411	int
:	O
log_error	(*(char))->(void)
(	O
"http_error_to_errno: 411 length required"	*(char)
)	O
;	O
return	O
EIO	int
;	O
case	O
-	O
413	int
:	O
log_error	(*(char))->(void)
(	O
"http_error_to_errno: 413 request entity too large"	*(char)
)	O
;	O
return	O
EIO	int
;	O
case	O
-	O
505	int
:	O
log_error	(*(char))->(void)
(	O
"http_error_to_errno: 413 HTTP version not supported"	*(char)
)	O
;	O
return	O
EIO	int
;	O
case	O
-	O
100	int
:	O
case	O
-	O
101	int
:	O
case	O
-	O
300	int
:	O
case	O
-	O
301	int
:	O
case	O
-	O
302	int
:	O
case	O
-	O
303	int
:	O
case	O
-	O
304	int
:	O
case	O
-	O
305	int
:	O
case	O
-	O
402	int
:	O
case	O
-	O
405	int
:	O
case	O
-	O
406	int
:	O
case	O
-	O
407	int
:	O
case	O
-	O
408	int
:	O
case	O
-	O
409	int
:	O
case	O
-	O
410	int
:	O
case	O
-	O
412	int
:	O
case	O
-	O
414	int
:	O
case	O
-	O
415	int
:	O
case	O
-	O
500	int
:	O
case	O
-	O
501	int
:	O
case	O
-	O
502	int
:	O
case	O
-	O
503	int
:	O
case	O
-	O
504	int
:	O
log_error	(*(char))->(void)
(	O
"http_error_to_errno: HTTP error %d"	*(char)
,	O
err	int
)	O
;	O
return	O
EIO	int
;	O
default	O
:	O
log_error	(*(char))->(void)
(	O
"http_error_to_errno: unknown error %d"	*(char)
,	O
err	int
)	O
;	O
return	O
EIO	int
;	O
}	O
}	O
static	O
Http_method	enum(int,int,int,int,int,int,int)
http_string_to_method	(*(char),long)->(enum(int,int,int,int,int,int,int))
(	O
const	O
char	O
*	O
method	enum(int,int,int,int,int,int,int)
,	O
size_t	long
n	long
)	O
{	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
method	enum(int,int,int,int,int,int,int)
,	O
"GET"	*(char)
,	O
n	long
)	O
==	O
0	int
)	O
return	O
HTTP_GET	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
method	enum(int,int,int,int,int,int,int)
,	O
"PUT"	*(char)
,	O
n	long
)	O
==	O
0	int
)	O
return	O
HTTP_PUT	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
method	enum(int,int,int,int,int,int,int)
,	O
"POST"	*(char)
,	O
n	long
)	O
==	O
0	int
)	O
return	O
HTTP_POST	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
method	enum(int,int,int,int,int,int,int)
,	O
"OPTIONS"	*(char)
,	O
n	long
)	O
==	O
0	int
)	O
return	O
HTTP_OPTIONS	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
method	enum(int,int,int,int,int,int,int)
,	O
"HEAD"	*(char)
,	O
n	long
)	O
==	O
0	int
)	O
return	O
HTTP_HEAD	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
method	enum(int,int,int,int,int,int,int)
,	O
"DELETE"	*(char)
,	O
n	long
)	O
==	O
0	int
)	O
return	O
HTTP_DELETE	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
method	enum(int,int,int,int,int,int,int)
,	O
"TRACE"	*(char)
,	O
n	long
)	O
==	O
0	int
)	O
return	O
HTTP_TRACE	int
;	O
return	O
-	O
1	int
;	O
}	O
static	O
const	O
char	O
*	O
http_method_to_string	(enum(int,int,int,int,int,int,int))->(*(char))
(	O
Http_method	enum(int,int,int,int,int,int,int)
method	enum(int,int,int,int,int,int,int)
)	O
{	O
switch	O
(	O
method	enum(int,int,int,int,int,int,int)
)	O
{	O
case	O
HTTP_GET	int
:	O
return	O
"GET"	*(char)
;	O
case	O
HTTP_PUT	int
:	O
return	O
"PUT"	*(char)
;	O
case	O
HTTP_POST	int
:	O
return	O
"POST"	*(char)
;	O
case	O
HTTP_OPTIONS	int
:	O
return	O
"OPTIONS"	*(char)
;	O
case	O
HTTP_HEAD	int
:	O
return	O
"HEAD"	*(char)
;	O
case	O
HTTP_DELETE	int
:	O
return	O
"DELETE"	*(char)
;	O
case	O
HTTP_TRACE	int
:	O
return	O
"TRACE"	*(char)
;	O
}	O
return	O
"(uknown)"	*(char)
;	O
}	O
static	O
ssize_t	long
read_until	(int,int,*(*(char)))->(long)
(	O
int	O
fd	int
,	O
int	O
ch	int
,	O
unsigned	O
char	O
*	O
*	O
data	*(void)
)	O
{	O
unsigned	O
char	O
*	O
buf	*(char)
,	O
*	O
buf2	*(char)
;	O
ssize_t	long
n	long
,	O
len	long
,	O
buf_size	long
;	O
*	O
data	*(void)
=	O
NULL	O
;	O
buf_size	long
=	O
100	int
;	O
buf	*(char)
=	O
malloc	(long)->(*(void))
(	O
buf_size	long
)	O
;	O
if	O
(	O
buf	*(char)
==	O
NULL	O
)	O
{	O
log_error	(*(char))->(void)
(	O
"read_until: out of memory"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	long
=	O
0	int
;	O
while	O
(	O
(	O
n	long
=	O
read_all	(int,*(void),long)->(long)
(	O
fd	int
,	O
buf	*(char)
+	O
len	long
,	O
1	int
)	O
)	O
==	O
1	int
)	O
{	O
if	O
(	O
buf	*(char)
[	O
len	long
++	O
]	O
==	O
ch	int
)	O
break	O
;	O
if	O
(	O
len	long
+	O
1	int
==	O
buf_size	long
)	O
{	O
buf_size	long
*=	O
2	int
;	O
buf2	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
buf	*(char)
,	O
buf_size	long
)	O
;	O
if	O
(	O
buf2	*(char)
==	O
NULL	O
)	O
{	O
log_error	(*(char))->(void)
(	O
"read_until: realloc failed"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
buf	*(char)
=	O
buf2	*(char)
;	O
}	O
}	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
buf	*(char)
)	O
;	O
if	O
(	O
n	long
==	O
0	int
)	O
log_error	(*(char))->(void)
(	O
"read_until: closed"	*(char)
)	O
;	O
else	O
log_error	(*(char))->(void)
(	O
"read_until: read error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
n	long
;	O
}	O
buf2	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
buf	*(char)
,	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
buf2	*(char)
==	O
NULL	O
)	O
log_error	(*(char))->(void)
(	O
"read_until: realloc: shrink failed"	*(char)
)	O
;	O
else	O
buf	*(char)
=	O
buf2	*(char)
;	O
*	O
data	*(void)
=	O
buf	*(char)
;	O
return	O
len	long
;	O
}	O
static	O
inline	O
Http_header	struct
*	O
http_alloc_header	(*(char),*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
(	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
value	*(char)
)	O
{	O
Http_header	struct
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
Http_header	struct
)	O
)	O
;	O
if	O
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
name	*(char)
=	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
value	*(char)
=	O
NULL	O
;	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
name	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
name	*(char)
)	O
;	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
value	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
value	*(char)
)	O
;	O
if	O
(	O
name	*(char)
==	O
NULL	O
||	O
value	*(char)
==	O
NULL	O
)	O
{	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
name	*(char)
)	O
;	O
if	O
(	O
value	*(char)
==	O
NULL	O
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
value	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
}	O
Http_header	struct
*	O
http_add_header	(*(*(struct(*(char),*(char),*(struct`)))),*(char),*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
(	O
Http_header	struct
*	O
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
value	*(char)
)	O
{	O
Http_header	struct
*	O
new_header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
new_header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
http_alloc_header	(*(char),*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
(	O
name	*(char)
,	O
value	*(char)
)	O
;	O
if	O
(	O
new_header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
new_header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
NULL	O
;	O
while	O
(	O
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
&	O
(	O
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
->	O
next	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
new_header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
return	O
new_header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
}	O
static	O
ssize_t	long
parse_header	(int,*(*(struct(*(char),*(char),*(struct`)))))->(long)
(	O
int	O
fd	int
,	O
Http_header	struct
*	O
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
{	O
unsigned	O
char	O
buf	*(char)
[	O
2	int
]	O
;	O
unsigned	O
char	O
*	O
data	*(void)
;	O
Http_header	struct
*	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
size_t	long
len	long
;	O
ssize_t	long
n	long
;	O
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
NULL	O
;	O
n	long
=	O
read_all	(int,*(void),long)->(long)
(	O
fd	int
,	O
buf	*(char)
,	O
2	int
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
return	O
n	long
;	O
if	O
(	O
buf	*(char)
[	O
0	int
]	O
==	O
'\r'	O
&&	O
buf	*(char)
[	O
1	int
]	O
==	O
'\n'	O
)	O
return	O
n	long
;	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
Http_header	struct
)	O
)	O
;	O
if	O
(	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
==	O
NULL	O
)	O
{	O
log_error	(*(char))->(void)
(	O
"parse_header: malloc failed"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
name	*(char)
=	O
NULL	O
;	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
value	*(char)
=	O
NULL	O
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
':'	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
return	O
n	long
;	O
data	*(void)
=	O
realloc	(*(void),long)->(*(void))
(	O
data	*(void)
,	O
n	long
+	O
2	int
)	O
;	O
if	O
(	O
data	*(void)
==	O
NULL	O
)	O
{	O
log_error	(*(char))->(void)
(	O
"parse_header: realloc failed"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
memmove	(*(void),*(void),long)->(*(void))
(	O
data	*(void)
+	O
2	int
,	O
data	*(void)
,	O
n	long
)	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
data	*(void)
,	O
buf	*(char)
,	O
2	int
)	O
;	O
n	long
+=	O
2	int
;	O
data	*(void)
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
name	*(char)
=	O
data	*(void)
;	O
len	long
=	O
n	long
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
'\r'	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
return	O
n	long
;	O
data	*(void)
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
value	*(char)
=	O
data	*(void)
;	O
len	long
+=	O
n	long
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
'\n'	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
return	O
n	long
;	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
!=	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"parse_header: invalid line ending"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	long
+=	O
n	long
;	O
log_verbose	()->(void)
(	O
"parse_header: %s:%s"	*(char)
,	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
name	*(char)
,	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
value	*(char)
)	O
;	O
n	long
=	O
parse_header	(int,*(*(struct(*(char),*(char),*(struct`)))))->(long)
(	O
fd	int
,	O
&	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
return	O
n	long
;	O
len	long
+=	O
n	long
;	O
return	O
len	long
;	O
}	O
static	O
ssize_t	long
http_write_header	(int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(long)
(	O
int	O
fd	int
,	O
Http_header	struct
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
{	O
ssize_t	long
n	long
=	O
0	int
,	O
m	long
;	O
if	O
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
==	O
NULL	O
)	O
return	O
write_all	(int,*(void),long)->(long)
(	O
fd	int
,	O
"\r\n"	*(char)
,	O
2	int
)	O
;	O
m	long
=	O
write_all	(int,*(void),long)->(long)
(	O
fd	int
,	O
(	O
void	O
*	O
)	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
name	*(char)
,	O
strlen	(*(char))->(long)
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
name	*(char)
)	O
)	O
;	O
if	O
(	O
m	long
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
n	long
+=	O
m	long
;	O
m	long
=	O
write_all	(int,*(void),long)->(long)
(	O
fd	int
,	O
": "	*(char)
,	O
2	int
)	O
;	O
if	O
(	O
m	long
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
n	long
+=	O
m	long
;	O
m	long
=	O
write_all	(int,*(void),long)->(long)
(	O
fd	int
,	O
(	O
void	O
*	O
)	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
value	*(char)
,	O
strlen	(*(char))->(long)
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
value	*(char)
)	O
)	O
;	O
if	O
(	O
m	long
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
n	long
+=	O
m	long
;	O
m	long
=	O
write_all	(int,*(void),long)->(long)
(	O
fd	int
,	O
"\r\n"	*(char)
,	O
2	int
)	O
;	O
if	O
(	O
m	long
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
n	long
+=	O
m	long
;	O
m	long
=	O
http_write_header	(int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(long)
(	O
fd	int
,	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
m	long
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
n	long
+=	O
m	long
;	O
return	O
n	long
;	O
}	O
static	O
void	O
http_destroy_header	(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(void)
(	O
Http_header	struct
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
{	O
if	O
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
==	O
NULL	O
)	O
return	O
;	O
http_destroy_header	(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(void)
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
name	*(char)
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
name	*(char)
)	O
;	O
if	O
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
value	*(char)
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
value	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
}	O
static	O
inline	O
Http_response	struct(int,int,int,*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
http_allocate_response	(*(char))->(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
(	O
const	O
char	O
*	O
status_message	*(char)
)	O
{	O
Http_response	struct(int,int,int,*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
Http_response	struct(int,int,int,*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
)	O
)	O
;	O
if	O
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_message	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
status_message	*(char)
)	O
;	O
if	O
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_message	*(char)
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
;	O
}	O
Http_response	struct(int,int,int,*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
http_create_response	(int,int,int,*(char))->(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
(	O
int	O
major_version	int
,	O
int	O
minor_version	int
,	O
int	O
status_code	int
,	O
const	O
char	O
*	O
status_message	*(char)
)	O
{	O
Http_response	struct(int,int,int,*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
=	O
http_allocate_response	(*(char))->(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
(	O
status_message	*(char)
)	O
;	O
if	O
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
major_version	int
=	O
major_version	int
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
minor_version	int
=	O
minor_version	int
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_code	int
=	O
status_code	int
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
NULL	O
;	O
return	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
;	O
}	O
ssize_t	long
http_parse_response	(int,*(*(struct(int,int,int,*(char),*(struct`)))))->(long)
(	O
int	O
fd	int
,	O
Http_response	struct(int,int,int,*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
*	O
response_	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
{	O
Http_response	struct(int,int,int,*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
;	O
unsigned	O
char	O
*	O
data	*(void)
;	O
size_t	long
len	long
;	O
ssize_t	long
n	long
;	O
*	O
response_	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
=	O
NULL	O
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
Http_response	struct(int,int,int,*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
)	O
)	O
;	O
if	O
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
==	O
NULL	O
)	O
{	O
log_error	(*(char))->(void)
(	O
"http_parse_response: out of memory"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
major_version	int
=	O
-	O
1	int
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
minor_version	int
=	O
-	O
1	int
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_code	int
=	O
-	O
1	int
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_message	*(char)
=	O
NULL	O
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
NULL	O
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
'/'	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
else	O
if	O
(	O
n	long
!=	O
5	int
||	O
memcmp	(*(void),*(void),long)->(int)
(	O
data	*(void)
,	O
"HTTP"	*(char)
,	O
4	int
)	O
!=	O
0	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"http_parse_response: expected \"HTTP\""	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
len	long
=	O
n	long
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
'.'	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
data	*(void)
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
major_version	int
=	O
atoi	(*(char))->(int)
(	O
data	*(void)
)	O
;	O
log_verbose	()->(void)
(	O
"http_parse_response: major version = %d"	*(char)
,	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
major_version	int
)	O
;	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
len	long
+=	O
n	long
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
' '	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
data	*(void)
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
minor_version	int
=	O
atoi	(*(char))->(int)
(	O
data	*(void)
)	O
;	O
log_verbose	()->(void)
(	O
"http_parse_response: minor version = %d"	*(char)
,	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
minor_version	int
)	O
;	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
len	long
+=	O
n	long
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
' '	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
data	*(void)
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_code	int
=	O
atoi	(*(char))->(int)
(	O
data	*(void)
)	O
;	O
log_verbose	()->(void)
(	O
"http_parse_response: status code = %d"	*(char)
,	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_code	int
)	O
;	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
len	long
+=	O
n	long
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
'\r'	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
data	*(void)
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_message	*(char)
=	O
data	*(void)
;	O
log_verbose	()->(void)
(	O
"http_parse_response: status message = \"%s\""	*(char)
,	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_message	*(char)
)	O
;	O
len	long
+=	O
n	long
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
'\n'	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
http_destroy_response	(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
!=	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"http_parse_request: invalid line ending"	*(char)
)	O
;	O
http_destroy_response	(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	long
+=	O
n	long
;	O
n	long
=	O
parse_header	(int,*(*(struct(*(char),*(char),*(struct`)))))->(long)
(	O
fd	int
,	O
&	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
http_destroy_response	(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
len	long
+=	O
n	long
;	O
*	O
response_	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
=	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
;	O
return	O
len	long
;	O
}	O
void	O
http_destroy_response	(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))->(void)
(	O
Http_response	struct(int,int,int,*(char),*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
{	O
if	O
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_message	*(char)
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
status_message	*(char)
)	O
;	O
http_destroy_header	(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
response	*(*(struct(int,int,int,*(char),*(struct(*`,*`,*`)))))
)	O
;	O
}	O
static	O
inline	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
http_allocate_request	(*(char))->(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
(	O
const	O
char	O
*	O
uri	*(char)
)	O
{	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
)	O
)	O
;	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
uri	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
uri	*(char)
)	O
;	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
uri	*(char)
==	O
NULL	O
)	O
{	O
free	(*(void))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
;	O
}	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
http_create_request	(enum(int,int,int,int,int,int,int),*(char),int,int)->(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
(	O
Http_method	enum(int,int,int,int,int,int,int)
method	enum(int,int,int,int,int,int,int)
,	O
const	O
char	O
*	O
uri	*(char)
,	O
int	O
major_version	int
,	O
int	O
minor_version	int
)	O
{	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
=	O
http_allocate_request	(*(char))->(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
(	O
uri	*(char)
)	O
;	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
method	enum(int,int,int,int,int,int,int)
=	O
method	enum(int,int,int,int,int,int,int)
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
major_version	int
=	O
major_version	int
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
minor_version	int
=	O
minor_version	int
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
NULL	O
;	O
return	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
;	O
}	O
ssize_t	long
http_parse_request	(int,*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct`)))))->(long)
(	O
int	O
fd	int
,	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
*	O
request_	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
{	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
;	O
unsigned	O
char	O
*	O
data	*(void)
;	O
size_t	long
len	long
;	O
ssize_t	long
n	long
;	O
*	O
request_	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
=	O
NULL	O
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
=	O
malloc	(long)->(*(void))
(	O
sizeof	O
(	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
)	O
)	O
;	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
==	O
NULL	O
)	O
{	O
log_error	(*(char))->(void)
(	O
"http_parse_request: out of memory"	*(char)
)	O
;	O
return	O
-	O
1	int
;	O
}	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
method	enum(int,int,int,int,int,int,int)
=	O
-	O
1	int
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
uri	*(char)
=	O
NULL	O
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
major_version	int
=	O
-	O
1	int
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
minor_version	int
=	O
-	O
1	int
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
NULL	O
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
' '	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
method	enum(int,int,int,int,int,int,int)
=	O
http_string_to_method	(*(char),long)->(enum(int,int,int,int,int,int,int))
(	O
data	*(void)
,	O
n	long
-	O
1	int
)	O
;	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
method	enum(int,int,int,int,int,int,int)
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"http_parse_request: expected an HTTP method"	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
data	*(void)
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
log_verbose	()->(void)
(	O
"http_parse_request: method = \"%s\""	*(char)
,	O
data	*(void)
)	O
;	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
len	long
=	O
n	long
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
' '	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
free	(*(void))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
data	*(void)
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
uri	*(char)
=	O
data	*(void)
;	O
len	long
+=	O
n	long
;	O
log_verbose	()->(void)
(	O
"http_parse_request: uri = \"%s\""	*(char)
,	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
uri	*(char)
)	O
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
'/'	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
http_destroy_request	(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
else	O
if	O
(	O
n	long
!=	O
5	int
||	O
memcmp	(*(void),*(void),long)->(int)
(	O
data	*(void)
,	O
"HTTP"	*(char)
,	O
4	int
)	O
!=	O
0	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"http_parse_request: expected \"HTTP\""	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
http_destroy_request	(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
len	long
=	O
n	long
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
'.'	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
http_destroy_request	(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
data	*(void)
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
major_version	int
=	O
atoi	(*(char))->(int)
(	O
data	*(void)
)	O
;	O
log_verbose	()->(void)
(	O
"http_parse_request: major version = %d"	*(char)
,	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
major_version	int
)	O
;	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
len	long
+=	O
n	long
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
'\r'	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
http_destroy_request	(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
data	*(void)
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
minor_version	int
=	O
atoi	(*(char))->(int)
(	O
data	*(void)
)	O
;	O
log_verbose	()->(void)
(	O
"http_parse_request: minor version = %d"	*(char)
,	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
minor_version	int
)	O
;	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
len	long
+=	O
n	long
;	O
n	long
=	O
read_until	(int,int,*(*(char)))->(long)
(	O
fd	int
,	O
'\n'	O
,	O
&	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
http_destroy_request	(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
free	(*(void))->(void)
(	O
data	*(void)
)	O
;	O
if	O
(	O
n	long
!=	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"http_parse_request: invalid line ending"	*(char)
)	O
;	O
http_destroy_request	(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
-	O
1	int
;	O
}	O
len	long
+=	O
n	long
;	O
n	long
=	O
parse_header	(int,*(*(struct(*(char),*(char),*(struct`)))))->(long)
(	O
fd	int
,	O
&	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
n	long
<=	O
0	int
)	O
{	O
http_destroy_request	(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
return	O
n	long
;	O
}	O
len	long
+=	O
n	long
;	O
*	O
request_	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
=	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
;	O
return	O
len	long
;	O
}	O
ssize_t	long
http_write_request	(int,*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(long)
(	O
int	O
fd	int
,	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
{	O
char	O
str	*(*(char))
[	O
1024	int
]	O
;	O
ssize_t	long
n	long
=	O
0	int
;	O
size_t	long
m	long
;	O
m	long
=	O
sprintf	(*(char),*(char))->(int)
(	O
str	*(*(char))
,	O
"%s %s HTTP/%d.%d\r\n"	*(char)
,	O
http_method_to_string	(enum(int,int,int,int,int,int,int))->(*(char))
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
method	enum(int,int,int,int,int,int,int)
)	O
,	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
uri	*(char)
,	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
major_version	int
,	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
minor_version	int
)	O
;	O
m	long
=	O
write_all	(int,*(void),long)->(long)
(	O
fd	int
,	O
str	*(*(char))
,	O
m	long
)	O
;	O
log_verbose	()->(void)
(	O
"http_write_request: %s"	*(char)
,	O
str	*(*(char))
)	O
;	O
if	O
(	O
m	long
==	O
-	O
1	int
)	O
{	O
log_error	(*(char))->(void)
(	O
"http_write_request: write error: %s"	*(char)
,	O
strerror	(int)->(*(char))
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
n	long
+=	O
m	long
;	O
m	long
=	O
http_write_header	(int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(long)
(	O
fd	int
,	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
if	O
(	O
m	long
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
n	long
+=	O
m	long
;	O
return	O
n	long
;	O
}	O
void	O
http_destroy_request	(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))->(void)
(	O
Http_request	struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
*	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
{	O
if	O
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
uri	*(char)
)	O
free	(*(void))->(void)
(	O
(	O
char	O
*	O
)	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
uri	*(char)
)	O
;	O
http_destroy_header	(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
->	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
)	O
;	O
free	(*(void))->(void)
(	O
request	*(*(struct(enum(int,int,int,int,int,int,int),*(char),int,int,*(struct(*`,*`,*`)))))
)	O
;	O
}	O
static	O
Http_header	struct
*	O
http_header_find	(*(struct(*(char),*(char),*(struct(*`,*`,*`)))),*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
(	O
Http_header	struct
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
name	*(char)
,	O
name	*(char)
)	O
==	O
0	int
)	O
return	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
return	O
http_header_find	(*(struct(*(char),*(char),*(struct(*`,*`,*`)))),*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
next	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
,	O
name	*(char)
)	O
;	O
}	O
const	O
char	O
*	O
http_header_get	(*(struct(*(char),*(char),*(struct(*`,*`,*`)))),*(char))->(*(char))
(	O
Http_header	struct
*	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
Http_header	struct
*	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
;	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
=	O
http_header_find	(*(struct(*(char),*(char),*(struct(*`,*`,*`)))),*(char))->(*(struct(*(char),*(char),*(struct(*`,*`,*`)))))
(	O
header	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
,	O
name	*(char)
)	O
;	O
if	O
(	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
h	*(struct(*(char),*(char),*(struct(*(char),*(char),*(struct`)))))
->	O
value	*(char)
;	O
}	O
