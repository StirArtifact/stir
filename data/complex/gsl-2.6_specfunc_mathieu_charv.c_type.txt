static	O
double	O
solve_cubic	(double,double,double)->(double)
(	O
double	O
c2	double
,	O
double	O
c1	double
,	O
double	O
c0	double
)	O
;	O
static	O
double	O
ceer	(int,double,double,int)->(double)
(	O
int	O
order	enum(int,int)
,	O
double	O
qq	double
,	O
double	O
aa	*(double)
,	O
int	O
nterms	int
)	O
{	O
double	O
term	double
,	O
term1	double
;	O
int	O
ii	int
,	O
n1	long
;	O
if	O
(	O
order	enum(int,int)
==	O
0	int
)	O
term	double
=	O
0.0	int
;	O
else	O
{	O
term	double
=	O
2.0	int
*	O
qq	double
*	O
qq	double
/	O
aa	*(double)
;	O
if	O
(	O
order	enum(int,int)
!=	O
2	int
)	O
{	O
n1	long
=	O
order	enum(int,int)
/	O
2	int
-	O
1	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
n1	long
;	O
ii	int
++	O
)	O
term	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	*(double)
-	O
4.0	int
*	O
(	O
ii	int
+	O
1	int
)	O
*	O
(	O
ii	int
+	O
1	int
)	O
-	O
term	double
)	O
;	O
}	O
}	O
term	double
+=	O
order	enum(int,int)
*	O
order	enum(int,int)
;	O
term1	double
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
nterms	int
;	O
ii	int
++	O
)	O
term1	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	*(double)
-	O
(	O
order	enum(int,int)
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
*	O
(	O
order	enum(int,int)
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
-	O
term1	double
)	O
;	O
if	O
(	O
order	enum(int,int)
==	O
0	int
)	O
term1	double
*=	O
2.0	int
;	O
return	O
(	O
term	double
+	O
term1	double
-	O
aa	*(double)
)	O
;	O
}	O
static	O
double	O
ceor	(int,double,double,int)->(double)
(	O
int	O
order	enum(int,int)
,	O
double	O
qq	double
,	O
double	O
aa	*(double)
,	O
int	O
nterms	int
)	O
{	O
double	O
term	double
,	O
term1	double
;	O
int	O
ii	int
,	O
n1	long
;	O
term	double
=	O
qq	double
;	O
n1	long
=	O
(	O
int	O
)	O
(	O
(	O
float	O
)	O
order	enum(int,int)
/	O
2.0	int
-	O
0.5	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
n1	long
;	O
ii	int
++	O
)	O
term	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	*(double)
-	O
(	O
2.0	int
*	O
ii	int
+	O
1.0	int
)	O
*	O
(	O
2.0	int
*	O
ii	int
+	O
1.0	int
)	O
-	O
term	double
)	O
;	O
term	double
+=	O
order	enum(int,int)
*	O
order	enum(int,int)
;	O
term1	double
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
nterms	int
;	O
ii	int
++	O
)	O
term1	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	*(double)
-	O
(	O
order	enum(int,int)
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
*	O
(	O
order	enum(int,int)
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
-	O
term1	double
)	O
;	O
return	O
(	O
term	double
+	O
term1	double
-	O
aa	*(double)
)	O
;	O
}	O
static	O
double	O
seer	(int,double,double,int)->(double)
(	O
int	O
order	enum(int,int)
,	O
double	O
qq	double
,	O
double	O
aa	*(double)
,	O
int	O
nterms	int
)	O
{	O
double	O
term	double
,	O
term1	double
;	O
int	O
ii	int
,	O
n1	long
;	O
term	double
=	O
0.0	int
;	O
n1	long
=	O
order	enum(int,int)
/	O
2	int
-	O
1	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
n1	long
;	O
ii	int
++	O
)	O
term	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	*(double)
-	O
4.0	int
*	O
(	O
ii	int
+	O
1	int
)	O
*	O
(	O
ii	int
+	O
1	int
)	O
-	O
term	double
)	O
;	O
term	double
+=	O
order	enum(int,int)
*	O
order	enum(int,int)
;	O
term1	double
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
nterms	int
;	O
ii	int
++	O
)	O
term1	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	*(double)
-	O
(	O
order	enum(int,int)
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
*	O
(	O
order	enum(int,int)
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
-	O
term1	double
)	O
;	O
return	O
(	O
term	double
+	O
term1	double
-	O
aa	*(double)
)	O
;	O
}	O
static	O
double	O
seor	(int,double,double,int)->(double)
(	O
int	O
order	enum(int,int)
,	O
double	O
qq	double
,	O
double	O
aa	*(double)
,	O
int	O
nterms	int
)	O
{	O
double	O
term	double
,	O
term1	double
;	O
int	O
ii	int
,	O
n1	long
;	O
term	double
=	O
-	O
1.0	int
*	O
qq	double
;	O
n1	long
=	O
(	O
int	O
)	O
(	O
(	O
float	O
)	O
order	enum(int,int)
/	O
2.0	int
-	O
0.5	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
n1	long
;	O
ii	int
++	O
)	O
term	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	*(double)
-	O
(	O
2.0	int
*	O
ii	int
+	O
1.0	int
)	O
*	O
(	O
2.0	int
*	O
ii	int
+	O
1.0	int
)	O
-	O
term	double
)	O
;	O
term	double
+=	O
order	enum(int,int)
*	O
order	enum(int,int)
;	O
term1	double
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
nterms	int
;	O
ii	int
++	O
)	O
term1	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	*(double)
-	O
(	O
order	enum(int,int)
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
*	O
(	O
order	enum(int,int)
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
-	O
term1	double
)	O
;	O
return	O
(	O
term	double
+	O
term1	double
-	O
aa	*(double)
)	O
;	O
}	O
static	O
double	O
asymptotic	(int,double)->(double)
(	O
int	O
order	enum(int,int)
,	O
double	O
qq	double
)	O
{	O
double	O
asymp	double
;	O
double	O
nn	long
,	O
n2	long
,	O
n4	double
,	O
n6	double
;	O
double	O
hh	double
,	O
ah	double
,	O
ah2	double
,	O
ah3	double
,	O
ah4	double
,	O
ah5	double
;	O
nn	long
=	O
2	int
*	O
order	enum(int,int)
+	O
1	int
;	O
n2	long
=	O
nn	long
*	O
nn	long
;	O
n4	double
=	O
n2	long
*	O
n2	long
;	O
n6	double
=	O
n4	double
*	O
n2	long
;	O
hh	double
=	O
2	int
*	O
sqrt	(double)->(double)
(	O
qq	double
)	O
;	O
ah	double
=	O
16	int
*	O
hh	double
;	O
ah2	double
=	O
ah	double
*	O
ah	double
;	O
ah3	double
=	O
ah2	double
*	O
ah	double
;	O
ah4	double
=	O
ah3	double
*	O
ah	double
;	O
ah5	double
=	O
ah4	double
*	O
ah	double
;	O
asymp	double
=	O
-	O
2	int
*	O
qq	double
+	O
nn	long
*	O
hh	double
-	O
0.125	int
*	O
(	O
n2	long
+	O
1	int
)	O
;	O
asymp	double
-=	O
0.25	int
*	O
nn	long
*	O
(	O
n2	long
+	O
3	int
)	O
/	O
ah	double
;	O
asymp	double
-=	O
0.25	int
*	O
(	O
5	int
*	O
n4	double
+	O
34	int
*	O
n2	long
+	O
9	int
)	O
/	O
ah2	double
;	O
asymp	double
-=	O
0.25	int
*	O
nn	long
*	O
(	O
33	int
*	O
n4	double
+	O
410	int
*	O
n2	long
+	O
405	int
)	O
/	O
ah3	double
;	O
asymp	double
-=	O
(	O
63	int
*	O
n6	double
+	O
1260	int
*	O
n4	double
+	O
2943	int
*	O
n2	long
+	O
486	int
)	O
/	O
ah4	double
;	O
asymp	double
-=	O
nn	long
*	O
(	O
527	int
*	O
n6	double
+	O
15617	int
*	O
n4	double
+	O
69001	int
*	O
n2	long
+	O
41607	int
)	O
/	O
ah5	double
;	O
return	O
asymp	double
;	O
}	O
static	O
double	O
solve_cubic	(double,double,double)->(double)
(	O
double	O
c2	double
,	O
double	O
c1	double
,	O
double	O
c0	double
)	O
{	O
double	O
qq	double
,	O
rr	double
,	O
ww	double
,	O
ss	double
,	O
tt	*(double)
;	O
qq	double
=	O
(	O
3	int
*	O
c1	double
-	O
c2	double
*	O
c2	double
)	O
/	O
9	int
;	O
rr	double
=	O
(	O
9	int
*	O
c2	double
*	O
c1	double
-	O
27	int
*	O
c0	double
-	O
2	int
*	O
c2	double
*	O
c2	double
*	O
c2	double
)	O
/	O
54	int
;	O
ww	double
=	O
qq	double
*	O
qq	double
*	O
qq	double
+	O
rr	double
*	O
rr	double
;	O
if	O
(	O
ww	double
>=	O
0	int
)	O
{	O
double	O
t1	double
=	O
rr	double
+	O
sqrt	(double)->(double)
(	O
ww	double
)	O
;	O
ss	double
=	O
fabs	(double)->(double)
(	O
t1	double
)	O
/	O
t1	double
*	O
pow	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
t1	double
)	O
,	O
1	int
/	O
3.	int
)	O
;	O
t1	double
=	O
rr	double
-	O
sqrt	(double)->(double)
(	O
ww	double
)	O
;	O
tt	*(double)
=	O
fabs	(double)->(double)
(	O
t1	double
)	O
/	O
t1	double
*	O
pow	(double,double)->(double)
(	O
fabs	(double)->(double)
(	O
t1	double
)	O
,	O
1	int
/	O
3.	int
)	O
;	O
}	O
else	O
{	O
double	O
theta	double
=	O
acos	(double)->(double)
(	O
rr	double
/	O
sqrt	(double)->(double)
(	O
-	O
qq	double
*	O
qq	double
*	O
qq	double
)	O
)	O
;	O
ss	double
=	O
2	int
*	O
sqrt	(double)->(double)
(	O
-	O
qq	double
)	O
*	O
cos	(double)->(double)
(	O
(	O
theta	double
+	O
4	int
*	O
M_PI	int
)	O
/	O
3.	int
)	O
;	O
tt	*(double)
=	O
0.0	int
;	O
}	O
return	O
(	O
ss	double
+	O
tt	*(double)
-	O
c2	double
/	O
3	int
)	O
;	O
}	O
static	O
double	O
approx_c	(int,double)->(double)
(	O
int	O
order	enum(int,int)
,	O
double	O
qq	double
)	O
{	O
double	O
approx	double
;	O
double	O
c0	double
,	O
c1	double
,	O
c2	double
;	O
if	O
(	O
order	enum(int,int)
<	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"Undefined order for Mathieu function"	*(char)
,	O
GSL_EINVAL	int
,	O
0.0	int
)	O
;	O
}	O
switch	O
(	O
order	enum(int,int)
)	O
{	O
case	O
0	int
:	O
if	O
(	O
qq	double
<=	O
4	int
)	O
return	O
(	O
2	int
-	O
sqrt	(double)->(double)
(	O
4	int
+	O
2	int
*	O
qq	double
*	O
qq	double
)	O
)	O
;	O
else	O
return	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
,	O
qq	double
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
qq	double
<=	O
4	int
)	O
return	O
(	O
5	int
+	O
0.5	int
*	O
(	O
qq	double
-	O
sqrt	(double)->(double)
(	O
5	int
*	O
qq	double
*	O
qq	double
-	O
16	int
*	O
qq	double
+	O
64	int
)	O
)	O
)	O
;	O
else	O
return	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
,	O
qq	double
)	O
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
qq	double
<=	O
3	int
)	O
{	O
c2	double
=	O
-	O
8.0	int
;	O
c1	double
=	O
-	O
48	int
-	O
3	int
*	O
qq	double
*	O
qq	double
;	O
c0	double
=	O
20	int
*	O
qq	double
*	O
qq	double
;	O
}	O
else	O
return	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
,	O
qq	double
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
qq	double
<=	O
6.25	int
)	O
{	O
c2	double
=	O
-	O
qq	double
-	O
8	int
;	O
c1	double
=	O
16	int
*	O
qq	double
-	O
128	int
-	O
2	int
*	O
qq	double
*	O
qq	double
;	O
c0	double
=	O
qq	double
*	O
qq	double
*	O
(	O
qq	double
+	O
8	int
)	O
;	O
}	O
else	O
return	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
,	O
qq	double
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
order	enum(int,int)
<	O
70	int
)	O
{	O
if	O
(	O
1.7	int
*	O
order	enum(int,int)
>	O
2	int
*	O
sqrt	(double)->(double)
(	O
qq	double
)	O
)	O
{	O
double	O
n2	long
=	O
(	O
double	O
)	O
(	O
order	enum(int,int)
*	O
order	enum(int,int)
)	O
;	O
double	O
n22	double
=	O
(	O
double	O
)	O
(	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
1	int
)	O
)	O
;	O
double	O
q2	double
=	O
qq	double
*	O
qq	double
;	O
double	O
q4	double
=	O
q2	double
*	O
q2	double
;	O
approx	double
=	O
n2	long
+	O
0.5	int
*	O
q2	double
/	O
(	O
n2	long
-	O
1	int
)	O
;	O
approx	double
+=	O
(	O
5	int
*	O
n2	long
+	O
7	int
)	O
*	O
q4	double
/	O
(	O
32	int
*	O
n22	double
*	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
4	int
)	O
)	O
;	O
approx	double
+=	O
(	O
9	int
*	O
n2	long
*	O
n2	long
+	O
58	int
*	O
n2	long
+	O
29	int
)	O
*	O
q4	double
*	O
q2	double
/	O
(	O
64	int
*	O
n22	double
*	O
n22	double
*	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
4	int
)	O
*	O
(	O
n2	long
-	O
9	int
)	O
)	O
;	O
if	O
(	O
1.4	int
*	O
order	enum(int,int)
<	O
2	int
*	O
sqrt	(double)->(double)
(	O
qq	double
)	O
)	O
{	O
approx	double
+=	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
,	O
qq	double
)	O
;	O
approx	double
*=	O
0.5	int
;	O
}	O
}	O
else	O
approx	double
=	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
,	O
qq	double
)	O
;	O
return	O
approx	double
;	O
}	O
else	O
return	O
order	enum(int,int)
*	O
order	enum(int,int)
;	O
}	O
approx	double
=	O
solve_cubic	(double,double,double)->(double)
(	O
c2	double
,	O
c1	double
,	O
c0	double
)	O
;	O
if	O
(	O
approx	double
<	O
0	int
&&	O
sqrt	(double)->(double)
(	O
qq	double
)	O
>	O
0.1	int
*	O
order	enum(int,int)
)	O
return	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
-	O
1	int
,	O
qq	double
)	O
;	O
else	O
return	O
(	O
order	enum(int,int)
*	O
order	enum(int,int)
+	O
fabs	(double)->(double)
(	O
approx	double
)	O
)	O
;	O
}	O
static	O
double	O
approx_s	(int,double)->(double)
(	O
int	O
order	enum(int,int)
,	O
double	O
qq	double
)	O
{	O
double	O
approx	double
;	O
double	O
c0	double
,	O
c1	double
,	O
c2	double
;	O
if	O
(	O
order	enum(int,int)
<	O
1	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"Undefined order for Mathieu function"	*(char)
,	O
GSL_EINVAL	int
,	O
0.0	int
)	O
;	O
}	O
switch	O
(	O
order	enum(int,int)
)	O
{	O
case	O
1	int
:	O
if	O
(	O
qq	double
<=	O
4	int
)	O
return	O
(	O
5	int
-	O
0.5	int
*	O
(	O
qq	double
+	O
sqrt	(double)->(double)
(	O
5	int
*	O
qq	double
*	O
qq	double
+	O
16	int
*	O
qq	double
+	O
64	int
)	O
)	O
)	O
;	O
else	O
return	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
-	O
1	int
,	O
qq	double
)	O
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
qq	double
<=	O
5	int
)	O
return	O
(	O
10	int
-	O
sqrt	(double)->(double)
(	O
36	int
+	O
qq	double
*	O
qq	double
)	O
)	O
;	O
else	O
return	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
-	O
1	int
,	O
qq	double
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
qq	double
<=	O
6.25	int
)	O
{	O
c2	double
=	O
qq	double
-	O
8	int
;	O
c1	double
=	O
-	O
128	int
-	O
16	int
*	O
qq	double
-	O
2	int
*	O
qq	double
*	O
qq	double
;	O
c0	double
=	O
qq	double
*	O
qq	double
*	O
(	O
8	int
-	O
qq	double
)	O
;	O
}	O
else	O
return	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
-	O
1	int
,	O
qq	double
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
order	enum(int,int)
<	O
70	int
)	O
{	O
if	O
(	O
1.7	int
*	O
order	enum(int,int)
>	O
2	int
*	O
sqrt	(double)->(double)
(	O
qq	double
)	O
)	O
{	O
double	O
n2	long
=	O
(	O
double	O
)	O
(	O
order	enum(int,int)
*	O
order	enum(int,int)
)	O
;	O
double	O
n22	double
=	O
(	O
double	O
)	O
(	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
1	int
)	O
)	O
;	O
double	O
q2	double
=	O
qq	double
*	O
qq	double
;	O
double	O
q4	double
=	O
q2	double
*	O
q2	double
;	O
approx	double
=	O
n2	long
+	O
0.5	int
*	O
q2	double
/	O
(	O
n2	long
-	O
1	int
)	O
;	O
approx	double
+=	O
(	O
5	int
*	O
n2	long
+	O
7	int
)	O
*	O
q4	double
/	O
(	O
32	int
*	O
n22	double
*	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
4	int
)	O
)	O
;	O
approx	double
+=	O
(	O
9	int
*	O
n2	long
*	O
n2	long
+	O
58	int
*	O
n2	long
+	O
29	int
)	O
*	O
q4	double
*	O
q2	double
/	O
(	O
64	int
*	O
n22	double
*	O
n22	double
*	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
4	int
)	O
*	O
(	O
n2	long
-	O
9	int
)	O
)	O
;	O
if	O
(	O
1.4	int
*	O
order	enum(int,int)
<	O
2	int
*	O
sqrt	(double)->(double)
(	O
qq	double
)	O
)	O
{	O
approx	double
+=	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
-	O
1	int
,	O
qq	double
)	O
;	O
approx	double
*=	O
0.5	int
;	O
}	O
}	O
else	O
approx	double
=	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
-	O
1	int
,	O
qq	double
)	O
;	O
return	O
approx	double
;	O
}	O
else	O
return	O
order	enum(int,int)
*	O
order	enum(int,int)
;	O
}	O
approx	double
=	O
solve_cubic	(double,double,double)->(double)
(	O
c2	double
,	O
c1	double
,	O
c0	double
)	O
;	O
if	O
(	O
approx	double
<	O
0	int
&&	O
sqrt	(double)->(double)
(	O
qq	double
)	O
>	O
0.1	int
*	O
order	enum(int,int)
)	O
return	O
asymptotic	(int,double)->(double)
(	O
order	enum(int,int)
-	O
1	int
,	O
qq	double
)	O
;	O
else	O
return	O
(	O
order	enum(int,int)
*	O
order	enum(int,int)
+	O
fabs	(double)->(double)
(	O
approx	double
)	O
)	O
;	O
}	O
int	O
gsl_sf_mathieu_a_e	(int,double,*(struct(double,double)))->(int)
(	O
int	O
order	enum(int,int)
,	O
double	O
qq	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
int	O
even_odd	int
,	O
nterms	int
=	O
50	int
,	O
ii	int
,	O
counter	int
=	O
0	int
,	O
maxcount	int
=	O
1000	int
;	O
int	O
dir	int
=	O
0	int
;	O
double	O
a1	double
,	O
a2	double
,	O
fa	double
,	O
fa1	double
,	O
dela	double
,	O
aa_orig	double
,	O
da	double
=	O
0.025	int
,	O
aa	*(double)
;	O
double	O
aa_approx	double
;	O
even_odd	int
=	O
0	int
;	O
if	O
(	O
order	enum(int,int)
%	O
2	int
!=	O
0	int
)	O
even_odd	int
=	O
1	int
;	O
if	O
(	O
qq	double
==	O
0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
order	enum(int,int)
*	O
order	enum(int,int)
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
if	O
(	O
order	enum(int,int)
<	O
0	int
)	O
order	enum(int,int)
*=	O
-	O
1	int
;	O
if	O
(	O
qq	double
<	O
0.0	int
)	O
{	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
return	O
gsl_sf_mathieu_a_e	(int,double,*(struct(double,double)))->(int)
(	O
order	enum(int,int)
,	O
-	O
qq	double
,	O
result	*(struct(double,double))
)	O
;	O
else	O
return	O
gsl_sf_mathieu_b_e	(int,double,*(struct(double,double)))->(int)
(	O
order	enum(int,int)
,	O
-	O
qq	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
aa_approx	double
=	O
approx_c	(int,double)->(double)
(	O
order	enum(int,int)
,	O
qq	double
)	O
;	O
aa_orig	double
=	O
aa	*(double)
=	O
aa_approx	double
;	O
while	O
(	O
counter	int
<	O
maxcount	int
)	O
{	O
a1	double
=	O
aa	*(double)
+	O
0.001	int
;	O
ii	int
=	O
0	int
;	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
fa1	double
=	O
ceer	(int,double,double,int)->(double)
(	O
order	enum(int,int)
,	O
qq	double
,	O
a1	double
,	O
nterms	int
)	O
;	O
else	O
fa1	double
=	O
ceor	(int,double,double,int)->(double)
(	O
order	enum(int,int)
,	O
qq	double
,	O
a1	double
,	O
nterms	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
fa	double
=	O
ceer	(int,double,double,int)->(double)
(	O
order	enum(int,int)
,	O
qq	double
,	O
aa	*(double)
,	O
nterms	int
)	O
;	O
else	O
fa	double
=	O
ceor	(int,double,double,int)->(double)
(	O
order	enum(int,int)
,	O
qq	double
,	O
aa	*(double)
,	O
nterms	int
)	O
;	O
a2	double
=	O
a1	double
;	O
a1	double
=	O
aa	*(double)
;	O
if	O
(	O
fa	double
==	O
fa1	double
)	O
{	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
break	O
;	O
}	O
aa	*(double)
-=	O
(	O
aa	*(double)
-	O
a2	double
)	O
/	O
(	O
fa	double
-	O
fa1	double
)	O
*	O
fa	double
;	O
dela	double
=	O
fabs	(double)->(double)
(	O
aa	*(double)
-	O
a2	double
)	O
;	O
if	O
(	O
dela	double
<	O
GSL_DBL_EPSILON	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
break	O
;	O
}	O
if	O
(	O
ii	int
>	O
40	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
=	O
dela	double
;	O
break	O
;	O
}	O
fa1	double
=	O
fa	double
;	O
ii	int
++	O
;	O
}	O
if	O
(	O
fabs	(double)->(double)
(	O
aa	*(double)
-	O
aa_orig	double
)	O
>	O
(	O
3	int
+	O
0.01	int
*	O
order	enum(int,int)
*	O
fabs	(double)->(double)
(	O
aa_orig	double
)	O
)	O
||	O
(	O
order	enum(int,int)
>	O
10	int
&&	O
fabs	(double)->(double)
(	O
aa	*(double)
-	O
aa_orig	double
)	O
>	O
1.5	int
*	O
order	enum(int,int)
)	O
)	O
{	O
counter	int
++	O
;	O
if	O
(	O
counter	int
==	O
maxcount	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
aa	*(double)
-	O
aa_orig	double
)	O
;	O
break	O
;	O
}	O
if	O
(	O
aa	*(double)
>	O
aa_orig	double
)	O
{	O
if	O
(	O
dir	int
==	O
1	int
)	O
da	double
/=	O
2	int
;	O
dir	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
dir	int
==	O
-	O
1	int
)	O
da	double
/=	O
2	int
;	O
dir	int
=	O
1	int
;	O
}	O
aa_approx	double
+=	O
dir	int
*	O
da	double
*	O
counter	int
;	O
aa	*(double)
=	O
aa_approx	double
;	O
continue	O
;	O
}	O
else	O
break	O
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
aa	*(double)
;	O
if	O
(	O
counter	int
==	O
maxcount	int
)	O
{	O
GSL_ERROR	O
(	O
"Wrong characteristic Mathieu value"	*(char)
,	O
GSL_EFAILED	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_mathieu_b_e	(int,double,*(struct(double,double)))->(int)
(	O
int	O
order	enum(int,int)
,	O
double	O
qq	double
,	O
gsl_sf_result	struct(double,double)
*	O
result	*(struct(double,double))
)	O
{	O
int	O
even_odd	int
,	O
nterms	int
=	O
50	int
,	O
ii	int
,	O
counter	int
=	O
0	int
,	O
maxcount	int
=	O
1000	int
;	O
int	O
dir	int
=	O
0	int
;	O
double	O
a1	double
,	O
a2	double
,	O
fa	double
,	O
fa1	double
,	O
dela	double
,	O
aa_orig	double
,	O
da	double
=	O
0.025	int
,	O
aa	*(double)
;	O
double	O
aa_approx	double
;	O
even_odd	int
=	O
0	int
;	O
if	O
(	O
order	enum(int,int)
%	O
2	int
!=	O
0	int
)	O
even_odd	int
=	O
1	int
;	O
if	O
(	O
order	enum(int,int)
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"Characteristic value undefined for order 0"	*(char)
,	O
GSL_EFAILED	int
)	O
;	O
}	O
if	O
(	O
qq	double
==	O
0	int
)	O
{	O
result	*(struct(double,double))
->	O
val	double
=	O
order	enum(int,int)
*	O
order	enum(int,int)
;	O
result	*(struct(double,double))
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
if	O
(	O
order	enum(int,int)
<	O
0	int
)	O
order	enum(int,int)
*=	O
-	O
1	int
;	O
if	O
(	O
qq	double
<	O
0.0	int
)	O
{	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
return	O
gsl_sf_mathieu_b_e	(int,double,*(struct(double,double)))->(int)
(	O
order	enum(int,int)
,	O
-	O
qq	double
,	O
result	*(struct(double,double))
)	O
;	O
else	O
return	O
gsl_sf_mathieu_a_e	(int,double,*(struct(double,double)))->(int)
(	O
order	enum(int,int)
,	O
-	O
qq	double
,	O
result	*(struct(double,double))
)	O
;	O
}	O
aa_approx	double
=	O
approx_s	(int,double)->(double)
(	O
order	enum(int,int)
,	O
qq	double
)	O
;	O
aa_orig	double
=	O
aa	*(double)
=	O
aa_approx	double
;	O
while	O
(	O
counter	int
<	O
maxcount	int
)	O
{	O
a1	double
=	O
aa	*(double)
+	O
0.001	int
;	O
ii	int
=	O
0	int
;	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
fa1	double
=	O
seer	(int,double,double,int)->(double)
(	O
order	enum(int,int)
,	O
qq	double
,	O
a1	double
,	O
nterms	int
)	O
;	O
else	O
fa1	double
=	O
seor	(int,double,double,int)->(double)
(	O
order	enum(int,int)
,	O
qq	double
,	O
a1	double
,	O
nterms	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
fa	double
=	O
seer	(int,double,double,int)->(double)
(	O
order	enum(int,int)
,	O
qq	double
,	O
aa	*(double)
,	O
nterms	int
)	O
;	O
else	O
fa	double
=	O
seor	(int,double,double,int)->(double)
(	O
order	enum(int,int)
,	O
qq	double
,	O
aa	*(double)
,	O
nterms	int
)	O
;	O
a2	double
=	O
a1	double
;	O
a1	double
=	O
aa	*(double)
;	O
if	O
(	O
fa	double
==	O
fa1	double
)	O
{	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
break	O
;	O
}	O
aa	*(double)
-=	O
(	O
aa	*(double)
-	O
a2	double
)	O
/	O
(	O
fa	double
-	O
fa1	double
)	O
*	O
fa	double
;	O
dela	double
=	O
fabs	(double)->(double)
(	O
aa	*(double)
-	O
a2	double
)	O
;	O
if	O
(	O
dela	double
<	O
1e-18	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
break	O
;	O
}	O
if	O
(	O
ii	int
>	O
40	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
=	O
dela	double
;	O
break	O
;	O
}	O
fa1	double
=	O
fa	double
;	O
ii	int
++	O
;	O
}	O
if	O
(	O
fabs	(double)->(double)
(	O
aa	*(double)
-	O
aa_orig	double
)	O
>	O
(	O
3	int
+	O
0.01	int
*	O
order	enum(int,int)
*	O
fabs	(double)->(double)
(	O
aa_orig	double
)	O
)	O
||	O
(	O
order	enum(int,int)
>	O
10	int
&&	O
fabs	(double)->(double)
(	O
aa	*(double)
-	O
aa_orig	double
)	O
>	O
1.5	int
*	O
order	enum(int,int)
)	O
)	O
{	O
counter	int
++	O
;	O
if	O
(	O
counter	int
==	O
maxcount	int
)	O
{	O
result	*(struct(double,double))
->	O
err	double
=	O
fabs	(double)->(double)
(	O
aa	*(double)
-	O
aa_orig	double
)	O
;	O
break	O
;	O
}	O
if	O
(	O
aa	*(double)
>	O
aa_orig	double
)	O
{	O
if	O
(	O
dir	int
==	O
1	int
)	O
da	double
/=	O
2	int
;	O
dir	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
dir	int
==	O
-	O
1	int
)	O
da	double
/=	O
2	int
;	O
dir	int
=	O
1	int
;	O
}	O
aa_approx	double
+=	O
dir	int
*	O
da	double
*	O
counter	int
;	O
aa	*(double)
=	O
aa_approx	double
;	O
continue	O
;	O
}	O
else	O
break	O
;	O
}	O
result	*(struct(double,double))
->	O
val	double
=	O
aa	*(double)
;	O
if	O
(	O
counter	int
==	O
maxcount	int
)	O
{	O
GSL_ERROR	O
(	O
"Wrong characteristic Mathieu value"	*(char)
,	O
GSL_EFAILED	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
figi	(int,*(double),*(double),*(double),*(double))->(int)
(	O
int	O
nn	long
,	O
double	O
*	O
tt	*(double)
,	O
double	O
*	O
dd	*(double)
,	O
double	O
*	O
ee	*(double)
,	O
double	O
*	O
e2	*(double)
)	O
{	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
nn	long
;	O
ii	int
++	O
)	O
{	O
if	O
(	O
ii	int
!=	O
0	int
)	O
{	O
e2	*(double)
[	O
ii	int
]	O
=	O
tt	*(double)
[	O
3	int
*	O
ii	int
]	O
*	O
tt	*(double)
[	O
3	int
*	O
(	O
ii	int
-	O
1	int
)	O
+	O
2	int
]	O
;	O
if	O
(	O
e2	*(double)
[	O
ii	int
]	O
<	O
0.0	int
)	O
{	O
return	O
(	O
nn	long
+	O
ii	int
)	O
;	O
}	O
if	O
(	O
e2	*(double)
[	O
ii	int
]	O
==	O
0.0	int
&&	O
(	O
tt	*(double)
[	O
3	int
*	O
ii	int
]	O
!=	O
0.0	int
||	O
tt	*(double)
[	O
3	int
*	O
(	O
ii	int
-	O
1	int
)	O
+	O
2	int
]	O
!=	O
0.0	int
)	O
)	O
{	O
return	O
(	O
-	O
1	int
*	O
(	O
3	int
*	O
nn	long
+	O
ii	int
)	O
)	O
;	O
}	O
ee	*(double)
[	O
ii	int
]	O
=	O
sqrt	(double)->(double)
(	O
e2	*(double)
[	O
ii	int
]	O
)	O
;	O
}	O
dd	*(double)
[	O
ii	int
]	O
=	O
tt	*(double)
[	O
3	int
*	O
ii	int
+	O
1	int
]	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
gsl_sf_mathieu_a_array	(int,int,double,*(struct(long,long,long,int,double,double,*(double),*(double),*(double),*(double),*(double),*(double),*(double),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,*`,*`,*`)))),array(double))->(int)
(	O
int	O
order_min	int
,	O
int	O
order_max	int
,	O
double	O
qq	double
,	O
gsl_sf_mathieu_workspace	struct(long,long,long,int,double,double,*(double),*(double),*(double),*(double),*(double),*(double),*(double),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(double),*(double),*(double),*(double))))
*	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
double	O
result_array	array(double)
[	O
]	O
)	O
{	O
unsigned	O
int	O
even_order	long
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
even_order	long
,	O
odd_order	long
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
odd_order	long
,	O
extra_values	int
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
extra_values	int
,	O
ii	int
,	O
jj	int
;	O
int	O
status	int
;	O
double	O
*	O
tt	*(double)
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
tt	*(double)
,	O
*	O
dd	*(double)
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
dd	*(double)
,	O
*	O
ee	*(double)
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
ee	*(double)
,	O
*	O
e2	*(double)
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
e2	*(double)
,	O
*	O
zz	*(double)
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
zz	*(double)
,	O
*	O
aa	*(double)
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
aa	*(double)
;	O
gsl_matrix_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
mat	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
gsl_eigen_symmv_workspace	struct(long,*(double),*(double),*(double),*(double))
*	O
wmat	*(struct(long,*(double),*(double),*(double),*(double)))
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
wmat	*(struct(long,*(double),*(double),*(double),*(double)))
;	O
if	O
(	O
order_max	int
>	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
||	O
order_max	int
<=	O
order_min	int
||	O
order_min	int
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid range [order_min,order_max]"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
tt	*(double)
[	O
0	int
]	O
=	O
0.0	int
;	O
tt	*(double)
[	O
1	int
]	O
=	O
0.0	int
;	O
tt	*(double)
[	O
2	int
]	O
=	O
qq	double
;	O
for	O
(	O
ii	int
=	O
1	int
;	O
ii	int
<	O
even_order	long
-	O
1	int
;	O
ii	int
++	O
)	O
{	O
tt	*(double)
[	O
3	int
*	O
ii	int
]	O
=	O
qq	double
;	O
tt	*(double)
[	O
3	int
*	O
ii	int
+	O
1	int
]	O
=	O
4	int
*	O
ii	int
*	O
ii	int
;	O
tt	*(double)
[	O
3	int
*	O
ii	int
+	O
2	int
]	O
=	O
qq	double
;	O
}	O
tt	*(double)
[	O
3	int
*	O
even_order	long
-	O
3	int
]	O
=	O
qq	double
;	O
tt	*(double)
[	O
3	int
*	O
even_order	long
-	O
2	int
]	O
=	O
4	int
*	O
(	O
even_order	long
-	O
1	int
)	O
*	O
(	O
even_order	long
-	O
1	int
)	O
;	O
tt	*(double)
[	O
3	int
*	O
even_order	long
-	O
1	int
]	O
=	O
0.0	int
;	O
tt	*(double)
[	O
3	int
]	O
*=	O
2	int
;	O
status	int
=	O
figi	(int,*(double),*(double),*(double),*(double))->(int)
(	O
(	O
signed	O
int	O
)	O
even_order	long
,	O
tt	*(double)
,	O
dd	*(double)
,	O
ee	*(double)
,	O
e2	*(double)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
GSL_ERROR	O
(	O
"Internal error in tridiagonal Mathieu matrix"	*(char)
,	O
GSL_EFAILED	int
)	O
;	O
}	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
even_order	long
*	O
even_order	long
;	O
ii	int
++	O
)	O
zz	*(double)
[	O
ii	int
]	O
=	O
0.0	int
;	O
zz	*(double)
[	O
0	int
]	O
=	O
dd	*(double)
[	O
0	int
]	O
;	O
zz	*(double)
[	O
1	int
]	O
=	O
ee	*(double)
[	O
1	int
]	O
;	O
for	O
(	O
ii	int
=	O
1	int
;	O
ii	int
<	O
even_order	long
-	O
1	int
;	O
ii	int
++	O
)	O
{	O
zz	*(double)
[	O
ii	int
*	O
even_order	long
+	O
ii	int
-	O
1	int
]	O
=	O
ee	*(double)
[	O
ii	int
]	O
;	O
zz	*(double)
[	O
ii	int
*	O
even_order	long
+	O
ii	int
]	O
=	O
dd	*(double)
[	O
ii	int
]	O
;	O
zz	*(double)
[	O
ii	int
*	O
even_order	long
+	O
ii	int
+	O
1	int
]	O
=	O
ee	*(double)
[	O
ii	int
+	O
1	int
]	O
;	O
}	O
zz	*(double)
[	O
even_order	long
*	O
(	O
even_order	long
-	O
1	int
)	O
+	O
even_order	long
-	O
2	int
]	O
=	O
ee	*(double)
[	O
even_order	long
-	O
1	int
]	O
;	O
zz	*(double)
[	O
even_order	long
*	O
even_order	long
-	O
1	int
]	O
=	O
dd	*(double)
[	O
even_order	long
-	O
1	int
]	O
;	O
mat	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_view_array	(*(double),long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
zz	*(double)
,	O
even_order	long
,	O
even_order	long
)	O
;	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_subvector	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
even_order	long
)	O
;	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
,	O
even_order	long
,	O
even_order	long
)	O
;	O
gsl_eigen_symmv	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(double),*(double),*(double),*(double))))->(int)
(	O
&	O
mat	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
wmat	*(struct(long,*(double),*(double),*(double),*(double)))
)	O
;	O
gsl_eigen_symmv_sort	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),enum(int,int,int,int))->(int)
(	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
GSL_EIGEN_SORT_VAL_ASC	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
even_order	long
-	O
extra_values	int
;	O
ii	int
++	O
)	O
aa	*(double)
[	O
2	int
*	O
ii	int
]	O
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
ii	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
*	O
odd_order	long
;	O
ii	int
++	O
)	O
zz	*(double)
[	O
ii	int
]	O
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
;	O
ii	int
++	O
)	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
odd_order	long
;	O
jj	int
++	O
)	O
{	O
if	O
(	O
ii	int
==	O
jj	int
)	O
zz	*(double)
[	O
ii	int
*	O
odd_order	long
+	O
jj	int
]	O
=	O
(	O
2	int
*	O
ii	int
+	O
1	int
)	O
*	O
(	O
2	int
*	O
ii	int
+	O
1	int
)	O
;	O
else	O
if	O
(	O
ii	int
==	O
jj	int
+	O
1	int
||	O
ii	int
+	O
1	int
==	O
jj	int
)	O
zz	*(double)
[	O
ii	int
*	O
odd_order	long
+	O
jj	int
]	O
=	O
qq	double
;	O
}	O
zz	*(double)
[	O
0	int
]	O
+=	O
qq	double
;	O
mat	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_view_array	(*(double),long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
zz	*(double)
,	O
odd_order	long
,	O
odd_order	long
)	O
;	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_subvector	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
odd_order	long
)	O
;	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
,	O
odd_order	long
,	O
odd_order	long
)	O
;	O
gsl_eigen_symmv	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(double),*(double),*(double),*(double))))->(int)
(	O
&	O
mat	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
wmat	*(struct(long,*(double),*(double),*(double),*(double)))
)	O
;	O
gsl_eigen_symmv_sort	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),enum(int,int,int,int))->(int)
(	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
GSL_EIGEN_SORT_VAL_ASC	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
-	O
extra_values	int
;	O
ii	int
++	O
)	O
aa	*(double)
[	O
2	int
*	O
ii	int
+	O
1	int
]	O
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
ii	int
)	O
;	O
for	O
(	O
ii	int
=	O
order_min	int
;	O
ii	int
<=	O
order_max	int
;	O
ii	int
++	O
)	O
{	O
result_array	array(double)
[	O
ii	int
-	O
order_min	int
]	O
=	O
aa	*(double)
[	O
ii	int
]	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_mathieu_b_array	(int,int,double,*(struct(long,long,long,int,double,double,*(double),*(double),*(double),*(double),*(double),*(double),*(double),*(struct(long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,*`,*`,*`,*`)))),array(double))->(int)
(	O
int	O
order_min	int
,	O
int	O
order_max	int
,	O
double	O
qq	double
,	O
gsl_sf_mathieu_workspace	struct(long,long,long,int,double,double,*(double),*(double),*(double),*(double),*(double),*(double),*(double),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(double),*(double),*(double),*(double))))
*	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
double	O
result_array	array(double)
[	O
]	O
)	O
{	O
unsigned	O
int	O
even_order	long
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
even_order	long
-	O
1	int
,	O
odd_order	long
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
odd_order	long
,	O
extra_values	int
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
extra_values	int
,	O
ii	int
,	O
jj	int
;	O
double	O
*	O
zz	*(double)
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
zz	*(double)
,	O
*	O
bb	*(double)
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
bb	*(double)
;	O
gsl_matrix_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
mat	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
gsl_eigen_symmv_workspace	struct(long,*(double),*(double),*(double),*(double))
*	O
wmat	*(struct(long,*(double),*(double),*(double),*(double)))
=	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
wmat	*(struct(long,*(double),*(double),*(double),*(double)))
;	O
if	O
(	O
order_max	int
>	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
||	O
order_max	int
<=	O
order_min	int
||	O
order_min	int
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid range [order_min,order_max]"	*(char)
,	O
GSL_EINVAL	int
)	O
;	O
}	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
even_order	long
*	O
even_order	long
;	O
ii	int
++	O
)	O
zz	*(double)
[	O
ii	int
]	O
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
even_order	long
;	O
ii	int
++	O
)	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
even_order	long
;	O
jj	int
++	O
)	O
{	O
if	O
(	O
ii	int
==	O
jj	int
)	O
zz	*(double)
[	O
ii	int
*	O
even_order	long
+	O
jj	int
]	O
=	O
4	int
*	O
(	O
ii	int
+	O
1	int
)	O
*	O
(	O
ii	int
+	O
1	int
)	O
;	O
else	O
if	O
(	O
ii	int
==	O
jj	int
+	O
1	int
||	O
ii	int
+	O
1	int
==	O
jj	int
)	O
zz	*(double)
[	O
ii	int
*	O
even_order	long
+	O
jj	int
]	O
=	O
qq	double
;	O
}	O
mat	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_view_array	(*(double),long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
zz	*(double)
,	O
even_order	long
,	O
even_order	long
)	O
;	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_subvector	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
even_order	long
)	O
;	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
,	O
even_order	long
,	O
even_order	long
)	O
;	O
gsl_eigen_symmv	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(double),*(double),*(double),*(double))))->(int)
(	O
&	O
mat	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
wmat	*(struct(long,*(double),*(double),*(double),*(double)))
)	O
;	O
gsl_eigen_symmv_sort	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),enum(int,int,int,int))->(int)
(	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
GSL_EIGEN_SORT_VAL_ASC	int
)	O
;	O
bb	*(double)
[	O
0	int
]	O
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
even_order	long
-	O
extra_values	int
;	O
ii	int
++	O
)	O
bb	*(double)
[	O
2	int
*	O
(	O
ii	int
+	O
1	int
)	O
]	O
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
ii	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
*	O
odd_order	long
;	O
ii	int
++	O
)	O
zz	*(double)
[	O
ii	int
]	O
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
;	O
ii	int
++	O
)	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
odd_order	long
;	O
jj	int
++	O
)	O
{	O
if	O
(	O
ii	int
==	O
jj	int
)	O
zz	*(double)
[	O
ii	int
*	O
odd_order	long
+	O
jj	int
]	O
=	O
(	O
2	int
*	O
ii	int
+	O
1	int
)	O
*	O
(	O
2	int
*	O
ii	int
+	O
1	int
)	O
;	O
else	O
if	O
(	O
ii	int
==	O
jj	int
+	O
1	int
||	O
ii	int
+	O
1	int
==	O
jj	int
)	O
zz	*(double)
[	O
ii	int
*	O
odd_order	long
+	O
jj	int
]	O
=	O
qq	double
;	O
}	O
zz	*(double)
[	O
0	int
]	O
-=	O
qq	double
;	O
mat	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_view_array	(*(double),long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
zz	*(double)
,	O
odd_order	long
,	O
odd_order	long
)	O
;	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_subvector	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
odd_order	long
)	O
;	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
,	O
odd_order	long
,	O
odd_order	long
)	O
;	O
gsl_eigen_symmv	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,*(double),*(double),*(double),*(double))))->(int)
(	O
&	O
mat	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
wmat	*(struct(long,*(double),*(double),*(double),*(double)))
)	O
;	O
gsl_eigen_symmv_sort	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),enum(int,int,int,int))->(int)
(	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
evec	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
GSL_EIGEN_SORT_VAL_ASC	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
-	O
extra_values	int
;	O
ii	int
++	O
)	O
bb	*(double)
[	O
2	int
*	O
ii	int
+	O
1	int
]	O
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
eval	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
ii	int
)	O
;	O
for	O
(	O
ii	int
=	O
order_min	int
;	O
ii	int
<=	O
order_max	int
;	O
ii	int
++	O
)	O
{	O
result_array	array(double)
[	O
ii	int
-	O
order_min	int
]	O
=	O
bb	*(double)
[	O
ii	int
]	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
double	O
gsl_sf_mathieu_a	(int,double)->(double)
(	O
int	O
order	enum(int,int)
,	O
double	O
qq	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_mathieu_a_e	(int,double,*(struct(double,double)))->(int)
(	O
order	enum(int,int)
,	O
qq	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
double	O
gsl_sf_mathieu_b	(int,double)->(double)
(	O
int	O
order	enum(int,int)
,	O
double	O
qq	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_mathieu_b_e	(int,double,*(struct(double,double)))->(int)
(	O
order	enum(int,int)
,	O
qq	double
,	O
&	O
result	*(struct(double,double))
)	O
)	O
;	O
}	O
