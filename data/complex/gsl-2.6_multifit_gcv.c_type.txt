typedef	O
struct	O
{	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
double	O
delta0	*(double)
;	O
size_t	long
np	long
;	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
}	O
gcv_params	struct(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,long,*(struct(long,long,*(double),*(struct(long,*`)),int)))
;	O
static	O
double	O
gcv_func	(double,*(void))->(double)
(	O
double	O
lambda	double
,	O
void	O
*	O
params	*(void)
)	O
;	O
int	O
gsl_multifit_linear_gcv_init	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(double),*(struct(long,long,long,long,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),double)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
y	double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
double	O
*	O
delta0	*(double)
,	O
gsl_multifit_linear_workspace	struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double)
*	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
)	O
{	O
const	O
size_t	long
n	int
=	O
y	double
->	O
size	long
;	O
if	O
(	O
n	int
!=	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
n	int
)	O
{	O
GSL_ERROR	O
(	O
"y vector does not match workspace"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
!=	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
p	int
)	O
{	O
GSL_ERROR	O
(	O
"UTy vector does not match workspace"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
const	O
size_t	long
p	int
=	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
p	int
;	O
gsl_matrix_view	struct(struct(long,long,long,*(double),*(struct(long,*(double))),int))
U	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_submatrix	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long,long)->(struct(struct(long,long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
A	*(float)
,	O
0	int
,	O
0	int
,	O
n	int
,	O
p	int
)	O
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_subvector	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
p	int
)	O
;	O
const	O
double	O
smax	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
0	int
)	O
;	O
const	O
double	O
smin	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
&	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
p	int
-	O
1	int
)	O
;	O
double	O
dr	double
;	O
double	O
normy	double
=	O
gsl_blas_dnrm2	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
y	double
)	O
;	O
double	O
normUTy	double
;	O
gsl_blas_dgemv	(enum(int,int,int),double,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
CblasTrans	int
,	O
1.0	int
,	O
&	O
U	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
.	O
matrix	struct(long,long,long,*(long double),*(struct(long,*(long double))),int)
,	O
y	double
,	O
0.0	int
,	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
normUTy	double
=	O
gsl_blas_dnrm2	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
dr	double
=	O
(	O
normy	double
+	O
normUTy	double
)	O
*	O
(	O
normy	double
-	O
normUTy	double
)	O
;	O
gsl_multifit_linear_lreg	(double,double,*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
smin	double
,	O
smax	double
,	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
if	O
(	O
n	int
>	O
p	int
&&	O
dr	double
>	O
0.0	int
)	O
*	O
delta0	*(double)
=	O
dr	double
;	O
else	O
*	O
delta0	*(double)
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_multifit_linear_gcv_curve	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,long,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),double)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
double	O
delta0	*(double)
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_multifit_linear_workspace	struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double)
*	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
)	O
{	O
const	O
size_t	long
n	int
=	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
n	int
;	O
const	O
size_t	long
p	int
=	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
p	int
;	O
const	O
size_t	long
N	int
=	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
if	O
(	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
!=	O
p	int
)	O
{	O
GSL_ERROR	O
(	O
"UTy vector does not match workspace"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"size of reg_param and G vectors do not match"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
size_t	long
i	long
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_subvector	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
p	int
)	O
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
QSI	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
,	O
p	int
)	O
;	O
gcv_params	struct(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,long,*(struct(long,long,*(double),*(struct(long,*`)),int)))
params	*(void)
;	O
params	*(void)
.	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
&	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
;	O
params	*(void)
.	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
params	*(void)
.	O
delta0	*(double)
=	O
delta0	*(double)
;	O
params	*(void)
.	O
np	long
=	O
n	int
-	O
p	int
;	O
params	*(void)
.	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
&	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
N	int
;	O
++	O
i	long
)	O
{	O
double	O
lambdai	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
double	O
Gi	double
=	O
gcv_func	(double,*(void))->(double)
(	O
lambdai	double
,	O
&	O
params	*(void)
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
Gi	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_multifit_linear_gcv_min	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,*(double),*(struct(long,long,long,long,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),double)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
double	O
delta0	*(double)
,	O
double	O
*	O
lambda	double
,	O
gsl_multifit_linear_workspace	struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double)
*	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
)	O
{	O
const	O
size_t	long
n	int
=	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
n	int
;	O
const	O
size_t	long
p	int
=	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
p	int
;	O
const	O
size_t	long
npts	long
=	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
if	O
(	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
!=	O
p	int
)	O
{	O
GSL_ERROR	O
(	O
"UTy vector does not match workspace"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
!=	O
npts	long
)	O
{	O
GSL_ERROR	O
(	O
"size of reg_param and G vectors do not match"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
int	O
status	int
;	O
const	O
size_t	long
max_iter	long
=	O
500	int
;	O
const	O
double	O
tol	double
=	O
1.0e-4	int
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_subvector	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
p	int
)	O
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
QSI	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
,	O
p	int
)	O
;	O
gcv_params	struct(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,long,*(struct(long,long,*(double),*(struct(long,*`)),int)))
params	*(void)
;	O
int	O
idxG	int
=	O
(	O
int	O
)	O
gsl_vector_min_index	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(long)
(	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
double	O
a	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
GSL_MIN	O
(	O
idxG	int
+	O
1	int
,	O
(	O
int	O
)	O
npts	long
-	O
1	int
)	O
)	O
;	O
double	O
b	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
GSL_MAX	O
(	O
idxG	int
-	O
1	int
,	O
0	int
)	O
)	O
;	O
double	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
idxG	int
)	O
;	O
size_t	long
iter	long
=	O
0	int
;	O
gsl_function	struct(*((double,*(void))->(double)),*(void))
F	struct(*((double,*(void))->(double)),*(void))
;	O
gsl_min_fminimizer	struct(*(struct(*(char),long,*((*`,*`,double,double,double,double,double,double)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`)->(int)))),*(struct(*((double,*`)->(double)),*(void))),double,double,double,double,double,double,*(void))
*	O
min_workspace_p	*(struct(*(struct(*(char),long,*((*`,*`,double,double,double,double,double,double)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`)->(int)))),*(struct(*((double,*`)->(double)),*(void))),double,double,double,double,double,double,*(void)))
;	O
if	O
(	O
idxG	int
==	O
0	int
||	O
idxG	int
==	O
(	O
(	O
int	O
)	O
npts	long
-	O
1	int
)	O
)	O
{	O
*	O
lambda	double
=	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
min_workspace_p	*(struct(*(struct(*(char),long,*((*`,*`,double,double,double,double,double,double)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`)->(int)))),*(struct(*((double,*`)->(double)),*(void))),double,double,double,double,double,double,*(void)))
=	O
gsl_min_fminimizer_alloc	(*(struct(*(char),long,*((*`,*`,double,double,double,double,double,double)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`)->(int)))))->(*(struct(*(struct(*`,long,*`,*`)),*(struct(*`,*`)),double,double,double,double,double,double,*(void))))
(	O
gsl_min_fminimizer_brent	*(struct(*(char),long,*((*(void),*(struct`),double,double,double,double,double,double)->(int)),*((*(void),*(struct`),*(double),*(double),*(double),*(double),*(double),*(double))->(int))))
)	O
;	O
params	*(void)
.	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
&	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
;	O
params	*(void)
.	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
params	*(void)
.	O
delta0	*(double)
=	O
delta0	*(double)
;	O
params	*(void)
.	O
np	long
=	O
n	int
-	O
p	int
;	O
params	*(void)
.	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
&	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
;	O
F	struct(*((double,*(void))->(double)),*(void))
.	O
function	*((double,*(void))->(double))
=	O
gcv_func	(double,*(void))->(double)
;	O
F	struct(*((double,*(void))->(double)),*(void))
.	O
params	*(void)
=	O
&	O
params	*(void)
;	O
gsl_min_fminimizer_set	(*(struct(*(struct(*`,long,*`,*`)),*(struct(*`,*`)),double,double,double,double,double,double,*(void))),*(struct(*((double,*`)->(double)),*(void))),double,double,double)->(int)
(	O
min_workspace_p	*(struct(*(struct(*(char),long,*((*`,*`,double,double,double,double,double,double)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`)->(int)))),*(struct(*((double,*`)->(double)),*(void))),double,double,double,double,double,double,*(void)))
,	O
&	O
F	struct(*((double,*(void))->(double)),*(void))
,	O
m	*(struct(long,long,long,*(long double),*(struct(long,*(long double))),int))
,	O
a	double
,	O
b	double
)	O
;	O
do	O
{	O
iter	long
++	O
;	O
status	int
=	O
gsl_min_fminimizer_iterate	(*(struct(*(struct(*`,long,*`,*`)),*(struct(*`,*`)),double,double,double,double,double,double,*(void))))->(int)
(	O
min_workspace_p	*(struct(*(struct(*(char),long,*((*`,*`,double,double,double,double,double,double)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`)->(int)))),*(struct(*((double,*`)->(double)),*(void))),double,double,double,double,double,double,*(void)))
)	O
;	O
a	double
=	O
gsl_min_fminimizer_x_lower	(*(struct(*(struct(*`,long,*`,*`)),*(struct(*`,*`)),double,double,double,double,double,double,*(void))))->(double)
(	O
min_workspace_p	*(struct(*(struct(*(char),long,*((*`,*`,double,double,double,double,double,double)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`)->(int)))),*(struct(*((double,*`)->(double)),*(void))),double,double,double,double,double,double,*(void)))
)	O
;	O
b	double
=	O
gsl_min_fminimizer_x_upper	(*(struct(*(struct(*`,long,*`,*`)),*(struct(*`,*`)),double,double,double,double,double,double,*(void))))->(double)
(	O
min_workspace_p	*(struct(*(struct(*(char),long,*((*`,*`,double,double,double,double,double,double)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`)->(int)))),*(struct(*((double,*`)->(double)),*(void))),double,double,double,double,double,double,*(void)))
)	O
;	O
status	int
=	O
gsl_min_test_interval	(double,double,double,double)->(int)
(	O
a	double
,	O
b	double
,	O
0.0	int
,	O
tol	double
)	O
;	O
}	O
while	O
(	O
status	int
==	O
GSL_CONTINUE	int
&&	O
iter	long
<	O
max_iter	long
)	O
;	O
if	O
(	O
status	int
==	O
GSL_SUCCESS	int
)	O
*	O
lambda	double
=	O
gsl_min_fminimizer_minimum	(*(struct(*(struct(*`,long,*`,*`)),*(struct(*`,*`)),double,double,double,double,double,double,*(void))))->(double)
(	O
min_workspace_p	*(struct(*(struct(*(char),long,*((*`,*`,double,double,double,double,double,double)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`)->(int)))),*(struct(*((double,*`)->(double)),*(void))),double,double,double,double,double,double,*(void)))
)	O
;	O
else	O
status	int
=	O
GSL_EMAXITER	int
;	O
gsl_min_fminimizer_free	(*(struct(*(struct(*`,long,*`,*`)),*(struct(*`,*`)),double,double,double,double,double,double,*(void))))->(void)
(	O
min_workspace_p	*(struct(*(struct(*(char),long,*((*`,*`,double,double,double,double,double,double)->(int)),*((*`,*`,*`,*`,*`,*`,*`,*`)->(int)))),*(struct(*((double,*`)->(double)),*(void))),double,double,double,double,double,double,*(void)))
)	O
;	O
return	O
status	int
;	O
}	O
}	O
double	O
gsl_multifit_linear_gcv_calc	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,long,long,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),double)))->(double)
(	O
const	O
double	O
lambda	double
,	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
const	O
double	O
delta0	*(double)
,	O
gsl_multifit_linear_workspace	struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double)
*	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
)	O
{	O
const	O
size_t	long
n	int
=	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
n	int
;	O
const	O
size_t	long
p	int
=	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
p	int
;	O
if	O
(	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
!=	O
p	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"UTy vector does not match workspace"	*(char)
,	O
GSL_EBADLEN	int
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_subvector	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
p	int
)	O
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_matrix_subcolumn	(*(struct(long,long,long,*(double),*(struct(long,*`)),int)),long,long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
QSI	*(struct(long,long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
0	int
,	O
p	int
)	O
;	O
gcv_params	struct(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,long,*(struct(long,long,*(double),*(struct(long,*`)),int)))
params	*(void)
;	O
double	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
params	*(void)
.	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
&	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
;	O
params	*(void)
.	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
params	*(void)
.	O
delta0	*(double)
=	O
delta0	*(double)
;	O
params	*(void)
.	O
np	long
=	O
n	int
-	O
p	int
;	O
params	*(void)
.	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
&	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
;	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gcv_func	(double,*(void))->(double)
(	O
lambda	double
,	O
&	O
params	*(void)
)	O
;	O
return	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
}	O
}	O
int	O
gsl_multifit_linear_gcv	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(double),*(double),*(struct(long,long,long,long,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),double)))->(int)
(	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
y	double
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
double	O
*	O
lambda	double
,	O
double	O
*	O
G_lambda	*(double)
,	O
gsl_multifit_linear_workspace	struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double)
*	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
)	O
{	O
const	O
size_t	long
n	int
=	O
y	double
->	O
size	long
;	O
const	O
size_t	long
N	int
=	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
if	O
(	O
n	int
!=	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
n	int
)	O
{	O
GSL_ERROR	O
(	O
"y vector does not match workspace"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"size of reg_param and G vectors do not match"	*(char)
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
int	O
status	int
;	O
const	O
size_t	long
p	int
=	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
p	int
;	O
gsl_vector_view	struct(struct(long,long,*(double),*(struct(long,*(double))),int))
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_vector_subvector	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,long)->(struct(struct(long,long,*(double),*(struct(long,*`)),int)))
(	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
->	O
xt	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
0	int
,	O
p	int
)	O
;	O
double	O
delta0	*(double)
;	O
status	int
=	O
gsl_multifit_linear_gcv_init	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(double),*(struct(long,long,long,long,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),double)))->(int)
(	O
y	double
,	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
&	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
&	O
delta0	*(double)
,	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
gsl_multifit_linear_gcv_curve	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,long,long,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),double)))->(int)
(	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
&	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
delta0	*(double)
,	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
gsl_multifit_linear_gcv_min	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,*(double),*(struct(long,long,long,long,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),double)))->(int)
(	O
reg_param	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
&	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
delta0	*(double)
,	O
lambda	double
,	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
*	O
G_lambda	*(double)
=	O
gsl_multifit_linear_gcv_calc	(double,*(struct(long,long,*(double),*(struct(long,*`)),int)),double,*(struct(long,long,long,long,*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),*(struct(long,long,*`,*`,int)),double)))->(double)
(	O
*	O
lambda	double
,	O
&	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
.	O
vector	struct(long,long,*(long double),*(struct(long,*(long double))),int)
,	O
delta0	*(double)
,	O
work	*(struct(long,long,long,long,*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double))
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
double	O
gcv_func	(double,*(void))->(double)
(	O
double	O
lambda	double
,	O
void	O
*	O
params	*(void)
)	O
{	O
gcv_params	struct(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,long,*(struct(long,long,*(double),*(struct(long,*`)),int)))
*	O
par	*(struct(*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double,long,*(struct(long,long,*(double),*(struct`),int))))
=	O
(	O
gcv_params	struct(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)),double,long,*(struct(long,long,*(double),*(struct(long,*`)),int)))
*	O
)	O
params	*(void)
;	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
par	*(struct(*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double,long,*(struct(long,long,*(double),*(struct`),int))))
->	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
const	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
par	*(struct(*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double,long,*(struct(long,long,*(double),*(struct`),int))))
->	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
double	O
delta0	*(double)
=	O
par	*(struct(*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double,long,*(struct(long,long,*(double),*(struct`),int))))
->	O
delta0	*(double)
;	O
size_t	long
np	long
=	O
par	*(struct(*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double,long,*(struct(long,long,*(double),*(struct`),int))))
->	O
np	long
;	O
gsl_vector	struct(long,long,*(double),*(struct(long,*(double))),int)
*	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
par	*(struct(*(struct(long,long,*(double),*(struct`),int)),*(struct(long,long,*(double),*(struct`),int)),double,long,*(struct(long,long,*(double),*(struct`),int))))
->	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
const	O
size_t	long
p	int
=	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
->	O
size	long
;	O
size_t	long
i	long
;	O
double	O
lambda_sq	double
=	O
lambda	double
*	O
lambda	double
;	O
double	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
d	double
,	O
norm	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
double	O
sumf	double
=	O
0.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
p	int
;	O
++	O
i	long
)	O
{	O
double	O
si	double
=	O
gsl_vector_get	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long)->(double)
(	O
S	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
)	O
;	O
double	O
fi	double
=	O
lambda_sq	double
/	O
(	O
si	double
*	O
si	double
+	O
lambda_sq	double
)	O
;	O
gsl_vector_set	(*(struct(long,long,*(double),*(struct(long,*`)),int)),long,double)->(void)
(	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
i	long
,	O
fi	double
)	O
;	O
sumf	double
+=	O
fi	double
;	O
}	O
d	double
=	O
(	O
double	O
)	O
np	long
+	O
sumf	double
;	O
gsl_vector_mul	(*(struct(long,long,*(double),*(struct(long,*`)),int)),*(struct(long,long,*(double),*(struct(long,*`)),int)))->(int)
(	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
,	O
UTy	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
norm	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
gsl_blas_dnrm2	(*(struct(long,long,*(double),*(struct(long,*`)),int)))->(double)
(	O
workp	*(struct(long,long,*(double),*(struct(long,*(double))),int))
)	O
;	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
=	O
(	O
norm	*(struct(long,long,*(double),*(struct(long,*(double))),int))
*	O
norm	*(struct(long,long,*(double),*(struct(long,*(double))),int))
+	O
delta0	*(double)
)	O
/	O
(	O
d	double
*	O
d	double
)	O
;	O
return	O
G	*(struct(long,long,*(double),*(struct(long,*(double))),int))
;	O
}	O
