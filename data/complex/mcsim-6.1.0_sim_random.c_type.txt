static	O
BOOL	int
vbSwitchGauss	O
=	O
FALSE	O
;	O
typedef	O
struct	O
tagRANDREC	O
{	O
double	O
seed	O
;	O
}	O
RANDREC	O
,	O
*	O
PRANDREC	O
;	O
static	O
BOOL	int
vbNoSeed	O
=	O
TRUE	O
;	O
static	O
BOOL	int
vbNotInitd	O
=	O
TRUE	O
;	O
static	O
RANDREC	O
vRandRec	O
;	O
double	O
GetSeed	()->(double)
(	O
void	O
)	O
{	O
return	O
(	O
vRandRec	O
.	O
seed	O
)	O
;	O
}	O
void	O
SetSeed	(double)->(void)
(	O
double	O
dSeed	double
)	O
{	O
int	O
bCorrected	O
=	O
0	int
;	O
if	O
(	O
dSeed	double
==	O
0.0	int
)	O
{	O
dSeed	double
=	O
SEED_DEFAULT	O
;	O
bCorrected	O
++	O
;	O
}	O
if	O
(	O
dSeed	double
<	O
0	int
)	O
dSeed	double
=	O
-	O
dSeed	double
;	O
if	O
(	O
dSeed	double
<	O
SEED_MIN	O
)	O
{	O
dSeed	double
=	O
SEED_MIN	O
+	O
(	O
dSeed	double
/	O
SEED_MIN	O
)	O
/	O
(	O
SEED_MAX	O
-	O
SEED_MIN	O
)	O
;	O
bCorrected	O
++	O
;	O
}	O
if	O
(	O
dSeed	double
>	O
SEED_MAX	O
)	O
{	O
dSeed	double
=	O
SEED_MIN	O
+	O
(	O
SEED_MAX	O
/	O
dSeed	double
)	O
/	O
(	O
SEED_MAX	O
-	O
SEED_MIN	O
)	O
;	O
bCorrected	O
++	O
;	O
}	O
assert	O
(	O
(	O
dSeed	double
>=	O
SEED_MIN	O
&&	O
dSeed	double
<=	O
SEED_MAX	O
)	O
)	O
;	O
if	O
(	O
bCorrected	O
)	O
printf	(*(char))->(int)
(	O
"SetSeed():  corrected out of range random number seed\n"	*(char)
"Seed must lie in the range [%g, %g]\n"	*(char)
"New seed --> %g\n"	*(char)
,	O
SEED_MIN	O
,	O
SEED_MAX	O
,	O
dSeed	double
)	O
;	O
vRandRec	O
.	O
seed	O
=	O
dSeed	double
;	O
vbNoSeed	O
=	O
FALSE	O
;	O
vbSwitchGauss	O
=	O
FALSE	O
;	O
}	O
void	O
InitRandom	(int,double,int)->(void)
(	O
int	O
rank	int
,	O
double	O
dSeed	double
,	O
int	O
bWarmUp	int
)	O
{	O
long	O
i	O
;	O
if	O
(	O
vbNoSeed	O
||	O
dSeed	double
!=	O
SEED_DEFAULT	O
)	O
SetSeed	(double)->(void)
(	O
dSeed	double
)	O
;	O
if	O
(	O
bWarmUp	int
)	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
50	int
;	O
i	O
++	O
)	O
(	O
void	O
)	O
Randoms	()->(double)
(	O
)	O
;	O
vbNotInitd	O
=	O
FALSE	O
;	O
}	O
}	O
double	O
Randoms	()->(double)
(	O
void	O
)	O
{	O
double	O
hi	O
,	O
test	O
;	O
if	O
(	O
vbNoSeed	O
)	O
SetSeed	(double)->(void)
(	O
SEED_DEFAULT	O
)	O
;	O
hi	O
=	O
(	O
long	O
)	O
(	O
vRandRec	O
.	O
seed	O
/	O
q	O
)	O
;	O
test	O
=	O
a	double
*	O
(	O
vRandRec	O
.	O
seed	O
-	O
q	O
*	O
hi	O
)	O
-	O
r	O
*	O
hi	O
;	O
if	O
(	O
test	O
>	O
0.0	int
)	O
vRandRec	O
.	O
seed	O
=	O
test	O
;	O
else	O
vRandRec	O
.	O
seed	O
=	O
test	O
+	O
m	O
;	O
return	O
(	O
vRandRec	O
.	O
seed	O
/	O
m	O
)	O
;	O
}	O
double	O
BetaRandom	(double,double,double,double)->(double)
(	O
double	O
alpha	double
,	O
double	O
beta	double
,	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
double	O
u1	O
,	O
u2	O
,	O
w	*(double)
;	O
if	O
(	O
b	double
<=	O
a	double
||	O
alpha	double
<=	O
0	int
||	O
beta	double
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad shape or range for a beta variate - Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
alpha	double
<	O
1	int
)	O
&&	O
(	O
beta	double
<	O
1	int
)	O
)	O
do	O
{	O
u1	O
=	O
Randoms	()->(double)
(	O
)	O
;	O
u2	O
=	O
Randoms	()->(double)
(	O
)	O
;	O
u1	O
=	O
pow	(double,double)->(double)
(	O
u1	O
,	O
1	int
/	O
alpha	double
)	O
;	O
u2	O
=	O
pow	(double,double)->(double)
(	O
u2	O
,	O
1	int
/	O
beta	double
)	O
;	O
w	*(double)
=	O
u1	O
+	O
u2	O
;	O
}	O
while	O
(	O
w	*(double)
>	O
1.0	int
)	O
;	O
else	O
{	O
u1	O
=	O
GammaRandom	(double)->(double)
(	O
alpha	double
)	O
;	O
u2	O
=	O
GammaRandom	(double)->(double)
(	O
beta	double
)	O
;	O
w	*(double)
=	O
u1	O
+	O
u2	O
;	O
}	O
return	O
(	O
a	double
+	O
(	O
u1	O
/	O
w	*(double)
)	O
*	O
(	O
b	double
-	O
a	double
)	O
)	O
;	O
}	O
double	O
BinomialBetaRandom	(double,double,double)->(double)
(	O
double	O
Expectation	double
,	O
double	O
alpha	double
,	O
double	O
beta	double
)	O
{	O
double	O
dTmp	O
=	O
Expectation	double
+	O
Expectation	double
*	O
beta	double
/	O
alpha	double
;	O
if	O
(	O
dTmp	O
<	O
LONG_MAX	O
)	O
return	O
BinomialRandom	(double,long)->(double)
(	O
BetaRandom	(double,double,double,double)->(double)
(	O
alpha	double
,	O
beta	double
,	O
0	int
,	O
1	int
)	O
,	O
(	O
long	O
)	O
dTmp	O
)	O
;	O
else	O
{	O
printf	(*(char))->(int)
(	O
"BinomialBetaRandom: N (= %g) too large - Exiting..."	*(char)
,	O
dTmp	O
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
}	O
double	O
BinomialRandom	(double,long)->(double)
(	O
double	O
p	double
,	O
long	O
N	O
)	O
{	O
long	O
j	O
;	O
static	O
long	O
iOldN	O
=	O
-	O
1	int
;	O
double	O
dAngle	O
,	O
dDeviate	O
,	O
dMean	double
,	O
dPtemp	O
,	O
dSqrt	O
,	O
dTangent	O
,	O
dTemp1	O
,	O
dTemp2	O
;	O
static	O
double	O
dLnFactN	O
,	O
dPold	O
=	O
-	O
1	int
,	O
dLnP	O
,	O
dQ	O
,	O
dLnQ	O
;	O
if	O
(	O
p	double
<	O
0	int
||	O
p	double
>	O
1	int
||	O
N	O
<	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: parameters out of bounds for a binomial variate "	*(char)
"- Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
dPtemp	O
=	O
(	O
p	double
<=	O
0.5	int
?	O
p	double
:	O
1	int
-	O
p	double
)	O
;	O
dMean	double
=	O
N	O
*	O
dPtemp	O
;	O
if	O
(	O
N	O
<	O
25	int
)	O
{	O
dDeviate	O
=	O
0	int
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<	O
N	O
;	O
j	O
++	O
)	O
if	O
(	O
Randoms	()->(double)
(	O
)	O
<	O
dPtemp	O
)	O
dDeviate	O
=	O
dDeviate	O
+	O
1	int
;	O
}	O
else	O
if	O
(	O
dMean	double
<	O
1	int
)	O
{	O
dTemp1	O
=	O
exp	(double)->(double)
(	O
-	O
dMean	double
)	O
;	O
dTemp2	O
=	O
1.0	int
;	O
for	O
(	O
j	O
=	O
0	int
;	O
j	O
<=	O
N	O
;	O
j	O
++	O
)	O
{	O
dTemp2	O
=	O
dTemp2	O
*	O
Randoms	()->(double)
(	O
)	O
;	O
if	O
(	O
dTemp2	O
<	O
dTemp1	O
)	O
break	O
;	O
}	O
dDeviate	O
=	O
(	O
j	O
<=	O
N	O
?	O
j	O
:	O
N	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
N	O
!=	O
iOldN	O
)	O
{	O
dLnFactN	O
=	O
lnGamma	(double)->(double)
(	O
(	O
double	O
)	O
N	O
+	O
1	int
)	O
;	O
iOldN	O
=	O
N	O
;	O
}	O
if	O
(	O
dPtemp	O
!=	O
dPold	O
)	O
{	O
dPold	O
=	O
dPtemp	O
;	O
dQ	O
=	O
1	int
-	O
dPtemp	O
;	O
dLnP	O
=	O
log	(double)->(double)
(	O
dPtemp	O
)	O
;	O
dLnQ	O
=	O
log	(double)->(double)
(	O
dQ	O
)	O
;	O
}	O
dSqrt	O
=	O
sqrt	(double)->(double)
(	O
2	int
*	O
dMean	double
*	O
dQ	O
)	O
;	O
do	O
{	O
do	O
{	O
dAngle	O
=	O
PI	O
*	O
Randoms	()->(double)
(	O
)	O
;	O
dTangent	O
=	O
tan	(double)->(double)
(	O
dAngle	O
)	O
;	O
dTemp1	O
=	O
dSqrt	O
*	O
dTangent	O
+	O
dMean	double
;	O
}	O
while	O
(	O
dTemp1	O
<	O
0	int
||	O
dTemp1	O
>=	O
(	O
N	O
+	O
1	int
)	O
)	O
;	O
dTemp1	O
=	O
floor	(double)->(double)
(	O
dTemp1	O
)	O
;	O
dTemp2	O
=	O
1.2	int
*	O
dSqrt	O
*	O
(	O
1	int
+	O
dTangent	O
*	O
dTangent	O
)	O
*	O
exp	(double)->(double)
(	O
dLnFactN	O
-	O
lnGamma	(double)->(double)
(	O
dTemp1	O
+	O
1	int
)	O
-	O
lnGamma	(double)->(double)
(	O
N	O
-	O
dTemp1	O
+	O
1	int
)	O
+	O
dTemp1	O
*	O
dLnP	O
+	O
(	O
N	O
-	O
dTemp1	O
)	O
*	O
dLnQ	O
)	O
;	O
}	O
while	O
(	O
Randoms	()->(double)
(	O
)	O
>	O
dTemp2	O
)	O
;	O
dDeviate	O
=	O
dTemp1	O
;	O
}	O
if	O
(	O
dPtemp	O
!=	O
p	double
)	O
dDeviate	O
=	O
N	O
-	O
dDeviate	O
;	O
return	O
(	O
dDeviate	O
)	O
;	O
}	O
double	O
CauchyRandom	(double)->(double)
(	O
double	O
dScale	double
)	O
{	O
double	O
z	double
,	O
x	*(*(double))
;	O
z	double
=	O
NormalRandom	(double,double)->(double)
(	O
0	int
,	O
dScale	double
)	O
;	O
x	*(*(double))
=	O
GGammaRandom	(double,double)->(double)
(	O
0.5	int
,	O
0.5	int
)	O
;	O
return	O
(	O
z	double
/	O
sqrt	(double)->(double)
(	O
x	*(*(double))
)	O
)	O
;	O
}	O
double	O
Chi2Random	(double)->(double)
(	O
double	O
dof	double
)	O
{	O
return	O
(	O
GGammaRandom	(double,double)->(double)
(	O
dof	double
/	O
2.0	int
,	O
0.5	int
)	O
)	O
;	O
}	O
double	O
ExpRandom	(double)->(double)
(	O
double	O
beta	double
)	O
{	O
if	O
(	O
beta	double
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: negative or null inverse scale for an exponential variate "	*(char)
"- Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
return	O
-	O
log	(double)->(double)
(	O
Randoms	()->(double)
(	O
)	O
)	O
/	O
beta	double
;	O
}	O
double	O
GammaRandom	(double)->(double)
(	O
double	O
alpha	double
)	O
{	O
static	O
double	O
aprev	O
=	O
0.0	int
,	O
c1	O
,	O
c2	O
,	O
c3	O
,	O
c4	O
,	O
c5	O
;	O
double	O
b	double
,	O
u1	O
,	O
u2	O
,	O
w	*(double)
,	O
x	*(*(double))
;	O
if	O
(	O
alpha	double
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: negative or null shape parameter for a gamma variate "	*(char)
"- Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
alpha	double
<	O
1	int
)	O
{	O
b	double
=	O
(	O
alpha	double
+	O
E	O
)	O
/	O
E	O
;	O
do	O
{	O
u1	O
=	O
b	double
*	O
Randoms	()->(double)
(	O
)	O
;	O
if	O
(	O
u1	O
<=	O
1.0	int
)	O
{	O
x	*(*(double))
=	O
pow	(double,double)->(double)
(	O
u1	O
,	O
1.	int
/	O
alpha	double
)	O
;	O
if	O
(	O
(	O
x	*(*(double))
>	O
DBL_MIN	O
)	O
&&	O
(	O
x	*(*(double))
<=	O
-	O
log	(double)->(double)
(	O
Randoms	()->(double)
(	O
)	O
)	O
)	O
)	O
return	O
(	O
x	*(*(double))
)	O
;	O
}	O
else	O
{	O
x	*(*(double))
=	O
-	O
log	(double)->(double)
(	O
(	O
b	double
-	O
u1	O
)	O
/	O
alpha	double
)	O
;	O
if	O
(	O
pow	(double,double)->(double)
(	O
x	*(*(double))
,	O
alpha	double
-	O
1	int
)	O
>=	O
Randoms	()->(double)
(	O
)	O
)	O
return	O
(	O
x	*(*(double))
)	O
;	O
}	O
}	O
while	O
(	O
1	int
==	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
alpha	double
>	O
1	int
)	O
{	O
if	O
(	O
alpha	double
!=	O
aprev	O
)	O
{	O
aprev	O
=	O
alpha	double
;	O
c1	O
=	O
alpha	double
-	O
1	int
;	O
b	double
=	O
1.0	int
/	O
c1	O
;	O
c2	O
=	O
b	double
*	O
(	O
alpha	double
-	O
(	O
1	int
/	O
(	O
6.0	int
*	O
alpha	double
)	O
)	O
)	O
;	O
c3	O
=	O
2	int
*	O
b	double
;	O
c4	O
=	O
c3	O
+	O
2.0	int
;	O
if	O
(	O
alpha	double
>	O
2.5	int
)	O
c5	O
=	O
1.0	int
/	O
sqrt	(double)->(double)
(	O
alpha	double
)	O
;	O
}	O
do	O
{	O
do	O
{	O
u1	O
=	O
Randoms	()->(double)
(	O
)	O
;	O
u2	O
=	O
Randoms	()->(double)
(	O
)	O
;	O
if	O
(	O
alpha	double
>	O
2.5	int
)	O
u1	O
=	O
u2	O
+	O
c5	O
*	O
(	O
1	int
-	O
1.86	int
*	O
u1	O
)	O
;	O
}	O
while	O
(	O
(	O
u1	O
>=	O
1	int
)	O
||	O
(	O
u1	O
<=	O
0	int
)	O
)	O
;	O
w	*(double)
=	O
c2	O
*	O
u2	O
/	O
u1	O
;	O
if	O
(	O
(	O
(	O
c3	O
*	O
u1	O
+	O
w	*(double)
+	O
1	int
/	O
w	*(double)
)	O
<=	O
c4	O
)	O
||	O
(	O
(	O
c3	O
*	O
log	(double)->(double)
(	O
u1	O
)	O
-	O
log	(double)->(double)
(	O
w	*(double)
)	O
+	O
w	*(double)
)	O
<	O
1	int
)	O
)	O
return	O
(	O
c1	O
*	O
w	*(double)
)	O
;	O
}	O
while	O
(	O
1	int
==	O
1	int
)	O
;	O
}	O
else	O
return	O
ExpRandom	(double)->(double)
(	O
1.0	int
)	O
;	O
}	O
}	O
double	O
GenLogNormalRandom	(double,double,double)->(double)
(	O
double	O
dMean	double
,	O
double	O
dStdDevNorm	double
,	O
double	O
dStdDevLogNorm	double
)	O
{	O
double	O
dmuz	O
,	O
dSLogNorm	O
,	O
dLambda	O
,	O
dz	O
;	O
if	O
(	O
dMean	double
<	O
0	int
)	O
{	O
char	O
str	O
[	O
10	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
str	O
,	O
"%5.2e"	*(char)
,	O
dMean	double
)	O
;	O
ReportRunTimeError	O
(	O
NULL	O
,	O
RE_BADLOGNORMALMEAN	O
|	O
RE_FATAL	O
,	O
""	*(char)
,	O
str	O
,	O
"GenLogNormalRandom"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
dStdDevLogNorm	double
<=	O
0	int
)	O
{	O
char	O
str	O
[	O
10	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
str	O
,	O
"%5.2e"	*(char)
,	O
dStdDevLogNorm	double
)	O
;	O
ReportRunTimeError	O
(	O
NULL	O
,	O
RE_BADLOGNORMALSD	O
|	O
RE_FATAL	O
,	O
""	*(char)
,	O
str	O
,	O
"GenLogNormalRandom"	*(char)
)	O
;	O
}	O
dSLogNorm	O
=	O
sqrt	(double)->(double)
(	O
exp	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
dStdDevLogNorm	double
,	O
2	int
)	O
)	O
*	O
(	O
exp	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
dStdDevLogNorm	double
,	O
2	int
)	O
)	O
-	O
1	int
)	O
)	O
;	O
dLambda	O
=	O
pow	(double,double)->(double)
(	O
dStdDevNorm	double
/	O
dSLogNorm	O
,	O
2	int
)	O
;	O
dmuz	O
=	O
log	(double)->(double)
(	O
dMean	double
+	O
sqrt	(double)->(double)
(	O
pow	(double,double)->(double)
(	O
dMean	double
,	O
2	int
)	O
+	O
dLambda	O
)	O
)	O
;	O
dz	O
=	O
NormalRandom	(double,double)->(double)
(	O
dmuz	O
,	O
dSLogNorm	O
)	O
;	O
return	O
(	O
exp	(double)->(double)
(	O
dz	O
)	O
-	O
dLambda	O
*	O
exp	(double)->(double)
(	O
-	O
dz	O
)	O
)	O
/	O
2	int
;	O
}	O
double	O
GGammaRandom	(double,double)->(double)
(	O
double	O
alpha	double
,	O
double	O
beta	double
)	O
{	O
if	O
(	O
beta	double
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: negative or null inverse scale for a gamma variate "	*(char)
"- Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
return	O
GammaRandom	(double)->(double)
(	O
alpha	double
)	O
/	O
beta	double
;	O
}	O
double	O
InvGGammaRandom	(double,double)->(double)
(	O
double	O
alpha	double
,	O
double	O
beta	double
)	O
{	O
if	O
(	O
beta	double
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: negative or null scale for an inverse gamma variate "	*(char)
"- Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
return	O
beta	double
/	O
GammaRandom	(double)->(double)
(	O
alpha	double
)	O
;	O
}	O
double	O
LogNormalRandom	(double,double)->(double)
(	O
double	O
dMean	double
,	O
double	O
dStdDev	double
)	O
{	O
if	O
(	O
dMean	double
<=	O
0	int
)	O
{	O
char	O
str	O
[	O
10	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
str	O
,	O
"%5.2e"	*(char)
,	O
dMean	double
)	O
;	O
ReportRunTimeError	O
(	O
NULL	O
,	O
RE_BADLOGNORMALMEAN	O
|	O
RE_FATAL	O
,	O
""	*(char)
,	O
str	O
,	O
"LogNormalRandom"	*(char)
)	O
;	O
}	O
else	O
if	O
(	O
dStdDev	double
<	O
1	int
)	O
{	O
char	O
str	O
[	O
10	int
]	O
;	O
sprintf	(*(char),*(char))->(int)
(	O
str	O
,	O
"%5.2e"	*(char)
,	O
dStdDev	double
)	O
;	O
ReportRunTimeError	O
(	O
NULL	O
,	O
RE_BADLOGNORMALSD	O
|	O
RE_FATAL	O
,	O
""	*(char)
,	O
str	O
,	O
"LogNormalRandom"	*(char)
)	O
;	O
}	O
return	O
exp	(double)->(double)
(	O
NormalRandom	(double,double)->(double)
(	O
log	(double)->(double)
(	O
dMean	double
)	O
,	O
log	(double)->(double)
(	O
dStdDev	double
)	O
)	O
)	O
;	O
}	O
double	O
LogUniformRandom	(double,double)->(double)
(	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
if	O
(	O
b	double
<	O
a	double
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad range a for uniform variate - Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
return	O
(	O
a	double
*	O
pow	(double,double)->(double)
(	O
b	double
/	O
a	double
,	O
Randoms	()->(double)
(	O
)	O
)	O
)	O
;	O
}	O
void	O
Multinomial	(long,int,*(double),*(double))->(void)
(	O
long	O
n	int
,	O
int	O
dim	int
,	O
double	O
*	O
p	double
,	O
double	O
*	O
x	*(*(double))
)	O
{	O
int	O
i	O
;	O
double	O
sum	O
,	O
ptemp	O
;	O
sum	O
=	O
1	int
;	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<=	O
dim	int
;	O
i	O
++	O
)	O
{	O
if	O
(	O
p	double
[	O
i	O
]	O
)	O
{	O
ptemp	O
=	O
p	double
[	O
i	O
]	O
/	O
sum	O
;	O
x	*(*(double))
[	O
i	O
]	O
=	O
BinomialRandom	(double,long)->(double)
(	O
ptemp	O
,	O
n	int
)	O
;	O
n	int
=	O
n	int
-	O
(	O
long	O
)	O
x	*(*(double))
[	O
i	O
]	O
;	O
sum	O
=	O
sum	O
-	O
p	double
[	O
i	O
]	O
;	O
}	O
else	O
x	*(*(double))
[	O
i	O
]	O
=	O
0.0	int
;	O
}	O
}	O
double	O
NormalRandom	(double,double)->(double)
(	O
double	O
dMean	double
,	O
double	O
dStdDev	double
)	O
{	O
double	O
dRacine	O
,	O
dTemp1	O
,	O
dTemp2	O
,	O
dTemp3	O
;	O
static	O
double	O
memGauss	O
;	O
if	O
(	O
vbSwitchGauss	O
)	O
{	O
vbSwitchGauss	O
=	O
FALSE	O
;	O
return	O
(	O
dMean	double
+	O
dStdDev	double
*	O
memGauss	O
)	O
;	O
}	O
do	O
{	O
dTemp1	O
=	O
2	int
*	O
Randoms	()->(double)
(	O
)	O
-	O
1	int
;	O
dTemp2	O
=	O
2	int
*	O
Randoms	()->(double)
(	O
)	O
-	O
1	int
;	O
dRacine	O
=	O
dTemp1	O
*	O
dTemp1	O
+	O
dTemp2	O
*	O
dTemp2	O
;	O
}	O
while	O
(	O
(	O
dRacine	O
>=	O
1	int
)	O
||	O
(	O
dRacine	O
==	O
0	int
)	O
)	O
;	O
dTemp3	O
=	O
sqrt	(double)->(double)
(	O
-	O
2	int
*	O
log	(double)->(double)
(	O
dRacine	O
)	O
/	O
dRacine	O
)	O
;	O
vbSwitchGauss	O
=	O
TRUE	O
;	O
memGauss	O
=	O
dTemp1	O
*	O
dTemp3	O
;	O
return	O
(	O
dMean	double
+	O
dStdDev	double
*	O
(	O
dTemp2	O
*	O
dTemp3	O
)	O
)	O
;	O
}	O
long	O
PoissonRandom	(double)->(long)
(	O
double	O
mu	double
)	O
{	O
double	O
u1	O
,	O
x	*(*(double))
,	O
u2	O
,	O
lnfact	O
,	O
s	O
,	O
t	*(double)
;	O
static	O
double	O
prev_mu	O
=	O
0	int
,	O
c	O
,	O
beta	double
,	O
alpha	double
,	O
k	O
;	O
long	O
n	int
=	O
0	int
;	O
if	O
(	O
mu	double
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: negative or null rate for a Poisson variate "	*(char)
"- Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
mu	double
<=	O
60	int
)	O
{	O
s	O
=	O
1	int
;	O
t	*(double)
=	O
1	int
;	O
u1	O
=	O
Randoms	()->(double)
(	O
)	O
*	O
exp	(double)->(double)
(	O
mu	double
)	O
;	O
while	O
(	O
s	O
<	O
u1	O
)	O
{	O
n	int
++	O
;	O
t	*(double)
=	O
t	*(double)
*	O
mu	double
/	O
n	int
;	O
s	O
=	O
s	O
+	O
t	*(double)
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mu	double
!=	O
prev_mu	O
)	O
{	O
c	O
=	O
0.767	int
-	O
3.36	int
/	O
mu	double
;	O
beta	double
=	O
PI	O
/	O
sqrt	(double)->(double)
(	O
3	int
*	O
mu	double
)	O
;	O
alpha	double
=	O
beta	double
*	O
mu	double
;	O
k	O
=	O
log	(double)->(double)
(	O
c	O
)	O
-	O
mu	double
-	O
log	(double)->(double)
(	O
beta	double
)	O
;	O
}	O
do	O
{	O
do	O
{	O
u1	O
=	O
Randoms	()->(double)
(	O
)	O
;	O
x	*(*(double))
=	O
(	O
alpha	double
-	O
log	(double)->(double)
(	O
(	O
1	int
-	O
u1	O
)	O
/	O
u1	O
)	O
)	O
/	O
beta	double
;	O
}	O
while	O
(	O
x	*(*(double))
<=	O
-	O
0.5	int
)	O
;	O
n	int
=	O
(	O
long	O
)	O
(	O
x	*(*(double))
+	O
0.5	int
)	O
;	O
u2	O
=	O
Randoms	()->(double)
(	O
)	O
;	O
lnfact	O
=	O
0.918938533	int
-	O
n	int
+	O
(	O
n	int
+	O
0.5	int
)	O
*	O
log	(double)->(double)
(	O
n	int
)	O
;	O
}	O
while	O
(	O
alpha	double
-	O
beta	double
*	O
x	*(*(double))
+	O
log	(double)->(double)
(	O
u2	O
/	O
pow	(double,double)->(double)
(	O
(	O
1	int
+	O
exp	(double)->(double)
(	O
alpha	double
-	O
beta	double
*	O
x	*(*(double))
)	O
)	O
,	O
2	int
)	O
)	O
>	O
k	O
+	O
n	int
*	O
log	(double)->(double)
(	O
mu	double
)	O
-	O
lnfact	O
)	O
;	O
}	O
return	O
n	int
;	O
}	O
double	O
StudentTRandom	(double,double,double)->(double)
(	O
double	O
dof	double
,	O
double	O
dMean	double
,	O
double	O
dStdDev	double
)	O
{	O
double	O
z	double
,	O
x	*(*(double))
;	O
if	O
(	O
dof	double
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: StudentTRandom: dof <= 0\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
z	double
=	O
NormalRandom	(double,double)->(double)
(	O
0	int
,	O
1	int
)	O
;	O
x	*(*(double))
=	O
Chi2Random	(double)->(double)
(	O
dof	double
)	O
;	O
return	O
(	O
dMean	double
+	O
dStdDev	double
*	O
z	double
*	O
sqrt	(double)->(double)
(	O
dof	double
/	O
x	*(*(double))
)	O
)	O
;	O
}	O
double	O
TruncInvGGammaRandom	(double,double,double,double)->(double)
(	O
double	O
alpha	double
,	O
double	O
beta	double
,	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
double	O
X	O
=	O
0.0	int
;	O
int	O
iter	O
=	O
0	int
;	O
if	O
(	O
a	double
>=	O
b	double
)	O
printf	(*(char))->(int)
(	O
"TruncLogNormalRandom: min >= max  [%g %g]\n"	*(char)
,	O
a	double
,	O
b	double
)	O
;	O
else	O
do	O
{	O
if	O
(	O
++	O
iter	O
==	O
25	int
)	O
{	O
printf	(*(char))->(int)
(	O
"TruncInvGGammaRandom: problem with range: "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"min %g, max %g, alpha %g, beta %g\n"	*(char)
,	O
a	double
,	O
b	double
,	O
alpha	double
,	O
beta	double
)	O
;	O
}	O
X	O
=	O
InvGGammaRandom	(double,double)->(double)
(	O
alpha	double
,	O
beta	double
)	O
;	O
}	O
while	O
(	O
X	O
<	O
a	double
||	O
X	O
>	O
b	double
)	O
;	O
return	O
X	O
;	O
}	O
double	O
TruncLogNormalRandom	(double,double,double,double)->(double)
(	O
double	O
dMean	double
,	O
double	O
dStdDev	double
,	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
double	O
X	O
=	O
0.0	int
;	O
int	O
iter	O
=	O
0	int
;	O
if	O
(	O
a	double
>=	O
b	double
)	O
printf	(*(char))->(int)
(	O
"TruncLogNormalRandom: min >= max  [%g %g]\n"	*(char)
,	O
a	double
,	O
b	double
)	O
;	O
else	O
do	O
{	O
if	O
(	O
++	O
iter	O
==	O
25	int
)	O
{	O
printf	(*(char))->(int)
(	O
"TruncLogNormalRandom: problem with range: "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"min %g, max %g, ave %g, sd %g\n"	*(char)
,	O
a	double
,	O
b	double
,	O
dMean	double
,	O
dStdDev	double
)	O
;	O
}	O
X	O
=	O
LogNormalRandom	(double,double)->(double)
(	O
dMean	double
,	O
dStdDev	double
)	O
;	O
}	O
while	O
(	O
X	O
<	O
a	double
||	O
X	O
>	O
b	double
)	O
;	O
return	O
X	O
;	O
}	O
double	O
TruncNormalRandom	(double,double,double,double)->(double)
(	O
double	O
dMean	double
,	O
double	O
dStdDev	double
,	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
double	O
X	O
=	O
0.0	int
;	O
int	O
iter	O
=	O
0	int
;	O
if	O
(	O
a	double
>=	O
b	double
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: TruncNormalRandom: min >= max  [%g %g]\n"	*(char)
,	O
a	double
,	O
b	double
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
else	O
do	O
{	O
if	O
(	O
++	O
iter	O
==	O
25	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Warning: TruncNormalRandom: problem with range: "	*(char)
)	O
;	O
printf	(*(char))->(int)
(	O
"min %g, max %g, ave %g, sd %g\n"	*(char)
,	O
a	double
,	O
b	double
,	O
dMean	double
,	O
dStdDev	double
)	O
;	O
}	O
X	O
=	O
NormalRandom	(double,double)->(double)
(	O
dMean	double
,	O
dStdDev	double
)	O
;	O
}	O
while	O
(	O
X	O
<	O
a	double
||	O
X	O
>	O
b	double
)	O
;	O
return	O
X	O
;	O
}	O
double	O
UniformRandom	(double,double)->(double)
(	O
double	O
a	double
,	O
double	O
b	double
)	O
{	O
if	O
(	O
b	double
<	O
a	double
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad range a for uniform variate - Exiting\n\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
return	O
(	O
Randoms	()->(double)
(	O
)	O
*	O
(	O
b	double
-	O
a	double
)	O
+	O
a	double
)	O
;	O
}	O
void	O
WishartRandom	(long,long,*(double),*(double),*(double))->(void)
(	O
long	O
n	int
,	O
long	O
p	double
,	O
double	O
*	O
t	*(double)
,	O
double	O
*	O
w	*(double)
,	O
double	O
*	O
work	*(double)
)	O
{	O
double	O
eta	O
,	O
sum	O
;	O
long	O
i	O
,	O
j	O
,	O
k	O
,	O
m	O
,	O
k1	O
,	O
k2	O
,	O
k3	O
;	O
printf	(*(char))->(int)
(	O
"WishartRandom not tested - Exiting..."	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
for	O
(	O
j	O
=	O
0	int
,	O
k	O
=	O
0	int
;	O
j	O
<	O
p	double
;	O
j	O
++	O
)	O
{	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
j	O
;	O
i	O
++	O
)	O
w	*(double)
[	O
k	O
++	O
]	O
=	O
NormalRandom	(double,double)->(double)
(	O
0	int
,	O
1	int
)	O
;	O
w	*(double)
[	O
k	O
++	O
]	O
=	O
GGammaRandom	(double,double)->(double)
(	O
(	O
n	int
-	O
i	O
)	O
/	O
2.0	int
,	O
0.5	int
)	O
;	O
}	O
for	O
(	O
j	O
=	O
p	double
-	O
1	int
,	O
m	O
=	O
k	O
-	O
1	int
,	O
k2	O
=	O
(	O
p	double
*	O
(	O
p	double
-	O
1	int
)	O
)	O
/	O
2	int
;	O
j	O
>=	O
0	int
;	O
k2	O
=	O
k2	O
-	O
(	O
j	O
--	O
)	O
)	O
{	O
eta	O
=	O
w	*(double)
[	O
m	O
]	O
;	O
for	O
(	O
i	O
=	O
j	O
,	O
k1	O
=	O
(	O
i	O
*	O
(	O
i	O
+	O
1	int
)	O
)	O
/	O
2	int
;	O
i	O
>=	O
0	int
;	O
k1	O
=	O
k1	O
-	O
(	O
i	O
--	O
)	O
,	O
m	O
--	O
)	O
{	O
for	O
(	O
k	O
=	O
0	int
,	O
sum	O
=	O
0.0	int
;	O
k	O
<	O
i	O
;	O
k	O
++	O
)	O
sum	O
=	O
sum	O
+	O
w	*(double)
[	O
k1	O
+	O
k	O
]	O
*	O
w	*(double)
[	O
k2	O
+	O
k	O
]	O
;	O
if	O
(	O
i	O
==	O
j	O
)	O
w	*(double)
[	O
m	O
]	O
=	O
sum	O
+	O
eta	O
;	O
else	O
w	*(double)
[	O
m	O
]	O
=	O
sum	O
+	O
sqrt	(double)->(double)
(	O
eta	O
)	O
*	O
w	*(double)
[	O
m	O
]	O
;	O
}	O
}	O
for	O
(	O
i	O
=	O
0	int
,	O
k1	O
=	O
0	int
,	O
m	O
=	O
0	int
;	O
i	O
<	O
p	double
;	O
k1	O
=	O
k1	O
+	O
(	O
++	O
i	O
)	O
)	O
{	O
for	O
(	O
j	O
=	O
0	int
,	O
k2	O
=	O
0	int
;	O
j	O
<	O
p	double
;	O
k2	O
=	O
k2	O
+	O
(	O
++	O
j	O
)	O
,	O
m	O
++	O
)	O
{	O
for	O
(	O
k	O
=	O
0	int
,	O
sum	O
=	O
0.0	int
;	O
k	O
<	O
j	O
;	O
k	O
++	O
)	O
sum	O
=	O
sum	O
+	O
t	*(double)
[	O
k1	O
+	O
k	O
]	O
*	O
w	*(double)
[	O
k2	O
+	O
k	O
]	O
;	O
for	O
(	O
k	O
=	O
j	O
,	O
k3	O
=	O
j	O
;	O
k	O
<=	O
i	O
;	O
k3	O
=	O
k3	O
+	O
(	O
++	O
k	O
)	O
)	O
sum	O
=	O
sum	O
+	O
t	*(double)
[	O
k1	O
+	O
k	O
]	O
*	O
w	*(double)
[	O
k2	O
+	O
k3	O
]	O
;	O
work	*(double)
[	O
m	O
]	O
=	O
sum	O
;	O
}	O
}	O
for	O
(	O
i	O
=	O
0	int
,	O
m	O
=	O
0	int
,	O
k1	O
=	O
0	int
;	O
i	O
<	O
p	double
;	O
i	O
++	O
,	O
k1	O
=	O
k1	O
+	O
p	double
)	O
{	O
for	O
(	O
j	O
=	O
0	int
,	O
k2	O
=	O
0	int
;	O
j	O
<=	O
i	O
;	O
k2	O
=	O
k2	O
+	O
(	O
++	O
j	O
)	O
,	O
m	O
++	O
)	O
{	O
for	O
(	O
k	O
=	O
0	int
,	O
sum	O
=	O
0.0	int
;	O
k	O
<=	O
j	O
;	O
k	O
++	O
)	O
sum	O
=	O
sum	O
+	O
work	*(double)
[	O
k1	O
+	O
k	O
]	O
*	O
t	*(double)
[	O
k2	O
+	O
k	O
]	O
;	O
w	*(double)
[	O
m	O
]	O
=	O
sum	O
;	O
}	O
}	O
}	O
BOOL	int
and	(int,int)->(int)
(	O
BOOL	int
A	int
,	O
BOOL	int
B	int
)	O
{	O
return	O
(	O
A	int
&&	O
B	int
)	O
;	O
}	O
void	O
CalcCumulative	(long,*(double),*(double),*(double),int)->(void)
(	O
long	O
cDim	long
,	O
double	O
*	O
rg_x	array(double)
,	O
double	O
*	O
rg_pdf	array(double)
,	O
double	O
*	O
rg_Cdf	array(double)
,	O
int	O
iOrder	int
)	O
{	O
long	O
i	O
;	O
if	O
(	O
iOrder	int
>	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"CalcCumulative: Order %d not supported"	*(char)
"-> using piecewise-linear\n"	*(char)
,	O
iOrder	int
)	O
;	O
iOrder	int
=	O
1	int
;	O
}	O
rg_Cdf	array(double)
[	O
0	int
]	O
=	O
0.0	int
;	O
switch	O
(	O
iOrder	int
)	O
{	O
case	O
0	int
:	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<	O
cDim	long
;	O
i	O
++	O
)	O
rg_Cdf	array(double)
[	O
i	O
]	O
=	O
rg_Cdf	array(double)
[	O
i	O
-	O
1	int
]	O
+	O
rg_pdf	array(double)
[	O
i	O
]	O
*	O
(	O
rg_x	array(double)
[	O
i	O
]	O
-	O
rg_x	array(double)
[	O
i	O
-	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<	O
cDim	long
;	O
i	O
++	O
)	O
rg_Cdf	array(double)
[	O
i	O
]	O
=	O
rg_Cdf	array(double)
[	O
i	O
-	O
1	int
]	O
+	O
(	O
(	O
rg_x	array(double)
[	O
i	O
]	O
-	O
rg_x	array(double)
[	O
i	O
-	O
1	int
]	O
)	O
*	O
(	O
rg_pdf	array(double)
[	O
i	O
]	O
+	O
rg_pdf	array(double)
[	O
i	O
-	O
1	int
]	O
)	O
/	O
2	int
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
double	O
CDFNormal	(double)->(double)
(	O
double	O
z	double
)	O
{	O
register	O
double	O
tmp	O
;	O
tmp	O
=	O
z	double
/	O
SQRT_2	O
;	O
if	O
(	O
tmp	O
>=	O
0	int
)	O
return	O
(	O
0.5	int
*	O
(	O
2	int
-	O
erfc	(double)->(double)
(	O
tmp	O
)	O
)	O
)	O
;	O
else	O
return	O
(	O
0.5	int
*	O
erfc	(double)->(double)
(	O
-	O
tmp	O
)	O
)	O
;	O
}	O
double	O
erfc	(double)->(double)
(	O
double	O
x	*(*(double))
)	O
{	O
double	O
dAbsX	O
,	O
t	*(double)
,	O
dVal	double
;	O
dAbsX	O
=	O
fabs	(double)->(double)
(	O
x	*(*(double))
)	O
;	O
if	O
(	O
dAbsX	O
>	O
20	int
)	O
{	O
return	O
(	O
x	*(*(double))
>=	O
0	int
?	O
0	int
:	O
2	int
)	O
;	O
}	O
else	O
{	O
t	*(double)
=	O
1	int
/	O
(	O
1	int
+	O
0.5	int
*	O
dAbsX	O
)	O
;	O
dVal	double
=	O
t	*(double)
*	O
exp	(double)->(double)
(	O
-	O
dAbsX	O
*	O
dAbsX	O
-	O
1.26551223	int
+	O
t	*(double)
*	O
(	O
1.00002368	int
+	O
t	*(double)
*	O
(	O
0.37409196	int
+	O
t	*(double)
*	O
(	O
0.09678418	int
+	O
t	*(double)
*	O
(	O
-	O
0.18628806	int
+	O
t	*(double)
*	O
(	O
0.27886807	int
+	O
t	*(double)
*	O
(	O
-	O
1.13520398	int
+	O
t	*(double)
*	O
(	O
1.48851587	int
+	O
t	*(double)
*	O
(	O
-	O
0.82215223	int
+	O
t	*(double)
*	O
(	O
0.17087277	int
)	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
;	O
return	O
(	O
x	*(*(double))
>=	O
0	int
?	O
dVal	double
:	O
2	int
-	O
dVal	double
)	O
;	O
}	O
}	O
double	O
InterpolateX	(array(double),array(double),long,double)->(double)
(	O
double	O
rgX	array(double)
[	O
]	O
,	O
double	O
rgY	array(double)
[	O
]	O
,	O
long	O
lLower	long
,	O
double	O
dY	double
)	O
{	O
return	O
rgX	array(double)
[	O
lLower	long
]	O
+	O
(	O
dY	double
-	O
rgY	array(double)
[	O
lLower	long
]	O
)	O
*	O
(	O
rgX	array(double)
[	O
lLower	long
+	O
1	int
]	O
-	O
rgX	array(double)
[	O
lLower	long
]	O
)	O
/	O
(	O
rgY	array(double)
[	O
lLower	long
+	O
1	int
]	O
-	O
rgY	array(double)
[	O
lLower	long
]	O
)	O
;	O
}	O
double	O
lnDFBeta	(double,double,double,double,double)->(double)
(	O
double	O
x	*(*(double))
,	O
double	O
alpha	double
,	O
double	O
beta	double
,	O
double	O
min	double
,	O
double	O
max	double
)	O
{	O
if	O
(	O
max	double
<=	O
min	double
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad range for beta variate in lnDFBeta\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
alpha	double
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad alpha for beta variate in LnDensity\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
if	O
(	O
beta	double
<=	O
0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: bad beta for beta variate in LnDensity\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
x	*(*(double))
=	O
(	O
x	*(*(double))
-	O
min	double
)	O
/	O
(	O
max	double
-	O
min	double
)	O
;	O
return	O
(	O
alpha	double
-	O
1	int
)	O
*	O
log	(double)->(double)
(	O
x	*(*(double))
)	O
+	O
(	O
beta	double
-	O
1	int
)	O
*	O
log	(double)->(double)
(	O
1	int
-	O
x	*(*(double))
)	O
+	O
lnGamma	(double)->(double)
(	O
alpha	double
+	O
beta	double
)	O
-	O
lnGamma	(double)->(double)
(	O
alpha	double
)	O
-	O
lnGamma	(double)->(double)
(	O
beta	double
)	O
-	O
log	(double)->(double)
(	O
max	double
-	O
min	double
)	O
;	O
}	O
double	O
lnDFNormal	(double,double,double)->(double)
(	O
double	O
x	*(*(double))
,	O
double	O
mu	double
,	O
double	O
sd	double
)	O
{	O
if	O
(	O
sd	double
<=	O
0.0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: negative or null SD in lnDFNormal\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
return	O
(	O
-	O
0.918938533204672669541	int
-	O
log	(double)->(double)
(	O
sd	double
)	O
-	O
0.5	int
*	O
pow	(double,double)->(double)
(	O
(	O
mu	double
-	O
x	*(*(double))
)	O
/	O
sd	double
,	O
2	int
)	O
)	O
;	O
}	O
double	O
lnGamma	(double)->(double)
(	O
double	O
x	*(*(double))
)	O
{	O
double	O
dSeries	O
,	O
dTemp	O
;	O
if	O
(	O
x	*(*(double))
<=	O
0.0	int
)	O
{	O
printf	(*(char))->(int)
(	O
"Error: negative or null parameter for lnGamma function\n"	*(char)
)	O
;	O
exit	(int)->(void)
(	O
0	int
)	O
;	O
}	O
dSeries	O
=	O
1.000000000190015	int
+	O
76.18009172947146	int
/	O
x	*(*(double))
-	O
86.50532032141677	int
/	O
(	O
x	*(*(double))
+	O
1	int
)	O
+	O
24.01409824083091	int
/	O
(	O
x	*(*(double))
+	O
2	int
)	O
-	O
1.231739572450155	int
/	O
(	O
x	*(*(double))
+	O
3	int
)	O
+	O
1.20865097386617E-3	int
/	O
(	O
x	*(*(double))
+	O
4	int
)	O
-	O
5.39523938495E-6	int
/	O
(	O
x	*(*(double))
+	O
5	int
)	O
;	O
dTemp	O
=	O
x	*(*(double))
+	O
4.5	int
;	O
dTemp	O
=	O
-	O
dTemp	O
+	O
(	O
x	*(*(double))
-	O
0.5	int
)	O
*	O
log	(double)->(double)
(	O
dTemp	O
)	O
+	O
log	(double)->(double)
(	O
2.50662827465	int
*	O
dSeries	O
)	O
;	O
return	O
dTemp	O
;	O
}	O
double	O
PiecewiseRandom	(double,double,double,double)->(double)
(	O
double	O
min	double
,	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
max	double
)	O
{	O
double	O
dTemp	O
;	O
static	O
double	O
Grille	O
[	O
4	int
]	O
;	O
static	O
double	O
densite	O
[	O
4	int
]	O
;	O
static	O
double	O
densiteCum	O
[	O
4	int
]	O
;	O
double	O
nvlle_densite	O
;	O
Grille	O
[	O
0	int
]	O
=	O
min	double
;	O
Grille	O
[	O
1	int
]	O
=	O
a	double
;	O
Grille	O
[	O
2	int
]	O
=	O
b	double
;	O
Grille	O
[	O
3	int
]	O
=	O
max	double
;	O
densite	O
[	O
0	int
]	O
=	O
0	int
;	O
densite	O
[	O
1	int
]	O
=	O
1	int
/	O
(	O
max	double
/	O
2	int
+	O
b	double
/	O
2	int
-	O
a	double
/	O
2	int
-	O
min	double
/	O
2	int
)	O
;	O
densite	O
[	O
2	int
]	O
=	O
1	int
/	O
(	O
max	double
/	O
2	int
+	O
b	double
/	O
2	int
-	O
a	double
/	O
2	int
-	O
min	double
/	O
2	int
)	O
;	O
densite	O
[	O
3	int
]	O
=	O
0	int
;	O
CalcCumulative	(long,*(double),*(double),*(double),int)->(void)
(	O
4	int
,	O
Grille	O
,	O
densite	O
,	O
densiteCum	O
,	O
1	int
)	O
;	O
dTemp	O
=	O
PiecewiseVariate	(long,array(double),array(double),array(double),int,*(double))->(double)
(	O
4	int
,	O
Grille	O
,	O
densite	O
,	O
densiteCum	O
,	O
1	int
,	O
&	O
nvlle_densite	O
)	O
;	O
return	O
(	O
dTemp	O
)	O
;	O
}	O
double	O
PiecewiseVariate	(long,array(double),array(double),array(double),int,*(double))->(double)
(	O
long	O
cDim	long
,	O
double	O
rg_x	array(double)
[	O
]	O
,	O
double	O
rg_pdf	array(double)
[	O
]	O
,	O
double	O
rg_Cdf	array(double)
[	O
]	O
,	O
int	O
iOrder	int
,	O
double	O
*	O
pVal_pdf	*(double)
)	O
{	O
double	O
dPWVariate	O
;	O
double	O
dValPdf	O
;	O
double	O
dUniform	O
=	O
UniformRandom	(double,double)->(double)
(	O
0	int
,	O
rg_Cdf	array(double)
[	O
cDim	long
-	O
1	int
]	O
)	O
;	O
long	O
lUpper	O
,	O
lLower	long
,	O
lIndex	O
;	O
if	O
(	O
iOrder	int
>	O
1	int
)	O
{	O
printf	(*(char))->(int)
(	O
"CalcCumulative: Order %d not supported"	*(char)
"-> using piecewise-linear\n"	*(char)
,	O
iOrder	int
)	O
;	O
iOrder	int
=	O
1	int
;	O
}	O
lUpper	O
=	O
cDim	long
;	O
lLower	long
=	O
0	int
;	O
lIndex	O
=	O
0	int
;	O
while	O
(	O
lUpper	O
-	O
lLower	long
>	O
1	int
)	O
{	O
lIndex	O
=	O
(	O
lUpper	O
+	O
lLower	long
)	O
/	O
2	int
;	O
if	O
(	O
dUniform	O
>	O
rg_Cdf	array(double)
[	O
lIndex	O
]	O
)	O
lLower	long
=	O
lIndex	O
;	O
else	O
if	O
(	O
dUniform	O
<	O
rg_Cdf	array(double)
[	O
lIndex	O
]	O
)	O
lUpper	O
=	O
lIndex	O
;	O
else	O
lUpper	O
=	O
lLower	long
=	O
lIndex	O
;	O
}	O
if	O
(	O
lUpper	O
==	O
lLower	long
)	O
{	O
dValPdf	O
=	O
rg_pdf	array(double)
[	O
lLower	long
]	O
;	O
dPWVariate	O
=	O
rg_x	array(double)
[	O
lLower	long
]	O
;	O
}	O
else	O
switch	O
(	O
iOrder	int
)	O
{	O
case	O
0	int
:	O
dValPdf	O
=	O
rg_pdf	array(double)
[	O
lLower	long
]	O
;	O
dPWVariate	O
=	O
InterpolateX	(array(double),array(double),long,double)->(double)
(	O
rg_x	array(double)
,	O
rg_Cdf	array(double)
,	O
lLower	long
,	O
dUniform	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
{	O
if	O
(	O
rg_pdf	array(double)
[	O
lLower	long
]	O
==	O
rg_pdf	array(double)
[	O
lUpper	O
]	O
)	O
{	O
dValPdf	O
=	O
rg_pdf	array(double)
[	O
lLower	long
]	O
;	O
dPWVariate	O
=	O
InterpolateX	(array(double),array(double),long,double)->(double)
(	O
rg_x	array(double)
,	O
rg_Cdf	array(double)
,	O
lLower	long
,	O
dUniform	O
)	O
;	O
}	O
else	O
{	O
double	O
a	double
,	O
b	double
,	O
c	O
,	O
dRadical	O
;	O
a	double
=	O
(	O
rg_pdf	array(double)
[	O
lUpper	O
]	O
-	O
rg_pdf	array(double)
[	O
lLower	long
]	O
)	O
/	O
(	O
rg_x	array(double)
[	O
lUpper	O
]	O
-	O
rg_x	array(double)
[	O
lLower	long
]	O
)	O
;	O
b	double
=	O
rg_pdf	array(double)
[	O
lLower	long
]	O
-	O
a	double
*	O
rg_x	array(double)
[	O
lLower	long
]	O
;	O
c	O
=	O
rg_Cdf	array(double)
[	O
lLower	long
]	O
-	O
(	O
a	double
*	O
rg_x	array(double)
[	O
lLower	long
]	O
/	O
2.0	int
+	O
b	double
)	O
*	O
rg_x	array(double)
[	O
lLower	long
]	O
;	O
dRadical	O
=	O
sqrt	(double)->(double)
(	O
b	double
*	O
b	double
-	O
2	int
*	O
a	double
*	O
(	O
c	O
-	O
dUniform	O
)	O
)	O
;	O
dPWVariate	O
=	O
(	O
-	O
b	double
+	O
dRadical	O
)	O
/	O
a	double
;	O
assert	O
(	O
dPWVariate	O
>=	O
rg_x	array(double)
[	O
lLower	long
]	O
&&	O
dPWVariate	O
<=	O
rg_x	array(double)
[	O
lUpper	O
]	O
)	O
;	O
dValPdf	O
=	O
a	double
*	O
dPWVariate	O
+	O
b	double
;	O
if	O
(	O
a	double
>	O
0	int
)	O
assert	O
(	O
dValPdf	O
>=	O
rg_pdf	array(double)
[	O
lLower	long
]	O
&&	O
dValPdf	O
<=	O
rg_pdf	array(double)
[	O
lUpper	O
]	O
)	O
;	O
else	O
assert	O
(	O
dValPdf	O
<=	O
rg_pdf	array(double)
[	O
lLower	long
]	O
&&	O
dValPdf	O
>=	O
rg_pdf	array(double)
[	O
lUpper	O
]	O
)	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
dValPdf	O
=	O
0	int
;	O
dPWVariate	O
=	O
0	int
;	O
assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
pVal_pdf	*(double)
)	O
*	O
pVal_pdf	*(double)
=	O
dValPdf	O
;	O
return	O
dPWVariate	O
;	O
}	O
