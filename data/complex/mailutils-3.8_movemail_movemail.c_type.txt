static	O
int	O
reverse_order	int
;	O
static	O
int	O
preserve_mail	int
;	O
static	O
int	O
emacs_mode	int
;	O
static	O
int	O
uidl_option	int
;	O
static	O
int	O
verbose_option	int
;	O
static	O
int	O
ignore_errors	int
;	O
static	O
char	O
*	O
program_id_option	*(char)
;	O
static	O
size_t	long
max_messages_option	long
;	O
static	O
int	O
notify	int
;	O
static	O
int	O
progress_meter_option	int
;	O
static	O
int	O
onerror_flags	int
;	O
size_t	long
msg_count	long
=	O
0	int
;	O
size_t	long
get_err_count	long
=	O
0	int
;	O
size_t	long
app_err_count	long
=	O
0	int
;	O
enum	O
set_ownership_mode	enum(int,int,int,int)
{	O
copy_owner_id	int
,	O
copy_owner_name	int
,	O
set_owner_id	int
,	O
set_owner_name	int
}	O
;	O
struct	O
user_id	struct(int,int)
{	O
uid_t	int
uid	int
;	O
gid_t	int
gid	int
;	O
}	O
;	O
struct	O
set_ownership_method	struct(enum(int,int,int,int),union(*(char),struct(int,int)))
{	O
enum	O
set_ownership_mode	enum(int,int,int,int)
mode	int
;	O
union	O
{	O
char	O
*	O
name	*(char)
;	O
struct	O
user_id	struct(int,int)
id	struct(int,int)
;	O
}	O
owner	*(void)
;	O
}	O
;	O
static	O
struct	O
set_ownership_method	struct(enum(int,int,int,int),union(*(char),struct(int,int)))
so_methods	array(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
[	O
SET_OWNERSHIP_MAX	int
]	O
;	O
static	O
int	O
so_method_num	int
;	O
struct	O
set_ownership_method	struct(enum(int,int,int,int),union(*(char),struct(int,int)))
*	O
get_next_so_method	()->(*(struct(enum(int,int,int,int),union(*(char),struct(int,int)))))
(	O
)	O
{	O
if	O
(	O
so_method_num	int
==	O
MU_ARRAY_SIZE	O
(	O
so_methods	array(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"ownership method table overflow"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
return	O
so_methods	array(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
+	O
so_method_num	int
++	O
;	O
}	O
mu_kwd_t	struct
method_kwd	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"copy-id"	*(char)
,	O
copy_owner_id	int
}	O
,	O
{	O
"copy-name"	*(char)
,	O
copy_owner_name	int
}	O
,	O
{	O
"set-name"	*(char)
,	O
set_owner_name	int
}	O
,	O
{	O
"user"	*(char)
,	O
set_owner_name	int
}	O
,	O
{	O
"set-id"	*(char)
,	O
set_owner_id	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
set_mailbox_ownership	(*(char))->(int)
(	O
const	O
char	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"clear"	*(char)
)	O
==	O
0	int
)	O
so_method_num	int
=	O
0	int
;	O
else	O
{	O
int	O
code	int
;	O
char	O
*	O
p	*(char)
;	O
size_t	long
len	long
=	O
strcspn	(*(char),*(char))->(long)
(	O
str	*(char)
,	O
"="	*(char)
)	O
;	O
struct	O
set_ownership_method	struct(enum(int,int,int,int),union(*(char),struct(int,int)))
*	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
;	O
if	O
(	O
mu_kwd_xlat_name_len	(*(struct(*(char),int)),*(char),long,*(int))->(int)
(	O
method_kwd	array(struct(*(char),int))
,	O
str	*(char)
,	O
len	long
,	O
&	O
code	int
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"invalid ownership method: %s"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
=	O
get_next_so_method	()->(*(struct(enum(int,int,int,int),union(*(char),struct(int,int)))))
(	O
)	O
;	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
->	O
mode	int
=	O
code	int
;	O
switch	O
(	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
->	O
mode	int
)	O
{	O
case	O
copy_owner_id	int
:	O
case	O
copy_owner_name	int
:	O
break	O
;	O
case	O
set_owner_id	int
:	O
if	O
(	O
!	O
str	*(char)
[	O
len	long
]	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"ownership method %s requires value"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
str	*(char)
+=	O
len	long
+	O
1	int
;	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
->	O
owner	*(void)
.	O
id	struct(int,int)
.	O
uid	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
,	O
&	O
p	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
)	O
{	O
if	O
(	O
*	O
p	*(char)
==	O
':'	O
)	O
{	O
str	*(char)
=	O
p	*(char)
+	O
1	int
;	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
->	O
owner	*(void)
.	O
id	struct(int,int)
.	O
gid	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
str	*(char)
,	O
&	O
p	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	*(char)
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"expected gid number, but found %s"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"expected uid number, but found %s"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
->	O
owner	*(void)
.	O
id	struct(int,int)
.	O
gid	int
=	O
(	O
gid_t	int
)	O
-	O
1	int
;	O
break	O
;	O
case	O
set_owner_name	int
:	O
if	O
(	O
!	O
str	*(char)
[	O
len	long
]	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"ownership method %s requires value"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
->	O
owner	*(void)
.	O
name	*(char)
=	O
mu_strdup	(*(char))->(*(char))
(	O
str	*(char)
+	O
len	long
+	O
1	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
set_mailbox_ownership_list	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
{	O
if	O
(	O
!	O
strchr	(*(char),int)->(*(char))
(	O
str	*(char)
,	O
','	O
)	O
)	O
return	O
set_mailbox_ownership	(*(char))->(int)
(	O
str	*(char)
)	O
;	O
else	O
{	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
size_t	long
i	long
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_delim	*(char)
=	O
","	*(char)
;	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
str	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_DELIM	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot parse %s: %s"	*(char)
)	O
,	O
str	*(char)
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
if	O
(	O
set_mailbox_ownership	(*(char))->(int)
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	long
]	O
)	O
)	O
return	O
1	int
;	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
return	O
0	int
;	O
}	O
}	O
static	O
int	O
set_onerror_action	(*(void),*(void))->(int)
(	O
void	O
*	O
item	*(void)
,	O
void	O
*	O
data	*(void)
)	O
{	O
char	O
*	O
str	*(char)
=	O
item	*(void)
;	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
str	*(char)
,	O
"abort"	*(char)
)	O
==	O
0	int
)	O
onerror_flags	int
=	O
0	int
;	O
else	O
{	O
static	O
struct	O
mu_kwd	struct(*(char),int)
onerror_kw	array(struct(*(char),int))
[	O
]	O
=	O
{	O
{	O
"skip"	*(char)
,	O
ONERROR_SKIP	int
}	O
,	O
{	O
"delete"	*(char)
,	O
ONERROR_DELETE	int
}	O
,	O
{	O
"count"	*(char)
,	O
ONERROR_COUNT	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
flag	int
,	O
clr	int
=	O
0	int
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
str	*(char)
,	O
"no"	*(char)
,	O
2	int
)	O
==	O
0	int
)	O
{	O
clr	int
=	O
1	int
;	O
str	*(char)
+=	O
2	int
;	O
}	O
if	O
(	O
mu_kwd_xlat_name	(*(struct(*(char),int)),*(char),*(int))->(int)
(	O
onerror_kw	array(struct(*(char),int))
,	O
str	*(char)
,	O
&	O
flag	int
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"unknown keyword: %s"	*(char)
)	O
,	O
str	*(char)
)	O
;	O
return	O
MU_ERR_FAILURE	O
;	O
}	O
if	O
(	O
clr	int
)	O
onerror_flags	int
&=	O
~	O
flag	int
;	O
else	O
onerror_flags	int
|=	O
flag	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
set_onerror_actions	(*(char))->(int)
(	O
char	O
const	O
*	O
str	*(char)
)	O
{	O
mu_list_t	*(struct)
list	*(struct)
;	O
int	O
rc	int
;	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
list	*(struct)
)	O
;	O
mu_list_set_destroy_item	(*(struct),*((*(void))->(void)))->(*((*(void))->(void)))
(	O
list	*(struct)
,	O
mu_list_free_item	(*(void))->(void)
)	O
;	O
mu_string_split	(*(char),*(char),*(struct))->(int)
(	O
str	*(char)
,	O
","	*(char)
,	O
list	*(struct)
)	O
;	O
rc	int
=	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
list	*(struct)
,	O
set_onerror_action	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
void	O
cli_mailbox_ownership	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
if	O
(	O
set_mailbox_ownership_list	(*(char))->(int)
(	O
arg	*(char)
)	O
)	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
}	O
static	O
void	O
cli_onerror	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
(	O
struct	O
mu_parseopt	struct(int,*(*(char)),long,*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),*((*(struct(int,*(*`),long,*(*`),int,*(char),*(void),int,*(char),*(char),*(*`),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct`),*(char),int,*(char),int,int,int,long,*(long))),*(struct))->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))
*	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
,	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
*	O
opt	*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char)))
,	O
char	O
const	O
*	O
arg	*(char)
)	O
{	O
if	O
(	O
set_onerror_actions	(*(char))->(int)
(	O
arg	*(char)
)	O
)	O
exit	(int)->(void)
(	O
po	*(struct(int,*(*(char)),long,*(*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`))),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char)))
->	O
po_exit_error	int
)	O
;	O
}	O
static	O
struct	O
mu_option	struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)),*(char))
movemail_options	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
[	O
]	O
=	O
{	O
{	O
"preserve"	*(char)
,	O
'p'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"preserve the source mailbox"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
preserve_mail	int
}	O
,	O
{	O
"keep-messages"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_ALIAS	int
}	O
,	O
{	O
"reverse"	*(char)
,	O
'r'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"reverse the sorting order"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
reverse_order	int
}	O
,	O
{	O
"emacs"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"output information used by Emacs rmail interface"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
emacs_mode	int
}	O
,	O
{	O
"uidl"	*(char)
,	O
'u'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"use UIDLs to avoid downloading the same message twice"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
uidl_option	int
}	O
,	O
{	O
"verbose"	*(char)
,	O
'v'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"increase verbosity level"	*(char)
)	O
,	O
mu_c_incr	int
,	O
&	O
verbose_option	int
}	O
,	O
{	O
"owner"	*(char)
,	O
'P'	O
,	O
N_	O
(	O
"MODELIST"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"control mailbox ownership"	*(char)
)	O
,	O
mu_c_string	int
,	O
cli_mailbox_ownership	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"ignore-errors"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"try to continue after errors"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
ignore_errors	int
}	O
,	O
{	O
"onerror"	*(char)
,	O
0	int
,	O
N_	O
(	O
"KW[,KW...]"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"what to do on errors"	*(char)
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
cli_onerror	(*(struct(int,*(*(char)),long,*(*(struct`)),int,*(char),*(void),int,*(char),*(char),*(*(char)),*(char),*(char),*(char),*(char),*(char),*((*`,*`)->(void)),*((*`,*`)->(void)),*((*`,*`)->(void)),int,int,*(struct),*(char),int,*(char),int,int,int,long,*(long))),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(char))->(void)
}	O
,	O
{	O
"program-id"	*(char)
,	O
0	int
,	O
N_	O
(	O
"FMT"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set program identifier for diagnostics (default: program name)"	*(char)
)	O
,	O
mu_c_string	int
,	O
&	O
program_id_option	*(char)
}	O
,	O
{	O
"max-messages"	*(char)
,	O
0	int
,	O
N_	O
(	O
"NUMBER"	*(char)
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"process at most NUMBER messages"	*(char)
)	O
,	O
mu_c_size	int
,	O
&	O
max_messages_option	long
}	O
,	O
{	O
"notify"	*(char)
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"enable biff notification"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
notify	int
}	O
,	O
{	O
"progress-meter"	*(char)
,	O
'm'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"enable progress meter"	*(char)
)	O
,	O
mu_c_bool	int
,	O
&	O
progress_meter_option	int
}	O
,	O
MU_OPTION_END	O
}	O
,	O
*	O
options	array(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))))
[	O
]	O
=	O
{	O
movemail_options	array(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct(int,*`,long,*`,int,*`,*`,int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,*`,*`,int,*`,int,int,int,long,*`)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(char))->(void)),*(char)))
,	O
NULL	O
}	O
;	O
static	O
int	O
cb_mailbox_ownership	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
int	O
i	long
;	O
if	O
(	O
val	array(int)
->	O
type	int
==	O
MU_CFG_STRING	int
)	O
set_mailbox_ownership_list	(*(char))->(int)
(	O
val	array(int)
->	O
v	array(*(char))
.	O
string	*(char)
)	O
;	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
val	array(int)
,	O
MU_CFG_LIST	int
)	O
)	O
return	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
val	array(int)
->	O
v	array(*(char))
.	O
arg	*(char)
.	O
c	char
;	O
i	long
++	O
)	O
{	O
if	O
(	O
mu_cfg_assert_value_type	(*(struct(int,union(*(struct`),*(char),struct(long,*`)))),int)->(int)
(	O
&	O
val	array(int)
->	O
v	array(*(char))
.	O
arg	*(char)
.	O
v	array(*(char))
[	O
i	long
]	O
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
set_mailbox_ownership	(*(char))->(int)
(	O
val	array(int)
->	O
v	array(*(char))
.	O
arg	*(char)
.	O
v	array(*(char))
[	O
i	long
]	O
.	O
v	array(*(char))
.	O
string	*(char)
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_onerror	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
(	O
void	O
*	O
data	*(void)
,	O
mu_config_value_t	struct
*	O
val	array(int)
)	O
{	O
switch	O
(	O
val	array(int)
->	O
type	int
)	O
{	O
case	O
MU_CFG_LIST	int
:	O
mu_list_foreach	(*(struct),*((*(void),*(void))->(int)),*(void))->(int)
(	O
val	array(int)
->	O
v	array(*(char))
.	O
list	*(struct)
,	O
set_onerror_action	(*(void),*(void))->(int)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
MU_CFG_STRING	int
:	O
set_onerror_actions	(*(char))->(int)
(	O
val	array(int)
->	O
v	array(*(char))
.	O
string	*(char)
)	O
;	O
break	O
;	O
default	O
:	O
mu_error	(*(char))->(int)
(	O
"%s"	*(char)
,	O
_	O
(	O
"too many arguments"	*(char)
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
mu_cfg_param	struct(*(char),int,*(void),long,*((*(void),*(struct(int,union(*`,*`,struct`))))->(int)),*(char),*(char))
movemail_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
[	O
]	O
=	O
{	O
{	O
"preserve"	*(char)
,	O
mu_c_bool	int
,	O
&	O
preserve_mail	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Do not remove messages from the source mailbox."	*(char)
)	O
}	O
,	O
{	O
"reverse"	*(char)
,	O
mu_c_bool	int
,	O
&	O
reverse_order	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Reverse message sorting order."	*(char)
)	O
}	O
,	O
{	O
"emacs"	*(char)
,	O
mu_c_bool	int
,	O
&	O
emacs_mode	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Output information used by Emacs rmail interface."	*(char)
)	O
}	O
,	O
{	O
"uidl"	*(char)
,	O
mu_c_bool	int
,	O
&	O
uidl_option	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Use UIDLs to avoid downloading the same message twice."	*(char)
)	O
}	O
,	O
{	O
"verbose"	*(char)
,	O
mu_c_int	int
,	O
&	O
verbose_option	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Set verbosity level."	*(char)
)	O
}	O
,	O
{	O
"program-id"	*(char)
,	O
mu_c_string	int
,	O
&	O
program_id_option	*(char)
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Set program identifier string (default: program name)"	*(char)
)	O
}	O
,	O
{	O
"mailbox-ownership"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_mailbox_ownership	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"Define a list of methods for setting mailbox ownership. Valid "	*(char)
"methods are:\n"	*(char)
" copy-id          get owner UID and GID from the source mailbox\n"	*(char)
" copy-name        get owner name from the source mailbox URL\n"	*(char)
" set-id=UID[:GID] set supplied UID and GID\n"	*(char)
" set-name=USER    make destination mailbox owned by USER"	*(char)
)	O
,	O
N_	O
(	O
"methods: list"	*(char)
)	O
}	O
,	O
{	O
"max-messages"	*(char)
,	O
mu_c_size	int
,	O
&	O
max_messages_option	long
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Copy at most <count> messages."	*(char)
)	O
,	O
N_	O
(	O
"count"	*(char)
)	O
}	O
,	O
{	O
"ignore-errors"	*(char)
,	O
mu_c_bool	int
,	O
&	O
ignore_errors	int
,	O
0	int
,	O
NULL	O
,	O
N_	O
(	O
"Continue after an error."	*(char)
)	O
}	O
,	O
{	O
"onerror"	*(char)
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_onerror	(*(void),*(struct(int,union(*(struct`),*(char),struct(long,*`)))))->(int)
,	O
N_	O
(	O
"What to do after an error. Argument is a list of:\n"	*(char)
" abort  -  terminate the program (the default)\n"	*(char)
" skip   -  skip to the next message\n"	*(char)
" delete -  delete this one and to the next message\n"	*(char)
" count  -  count this message as processed\n"	*(char)
"Each keyword can be prefixed with \"no\" to reverse its meaning."	*(char)
)	O
,	O
N_	O
(	O
"arg: list"	*(char)
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
mu_cli_setup	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*(void),*(struct`))->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
cli	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
=	O
{	O
options	array(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*(struct`),*(struct`),*(char))->(void)),*(char))))
,	O
movemail_cfg_param	array(struct(*(char),int,*(void),long,*((*(void),*(struct(int,union`)))->(int)),*(char),*(char)))
,	O
N_	O
(	O
"GNU movemail -- move messages across mailboxes."	*(char)
)	O
,	O
N_	O
(	O
"inbox-url destfile [POP-password]"	*(char)
)	O
}	O
;	O
static	O
char	O
*	O
movemail_capa	array(*(char))
[	O
]	O
=	O
{	O
"debug"	*(char)
,	O
"locking"	*(char)
,	O
"mailbox"	*(char)
,	O
"auth"	*(char)
,	O
NULL	O
}	O
;	O
void	O
die	(*(struct),*(char),int)->(void)
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
,	O
const	O
char	O
*	O
msg	*(struct)
,	O
int	O
status	int
)	O
{	O
mu_url_t	*(struct)
url	*(struct)
=	O
NULL	O
;	O
mu_mailbox_get_url	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
url	*(struct)
)	O
;	O
if	O
(	O
emacs_mode	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%s:mailbox `%s': %s: %s"	*(char)
)	O
,	O
mu_errname	(int)->(*(char))
(	O
status	int
)	O
,	O
mu_url_to_string	(*(struct))->(*(char))
(	O
url	*(struct)
)	O
,	O
msg	*(struct)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
else	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"mailbox `%s': %s: %s"	*(char)
)	O
,	O
mu_url_to_string	(*(struct))->(*(char))
(	O
url	*(struct)
)	O
,	O
msg	*(struct)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
void	O
lock_mailbox	(*(struct))->(void)
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
)	O
{	O
mu_locker_t	*(struct)
lock	*(struct)
;	O
int	O
status	int
;	O
status	int
=	O
mu_mailbox_get_locker	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
lock	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
die	(*(struct),*(char),int)->(void)
(	O
mbox	*(struct)
,	O
_	O
(	O
"cannot retrieve locker"	*(char)
)	O
,	O
status	int
)	O
;	O
if	O
(	O
!	O
lock	*(struct)
)	O
return	O
;	O
status	int
=	O
mu_locker_lock	(*(struct))->(int)
(	O
lock	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
die	(*(struct),*(char),int)->(void)
(	O
mbox	*(struct)
,	O
_	O
(	O
"cannot lock"	*(char)
)	O
,	O
status	int
)	O
;	O
}	O
void	O
attach_passwd_ticket	(*(struct),*(char))->(void)
(	O
mu_mailbox_t	*(struct)
mbx	*(struct)
,	O
char	O
*	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
)	O
{	O
mu_folder_t	*(struct)
folder	*(struct)
=	O
NULL	O
;	O
mu_authority_t	*(struct)
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
NULL	O
;	O
mu_secret_t	*(struct)
secret	*(struct)
;	O
mu_ticket_t	*(struct)
t	long
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_secret_create	(*(*(struct)),*(char),long)->(int)
(	O
&	O
secret	*(struct)
,	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
,	O
strlen	(*(char))->(long)
(	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
"mu_secret_create: %s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
mu_ticket_create	(*(*(struct)),*(void))->(int)
(	O
&	O
t	long
,	O
NULL	O
)	O
;	O
mu_ticket_set_secret	(*(struct),*(struct))->(int)
(	O
t	long
,	O
secret	*(struct)
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_get_folder	(*(struct),*(*(struct)))->(int)
(	O
mbx	*(struct)
,	O
&	O
folder	*(struct)
)	O
)	O
)	O
die	(*(struct),*(char),int)->(void)
(	O
mbx	*(struct)
,	O
_	O
(	O
"mu_mailbox_get_folder failed"	*(char)
)	O
,	O
rc	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_folder_get_authority	(*(struct),*(*(struct)))->(int)
(	O
folder	*(struct)
,	O
&	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
)	O
)	O
die	(*(struct),*(char),int)->(void)
(	O
mbx	*(struct)
,	O
_	O
(	O
"mu_folder_get_authority failed"	*(char)
)	O
,	O
rc	int
)	O
;	O
if	O
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
&&	O
(	O
rc	int
=	O
mu_authority_set_ticket	(*(struct),*(struct))->(int)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
,	O
t	long
)	O
)	O
)	O
die	(*(struct),*(char),int)->(void)
(	O
mbx	*(struct)
,	O
_	O
(	O
"mu_authority_set_ticket failed"	*(char)
)	O
,	O
rc	int
)	O
;	O
}	O
void	O
open_mailbox	(*(*(struct)),*(char),int,*(char))->(void)
(	O
mu_mailbox_t	*(struct)
*	O
mbx	*(struct)
,	O
char	O
*	O
name	*(char)
,	O
int	O
flags	int
,	O
char	O
*	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
)	O
{	O
int	O
status	int
=	O
mu_mailbox_create_default	(*(*(struct)),*(char))->(int)
(	O
mbx	*(struct)
,	O
name	*(char)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
if	O
(	O
name	*(char)
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"could not create mailbox `%s': %s"	*(char)
)	O
,	O
name	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
else	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"could not create default mailbox: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
status	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
)	O
attach_passwd_ticket	(*(struct),*(char))->(void)
(	O
*	O
mbx	*(struct)
,	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
)	O
;	O
status	int
=	O
mu_mailbox_open	(*(struct),int)->(int)
(	O
*	O
mbx	*(struct)
,	O
flags	int
)	O
;	O
if	O
(	O
status	int
)	O
die	(*(struct),*(char),int)->(void)
(	O
*	O
mbx	*(struct)
,	O
_	O
(	O
"cannot open"	*(char)
)	O
,	O
status	int
)	O
;	O
lock_mailbox	(*(struct))->(void)
(	O
*	O
mbx	*(struct)
)	O
;	O
}	O
int	O
move_message	(*(struct),*(struct),long)->(int)
(	O
mu_mailbox_t	*(struct)
dst	*(char)
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
size_t	long
msgno	long
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_append_message	(*(struct),*(struct))->(int)
(	O
dst	*(char)
,	O
msg	*(struct)
)	O
)	O
!=	O
0	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot append message %lu: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
msgno	long
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
if	O
(	O
!	O
(	O
onerror_flags	int
&	O
ONERROR_DELETE	int
)	O
)	O
return	O
rc	int
;	O
}	O
if	O
(	O
!	O
preserve_mail	int
)	O
{	O
mu_attribute_t	*(struct)
attr	*(struct)
;	O
mu_message_get_attribute	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
attr	*(struct)
)	O
;	O
mu_attribute_set_deleted	(*(struct))->(int)
(	O
attr	*(struct)
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
movemail	(*(struct),*(struct),long)->(int)
(	O
mu_mailbox_t	*(struct)
dst	*(char)
,	O
mu_message_t	*(struct)
msg	*(struct)
,	O
size_t	long
msgno	long
)	O
{	O
int	O
rc	int
=	O
move_message	(*(struct),*(struct),long)->(int)
(	O
dst	*(char)
,	O
msg	*(struct)
,	O
msgno	long
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
++	O
msg_count	long
;	O
else	O
{	O
app_err_count	long
++	O
;	O
if	O
(	O
onerror_flags	int
)	O
{	O
if	O
(	O
onerror_flags	int
&	O
ONERROR_COUNT	int
)	O
++	O
msg_count	long
;	O
}	O
else	O
return	O
1	int
;	O
}	O
return	O
max_messages_option	long
&&	O
msg_count	long
>=	O
max_messages_option	long
;	O
}	O
void	O
compatibility_mode	(*(*(struct)),*(char),*(char),int)->(void)
(	O
mu_mailbox_t	*(struct)
*	O
mbx	*(struct)
,	O
char	O
*	O
source_name	*(char)
,	O
char	O
*	O
password	*(char)
,	O
int	O
flags	int
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
char	O
*	O
user_name	*(char)
=	O
strtok	(*(char),*(char))->(*(char))
(	O
source_name	*(char)
+	O
3	int
,	O
":"	*(char)
)	O
;	O
char	O
*	O
host	*(*(char))
=	O
strtok	(*(char),*(char))->(*(char))
(	O
NULL	O
,	O
":"	*(char)
)	O
;	O
if	O
(	O
!	O
host	*(*(char))
)	O
host	*(*(char))
=	O
getenv	(*(char))->(*(char))
(	O
"MAILHOST"	*(char)
)	O
;	O
if	O
(	O
!	O
host	*(*(char))
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"hostname of the POP3 server is unknown"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
&	O
tmp	*(char)
,	O
"pop://%s@%s"	*(char)
,	O
user_name	*(char)
,	O
host	*(*(char))
)	O
;	O
open_mailbox	(*(*(struct)),*(char),int,*(char))->(void)
(	O
mbx	*(struct)
,	O
tmp	*(char)
,	O
flags	int
,	O
password	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
}	O
static	O
mu_mailbox_t	*(struct)
source	*(char)
,	O
dest	*(struct(*(char),int,int))
;	O
static	O
void	O
close_mailboxes	()->(void)
(	O
void	O
)	O
{	O
mu_mailbox_close	(*(struct))->(int)
(	O
dest	*(struct(*(char),int,int))
)	O
;	O
mu_mailbox_close	(*(struct))->(int)
(	O
source	*(char)
)	O
;	O
}	O
static	O
int	O
get_mbox_owner_id	(*(struct),*(struct),*(struct(int,int)))->(int)
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
,	O
mu_url_t	*(struct)
url	*(struct)
,	O
struct	O
user_id	struct(int,int)
*	O
id	struct(int,int)
)	O
{	O
const	O
char	O
*	O
s	*(char)
;	O
int	O
rc	int
=	O
mu_url_sget_scheme	(*(struct),*(*(char)))->(int)
(	O
url	*(struct)
,	O
&	O
s	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
die	(*(struct),*(char),int)->(void)
(	O
mbox	*(struct)
,	O
_	O
(	O
"cannot get scheme"	*(char)
)	O
,	O
rc	int
)	O
;	O
if	O
(	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"/"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"mbox"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"mh"	*(char)
)	O
==	O
0	int
||	O
strcmp	(*(char),*(char))->(int)
(	O
s	*(char)
,	O
"maildir"	*(char)
)	O
==	O
0	int
)	O
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long))
;	O
rc	int
=	O
mu_url_sget_path	(*(struct),*(*(char)))->(int)
(	O
url	*(struct)
,	O
&	O
s	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
die	(*(struct),*(char),int)->(void)
(	O
mbox	*(struct)
,	O
_	O
(	O
"cannot get path"	*(char)
)	O
,	O
rc	int
)	O
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
s	*(char)
,	O
&	O
st	*(struct(long,long,long))
)	O
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"stat"	*(char)
,	O
s	*(char)
,	O
errno	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
id	struct(int,int)
->	O
uid	int
=	O
st	*(struct(long,long,long))
.	O
st_uid	int
;	O
id	struct(int,int)
->	O
gid	int
=	O
st	*(struct(long,long,long))
.	O
st_gid	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
verbose_option	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"ignoring copy-name: not a local mailbox"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
get_user_id	(*(char),*(struct(int,int)))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
struct	O
user_id	struct(int,int)
*	O
id	struct(int,int)
)	O
{	O
struct	O
mu_auth_data	struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)
*	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
=	O
mu_get_auth_by_name	(*(char))->(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
{	O
if	O
(	O
verbose_option	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"no such user: %s"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
1	int
;	O
}	O
id	struct(int,int)
->	O
uid	int
=	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
uid	int
;	O
id	struct(int,int)
->	O
gid	int
=	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
->	O
gid	int
;	O
mu_auth_data_free	(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))->(void)
(	O
auth	*(*(struct(*(char),*(char),*(char),int,int,*(char),*(char),*(char),*(char),long,int,int)))
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
get_mbox_owner_name	(*(struct),*(struct),*(struct(int,int)))->(int)
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
,	O
mu_url_t	*(struct)
url	*(struct)
,	O
struct	O
user_id	struct(int,int)
*	O
id	struct(int,int)
)	O
{	O
const	O
char	O
*	O
s	*(char)
;	O
int	O
rc	int
=	O
mu_url_sget_user	(*(struct),*(*(char)))->(int)
(	O
url	*(struct)
,	O
&	O
s	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
die	(*(struct),*(char),int)->(void)
(	O
mbox	*(struct)
,	O
_	O
(	O
"cannot get mailbox owner name"	*(char)
)	O
,	O
rc	int
)	O
;	O
return	O
get_user_id	(*(char),*(struct(int,int)))->(int)
(	O
s	*(char)
,	O
id	struct(int,int)
)	O
;	O
}	O
static	O
int	O
guess_mbox_owner	(*(struct),*(struct(int,int)))->(int)
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
,	O
struct	O
user_id	struct(int,int)
*	O
id	struct(int,int)
)	O
{	O
mu_url_t	*(struct)
url	*(struct)
=	O
NULL	O
;	O
int	O
rc	int
;	O
struct	O
set_ownership_method	struct(enum(int,int,int,int),union(*(char),struct(int,int)))
*	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
;	O
rc	int
=	O
mu_mailbox_get_url	(*(struct),*(*(struct)))->(int)
(	O
mbox	*(struct)
,	O
&	O
url	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_mailbox_get_url"	*(char)
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
rc	int
=	O
1	int
;	O
for	O
(	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
=	O
so_methods	array(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
;	O
rc	int
==	O
1	int
&&	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
<	O
so_methods	array(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
+	O
so_method_num	int
;	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
++	O
)	O
{	O
switch	O
(	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
->	O
mode	int
)	O
{	O
case	O
copy_owner_id	int
:	O
rc	int
=	O
get_mbox_owner_id	(*(struct),*(struct),*(struct(int,int)))->(int)
(	O
mbox	*(struct)
,	O
url	*(struct)
,	O
id	struct(int,int)
)	O
;	O
break	O
;	O
case	O
copy_owner_name	int
:	O
rc	int
=	O
get_mbox_owner_name	(*(struct),*(struct),*(struct(int,int)))->(int)
(	O
mbox	*(struct)
,	O
url	*(struct)
,	O
id	struct(int,int)
)	O
;	O
break	O
;	O
case	O
set_owner_id	int
:	O
id	struct(int,int)
->	O
uid	int
=	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
->	O
owner	*(void)
.	O
id	struct(int,int)
.	O
uid	int
;	O
rc	int
=	O
0	int
;	O
if	O
(	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
->	O
owner	*(void)
.	O
id	struct(int,int)
.	O
gid	int
==	O
(	O
gid_t	int
)	O
-	O
1	int
)	O
{	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
=	O
getpwuid	(int)->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
id	struct(int,int)
->	O
uid	int
)	O
;	O
if	O
(	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
)	O
id	struct(int,int)
->	O
gid	int
=	O
pw	*(struct(*(char),*(char),int,int,*(char),*(char),*(char)))
->	O
pw_gid	int
;	O
else	O
{	O
if	O
(	O
verbose_option	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"no user with uid %lu found"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
id	struct(int,int)
->	O
uid	int
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
}	O
else	O
id	struct(int,int)
->	O
gid	int
=	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
->	O
owner	*(void)
.	O
id	struct(int,int)
.	O
gid	int
;	O
break	O
;	O
case	O
set_owner_name	int
:	O
rc	int
=	O
get_user_id	(*(char),*(struct(int,int)))->(int)
(	O
meth	*(struct(enum(int,int,int,int),union(*(char),struct(int,int))))
->	O
owner	*(void)
.	O
name	*(char)
,	O
id	struct(int,int)
)	O
;	O
break	O
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
static	O
void	O
switch_owner	(*(struct))->(void)
(	O
mu_mailbox_t	*(struct)
mbox	*(struct)
)	O
{	O
struct	O
user_id	struct(int,int)
user_id	struct(int,int)
;	O
if	O
(	O
so_method_num	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
getuid	()->(int)
(	O
)	O
)	O
{	O
if	O
(	O
verbose_option	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"ignoring mailbox-ownership statement"	*(char)
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
guess_mbox_owner	(*(struct),*(struct(int,int)))->(int)
(	O
mbox	*(struct)
,	O
&	O
user_id	struct(int,int)
)	O
==	O
0	int
)	O
{	O
if	O
(	O
mu_switch_to_privs	(int,int,*(struct))->(int)
(	O
user_id	struct(int,int)
.	O
uid	int
,	O
user_id	struct(int,int)
.	O
gid	int
,	O
NULL	O
)	O
)	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
else	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"no suitable method for setting mailbox ownership"	*(char)
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
}	O
static	O
int	O
_compare_uidls	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
value	*(void)
)	O
{	O
const	O
struct	O
mu_uidl	struct(long,array(char))
*	O
a	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
=	O
item	*(void)
;	O
const	O
struct	O
mu_uidl	struct(long,array(char))
*	O
b	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
=	O
value	*(void)
;	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
a	*(*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*`,*`,*`,*`,*`,*`,*`,*`)))))
->	O
uidl	array(char)
,	O
b	*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct(*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`)))))
->	O
uidl	array(char)
)	O
;	O
}	O
struct	O
movemail_getvar_closure	struct(*(char),*(char),*(struct),*(struct))
{	O
const	O
char	O
*	O
source_name	*(char)
;	O
const	O
char	O
*	O
dest_name	*(char)
;	O
mu_url_t	*(struct)
source_url	*(struct)
;	O
mu_url_t	*(struct)
dest_url	*(struct)
;	O
}	O
;	O
static	O
int	O
get_url_part	(*(struct),*(char),long,*(*(char)))->(int)
(	O
mu_url_t	*(struct)
url	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
nlen	long
,	O
char	O
*	O
*	O
ret	*(*(struct))
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
!	O
url	*(struct)
)	O
return	O
MU_WRDSE_UNDEF	O
;	O
if	O
(	O
SEQ	O
(	O
"user"	*(char)
,	O
name	*(char)
,	O
nlen	long
)	O
)	O
rc	int
=	O
mu_url_aget_user	(*(struct),*(*(char)))->(int)
(	O
url	*(struct)
,	O
ret	*(*(struct))
)	O
;	O
else	O
if	O
(	O
SEQ	O
(	O
"host"	*(char)
,	O
name	*(char)
,	O
nlen	long
)	O
)	O
rc	int
=	O
mu_url_aget_host	(*(struct),*(*(char)))->(int)
(	O
url	*(struct)
,	O
ret	*(*(struct))
)	O
;	O
else	O
if	O
(	O
SEQ	O
(	O
"port"	*(char)
,	O
name	*(char)
,	O
nlen	long
)	O
)	O
rc	int
=	O
mu_url_aget_portstr	(*(struct),*(*(char)))->(int)
(	O
url	*(struct)
,	O
ret	*(*(struct))
)	O
;	O
else	O
if	O
(	O
SEQ	O
(	O
"path"	*(char)
,	O
name	*(char)
,	O
nlen	long
)	O
)	O
rc	int
=	O
mu_url_aget_path	(*(struct),*(*(char)))->(int)
(	O
url	*(struct)
,	O
ret	*(*(struct))
)	O
;	O
else	O
return	O
MU_WRDSE_UNDEF	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
MU_ERR_NOENT	O
:	O
return	O
MU_WRDSE_UNDEF	O
;	O
default	O
:	O
if	O
(	O
mu_asprintf	(*(*(char)),*(char))->(int)
(	O
ret	*(*(struct))
,	O
"%s"	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
)	O
return	O
MU_WRDSE_NOSPACE	O
;	O
return	O
MU_WRDSE_USERERR	O
;	O
}	O
return	O
MU_WRDSE_OK	O
;	O
}	O
static	O
int	O
movemail_getvar	(*(*(char)),*(char),long,*(void))->(int)
(	O
char	O
*	O
*	O
ret	*(*(struct))
,	O
const	O
char	O
*	O
name	*(char)
,	O
size_t	long
nlen	long
,	O
void	O
*	O
data	*(void)
)	O
{	O
struct	O
movemail_getvar_closure	struct(*(char),*(char),*(struct),*(struct))
*	O
pc	long
=	O
data	*(void)
;	O
const	O
char	O
*	O
s	*(char)
;	O
if	O
(	O
nlen	long
>	O
7	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
"source_"	*(char)
,	O
name	*(char)
,	O
7	int
)	O
==	O
0	int
)	O
return	O
get_url_part	(*(struct),*(char),long,*(*(char)))->(int)
(	O
pc	long
->	O
source_url	*(struct)
,	O
name	*(char)
+	O
7	int
,	O
nlen	long
-	O
7	int
,	O
ret	*(*(struct))
)	O
;	O
if	O
(	O
nlen	long
>	O
5	int
&&	O
memcmp	(*(void),*(void),long)->(int)
(	O
"dest_"	*(char)
,	O
name	*(char)
,	O
5	int
)	O
==	O
0	int
)	O
return	O
get_url_part	(*(struct),*(char),long,*(*(char)))->(int)
(	O
pc	long
->	O
dest_url	*(struct)
,	O
name	*(char)
+	O
5	int
,	O
nlen	long
-	O
5	int
,	O
ret	*(*(struct))
)	O
;	O
if	O
(	O
SEQ	O
(	O
"progname"	*(char)
,	O
name	*(char)
,	O
nlen	long
)	O
)	O
s	*(char)
=	O
mu_program_name	*(char)
;	O
else	O
if	O
(	O
SEQ	O
(	O
"source"	*(char)
,	O
name	*(char)
,	O
nlen	long
)	O
)	O
s	*(char)
=	O
pc	long
->	O
source_name	*(char)
;	O
else	O
if	O
(	O
SEQ	O
(	O
"dest"	*(char)
,	O
name	*(char)
,	O
nlen	long
)	O
)	O
s	*(char)
=	O
pc	long
->	O
dest_name	*(char)
;	O
else	O
return	O
MU_WRDSE_UNDEF	O
;	O
*	O
ret	*(*(struct))
=	O
strdup	(*(char))->(*(char))
(	O
s	*(char)
)	O
;	O
if	O
(	O
!	O
*	O
ret	*(*(struct))
)	O
return	O
MU_WRDSE_NOSPACE	O
;	O
return	O
MU_WRDSE_OK	O
;	O
}	O
static	O
void	O
set_program_id	(*(char),*(char))->(void)
(	O
const	O
char	O
*	O
source_name	*(char)
,	O
const	O
char	O
*	O
dest_name	*(char)
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
struct	O
movemail_getvar_closure	struct(*(char),*(char),*(struct),*(struct))
clos	*(void)
;	O
clos	*(void)
.	O
source_name	*(char)
=	O
source_name	*(char)
;	O
clos	*(void)
.	O
dest_name	*(char)
=	O
dest_name	*(char)
;	O
rc	int
=	O
mu_mailbox_get_url	(*(struct),*(*(struct)))->(int)
(	O
source	*(char)
,	O
&	O
clos	*(void)
.	O
source_url	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"cannot obtain source mailbox URL: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
rc	int
=	O
mu_mailbox_get_url	(*(struct),*(*(struct)))->(int)
(	O
dest	*(struct(*(char),int,int))
,	O
&	O
clos	*(void)
.	O
dest_url	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"cannot obtain destination mailbox URL: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_getvar	*((*(*(char)),*(char),long,*(void))->(int))
=	O
movemail_getvar	(*(*(char)),*(char),long,*(void))->(int)
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_closure	*(void)
=	O
&	O
clos	*(void)
;	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
program_id_option	*(char)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_NOSPLIT	O
|	O
MU_WRDSF_NOCMD	O
|	O
MU_WRDSF_GETVAR	O
|	O
MU_WRDSF_CLOSURE	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot expand line `%s': %s"	*(char)
)	O
,	O
program_id_option	*(char)
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
;	O
return	O
;	O
}	O
mu_program_name	*(char)
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
=	O
0	int
;	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
mu_stdstream_strerr_setup	(int)->(int)
(	O
MU_STRERR_STDERR	int
)	O
;	O
}	O
static	O
int	O
screen_width	()->(int)
(	O
void	O
)	O
{	O
struct	O
winsize	struct(short,short,short,short)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_col	short
=	O
0	int
;	O
if	O
(	O
ioctl	(int,long)->(int)
(	O
1	int
,	O
TIOCGWINSZ	int
,	O
(	O
char	O
*	O
)	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
<	O
0	int
)	O
{	O
char	O
*	O
p	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"COLUMNS"	*(char)
)	O
;	O
if	O
(	O
p	*(char)
)	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_col	short
=	O
atol	(*(char))->(long)
(	O
p	*(char)
)	O
;	O
}	O
if	O
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_col	short
==	O
0	int
)	O
return	O
80	int
;	O
return	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_col	short
;	O
}	O
static	O
void	O
progress_format	(long,long)->(void)
(	O
size_t	long
pos	long
,	O
size_t	long
count	long
)	O
{	O
int	O
n	*(long)
;	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\r'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
n	*(long)
=	O
printf	(*(char))->(int)
(	O
"message %zu/%zu"	*(char)
,	O
pos	long
,	O
count	long
)	O
;	O
n	*(long)
=	O
screen_width	()->(int)
(	O
)	O
-	O
n	*(long)
;	O
while	O
(	O
n	*(long)
--	O
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
' '	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
fflush	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
void	O
progress_start	(*(struct))->(void)
(	O
mu_iterator_t	*(struct)
itr	*(struct)
)	O
{	O
size_t	long
count	long
;	O
if	O
(	O
!	O
progress_meter_option	int
)	O
return	O
;	O
if	O
(	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_count	int
,	O
&	O
count	long
)	O
)	O
{	O
progress_meter_option	int
=	O
0	int
;	O
return	O
;	O
}	O
progress_format	(long,long)->(void)
(	O
0	int
,	O
count	long
)	O
;	O
}	O
void	O
progress_mark	(*(struct))->(void)
(	O
mu_iterator_t	*(struct)
itr	*(struct)
)	O
{	O
size_t	long
count	long
,	O
pos	long
;	O
if	O
(	O
!	O
progress_meter_option	int
)	O
return	O
;	O
if	O
(	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_count	int
,	O
&	O
count	long
)	O
||	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_tell	int
,	O
&	O
pos	long
)	O
)	O
{	O
progress_meter_option	int
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
reverse_order	int
)	O
pos	long
=	O
count	long
-	O
pos	long
+	O
1	int
;	O
progress_format	(long,long)->(void)
(	O
pos	long
,	O
count	long
)	O
;	O
}	O
void	O
progress_stop	()->(void)
(	O
void	O
)	O
{	O
if	O
(	O
progress_meter_option	int
)	O
fputc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
'\n'	O
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
size_t	long
total	long
;	O
int	O
rc	int
=	O
0	int
;	O
char	O
*	O
source_name	*(char)
,	O
*	O
dest_name	*(char)
;	O
int	O
flags	int
;	O
mu_list_t	*(struct)
src_uidl_list	*(struct)
=	O
NULL	O
;	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
MU_APP_INIT_NLS	O
(	O
)	O
;	O
MU_AUTH_REGISTER_ALL_MODULES	O
(	O
)	O
;	O
mu_register_all_formats	O
(	O
)	O
;	O
mu_auth_register_module	(*(struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*`,int,*`,int,*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*`,*`,*`)),*(struct(*`,int,*`,long,*`,*`,*`)),*((enum(int,int),*`,*`,*`,*`,*`)->(int)),*((*`)->(void)))))->(void)
(	O
&	O
mu_auth_tls_module	struct(*(char),array(*((*(*(struct(*`,*`,*`,int,int,*`,*`,*`,*`,long,int,int))),*(void),*(void),*(void))->(int))),array(*(void)),*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*((enum(int,int),*(struct(struct`,enum(int,int,int),*`,*`,*`,*`)),*(char),*(*(void)),*(void),*(struct(*`,*`)))->(int)),*((*(void))->(void)))
)	O
;	O
mu_cli	(int,*(*(char)),*(struct(*(*(struct`)),*(struct(*`,int,*`,long,*`,*`,*`)),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*`)->(void)))),*(*(char)),*(void),*(int),*(*(*(char))))->(void)
(	O
argc	long
,	O
argv	*(*(char))
,	O
&	O
cli	struct(*(*(struct(*(char),int,*(char),int,*(char),enum(int,int,int,int,int,int,int,int,int,int,int,int,int,int,int,int),*(void),*((*`,*`,*`)->(void)),*(char)))),*(struct(*(char),int,*(void),long,*((*`,*`)->(int)),*(char),*(char))),*(char),*(char),*(*(char)),*(char),int,int,int,int,*((*(struct))->(void)))
,	O
movemail_capa	array(*(char))
,	O
NULL	O
,	O
&	O
argc	long
,	O
&	O
argv	*(*(char))
)	O
;	O
if	O
(	O
argc	long
<	O
2	int
||	O
argc	long
>	O
3	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"wrong number of arguments"	*(char)
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ignore_errors	int
)	O
onerror_flags	int
|=	O
ONERROR_SKIP	int
|	O
ONERROR_COUNT	int
;	O
if	O
(	O
!	O
isatty	(int)->(int)
(	O
1	int
)	O
)	O
progress_meter_option	int
=	O
0	int
;	O
if	O
(	O
emacs_mode	int
)	O
{	O
mu_registrar_set_default_record	(*(struct(int,*(char),int,int,int,*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*((*`)->(int)),*(void),*((*`,*`,int)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`)->(int)),*((*`,*`,int)->(int)))))->(void)
(	O
mu_mbox_record	*(struct(int,*(char),int,int,int,*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*((*(struct`))->(int)),*(void),*((*(struct`),*(struct`),int)->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(*`))->(int)),*((*(struct`),*(char),int)->(int))))
)	O
;	O
mu_stdstream_strerr_setup	(int)->(int)
(	O
MU_STRERR_STDERR	int
)	O
;	O
}	O
atexit	(*(()->(void)))->(int)
(	O
close_mailboxes	()->(void)
)	O
;	O
source_name	*(char)
=	O
argv	*(*(char))
[	O
0	int
]	O
;	O
dest_name	*(char)
=	O
argv	*(*(char))
[	O
1	int
]	O
;	O
flags	int
=	O
preserve_mail	int
?	O
MU_STREAM_READ	int
:	O
MU_STREAM_RDWR	O
;	O
if	O
(	O
strncmp	(*(char),*(char),long)->(int)
(	O
source_name	*(char)
,	O
"po:"	*(char)
,	O
3	int
)	O
==	O
0	int
)	O
compatibility_mode	(*(*(struct)),*(char),*(char),int)->(void)
(	O
&	O
source	*(char)
,	O
source_name	*(char)
,	O
argv	*(*(char))
[	O
2	int
]	O
,	O
flags	int
)	O
;	O
else	O
open_mailbox	(*(*(struct)),*(char),int,*(char))->(void)
(	O
&	O
source	*(char)
,	O
source_name	*(char)
,	O
flags	int
,	O
argv	*(*(char))
[	O
2	int
]	O
)	O
;	O
switch_owner	(*(struct))->(void)
(	O
source	*(char)
)	O
;	O
open_mailbox	(*(*(struct)),*(char),int,*(char))->(void)
(	O
&	O
dest	*(struct(*(char),int,int))
,	O
dest_name	*(char)
,	O
MU_STREAM_APPEND	int
|	O
MU_STREAM_READ	int
|	O
MU_STREAM_CREAT	int
,	O
NULL	O
)	O
;	O
if	O
(	O
program_id_option	*(char)
)	O
set_program_id	(*(char),*(char))->(void)
(	O
source_name	*(char)
,	O
dest_name	*(char)
)	O
;	O
if	O
(	O
notify	int
)	O
{	O
rc	int
=	O
mu_mailbox_set_notify	(*(struct),*(char))->(int)
(	O
dest	*(struct(*(char),int,int))
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"failed to set up notification: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
rc	int
=	O
mu_mailbox_messages_count	(*(struct),*(long))->(int)
(	O
source	*(char)
,	O
&	O
total	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot count messages: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
if	O
(	O
verbose_option	int
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"number of messages in source mailbox: %lu"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
total	long
)	O
;	O
if	O
(	O
max_messages_option	long
)	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
reverse_order	int
?	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"will process last %lu message"	*(char)
,	O
"will process last %lu messages"	*(char)
,	O
max_messages_option	long
)	O
:	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"will process first %lu message"	*(char)
,	O
"will process first %lu messages"	*(char)
,	O
max_messages_option	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
max_messages_option	long
)	O
;	O
}	O
if	O
(	O
uidl_option	int
)	O
{	O
mu_list_t	*(struct)
dst_uidl_list	*(struct)
=	O
NULL	O
;	O
rc	int
=	O
mu_mailbox_get_uidls	(*(struct),*(*(struct)))->(int)
(	O
source	*(char)
,	O
&	O
src_uidl_list	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
die	(*(struct),*(char),int)->(void)
(	O
source	*(char)
,	O
_	O
(	O
"cannot get UIDLs"	*(char)
)	O
,	O
rc	int
)	O
;	O
rc	int
=	O
mu_mailbox_get_uidls	(*(struct),*(*(struct)))->(int)
(	O
dest	*(struct(*(char),int,int))
,	O
&	O
dst_uidl_list	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
die	(*(struct),*(char),int)->(void)
(	O
dest	*(struct(*(char),int,int))
,	O
_	O
(	O
"cannot get UIDLs"	*(char)
)	O
,	O
rc	int
)	O
;	O
mu_list_set_comparator	(*(struct),*((*(void),*(void))->(int)))->(*((*(void),*(void))->(int)))
(	O
dst_uidl_list	*(struct)
,	O
_compare_uidls	(*(void),*(void))->(int)
)	O
;	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
src_uidl_list	*(struct)
,	O
&	O
itr	*(struct)
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
struct	O
mu_uidl	struct(long,array(char))
*	O
uidl	array(char)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
uidl	array(char)
)	O
;	O
if	O
(	O
mu_list_locate	(*(struct),*(void),*(*(void)))->(int)
(	O
dst_uidl_list	*(struct)
,	O
uidl	array(char)
,	O
NULL	O
)	O
==	O
0	int
)	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_delete	int
,	O
NULL	O
)	O
;	O
}	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
dst_uidl_list	*(struct)
)	O
;	O
mu_list_set_comparator	(*(struct),*((*(void),*(void))->(int)))->(*((*(void),*(void))->(int)))
(	O
src_uidl_list	*(struct)
,	O
NULL	O
)	O
;	O
rc	int
=	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_set_direction	int
,	O
&	O
reverse_order	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot set iteration direction: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
exit	(int)->(void)
(	O
1	int
)	O
;	O
}	O
progress_start	(*(struct))->(void)
(	O
itr	*(struct)
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
struct	O
mu_uidl	struct(long,array(char))
*	O
uidl	array(char)
;	O
mu_message_t	*(struct)
msg	*(struct)
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
uidl	array(char)
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_get_message	(*(struct),long,*(*(struct)))->(int)
(	O
source	*(char)
,	O
uidl	array(char)
->	O
msgno	long
,	O
&	O
msg	*(struct)
)	O
)	O
!=	O
0	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot read message %lu: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
uidl	array(char)
->	O
msgno	long
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
get_err_count	long
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%lu: cannot get header: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
uidl	array(char)
->	O
msgno	long
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
else	O
{	O
char	O
const	O
*	O
suidl	*(char)
=	O
NULL	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_header_sget_value	O
(	O
hdr	*(struct)
,	O
MU_HEADER_X_UIDL	*(char)
,	O
&	O
suidl	*(char)
)	O
)	O
)	O
{	O
if	O
(	O
rc	int
!=	O
MU_ERR_NOENT	O
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%lu: cannot get %s: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
uidl	array(char)
->	O
msgno	long
,	O
MU_HEADER_X_UIDL	*(char)
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	(*(char),*(char))->(int)
(	O
suidl	*(char)
,	O
uidl	array(char)
->	O
uidl	array(char)
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%lu: stored and reported UIDL differ; fixing"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
uidl	array(char)
->	O
msgno	long
)	O
;	O
suidl	*(char)
=	O
NULL	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_header_set_value	(*(struct),*(char),*(char),int)->(int)
(	O
hdr	*(struct)
,	O
MU_HEADER_X_UIDL	*(char)
,	O
uidl	array(char)
->	O
uidl	array(char)
,	O
1	int
)	O
)	O
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"%lu: cannot set header: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
uidl	array(char)
->	O
msgno	long
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
}	O
}	O
progress_mark	(*(struct))->(void)
(	O
itr	*(struct)
)	O
;	O
if	O
(	O
movemail	(*(struct),*(struct),long)->(int)
(	O
dest	*(struct(*(char),int,int))
,	O
msg	*(struct)
,	O
uidl	array(char)
->	O
msgno	long
)	O
)	O
break	O
;	O
}	O
}	O
else	O
{	O
rc	int
=	O
mu_mailbox_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
source	*(char)
,	O
&	O
itr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot obtain mailbox iterator: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_set_direction	int
,	O
&	O
reverse_order	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot set iteration direction: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
progress_start	(*(struct))->(void)
(	O
itr	*(struct)
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
mu_message_t	*(struct)
msg	*(struct)
;	O
size_t	long
msgno	long
;	O
rc	int
=	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_tell	int
,	O
&	O
msgno	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot get iterator position: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
msg	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot read message %lu: %s"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
msgno	long
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
get_err_count	long
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
movemail	(*(struct),*(struct),long)->(int)
(	O
dest	*(struct(*(char),int,int))
,	O
msg	*(struct)
,	O
msgno	long
)	O
)	O
break	O
;	O
progress_mark	(*(struct))->(void)
(	O
itr	*(struct)
)	O
;	O
}	O
}	O
progress_stop	()->(void)
(	O
)	O
;	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
if	O
(	O
verbose_option	int
)	O
{	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"number of processed messages: %lu"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
msg_count	long
)	O
;	O
mu_diag_output	(int,*(char))->(void)
(	O
MU_DIAG_INFO	O
,	O
_	O
(	O
"number of errors: %lu / %lu"	*(char)
)	O
,	O
(	O
unsigned	O
long	O
)	O
get_err_count	long
,	O
(	O
unsigned	O
long	O
)	O
app_err_count	long
)	O
;	O
}	O
if	O
(	O
app_err_count	long
&&	O
!	O
(	O
onerror_flags	int
&	O
(	O
ONERROR_DELETE	int
|	O
ONERROR_COUNT	int
)	O
)	O
)	O
preserve_mail	int
=	O
1	int
;	O
if	O
(	O
onerror_flags	int
&	O
ONERROR_COUNT	int
)	O
app_err_count	long
=	O
0	int
;	O
mu_mailbox_sync	(*(struct))->(int)
(	O
dest	*(struct(*(char),int,int))
)	O
;	O
rc	int
=	O
mu_mailbox_close	(*(struct))->(int)
(	O
dest	*(struct(*(char),int,int))
)	O
;	O
mu_mailbox_destroy	(*(*(struct)))->(void)
(	O
&	O
dest	*(struct(*(char),int,int))
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"cannot close destination mailbox: %s"	*(char)
)	O
,	O
mu_strerror	(int)->(*(char))
(	O
rc	int
)	O
)	O
;	O
else	O
if	O
(	O
!	O
preserve_mail	int
)	O
mu_mailbox_expunge	(*(struct))->(int)
(	O
source	*(char)
)	O
;	O
mu_mailbox_close	(*(struct))->(int)
(	O
source	*(char)
)	O
;	O
mu_mailbox_destroy	(*(*(struct)))->(void)
(	O
&	O
source	*(char)
)	O
;	O
return	O
!	O
(	O
rc	int
==	O
0	int
&&	O
(	O
app_err_count	long
+	O
get_err_count	long
)	O
==	O
0	int
)	O
;	O
}	O
