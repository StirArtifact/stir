static	O
void	O
FFN	(int)->(int)
(	O
Fcatch	int
)	O
(	O
VOL	O
object	int
args	int
)	O
{	O
object	int
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
args	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
args	int
)	O
;	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
args	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
vs_push	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
frs_push	()->(int)
(	O
FRS_CATCH	O
,	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
nlj_active	O
=	O
FALSE	O
;	O
else	O
Fprogn	()->(int)
(	O
MMcdr	()->(int)
(	O
args	int
)	O
)	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
}	O
DEFUNM_NEW	()->(int)
(	O
"ERROR-SET"	*(char)
,	O
object	int
,	O
fSerror_set	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
volatile	O
object	int
x0	O
)	O
,	O
"Evaluates the FORM in the null environment.  If the evaluation of the FORM has successfully completed, SI:ERROR-SET returns NIL as the first value and the result of the evaluation as the rest of the values.  If, in the course of the evaluation, a non-local jump from the FORM is atempted, SI:ERROR-SET traps the jump and returns the corresponding jump tag as its value."	*(char)
)	O
{	O
object	int
*	O
old_lex	O
=	O
lex_env	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
frs_push	()->(int)
(	O
FRS_CATCHALL	O
,	O
Cnil	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
nlj_active	O
=	O
FALSE	O
;	O
x0	O
=	O
nlj_tag	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
lex_env	O
=	O
old_lex	O
;	O
RETURN1	()->(int)
(	O
x0	O
)	O
;	O
}	O
else	O
{	O
lex_env	O
=	O
vs_top	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
vs_push	()->(int)
(	O
Cnil	O
)	O
;	O
x0	O
=	O
Ieval	()->(int)
(	O
x0	O
)	O
;	O
}	O
frs_pop	()->(int)
(	O
)	O
;	O
lex_env	O
=	O
old_lex	O
;	O
{	O
int	O
i	int
=	O
fcall	O
.	O
nvalues	O
;	O
if	O
(	O
i	int
+	O
1	int
>=	O
sizeof	O
(	O
fcall	O
.	O
values	O
)	O
/	O
sizeof	O
(	O
*	O
fcall	O
.	O
values	O
)	O
)	O
FEerror	()->(int)
(	O
"Too many function call values"	*(char)
,	O
0	int
)	O
;	O
while	O
(	O
i	int
>	O
0	int
)	O
{	O
fcall	O
.	O
values	O
[	O
i	int
+	O
1	int
]	O
=	O
fcall	O
.	O
values	O
[	O
i	int
]	O
;	O
i	int
--	O
;	O
}	O
fcall	O
.	O
nvalues	O
++	O
;	O
fcall	O
.	O
values	O
[	O
1	int
]	O
=	O
x0	O
;	O
}	O
return	O
Cnil	O
;	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Funwind_protect	int
)	O
(	O
VOL	O
object	int
args	int
)	O
{	O
object	int
*	O
top	O
=	O
vs_top	O
;	O
object	int
*	O
value_top	O
;	O
if	O
(	O
endp	()->(int)
(	O
args	int
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
args	int
)	O
;	O
frs_push	()->(int)
(	O
FRS_PROTECT	O
,	O
Cnil	O
)	O
;	O
if	O
(	O
nlj_active	O
)	O
{	O
object	int
tag	O
=	O
nlj_tag	O
;	O
frame_ptr	O
fr	O
=	O
nlj_fr	O
;	O
value_top	O
=	O
vs_top	O
;	O
vs_top	O
=	O
top	O
;	O
while	O
(	O
vs_base	O
<	O
value_top	O
)	O
{	O
vs_push	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
++	O
;	O
}	O
value_top	O
=	O
vs_top	O
;	O
nlj_active	O
=	O
FALSE	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
Fprogn	()->(int)
(	O
MMcdr	()->(int)
(	O
args	int
)	O
)	O
;	O
vs_base	O
=	O
top	O
;	O
vs_top	O
=	O
value_top	O
;	O
if	O
(	O
vs_top	O
==	O
vs_base	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
unwind	()->(int)
(	O
fr	O
,	O
tag	O
)	O
;	O
}	O
else	O
{	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
args	int
)	O
)	O
;	O
frs_pop	()->(int)
(	O
)	O
;	O
value_top	O
=	O
vs_top	O
;	O
vs_top	O
=	O
top	O
;	O
while	O
(	O
vs_base	O
<	O
value_top	O
)	O
{	O
vs_push	()->(int)
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
vs_base	O
++	O
;	O
}	O
value_top	O
=	O
vs_top	O
;	O
Fprogn	()->(int)
(	O
MMcdr	()->(int)
(	O
args	int
)	O
)	O
;	O
vs_base	O
=	O
top	O
;	O
vs_top	O
=	O
value_top	O
;	O
if	O
(	O
vs_top	O
==	O
vs_base	O
)	O
vs_base	O
[	O
0	int
]	O
=	O
Cnil	O
;	O
}	O
}	O
static	O
void	O
FFN	(int)->(int)
(	O
Fthrow	int
)	O
(	O
object	int
args	int
)	O
{	O
object	int
*	O
top	O
=	O
vs_top	O
;	O
object	int
tag	O
;	O
frame_ptr	O
fr	O
;	O
if	O
(	O
endp	()->(int)
(	O
args	int
)	O
||	O
endp	()->(int)
(	O
MMcdr	()->(int)
(	O
args	int
)	O
)	O
)	O
FEtoo_few_argumentsF	()->(int)
(	O
args	int
)	O
;	O
if	O
(	O
!	O
endp	()->(int)
(	O
MMcddr	()->(int)
(	O
args	int
)	O
)	O
)	O
FEtoo_many_argumentsF	()->(int)
(	O
args	int
)	O
;	O
eval	()->(int)
(	O
MMcar	()->(int)
(	O
args	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
tag	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_push	()->(int)
(	O
tag	O
)	O
;	O
fr	O
=	O
frs_sch_catch	()->(int)
(	O
tag	O
)	O
;	O
if	O
(	O
fr	O
==	O
NULL	O
)	O
FEerror	()->(int)
(	O
"~S is an undefined tag."	*(char)
,	O
1	int
,	O
tag	O
)	O
;	O
eval	()->(int)
(	O
MMcadr	()->(int)
(	O
args	int
)	O
)	O
;	O
unwind	()->(int)
(	O
fr	O
,	O
tag	O
)	O
;	O
}	O
void	O
gcl_init_catch	()->(void)
(	O
void	O
)	O
{	O
make_special_form	()->(int)
(	O
"CATCH"	*(char)
,	O
Fcatch	int
)	O
;	O
make_special_form	()->(int)
(	O
"UNWIND-PROTECT"	*(char)
,	O
Funwind_protect	int
)	O
;	O
make_special_form	()->(int)
(	O
"THROW"	*(char)
,	O
Fthrow	int
)	O
;	O
}	O
