static	O
mu_assoc_t	*(struct)
aliases	*(struct)
;	O
static	O
void	O
alias_free	(*(void))->(void)
(	O
void	O
*	O
data	*(void)
)	O
{	O
mu_list_t	*(struct)
al	*(struct)
=	O
data	*(void)
;	O
util_slist_destroy	(*(*(struct)))->(void)
(	O
&	O
al	*(struct)
)	O
;	O
}	O
static	O
void	O
alias_print_group	(*(char),*(struct))->(void)
(	O
const	O
char	O
*	O
name	*(char)
,	O
mu_list_t	*(struct)
al	*(struct)
)	O
{	O
mu_printf	(*(char))->(int)
(	O
"%s    "	*(char)
,	O
name	*(char)
)	O
;	O
util_slist_print	(*(struct),int)->(void)
(	O
al	*(struct)
,	O
0	int
)	O
;	O
mu_printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
static	O
mu_list_t	*(struct)
alias_lookup	(*(char))->(*(struct))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
mu_assoc_get	(*(struct),*(char))->(*(void))
(	O
aliases	*(struct)
,	O
name	*(char)
)	O
;	O
}	O
static	O
void	O
alias_print	(*(char))->(void)
(	O
char	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
!	O
name	*(char)
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
if	O
(	O
!	O
aliases	*(struct)
)	O
return	O
;	O
mu_assoc_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
aliases	*(struct)
,	O
&	O
itr	*(struct)
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
mu_list_t	*(struct)
al	*(struct)
;	O
if	O
(	O
mu_iterator_current_kv	(*(struct),*(*(void)),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
name	*(char)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
al	*(struct)
)	O
)	O
continue	O
;	O
alias_print_group	(*(char),*(struct))->(void)
(	O
name	*(char)
,	O
al	*(struct)
)	O
;	O
}	O
}	O
else	O
{	O
mu_list_t	*(struct)
al	*(struct)
;	O
al	*(struct)
=	O
alias_lookup	(*(char))->(*(struct))
(	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
al	*(struct)
)	O
{	O
mu_error	(*(char))->(int)
(	O
_	O
(	O
"\"%s\": not a group"	*(char)
)	O
,	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
alias_print_group	(*(char),*(struct))->(void)
(	O
name	*(char)
,	O
al	*(struct)
)	O
;	O
}	O
}	O
static	O
int	O
alias_create	(*(char),*(*(struct)))->(int)
(	O
const	O
char	O
*	O
name	*(char)
,	O
mu_list_t	*(struct)
*	O
al	*(struct)
)	O
{	O
int	O
rc	int
;	O
mu_list_t	*(struct)
l	*(struct)
;	O
if	O
(	O
!	O
aliases	*(struct)
)	O
{	O
mu_assoc_create	(*(*(struct)),int)->(int)
(	O
&	O
aliases	*(struct)
,	O
0	int
)	O
;	O
mu_assoc_set_destroy_item	(*(struct),*((*(void))->(void)))->(int)
(	O
aliases	*(struct)
,	O
alias_free	(*(void))->(void)
)	O
;	O
}	O
if	O
(	O
mu_assoc_lookup_ref	(*(struct),*(char),*(void))->(int)
(	O
aliases	*(struct)
,	O
name	*(char)
,	O
al	*(struct)
)	O
)	O
{	O
rc	int
=	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
l	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_assoc_install	(*(struct),*(char),*(void))->(int)
(	O
aliases	*(struct)
,	O
name	*(char)
,	O
l	*(struct)
)	O
;	O
*	O
al	*(struct)
=	O
l	*(struct)
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
void	O
alias_destroy	(*(char))->(void)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
mu_assoc_remove	(*(struct),*(char))->(int)
(	O
aliases	*(struct)
,	O
name	*(char)
)	O
;	O
}	O
static	O
void	O
recursive_alias_expand	(*(char),*(struct),*(struct))->(void)
(	O
const	O
char	O
*	O
name	*(char)
,	O
mu_list_t	*(struct)
exlist	*(struct)
,	O
mu_list_t	*(struct)
origlist	*(struct)
)	O
{	O
mu_list_t	*(struct)
al	*(struct)
;	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
if	O
(	O
(	O
al	*(struct)
=	O
alias_lookup	(*(char))->(*(struct))
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
mu_list_locate	(*(struct),*(void),*(*(void)))->(int)
(	O
exlist	*(struct)
,	O
(	O
void	O
*	O
)	O
name	*(char)
,	O
NULL	O
)	O
==	O
MU_ERR_NOENT	O
)	O
mu_list_append	(*(struct),*(void))->(int)
(	O
exlist	*(struct)
,	O
(	O
void	O
*	O
)	O
name	*(char)
)	O
;	O
return	O
;	O
}	O
mu_list_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
al	*(struct)
,	O
&	O
itr	*(struct)
)	O
;	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
char	O
*	O
word	*(char)
;	O
mu_iterator_current	(*(struct),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
word	*(char)
)	O
;	O
if	O
(	O
mu_list_locate	(*(struct),*(void),*(*(void)))->(int)
(	O
origlist	*(struct)
,	O
word	*(char)
,	O
NULL	O
)	O
==	O
MU_ERR_NOENT	O
)	O
{	O
mu_list_push	(*(struct),*(void))->(int)
(	O
origlist	*(struct)
,	O
word	*(char)
)	O
;	O
recursive_alias_expand	(*(char),*(struct),*(struct))->(void)
(	O
word	*(char)
,	O
exlist	*(struct)
,	O
origlist	*(struct)
)	O
;	O
mu_list_pop	(*(struct),*(*(void)))->(int)
(	O
origlist	*(struct)
,	O
NULL	O
)	O
;	O
}	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
static	O
int	O
string_comp	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
item	*(void)
,	O
const	O
void	O
*	O
value	*(void)
)	O
{	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
item	*(void)
,	O
value	*(void)
)	O
;	O
}	O
char	O
*	O
alias_expand	(*(char))->(*(char))
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
mu_list_t	*(struct)
al	*(struct)
;	O
mu_list_t	*(struct)
list	*(struct)
;	O
if	O
(	O
mailvar_is_true	(*(char))->(int)
(	O
mailvar_name_recursivealiases	*(char)
)	O
)	O
{	O
char	O
*	O
s	*(char)
;	O
mu_list_t	*(struct)
origlist	*(struct)
;	O
int	O
status	int
=	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
list	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_list_create"	*(char)
,	O
NULL	O
,	O
status	int
)	O
;	O
return	O
NULL	O
;	O
}	O
status	int
=	O
mu_list_create	(*(*(struct)))->(int)
(	O
&	O
origlist	*(struct)
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
origlist	*(struct)
)	O
;	O
mu_diag_funcall	(int,*(char),*(char),int)->(void)
(	O
MU_DIAG_ERROR	O
,	O
"mu_list_create"	*(char)
,	O
NULL	O
,	O
status	int
)	O
;	O
return	O
NULL	O
;	O
}	O
mu_list_set_comparator	(*(struct),*((*(void),*(void))->(int)))->(*((*(void),*(void))->(int)))
(	O
list	*(struct)
,	O
string_comp	(*(void),*(void))->(int)
)	O
;	O
mu_list_set_comparator	(*(struct),*((*(void),*(void))->(int)))->(*((*(void),*(void))->(int)))
(	O
origlist	*(struct)
,	O
string_comp	(*(void),*(void))->(int)
)	O
;	O
recursive_alias_expand	(*(char),*(struct),*(struct))->(void)
(	O
name	*(char)
,	O
list	*(struct)
,	O
origlist	*(struct)
)	O
;	O
s	*(char)
=	O
util_slist_to_string	(*(struct),*(char))->(*(char))
(	O
list	*(struct)
,	O
","	*(char)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
origlist	*(struct)
)	O
;	O
mu_list_destroy	(*(*(struct)))->(void)
(	O
&	O
list	*(struct)
)	O
;	O
return	O
s	*(char)
;	O
}	O
if	O
(	O
(	O
al	*(struct)
=	O
alias_lookup	(*(char))->(*(struct))
(	O
name	*(char)
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
util_slist_to_string	(*(struct),*(char))->(*(char))
(	O
al	*(struct)
,	O
","	*(char)
)	O
;	O
}	O
struct	O
alias_iterator	struct(*(struct),*(char),int,int)
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
const	O
char	O
*	O
prefix	array(*(char))
;	O
int	O
prefixlen	int
;	O
int	O
pos	int
;	O
}	O
;	O
const	O
char	O
*	O
alias_iterate_next	(*(struct))->(*(char))
(	O
alias_iterator_t	*(struct)
atr	*(struct(*(struct),*(char),int,int))
)	O
{	O
while	O
(	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
atr	*(struct(*(struct),*(char),int,int))
->	O
itr	*(struct)
)	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
mu_list_t	*(struct)
al	*(struct)
;	O
if	O
(	O
mu_iterator_current_kv	(*(struct),*(*(void)),*(*(void)))->(int)
(	O
atr	*(struct(*(struct),*(char),int,int))
->	O
itr	*(struct)
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
name	*(char)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
al	*(struct)
)	O
)	O
continue	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
atr	*(struct(*(struct),*(char),int,int))
->	O
itr	*(struct)
)	O
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
name	*(char)
)	O
>=	O
atr	*(struct(*(struct),*(char),int,int))
->	O
prefixlen	int
&&	O
strncmp	(*(char),*(char),long)->(int)
(	O
name	*(char)
,	O
atr	*(struct(*(struct),*(char),int,int))
->	O
prefix	array(*(char))
,	O
atr	*(struct(*(struct),*(char),int,int))
->	O
prefixlen	int
)	O
==	O
0	int
)	O
return	O
name	*(char)
;	O
}	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
alias_iterate_first	(*(char),*(*(struct)))->(*(char))
(	O
const	O
char	O
*	O
prefix	array(*(char))
,	O
alias_iterator_t	*(struct)
*	O
pc	long
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
alias_iterator_t	*(struct)
atr	*(struct(*(struct),*(char),int,int))
;	O
if	O
(	O
!	O
aliases	*(struct)
)	O
{	O
*	O
pc	long
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
mu_assoc_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
aliases	*(struct)
,	O
&	O
itr	*(struct)
)	O
)	O
return	O
NULL	O
;	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
atr	*(struct(*(struct),*(char),int,int))
=	O
mu_alloc	(long)->(*(void))
(	O
sizeof	O
*	O
atr	*(struct(*(struct),*(char),int,int))
)	O
;	O
atr	*(struct(*(struct),*(char),int,int))
->	O
prefix	array(*(char))
=	O
prefix	array(*(char))
;	O
atr	*(struct(*(struct),*(char),int,int))
->	O
prefixlen	int
=	O
strlen	(*(char))->(long)
(	O
prefix	array(*(char))
)	O
;	O
atr	*(struct(*(struct),*(char),int,int))
->	O
pos	int
=	O
0	int
;	O
atr	*(struct(*(struct),*(char),int,int))
->	O
itr	*(struct)
=	O
itr	*(struct)
;	O
*	O
pc	long
=	O
atr	*(struct(*(struct),*(char),int,int))
;	O
return	O
alias_iterate_next	(*(struct))->(*(char))
(	O
atr	*(struct(*(struct),*(char),int,int))
)	O
;	O
}	O
void	O
alias_iterate_end	(*(*(struct)))->(void)
(	O
alias_iterator_t	*(struct)
*	O
pc	long
)	O
{	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
(	O
*	O
pc	long
)	O
->	O
itr	*(struct)
)	O
;	O
free	(*(void))->(void)
(	O
*	O
pc	long
)	O
;	O
*	O
pc	long
=	O
NULL	O
;	O
}	O
int	O
mail_alias	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
)	O
alias_print	(*(char))->(void)
(	O
NULL	O
)	O
;	O
else	O
if	O
(	O
argc	int
==	O
2	int
)	O
alias_print	(*(char))->(void)
(	O
argv	*(*(char))
[	O
1	int
]	O
)	O
;	O
else	O
{	O
mu_list_t	*(struct)
al	*(struct)
;	O
if	O
(	O
alias_create	(*(char),*(*(struct)))->(int)
(	O
argv	*(*(char))
[	O
1	int
]	O
,	O
&	O
al	*(struct)
)	O
)	O
return	O
1	int
;	O
argc	int
--	O
;	O
argv	*(*(char))
++	O
;	O
while	O
(	O
--	O
argc	int
)	O
util_slist_add	(*(*(struct)),*(char))->(void)
(	O
&	O
al	*(struct)
,	O
*	O
++	O
argv	*(*(char))
)	O
;	O
}	O
return	O
0	int
;	O
}	O
