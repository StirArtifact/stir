static	O
int	O
level	int
=	O
DEFAULT_LEVEL	int
;	O
static	O
int	O
level_offset	int
=	O
0	int
;	O
static	O
int	O
min_level	int
=	O
0	int
;	O
static	O
int	O
max_level	int
=	O
gg_max	O
(	O
DEFAULT_LEVEL	int
,	O
10	int
)	O
;	O
static	O
int	O
main_time	int
=	O
-	O
1	int
;	O
static	O
int	O
byoyomi_time	int
=	O
-	O
1	int
;	O
static	O
int	O
byoyomi_stones	int
=	O
-	O
1	int
;	O
struct	O
remaining_time_data	struct(double,double,int,int,int)
{	O
double	O
time_left	int
;	O
double	O
time_for_last_move	double
;	O
int	O
stones	*(int)
;	O
int	O
movenum	int
;	O
int	O
in_byoyomi	int
;	O
}	O
;	O
struct	O
timer_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
{	O
struct	O
remaining_time_data	struct(double,double,int,int,int)
official	struct(double,double,int,int,int)
;	O
struct	O
remaining_time_data	struct(double,double,int,int,int)
estimated	struct(double,double,int,int,int)
;	O
int	O
time_out	int
;	O
}	O
;	O
static	O
struct	O
timer_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
black_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
;	O
static	O
struct	O
timer_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
;	O
static	O
void	O
timeval_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),double)->(void)
(	O
FILE	struct
*	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
double	O
tv	double
)	O
{	O
int	O
min	int
;	O
double	O
sec	double
;	O
min	int
=	O
(	O
int	O
)	O
tv	double
/	O
60	int
;	O
sec	double
=	O
tv	double
-	O
min	int
*	O
60	int
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
outfile	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%3dmin %.2fsec "	*(char)
,	O
min	int
,	O
sec	double
)	O
;	O
}	O
void	O
clock_print	(int)->(void)
(	O
int	O
color	int
)	O
{	O
struct	O
timer_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
*	O
const	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
=	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
&	O
black_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
:	O
&	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"clock: "	*(char)
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"%s "	*(char)
,	O
color_to_string	(int)->(*(char))
(	O
color	int
)	O
)	O
;	O
if	O
(	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
time_out	int
)	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"TIME OUT! "	*(char)
)	O
;	O
else	O
{	O
if	O
(	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
in_byoyomi	int
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"byoyomi"	*(char)
)	O
;	O
timeval_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),double)->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_left	int
)	O
;	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"for %d stones."	*(char)
,	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
stones	*(int)
)	O
;	O
}	O
else	O
timeval_print	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),double)->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_left	int
)	O
;	O
}	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
"\n"	*(char)
)	O
;	O
}	O
void	O
clock_settings	(int,int,int)->(void)
(	O
int	O
time	(*(long))->(long)
,	O
int	O
byo_time	int
,	O
int	O
byo_stones	int
)	O
{	O
if	O
(	O
time	(*(long))->(long)
>=	O
0	int
)	O
main_time	int
=	O
time	(*(long))->(long)
;	O
if	O
(	O
byo_time	int
>=	O
0	int
)	O
byoyomi_time	int
=	O
byo_time	int
;	O
if	O
(	O
byo_stones	int
>=	O
0	int
)	O
byoyomi_stones	int
=	O
byo_stones	int
;	O
init_timers	()->(void)
(	O
)	O
;	O
}	O
int	O
have_time_settings	()->(int)
(	O
void	O
)	O
{	O
if	O
(	O
byoyomi_time	int
>	O
0	int
&&	O
byoyomi_stones	int
==	O
0	int
)	O
return	O
0	int
;	O
else	O
return	O
(	O
main_time	int
>=	O
0	int
||	O
byoyomi_time	int
>=	O
0	int
)	O
;	O
}	O
void	O
init_timers	()->(void)
(	O
)	O
{	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
.	O
official	struct(double,double,int,int,int)
.	O
time_left	int
=	O
main_time	int
;	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
.	O
official	struct(double,double,int,int,int)
.	O
time_for_last_move	double
=	O
-	O
1.0	int
;	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
.	O
official	struct(double,double,int,int,int)
.	O
stones	*(int)
=	O
0	int
;	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
.	O
official	struct(double,double,int,int,int)
.	O
movenum	int
=	O
0	int
;	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
.	O
official	struct(double,double,int,int,int)
.	O
in_byoyomi	int
=	O
0	int
;	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
.	O
estimated	struct(double,double,int,int,int)
=	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
.	O
official	struct(double,double,int,int,int)
;	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
.	O
time_out	int
=	O
0	int
;	O
black_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
=	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
;	O
level_offset	int
=	O
0	int
;	O
}	O
void	O
update_time_left	(int,int,int)->(void)
(	O
int	O
color	int
,	O
int	O
time_left	int
,	O
int	O
stones	*(int)
)	O
{	O
struct	O
timer_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
*	O
const	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
=	O
(	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
&	O
black_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
:	O
&	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
)	O
;	O
int	O
time_used	int
=	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
official	struct(double,double,int,int,int)
.	O
time_left	int
-	O
time_left	int
;	O
if	O
(	O
time_left	int
>	O
0	int
)	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
time_out	int
=	O
0	int
;	O
else	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
time_out	int
=	O
1	int
;	O
if	O
(	O
time_used	int
>	O
0	int
&&	O
gg_abs	O
(	O
time_used	int
-	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_for_last_move	double
)	O
>=	O
1.0	int
)	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_for_last_move	double
=	O
time_used	int
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
stones	*(int)
=	O
stones	*(int)
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
movenum	int
=	O
movenum	int
;	O
if	O
(	O
gg_abs	O
(	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_left	int
-	O
time_left	int
)	O
>=	O
1.0	int
)	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_left	int
=	O
time_left	int
;	O
if	O
(	O
stones	*(int)
>	O
0	int
)	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
in_byoyomi	int
=	O
1	int
;	O
else	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
in_byoyomi	int
=	O
0	int
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
official	struct(double,double,int,int,int)
.	O
stones	*(int)
=	O
stones	*(int)
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
official	struct(double,double,int,int,int)
.	O
movenum	int
=	O
movenum	int
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
official	struct(double,double,int,int,int)
.	O
time_for_last_move	double
=	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
official	struct(double,double,int,int,int)
.	O
time_for_last_move	double
-	O
time_left	int
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
official	struct(double,double,int,int,int)
.	O
time_left	int
=	O
time_left	int
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
official	struct(double,double,int,int,int)
.	O
in_byoyomi	int
=	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
in_byoyomi	int
;	O
}	O
void	O
clock_push_button	(int)->(void)
(	O
int	O
color	int
)	O
{	O
static	O
double	O
last_time	double
=	O
-	O
1.0	int
;	O
static	O
int	O
last_movenum	int
=	O
-	O
1	int
;	O
struct	O
timer_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
*	O
const	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
=	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
&	O
black_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
:	O
&	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
;	O
double	O
now	double
=	O
gg_gettimeofday	()->(double)
(	O
)	O
;	O
if	O
(	O
!	O
have_time_settings	()->(int)
(	O
)	O
)	O
return	O
;	O
if	O
(	O
last_movenum	int
>=	O
0	int
&&	O
movenum	int
==	O
last_movenum	int
+	O
1	int
&&	O
movenum	int
>	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
movenum	int
)	O
{	O
double	O
time_used	int
=	O
now	double
-	O
last_time	double
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_left	int
-=	O
time_used	int
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
movenum	int
=	O
movenum	int
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_for_last_move	double
=	O
time_used	int
;	O
if	O
(	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_left	int
<	O
0	int
)	O
{	O
if	O
(	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
in_byoyomi	int
||	O
byoyomi_stones	int
==	O
0	int
)	O
{	O
DEBUG	O
(	O
DEBUG_TIME	int
,	O
"%s ran out of time.\n"	*(char)
,	O
color_to_string	(int)->(*(char))
(	O
color	int
)	O
)	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_TIME	int
)	O
clock_print	(int)->(void)
(	O
color	int
)	O
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
time_out	int
=	O
1	int
;	O
}	O
else	O
{	O
gg_assert	O
(	O
!	O
(	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
in_byoyomi	int
)	O
)	O
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
in_byoyomi	int
=	O
1	int
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
stones	*(int)
=	O
byoyomi_stones	int
-	O
1	int
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_left	int
+=	O
byoyomi_time	int
;	O
if	O
(	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_left	int
<	O
0	int
)	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
time_out	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
stones	*(int)
>	O
0	int
)	O
{	O
gg_assert	O
(	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
in_byoyomi	int
)	O
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
stones	*(int)
=	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
stones	*(int)
-	O
1	int
;	O
if	O
(	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
stones	*(int)
==	O
0	int
)	O
{	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
time_left	int
=	O
byoyomi_time	int
;	O
td	*(struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int))
->	O
estimated	struct(double,double,int,int,int)
.	O
stones	*(int)
=	O
byoyomi_stones	int
;	O
}	O
}	O
}	O
last_movenum	int
=	O
movenum	int
;	O
last_time	double
=	O
now	double
;	O
if	O
(	O
debug	int
&	O
DEBUG_TIME	int
)	O
clock_print	(int)->(void)
(	O
color	int
)	O
;	O
}	O
static	O
int	O
analyze_time_data	(int,*(double),*(double),*(int))->(int)
(	O
int	O
color	int
,	O
double	O
*	O
time_for_last_move	double
,	O
double	O
*	O
time_left	int
,	O
int	O
*	O
stones_left	*(int)
)	O
{	O
struct	O
remaining_time_data	struct(double,double,int,int,int)
*	O
const	O
timer	*(struct(double,double,int,int,int))
=	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
&	O
black_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
.	O
estimated	struct(double,double,int,int,int)
:	O
&	O
white_time_data	struct(struct(double,double,int,int,int),struct(double,double,int,int,int),int)
.	O
estimated	struct(double,double,int,int,int)
;	O
if	O
(	O
!	O
have_time_settings	()->(int)
(	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
timer	*(struct(double,double,int,int,int))
->	O
time_for_last_move	double
<	O
0.0	int
)	O
return	O
0	int
;	O
*	O
time_for_last_move	double
=	O
timer	*(struct(double,double,int,int,int))
->	O
time_for_last_move	double
;	O
if	O
(	O
timer	*(struct(double,double,int,int,int))
->	O
stones	*(int)
==	O
0	int
)	O
{	O
*	O
time_left	int
=	O
timer	*(struct(double,double,int,int,int))
->	O
time_left	int
+	O
byoyomi_time	int
;	O
if	O
(	O
byoyomi_time	int
>	O
0	int
)	O
*	O
stones_left	*(int)
=	O
byoyomi_stones	int
;	O
else	O
{	O
int	O
nominal_moves	int
=	O
board_size	int
*	O
board_size	int
/	O
3	int
;	O
*	O
stones_left	*(int)
=	O
gg_max	O
(	O
nominal_moves	int
-	O
movenum	int
/	O
2	int
,	O
2	int
*	O
nominal_moves	int
/	O
5	int
)	O
;	O
}	O
}	O
else	O
{	O
*	O
time_left	int
=	O
timer	*(struct(double,double,int,int,int))
->	O
time_left	int
;	O
*	O
stones_left	*(int)
=	O
timer	*(struct(double,double,int,int,int))
->	O
stones	*(int)
;	O
}	O
return	O
1	int
;	O
}	O
void	O
adjust_level_offset	(int)->(void)
(	O
int	O
color	int
)	O
{	O
double	O
time_for_last_move	double
;	O
double	O
time_left	int
;	O
int	O
stones_left	*(int)
;	O
if	O
(	O
!	O
analyze_time_data	(int,*(double),*(double),*(int))->(int)
(	O
color	int
,	O
&	O
time_for_last_move	double
,	O
&	O
time_left	int
,	O
&	O
stones_left	*(int)
)	O
)	O
return	O
;	O
if	O
(	O
time_left	int
<	O
time_for_last_move	double
*	O
(	O
stones_left	*(int)
+	O
3	int
)	O
)	O
level_offset	int
--	O
;	O
if	O
(	O
time_left	int
<	O
time_for_last_move	double
*	O
stones_left	*(int)
)	O
level_offset	int
--	O
;	O
if	O
(	O
3	int
*	O
time_left	int
<	O
2	int
*	O
time_for_last_move	double
*	O
stones_left	*(int)
)	O
level_offset	int
--	O
;	O
if	O
(	O
2	int
*	O
time_left	int
<	O
time_for_last_move	double
*	O
stones_left	*(int)
)	O
level_offset	int
--	O
;	O
if	O
(	O
3	int
*	O
time_left	int
<	O
time_for_last_move	double
*	O
stones_left	*(int)
)	O
level_offset	int
--	O
;	O
if	O
(	O
time_for_last_move	double
==	O
0	int
)	O
time_for_last_move	double
=	O
1	int
;	O
if	O
(	O
time_left	int
>	O
time_for_last_move	double
*	O
(	O
stones_left	*(int)
+	O
6	int
)	O
)	O
level_offset	int
++	O
;	O
if	O
(	O
time_left	int
>	O
2	int
*	O
time_for_last_move	double
*	O
(	O
stones_left	*(int)
+	O
6	int
)	O
)	O
level_offset	int
++	O
;	O
if	O
(	O
level	int
+	O
level_offset	int
<	O
min_level	int
)	O
level_offset	int
=	O
min_level	int
-	O
level	int
;	O
if	O
(	O
level	int
+	O
level_offset	int
>	O
max_level	int
)	O
level_offset	int
=	O
max_level	int
-	O
level	int
;	O
DEBUG	O
(	O
DEBUG_TIME	int
,	O
"New level %d (%d %C %f %f %d)\n"	*(char)
,	O
level	int
+	O
level_offset	int
,	O
movenum	int
/	O
2	int
,	O
color	int
,	O
time_for_last_move	double
,	O
time_left	int
,	O
stones_left	*(int)
)	O
;	O
}	O
int	O
get_level	()->(int)
(	O
)	O
{	O
return	O
level	int
+	O
level_offset	int
;	O
}	O
void	O
set_level	(int)->(void)
(	O
int	O
new_level	int
)	O
{	O
level	int
=	O
new_level	int
;	O
level_offset	int
=	O
0	int
;	O
if	O
(	O
level	int
>	O
max_level	int
)	O
max_level	int
=	O
level	int
;	O
if	O
(	O
level	int
<	O
min_level	int
)	O
min_level	int
=	O
level	int
;	O
}	O
void	O
set_max_level	(int)->(void)
(	O
int	O
new_max	int
)	O
{	O
max_level	int
=	O
new_max	int
;	O
}	O
void	O
set_min_level	(int)->(void)
(	O
int	O
new_min	int
)	O
{	O
min_level	int
=	O
new_min	int
;	O
}	O
