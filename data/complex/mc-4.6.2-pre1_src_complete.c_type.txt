typedef	O
char	O
*	O
CompletionFunction	(*(char),int)->(*(char))
(	O
char	O
*	O
,	O
int	O
)	O
;	O
static	O
int	O
ignore_filenames	int
=	O
0	int
;	O
static	O
int	O
look_for_executables	int
=	O
0	int
;	O
static	O
char	O
*	O
filename_completion_function	(*(char),int)->(*(char))
(	O
char	O
*	O
text	*(char)
,	O
int	O
state	*(int)
)	O
{	O
static	O
DIR	struct
*	O
directory	enum(int,int,int,int,int,int,int,int,int)
;	O
static	O
char	O
*	O
filename	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
dirname	*(char)
=	O
NULL	O
;	O
static	O
char	O
*	O
users_dirname	*(char)
=	O
NULL	O
;	O
static	O
size_t	long
filename_len	long
;	O
int	O
isdir	int
=	O
1	int
,	O
isexec	int
=	O
0	int
;	O
struct	O
dirent	struct(long,long,short,char,array(char))
*	O
entry	*(struct(long,long,short,char,array(char)))
=	O
NULL	O
;	O
if	O
(	O
!	O
state	*(int)
)	O
{	O
const	O
char	O
*	O
temp	*(char)
;	O
g_free	(*(void))->(void)
(	O
dirname	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
users_dirname	*(char)
)	O
;	O
if	O
(	O
(	O
*	O
text	*(char)
)	O
&&	O
(	O
temp	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
text	*(char)
,	O
PATH_SEP	char
)	O
)	O
)	O
{	O
filename	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
++	O
temp	*(char)
)	O
;	O
dirname	*(char)
=	O
g_strndup	(*(char),long)->(*(char))
(	O
text	*(char)
,	O
temp	*(char)
-	O
text	*(char)
)	O
;	O
}	O
else	O
{	O
dirname	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
"."	*(char)
)	O
;	O
filename	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
text	*(char)
)	O
;	O
}	O
users_dirname	*(char)
=	O
dirname	*(char)
;	O
{	O
dirname	*(char)
=	O
tilde_expand	(*(char))->(*(char))
(	O
dirname	*(char)
)	O
;	O
canonicalize_pathname	(*(char))->(void)
(	O
dirname	*(char)
)	O
;	O
}	O
directory	enum(int,int,int,int,int,int,int,int,int)
=	O
mc_opendir	(*(char))->(*(struct))
(	O
dirname	*(char)
)	O
;	O
filename_len	long
=	O
strlen	(*(char))->(long)
(	O
filename	*(char)
)	O
;	O
}	O
while	O
(	O
directory	enum(int,int,int,int,int,int,int,int,int)
&&	O
(	O
entry	*(struct(long,long,short,char,array(char)))
=	O
mc_readdir	(*(struct))->(*(struct(long,long,short,char,array(char))))
(	O
directory	enum(int,int,int,int,int,int,int,int,int)
)	O
)	O
)	O
{	O
if	O
(	O
!	O
filename_len	long
)	O
{	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
entry	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
,	O
"."	*(char)
)	O
||	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
entry	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
,	O
".."	*(char)
)	O
)	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
entry	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
[	O
0	int
]	O
!=	O
filename	*(char)
[	O
0	int
]	O
)	O
||	O
(	O
(	O
NLENGTH	O
(	O
entry	*(struct(long,long,short,char,array(char)))
)	O
)	O
<	O
filename_len	long
)	O
||	O
strncmp	(*(char),*(char),long)->(int)
(	O
filename	*(char)
,	O
entry	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
,	O
filename_len	long
)	O
)	O
continue	O
;	O
}	O
isdir	int
=	O
1	int
;	O
isexec	int
=	O
0	int
;	O
{	O
char	O
*	O
tmp	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
3	int
+	O
strlen	(*(char))->(long)
(	O
dirname	*(char)
)	O
+	O
NLENGTH	O
(	O
entry	*(struct(long,long,short,char,array(char)))
)	O
)	O
;	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
tempstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
tmp	*(char)
,	O
dirname	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
tmp	*(char)
,	O
PATH_SEP_STR	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
tmp	*(char)
,	O
entry	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
canonicalize_pathname	(*(char))->(void)
(	O
tmp	*(char)
)	O
;	O
if	O
(	O
!	O
mc_stat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
tmp	*(char)
,	O
&	O
tempstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
)	O
)	O
{	O
uid_t	int
my_uid	int
=	O
getuid	()->(int)
(	O
)	O
;	O
gid_t	int
my_gid	int
=	O
getgid	()->(int)
(	O
)	O
;	O
if	O
(	O
!	O
S_ISDIR	O
(	O
tempstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
)	O
)	O
{	O
isdir	int
=	O
0	int
;	O
if	O
(	O
(	O
!	O
my_uid	int
&&	O
(	O
tempstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
0111	int
)	O
)	O
||	O
(	O
my_uid	int
==	O
tempstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_uid	int
&&	O
(	O
tempstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
0100	int
)	O
)	O
||	O
(	O
my_gid	int
==	O
tempstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_gid	int
&&	O
(	O
tempstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
0010	int
)	O
)	O
||	O
(	O
tempstat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
.	O
st_mode	int
&	O
0001	int
)	O
)	O
isexec	int
=	O
1	int
;	O
}	O
}	O
g_free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
}	O
switch	O
(	O
look_for_executables	int
)	O
{	O
case	O
2	int
:	O
if	O
(	O
!	O
isexec	int
)	O
continue	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
!	O
isexec	int
&&	O
!	O
isdir	int
)	O
continue	O
;	O
break	O
;	O
}	O
if	O
(	O
ignore_filenames	int
&&	O
!	O
isdir	int
)	O
continue	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
entry	*(struct(long,long,short,char,array(char)))
)	O
{	O
if	O
(	O
directory	enum(int,int,int,int,int,int,int,int,int)
)	O
{	O
mc_closedir	(*(struct))->(int)
(	O
directory	enum(int,int,int,int,int,int,int,int,int)
)	O
;	O
directory	enum(int,int,int,int,int,int,int,int,int)
=	O
NULL	O
;	O
}	O
g_free	(*(void))->(void)
(	O
dirname	*(char)
)	O
;	O
dirname	*(char)
=	O
NULL	O
;	O
g_free	(*(void))->(void)
(	O
filename	*(char)
)	O
;	O
filename	*(char)
=	O
NULL	O
;	O
g_free	(*(void))->(void)
(	O
users_dirname	*(char)
)	O
;	O
users_dirname	*(char)
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
char	O
*	O
temp	*(char)
;	O
if	O
(	O
users_dirname	*(char)
&&	O
(	O
users_dirname	*(char)
[	O
0	int
]	O
!=	O
'.'	O
||	O
users_dirname	*(char)
[	O
1	int
]	O
)	O
)	O
{	O
int	O
dirlen	int
=	O
strlen	(*(char))->(long)
(	O
users_dirname	*(char)
)	O
;	O
temp	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
3	int
+	O
dirlen	int
+	O
NLENGTH	O
(	O
entry	*(struct(long,long,short,char,array(char)))
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
temp	*(char)
,	O
users_dirname	*(char)
)	O
;	O
if	O
(	O
users_dirname	*(char)
[	O
dirlen	int
-	O
1	int
]	O
!=	O
PATH_SEP	char
)	O
{	O
temp	*(char)
[	O
dirlen	int
]	O
=	O
PATH_SEP	char
;	O
temp	*(char)
[	O
dirlen	int
+	O
1	int
]	O
=	O
0	int
;	O
}	O
strcat	(*(char),*(char))->(*(char))
(	O
temp	*(char)
,	O
entry	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
}	O
else	O
{	O
temp	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
2	int
+	O
NLENGTH	O
(	O
entry	*(struct(long,long,short,char,array(char)))
)	O
)	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
temp	*(char)
,	O
entry	*(struct(long,long,short,char,array(char)))
->	O
d_name	array(char)
)	O
;	O
}	O
if	O
(	O
isdir	int
)	O
strcat	(*(char),*(char))->(*(char))
(	O
temp	*(char)
,	O
PATH_SEP_STR	*(char)
)	O
;	O
return	O
temp	*(char)
;	O
}	O
}	O
static	O
char	O
*	O
username_completion_function	(*(char),int)->(*(char))
(	O
char	O
*	O
text	*(char)
,	O
int	O
state	*(int)
)	O
{	O
static	O
struct	O
passwd	struct(*(char),*(char),int,int,*(char),*(char),*(char))
*	O
entry	*(struct(long,long,short,char,array(char)))
;	O
static	O
int	O
userlen	int
;	O
if	O
(	O
!	O
state	*(int)
)	O
{	O
setpwent	()->(void)
(	O
)	O
;	O
userlen	int
=	O
strlen	(*(char))->(long)
(	O
text	*(char)
+	O
1	int
)	O
;	O
}	O
while	O
(	O
(	O
entry	*(struct(long,long,short,char,array(char)))
=	O
getpwent	()->(*(struct(*(char),*(char),int,int,*(char),*(char),*(char))))
(	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
userlen	int
)	O
break	O
;	O
else	O
if	O
(	O
text	*(char)
[	O
1	int
]	O
==	O
entry	*(struct(long,long,short,char,array(char)))
->	O
pw_name	*(char)
[	O
0	int
]	O
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
text	*(char)
+	O
1	int
,	O
entry	*(struct(long,long,short,char,array(char)))
->	O
pw_name	*(char)
,	O
userlen	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
entry	*(struct(long,long,short,char,array(char)))
)	O
{	O
endpwent	()->(void)
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
char	O
*	O
temp	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
3	int
+	O
strlen	(*(char))->(long)
(	O
entry	*(struct(long,long,short,char,array(char)))
->	O
pw_name	*(char)
)	O
)	O
;	O
*	O
temp	*(char)
=	O
'~'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
temp	*(char)
+	O
1	int
,	O
entry	*(struct(long,long,short,char,array(char)))
->	O
pw_name	*(char)
)	O
;	O
strcat	(*(char),*(char))->(*(char))
(	O
temp	*(char)
,	O
PATH_SEP_STR	*(char)
)	O
;	O
return	O
temp	*(char)
;	O
}	O
}	O
static	O
char	O
*	O
variable_completion_function	(*(char),int)->(*(char))
(	O
char	O
*	O
text	*(char)
,	O
int	O
state	*(int)
)	O
{	O
static	O
char	O
*	O
*	O
env_p	*(*(char))
;	O
static	O
int	O
varlen	int
,	O
isbrace	int
;	O
const	O
char	O
*	O
p	*(void)
=	O
NULL	O
;	O
if	O
(	O
!	O
state	*(int)
)	O
{	O
isbrace	int
=	O
(	O
text	*(char)
[	O
1	int
]	O
==	O
'{'	O
)	O
;	O
varlen	int
=	O
strlen	(*(char))->(long)
(	O
text	*(char)
+	O
1	int
+	O
isbrace	int
)	O
;	O
env_p	*(*(char))
=	O
environ	*(*(char))
;	O
}	O
while	O
(	O
*	O
env_p	*(*(char))
)	O
{	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
*	O
env_p	*(*(char))
,	O
'='	O
)	O
;	O
if	O
(	O
p	*(void)
&&	O
p	*(void)
-	O
*	O
env_p	*(*(char))
>=	O
varlen	int
&&	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
text	*(char)
+	O
1	int
+	O
isbrace	int
,	O
*	O
env_p	*(*(char))
,	O
varlen	int
)	O
)	O
break	O
;	O
env_p	*(*(char))
++	O
;	O
}	O
if	O
(	O
!	O
*	O
env_p	*(*(char))
)	O
return	O
NULL	O
;	O
else	O
{	O
char	O
*	O
temp	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
2	int
+	O
2	int
*	O
isbrace	int
+	O
p	*(void)
-	O
*	O
env_p	*(*(char))
)	O
;	O
*	O
temp	*(char)
=	O
'$'	O
;	O
if	O
(	O
isbrace	int
)	O
temp	*(char)
[	O
1	int
]	O
=	O
'{'	O
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
temp	*(char)
+	O
1	int
+	O
isbrace	int
,	O
*	O
env_p	*(*(char))
,	O
p	*(void)
-	O
*	O
env_p	*(*(char))
)	O
;	O
if	O
(	O
isbrace	int
)	O
strcpy	(*(char),*(char))->(*(char))
(	O
temp	*(char)
+	O
2	int
+	O
(	O
p	*(void)
-	O
*	O
env_p	*(*(char))
)	O
,	O
"}"	*(char)
)	O
;	O
else	O
temp	*(char)
[	O
1	int
+	O
p	*(void)
-	O
*	O
env_p	*(*(char))
]	O
=	O
0	int
;	O
env_p	*(*(char))
++	O
;	O
return	O
temp	*(char)
;	O
}	O
}	O
static	O
char	O
*	O
*	O
hosts	*(*(char))
=	O
NULL	O
;	O
static	O
char	O
*	O
*	O
hosts_p	*(*(char))
=	O
NULL	O
;	O
static	O
int	O
hosts_alloclen	int
=	O
0	int
;	O
static	O
void	O
fetch_hosts	(*(char))->(void)
(	O
const	O
char	O
*	O
filename	*(char)
)	O
{	O
FILE	struct
*	O
file	*(char)
=	O
fopen	(*(char),*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
filename	*(char)
,	O
"r"	*(char)
)	O
;	O
char	O
buffer	*(char)
[	O
256	int
]	O
,	O
*	O
name	*(char)
;	O
register	O
int	O
i	array(int)
,	O
start	*(int)
;	O
if	O
(	O
!	O
file	*(char)
)	O
return	O
;	O
while	O
(	O
fgets	(*(char),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(*(char))
(	O
buffer	*(char)
,	O
255	int
,	O
file	*(char)
)	O
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	array(int)
=	O
0	int
;	O
buffer	*(char)
[	O
i	array(int)
]	O
&&	O
cr_whitespace	O
(	O
buffer	*(char)
[	O
i	array(int)
]	O
)	O
;	O
i	array(int)
++	O
)	O
;	O
if	O
(	O
buffer	*(char)
[	O
i	array(int)
]	O
==	O
'#'	O
)	O
continue	O
;	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
buffer	*(char)
+	O
i	array(int)
,	O
"$include "	*(char)
,	O
9	int
)	O
)	O
{	O
char	O
*	O
includefile	*(char)
=	O
buffer	*(char)
+	O
i	array(int)
+	O
9	int
;	O
char	O
*	O
t	long
;	O
while	O
(	O
*	O
includefile	*(char)
&&	O
whitespace	O
(	O
*	O
includefile	*(char)
)	O
)	O
includefile	*(char)
++	O
;	O
t	long
=	O
includefile	*(char)
;	O
while	O
(	O
*	O
t	long
&&	O
!	O
cr_whitespace	O
(	O
*	O
t	long
)	O
)	O
t	long
++	O
;	O
*	O
t	long
=	O
'\0'	O
;	O
fetch_hosts	(*(char))->(void)
(	O
includefile	*(char)
)	O
;	O
continue	O
;	O
}	O
while	O
(	O
buffer	*(char)
[	O
i	array(int)
]	O
&&	O
!	O
cr_whitespace	O
(	O
buffer	*(char)
[	O
i	array(int)
]	O
)	O
)	O
i	array(int)
++	O
;	O
while	O
(	O
buffer	*(char)
[	O
i	array(int)
]	O
&&	O
buffer	*(char)
[	O
i	array(int)
]	O
!=	O
'#'	O
)	O
{	O
while	O
(	O
buffer	*(char)
[	O
i	array(int)
]	O
&&	O
cr_whitespace	O
(	O
buffer	*(char)
[	O
i	array(int)
]	O
)	O
)	O
i	array(int)
++	O
;	O
if	O
(	O
buffer	*(char)
[	O
i	array(int)
]	O
==	O
'#'	O
)	O
continue	O
;	O
for	O
(	O
start	*(int)
=	O
i	array(int)
;	O
buffer	*(char)
[	O
i	array(int)
]	O
&&	O
!	O
cr_whitespace	O
(	O
buffer	*(char)
[	O
i	array(int)
]	O
)	O
;	O
i	array(int)
++	O
)	O
;	O
if	O
(	O
i	array(int)
-	O
start	*(int)
==	O
0	int
)	O
continue	O
;	O
name	*(char)
=	O
g_strndup	(*(char),long)->(*(char))
(	O
buffer	*(char)
+	O
start	*(int)
,	O
i	array(int)
-	O
start	*(int)
)	O
;	O
{	O
char	O
*	O
*	O
host_p	*(*(char))
;	O
if	O
(	O
hosts_p	*(*(char))
-	O
hosts	*(*(char))
>=	O
hosts_alloclen	int
)	O
{	O
int	O
j	int
=	O
hosts_p	*(*(char))
-	O
hosts	*(*(char))
;	O
hosts	*(*(char))
=	O
g_realloc	(*(void),long)->(*(void))
(	O
(	O
void	O
*	O
)	O
hosts	*(*(char))
,	O
(	O
(	O
hosts_alloclen	int
+=	O
30	int
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
hosts_p	*(*(char))
=	O
hosts	*(*(char))
+	O
j	int
;	O
}	O
for	O
(	O
host_p	*(*(char))
=	O
hosts	*(*(char))
;	O
host_p	*(*(char))
<	O
hosts_p	*(*(char))
;	O
host_p	*(*(char))
++	O
)	O
if	O
(	O
!	O
strcmp	(*(char),*(char))->(int)
(	O
name	*(char)
,	O
*	O
host_p	*(*(char))
)	O
)	O
break	O
;	O
if	O
(	O
host_p	*(*(char))
==	O
hosts_p	*(*(char))
)	O
{	O
*	O
(	O
hosts_p	*(*(char))
++	O
)	O
=	O
name	*(char)
;	O
*	O
hosts_p	*(*(char))
=	O
NULL	O
;	O
}	O
else	O
g_free	(*(void))->(void)
(	O
name	*(char)
)	O
;	O
}	O
}	O
}	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
file	*(char)
)	O
;	O
}	O
static	O
char	O
*	O
hostname_completion_function	(*(char),int)->(*(char))
(	O
char	O
*	O
text	*(char)
,	O
int	O
state	*(int)
)	O
{	O
static	O
char	O
*	O
*	O
host_p	*(*(char))
;	O
static	O
int	O
textstart	int
,	O
textlen	int
;	O
if	O
(	O
!	O
state	*(int)
)	O
{	O
const	O
char	O
*	O
p	*(void)
;	O
if	O
(	O
hosts	*(*(char))
!=	O
NULL	O
)	O
{	O
for	O
(	O
host_p	*(*(char))
=	O
hosts	*(*(char))
;	O
*	O
host_p	*(*(char))
;	O
host_p	*(*(char))
++	O
)	O
g_free	(*(void))->(void)
(	O
*	O
host_p	*(*(char))
)	O
;	O
g_free	(*(void))->(void)
(	O
hosts	*(*(char))
)	O
;	O
}	O
hosts	*(*(char))
=	O
g_new	O
(	O
char	O
*	O
,	O
(	O
hosts_alloclen	int
=	O
30	int
)	O
+	O
1	int
)	O
;	O
*	O
hosts	*(*(char))
=	O
NULL	O
;	O
hosts_p	*(*(char))
=	O
hosts	*(*(char))
;	O
fetch_hosts	(*(char))->(void)
(	O
(	O
p	*(void)
=	O
getenv	(*(char))->(*(char))
(	O
"HOSTFILE"	*(char)
)	O
)	O
?	O
p	*(void)
:	O
"/etc/hosts"	*(char)
)	O
;	O
host_p	*(*(char))
=	O
hosts	*(*(char))
;	O
textstart	int
=	O
(	O
*	O
text	*(char)
==	O
'@'	O
)	O
?	O
1	int
:	O
0	int
;	O
textlen	int
=	O
strlen	(*(char))->(long)
(	O
text	*(char)
+	O
textstart	int
)	O
;	O
}	O
while	O
(	O
*	O
host_p	*(*(char))
)	O
{	O
if	O
(	O
!	O
textlen	int
)	O
break	O
;	O
else	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
text	*(char)
+	O
textstart	int
,	O
*	O
host_p	*(*(char))
,	O
textlen	int
)	O
)	O
break	O
;	O
host_p	*(*(char))
++	O
;	O
}	O
if	O
(	O
!	O
*	O
host_p	*(*(char))
)	O
{	O
for	O
(	O
host_p	*(*(char))
=	O
hosts	*(*(char))
;	O
*	O
host_p	*(*(char))
;	O
host_p	*(*(char))
++	O
)	O
g_free	(*(void))->(void)
(	O
*	O
host_p	*(*(char))
)	O
;	O
g_free	(*(void))->(void)
(	O
hosts	*(*(char))
)	O
;	O
hosts	*(*(char))
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
char	O
*	O
temp	*(char)
=	O
g_malloc	(long)->(*(void))
(	O
2	int
+	O
strlen	(*(char))->(long)
(	O
*	O
host_p	*(*(char))
)	O
)	O
;	O
if	O
(	O
textstart	int
)	O
*	O
temp	*(char)
=	O
'@'	O
;	O
strcpy	(*(char),*(char))->(*(char))
(	O
temp	*(char)
+	O
textstart	int
,	O
*	O
host_p	*(*(char))
)	O
;	O
host_p	*(*(char))
++	O
;	O
return	O
temp	*(char)
;	O
}	O
}	O
static	O
char	O
*	O
command_completion_function	(*(char),int)->(*(char))
(	O
char	O
*	O
text	*(char)
,	O
int	O
state	*(int)
)	O
{	O
static	O
const	O
char	O
*	O
path_end	*(char)
;	O
static	O
int	O
isabsolute	int
;	O
static	O
int	O
phase	int
;	O
static	O
int	O
text_len	long
;	O
static	O
const	O
char	O
*	O
const	O
*	O
words	*(*(char))
;	O
static	O
char	O
*	O
path	*(char)
;	O
static	O
char	O
*	O
cur_path	*(char)
;	O
static	O
char	O
*	O
cur_word	*(char)
;	O
static	O
int	O
init_state	int
;	O
static	O
const	O
char	O
*	O
const	O
bash_reserved	array(*(char))
[	O
]	O
=	O
{	O
"if"	*(char)
,	O
"then"	*(char)
,	O
"else"	*(char)
,	O
"elif"	*(char)
,	O
"fi"	*(char)
,	O
"case"	*(char)
,	O
"esac"	*(char)
,	O
"for"	*(char)
,	O
"select"	*(char)
,	O
"while"	*(char)
,	O
"until"	*(char)
,	O
"do"	*(char)
,	O
"done"	*(char)
,	O
"in"	*(char)
,	O
"function"	*(char)
,	O
0	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
bash_builtins	array(*(char))
[	O
]	O
=	O
{	O
"alias"	*(char)
,	O
"bg"	*(char)
,	O
"bind"	*(char)
,	O
"break"	*(char)
,	O
"builtin"	*(char)
,	O
"cd"	*(char)
,	O
"command"	*(char)
,	O
"continue"	*(char)
,	O
"declare"	*(char)
,	O
"dirs"	*(char)
,	O
"echo"	*(char)
,	O
"enable"	*(char)
,	O
"eval"	*(char)
,	O
"exec"	*(char)
,	O
"exit"	*(char)
,	O
"export"	*(char)
,	O
"fc"	*(char)
,	O
"fg"	*(char)
,	O
"getopts"	*(char)
,	O
"hash"	*(char)
,	O
"help"	*(char)
,	O
"history"	*(char)
,	O
"jobs"	*(char)
,	O
"kill"	*(char)
,	O
"let"	*(char)
,	O
"local"	*(char)
,	O
"logout"	*(char)
,	O
"popd"	*(char)
,	O
"pushd"	*(char)
,	O
"pwd"	*(char)
,	O
"read"	*(char)
,	O
"readonly"	*(char)
,	O
"return"	*(char)
,	O
"set"	*(char)
,	O
"shift"	*(char)
,	O
"source"	*(char)
,	O
"suspend"	*(char)
,	O
"test"	*(char)
,	O
"times"	*(char)
,	O
"trap"	*(char)
,	O
"type"	*(char)
,	O
"typeset"	*(char)
,	O
"ulimit"	*(char)
,	O
"umask"	*(char)
,	O
"unalias"	*(char)
,	O
"unset"	*(char)
,	O
"wait"	*(char)
,	O
0	int
}	O
;	O
char	O
*	O
p	*(void)
,	O
*	O
found	*(char)
;	O
if	O
(	O
!	O
state	*(int)
)	O
{	O
isabsolute	int
=	O
strchr	(*(char),int)->(*(char))
(	O
text	*(char)
,	O
PATH_SEP	char
)	O
!=	O
0	int
;	O
look_for_executables	int
=	O
isabsolute	int
?	O
1	int
:	O
2	int
;	O
if	O
(	O
!	O
isabsolute	int
)	O
{	O
words	*(*(char))
=	O
bash_reserved	array(*(char))
;	O
phase	int
=	O
0	int
;	O
text_len	long
=	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
;	O
if	O
(	O
!	O
path	*(char)
&&	O
(	O
path	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
getenv	(*(char))->(*(char))
(	O
"PATH"	*(char)
)	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
p	*(void)
=	O
path	*(char)
;	O
path_end	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
0	int
)	O
;	O
while	O
(	O
(	O
p	*(void)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(void)
,	O
PATH_ENV_SEP	char
)	O
)	O
)	O
{	O
*	O
p	*(void)
++	O
=	O
0	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
isabsolute	int
)	O
{	O
p	*(void)
=	O
filename_completion_function	(*(char),int)->(*(char))
(	O
text	*(char)
,	O
state	*(int)
)	O
;	O
if	O
(	O
!	O
p	*(void)
)	O
look_for_executables	int
=	O
0	int
;	O
return	O
p	*(void)
;	O
}	O
found	*(char)
=	O
NULL	O
;	O
switch	O
(	O
phase	int
)	O
{	O
case	O
0	int
:	O
while	O
(	O
*	O
words	*(*(char))
)	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
*	O
words	*(*(char))
,	O
text	*(char)
,	O
text_len	long
)	O
)	O
return	O
g_strdup	(*(char))->(*(char))
(	O
*	O
(	O
words	*(*(char))
++	O
)	O
)	O
;	O
words	*(*(char))
++	O
;	O
}	O
phase	int
++	O
;	O
words	*(*(char))
=	O
bash_builtins	array(*(char))
;	O
case	O
1	int
:	O
while	O
(	O
*	O
words	*(*(char))
)	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
*	O
words	*(*(char))
,	O
text	*(char)
,	O
text_len	long
)	O
)	O
return	O
g_strdup	(*(char))->(*(char))
(	O
*	O
(	O
words	*(*(char))
++	O
)	O
)	O
;	O
words	*(*(char))
++	O
;	O
}	O
phase	int
++	O
;	O
if	O
(	O
!	O
path	*(char)
)	O
break	O
;	O
cur_path	*(char)
=	O
path	*(char)
;	O
cur_word	*(char)
=	O
NULL	O
;	O
case	O
2	int
:	O
while	O
(	O
!	O
found	*(char)
)	O
{	O
if	O
(	O
!	O
cur_word	*(char)
)	O
{	O
char	O
*	O
expanded	*(char)
;	O
if	O
(	O
cur_path	*(char)
>=	O
path_end	*(char)
)	O
break	O
;	O
expanded	*(char)
=	O
tilde_expand	(*(char))->(*(char))
(	O
*	O
cur_path	*(char)
?	O
cur_path	*(char)
:	O
"."	*(char)
)	O
;	O
cur_word	*(char)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
expanded	*(char)
,	O
text	*(char)
)	O
;	O
g_free	(*(void))->(void)
(	O
expanded	*(char)
)	O
;	O
canonicalize_pathname	(*(char))->(void)
(	O
cur_word	*(char)
)	O
;	O
cur_path	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cur_path	*(char)
,	O
0	int
)	O
+	O
1	int
;	O
init_state	int
=	O
state	*(int)
;	O
}	O
found	*(char)
=	O
filename_completion_function	(*(char),int)->(*(char))
(	O
cur_word	*(char)
,	O
state	*(int)
-	O
init_state	int
)	O
;	O
if	O
(	O
!	O
found	*(char)
)	O
{	O
g_free	(*(void))->(void)
(	O
cur_word	*(char)
)	O
;	O
cur_word	*(char)
=	O
NULL	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
found	*(char)
)	O
{	O
look_for_executables	int
=	O
0	int
;	O
g_free	(*(void))->(void)
(	O
path	*(char)
)	O
;	O
path	*(char)
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
p	*(void)
=	O
strrchr	(*(char),int)->(*(char))
(	O
found	*(char)
,	O
PATH_SEP	char
)	O
)	O
!=	O
NULL	O
)	O
{	O
p	*(void)
++	O
;	O
p	*(void)
=	O
g_strdup	(*(char))->(*(char))
(	O
p	*(void)
)	O
;	O
g_free	(*(void))->(void)
(	O
found	*(char)
)	O
;	O
return	O
p	*(void)
;	O
}	O
return	O
found	*(char)
;	O
}	O
static	O
int	O
match_compare	(*(void),*(void))->(int)
(	O
const	O
void	O
*	O
a	*(void)
,	O
const	O
void	O
*	O
b	*(void)
)	O
{	O
return	O
strcmp	(*(char),*(char))->(int)
(	O
*	O
(	O
char	O
*	O
*	O
)	O
a	*(void)
,	O
*	O
(	O
char	O
*	O
*	O
)	O
b	*(void)
)	O
;	O
}	O
static	O
char	O
*	O
*	O
completion_matches	(*(char),(*(char),int)->(*(char)))->(*(*(char)))
(	O
char	O
*	O
text	*(char)
,	O
CompletionFunction	(*(char),int)->(*(char))
entry_function	(*(char),int)->(*(char))
)	O
{	O
int	O
match_list_size	int
;	O
char	O
*	O
*	O
match_list	*(*(char))
=	O
g_new	O
(	O
char	O
*	O
,	O
(	O
match_list_size	int
=	O
30	int
)	O
+	O
1	int
)	O
;	O
int	O
matches	int
=	O
0	int
;	O
char	O
*	O
string	*(char)
;	O
match_list	*(*(char))
[	O
1	int
]	O
=	O
NULL	O
;	O
while	O
(	O
(	O
string	*(char)
=	O
(	O
*	O
entry_function	(*(char),int)->(*(char))
)	O
(	O
text	*(char)
,	O
matches	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
matches	int
+	O
1	int
==	O
match_list_size	int
)	O
match_list	*(*(char))
=	O
(	O
char	O
*	O
*	O
)	O
g_realloc	(*(void),long)->(*(void))
(	O
match_list	*(*(char))
,	O
(	O
(	O
match_list_size	int
+=	O
30	int
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
match_list	*(*(char))
[	O
++	O
matches	int
]	O
=	O
string	*(char)
;	O
match_list	*(*(char))
[	O
matches	int
+	O
1	int
]	O
=	O
NULL	O
;	O
}	O
if	O
(	O
matches	int
)	O
{	O
register	O
int	O
i	array(int)
=	O
1	int
;	O
int	O
low	int
=	O
4096	int
;	O
if	O
(	O
matches	int
==	O
1	int
)	O
{	O
match_list	*(*(char))
[	O
0	int
]	O
=	O
match_list	*(*(char))
[	O
1	int
]	O
;	O
match_list	*(*(char))
[	O
1	int
]	O
=	O
NULL	O
;	O
}	O
else	O
{	O
int	O
j	int
;	O
qsort	(*(void),long,long,*((*(void),*(void))->(int)))->(void)
(	O
match_list	*(*(char))
+	O
1	int
,	O
matches	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
match_compare	(*(void),*(void))->(int)
)	O
;	O
j	int
=	O
i	array(int)
+	O
1	int
;	O
while	O
(	O
j	int
<	O
matches	int
+	O
1	int
)	O
{	O
register	O
int	O
c1	int
,	O
c2	int
,	O
si	int
;	O
for	O
(	O
si	int
=	O
0	int
;	O
(	O
c1	int
=	O
match_list	*(*(char))
[	O
i	array(int)
]	O
[	O
si	int
]	O
)	O
&&	O
(	O
c2	int
=	O
match_list	*(*(char))
[	O
j	int
]	O
[	O
si	int
]	O
)	O
;	O
si	int
++	O
)	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
break	O
;	O
if	O
(	O
!	O
c1	int
&&	O
!	O
match_list	*(*(char))
[	O
j	int
]	O
[	O
si	int
]	O
)	O
{	O
g_free	(*(void))->(void)
(	O
match_list	*(*(char))
[	O
j	int
]	O
)	O
;	O
j	int
++	O
;	O
if	O
(	O
j	int
>	O
matches	int
)	O
break	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
low	int
>	O
si	int
)	O
low	int
=	O
si	int
;	O
if	O
(	O
i	array(int)
+	O
1	int
!=	O
j	int
)	O
match_list	*(*(char))
[	O
i	array(int)
+	O
1	int
]	O
=	O
match_list	*(*(char))
[	O
j	int
]	O
;	O
i	array(int)
++	O
;	O
j	int
++	O
;	O
}	O
matches	int
=	O
i	array(int)
;	O
match_list	*(*(char))
[	O
matches	int
+	O
1	int
]	O
=	O
NULL	O
;	O
match_list	*(*(char))
[	O
0	int
]	O
=	O
g_strndup	(*(char),long)->(*(char))
(	O
match_list	*(*(char))
[	O
1	int
]	O
,	O
low	int
)	O
;	O
}	O
}	O
else	O
{	O
g_free	(*(void))->(void)
(	O
match_list	*(*(char))
)	O
;	O
match_list	*(*(char))
=	O
NULL	O
;	O
}	O
return	O
match_list	*(*(char))
;	O
}	O
static	O
int	O
check_is_cd	(*(char),int,int)->(int)
(	O
const	O
char	O
*	O
text	*(char)
,	O
int	O
start	*(int)
,	O
int	O
flags	enum(int,int,int,int)
)	O
{	O
const	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(char)
;	O
if	O
(	O
flags	enum(int,int,int,int)
&	O
INPUT_COMPLETE_CD	int
)	O
return	O
1	int
;	O
if	O
(	O
!	O
(	O
flags	enum(int,int,int,int)
&	O
INPUT_COMPLETE_COMMANDS	int
)	O
)	O
return	O
0	int
;	O
p	*(void)
=	O
text	*(char)
;	O
q	*(char)
=	O
text	*(char)
+	O
start	*(int)
;	O
while	O
(	O
p	*(void)
<	O
q	*(char)
&&	O
*	O
p	*(void)
&&	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	*(void)
)	O
)	O
p	*(void)
++	O
;	O
if	O
(	O
p	*(void)
[	O
0	int
]	O
==	O
'c'	O
&&	O
p	*(void)
[	O
1	int
]	O
==	O
'd'	O
&&	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
p	*(void)
[	O
2	int
]	O
)	O
&&	O
(	O
p	*(void)
+	O
2	int
<	O
q	*(char)
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
*	O
try_complete	(*(char),*(int),*(int),int)->(*(*(char)))
(	O
char	O
*	O
text	*(char)
,	O
int	O
*	O
start	*(int)
,	O
int	O
*	O
end	*(struct)
,	O
int	O
flags	enum(int,int,int,int)
)	O
{	O
int	O
in_command_position	int
=	O
0	int
,	O
i	array(int)
;	O
char	O
*	O
word	*(char)
,	O
c	int
;	O
char	O
*	O
*	O
matches	int
=	O
NULL	O
;	O
const	O
char	O
*	O
command_separator_chars	*(char)
=	O
";|&{(`"	*(char)
;	O
char	O
*	O
p	*(void)
=	O
NULL	O
,	O
*	O
q	*(char)
=	O
NULL	O
,	O
*	O
r	*(struct)
=	O
NULL	O
;	O
int	O
is_cd	int
=	O
check_is_cd	(*(char),int,int)->(int)
(	O
text	*(char)
,	O
*	O
start	*(int)
,	O
flags	enum(int,int,int,int)
)	O
;	O
ignore_filenames	int
=	O
0	int
;	O
c	int
=	O
text	*(char)
[	O
*	O
end	*(struct)
]	O
;	O
text	*(char)
[	O
*	O
end	*(struct)
]	O
=	O
0	int
;	O
word	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
text	*(char)
+	O
*	O
start	*(int)
)	O
;	O
text	*(char)
[	O
*	O
end	*(struct)
]	O
=	O
c	int
;	O
if	O
(	O
!	O
is_cd	int
&&	O
(	O
flags	enum(int,int,int,int)
&	O
INPUT_COMPLETE_COMMANDS	int
)	O
)	O
{	O
i	array(int)
=	O
*	O
start	*(int)
-	O
1	int
;	O
while	O
(	O
i	array(int)
>	O
-	O
1	int
&&	O
(	O
text	*(char)
[	O
i	array(int)
]	O
==	O
' '	O
||	O
text	*(char)
[	O
i	array(int)
]	O
==	O
'\t'	O
)	O
)	O
i	array(int)
--	O
;	O
if	O
(	O
i	array(int)
<	O
0	int
)	O
in_command_position	int
++	O
;	O
else	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
command_separator_chars	*(char)
,	O
text	*(char)
[	O
i	array(int)
]	O
)	O
)	O
{	O
register	O
int	O
this_char	int
,	O
prev_char	int
;	O
in_command_position	int
++	O
;	O
if	O
(	O
i	array(int)
)	O
{	O
this_char	int
=	O
text	*(char)
[	O
i	array(int)
]	O
;	O
prev_char	int
=	O
text	*(char)
[	O
i	array(int)
-	O
1	int
]	O
;	O
if	O
(	O
(	O
this_char	int
==	O
'&'	O
&&	O
(	O
prev_char	int
==	O
'<'	O
||	O
prev_char	int
==	O
'>'	O
)	O
)	O
||	O
(	O
this_char	int
==	O
'|'	O
&&	O
prev_char	int
==	O
'>'	O
)	O
)	O
in_command_position	int
=	O
0	int
;	O
else	O
if	O
(	O
i	array(int)
>	O
0	int
&&	O
text	*(char)
[	O
i	array(int)
-	O
1	int
]	O
==	O
'\\'	O
)	O
in_command_position	int
=	O
0	int
;	O
}	O
}	O
}	O
if	O
(	O
flags	enum(int,int,int,int)
&	O
INPUT_COMPLETE_COMMANDS	int
)	O
p	*(void)
=	O
strrchr	(*(char),int)->(*(char))
(	O
word	*(char)
,	O
'`'	O
)	O
;	O
if	O
(	O
flags	enum(int,int,int,int)
&	O
(	O
INPUT_COMPLETE_COMMANDS	int
|	O
INPUT_COMPLETE_VARIABLES	int
)	O
)	O
q	*(char)
=	O
strrchr	(*(char),int)->(*(char))
(	O
word	*(char)
,	O
'$'	O
)	O
;	O
if	O
(	O
flags	enum(int,int,int,int)
&	O
INPUT_COMPLETE_HOSTNAMES	int
)	O
r	*(struct)
=	O
strrchr	(*(char),int)->(*(char))
(	O
word	*(char)
,	O
'@'	O
)	O
;	O
if	O
(	O
q	*(char)
&&	O
q	*(char)
[	O
1	int
]	O
==	O
'('	O
&&	O
INPUT_COMPLETE_COMMANDS	int
)	O
{	O
if	O
(	O
q	*(char)
>	O
p	*(void)
)	O
p	*(void)
=	O
q	*(char)
+	O
1	int
;	O
q	*(char)
=	O
NULL	O
;	O
}	O
if	O
(	O
p	*(void)
>	O
q	*(char)
&&	O
p	*(void)
>	O
r	*(struct)
)	O
{	O
matches	int
=	O
completion_matches	(*(char),(*(char),int)->(*(char)))->(*(*(char)))
(	O
p	*(void)
+	O
1	int
,	O
command_completion_function	(*(char),int)->(*(char))
)	O
;	O
if	O
(	O
matches	int
)	O
*	O
start	*(int)
+=	O
p	*(void)
+	O
1	int
-	O
word	*(char)
;	O
}	O
else	O
if	O
(	O
q	*(char)
>	O
p	*(void)
&&	O
q	*(char)
>	O
r	*(struct)
)	O
{	O
matches	int
=	O
completion_matches	(*(char),(*(char),int)->(*(char)))->(*(*(char)))
(	O
q	*(char)
,	O
variable_completion_function	(*(char),int)->(*(char))
)	O
;	O
if	O
(	O
matches	int
)	O
*	O
start	*(int)
+=	O
q	*(char)
-	O
word	*(char)
;	O
}	O
else	O
if	O
(	O
r	*(struct)
>	O
p	*(void)
&&	O
r	*(struct)
>	O
q	*(char)
)	O
{	O
matches	int
=	O
completion_matches	(*(char),(*(char),int)->(*(char)))->(*(*(char)))
(	O
r	*(struct)
,	O
hostname_completion_function	(*(char),int)->(*(char))
)	O
;	O
if	O
(	O
matches	int
)	O
*	O
start	*(int)
+=	O
r	*(struct)
-	O
word	*(char)
;	O
}	O
if	O
(	O
!	O
matches	int
&&	O
*	O
word	*(char)
==	O
'~'	O
&&	O
(	O
flags	enum(int,int,int,int)
&	O
INPUT_COMPLETE_USERNAMES	int
)	O
&&	O
!	O
strchr	(*(char),int)->(*(char))
(	O
word	*(char)
,	O
PATH_SEP	char
)	O
)	O
matches	int
=	O
completion_matches	(*(char),(*(char),int)->(*(char)))->(*(*(char)))
(	O
word	*(char)
,	O
username_completion_function	(*(char),int)->(*(char))
)	O
;	O
if	O
(	O
!	O
matches	int
&&	O
in_command_position	int
)	O
matches	int
=	O
completion_matches	(*(char),(*(char),int)->(*(char)))->(*(*(char)))
(	O
word	*(char)
,	O
command_completion_function	(*(char),int)->(*(char))
)	O
;	O
else	O
if	O
(	O
!	O
matches	int
&&	O
(	O
flags	enum(int,int,int,int)
&	O
INPUT_COMPLETE_FILENAMES	int
)	O
)	O
{	O
if	O
(	O
is_cd	int
)	O
ignore_filenames	int
=	O
1	int
;	O
matches	int
=	O
completion_matches	(*(char),(*(char),int)->(*(char)))->(*(*(char)))
(	O
word	*(char)
,	O
filename_completion_function	(*(char),int)->(*(char))
)	O
;	O
ignore_filenames	int
=	O
0	int
;	O
if	O
(	O
!	O
matches	int
&&	O
is_cd	int
&&	O
*	O
word	*(char)
!=	O
PATH_SEP	char
&&	O
*	O
word	*(char)
!=	O
'~'	O
)	O
{	O
char	O
*	O
p	*(void)
,	O
*	O
q	*(char)
=	O
text	*(char)
+	O
*	O
start	*(int)
;	O
for	O
(	O
p	*(void)
=	O
text	*(char)
;	O
*	O
p	*(void)
&&	O
p	*(void)
<	O
q	*(char)
&&	O
(	O
*	O
p	*(void)
==	O
' '	O
||	O
*	O
p	*(void)
==	O
'\t'	O
)	O
;	O
p	*(void)
++	O
)	O
;	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
p	*(void)
,	O
"cd"	*(char)
,	O
2	int
)	O
)	O
for	O
(	O
p	*(void)
+=	O
2	int
;	O
*	O
p	*(void)
&&	O
p	*(void)
<	O
q	*(char)
&&	O
(	O
*	O
p	*(void)
==	O
' '	O
||	O
*	O
p	*(void)
==	O
'\t'	O
)	O
;	O
p	*(void)
++	O
)	O
;	O
if	O
(	O
p	*(void)
==	O
q	*(char)
)	O
{	O
char	O
*	O
const	O
cdpath_ref	*(char)
=	O
g_strdup	(*(char))->(*(char))
(	O
getenv	(*(char))->(*(char))
(	O
"CDPATH"	*(char)
)	O
)	O
;	O
char	O
*	O
cdpath	*(char)
=	O
cdpath_ref	*(char)
;	O
char	O
c	int
,	O
*	O
s	*(char)
,	O
*	O
r	*(struct)
;	O
if	O
(	O
cdpath	*(char)
==	O
NULL	O
)	O
c	int
=	O
0	int
;	O
else	O
c	int
=	O
':'	O
;	O
while	O
(	O
!	O
matches	int
&&	O
c	int
==	O
':'	O
)	O
{	O
s	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cdpath	*(char)
,	O
':'	O
)	O
;	O
if	O
(	O
s	*(char)
==	O
NULL	O
)	O
s	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
cdpath	*(char)
,	O
0	int
)	O
;	O
c	int
=	O
*	O
s	*(char)
;	O
*	O
s	*(char)
=	O
0	int
;	O
if	O
(	O
*	O
cdpath	*(char)
)	O
{	O
r	*(struct)
=	O
concat_dir_and_file	(*(char),*(char))->(*(char))
(	O
cdpath	*(char)
,	O
word	*(char)
)	O
;	O
ignore_filenames	int
=	O
1	int
;	O
matches	int
=	O
completion_matches	(*(char),(*(char),int)->(*(char)))->(*(*(char)))
(	O
r	*(struct)
,	O
filename_completion_function	(*(char),int)->(*(char))
)	O
;	O
ignore_filenames	int
=	O
0	int
;	O
g_free	(*(void))->(void)
(	O
r	*(struct)
)	O
;	O
}	O
*	O
s	*(char)
=	O
c	int
;	O
cdpath	*(char)
=	O
s	*(char)
+	O
1	int
;	O
}	O
g_free	(*(void))->(void)
(	O
cdpath_ref	*(char)
)	O
;	O
}	O
}	O
}	O
g_free	(*(void))->(void)
(	O
word	*(char)
)	O
;	O
return	O
matches	int
;	O
}	O
void	O
free_completions	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))->(void)
(	O
WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
in	*(char)
)	O
{	O
char	O
*	O
*	O
p	*(void)
;	O
if	O
(	O
!	O
in	*(char)
->	O
completions	*(*(char))
)	O
return	O
;	O
for	O
(	O
p	*(void)
=	O
in	*(char)
->	O
completions	*(*(char))
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
g_free	(*(void))->(void)
(	O
*	O
p	*(void)
)	O
;	O
g_free	(*(void))->(void)
(	O
in	*(char)
->	O
completions	*(*(char))
)	O
;	O
in	*(char)
->	O
completions	*(*(char))
=	O
NULL	O
;	O
}	O
static	O
int	O
query_height	int
,	O
query_width	int
;	O
static	O
WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
input	*(int)
;	O
static	O
int	O
min_end	int
;	O
static	O
int	O
start	*(int)
,	O
end	*(struct)
;	O
static	O
int	O
insert_text	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))),*(char),long)->(int)
(	O
WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
in	*(char)
,	O
char	O
*	O
text	*(char)
,	O
ssize_t	long
len	int
)	O
{	O
len	int
=	O
min	long
(	O
len	int
,	O
(	O
ssize_t	long
)	O
strlen	(*(char))->(long)
(	O
text	*(char)
)	O
)	O
+	O
start	*(int)
-	O
end	*(struct)
;	O
if	O
(	O
strlen	(*(char))->(long)
(	O
in	*(char)
->	O
buffer	*(char)
)	O
+	O
len	int
>=	O
(	O
size_t	long
)	O
in	*(char)
->	O
current_max_len	int
)	O
{	O
char	O
*	O
narea	*(char)
=	O
g_realloc	(*(void),long)->(*(void))
(	O
in	*(char)
->	O
buffer	*(char)
,	O
in	*(char)
->	O
current_max_len	int
+	O
len	int
+	O
in	*(char)
->	O
field_len	int
)	O
;	O
if	O
(	O
narea	*(char)
)	O
{	O
in	*(char)
->	O
buffer	*(char)
=	O
narea	*(char)
;	O
in	*(char)
->	O
current_max_len	int
+=	O
len	int
+	O
in	*(char)
->	O
field_len	int
;	O
}	O
}	O
if	O
(	O
strlen	(*(char))->(long)
(	O
in	*(char)
->	O
buffer	*(char)
)	O
+	O
1	int
<	O
(	O
size_t	long
)	O
in	*(char)
->	O
current_max_len	int
)	O
{	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
int	O
i	array(int)
=	O
strlen	(*(char))->(long)
(	O
&	O
in	*(char)
->	O
buffer	*(char)
[	O
end	*(struct)
]	O
)	O
;	O
for	O
(	O
;	O
i	array(int)
>=	O
0	int
;	O
i	array(int)
--	O
)	O
in	*(char)
->	O
buffer	*(char)
[	O
end	*(struct)
+	O
len	int
+	O
i	array(int)
]	O
=	O
in	*(char)
->	O
buffer	*(char)
[	O
end	*(struct)
+	O
i	array(int)
]	O
;	O
}	O
else	O
if	O
(	O
len	int
<	O
0	int
)	O
{	O
char	O
*	O
p	*(void)
=	O
in	*(char)
->	O
buffer	*(char)
+	O
end	*(struct)
+	O
len	int
,	O
*	O
q	*(char)
=	O
in	*(char)
->	O
buffer	*(char)
+	O
end	*(struct)
;	O
while	O
(	O
*	O
q	*(char)
)	O
*	O
(	O
p	*(void)
++	O
)	O
=	O
*	O
(	O
q	*(char)
++	O
)	O
;	O
*	O
p	*(void)
=	O
0	int
;	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
in	*(char)
->	O
buffer	*(char)
+	O
start	*(int)
,	O
text	*(char)
,	O
len	int
-	O
start	*(int)
+	O
end	*(struct)
)	O
;	O
in	*(char)
->	O
point	int
+=	O
len	int
;	O
update_input	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))),int)->(void)
(	O
in	*(char)
,	O
1	int
)	O
;	O
end	*(struct)
+=	O
len	int
;	O
}	O
return	O
len	int
!=	O
0	int
;	O
}	O
static	O
cb_ret_t	enum(int,int)
query_callback	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
(	O
Dlg_head	struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))))))
*	O
h	*(struct)
,	O
dlg_msg_t	enum(int,int,int,int,int,int,int,int,int,int,int,int,int)
msg	*(char)
,	O
int	O
parm	int
)	O
{	O
switch	O
(	O
msg	*(char)
)	O
{	O
case	O
DLG_KEY	int
:	O
switch	O
(	O
parm	int
)	O
{	O
case	O
KEY_LEFT	int
:	O
case	O
KEY_RIGHT	int
:	O
h	*(struct)
->	O
ret_value	int
=	O
0	int
;	O
dlg_stop	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
h	*(struct)
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
KEY_BACKSPACE	int
:	O
if	O
(	O
end	*(struct)
==	O
min_end	int
)	O
{	O
h	*(struct)
->	O
ret_value	int
=	O
0	int
;	O
dlg_stop	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
h	*(struct)
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
else	O
{	O
WLEntry	struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))))),*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))))))
*	O
e	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
,	O
*	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
;	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
=	O
e	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
=	O
(	O
(	O
WListbox	struct
*	O
)	O
(	O
h	*(struct)
->	O
current	*(struct)
)	O
)	O
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
do	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
input	*(int)
->	O
buffer	*(char)
+	O
start	*(int)
,	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
end	*(struct)
-	O
start	*(int)
-	O
1	int
)	O
)	O
{	O
listbox_select_entry	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),int,int,int,int,int,int,*((*`)->(int)),int,int)),*(struct(*(char),int,*(void),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)))))->(void)
(	O
(	O
WListbox	struct
*	O
)	O
(	O
h	*(struct)
->	O
current	*(struct)
)	O
,	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
)	O
;	O
handle_char	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))),int)->(enum(int,int))
(	O
input	*(int)
,	O
parm	int
)	O
;	O
end	*(struct)
--	O
;	O
send_message	(*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
(	O
h	*(struct)
->	O
current	*(struct)
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
break	O
;	O
}	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
=	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
while	O
(	O
e	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
!=	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
)	O
;	O
}	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
if	O
(	O
parm	int
>	O
0xff	int
||	O
!	O
is_printable	(int)->(int)
(	O
parm	int
)	O
)	O
{	O
if	O
(	O
is_in_input_map	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))),int)->(int)
(	O
input	*(int)
,	O
parm	int
)	O
==	O
2	int
)	O
{	O
if	O
(	O
end	*(struct)
==	O
min_end	int
)	O
return	O
MSG_HANDLED	int
;	O
h	*(struct)
->	O
ret_value	int
=	O
B_USER	int
;	O
dlg_stop	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
h	*(struct)
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
else	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
else	O
{	O
WLEntry	struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))))),*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))))))
*	O
e	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
,	O
*	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
;	O
int	O
need_redraw	int
=	O
0	int
;	O
int	O
low	int
=	O
4096	int
;	O
char	O
*	O
last_text	*(char)
=	O
NULL	O
;	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
=	O
e	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
=	O
(	O
(	O
WListbox	struct
*	O
)	O
(	O
h	*(struct)
->	O
current	*(struct)
)	O
)	O
->	O
list	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`)))))
;	O
do	O
{	O
if	O
(	O
!	O
strncmp	(*(char),*(char),long)->(int)
(	O
input	*(int)
->	O
buffer	*(char)
+	O
start	*(int)
,	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
->	O
text	*(char)
,	O
end	*(struct)
-	O
start	*(int)
)	O
)	O
{	O
if	O
(	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
->	O
text	*(char)
[	O
end	*(struct)
-	O
start	*(int)
]	O
==	O
parm	int
)	O
{	O
if	O
(	O
need_redraw	int
)	O
{	O
register	O
int	O
c1	int
,	O
c2	int
,	O
si	int
;	O
for	O
(	O
si	int
=	O
end	*(struct)
-	O
start	*(int)
+	O
1	int
;	O
(	O
c1	int
=	O
last_text	*(char)
[	O
si	int
]	O
)	O
&&	O
(	O
c2	int
=	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
->	O
text	*(char)
[	O
si	int
]	O
)	O
;	O
si	int
++	O
)	O
if	O
(	O
c1	int
!=	O
c2	int
)	O
break	O
;	O
if	O
(	O
low	int
>	O
si	int
)	O
low	int
=	O
si	int
;	O
last_text	*(char)
=	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
->	O
text	*(char)
;	O
need_redraw	int
=	O
2	int
;	O
}	O
else	O
{	O
need_redraw	int
=	O
1	int
;	O
listbox_select_entry	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),int,int,int,int,int,int,*((*`)->(int)),int,int)),*(struct(*(char),int,*(void),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)))))->(void)
(	O
(	O
WListbox	struct
*	O
)	O
(	O
h	*(struct)
->	O
current	*(struct)
)	O
,	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
)	O
;	O
last_text	*(char)
=	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
->	O
text	*(char)
;	O
}	O
}	O
}	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
=	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
->	O
next	*(struct(*(void),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`))),*(struct(*(void),*(struct`),*(struct`),*(struct`),*(struct`)))))
;	O
}	O
while	O
(	O
e	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
!=	O
e1	*(struct(*(char),int,*(void),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`)))))
)	O
;	O
if	O
(	O
need_redraw	int
==	O
2	int
)	O
{	O
insert_text	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))),*(char),long)->(int)
(	O
input	*(int)
,	O
last_text	*(char)
,	O
low	int
)	O
;	O
send_message	(*(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
(	O
h	*(struct)
->	O
current	*(struct)
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
need_redraw	int
==	O
1	int
)	O
{	O
h	*(struct)
->	O
ret_value	int
=	O
B_ENTER	int
;	O
dlg_stop	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
h	*(struct)
)	O
;	O
}	O
}	O
return	O
MSG_HANDLED	int
;	O
}	O
break	O
;	O
default	O
:	O
return	O
default_dlg_callback	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
(	O
h	*(struct)
,	O
msg	*(char)
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
int	O
complete_engine	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))),int)->(int)
(	O
WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
in	*(char)
,	O
int	O
what_to_do	int
)	O
{	O
if	O
(	O
in	*(char)
->	O
completions	*(*(char))
&&	O
in	*(char)
->	O
point	int
!=	O
end	*(struct)
)	O
free_completions	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))->(void)
(	O
in	*(char)
)	O
;	O
if	O
(	O
!	O
in	*(char)
->	O
completions	*(*(char))
)	O
{	O
end	*(struct)
=	O
in	*(char)
->	O
point	int
;	O
for	O
(	O
start	*(int)
=	O
end	*(struct)
?	O
end	*(struct)
-	O
1	int
:	O
0	int
;	O
start	*(int)
>	O
-	O
1	int
;	O
start	*(int)
--	O
)	O
if	O
(	O
strchr	(*(char),int)->(*(char))
(	O
" \t;|<>"	*(char)
,	O
in	*(char)
->	O
buffer	*(char)
[	O
start	*(int)
]	O
)	O
)	O
break	O
;	O
if	O
(	O
start	*(int)
<	O
end	*(struct)
)	O
start	*(int)
++	O
;	O
in	*(char)
->	O
completions	*(*(char))
=	O
try_complete	(*(char),*(int),*(int),int)->(*(*(char)))
(	O
in	*(char)
->	O
buffer	*(char)
,	O
&	O
start	*(int)
,	O
&	O
end	*(struct)
,	O
in	*(char)
->	O
completion_flags	int
)	O
;	O
}	O
if	O
(	O
in	*(char)
->	O
completions	*(*(char))
)	O
{	O
if	O
(	O
what_to_do	int
&	O
DO_INSERTION	int
||	O
(	O
(	O
what_to_do	int
&	O
DO_QUERY	int
)	O
&&	O
!	O
in	*(char)
->	O
completions	*(*(char))
[	O
1	int
]	O
)	O
)	O
{	O
if	O
(	O
insert_text	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))),*(char),long)->(int)
(	O
in	*(char)
,	O
in	*(char)
->	O
completions	*(*(char))
[	O
0	int
]	O
,	O
strlen	(*(char))->(long)
(	O
in	*(char)
->	O
completions	*(*(char))
[	O
0	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
in	*(char)
->	O
completions	*(*(char))
[	O
1	int
]	O
)	O
beep	O
(	O
)	O
;	O
else	O
free_completions	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))->(void)
(	O
in	*(char)
)	O
;	O
}	O
else	O
beep	O
(	O
)	O
;	O
}	O
if	O
(	O
(	O
what_to_do	int
&	O
DO_QUERY	int
)	O
&&	O
in	*(char)
->	O
completions	*(*(char))
&&	O
in	*(char)
->	O
completions	*(*(char))
[	O
1	int
]	O
)	O
{	O
int	O
maxlen	int
=	O
0	int
,	O
i	array(int)
,	O
count	int
=	O
0	int
;	O
int	O
x	array(long)
,	O
y	short
,	O
w	*(int)
,	O
h	*(struct)
;	O
int	O
start_x	int
,	O
start_y	int
;	O
char	O
*	O
*	O
p	*(void)
,	O
*	O
q	*(char)
;	O
Dlg_head	struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`))))))
*	O
query_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
;	O
WListbox	struct
*	O
query_list	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
;	O
for	O
(	O
p	*(void)
=	O
in	*(char)
->	O
completions	*(*(char))
+	O
1	int
;	O
*	O
p	*(void)
;	O
count	int
++	O
,	O
p	*(void)
++	O
)	O
if	O
(	O
(	O
i	array(int)
=	O
strlen	(*(char))->(long)
(	O
*	O
p	*(void)
)	O
)	O
>	O
maxlen	int
)	O
maxlen	int
=	O
i	array(int)
;	O
start_x	int
=	O
in	*(char)
->	O
widget	*(struct)
.	O
x	array(long)
;	O
start_y	int
=	O
in	*(char)
->	O
widget	*(struct)
.	O
y	short
;	O
if	O
(	O
start_y	int
-	O
2	int
>=	O
count	int
)	O
{	O
y	short
=	O
start_y	int
-	O
2	int
-	O
count	int
;	O
h	*(struct)
=	O
2	int
+	O
count	int
;	O
}	O
else	O
{	O
if	O
(	O
start_y	int
>=	O
LINES	O
-	O
start_y	int
-	O
1	int
)	O
{	O
y	short
=	O
0	int
;	O
h	*(struct)
=	O
start_y	int
;	O
}	O
else	O
{	O
y	short
=	O
start_y	int
+	O
1	int
;	O
h	*(struct)
=	O
LINES	O
-	O
start_y	int
-	O
1	int
;	O
}	O
}	O
x	array(long)
=	O
start	*(int)
-	O
in	*(char)
->	O
first_shown	int
-	O
2	int
+	O
start_x	int
;	O
w	*(int)
=	O
maxlen	int
+	O
4	int
;	O
if	O
(	O
x	array(long)
+	O
w	*(int)
>	O
COLS	O
)	O
x	array(long)
=	O
COLS	O
-	O
w	*(int)
;	O
if	O
(	O
x	array(long)
<	O
0	int
)	O
x	array(long)
=	O
0	int
;	O
if	O
(	O
x	array(long)
+	O
w	*(int)
>	O
COLS	O
)	O
w	*(int)
=	O
COLS	O
;	O
input	*(int)
=	O
in	*(char)
;	O
min_end	int
=	O
end	*(struct)
;	O
query_height	int
=	O
h	*(struct)
;	O
query_width	int
=	O
w	*(int)
;	O
query_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
=	O
create_dlg	(int,int,int,int,*(int),*((*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(char),*(char),int)->(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))
(	O
y	short
,	O
x	array(long)
,	O
query_height	int
,	O
query_width	int
,	O
dialog_colors	array(int)
,	O
query_callback	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))
,	O
"[Completion]"	*(char)
,	O
NULL	O
,	O
DLG_COMPACT	O
)	O
;	O
query_list	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
=	O
listbox_new	(int,int,int,int,*((*(struct(struct`,*`,*`,*`,int,int,int,int,int,int,*`,int,int)))->(int)))->(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),int,int,int,int,int,int,*((*`)->(int)),int,int)))
(	O
1	int
,	O
1	int
,	O
w	*(int)
-	O
2	int
,	O
h	*(struct)
-	O
2	int
,	O
NULL	O
)	O
;	O
add_widget	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))),*(void))->(int)
(	O
query_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
,	O
query_list	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
)	O
;	O
for	O
(	O
p	*(void)
=	O
in	*(char)
->	O
completions	*(*(char))
+	O
1	int
;	O
*	O
p	*(void)
;	O
p	*(void)
++	O
)	O
listbox_add_item	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),int,int,int,int,int,int,*((*`)->(int)),int,int)),enum(int,int,int),int,*(char),*(void))->(*(char))
(	O
query_list	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
0	int
,	O
0	int
,	O
*	O
p	*(void)
,	O
NULL	O
)	O
;	O
run_dlg	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(int)
(	O
query_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
q	*(char)
=	O
NULL	O
;	O
if	O
(	O
query_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
ret_value	int
==	O
B_ENTER	int
)	O
{	O
listbox_get_current	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),*(struct(*`,int,*`,*`,*`)),int,int,int,int,int,int,*((*`)->(int)),int,int)),*(*(char)),*(*(char)))->(void)
(	O
query_list	*(struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),*(struct(*(char),int,*(void),*(struct`),*(struct`))),int,int,int,int,int,int,*((*(struct`))->(int)),int,int))
,	O
&	O
q	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
q	*(char)
)	O
insert_text	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))),*(char),long)->(int)
(	O
in	*(char)
,	O
q	*(char)
,	O
strlen	(*(char))->(long)
(	O
q	*(char)
)	O
)	O
;	O
}	O
if	O
(	O
q	*(char)
||	O
end	*(struct)
!=	O
min_end	int
)	O
free_completions	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))->(void)
(	O
in	*(char)
)	O
;	O
i	array(int)
=	O
query_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
->	O
ret_value	int
;	O
destroy_dlg	(*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*`,*`,*`,*`,*`)),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*`,*`,*`,int,int,int,int,int,int,int,int,int,*`,*`,*`)))))->(void)
(	O
query_dlg	*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))))
)	O
;	O
if	O
(	O
i	array(int)
==	O
B_USER	int
)	O
return	O
1	int
;	O
}	O
}	O
else	O
beep	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
complete	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))))->(void)
(	O
WInput	struct(struct(int,int,int,int,int,int,*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`))),*((*(struct`),enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*(struct`),*(void))->(int)),*(struct(int,*(char),*(int),*(char),int,int,int,int,int,int,int,int,int,*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*(struct`)))),int,int,int,int,int,int,int,int,int,*(char),*(struct(*(void),*(struct(*`,*`,*`)),*(struct(*`,*`,*`)))),int,*(*(char)),int,*(char))
*	O
in	*(char)
)	O
{	O
int	O
engine_flags	int
;	O
if	O
(	O
in	*(char)
->	O
completions	*(*(char))
)	O
engine_flags	int
=	O
DO_QUERY	int
;	O
else	O
{	O
engine_flags	int
=	O
DO_INSERTION	int
;	O
if	O
(	O
show_all_if_ambiguous	int
)	O
engine_flags	int
|=	O
DO_QUERY	int
;	O
}	O
while	O
(	O
complete_engine	(*(struct(struct(int,int,int,int,int,int,*(struct`),*(struct`),*((*`,enum(int,int,int,int,int,int,int,int,int,int),int)->(enum(int,int))),*((*`,*`)->(int)),*(struct`)),int,int,int,int,int,int,int,int,int,*(char),*(struct(*`,*`,*`)),int,*(*(char)),int,*(char))),int)->(int)
(	O
in	*(char)
,	O
engine_flags	int
)	O
)	O
;	O
}	O
