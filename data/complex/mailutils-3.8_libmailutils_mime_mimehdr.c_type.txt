void	O
mu_mime_param_free	(*(struct(*(char),*(char),*(char))))->(void)
(	O
struct	O
mu_mime_param	struct(*(char),*(char),*(char))
*	O
p	*(char)
)	O
{	O
if	O
(	O
p	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
p	*(char)
->	O
lang	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
->	O
cset	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
->	O
value	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
p	*(char)
)	O
;	O
}	O
}	O
static	O
void	O
_mu_mime_param_free_item	(*(void))->(void)
(	O
void	O
*	O
item	*(void)
)	O
{	O
mu_mime_param_free	(*(struct(*(char),*(char),*(char))))->(void)
(	O
item	*(void)
)	O
;	O
}	O
static	O
int	O
_recode_string	(*(char),*(char),*(char),*(*(char)))->(int)
(	O
char	O
*	O
text	struct(long)
,	O
const	O
char	O
*	O
ics	*(char)
,	O
const	O
char	O
*	O
ocs	*(char)
,	O
char	O
*	O
*	O
presult	*(*(char))
)	O
{	O
mu_stream_t	*(struct)
istr	*(struct)
,	O
ostr	*(struct)
,	O
cvt	*(struct)
;	O
mu_off_t	long
size	long
;	O
char	O
*	O
decoded	*(char)
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_static_memory_stream_create	(*(*(struct)),*(void),long)->(int)
(	O
&	O
istr	*(struct)
,	O
text	struct(long)
,	O
strlen	(*(char))->(long)
(	O
text	struct(long)
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_memory_stream_create	(*(*(struct)),int)->(int)
(	O
&	O
ostr	*(struct)
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_decode_filter	(*(*(struct)),*(struct),*(char),*(char),*(char))->(int)
(	O
&	O
cvt	*(struct)
,	O
istr	*(struct)
,	O
NULL	O
,	O
ics	*(char)
,	O
ocs	*(char)
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
istr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_unref	(*(struct))->(void)
(	O
ostr	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_stream_copy	(*(struct),*(struct),long,*(long))->(int)
(	O
ostr	*(struct)
,	O
cvt	*(struct)
,	O
0	int
,	O
&	O
size	long
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
cvt	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_stream_unref	(*(struct))->(void)
(	O
ostr	*(struct)
)	O
;	O
return	O
rc	int
;	O
}	O
decoded	*(char)
=	O
malloc	(long)->(*(void))
(	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
decoded	*(char)
)	O
{	O
mu_stream_unref	(*(struct))->(void)
(	O
ostr	*(struct)
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
ostr	*(struct)
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
rc	int
=	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
ostr	*(struct)
,	O
decoded	*(char)
,	O
size	long
,	O
NULL	O
)	O
;	O
mu_stream_unref	(*(struct))->(void)
(	O
ostr	*(struct)
)	O
;	O
if	O
(	O
rc	int
)	O
free	(*(void))->(void)
(	O
decoded	*(char)
)	O
;	O
else	O
{	O
decoded	*(char)
[	O
size	long
]	O
=	O
0	int
;	O
*	O
presult	*(*(char))
=	O
decoded	*(char)
;	O
}	O
return	O
rc	int
;	O
}	O
struct	O
param_continuation	struct(*(char),long,*(struct),int,*(char),*(char))
{	O
char	O
*	O
param_name	*(char)
;	O
size_t	long
param_length	long
;	O
mu_stream_t	*(struct)
param_value	*(struct)
;	O
int	O
param_cind	int
;	O
const	O
char	O
*	O
param_lang	*(char)
;	O
const	O
char	O
*	O
param_cset	*(char)
;	O
}	O
;	O
static	O
void	O
free_param_continuation	(*(struct(*(char),long,*(struct),int,*(char),*(char))))->(void)
(	O
struct	O
param_continuation	struct(*(char),long,*(struct),int,*(char),*(char))
*	O
p	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
p	*(char)
->	O
param_name	*(char)
)	O
;	O
mu_stream_destroy	(*(*(struct)))->(void)
(	O
&	O
p	*(char)
->	O
param_value	*(struct)
)	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
p	*(char)
,	O
0	int
,	O
sizeof	O
(	O
*	O
p	*(char)
)	O
)	O
;	O
}	O
static	O
int	O
flush_param	(*(struct(*(char),long,*(struct),int,*(char),*(char))),*(struct),int,*(char))->(int)
(	O
struct	O
param_continuation	struct(*(char),long,*(struct),int,*(char),*(char))
*	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
,	O
mu_assoc_t	*(struct)
assoc	*(struct)
,	O
int	O
subset	int
,	O
const	O
char	O
*	O
outcharset	*(char)
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_mime_param	struct(*(char),*(char),*(char))
*	O
param	*(char)
,	O
*	O
*	O
param_slot	*(*(struct(*(char),*(char),*(char))))
;	O
mu_off_t	long
size	long
;	O
if	O
(	O
subset	int
)	O
{	O
rc	int
=	O
mu_assoc_lookup_ref	(*(struct),*(char),*(void))->(int)
(	O
assoc	*(struct)
,	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_name	*(char)
,	O
&	O
param_slot	*(*(struct(*(char),*(char),*(char))))
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
0	int
;	O
}	O
param	*(char)
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
*	O
param	*(char)
)	O
;	O
if	O
(	O
!	O
param	*(char)
)	O
return	O
errno	O
;	O
if	O
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_lang	*(char)
)	O
{	O
param	*(char)
->	O
lang	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_lang	*(char)
)	O
;	O
if	O
(	O
!	O
param	*(char)
->	O
lang	*(char)
)	O
{	O
mu_mime_param_free	(*(struct(*(char),*(char),*(char))))->(void)
(	O
param	*(char)
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
}	O
else	O
param	*(char)
->	O
lang	*(char)
=	O
NULL	O
;	O
if	O
(	O
outcharset	*(char)
||	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_cset	*(char)
)	O
{	O
param	*(char)
->	O
cset	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
outcharset	*(char)
?	O
outcharset	*(char)
:	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_cset	*(char)
)	O
;	O
if	O
(	O
!	O
param	*(char)
->	O
cset	*(char)
)	O
{	O
mu_mime_param_free	(*(struct(*(char),*(char),*(char))))->(void)
(	O
param	*(char)
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
}	O
rc	int
=	O
mu_stream_size	(*(struct),*(long))->(int)
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_value	*(struct)
,	O
&	O
size	long
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
param	*(char)
->	O
value	*(char)
=	O
malloc	(long)->(*(void))
(	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
param	*(char)
->	O
value	*(char)
)	O
{	O
mu_mime_param_free	(*(struct(*(char),*(char),*(char))))->(void)
(	O
param	*(char)
)	O
;	O
rc	int
=	O
ENOMEM	int
;	O
}	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
rc	int
=	O
mu_stream_seek	(*(struct),long,int,*(long))->(int)
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_value	*(struct)
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
rc	int
=	O
mu_stream_read	(*(struct),*(void),long,*(long))->(int)
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_value	*(struct)
,	O
param	*(char)
->	O
value	*(char)
,	O
size	long
,	O
NULL	O
)	O
;	O
param	*(char)
->	O
value	*(char)
[	O
size	long
]	O
=	O
0	int
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
mu_mime_param_free	(*(struct(*(char),*(char),*(char))))->(void)
(	O
param	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_cset	*(char)
&&	O
outcharset	*(char)
&&	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_cset	*(char)
,	O
outcharset	*(char)
)	O
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
rc	int
=	O
_recode_string	(*(char),*(char),*(char),*(*(char)))->(int)
(	O
param	*(char)
->	O
value	*(char)
,	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_cset	*(char)
,	O
outcharset	*(char)
,	O
&	O
tmp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
param	*(char)
->	O
value	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_mime_param_free	(*(struct(*(char),*(char),*(char))))->(void)
(	O
param	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
param	*(char)
->	O
value	*(char)
=	O
tmp	*(char)
;	O
}	O
if	O
(	O
subset	int
)	O
{	O
*	O
param_slot	*(*(struct(*(char),*(char),*(char))))
=	O
param	*(char)
;	O
}	O
else	O
{	O
rc	int
=	O
mu_assoc_install	(*(struct),*(char),*(void))->(int)
(	O
assoc	*(struct)
,	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
->	O
param_name	*(char)
,	O
param	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
mu_mime_param_free	(*(struct(*(char),*(char),*(char))))->(void)
(	O
param	*(char)
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_mime_param_assoc_create	(*(*(struct)))->(int)
(	O
mu_assoc_t	*(struct)
*	O
paramtab	*(*(struct))
)	O
{	O
mu_assoc_t	*(struct)
assoc	*(struct)
;	O
int	O
rc	int
=	O
mu_assoc_create	(*(*(struct)),int)->(int)
(	O
&	O
assoc	*(struct)
,	O
MU_ASSOC_ICASE	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
mu_assoc_set_destroy_item	(*(struct),*((*(void))->(void)))->(int)
(	O
assoc	*(struct)
,	O
_mu_mime_param_free_item	(*(void))->(void)
)	O
;	O
*	O
paramtab	*(*(struct))
=	O
assoc	*(struct)
;	O
return	O
rc	int
;	O
}	O
int	O
mu_mime_param_assoc_add	(*(struct),*(char))->(int)
(	O
mu_assoc_t	*(struct)
assoc	*(struct)
,	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
return	O
mu_assoc_install	(*(struct),*(char),*(void))->(int)
(	O
assoc	*(struct)
,	O
name	*(char)
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
_mime_header_parse	(*(char),*(*(char)),*(struct),*(char),int)->(int)
(	O
const	O
char	O
*	O
text	struct(long)
,	O
char	O
*	O
*	O
pvalue	*(*(char))
,	O
mu_assoc_t	*(struct)
assoc	*(struct)
,	O
const	O
char	O
*	O
outcharset	*(char)
,	O
int	O
subset	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
struct	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
;	O
struct	O
param_continuation	struct(*(char),long,*(struct),int,*(char),*(char))
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
;	O
size_t	long
i	long
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_delim	*(char)
=	O
" \t\r\n;"	*(char)
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_escape	array(*(char))
[	O
0	int
]	O
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_escape	array(*(char))
[	O
1	int
]	O
=	O
"\\\\\"\""	*(char)
;	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_options	int
=	O
0	int
;	O
MU_WRDSO_ESC_SET	O
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
0	int
,	O
MU_WRDSO_BSKEEP	O
)	O
;	O
MU_WRDSO_ESC_SET	O
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
1	int
,	O
MU_WRDSO_BSKEEP	O
)	O
;	O
if	O
(	O
mu_wordsplit	struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct(long,*(*`),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*`),*(*`),long,long,*(*`),long,*(*`),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct`),*(struct`),array(char),int)))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*(char)),*(char),long,*(void))->(int)),*(void),*((*(*(char)),*(char),long,*(*(char)),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)
(	O
text	struct(long)
,	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
,	O
MU_WRDSF_DELIM	O
|	O
MU_WRDSF_ESCAPE	O
|	O
MU_WRDSF_NOVAR	O
|	O
MU_WRDSF_NOCMD	O
|	O
MU_WRDSF_DQUOTE	O
|	O
MU_WRDSF_SQUEEZE_DELIMS	O
|	O
MU_WRDSF_RETURN_DELIMS	O
|	O
MU_WRDSF_WS	O
|	O
MU_WRDSF_OPTIONS	O
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MIME	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
_	O
(	O
"wordsplit: %s"	*(char)
)	O
,	O
mu_wordsplit_strerror	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(*(char))
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
)	O
)	O
;	O
return	O
MU_ERR_PARSE	O
;	O
}	O
if	O
(	O
!	O
assoc	*(struct)
)	O
{	O
if	O
(	O
!	O
pvalue	*(*(char))
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
*	O
pvalue	*(*(char))
=	O
strdup	(*(char))->(*(char))
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
)	O
;	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
if	O
(	O
!	O
*	O
pvalue	*(*(char))
)	O
return	O
ENOMEM	int
;	O
return	O
0	int
;	O
}	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
,	O
0	int
,	O
sizeof	O
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
)	O
)	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
{	O
size_t	long
klen	long
;	O
char	O
*	O
key	*(*(void))
;	O
char	O
*	O
val	array(int)
;	O
const	O
char	O
*	O
lang	*(char)
=	O
NULL	O
;	O
const	O
char	O
*	O
cset	*(char)
=	O
NULL	O
;	O
char	O
*	O
langp	*(char)
=	O
NULL	O
;	O
char	O
*	O
csetp	*(char)
=	O
NULL	O
;	O
char	O
*	O
p	*(char)
;	O
char	O
*	O
decoded	*(char)
;	O
int	O
flags	int
=	O
0	int
;	O
struct	O
mu_mime_param	struct(*(char),*(char),*(char))
*	O
param	*(char)
;	O
key	*(*(void))
=	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
i	long
]	O
;	O
if	O
(	O
key	*(*(void))
[	O
0	int
]	O
==	O
';'	O
)	O
continue	O
;	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
key	*(*(void))
,	O
'='	O
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
val	array(int)
=	O
""	*(char)
;	O
else	O
{	O
*	O
p	*(char)
++	O
=	O
0	int
;	O
val	array(int)
=	O
p	*(char)
;	O
}	O
klen	long
=	O
strlen	(*(char))->(long)
(	O
key	*(*(void))
)	O
;	O
if	O
(	O
klen	long
==	O
0	int
)	O
continue	O
;	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
key	*(*(void))
,	O
'*'	O
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
klen	long
=	O
p	*(char)
-	O
key	*(*(void))
;	O
if	O
(	O
p	*(char)
[	O
1	int
]	O
)	O
{	O
if	O
(	O
mu_isdigit	O
(	O
p	*(char)
[	O
1	int
]	O
)	O
)	O
{	O
char	O
*	O
q	*(char)
;	O
unsigned	O
long	O
n	long
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
p	*(char)
+	O
1	int
,	O
&	O
q	*(char)
,	O
10	int
)	O
;	O
if	O
(	O
*	O
q	*(char)
&&	O
*	O
q	*(char)
!=	O
'*'	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MIME	int
,	O
MU_DEBUG_TRACE0	int
,	O
(	O
_	O
(	O
"malformed parameter name %s: skipping"	*(char)
)	O
,	O
key	*(*(void))
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
n	long
!=	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_cind	int
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MIME	int
,	O
MU_DEBUG_TRACE0	int
,	O
(	O
_	O
(	O
"continuation index out of sequence in %s: "	*(char)
"skipping"	*(char)
)	O
,	O
key	*(*(void))
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_name	*(char)
=	O
malloc	(long)->(*(void))
(	O
klen	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_name	*(char)
)	O
{	O
rc	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_length	long
=	O
klen	long
;	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_name	*(char)
,	O
key	*(*(void))
,	O
klen	long
)	O
;	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_name	*(char)
[	O
klen	long
]	O
=	O
0	int
;	O
rc	int
=	O
mu_memory_stream_create	(*(*(struct)),int)->(int)
(	O
&	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_value	*(struct)
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_length	long
!=	O
klen	long
||	O
memcmp	(*(void),*(void),long)->(int)
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_name	*(char)
,	O
key	*(*(void))
,	O
klen	long
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MIME	int
,	O
MU_DEBUG_TRACE0	int
,	O
(	O
_	O
(	O
"continuation name mismatch: %s: "	*(char)
"skipping"	*(char)
)	O
,	O
key	*(*(void))
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
q	*(char)
==	O
'*'	O
)	O
flags	int
|=	O
MU_MIMEHDR_CSINFO	int
;	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_cind	int
++	O
;	O
flags	int
|=	O
MU_MIMEHDR_MULTILINE	int
;	O
}	O
}	O
else	O
{	O
flags	int
|=	O
MU_MIMEHDR_CSINFO	int
;	O
*	O
p	*(char)
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_name	*(char)
)	O
{	O
rc	int
=	O
flush_param	(*(struct(*(char),long,*(struct),int,*(char),*(char))),*(struct),int,*(char))->(int)
(	O
&	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
,	O
assoc	*(struct)
,	O
subset	int
,	O
outcharset	*(char)
)	O
;	O
free_param_continuation	(*(struct(*(char),long,*(struct),int,*(char),*(char))))->(void)
(	O
&	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
}	O
if	O
(	O
flags	int
&	O
MU_MIMEHDR_CSINFO	int
)	O
{	O
p	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
val	array(int)
,	O
'\''	O
)	O
;	O
if	O
(	O
p	*(char)
)	O
{	O
char	O
*	O
q	*(char)
=	O
strchr	(*(char),int)->(*(char))
(	O
p	*(char)
+	O
1	int
,	O
'\''	O
)	O
;	O
if	O
(	O
q	*(char)
)	O
{	O
cset	*(char)
=	O
val	array(int)
;	O
*	O
p	*(char)
++	O
=	O
0	int
;	O
lang	*(char)
=	O
p	*(char)
;	O
*	O
q	*(char)
++	O
=	O
0	int
;	O
val	array(int)
=	O
q	*(char)
;	O
}	O
}	O
if	O
(	O
(	O
flags	int
&	O
MU_MIMEHDR_MULTILINE	int
)	O
&&	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_cind	int
==	O
1	int
)	O
{	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_lang	*(char)
=	O
lang	*(char)
;	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_cset	*(char)
=	O
cset	*(char)
;	O
}	O
}	O
if	O
(	O
flags	int
&	O
MU_MIMEHDR_CSINFO	int
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
rc	int
=	O
mu_str_url_decode	(*(*(char)),*(char))->(int)
(	O
&	O
tmp	*(char)
,	O
val	array(int)
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
MU_MIMEHDR_MULTILINE	int
)	O
)	O
{	O
if	O
(	O
!	O
outcharset	*(char)
||	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
cset	*(char)
,	O
outcharset	*(char)
)	O
==	O
0	int
)	O
decoded	*(char)
=	O
tmp	*(char)
;	O
else	O
{	O
rc	int
=	O
_recode_string	(*(char),*(char),*(char),*(*(char)))->(int)
(	O
tmp	*(char)
,	O
cset	*(char)
,	O
outcharset	*(char)
,	O
&	O
decoded	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
break	O
;	O
}	O
else	O
decoded	*(char)
=	O
tmp	*(char)
;	O
}	O
else	O
{	O
struct	O
mu_mime_param	struct(*(char),*(char),*(char))
*	O
param	*(char)
;	O
rc	int
=	O
mu_rfc2047_decode_param	(*(char),*(char),*(*(struct(*(char),*(char),*(char)))))->(int)
(	O
outcharset	*(char)
,	O
val	array(int)
,	O
&	O
param	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
cset	*(char)
=	O
csetp	*(char)
=	O
param	*(char)
->	O
cset	*(char)
;	O
lang	*(char)
=	O
langp	*(char)
=	O
param	*(char)
->	O
lang	*(char)
;	O
decoded	*(char)
=	O
param	*(char)
->	O
value	*(char)
;	O
free	(*(void))->(void)
(	O
param	*(char)
)	O
;	O
}	O
val	array(int)
=	O
decoded	*(char)
;	O
if	O
(	O
flags	int
&	O
MU_MIMEHDR_MULTILINE	int
)	O
{	O
rc	int
=	O
mu_stream_write	(*(struct),*(void),long,*(long))->(int)
(	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_value	*(struct)
,	O
val	array(int)
,	O
strlen	(*(char))->(long)
(	O
val	array(int)
)	O
,	O
NULL	O
)	O
;	O
free	(*(void))->(void)
(	O
decoded	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
csetp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
langp	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
continue	O
;	O
}	O
param	*(char)
=	O
calloc	(long,long)->(*(void))
(	O
1	int
,	O
sizeof	O
(	O
*	O
param	*(char)
)	O
)	O
;	O
if	O
(	O
!	O
param	*(char)
)	O
rc	int
=	O
ENOMEM	int
;	O
else	O
{	O
if	O
(	O
lang	*(char)
)	O
{	O
param	*(char)
->	O
lang	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
lang	*(char)
)	O
;	O
if	O
(	O
!	O
param	*(char)
->	O
lang	*(char)
)	O
rc	int
=	O
ENOMEM	int
;	O
}	O
if	O
(	O
rc	int
==	O
0	int
&&	O
cset	*(char)
)	O
{	O
param	*(char)
->	O
cset	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
cset	*(char)
)	O
;	O
if	O
(	O
!	O
param	*(char)
->	O
cset	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
param	*(char)
->	O
lang	*(char)
)	O
;	O
rc	int
=	O
ENOMEM	int
;	O
}	O
}	O
free	(*(void))->(void)
(	O
csetp	*(char)
)	O
;	O
free	(*(void))->(void)
(	O
langp	*(char)
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
free	(*(void))->(void)
(	O
decoded	*(char)
)	O
;	O
break	O
;	O
}	O
param	*(char)
->	O
value	*(char)
=	O
strdup	(*(char))->(*(char))
(	O
val	array(int)
)	O
;	O
free	(*(void))->(void)
(	O
decoded	*(char)
)	O
;	O
if	O
(	O
!	O
param	*(char)
->	O
value	*(char)
)	O
{	O
mu_mime_param_free	(*(struct(*(char),*(char),*(char))))->(void)
(	O
param	*(char)
)	O
;	O
rc	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
if	O
(	O
subset	int
)	O
{	O
struct	O
mu_mime_param	struct(*(char),*(char),*(char))
*	O
*	O
p	*(char)
;	O
if	O
(	O
mu_assoc_lookup_ref	(*(struct),*(char),*(void))->(int)
(	O
assoc	*(struct)
,	O
key	*(*(void))
,	O
&	O
p	*(char)
)	O
==	O
0	int
)	O
*	O
p	*(char)
=	O
param	*(char)
;	O
else	O
mu_mime_param_free	(*(struct(*(char),*(char),*(char))))->(void)
(	O
param	*(char)
)	O
;	O
}	O
else	O
{	O
rc	int
=	O
mu_assoc_install	(*(struct),*(char),*(void))->(int)
(	O
assoc	*(struct)
,	O
key	*(*(void))
,	O
param	*(char)
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_mime_param_free	(*(struct(*(char),*(char),*(char))))->(void)
(	O
param	*(char)
)	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
rc	int
==	O
0	int
&&	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
.	O
param_name	*(char)
)	O
rc	int
=	O
flush_param	(*(struct(*(char),long,*(struct),int,*(char),*(char))),*(struct),int,*(char))->(int)
(	O
&	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
,	O
assoc	*(struct)
,	O
subset	int
,	O
outcharset	*(char)
)	O
;	O
free_param_continuation	(*(struct(*(char),long,*(struct),int,*(char),*(char))))->(void)
(	O
&	O
cont	*(struct(*(char),long,*(struct),int,*(char),*(char)))
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
pvalue	*(*(char))
)	O
{	O
*	O
pvalue	*(*(char))
=	O
strdup	(*(char))->(*(char))
(	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
.	O
ws_wordv	*(*(char))
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
*	O
pvalue	*(*(char))
)	O
rc	int
=	O
ENOMEM	int
;	O
}	O
}	O
mu_wordsplit_free	(*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*`)->(void)),*((*`)->(void)),*((*`)->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*`,*`,long,*`)->(int)),*(void),*((*`,*`,long,*`,*`)->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int)))->(void)
(	O
&	O
ws	*(struct(long,*(*(char)),long,long,int,int,long,long,*(char),*(char),array(*(char)),*((*(struct`))->(void)),*((*(char))->(void)),*((*(char))->(void)),*(*(char)),*(*(char)),long,long,*(*(char)),long,*(*(char)),long,long,*((*(*`),*(char),long,*(void))->(int)),*(void),*((*(*`),*(char),long,*(*`),*(void))->(int)),*(char),long,long,int,*(char),*(char),*(struct),*(struct),array(char),int))
)	O
;	O
if	O
(	O
subset	int
)	O
{	O
mu_iterator_t	*(struct)
itr	*(struct)
;	O
rc	int
=	O
mu_assoc_get_iterator	(*(struct),*(*(struct)))->(int)
(	O
assoc	*(struct)
,	O
&	O
itr	*(struct)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
for	O
(	O
mu_iterator_first	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
!	O
mu_iterator_is_done	(*(struct))->(int)
(	O
itr	*(struct)
)	O
;	O
mu_iterator_next	(*(struct))->(int)
(	O
itr	*(struct)
)	O
)	O
{	O
const	O
char	O
*	O
name	*(char)
;	O
struct	O
mu_mime_param	struct(*(char),*(char),*(char))
*	O
p	*(char)
;	O
mu_iterator_current_kv	(*(struct),*(*(void)),*(*(void)))->(int)
(	O
itr	*(struct)
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
name	*(char)
,	O
(	O
void	O
*	O
*	O
)	O
&	O
p	*(char)
)	O
;	O
if	O
(	O
!	O
p	*(char)
)	O
mu_iterator_ctl	(*(struct),enum(int,int,int,int,int,int,int,int,int,int),*(void))->(int)
(	O
itr	*(struct)
,	O
mu_itrctl_delete	int
,	O
NULL	O
)	O
;	O
}	O
mu_iterator_destroy	(*(*(struct)))->(void)
(	O
&	O
itr	*(struct)
)	O
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_mime_header_parse_subset	(*(char),*(char),*(*(char)),*(struct))->(int)
(	O
const	O
char	O
*	O
text	struct(long)
,	O
const	O
char	O
*	O
cset	*(char)
,	O
char	O
*	O
*	O
pvalue	*(*(char))
,	O
mu_assoc_t	*(struct)
assoc	*(struct)
)	O
{	O
return	O
_mime_header_parse	(*(char),*(*(char)),*(struct),*(char),int)->(int)
(	O
text	struct(long)
,	O
pvalue	*(*(char))
,	O
assoc	*(struct)
,	O
cset	*(char)
,	O
1	int
)	O
;	O
}	O
int	O
mu_mime_header_parse	(*(char),*(char),*(*(char)),*(*(struct)))->(int)
(	O
const	O
char	O
*	O
text	struct(long)
,	O
char	O
const	O
*	O
cset	*(char)
,	O
char	O
*	O
*	O
pvalue	*(*(char))
,	O
mu_assoc_t	*(struct)
*	O
passoc	*(*(struct))
)	O
{	O
int	O
rc	int
;	O
mu_assoc_t	*(struct)
assoc	*(struct)
;	O
rc	int
=	O
mu_mime_param_assoc_create	(*(*(struct)))->(int)
(	O
&	O
assoc	*(struct)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
rc	int
=	O
_mime_header_parse	(*(char),*(*(char)),*(struct),*(char),int)->(int)
(	O
text	struct(long)
,	O
pvalue	*(*(char))
,	O
assoc	*(struct)
,	O
cset	*(char)
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
||	O
!	O
passoc	*(*(struct))
)	O
mu_assoc_destroy	(*(*(struct)))->(void)
(	O
&	O
assoc	*(struct)
)	O
;	O
else	O
*	O
passoc	*(*(struct))
=	O
assoc	*(struct)
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_mimehdr_get_disp	(*(char),*(char),long,*(long))->(int)
(	O
const	O
char	O
*	O
text	struct(long)
,	O
char	O
*	O
buf	*(struct)
,	O
size_t	long
bufsz	long
,	O
size_t	long
*	O
retsz	*(long)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
value	*(char)
;	O
rc	int
=	O
mu_mime_header_parse	(*(char),*(char),*(*(char)),*(*(struct)))->(int)
(	O
text	struct(long)
,	O
NULL	O
,	O
&	O
value	*(char)
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
size_t	long
size	long
=	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
;	O
if	O
(	O
size	long
>	O
bufsz	long
)	O
size	long
=	O
bufsz	long
;	O
if	O
(	O
buf	*(struct)
)	O
size	long
=	O
mu_cpystr	(*(char),*(char),long)->(long)
(	O
buf	*(struct)
,	O
value	*(char)
,	O
size	long
)	O
;	O
if	O
(	O
retsz	*(long)
)	O
*	O
retsz	*(long)
=	O
size	long
;	O
}	O
free	(*(void))->(void)
(	O
value	*(char)
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_mimehdr_aget_disp	(*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
text	struct(long)
,	O
char	O
*	O
*	O
pvalue	*(*(char))
)	O
{	O
return	O
mu_mime_header_parse	(*(char),*(char),*(*(char)),*(*(struct)))->(int)
(	O
text	struct(long)
,	O
NULL	O
,	O
pvalue	*(*(char))
,	O
NULL	O
)	O
;	O
}	O
int	O
mu_mimehdr_get_param	(*(char),*(char),*(char),long,*(long))->(int)
(	O
const	O
char	O
*	O
str	*(char)
,	O
const	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
buf	*(struct)
,	O
size_t	long
bufsz	long
,	O
size_t	long
*	O
retsz	*(long)
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
value	*(char)
;	O
rc	int
=	O
mu_mimehdr_aget_param	(*(char),*(char),*(*(char)))->(int)
(	O
str	*(char)
,	O
name	*(char)
,	O
&	O
value	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
size_t	long
size	long
=	O
strlen	(*(char))->(long)
(	O
value	*(char)
)	O
;	O
if	O
(	O
size	long
>	O
bufsz	long
)	O
size	long
=	O
bufsz	long
;	O
if	O
(	O
buf	*(struct)
)	O
size	long
=	O
mu_cpystr	(*(char),*(char),long)->(long)
(	O
buf	*(struct)
,	O
value	*(char)
,	O
size	long
)	O
;	O
if	O
(	O
retsz	*(long)
)	O
*	O
retsz	*(long)
=	O
size	long
;	O
}	O
free	(*(void))->(void)
(	O
value	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_mimehdr_aget_param	(*(char),*(char),*(*(char)))->(int)
(	O
const	O
char	O
*	O
str	*(char)
,	O
const	O
char	O
*	O
name	*(char)
,	O
char	O
*	O
*	O
pval	*(*(char))
)	O
{	O
return	O
mu_mimehdr_aget_decoded_param	(*(char),*(char),*(char),*(*(char)),*(*(char)))->(int)
(	O
str	*(char)
,	O
name	*(char)
,	O
NULL	O
,	O
pval	*(*(char))
,	O
NULL	O
)	O
;	O
}	O
int	O
mu_mimehdr_aget_decoded_param	(*(char),*(char),*(char),*(*(char)),*(*(char)))->(int)
(	O
const	O
char	O
*	O
str	*(char)
,	O
const	O
char	O
*	O
name	*(char)
,	O
const	O
char	O
*	O
charset	*(char)
,	O
char	O
*	O
*	O
pval	*(*(char))
,	O
char	O
*	O
*	O
plang	*(*(char))
)	O
{	O
mu_assoc_t	*(struct)
assoc	*(struct)
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_mime_param_assoc_create	(*(*(struct)))->(int)
(	O
&	O
assoc	*(struct)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
rc	int
=	O
mu_mime_param_assoc_add	(*(struct),*(char))->(int)
(	O
assoc	*(struct)
,	O
name	*(char)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
rc	int
=	O
mu_mime_header_parse_subset	(*(char),*(char),*(*(char)),*(struct))->(int)
(	O
str	*(char)
,	O
charset	*(char)
,	O
NULL	O
,	O
assoc	*(struct)
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
struct	O
mu_mime_param	struct(*(char),*(char),*(char))
*	O
param	*(char)
=	O
mu_assoc_get	(*(struct),*(char))->(*(void))
(	O
assoc	*(struct)
,	O
name	*(char)
)	O
;	O
if	O
(	O
!	O
param	*(char)
)	O
rc	int
=	O
MU_ERR_NOENT	O
;	O
else	O
{	O
*	O
pval	*(*(char))
=	O
param	*(char)
->	O
value	*(char)
;	O
if	O
(	O
plang	*(*(char))
)	O
{	O
*	O
plang	*(*(char))
=	O
param	*(char)
->	O
lang	*(char)
;	O
param	*(char)
->	O
lang	*(char)
=	O
NULL	O
;	O
}	O
param	*(char)
->	O
value	*(char)
=	O
NULL	O
;	O
}	O
}	O
}	O
mu_assoc_destroy	(*(*(struct)))->(void)
(	O
&	O
assoc	*(struct)
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
_get_attachment_name	(*(struct),*(char),*(*(char)),*(long),*(*(char)))->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
const	O
char	O
*	O
charset	*(char)
,	O
char	O
*	O
*	O
pbuf	*(*(char))
,	O
size_t	long
*	O
psz	*(long)
,	O
char	O
*	O
*	O
plang	*(*(char))
)	O
{	O
int	O
ret	*(*(char))
=	O
EINVAL	int
;	O
mu_header_t	*(struct)
hdr	*(struct)
;	O
char	O
*	O
value	*(char)
=	O
NULL	O
;	O
mu_assoc_t	*(struct)
assoc	*(struct)
;	O
if	O
(	O
!	O
msg	*(struct)
)	O
return	O
ret	*(*(char))
;	O
if	O
(	O
(	O
ret	*(*(char))
=	O
mu_message_get_header	(*(struct),*(*(struct)))->(int)
(	O
msg	*(struct)
,	O
&	O
hdr	*(struct)
)	O
)	O
!=	O
0	int
)	O
return	O
ret	*(*(char))
;	O
ret	*(*(char))
=	O
mu_header_aget_value_unfold	O
(	O
hdr	*(struct)
,	O
MU_HEADER_CONTENT_DISPOSITION	*(char)
,	O
&	O
value	*(char)
)	O
;	O
if	O
(	O
ret	*(*(char))
!=	O
0	int
&&	O
ret	*(*(char))
!=	O
MU_ERR_NOENT	O
)	O
return	O
ret	*(*(char))
;	O
if	O
(	O
ret	*(*(char))
==	O
0	int
&&	O
value	*(char)
!=	O
NULL	O
)	O
{	O
ret	*(*(char))
=	O
mu_mime_param_assoc_create	(*(*(struct)))->(int)
(	O
&	O
assoc	*(struct)
)	O
;	O
if	O
(	O
ret	*(*(char))
)	O
return	O
ret	*(*(char))
;	O
ret	*(*(char))
=	O
mu_mime_param_assoc_add	(*(struct),*(char))->(int)
(	O
assoc	*(struct)
,	O
"filename"	*(char)
)	O
;	O
if	O
(	O
ret	*(*(char))
==	O
0	int
)	O
{	O
char	O
*	O
disp	*(char)
;	O
ret	*(*(char))
=	O
mu_mime_header_parse_subset	(*(char),*(char),*(*(char)),*(struct))->(int)
(	O
value	*(char)
,	O
charset	*(char)
,	O
&	O
disp	*(char)
,	O
assoc	*(struct)
)	O
;	O
if	O
(	O
ret	*(*(char))
==	O
0	int
)	O
{	O
struct	O
mu_mime_param	struct(*(char),*(char),*(char))
*	O
param	*(char)
;	O
if	O
(	O
mu_c_strcasecmp	(*(char),*(char))->(int)
(	O
disp	*(char)
,	O
"attachment"	*(char)
)	O
==	O
0	int
&&	O
(	O
param	*(char)
=	O
mu_assoc_get	(*(struct),*(char))->(*(void))
(	O
assoc	*(struct)
,	O
"filename"	*(char)
)	O
)	O
)	O
{	O
*	O
pbuf	*(*(char))
=	O
param	*(char)
->	O
value	*(char)
;	O
if	O
(	O
psz	*(long)
)	O
*	O
psz	*(long)
=	O
strlen	(*(char))->(long)
(	O
*	O
pbuf	*(*(char))
)	O
;	O
param	*(char)
->	O
value	*(char)
=	O
NULL	O
;	O
if	O
(	O
plang	*(*(char))
)	O
{	O
*	O
plang	*(*(char))
=	O
param	*(char)
->	O
lang	*(char)
;	O
param	*(char)
->	O
lang	*(char)
=	O
NULL	O
;	O
}	O
}	O
else	O
ret	*(*(char))
=	O
MU_ERR_NOENT	O
;	O
free	(*(void))->(void)
(	O
disp	*(char)
)	O
;	O
mu_assoc_destroy	(*(*(struct)))->(void)
(	O
&	O
assoc	*(struct)
)	O
;	O
}	O
}	O
}	O
free	(*(void))->(void)
(	O
value	*(char)
)	O
;	O
if	O
(	O
ret	*(*(char))
==	O
0	int
)	O
return	O
ret	*(*(char))
;	O
ret	*(*(char))
=	O
mu_header_aget_value_unfold	O
(	O
hdr	*(struct)
,	O
MU_HEADER_CONTENT_TYPE	*(char)
,	O
&	O
value	*(char)
)	O
;	O
if	O
(	O
ret	*(*(char))
==	O
0	int
)	O
{	O
ret	*(*(char))
=	O
mu_mime_param_assoc_create	(*(*(struct)))->(int)
(	O
&	O
assoc	*(struct)
)	O
;	O
if	O
(	O
ret	*(*(char))
)	O
return	O
ret	*(*(char))
;	O
ret	*(*(char))
=	O
mu_mime_param_assoc_add	(*(struct),*(char))->(int)
(	O
assoc	*(struct)
,	O
"name"	*(char)
)	O
;	O
if	O
(	O
ret	*(*(char))
==	O
0	int
)	O
{	O
ret	*(*(char))
=	O
mu_mime_header_parse_subset	(*(char),*(char),*(*(char)),*(struct))->(int)
(	O
value	*(char)
,	O
charset	*(char)
,	O
NULL	O
,	O
assoc	*(struct)
)	O
;	O
if	O
(	O
ret	*(*(char))
==	O
0	int
)	O
{	O
struct	O
mu_mime_param	struct(*(char),*(char),*(char))
*	O
param	*(char)
;	O
if	O
(	O
(	O
param	*(char)
=	O
mu_assoc_get	(*(struct),*(char))->(*(void))
(	O
assoc	*(struct)
,	O
"name"	*(char)
)	O
)	O
)	O
{	O
*	O
pbuf	*(*(char))
=	O
param	*(char)
->	O
value	*(char)
;	O
if	O
(	O
psz	*(long)
)	O
*	O
psz	*(long)
=	O
strlen	(*(char))->(long)
(	O
*	O
pbuf	*(*(char))
)	O
;	O
param	*(char)
->	O
value	*(char)
=	O
NULL	O
;	O
if	O
(	O
plang	*(*(char))
)	O
{	O
*	O
plang	*(*(char))
=	O
param	*(char)
->	O
lang	*(char)
;	O
param	*(char)
->	O
lang	*(char)
=	O
NULL	O
;	O
}	O
}	O
else	O
ret	*(*(char))
=	O
MU_ERR_NOENT	O
;	O
}	O
}	O
free	(*(void))->(void)
(	O
value	*(char)
)	O
;	O
}	O
return	O
ret	*(*(char))
;	O
}	O
int	O
mu_message_aget_attachment_name	(*(struct),*(*(char)))->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
char	O
*	O
*	O
name	*(char)
)	O
{	O
if	O
(	O
name	*(char)
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
return	O
_get_attachment_name	(*(struct),*(char),*(*(char)),*(long),*(*(char)))->(int)
(	O
msg	*(struct)
,	O
NULL	O
,	O
name	*(char)
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
int	O
mu_message_aget_decoded_attachment_name	(*(struct),*(char),*(*(char)),*(*(char)))->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
const	O
char	O
*	O
charset	*(char)
,	O
char	O
*	O
*	O
pval	*(*(char))
,	O
char	O
*	O
*	O
plang	*(*(char))
)	O
{	O
if	O
(	O
pval	*(*(char))
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
return	O
_get_attachment_name	(*(struct),*(char),*(*(char)),*(long),*(*(char)))->(int)
(	O
msg	*(struct)
,	O
charset	*(char)
,	O
pval	*(*(char))
,	O
NULL	O
,	O
plang	*(*(char))
)	O
;	O
}	O
int	O
mu_message_get_attachment_name	(*(struct),*(char),long,*(long))->(int)
(	O
mu_message_t	*(struct)
msg	*(struct)
,	O
char	O
*	O
buf	*(struct)
,	O
size_t	long
bufsz	long
,	O
size_t	long
*	O
sz	*(long)
)	O
{	O
char	O
*	O
tmp	*(char)
;	O
size_t	long
size	long
;	O
int	O
rc	int
=	O
_get_attachment_name	(*(struct),*(char),*(*(char)),*(long),*(*(char)))->(int)
(	O
msg	*(struct)
,	O
NULL	O
,	O
&	O
tmp	*(char)
,	O
&	O
size	long
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
size	long
>	O
bufsz	long
)	O
size	long
=	O
bufsz	long
;	O
if	O
(	O
buf	*(struct)
)	O
size	long
=	O
mu_cpystr	(*(char),*(char),long)->(long)
(	O
buf	*(struct)
,	O
tmp	*(char)
,	O
size	long
)	O
;	O
if	O
(	O
sz	*(long)
)	O
*	O
sz	*(long)
=	O
size	long
;	O
}	O
free	(*(void))->(void)
(	O
tmp	*(char)
)	O
;	O
return	O
rc	int
;	O
}	O
