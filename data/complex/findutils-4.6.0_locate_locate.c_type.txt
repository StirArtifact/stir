static	O
unsigned	O
int	O
warn_number_units	int
=	O
8	int
;	O
static	O
const	O
char	O
warn_name_units	array(char)
[	O
]	O
=	O
N_	O
(	O
"days"	*(char)
)	O
;	O
enum	O
visit_result	enum(int,int,int,int)
{	O
VISIT_CONTINUE	int
=	O
1	int
,	O
VISIT_ACCEPTED	int
=	O
2	int
,	O
VISIT_REJECTED	int
=	O
4	int
,	O
VISIT_ABORT	int
=	O
8	int
}	O
;	O
enum	O
ExistenceCheckType	enum(int,int,int)
{	O
ACCEPT_EITHER	int
,	O
ACCEPT_EXISTING	int
,	O
ACCEPT_NON_EXISTING	int
}	O
;	O
enum	O
ExistenceCheckType	enum(int,int,int)
check_existence	enum(int,int,int)
=	O
ACCEPT_EITHER	int
;	O
static	O
int	O
follow_symlinks	int
=	O
1	int
;	O
static	O
int	O
separator	int
=	O
'\n'	O
;	O
static	O
struct	O
quoting_options	O
*	O
quote_opts	*(struct)
=	O
NULL	O
;	O
static	O
bool	bool
stdout_is_a_tty	bool
;	O
static	O
bool	bool
print_quoted_filename	bool
;	O
static	O
bool	bool
results_were_filtered	bool
;	O
static	O
const	O
char	O
*	O
selected_secure_db	*(char)
=	O
NULL	O
;	O
static	O
void	O
set_max_db_age	(*(char))->(void)
(	O
const	O
char	O
*	O
s	long
)	O
{	O
char	O
*	O
end	*(int)
;	O
unsigned	O
long	O
int	O
val	int
;	O
if	O
(	O
0	int
==	O
*	O
s	long
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"The argument for option --max-database-age must not be empty"	*(char)
)	O
)	O
;	O
}	O
errno	O
=	O
0	int
;	O
val	int
=	O
strtoul	(*(char),*(*(char)),int)->(long)
(	O
s	long
,	O
&	O
end	*(int)
,	O
10	int
)	O
;	O
if	O
(	O
(	O
ULONG_MAX	O
==	O
val	int
&&	O
ERANGE	int
==	O
errno	O
)	O
||	O
(	O
0	int
==	O
val	int
&&	O
EINVAL	int
==	O
errno	O
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Invalid argument %s for option --max-database-age"	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
s	long
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
end	*(int)
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Invalid argument %s for option --max-database-age"	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
s	long
)	O
)	O
;	O
}	O
else	O
{	O
warn_number_units	int
=	O
val	int
;	O
}	O
}	O
static	O
short	O
get_short	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(short)
(	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
register	O
short	O
x	short
;	O
x	short
=	O
(	O
signed	O
char	O
)	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
<<	O
8	int
;	O
x	short
|=	O
(	O
fgetc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
&	O
0xff	int
)	O
;	O
return	O
x	short
;	O
}	O
const	O
char	O
*	O
const	O
metacharacters	*(char)
=	O
"*?[]\\"	*(char)
;	O
static	O
int	O
contains_metacharacter	(*(char))->(int)
(	O
const	O
char	O
*	O
s	long
)	O
{	O
if	O
(	O
NULL	O
==	O
strpbrk	(*(char),*(char))->(*(char))
(	O
s	long
,	O
metacharacters	*(char)
)	O
)	O
return	O
0	int
;	O
else	O
return	O
1	int
;	O
}	O
static	O
int	O
locate_read_str	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,int)->(int)
(	O
char	O
*	O
*	O
buf	*(char)
,	O
size_t	long
*	O
siz	*(long)
,	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
int	O
delimiter	int
,	O
int	O
offs	int
)	O
{	O
char	O
*	O
p	*(void)
=	O
NULL	O
;	O
size_t	long
sz	long
=	O
0	int
;	O
int	O
nread	int
;	O
size_t	long
needed	long
;	O
nread	int
=	O
getdelim	(*(*(char)),*(long),int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
&	O
p	*(void)
,	O
&	O
sz	long
,	O
delimiter	int
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
nread	int
>=	O
0	int
)	O
{	O
assert	O
(	O
p	*(void)
!=	O
NULL	O
)	O
;	O
needed	long
=	O
offs	int
+	O
nread	int
+	O
1u	int
;	O
if	O
(	O
needed	long
>	O
(	O
*	O
siz	*(long)
)	O
)	O
{	O
char	O
*	O
pnew	*(char)
=	O
realloc	(*(void),long)->(*(void))
(	O
*	O
buf	*(char)
,	O
needed	long
)	O
;	O
if	O
(	O
NULL	O
==	O
pnew	*(char)
)	O
{	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
*	O
siz	*(long)
=	O
needed	long
;	O
*	O
buf	*(char)
=	O
pnew	*(char)
;	O
}	O
}	O
memcpy	(*(void),*(void),long)->(*(void))
(	O
(	O
*	O
buf	*(char)
)	O
+	O
offs	int
,	O
p	*(void)
,	O
nread	int
+	O
1	int
)	O
;	O
free	(*(void))->(void)
(	O
p	*(void)
)	O
;	O
}	O
return	O
nread	int
;	O
}	O
struct	O
locate_limits	struct(long,long)
{	O
uintmax_t	long
limit	long
;	O
uintmax_t	long
items_accepted	long
;	O
}	O
;	O
static	O
struct	O
locate_limits	struct(long,long)
limits	struct(long,long)
;	O
struct	O
locate_stats	struct(long,long,long,long,long,long)
{	O
uintmax_t	long
compressed_bytes	long
;	O
uintmax_t	long
total_filename_count	long
;	O
uintmax_t	long
total_filename_length	long
;	O
uintmax_t	long
whitespace_count	long
;	O
uintmax_t	long
newline_count	long
;	O
uintmax_t	long
highbit_filename_count	long
;	O
}	O
;	O
static	O
struct	O
locate_stats	struct(long,long,long,long,long,long)
statistics	struct(long,long,long,long,long,long)
;	O
struct	O
regular_expression	struct(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
{	O
struct	O
re_pattern_buffer	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
;	O
}	O
;	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
{	O
int	O
c	char
;	O
int	O
count	int
;	O
int	O
len	long
;	O
char	O
*	O
original_filename	*(char)
;	O
size_t	long
pathsize	long
;	O
char	O
*	O
munged_filename	*(char)
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
const	O
char	O
*	O
dbfile	*(char)
;	O
GetwordEndianState	enum(int,int,int)
endian_state	enum(int,int,int)
;	O
char	O
bigram1	array(char)
[	O
128	int
]	O
;	O
char	O
bigram2	array(char)
[	O
128	int
]	O
;	O
}	O
;	O
typedef	O
int	O
(	O
*	O
visitfunc	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
)	O
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
;	O
struct	O
visitor	struct(*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void),*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`))))))
{	O
visitfunc	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
inspector	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
;	O
void	O
*	O
context	*(void)
;	O
struct	O
visitor	struct(*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void),*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`))))))
*	O
next	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
;	O
}	O
;	O
static	O
struct	O
visitor	struct(*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void),*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`))))))
*	O
inspectors	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
NULL	O
;	O
static	O
struct	O
visitor	struct(*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void),*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`))))))
*	O
lastinspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
NULL	O
;	O
static	O
struct	O
visitor	struct(*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void),*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`))))))
*	O
past_pat_inspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
NULL	O
;	O
static	O
inline	O
int	O
visit	(*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))),int,*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))))->(int)
(	O
const	O
struct	O
visitor	struct(*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void),*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`))))))
*	O
p	*(void)
,	O
int	O
accept_flags	int
,	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
const	O
struct	O
visitor	struct(*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void),*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`))))))
*	O
const	O
stop	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
)	O
{	O
register	O
int	O
result	int
=	O
accept_flags	int
;	O
while	O
(	O
(	O
accept_flags	int
&	O
result	int
)	O
&&	O
(	O
stop	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
!=	O
p	*(void)
)	O
)	O
{	O
result	int
=	O
(	O
p	*(void)
->	O
inspector	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
)	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
p	*(void)
->	O
context	*(void)
)	O
;	O
p	*(void)
=	O
p	*(void)
->	O
next	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
;	O
}	O
return	O
result	int
;	O
}	O
static	O
int	O
process_simple	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
)	O
{	O
return	O
visit	(*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))),int,*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))))->(int)
(	O
inspectors	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
,	O
(	O
VISIT_CONTINUE	int
|	O
VISIT_ACCEPTED	int
)	O
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
process_or	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
)	O
{	O
int	O
result	int
;	O
result	int
=	O
visit	(*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))),int,*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))))->(int)
(	O
inspectors	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
,	O
(	O
VISIT_CONTINUE	int
|	O
VISIT_REJECTED	int
)	O
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
past_pat_inspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
)	O
;	O
if	O
(	O
result	int
==	O
VISIT_CONTINUE	int
)	O
result	int
=	O
VISIT_REJECTED	int
;	O
if	O
(	O
result	int
&	O
(	O
VISIT_ABORT	int
|	O
VISIT_REJECTED	int
)	O
)	O
return	O
result	int
;	O
result	int
=	O
visit	(*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))),int,*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))))->(int)
(	O
past_pat_inspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
,	O
VISIT_CONTINUE	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
NULL	O
)	O
;	O
if	O
(	O
VISIT_CONTINUE	int
==	O
result	int
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
result	int
;	O
}	O
static	O
int	O
process_and	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
)	O
{	O
int	O
result	int
;	O
result	int
=	O
visit	(*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))),int,*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))))->(int)
(	O
inspectors	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
,	O
(	O
VISIT_CONTINUE	int
|	O
VISIT_ACCEPTED	int
)	O
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
past_pat_inspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
)	O
;	O
if	O
(	O
result	int
==	O
VISIT_CONTINUE	int
)	O
result	int
=	O
VISIT_REJECTED	int
;	O
if	O
(	O
result	int
&	O
(	O
VISIT_ABORT	int
|	O
VISIT_REJECTED	int
)	O
)	O
return	O
result	int
;	O
result	int
=	O
visit	(*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))),int,*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(struct(*((*`,*`)->(int)),*(void),*(struct(*`,*`,*`)))))->(int)
(	O
past_pat_inspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
,	O
VISIT_CONTINUE	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
NULL	O
)	O
;	O
if	O
(	O
VISIT_CONTINUE	int
==	O
result	int
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
result	int
;	O
}	O
typedef	O
int	O
(	O
*	O
processfunc	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))))->(int))
)	O
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
)	O
;	O
static	O
processfunc	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))))->(int))
mainprocessor	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))))->(int))
=	O
NULL	O
;	O
static	O
void	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visitfunc	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
fn	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
,	O
void	O
*	O
context	*(void)
)	O
{	O
struct	O
visitor	struct(*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void),*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`))))))
*	O
p	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
struct	O
visitor	struct(*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void),*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`))))))
)	O
)	O
;	O
p	*(void)
->	O
inspector	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
=	O
fn	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
;	O
p	*(void)
->	O
context	*(void)
=	O
context	*(void)
;	O
p	*(void)
->	O
next	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
NULL	O
;	O
if	O
(	O
NULL	O
==	O
lastinspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
)	O
{	O
lastinspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
inspectors	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
p	*(void)
;	O
}	O
else	O
{	O
lastinspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
->	O
next	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
p	*(void)
;	O
lastinspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
p	*(void)
;	O
}	O
}	O
static	O
int	O
visit_justprint_quoted	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
(	O
void	O
)	O
context	*(void)
;	O
print_quoted	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(struct),bool,*(char),*(char))->(int)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
quote_opts	*(struct)
,	O
stdout_is_a_tty	bool
,	O
"%s"	*(char)
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
)	O
;	O
putchar	(int)->(int)
(	O
separator	int
)	O
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_justprint_unquoted	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
(	O
void	O
)	O
context	*(void)
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
,	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
putchar	(int)->(int)
(	O
separator	int
)	O
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
void	O
toolong	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))))->(void)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"locate database %s contains a "	*(char)
"filename longer than locate can handle"	*(char)
)	O
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
dbfile	*(char)
)	O
;	O
}	O
static	O
void	O
extend	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),long,long)->(void)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
size_t	long
siz1	long
,	O
size_t	long
siz2	long
)	O
{	O
if	O
(	O
SIZE_MAX	O
-	O
siz1	long
<	O
siz2	long
)	O
{	O
toolong	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))))->(void)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
)	O
;	O
}	O
else	O
if	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
pathsize	long
<	O
(	O
siz1	long
+	O
siz2	long
)	O
)	O
{	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
pathsize	long
=	O
siz1	long
+	O
siz2	long
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
=	O
x2nrealloc	(*(void),*(long),long)->(*(void))
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
,	O
&	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
pathsize	long
,	O
1	int
)	O
;	O
}	O
}	O
static	O
int	O
visit_old_format	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
register	O
size_t	long
i	int
;	O
(	O
void	O
)	O
context	*(void)
;	O
if	O
(	O
EOF	O
==	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
)	O
return	O
VISIT_ABORT	int
;	O
if	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
==	O
LOCATEDB_OLD_ESCAPE	int
)	O
{	O
int	O
minval	int
,	O
maxval	int
;	O
int	O
word	int
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
-=	O
LOCATEDB_OLD_OFFSET	int
;	O
minval	int
=	O
(	O
0	int
-	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
)	O
;	O
if	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
>=	O
0	int
)	O
maxval	int
=	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
len	long
-	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
)	O
;	O
else	O
maxval	int
=	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
len	long
-	O
0	int
)	O
;	O
word	int
=	O
getword	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char),long,long,*(enum(int,int,int)))->(int)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
dbfile	*(char)
,	O
minval	int
,	O
maxval	int
,	O
&	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
endian_state	enum(int,int,int)
)	O
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
+=	O
word	int
;	O
assert	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
>=	O
0	int
)	O
;	O
}	O
else	O
{	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
+=	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
-	O
LOCATEDB_OLD_OFFSET	int
)	O
;	O
assert	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
>=	O
0	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
;	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
>	O
LOCATEDB_OLD_ESCAPE	int
;	O
)	O
{	O
if	O
(	O
EOF	O
==	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
)	O
break	O
;	O
if	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
<	O
0200	int
)	O
{	O
extend	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),long,long)->(void)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
i	int
,	O
1u	int
)	O
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
[	O
i	int
++	O
]	O
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
;	O
}	O
else	O
{	O
extend	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),long,long)->(void)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
i	int
,	O
2u	int
)	O
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
&=	O
0177	int
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
[	O
i	int
++	O
]	O
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
bigram1	array(char)
[	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
]	O
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
[	O
i	int
++	O
]	O
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
bigram2	array(char)
[	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
]	O
;	O
}	O
}	O
extend	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),long,long)->(void)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
i	int
,	O
1u	int
)	O
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
[	O
i	int
]	O
=	O
0	int
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
len	long
=	O
i	int
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
munged_filename	*(char)
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_locate02_format	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
register	O
char	O
*	O
s	long
;	O
int	O
nread	int
;	O
(	O
void	O
)	O
context	*(void)
;	O
if	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
==	O
LOCATEDB_ESCAPE	int
)	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
+=	O
(	O
short	O
)	O
get_short	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(short)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
else	O
if	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
>	O
127	int
)	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
+=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
-	O
256	int
;	O
else	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
+=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
;	O
if	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
>	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
len	long
||	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
<	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"locate database %s is corrupt or invalid"	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
dbfile	*(char)
)	O
)	O
;	O
}	O
nread	int
=	O
locate_read_str	(*(*(char)),*(long),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),int,int)->(int)
(	O
&	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
,	O
&	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
pathsize	long
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
0	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
)	O
;	O
if	O
(	O
nread	int
<	O
1	int
)	O
return	O
VISIT_ABORT	int
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
len	long
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
count	int
+	O
nread	int
-	O
1	int
;	O
if	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
len	long
<	O
1	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"locate database %s is corrupt or invalid"	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
dbfile	*(char)
)	O
)	O
;	O
}	O
s	long
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
+	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
len	long
-	O
1	int
;	O
assert	O
(	O
s	long
[	O
0	int
]	O
!=	O
'\0'	O
)	O
;	O
assert	O
(	O
s	long
[	O
1	int
]	O
==	O
'\0'	O
)	O
;	O
assert	O
(	O
s	long
[	O
2	int
]	O
==	O
'\0'	O
)	O
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
munged_filename	*(char)
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_basename	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
(	O
void	O
)	O
context	*(void)
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
munged_filename	*(char)
=	O
last_component	(*(char))->(*(char))
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
)	O
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_existing_follow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
(	O
void	O
)	O
context	*(void)
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
!=	O
0	int
)	O
{	O
return	O
VISIT_REJECTED	int
;	O
}	O
else	O
{	O
return	O
VISIT_CONTINUE	int
;	O
}	O
}	O
static	O
int	O
visit_non_existing_follow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
(	O
void	O
)	O
context	*(void)
;	O
if	O
(	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
==	O
0	int
)	O
{	O
return	O
VISIT_REJECTED	int
;	O
}	O
else	O
{	O
return	O
VISIT_CONTINUE	int
;	O
}	O
}	O
static	O
int	O
visit_existing_nofollow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
(	O
void	O
)	O
context	*(void)
;	O
if	O
(	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
!=	O
0	int
)	O
{	O
return	O
VISIT_REJECTED	int
;	O
}	O
else	O
{	O
return	O
VISIT_CONTINUE	int
;	O
}	O
}	O
static	O
int	O
visit_non_existing_nofollow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
(	O
void	O
)	O
context	*(void)
;	O
if	O
(	O
lstat	(*(char),*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
==	O
0	int
)	O
{	O
return	O
VISIT_REJECTED	int
;	O
}	O
else	O
{	O
return	O
VISIT_CONTINUE	int
;	O
}	O
}	O
static	O
int	O
visit_substring_match_nocasefold_wide	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
const	O
char	O
*	O
pattern	*(char)
=	O
context	*(void)
;	O
if	O
(	O
NULL	O
!=	O
mbsstr	(*(char),*(char))->(*(char))
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
munged_filename	*(char)
,	O
pattern	*(char)
)	O
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
VISIT_REJECTED	int
;	O
}	O
static	O
int	O
visit_substring_match_nocasefold_narrow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
const	O
char	O
*	O
pattern	*(char)
=	O
context	*(void)
;	O
assert	O
(	O
MB_CUR_MAX	O
==	O
1	int
)	O
;	O
if	O
(	O
NULL	O
!=	O
strstr	(*(char),*(char))->(*(char))
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
munged_filename	*(char)
,	O
pattern	*(char)
)	O
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
VISIT_REJECTED	int
;	O
}	O
static	O
int	O
visit_substring_match_casefold_wide	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
const	O
char	O
*	O
pattern	*(char)
=	O
context	*(void)
;	O
if	O
(	O
NULL	O
!=	O
mbscasestr	(*(char),*(char))->(*(char))
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
munged_filename	*(char)
,	O
pattern	*(char)
)	O
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
VISIT_REJECTED	int
;	O
}	O
static	O
int	O
visit_substring_match_casefold_narrow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
const	O
char	O
*	O
pattern	*(char)
=	O
context	*(void)
;	O
assert	O
(	O
MB_CUR_MAX	O
==	O
1	int
)	O
;	O
if	O
(	O
NULL	O
!=	O
strcasestr	(*(char),*(char))->(*(char))
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
munged_filename	*(char)
,	O
pattern	*(char)
)	O
)	O
return	O
VISIT_ACCEPTED	int
;	O
else	O
return	O
VISIT_REJECTED	int
;	O
}	O
static	O
int	O
visit_globmatch_nofold	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
const	O
char	O
*	O
glob	*(char)
=	O
context	*(void)
;	O
if	O
(	O
fnmatch	(*(char),*(char),int)->(int)
(	O
glob	*(char)
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
munged_filename	*(char)
,	O
0	int
)	O
!=	O
0	int
)	O
return	O
VISIT_REJECTED	int
;	O
else	O
return	O
VISIT_ACCEPTED	int
;	O
}	O
static	O
int	O
visit_globmatch_casefold	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
const	O
char	O
*	O
glob	*(char)
=	O
context	*(void)
;	O
if	O
(	O
fnmatch	(*(char),*(char),int)->(int)
(	O
glob	*(char)
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
munged_filename	*(char)
,	O
FNM_CASEFOLD	O
)	O
!=	O
0	int
)	O
return	O
VISIT_REJECTED	int
;	O
else	O
return	O
VISIT_ACCEPTED	int
;	O
}	O
static	O
int	O
visit_regex	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
struct	O
regular_expression	struct(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
p	*(void)
=	O
context	*(void)
;	O
const	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
munged_filename	*(char)
)	O
;	O
int	O
rv	int
=	O
re_search	(*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)),*(char),int,int,int,*(struct(int,*(int),*(int))))->(int)
(	O
&	O
p	*(void)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
munged_filename	*(char)
,	O
len	long
,	O
0	int
,	O
len	long
,	O
(	O
struct	O
re_registers	struct(int,*(int),*(int))
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
rv	int
<	O
0	int
)	O
{	O
return	O
VISIT_REJECTED	int
;	O
}	O
else	O
{	O
return	O
VISIT_ACCEPTED	int
;	O
}	O
}	O
static	O
int	O
visit_stats	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
struct	O
locate_stats	struct(long,long,long,long,long,long)
*	O
p	*(void)
=	O
context	*(void)
;	O
size_t	long
len	long
=	O
strlen	(*(char))->(long)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
)	O
;	O
const	O
char	O
*	O
s	long
;	O
int	O
highbit	int
,	O
whitespace	int
,	O
newline	int
;	O
++	O
(	O
p	*(void)
->	O
total_filename_count	long
)	O
;	O
p	*(void)
->	O
total_filename_length	long
+=	O
len	long
;	O
highbit	int
=	O
whitespace	int
=	O
newline	int
=	O
0	int
;	O
for	O
(	O
s	long
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
->	O
original_filename	*(char)
;	O
*	O
s	long
;	O
++	O
s	long
)	O
{	O
if	O
(	O
(	O
int	O
)	O
(	O
*	O
s	long
)	O
&	O
128	int
)	O
highbit	int
=	O
1	int
;	O
if	O
(	O
'\n'	O
==	O
*	O
s	long
)	O
{	O
newline	int
=	O
whitespace	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
isspace	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	long
)	O
)	O
{	O
whitespace	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
highbit	int
)	O
++	O
(	O
p	*(void)
->	O
highbit_filename_count	long
)	O
;	O
if	O
(	O
whitespace	int
)	O
++	O
(	O
p	*(void)
->	O
whitespace_count	long
)	O
;	O
if	O
(	O
newline	int
)	O
++	O
(	O
p	*(void)
->	O
newline_count	long
)	O
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_limit	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
struct	O
locate_limits	struct(long,long)
*	O
p	*(void)
=	O
context	*(void)
;	O
(	O
void	O
)	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
;	O
if	O
(	O
++	O
p	*(void)
->	O
items_accepted	long
>=	O
p	*(void)
->	O
limit	long
)	O
return	O
VISIT_ABORT	int
;	O
else	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
int	O
visit_count	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
(	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
*	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
void	O
*	O
context	*(void)
)	O
{	O
struct	O
locate_limits	struct(long,long)
*	O
p	*(void)
=	O
context	*(void)
;	O
(	O
void	O
)	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
;	O
++	O
p	*(void)
->	O
items_accepted	long
;	O
return	O
VISIT_CONTINUE	int
;	O
}	O
static	O
void	O
print_stats	(int,long,*(struct(long,long)))->(void)
(	O
int	O
argc	int
,	O
size_t	long
database_file_size	long
,	O
const	O
struct	O
timespec	struct(long,long)
*	O
database_mtime	*(struct(long,long))
)	O
{	O
char	O
hbuf1	array(char)
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
char	O
hbuf2	array(char)
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
char	O
hbuf3	array(char)
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
char	O
hbuf4	array(char)
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
if	O
(	O
database_mtime	*(struct(long,long))
)	O
{	O
const	O
struct	O
tm	struct(int,int,int,int,int,int,int,int,int,long,*(char))
*	O
ptm	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
=	O
localtime	(*(long))->(*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))
(	O
&	O
(	O
database_mtime	*(struct(long,long))
->	O
tv_sec	long
)	O
)	O
;	O
if	O
(	O
ptm	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
)	O
{	O
enum	O
{	O
TIME_BUF_LEN	int
=	O
20	int
}	O
;	O
char	O
whenbuf	array(char)
[	O
TIME_BUF_LEN	int
]	O
;	O
size_t	long
printed	long
=	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
whenbuf	array(char)
,	O
TIME_BUF_LEN	int
,	O
"%Y:%m:%d %H:%M:%S"	*(char)
,	O
ptm	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
)	O
;	O
assert	O
(	O
printed	long
==	O
TIME_BUF_LEN	int
-	O
1	int
)	O
;	O
assert	O
(	O
whenbuf	array(char)
[	O
TIME_BUF_LEN	int
-	O
1	int
]	O
==	O
0	int
)	O
;	O
assert	O
(	O
whenbuf	array(char)
[	O
TIME_BUF_LEN	int
-	O
2	int
]	O
!=	O
0	int
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Database was last modified at %s.%09ld"	*(char)
)	O
,	O
whenbuf	array(char)
,	O
(	O
long	O
int	O
)	O
database_mtime	*(struct(long,long))
->	O
tv_nsec	long
)	O
;	O
printed	long
=	O
strftime	(*(char),long,*(char),*(struct(int,int,int,int,int,int,int,int,int,long,*(char))))->(long)
(	O
whenbuf	array(char)
,	O
TIME_BUF_LEN	int
,	O
"%z"	*(char)
,	O
ptm	*(struct(int,int,int,int,int,int,int,int,int,long,*(char)))
)	O
;	O
assert	O
(	O
printed	long
==	O
5	int
)	O
;	O
printf	(*(char))->(int)
(	O
" %s\n"	*(char)
,	O
whenbuf	array(char)
)	O
;	O
}	O
}	O
printf	(*(char))->(int)
(	O
ngettext	(*(char),*(char),long)->(*(char))
(	O
"Locate database size: %s byte\n"	*(char)
,	O
"Locate database size: %s bytes\n"	*(char)
,	O
database_file_size	long
)	O
,	O
human_readable	(long,*(char),int,long,long)->(*(char))
(	O
(	O
uintmax_t	long
)	O
database_file_size	long
,	O
hbuf1	array(char)
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
(	O
results_were_filtered	bool
?	O
_	O
(	O
"Matching Filenames: %s\n"	*(char)
)	O
:	O
_	O
(	O
"All Filenames: %s\n"	*(char)
)	O
)	O
,	O
human_readable	(long,*(char),int,long,long)->(*(char))
(	O
statistics	struct(long,long,long,long,long,long)
.	O
total_filename_count	long
,	O
hbuf1	array(char)
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
printf	(*(char))->(int)
(	O
_	O
(	O
"File names have a cumulative length of %s bytes.\n"	*(char)
"Of those file names,\n"	*(char)
"\n\t%s contain whitespace, "	*(char)
"\n\t%s contain newline characters, "	*(char)
"\n\tand %s contain characters with the high bit set.\n"	*(char)
)	O
,	O
human_readable	(long,*(char),int,long,long)->(*(char))
(	O
statistics	struct(long,long,long,long,long,long)
.	O
total_filename_length	long
,	O
hbuf1	array(char)
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
,	O
human_readable	(long,*(char),int,long,long)->(*(char))
(	O
statistics	struct(long,long,long,long,long,long)
.	O
whitespace_count	long
,	O
hbuf2	array(char)
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
,	O
human_readable	(long,*(char),int,long,long)->(*(char))
(	O
statistics	struct(long,long,long,long,long,long)
.	O
newline_count	long
,	O
hbuf3	array(char)
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
,	O
human_readable	(long,*(char),int,long,long)->(*(char))
(	O
statistics	struct(long,long,long,long,long,long)
.	O
highbit_filename_count	long
,	O
hbuf4	array(char)
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
argc	int
)	O
{	O
if	O
(	O
results_were_filtered	bool
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Some filenames may have been filtered out, "	*(char)
"so we cannot compute the compression ratio.\n"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
statistics	struct(long,long,long,long,long,long)
.	O
total_filename_length	long
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Compression ratio %4.2f%% (higher is better)\n"	*(char)
)	O
,	O
100.0	int
*	O
(	O
(	O
double	O
)	O
statistics	struct(long,long,long,long,long,long)
.	O
total_filename_length	long
-	O
(	O
double	O
)	O
database_file_size	long
)	O
/	O
(	O
double	O
)	O
statistics	struct(long,long,long,long,long,long)
.	O
total_filename_length	long
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Compression ratio is undefined\n"	*(char)
)	O
)	O
;	O
}	O
}	O
}	O
printf	(*(char))->(int)
(	O
"\n"	*(char)
)	O
;	O
}	O
static	O
int	O
looking_at_gnu_locatedb	(*(char),long)->(int)
(	O
const	O
char	O
*	O
data	*(char)
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
len	long
<	O
sizeof	O
(	O
LOCATEDB_MAGIC	*(char)
)	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
0	int
==	O
memcmp	(*(void),*(void),long)->(int)
(	O
data	*(char)
,	O
LOCATEDB_MAGIC	*(char)
,	O
sizeof	O
(	O
LOCATEDB_MAGIC	*(char)
)	O
)	O
)	O
return	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
static	O
int	O
looking_at_slocate_locatedb	(*(char),*(char),long,*(int))->(int)
(	O
const	O
char	O
*	O
filename	*(char)
,	O
const	O
char	O
*	O
data	*(char)
,	O
size_t	long
len	long
,	O
int	O
*	O
seclevel	*(int)
)	O
{	O
assert	O
(	O
len	long
<=	O
2	int
)	O
;	O
if	O
(	O
len	long
<	O
2	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
0	int
==	O
data	*(char)
[	O
1	int
]	O
)	O
{	O
if	O
(	O
isdigit	(int)->(int)
(	O
(	O
unsigned	O
char	O
)	O
data	*(char)
[	O
0	int
]	O
)	O
)	O
{	O
*	O
seclevel	*(int)
=	O
(	O
data	*(char)
[	O
0	int
]	O
-	O
'0'	O
)	O
;	O
if	O
(	O
*	O
seclevel	*(int)
>	O
1	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"locate database %s looks like an slocate "	*(char)
"database but it seems to have security level %c, "	*(char)
"which GNU findutils does not currently support"	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
filename	*(char)
)	O
,	O
data	*(char)
[	O
1	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
}	O
static	O
int	O
i_am_little_endian	()->(int)
(	O
void	O
)	O
{	O
union	O
{	O
unsigned	O
char	O
uch	array(char)
[	O
4	int
]	O
;	O
unsigned	O
int	O
ui	int
;	O
}	O
u	union(array(char),int)
;	O
u	union(array(char),int)
.	O
ui	int
=	O
0u	int
;	O
u	union(array(char),int)
.	O
uch	array(char)
[	O
0	int
]	O
=	O
1	int
;	O
u	union(array(char),int)
.	O
uch	array(char)
[	O
1	int
]	O
=	O
u	union(array(char),int)
.	O
uch	array(char)
[	O
2	int
]	O
=	O
u	union(array(char),int)
.	O
uch	array(char)
[	O
3	int
]	O
=	O
0	int
;	O
return	O
u	union(array(char),int)
.	O
ui	int
==	O
1	int
;	O
}	O
static	O
unsigned	O
long	O
search_one_database	(int,*(*(char)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,*(struct(long,long)),int,int,int,int,*(struct(long,long)),int,int,int,int)->(long)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
const	O
char	O
*	O
dbfile	*(char)
,	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
off_t	long
filesize	long
,	O
const	O
struct	O
timespec	struct(long,long)
*	O
database_mtime	*(struct(long,long))
,	O
int	O
ignore_case	int
,	O
int	O
enable_print	int
,	O
int	O
basename_only	int
,	O
int	O
use_limit	int
,	O
struct	O
locate_limits	struct(long,long)
*	O
plimit	*(struct(long,long))
,	O
int	O
stats	int
,	O
int	O
op_and	int
,	O
int	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
int	O
regex_options	int
)	O
{	O
char	O
*	O
pathpart	*(char)
;	O
int	O
argn	int
;	O
int	O
nread	int
;	O
struct	O
process_data	struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
;	O
int	O
slocate_seclevel	int
;	O
int	O
oldformat	int
;	O
int	O
slocatedb_format	int
;	O
struct	O
visitor	struct(*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void),*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`))))))
*	O
pvis	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
;	O
const	O
char	O
*	O
format_name	*(char)
;	O
enum	O
ExistenceCheckType	enum(int,int,int)
do_check_existence	enum(int,int,int)
;	O
do_check_existence	enum(int,int,int)
=	O
check_existence	enum(int,int,int)
;	O
if	O
(	O
ignore_case	int
)	O
regex_options	int
|=	O
RE_ICASE	O
;	O
oldformat	int
=	O
0	int
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
endian_state	enum(int,int,int)
=	O
GetwordEndianStateInitial	int
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
len	long
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
count	int
=	O
0	int
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
dbfile	*(char)
=	O
dbfile	*(char)
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
inspectors	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
NULL	O
;	O
lastinspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
NULL	O
;	O
past_pat_inspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
NULL	O
;	O
results_were_filtered	bool
=	O
false	int
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
pathsize	long
=	O
128	int
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
original_filename	*(char)
=	O
xmalloc	(long)->(*(void))
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
pathsize	long
)	O
;	O
nread	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
original_filename	*(char)
,	O
1	int
,	O
SLOCATE_DB_MAGIC_LEN	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
slocate_seclevel	int
=	O
0	int
;	O
if	O
(	O
looking_at_slocate_locatedb	(*(char),*(char),long,*(int))->(int)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
dbfile	*(char)
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
original_filename	*(char)
,	O
nread	int
,	O
&	O
slocate_seclevel	int
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s is an slocate database.  "	*(char)
"Support for these is new, expect problems for now."	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
dbfile	*(char)
)	O
)	O
;	O
if	O
(	O
slocate_seclevel	int
>	O
1	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s is an slocate database of unsupported security level %d; skipping it."	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
dbfile	*(char)
)	O
,	O
slocate_seclevel	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
slocate_seclevel	int
>	O
0	int
)	O
{	O
if	O
(	O
ACCEPT_NON_EXISTING	int
==	O
check_existence	enum(int,int,int)
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"You specified the -E option, but that option "	*(char)
"cannot be used with slocate-format databases "	*(char)
"with a non-zero security level.  No results will be "	*(char)
"generated for this database.\n"	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
ACCEPT_EXISTING	int
!=	O
do_check_existence	enum(int,int,int)
)	O
{	O
if	O
(	O
enable_print	int
||	O
stats	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s is an slocate database.  "	*(char)
"Turning on the '-e' option."	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
dbfile	*(char)
)	O
)	O
;	O
}	O
do_check_existence	enum(int,int,int)
=	O
ACCEPT_EXISTING	int
;	O
}	O
}	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_locate02_format	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
NULL	O
)	O
;	O
format_name	*(char)
=	O
"slocate"	*(char)
;	O
slocatedb_format	int
=	O
1	int
;	O
}	O
else	O
{	O
int	O
nread2	int
;	O
slocatedb_format	int
=	O
0	int
;	O
extend	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),long,long)->(void)
(	O
&	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
sizeof	O
(	O
LOCATEDB_MAGIC	*(char)
)	O
,	O
0u	int
)	O
;	O
nread2	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
original_filename	*(char)
+	O
nread	int
,	O
1	int
,	O
sizeof	O
(	O
LOCATEDB_MAGIC	*(char)
)	O
-	O
nread	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
looking_at_gnu_locatedb	(*(char),long)->(int)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
original_filename	*(char)
,	O
nread	int
+	O
nread2	int
)	O
)	O
{	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_locate02_format	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
NULL	O
)	O
;	O
format_name	*(char)
=	O
"GNU LOCATE02"	*(char)
;	O
}	O
else	O
{	O
int	O
i	int
;	O
nread	int
+=	O
nread2	int
;	O
extend	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),long,long)->(void)
(	O
&	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
,	O
256u	int
,	O
0u	int
)	O
;	O
if	O
(	O
nread	int
<	O
256	int
)	O
{	O
int	O
more_read	int
=	O
fread	(*(void),long,long,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(long)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
original_filename	*(char)
+	O
nread	int
,	O
1	int
,	O
256	int
-	O
nread	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
(	O
more_read	int
+	O
nread	int
)	O
!=	O
256	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Old-format locate database %s is "	*(char)
"too short to be valid"	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
dbfile	*(char)
)	O
)	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
128	int
;	O
i	int
++	O
)	O
{	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
bigram1	array(char)
[	O
i	int
]	O
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
original_filename	*(char)
[	O
i	int
<<	O
1	int
]	O
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
bigram2	array(char)
[	O
i	int
]	O
=	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
original_filename	*(char)
[	O
(	O
i	int
<<	O
1	int
)	O
+	O
1	int
]	O
;	O
}	O
format_name	*(char)
=	O
"old"	*(char)
;	O
oldformat	int
=	O
1	int
;	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_old_format	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
basename_only	int
)	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_basename	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
NULL	O
)	O
;	O
for	O
(	O
argn	int
=	O
0	int
;	O
argn	int
<	O
argc	int
;	O
argn	int
++	O
)	O
{	O
results_were_filtered	bool
=	O
true	int
;	O
pathpart	*(char)
=	O
argv	*(*(char))
[	O
argn	int
]	O
;	O
if	O
(	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
{	O
struct	O
regular_expression	struct(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int))
*	O
p	*(void)
=	O
xmalloc	(long)->(*(void))
(	O
sizeof	O
(	O
*	O
p	*(void)
)	O
)	O
;	O
const	O
char	O
*	O
error_message	*(char)
=	O
NULL	O
;	O
memset	(*(void),int,long)->(*(void))
(	O
&	O
p	*(void)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
0	int
,	O
sizeof	O
(	O
p	*(void)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
)	O
;	O
re_set_syntax	(long)->(long)
(	O
regex_options	int
)	O
;	O
p	*(void)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
.	O
allocated	long
=	O
100	int
;	O
p	*(void)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
.	O
buffer	*(struct)
=	O
xmalloc	(long)->(*(void))
(	O
p	*(void)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
.	O
allocated	long
)	O
;	O
p	*(void)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
.	O
fastmap	*(char)
=	O
NULL	O
;	O
p	*(void)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
.	O
syntax	long
=	O
regex_options	int
;	O
p	*(void)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
.	O
translate	*(char)
=	O
NULL	O
;	O
error_message	*(char)
=	O
re_compile_pattern	(*(char),long,*(struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)))->(*(char))
(	O
pathpart	*(char)
,	O
strlen	(*(char))->(long)
(	O
pathpart	*(char)
)	O
,	O
&	O
p	*(void)
->	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
)	O
;	O
if	O
(	O
error_message	*(char)
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"%s"	*(char)
,	O
error_message	*(char)
)	O
;	O
}	O
else	O
{	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_regex	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
p	*(void)
)	O
;	O
}	O
}	O
else	O
if	O
(	O
contains_metacharacter	(*(char))->(int)
(	O
pathpart	*(char)
)	O
)	O
{	O
if	O
(	O
ignore_case	int
)	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_globmatch_casefold	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
pathpart	*(char)
)	O
;	O
else	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_globmatch_nofold	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
pathpart	*(char)
)	O
;	O
}	O
else	O
{	O
visitfunc	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
matcher	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
;	O
if	O
(	O
1	int
==	O
MB_CUR_MAX	O
)	O
{	O
matcher	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
=	O
ignore_case	int
?	O
visit_substring_match_casefold_narrow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
:	O
visit_substring_match_nocasefold_narrow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
;	O
}	O
else	O
{	O
matcher	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
=	O
ignore_case	int
?	O
visit_substring_match_casefold_wide	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
:	O
visit_substring_match_nocasefold_wide	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
;	O
}	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
matcher	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int))
,	O
pathpart	*(char)
)	O
;	O
}	O
}	O
pvis	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
lastinspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
;	O
switch	O
(	O
do_check_existence	enum(int,int,int)
)	O
{	O
case	O
ACCEPT_EXISTING	int
:	O
results_were_filtered	bool
=	O
true	int
;	O
if	O
(	O
follow_symlinks	int
)	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_existing_follow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
NULL	O
)	O
;	O
else	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_existing_nofollow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
ACCEPT_NON_EXISTING	int
:	O
results_were_filtered	bool
=	O
true	int
;	O
if	O
(	O
follow_symlinks	int
)	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_non_existing_follow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
NULL	O
)	O
;	O
else	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_non_existing_nofollow	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
ACCEPT_EITHER	int
:	O
break	O
;	O
}	O
if	O
(	O
stats	int
)	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_stats	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
&	O
statistics	struct(long,long,long,long,long,long)
)	O
;	O
if	O
(	O
enable_print	int
)	O
{	O
if	O
(	O
print_quoted_filename	bool
)	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_justprint_quoted	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
NULL	O
)	O
;	O
else	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_justprint_unquoted	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
use_limit	int
)	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_limit	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
plimit	*(struct(long,long))
)	O
;	O
else	O
add_visitor	(*((*(struct(int,int,int,*`,long,*`,*`,*`,enum(int,int,int),array(char),array(char))),*(void))->(int)),*(void))->(void)
(	O
visit_count	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))),*(void))->(int)
,	O
plimit	*(struct(long,long))
)	O
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
past_pat_inspector	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
=	O
pvis	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
->	O
next	*(struct(*((*(struct`),*(void))->(int)),*(void),*(struct(*((*`,*`)->(int)),*(void),*(struct`)))))
;	O
if	O
(	O
op_and	int
)	O
mainprocessor	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))))->(int))
=	O
process_and	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))))->(int)
;	O
else	O
mainprocessor	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))))->(int))
=	O
process_or	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))))->(int)
;	O
}	O
else	O
mainprocessor	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))))->(int))
=	O
process_simple	(*(struct(int,int,int,*(char),long,*(char),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(char),enum(int,int,int),array(char),array(char))))->(int)
;	O
if	O
(	O
stats	int
)	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"Database %s is in the %s format.\n"	*(char)
)	O
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
dbfile	*(char)
,	O
format_name	*(char)
)	O
;	O
}	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
c	char
=	O
getc	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
if	O
(	O
slocatedb_format	int
&&	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
c	char
!=	O
EOF	O
)	O
)	O
{	O
ungetc	(int,*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
c	char
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
c	char
=	O
0	int
;	O
}	O
while	O
(	O
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
c	char
!=	O
EOF	O
)	O
&&	O
(	O
VISIT_ABORT	int
!=	O
(	O
mainprocessor	*((*(struct(int,int,int,*(char),long,*(char),*(struct`),*(char),enum(int,int,int),array(char),array(char))))->(int))
)	O
(	O
&	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
)	O
)	O
)	O
{	O
}	O
if	O
(	O
stats	int
)	O
{	O
if	O
(	O
oldformat	int
)	O
{	O
int	O
host_little_endian	int
=	O
i_am_little_endian	()->(int)
(	O
)	O
;	O
const	O
char	O
*	O
little	*(char)
=	O
_	O
(	O
"The database has little-endian "	*(char)
"machine-word encoding.\n"	*(char)
)	O
;	O
const	O
char	O
*	O
big	*(char)
=	O
_	O
(	O
"The database has big-endian "	*(char)
"machine-word encoding.\n"	*(char)
)	O
;	O
if	O
(	O
GetwordEndianStateNative	int
==	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
endian_state	enum(int,int,int)
)	O
{	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
(	O
host_little_endian	int
?	O
little	*(char)
:	O
big	*(char)
)	O
)	O
;	O
}	O
else	O
if	O
(	O
GetwordEndianStateSwab	int
==	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
endian_state	enum(int,int,int)
)	O
{	O
printf	(*(char))->(int)
(	O
"%s"	*(char)
,	O
(	O
host_little_endian	int
?	O
big	*(char)
:	O
little	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
printf	(*(char))->(int)
(	O
_	O
(	O
"The database machine-word encoding order "	*(char)
"is not obvious.\n"	*(char)
)	O
)	O
;	O
}	O
}	O
if	O
(	O
filesize	long
||	O
(	O
database_mtime	*(struct(long,long))
!=	O
NULL	O
)	O
)	O
print_stats	(int,long,*(struct(long,long)))->(void)
(	O
argc	int
,	O
filesize	long
,	O
database_mtime	*(struct(long,long))
)	O
;	O
}	O
if	O
(	O
ferror	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
procdata	*(struct(int,int,int,*(char),long,*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(char),enum(int,int,int),array(char),array(char)))
.	O
dbfile	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
plimit	*(struct(long,long))
->	O
items_accepted	long
;	O
}	O
extern	O
char	O
*	O
version_string	*(char)
;	O
static	O
void	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
FILE	struct
*	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
fprintf	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),*(char))->(int)
(	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
_	O
(	O
"Usage: %s [-d path | --database=path] [-e | -E | --[non-]existing]\n      [-i | --ignore-case] [-w | --wholename] [-b | --basename] \n      [--limit=N | -l N] [-S | --statistics] [-0 | --null] [-c | --count]\n      [-P | -H | --nofollow] [-L | --follow] [-m | --mmap] [-s | --stdio]\n      [-A | --all] [-p | --print] [-r | --regex] [--regextype=TYPE]\n      [--max-database-age D] [--version] [--help]\n      pattern...\n"	*(char)
)	O
,	O
program_name	*(char)
)	O
;	O
fputs	(*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
_	O
(	O
"\nReport bugs to <bug-findutils@gnu.org>.\n"	*(char)
)	O
,	O
stream	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
}	O
enum	O
{	O
REGEXTYPE_OPTION	int
=	O
CHAR_MAX	O
+	O
1	int
,	O
MAX_DB_AGE	int
}	O
;	O
static	O
struct	O
option	struct(*(char),int,*(int),int)
const	O
longopts	array(struct(*(char),int,*(int),int))
[	O
]	O
=	O
{	O
{	O
"database"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"existing"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"non-existing"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'E'	O
}	O
,	O
{	O
"ignore-case"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"all"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'A'	O
}	O
,	O
{	O
"help"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"version"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"null"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'0'	O
}	O
,	O
{	O
"count"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"wholename"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
"wholepath"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
"basename"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'b'	O
}	O
,	O
{	O
"print"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"stdio"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"mmap"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'm'	O
}	O
,	O
{	O
"limit"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"regex"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"regextype"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
REGEXTYPE_OPTION	int
}	O
,	O
{	O
"statistics"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'S'	O
}	O
,	O
{	O
"follow"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'L'	O
}	O
,	O
{	O
"nofollow"	*(char)
,	O
no_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"max-database-age"	*(char)
,	O
required_argument	int
,	O
NULL	O
,	O
MAX_DB_AGE	int
}	O
,	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
int	O
drop_privs	()->(int)
(	O
void	O
)	O
{	O
const	O
char	O
*	O
what	*(char)
=	O
"failed"	*(char)
;	O
const	O
uid_t	int
orig_euid	int
=	O
geteuid	()->(int)
(	O
)	O
;	O
const	O
uid_t	int
uid	int
=	O
getuid	()->(int)
(	O
)	O
;	O
const	O
gid_t	int
gid	int
=	O
getgid	()->(int)
(	O
)	O
;	O
if	O
(	O
0	int
==	O
orig_euid	int
)	O
{	O
gid_t	int
groups	array(int)
[	O
1	int
]	O
;	O
groups	array(int)
[	O
0	int
]	O
=	O
gid	int
;	O
if	O
(	O
0	int
!=	O
setgroups	(long,*(int))->(int)
(	O
1u	int
,	O
groups	array(int)
)	O
)	O
{	O
what	*(char)
=	O
_	O
(	O
"failed to drop group privileges"	*(char)
)	O
;	O
goto	O
fail	O
;	O
}	O
}	O
if	O
(	O
uid	int
!=	O
orig_euid	int
)	O
{	O
if	O
(	O
0	int
==	O
uid	int
)	O
{	O
}	O
else	O
{	O
errno	O
=	O
0	int
;	O
if	O
(	O
0	int
!=	O
setuid	(int)->(int)
(	O
getuid	()->(int)
(	O
)	O
)	O
)	O
{	O
what	*(char)
=	O
_	O
(	O
"failed to drop setuid privileges"	*(char)
)	O
;	O
goto	O
fail	O
;	O
}	O
else	O
{	O
if	O
(	O
0	int
==	O
setuid	(int)->(int)
(	O
0	int
)	O
)	O
{	O
what	*(char)
=	O
_	O
(	O
"Failed to fully drop privileges"	*(char)
)	O
;	O
errno	O
=	O
0	int
;	O
goto	O
fail	O
;	O
}	O
}	O
}	O
}	O
errno	O
=	O
0	int
;	O
if	O
(	O
0	int
!=	O
setgid	(int)->(int)
(	O
gid	int
)	O
)	O
{	O
what	*(char)
=	O
_	O
(	O
"failed to drop setgid privileges"	*(char)
)	O
;	O
goto	O
fail	O
;	O
}	O
return	O
0	int
;	O
fail	O
:	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
what	*(char)
)	O
)	O
;	O
abort	()->(void)
(	O
)	O
;	O
kill	(int,int)->(int)
(	O
0	int
,	O
SIGKILL	int
)	O
;	O
_exit	(int)->(void)
(	O
1	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
}	O
}	O
static	O
int	O
opendb	(*(char))->(int)
(	O
const	O
char	O
*	O
name	*(char)
)	O
{	O
int	O
fd	int
=	O
open	(*(char),int)->(int)
(	O
name	*(char)
,	O
O_RDONLY	int
|	O
O_LARGEFILE	O
)	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
if	O
(	O
0	int
!=	O
fcntl	(int,int)->(int)
(	O
fd	int
,	O
F_SETFD	int
,	O
FD_CLOEXEC	int
)	O
)	O
{	O
close	*((*(void))->(int))
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
}	O
return	O
fd	int
;	O
}	O
static	O
void	O
cleanup_quote_opts	()->(void)
(	O
void	O
)	O
{	O
free	(*(void))->(void)
(	O
quote_opts	*(struct)
)	O
;	O
}	O
int	O
dolocate	(int,*(*(char)),int)->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
,	O
int	O
secure_db_fd	int
)	O
{	O
char	O
*	O
path_element	*(char)
=	O
NULL	O
;	O
size_t	long
path_element_pos	long
,	O
path_element_len	long
;	O
const	O
char	O
*	O
user_selected_locate_path	*(char)
;	O
const	O
char	O
*	O
db_name	*(char)
;	O
const	O
char	O
*	O
path_separators	*(char)
=	O
":"	*(char)
;	O
unsigned	O
long	O
int	O
found	long
=	O
0uL	int
;	O
int	O
ignore_case	int
=	O
0	int
;	O
int	O
print	int
=	O
0	int
;	O
int	O
just_count	int
=	O
0	int
;	O
int	O
basename_only	int
=	O
0	int
;	O
int	O
use_limit	int
=	O
0	int
;	O
int	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
0	int
;	O
int	O
regex_options	int
=	O
RE_SYNTAX_EMACS	int
;	O
int	O
stats	int
=	O
0	int
;	O
int	O
op_and	int
=	O
0	int
;	O
FILE	struct
*	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
;	O
bool	bool
did_stdin	bool
=	O
false	int
;	O
if	O
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
set_program_name	(*(char))->(void)
(	O
argv	*(*(char))
[	O
0	int
]	O
)	O
;	O
else	O
set_program_name	(*(char))->(void)
(	O
"locate"	*(char)
)	O
;	O
setlocale	(int,*(char))->(*(char))
(	O
LC_ALL	O
,	O
""	*(char)
)	O
;	O
bindtextdomain	(*(char),*(char))->(*(char))
(	O
PACKAGE	*(char)
,	O
LOCALEDIR	O
)	O
;	O
textdomain	(*(char))->(*(char))
(	O
PACKAGE	*(char)
)	O
;	O
quote_opts	*(struct)
=	O
clone_quoting_options	(*(struct))->(*(struct))
(	O
NULL	O
)	O
;	O
if	O
(	O
atexit	(*(()->(void)))->(int)
(	O
close_stdout	()->(void)
)	O
||	O
atexit	(*(()->(void)))->(int)
(	O
cleanup_quote_opts	()->(void)
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"The atexit library function failed"	*(char)
)	O
)	O
;	O
}	O
limits	struct(long,long)
.	O
limit	long
=	O
0	int
;	O
limits	struct(long,long)
.	O
items_accepted	long
=	O
0	int
;	O
print_quoted_filename	bool
=	O
true	int
;	O
user_selected_locate_path	*(char)
=	O
getenv	(*(char))->(*(char))
(	O
"LOCATE_PATH"	*(char)
)	O
;	O
check_existence	enum(int,int,int)
=	O
ACCEPT_EITHER	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
opti	int
=	O
-	O
1	int
;	O
int	O
optc	int
=	O
getopt_long	(int,*(*(char)),*(char),*(struct(*(char),int,*(int),int)),*(int))->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
"Abcd:eEil:prsm0SwHPL"	*(char)
,	O
longopts	array(struct(*(char),int,*(int),int))
,	O
&	O
opti	int
)	O
;	O
if	O
(	O
optc	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'0'	O
:	O
separator	int
=	O
0	int
;	O
print_quoted_filename	bool
=	O
false	int
;	O
break	O
;	O
case	O
'A'	O
:	O
op_and	int
=	O
1	int
;	O
break	O
;	O
case	O
'b'	O
:	O
basename_only	int
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
just_count	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
user_selected_locate_path	*(char)
=	O
optarg	*(char)
;	O
assert	O
(	O
optarg	*(char)
!=	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
check_existence	enum(int,int,int)
=	O
ACCEPT_EXISTING	int
;	O
break	O
;	O
case	O
'E'	O
:	O
check_existence	enum(int,int,int)
=	O
ACCEPT_NON_EXISTING	int
;	O
break	O
;	O
case	O
'i'	O
:	O
ignore_case	int
=	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stdout	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
0	int
;	O
case	O
MAX_DB_AGE	int
:	O
set_max_db_age	(*(char))->(void)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
print	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
display_findutils_version	(*(char))->(void)
(	O
"locate"	*(char)
)	O
;	O
return	O
0	int
;	O
case	O
'w'	O
:	O
basename_only	int
=	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
=	O
1	int
;	O
break	O
;	O
case	O
REGEXTYPE_OPTION	int
:	O
regex_options	int
=	O
get_regex_type	(*(char))->(int)
(	O
optarg	*(char)
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
stats	int
=	O
1	int
;	O
break	O
;	O
case	O
'L'	O
:	O
follow_symlinks	int
=	O
1	int
;	O
break	O
;	O
case	O
'P'	O
:	O
case	O
'H'	O
:	O
follow_symlinks	int
=	O
0	int
;	O
break	O
;	O
case	O
'l'	O
:	O
{	O
char	O
*	O
end	*(int)
=	O
optarg	*(char)
;	O
strtol_error	enum(int,int,int,int,int)
err	long
=	O
xstrtoumax	(*(char),*(*(char)),int,*(long),*(char))->(enum(int,int,int,int,int))
(	O
optarg	*(char)
,	O
&	O
end	*(int)
,	O
10	int
,	O
&	O
limits	struct(long,long)
.	O
limit	long
,	O
NULL	O
)	O
;	O
if	O
(	O
LONGINT_OK	int
!=	O
err	long
)	O
xstrtol_fatal	(enum(int,int,int,int,int),int,char,*(struct(*(char),int,*(int),int)),*(char))->(void)
(	O
err	long
,	O
opti	int
,	O
optc	int
,	O
longopts	array(struct(*(char),int,*(int),int))
,	O
optarg	*(char)
)	O
;	O
use_limit	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
's'	O
:	O
case	O
'm'	O
:	O
break	O
;	O
default	O
:	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
user_selected_locate_path	*(char)
)	O
{	O
if	O
(	O
secure_db_fd	int
>=	O
0	int
)	O
{	O
close	*((*(void))->(int))
(	O
secure_db_fd	int
)	O
;	O
secure_db_fd	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
just_count	int
&&	O
!	O
stats	int
)	O
print	int
=	O
1	int
;	O
if	O
(	O
stats	int
)	O
{	O
if	O
(	O
optind	int
==	O
argc	int
)	O
use_limit	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
just_count	int
&&	O
optind	int
==	O
argc	int
)	O
{	O
usage	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(void)
(	O
stderr	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
1	int
==	O
isatty	(int)->(int)
(	O
STDOUT_FILENO	int
)	O
)	O
stdout_is_a_tty	bool
=	O
true	int
;	O
else	O
stdout_is_a_tty	bool
=	O
false	int
;	O
if	O
(	O
user_selected_locate_path	*(char)
)	O
{	O
splitstring	(*(char),*(char),bool,*(long),*(long))->(bool)
(	O
user_selected_locate_path	*(char)
,	O
path_separators	*(char)
,	O
true	int
,	O
&	O
path_element_pos	long
,	O
&	O
path_element_len	long
)	O
;	O
}	O
while	O
(	O
!	O
use_limit	int
||	O
limits	struct(long,long)
.	O
limit	long
>	O
limits	struct(long,long)
.	O
items_accepted	long
)	O
{	O
struct	O
stat	struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
;	O
struct	O
timespec	struct(long,long)
database_mtime	*(struct(long,long))
;	O
int	O
have_mtime	int
;	O
int	O
fd	int
;	O
off_t	long
filesize	long
;	O
statistics	struct(long,long,long,long,long,long)
.	O
compressed_bytes	long
=	O
statistics	struct(long,long,long,long,long,long)
.	O
total_filename_count	long
=	O
statistics	struct(long,long,long,long,long,long)
.	O
total_filename_length	long
=	O
statistics	struct(long,long,long,long,long,long)
.	O
whitespace_count	long
=	O
statistics	struct(long,long,long,long,long,long)
.	O
newline_count	long
=	O
statistics	struct(long,long,long,long,long,long)
.	O
highbit_filename_count	long
=	O
0u	int
;	O
if	O
(	O
user_selected_locate_path	*(char)
)	O
{	O
if	O
(	O
1	int
==	O
path_element_len	long
&&	O
'-'	O
==	O
user_selected_locate_path	*(char)
[	O
path_element_pos	long
]	O
)	O
{	O
if	O
(	O
did_stdin	bool
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: the locate database can only be read from stdin once."	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
db_name	*(char)
=	O
"<stdin>"	*(char)
;	O
fd	int
=	O
0	int
;	O
did_stdin	bool
=	O
true	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
0	int
==	O
path_element_len	long
||	O
(	O
1	int
==	O
path_element_len	long
&&	O
'.'	O
==	O
user_selected_locate_path	*(char)
[	O
path_element_pos	long
]	O
)	O
)	O
{	O
db_name	*(char)
=	O
LOCATE_DB	O
;	O
}	O
else	O
{	O
path_element	*(char)
=	O
strndup	(*(char),long)->(*(char))
(	O
&	O
user_selected_locate_path	*(char)
[	O
path_element_pos	long
]	O
,	O
path_element_len	long
)	O
;	O
db_name	*(char)
=	O
path_element	*(char)
;	O
}	O
fd	int
=	O
opendb	(*(char))->(int)
(	O
db_name	*(char)
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
db_name	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
-	O
1	int
==	O
secure_db_fd	int
)	O
{	O
break	O
;	O
}	O
else	O
{	O
db_name	*(char)
=	O
selected_secure_db	*(char)
;	O
fd	int
=	O
secure_db_fd	int
;	O
secure_db_fd	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
fstat	(int,*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(int)
(	O
fd	int
,	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
db_name	*(char)
)	O
)	O
;	O
filesize	long
=	O
(	O
off_t	long
)	O
0	int
;	O
have_mtime	int
=	O
0	int
;	O
}	O
else	O
{	O
time_t	long
now	long
;	O
filesize	long
=	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
.	O
st_size	long
;	O
database_mtime	*(struct(long,long))
=	O
get_stat_mtime	(*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long))))->(struct(long,long))
(	O
&	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
)	O
;	O
have_mtime	int
=	O
1	int
;	O
if	O
(	O
(	O
time_t	long
)	O
-	O
1	int
==	O
time	struct(long,long)
(	O
&	O
now	long
)	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"time system call failed"	*(char)
)	O
)	O
;	O
}	O
else	O
{	O
double	O
age	double
=	O
difftime	(long,long)->(double)
(	O
now	long
,	O
st	*(struct(long,long,long,int,int,int,int,long,long,long,long,struct(long,long),struct(long,long),struct(long,long),array(long)))
.	O
st_mtime	O
)	O
;	O
double	O
warn_seconds	double
=	O
SECONDS_PER_UNIT	O
*	O
warn_number_units	int
;	O
if	O
(	O
age	double
>	O
warn_seconds	double
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: database %s is more than %d %s old (actual age is %.1f %s)"	*(char)
)	O
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
db_name	*(char)
)	O
,	O
warn_number_units	int
,	O
_	O
(	O
warn_name_units	array(char)
)	O
,	O
(	O
age	double
/	O
(	O
double	O
)	O
SECONDS_PER_UNIT	O
)	O
,	O
_	O
(	O
warn_name_units	array(char)
)	O
)	O
;	O
}	O
}	O
}	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
=	O
fdopen	(int,*(char))->(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))
(	O
fd	int
,	O
"r"	*(char)
)	O
;	O
if	O
(	O
NULL	O
==	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
db_name	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
found	long
=	O
search_one_database	(int,*(*(char)),*(char),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))),long,*(struct(long,long)),int,int,int,int,*(struct(long,long)),int,int,int,int)->(long)
(	O
argc	int
-	O
optind	int
,	O
&	O
argv	*(*(char))
[	O
optind	int
]	O
,	O
db_name	*(char)
,	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
,	O
filesize	long
,	O
have_mtime	int
?	O
(	O
&	O
database_mtime	*(struct(long,long))
)	O
:	O
NULL	O
,	O
ignore_case	int
,	O
print	int
,	O
basename_only	int
,	O
use_limit	int
,	O
&	O
limits	struct(long,long)
,	O
stats	int
,	O
op_and	int
,	O
regex	struct(*(struct),long,long,long,*(char),*(char),long,int,int,int,int,int,int,int)
,	O
regex_options	int
)	O
;	O
if	O
(	O
fclose	(*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,*`,int,int,long,short,char,array(char),*`,long,*`,*`,*`,*`,long,int,array(char))),*(void),long,int,array(char))))->(int)
(	O
fp	*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),int,int,long,short,char,array(char),*(void),long,*(struct),*(struct),*(struct(int,*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(char),*(struct`),*(struct`),int,int,long,short,char,array(char),*(void),long,*(struct`),*(struct`),*(struct`),*(void),long,int,array(char))),*(void),long,int,array(char)))
)	O
==	O
EOF	O
)	O
{	O
error	(int,int,*(char))->(void)
(	O
0	int
,	O
errno	O
,	O
"%s"	*(char)
,	O
quotearg_n_style	(int,enum(int,int,int,int,int,int,int,int,int,int,int),*(char))->(*(char))
(	O
0	int
,	O
locale_quoting_style	int
,	O
db_name	*(char)
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
path_element	*(char)
)	O
{	O
free	(*(void))->(void)
(	O
path_element	*(char)
)	O
;	O
path_element	*(char)
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
user_selected_locate_path	*(char)
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
splitstring	(*(char),*(char),bool,*(long),*(long))->(bool)
(	O
user_selected_locate_path	*(char)
,	O
path_separators	*(char)
,	O
false	int
,	O
&	O
path_element_pos	long
,	O
&	O
path_element_len	long
)	O
)	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
just_count	int
)	O
{	O
printf	(*(char))->(int)
(	O
"%ld\n"	*(char)
,	O
found	long
)	O
;	O
}	O
if	O
(	O
found	long
||	O
(	O
use_limit	int
&&	O
(	O
limits	struct(long,long)
.	O
limit	long
==	O
0	int
)	O
)	O
||	O
stats	int
)	O
return	O
0	int
;	O
else	O
return	O
1	int
;	O
}	O
static	O
int	O
open_secure_db	()->(int)
(	O
void	O
)	O
{	O
int	O
fd	int
,	O
i	int
;	O
const	O
char	O
*	O
secure_db_list	array(*(char))
[	O
]	O
=	O
{	O
LOCATE_DB	O
,	O
"/var/lib/slocate/slocate.db"	*(char)
,	O
NULL	O
}	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
secure_db_list	array(*(char))
[	O
i	int
]	O
;	O
++	O
i	int
)	O
{	O
fd	int
=	O
opendb	(*(char))->(int)
(	O
secure_db_list	array(*(char))
[	O
i	int
]	O
)	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
selected_secure_db	*(char)
=	O
secure_db_list	array(*(char))
[	O
i	int
]	O
;	O
return	O
fd	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
main	(int,*(*(char)))->(int)
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	*(*(char))
)	O
{	O
int	O
dbfd	int
=	O
open_secure_db	()->(int)
(	O
)	O
;	O
drop_privs	()->(int)
(	O
)	O
;	O
return	O
dolocate	(int,*(*(char)),int)->(int)
(	O
argc	int
,	O
argv	*(*(char))
,	O
dbfd	int
)	O
;	O
}	O
